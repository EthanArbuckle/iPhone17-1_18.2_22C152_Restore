void sub_100B78EE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  void v9[7];
  void *aBlock;
  dispatch_object_t v11[2];
  long long v12;

  v9[6] = a5;
  aBlock = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_100B7E9F4;
  v9[3] = &unk_101A40450;
  v9[4] = a2;
  v9[5] = a4;
  aBlock = _Block_copy(v9);
  v6 = *(std::__shared_weak_count **)(a2 + 8);
  if (v6)
  {
    v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      v8 = v7;
      sub_1001644F8(v11, &aBlock, *(dispatch_object_t *)(a2 + 16));
      sub_100164540(&v12, v11);
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B79120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20)
{
  if (a2)
  {
    sub_100163BC8(v21 - 80);
    uint64_t v23 = *(void *)(v21 - 88);
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    std::__shared_weak_count::__release_weak(v20);
    sub_100161C9C((uint64_t)&a19);
    sub_10016578C((uint64_t)&a17);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B791D8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 112);
  *(unsigned char *)(v1 + 3) = 1;
  *(unsigned char *)(v1 + 1) = 0;
  return result;
}

uint64_t sub_100B791EC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 112);
  *(unsigned char *)(v1 + 1) = 1;
  *(unsigned char *)(v1 + 3) = 0;
  return result;
}

uint64_t sub_100B79200(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 112) + 1) = 1;
  return result;
}

uint64_t sub_100B79210(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(result + 112) + 2) = a2;
  return result;
}

uint64_t sub_100B7921C(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 112) + 36) = 1;
  return result;
}

void sub_100B7922C(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 112) + 36) = 0;
  if (*(unsigned char *)(a1 + 129))
  {
    sub_100B7C034(a1);
    *(unsigned char *)(a1 + 129) = 0;
  }
}

void sub_100B79264(uint64_t a1, char a2)
{
  if (*(unsigned char *)(*(void *)(a1 + 112) + 32)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = (a2 & 1) == *(unsigned char *)(*(void *)(a1 + 112) + 32);
  }
  if (!v2) {
    sub_100B7C034(a1);
  }
}

uint64_t sub_100B79284@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t result = sub_100B7A958(a1, a2);
  uint64_t v7 = *(void *)(v3 + 16);
  uint64_t v6 = v3 + 16;
  uint64_t v5 = v7;
  if (!v7) {
    goto LABEL_11;
  }
  uint64_t v8 = v6;
  do
  {
    int v9 = *(_DWORD *)(v5 + 28);
    BOOL v10 = v9 < (int)result;
    if (v9 >= (int)result) {
      v11 = (uint64_t *)v5;
    }
    else {
      v11 = (uint64_t *)(v5 + 8);
    }
    if (!v10) {
      uint64_t v8 = v5;
    }
    uint64_t v5 = *v11;
  }
  while (*v11);
  if (v8 == v6 || (int)result < *(_DWORD *)(v8 + 28)) {
LABEL_11:
  }
    uint64_t v8 = v6;
  if (v8 != *(void *)(a1 + 112) + 16 && *(unsigned char *)(v8 + 32))
  {
    v12 = *(uint64_t (**)(void))(**(void **)(a1 + 96) + 56);
    return v12();
  }
  return result;
}

void sub_100B7934C(uint64_t a1)
{
  sub_100B7C750(a1);

  sub_100B7CEC8(a1, v2);
}

void *sub_100B79384(void *result, void *a2)
{
  if (result[33] == a2[2])
  {
    BOOL v2 = (void *)result[31];
    if (v2 == result + 32) {
      return result;
    }
    uint64_t v3 = (void *)*a2;
    while (*((_DWORD *)v2 + 8) == *((_DWORD *)v3 + 8) && v2[7] == v3[7])
    {
      v4 = (void *)v2[5];
      if (v4 != v2 + 6)
      {
        uint64_t v5 = (void *)v3[5];
        while (*((_DWORD *)v4 + 8) == *((_DWORD *)v5 + 8) && v4[7] == v5[7])
        {
          uint64_t v6 = (void *)v4[5];
          if (v6 != v4 + 6)
          {
            uint64_t v7 = (void *)v5[5];
            do
            {
              BOOL v8 = *((_DWORD *)v6 + 7) == *((_DWORD *)v7 + 7)
                && *((unsigned __int8 *)v6 + 32) == *((unsigned __int8 *)v7 + 32);
              if (!v8) {
                goto LABEL_51;
              }
              int v9 = (void *)v6[1];
              BOOL v10 = v6;
              if (v9)
              {
                do
                {
                  uint64_t v6 = v9;
                  int v9 = (void *)*v9;
                }
                while (v9);
              }
              else
              {
                do
                {
                  uint64_t v6 = (void *)v10[2];
                  BOOL v8 = *v6 == (void)v10;
                  BOOL v10 = v6;
                }
                while (!v8);
              }
              v11 = (void *)v7[1];
              if (v11)
              {
                do
                {
                  v12 = v11;
                  v11 = (void *)*v11;
                }
                while (v11);
              }
              else
              {
                do
                {
                  v12 = (void *)v7[2];
                  BOOL v8 = *v12 == (void)v7;
                  uint64_t v7 = v12;
                }
                while (!v8);
              }
              uint64_t v7 = v12;
            }
            while (v6 != v4 + 6);
          }
          v13 = (void *)v4[1];
          if (v13)
          {
            do
            {
              v14 = v13;
              v13 = (void *)*v13;
            }
            while (v13);
          }
          else
          {
            do
            {
              v14 = (void *)v4[2];
              BOOL v8 = *v14 == (void)v4;
              v4 = v14;
            }
            while (!v8);
          }
          v15 = (void *)v5[1];
          if (v15)
          {
            do
            {
              v16 = v15;
              v15 = (void *)*v15;
            }
            while (v15);
          }
          else
          {
            do
            {
              v16 = (void *)v5[2];
              BOOL v8 = *v16 == (void)v5;
              uint64_t v5 = v16;
            }
            while (!v8);
          }
          uint64_t v5 = v16;
          v4 = v14;
          if (v14 == v2 + 6) {
            goto LABEL_39;
          }
        }
        break;
      }
LABEL_39:
      v17 = (void *)v2[1];
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          v18 = (void *)v2[2];
          BOOL v8 = *v18 == (void)v2;
          BOOL v2 = v18;
        }
        while (!v8);
      }
      v19 = (void *)v3[1];
      if (v19)
      {
        do
        {
          v20 = v19;
          v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = (void *)v3[2];
          BOOL v8 = *v20 == (void)v3;
          uint64_t v3 = v20;
        }
        while (!v8);
      }
      uint64_t v3 = v20;
      BOOL v2 = v18;
      if (v18 == result + 32) {
        return result;
      }
    }
  }
LABEL_51:
  uint64_t v21 = result[12];
  if (v21) {
    return (void *)(*(uint64_t (**)(void))(*(void *)v21 + 64))(result[12]);
  }
  return result;
}

uint64_t sub_100B795A0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 96);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

void sub_100B795D0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 32) + 16);
  if (!v1 || (BOOL v2 = std::__shared_weak_count::lock(v1)) == 0) {
    sub_100088B9C();
  }
  uint64_t v3 = v2;
  p_shared_weak_owners = &v2->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v2);
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  sub_10017B514();
  std::__shared_weak_count::__release_weak(v3);
  std::__shared_weak_count::__release_weak(v3);
}

void sub_100B796A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  std::__shared_weak_count::__release_weak(v16);
  _Unwind_Resume(a1);
}

void sub_100B796C8(uint64_t a1)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_100B79808;
  v9[3] = &unk_101A40130;
  long long v1 = *(_OWORD *)(a1 + 32);
  long long v10 = v1;
  uint64_t v2 = v1;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  v11 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v4 || (uint64_t v5 = *(void *)(v1 + 8), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  BOOL v8 = *(NSObject **)(v2 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100B80614;
  block[3] = &unk_101A408A8;
  block[5] = v5;
  v13 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v8, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v7);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_100B79808(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        v8[0] = 0;
        v8[1] = 524562;
        if (sub_10017B48C()) {
          operator new();
        }
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Metric is not collectable", v7, 2u);
        }
        sub_100B81470(v8);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100B79B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100B81470((uint64_t *)va);
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

uint64_t sub_100B79BC0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B79BDC(uint64_t a1)
{
  long long v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100B79BEC(uint64_t a1)
{
  *(void *)a1 = off_101A40000;
  *(void *)(a1 + 48) = off_101A400C0;
  sub_100B7E174(a1 + 248, *(void **)(a1 + 256));
  sub_100087F94(a1 + 224, *(void **)(a1 + 232));
  sub_100119D90(*(void **)(a1 + 200));
  sub_1000DA2E4(*(char **)(a1 + 168));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 144);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    sub_10004D2C8(v3);
  }
  v4 = *(std::__shared_weak_count **)(a1 + 104);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_100160A84((atomic_uint **)(a1 + 56));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100B79CC4(uint64_t a1)
{
  return sub_100B79BEC(a1 - 48);
}

void sub_100B79CCC(uint64_t a1)
{
  sub_100B79BEC(a1);

  operator delete();
}

void sub_100B79D04(uint64_t a1)
{
  sub_100B79BEC(a1 - 48);

  operator delete();
}

void sub_100B79D40(void *a1, char a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  uint64_t v8[2] = sub_100B79E5C;
  v8[3] = &unk_101A401B0;
  v8[4] = a1;
  char v9 = a2;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (v4 = a1[1], (uint64_t v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100B80614;
  block[3] = &unk_101A408A8;
  block[5] = v4;
  v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v6);
}

void sub_100B79E5C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(a1 + 40))
  {
    Registry::getTimerService((uint64_t *)&__p, *(Registry **)(v1 + 80));
    *(void *)(v1 + 184) = (**(uint64_t (***)(void *))__p)(__p);
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
  else
  {
    sub_100058DB0(&__p, "TotalAssertionTime");
    sub_100B79F34(v1, (char *)&__p, (void *)(v1 + 184));
    if (v4 < 0) {
      operator delete(__p);
    }
  }
}

void sub_100B79F04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B79F34(uint64_t a1, char *a2, void *a3)
{
  uint64_t v7 = (uint64_t **)(a1 + 168);
  uint64_t v6 = *(uint64_t **)(a1 + 168);
  if (!v6)
  {
    BOOL v8 = (uint64_t **)(a1 + 168);
LABEL_9:
    long long v10 = (uint64_t *)operator new(0x60uLL);
    v11 = v10 + 4;
    if (a2[23] < 0)
    {
      sub_10004FC84(v11, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      *(_OWORD *)v11 = *(_OWORD *)a2;
      v10[6] = *((void *)a2 + 2);
    }
    *((_DWORD *)v10 + 22) = 0;
    *(_OWORD *)(v10 + 9) = 0u;
    *(_OWORD *)(v10 + 7) = 0u;
    *long long v10 = 0;
    v10[1] = 0;
    v10[2] = (uint64_t)v8;
    *uint64_t v7 = v10;
    uint64_t v12 = **(void **)(a1 + 160);
    v13 = v10;
    if (v12)
    {
      *(void *)(a1 + 160) = v12;
      v13 = *v7;
    }
    sub_100046C90(*(uint64_t **)(a1 + 168), v13);
    ++*(void *)(a1 + 176);
    goto LABEL_15;
  }
  while (1)
  {
    while (1)
    {
      BOOL v8 = (uint64_t **)v6;
      char v9 = v6 + 4;
      if ((sub_100046FE8(a2, (void **)v6 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v6 = *v8;
      uint64_t v7 = v8;
      if (!*v8) {
        goto LABEL_9;
      }
    }
    if ((sub_100046FE8(v9, (void **)a2) & 0x80) == 0) {
      break;
    }
    uint64_t v7 = v8 + 1;
    uint64_t v6 = v8[1];
    if (!v6) {
      goto LABEL_9;
    }
  }
  long long v10 = *v7;
  if (!*v7) {
    goto LABEL_9;
  }
LABEL_15:
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 80));
  uint64_t v14 = (***(uint64_t (****)(void))buf)(*(void *)buf);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v15 = v14 - *a3;
  v16 = v10 + 7;
  if ((unint64_t)(v15 + 999999999) >= 0x773593FF)
  {
    if (v15 > 0x165A0BBFFLL)
    {
      unint64_t v17 = v15 / 1000000000;
      if ((unint64_t)(v15 / 1000000000) > 0xA)
      {
        if (v17 > 0x14)
        {
          if (v17 > 0x1E)
          {
            if (v17 > 0x3C)
            {
              if (v17 > 0x78)
              {
                if (v17 > 0xF0) {
                  v16 = v10 + 11;
                }
                else {
                  v16 = (_DWORD *)v10 + 21;
                }
              }
              else
              {
                v16 = v10 + 10;
              }
            }
            else
            {
              v16 = (_DWORD *)v10 + 19;
            }
          }
          else
          {
            v16 = v10 + 9;
          }
        }
        else
        {
          v16 = (_DWORD *)v10 + 17;
        }
      }
      else
      {
        v16 = v10 + 8;
      }
    }
    else
    {
      v16 = (_DWORD *)v10 + 15;
    }
  }
  ++*v16;
  v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] < 0) {
      a2 = *(char **)a2;
    }
    uint64_t v45 = 0;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    *(_OWORD *)__p = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_10004DE24((uint64_t)buf);
    sub_10004B96C(buf, (uint64_t)"0:", 2);
    v19 = (void *)std::ostream::operator<<();
    sub_10004B96C(v19, (uint64_t)" 5:", 3);
    v20 = (void *)std::ostream::operator<<();
    sub_10004B96C(v20, (uint64_t)" 10:", 4);
    uint64_t v21 = (void *)std::ostream::operator<<();
    sub_10004B96C(v21, (uint64_t)" 20:", 4);
    v22 = (void *)std::ostream::operator<<();
    sub_10004B96C(v22, (uint64_t)" 30:", 4);
    uint64_t v23 = (void *)std::ostream::operator<<();
    sub_10004B96C(v23, (uint64_t)" 60:", 4);
    v24 = (void *)std::ostream::operator<<();
    sub_10004B96C(v24, (uint64_t)" 120:", 5);
    v25 = (void *)std::ostream::operator<<();
    sub_10004B96C(v25, (uint64_t)" 240:", 5);
    v26 = (void *)std::ostream::operator<<();
    sub_10004B96C(v26, (uint64_t)" 240p:", 6);
    std::ostream::operator<<();
    sub_10004BC98((uint64_t)&buf[8], v28);
    if (SHIBYTE(v34) < 0) {
      operator delete(__p[1]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    v27 = v28;
    if (v29 < 0) {
      v27 = (void **)v28[0];
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&buf[4] = a2;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v27;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I SSS: %s: %s", buf, 0x16u);
    if (v29 < 0) {
      operator delete(v28[0]);
    }
  }
}

void sub_100B7A410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14)
{
  operator delete(v14);
  _Unwind_Resume(a1);
}

void sub_100B7A450(void *a1, long long *a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  v10[2] = sub_100B7A5AC;
  v10[3] = &unk_101A401D0;
  v10[4] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v12 = *((void *)a2 + 2);
  }
  uint64_t v13 = a3;
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  BOOL v8 = v7;
  char v9 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100B80614;
  block[3] = &unk_101A408A8;
  block[5] = v6;
  uint64_t v15 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v9, block);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10004D2C8(v8);
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
}

void sub_100B7A5AC(uint64_t a1)
{
}

void sub_100B7A5C0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B7A6B0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6 = (Registry **)(a1 + 80);
  if ((subscriber::isValidSimSlot() & 1) == 0) {
    a2 = sub_100B7A958(a1, (uint64_t *)v7);
  }
  char v9 = (uint64_t **)(a1 + 200);
  uint64_t v8 = *(void *)(a1 + 200);
  if (!v8) {
    goto LABEL_13;
  }
  uint64_t v7 = a1 + 200;
  do
  {
    int v10 = *(_DWORD *)(v8 + 32);
    BOOL v11 = v10 < (int)a2;
    if (v10 >= (int)a2) {
      uint64_t v12 = (uint64_t *)v8;
    }
    else {
      uint64_t v12 = (uint64_t *)(v8 + 8);
    }
    if (!v11) {
      uint64_t v7 = v8;
    }
    uint64_t v8 = *v12;
  }
  while (*v12);
  if ((uint64_t **)v7 == v9 || (int)a2 < *(_DWORD *)(v7 + 32))
  {
LABEL_13:
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v7, *v6);
    uint64_t v14 = ServiceMap;
    if ((v15 & 0x8000000000000000) != 0)
    {
      v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        unint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v34 = v15;
    v19 = sub_10004D37C(&v14[1].__m_.__sig, &v34);
    if (v19)
    {
      uint64_t v21 = v19[3];
      v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        if (!v21) {
          goto LABEL_40;
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    v20 = 0;
    char v22 = 1;
    if (!v21)
    {
LABEL_40:
      if ((v22 & 1) == 0) {
        sub_10004D2C8(v20);
      }
      if (!v21)
      {
        *a3 = 0;
        a3[1] = 0;
      }
      return;
    }
LABEL_22:
    *a3 = 0;
    a3[1] = 0;
    (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 632))(v21, a2);
    uint64_t v23 = *a3;
    if (*a3)
    {
      v24 = *v9;
      v25 = (uint64_t **)(a1 + 200);
      if (*v9)
      {
        do
        {
          while (1)
          {
            v25 = (uint64_t **)v24;
            int v26 = *((_DWORD *)v24 + 8);
            if (v26 <= (int)a2) {
              break;
            }
            v24 = *v25;
            char v9 = v25;
            if (!*v25) {
              goto LABEL_31;
            }
          }
          if (v26 >= (int)a2)
          {
            long long v31 = v25;
            goto LABEL_36;
          }
          v24 = v25[1];
        }
        while (v24);
        char v9 = v25 + 1;
      }
LABEL_31:
      long long v31 = operator new(0x38uLL);
      *((_DWORD *)v31 + 8) = a2;
      *((void *)v31 + 5) = 0;
      *((void *)v31 + 6) = 0;
      *(void *)long long v31 = 0;
      *((void *)v31 + 1) = 0;
      *((void *)v31 + 2) = v25;
      *char v9 = (uint64_t *)v31;
      uint64_t v27 = **(void **)(a1 + 192);
      v28 = (uint64_t *)v31;
      if (v27)
      {
        *(void *)(a1 + 192) = v27;
        v28 = *v9;
      }
      sub_100046C90(*(uint64_t **)(a1 + 200), v28);
      ++*(void *)(a1 + 208);
      uint64_t v23 = *a3;
LABEL_36:
      uint64_t v32 = a3[1];
      if (v32) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
      }
      v33 = (std::__shared_weak_count *)*((void *)v31 + 6);
      *((void *)v31 + 5) = v23;
      *((void *)v31 + 6) = v32;
      if (v33) {
        sub_10004D2C8(v33);
      }
    }
    goto LABEL_40;
  }
  uint64_t v30 = *(void *)(v7 + 40);
  uint64_t v29 = *(void *)(v7 + 48);
  *a3 = v30;
  a3[1] = v29;
  if (v29) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_100B7A928(_Unwind_Exception *exception_object)
{
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 8);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B7A958@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 80));
  char v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, &v16);
  if (v9)
  {
    uint64_t v10 = v9[3];
    BOOL v11 = (std::__shared_weak_count *)v9[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v12 = 0;
      if (!v10) {
        goto LABEL_7;
      }
LABEL_11:
      char v4 = (std::mutex *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 760))(v10);
      if (v12) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  BOOL v11 = 0;
  char v12 = 1;
  if (v10) {
    goto LABEL_11;
  }
LABEL_7:
  if ((v12 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v11);
LABEL_13:
  if (!v10)
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E DataService not started yet", v15, 2u);
    }
    return 1;
  }
  return (uint64_t)v4;
}

void sub_100B7AABC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B7AAD8(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
}

void sub_100B7AAE0(capabilities::radio *a1, BOOL a2, NSObject **a3)
{
  if (!capabilities::radio::getPacketFilteringVersion(a1)) {
    return;
  }
  if (!a2) {
    goto LABEL_31;
  }
  uint64_t v6 = (unsigned char *)*((void *)a1 + 14);
  if (v6[1] || v6[2])
  {
    uint64_t v7 = *((void *)a1 + 5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)group = 136315138;
      *(void *)&group[4] = asStringBool(1);
      unsigned int v8 = "#I %s: filterUnsolicitedPackets: in airplane mode";
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, group, 0xCu);
      return;
    }
    return;
  }
  char v9 = (uint64_t *)v6[3];
  if (!v9)
  {
    uint64_t v7 = *((void *)a1 + 5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)group = 136315138;
      *(void *)&group[4] = asStringBool(1);
      unsigned int v8 = "#I %s: filterUnsolicitedPackets: modem power off";
      goto LABEL_7;
    }
    return;
  }
  int v10 = sub_100B7AE8C((uint64_t)a1, v9);
  uint64_t v11 = *((void *)a1 + 14);
  uint64_t v14 = *(void *)(v11 + 16);
  uint64_t v12 = v11 + 16;
  uint64_t v13 = v14;
  if (v14)
  {
    uint64_t v15 = v12;
    do
    {
      int v16 = *(_DWORD *)(v13 + 28);
      BOOL v17 = v16 < v10;
      if (v16 >= v10) {
        unsigned int v18 = (uint64_t *)v13;
      }
      else {
        unsigned int v18 = (uint64_t *)(v13 + 8);
      }
      if (!v17) {
        uint64_t v15 = v13;
      }
      uint64_t v13 = *v18;
    }
    while (*v18);
    if (v15 != v12 && *(_DWORD *)(v15 + 28) <= v10)
    {
      v19 = (uint64_t *)*(unsigned __int8 *)(v15 + 32);
      if (v19)
      {
        int v20 = sub_100B7AE8C((uint64_t)a1, v19);
        uint64_t v21 = *((void *)a1 + 14);
        uint64_t v24 = *(void *)(v21 + 48);
        uint64_t v22 = v21 + 48;
        uint64_t v23 = v24;
        if (v24)
        {
          uint64_t v25 = v22;
          do
          {
            int v26 = *(_DWORD *)(v23 + 28);
            BOOL v27 = v26 < v20;
            if (v26 >= v20) {
              v28 = (uint64_t *)v23;
            }
            else {
              v28 = (uint64_t *)(v23 + 8);
            }
            if (!v27) {
              uint64_t v25 = v23;
            }
            uint64_t v23 = *v28;
          }
          while (*v28);
          if (v25 != v22 && *(_DWORD *)(v25 + 28) <= v20 && *(int *)(v25 + 32) > 0)
          {
LABEL_31:
            uint64_t v29 = *((void *)a1 + 5);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)group = 136315138;
              *(void *)&group[4] = asStringBool(a2);
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s: filterUnsolicitedPackets: sending unsolicited packets", group, 0xCu);
            }
            uint64_t v30 = *a3;
            if (v30)
            {
              dispatch_retain(v30);
              dispatch_group_enter(v30);
            }
            long long v31 = *((void *)a1 + 5);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)group = 0;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I sendFilterUnsolicitedPackets", group, 2u);
            }
            uint64_t v32 = *((void *)a1 + 12);
            *(void *)group = v30;
            if (v30)
            {
              dispatch_retain(v30);
              dispatch_group_enter(v30);
            }
            (*(void (**)(uint64_t, BOOL, unsigned char *))(*(void *)v32 + 48))(v32, a2, group);
            if (*(void *)group)
            {
              dispatch_group_leave(*(dispatch_group_t *)group);
              if (*(void *)group) {
                dispatch_release(*(dispatch_object_t *)group);
              }
            }
            if (v30)
            {
              dispatch_group_leave(v30);
              dispatch_release(v30);
            }
            return;
          }
        }
      }
    }
  }
  uint64_t v7 = *((void *)a1 + 5);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)group = 136315138;
    *(void *)&group[4] = asStringBool(1);
    unsigned int v8 = "#I %s: filterUnsolicitedPackets: no data";
    goto LABEL_7;
  }
}

void sub_100B7AE00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  if (v9)
  {
    dispatch_group_leave(v9);
    dispatch_release(v9);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B7AE38(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v2 = a1 + 16;
  uint64_t v3 = v4;
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v2;
  do
  {
    int v6 = *(_DWORD *)(v3 + 28);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      unsigned int v8 = (uint64_t *)v3;
    }
    else {
      unsigned int v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  return v5 != v2 && *(_DWORD *)(v5 + 28) <= a2 && *(unsigned char *)(v5 + 32) != 0;
}

uint64_t sub_100B7AE8C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 80));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, &v16);
  if (v9)
  {
    uint64_t v10 = v9[3];
    uint64_t v11 = (std::__shared_weak_count *)v9[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v12 = 0;
      if (!v10) {
        goto LABEL_7;
      }
LABEL_11:
      uint64_t v4 = (std::mutex *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 776))(v10);
      if (v12) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v11 = 0;
  char v12 = 1;
  if (v10) {
    goto LABEL_11;
  }
LABEL_7:
  if ((v12 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v11);
LABEL_13:
  if (!v10)
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E DataService not started yet", v15, 2u);
    }
    return 1;
  }
  return (uint64_t)v4;
}

void sub_100B7AFF0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B7B00C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t dormancy::DormancyController::Rel8_FD_ScreenOn_Mode(capabilities::ct *a1)
{
  uint64_t v2 = capabilities::ct::dormancyWatchMode(a1);
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v11 + 32))(&cf, v11, kOperator1BundleId, @"AllowScreenOnFastDormancy", 0, 0);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (cf) {
    uint64_t v13 = sub_100080934;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13)
  {
    CFTypeID v14 = CFGetTypeID(cf);
    if (v14 == CFNumberGetTypeID())
    {
      unsigned int valuePtr = 0;
      if (CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, &valuePtr))
      {
        uint64_t v15 = valuePtr;
        if (valuePtr < 3)
        {
LABEL_21:
          uint64_t v2 = v15;
          goto LABEL_26;
        }
        sub_100B7B3D0();
        unint64_t v16 = qword_101B10198;
        if (os_log_type_enabled((os_log_t)qword_101B10198, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = valuePtr;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I unexpected value %d in carrier-bundle key AllowScreenOnFastDormancy. Ignored with default behavior", buf, 8u);
        }
      }
      uint64_t v15 = v2;
      goto LABEL_21;
    }
    CFTypeID v17 = CFGetTypeID(cf);
    if (v17 == CFBooleanGetTypeID())
    {
      uint64_t v2 = CFBooleanGetValue((CFBooleanRef)cf) == 1;
    }
    else
    {
      sub_100B7B3D0();
      unsigned int v18 = qword_101B10198;
      if (os_log_type_enabled((os_log_t)qword_101B10198, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I AllowScreenOnFastDormancy is of unsupported type", buf, 2u);
      }
    }
  }
LABEL_26:
  sub_1000577C4(&cf);
  return v2;
}

void sub_100B7B38C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100B7B3D0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B101A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B101A0))
  {
    LogGroupName = (const char *)sGetLogGroupName();
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B10198, kCtLoggingSystemName, LogGroupName);
    __cxa_guard_release(&qword_101B101A0);
  }
}

void sub_100B7B454(_Unwind_Exception *a1)
{
}

void sub_100B7B46C(void *a1, int a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I forceDormancyAfterDelay", buf, 2u);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (!v5 || (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  unsigned int v8 = v7;
  p_shared_weak_owners = &v7->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v7);
  dispatch_time_t v10 = dispatch_time(0, 1000000 * a2);
  uint64_t v11 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100B7B594;
  block[3] = &unk_101A40200;
  block[4] = a1;
  block[5] = v6;
  uint64_t v13 = v8;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  dispatch_after(v10, v11, block);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  std::__shared_weak_count::__release_weak(v8);
}

void sub_100B7B594(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5]) {
        sub_100B7B638(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100B7B624(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100B7B638(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 128))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(buf) = 0;
    uint64_t v5 = "#I Dormancy not allowed, squelching the dormancy request";
    goto LABEL_10;
  }
  uint64_t v2 = *(void *)(a1 + 112);
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int buf = 136315138;
    *(void *)buf_4 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I prepareDormancyRequest: model state: %s", (uint8_t *)&buf, 0xCu);
  }
  if (*(unsigned char *)(v2 + 1) || *(unsigned char *)(v2 + 2))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(buf) = 0;
    uint64_t v5 = "#I prepareDormancyRequest: in airplane mode";
LABEL_10:
    uint64_t v6 = v4;
    uint32_t v7 = 2;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&buf, v7);
    return;
  }
  if (*(unsigned char *)(v2 + 3))
  {
    if (*(unsigned char *)(v2 + 36))
    {
      unsigned int v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I prepareDormancyRequest: in voice call", (uint8_t *)&buf, 2u);
      }
      *(unsigned char *)(a1 + 129) = 1;
      return;
    }
    unsigned int v10 = *(unsigned __int8 *)(v2 + 88);
    uint64_t v11 = (uint64_t *)((1 << v10) & 0x15);
    if (v10 > 4 || v11 == 0)
    {
      v66 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v67 = asString();
        int buf = 136315138;
        *(void *)buf_4 = v67;
        uint64_t v5 = "#I prepareDormancyRequest: Baseband not in Active state: %s";
        uint64_t v6 = v66;
        uint32_t v7 = 12;
        goto LABEL_11;
      }
    }
    else
    {
      int v13 = sub_100B7A958(a1, v11);
      uint64_t v14 = *(void *)(a1 + 112);
      uint64_t v17 = *(void *)(v14 + 16);
      uint64_t v15 = v14 + 16;
      uint64_t v16 = v17;
      if (v17)
      {
        uint64_t v18 = v15;
        do
        {
          int v19 = *(_DWORD *)(v16 + 28);
          BOOL v20 = v19 < v13;
          if (v19 >= v13) {
            uint64_t v21 = (uint64_t *)v16;
          }
          else {
            uint64_t v21 = (uint64_t *)(v16 + 8);
          }
          if (!v20) {
            uint64_t v18 = v16;
          }
          uint64_t v16 = *v21;
        }
        while (*v21);
        if (v18 != v15 && *(_DWORD *)(v18 + 28) <= v13)
        {
          uint64_t v22 = (uint64_t *)*(unsigned __int8 *)(v18 + 32);
          if (v22)
          {
            int v23 = sub_100B7A958(a1, v22);
            uint64_t v24 = *(void *)(a1 + 112);
            uint64_t v27 = *(void *)(v24 + 48);
            uint64_t v25 = v24 + 48;
            uint64_t v26 = v27;
            if (v27)
            {
              uint64_t v28 = v25;
              do
              {
                int v29 = *(_DWORD *)(v26 + 28);
                BOOL v30 = v29 < v23;
                if (v29 >= v23) {
                  long long v31 = (uint64_t *)v26;
                }
                else {
                  long long v31 = (uint64_t *)(v26 + 8);
                }
                if (!v30) {
                  uint64_t v28 = v26;
                }
                uint64_t v26 = *v31;
              }
              while (*v31);
              if (v28 != v25 && *(_DWORD *)(v28 + 28) <= v23 && (*(_DWORD *)(v28 + 36) - 3) <= 2)
              {
                uint64_t v32 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
                {
                  int v34 = sub_100B7A958(a1, v33);
                  BOOL v35 = sub_100B7AE38(*(void *)(a1 + 112), v34);
                  int v37 = sub_100B7A958(a1, v36);
                  uint64_t v38 = *(void *)(*(void *)(a1 + 112) + 48);
                  if (v38)
                  {
                    do
                    {
                      if (*(_DWORD *)(v38 + 28) >= v37) {
                        long long v39 = (uint64_t *)v38;
                      }
                      else {
                        long long v39 = (uint64_t *)(v38 + 8);
                      }
                      uint64_t v38 = *v39;
                    }
                    while (*v39);
                  }
                  uint64_t v40 = asString();
                  int buf = 67109378;
                  *(_DWORD *)buf_4 = v35;
                  *(_WORD *)&buf_4[4] = 2080;
                  *(void *)&buf_4[6] = v40;
                  _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I prepareDormancyRequest: dataAttached: %d, dataMode: %s", (uint8_t *)&buf, 0x12u);
                }
                if (!*(unsigned char *)(v2 + 32)
                  || dormancy::DormancyController::Rel8_FD_ScreenOn_Mode((capabilities::ct *)(a1 + 80)) != 2)
                {
                  goto LABEL_80;
                }
                long long v41 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                {
                  int v43 = *(unsigned __int8 *)(v2 + 32);
                  int v44 = dormancy::DormancyController::Rel8_FD_ScreenOn_Mode((capabilities::ct *)(a1 + 80));
                  int buf = 67109376;
                  *(_DWORD *)buf_4 = v43;
                  *(_WORD *)&buf_4[4] = 1024;
                  *(_DWORD *)&buf_4[6] = v44;
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I prepareDormancyRequest: fDisplayStatus: %d, Rel8_FD_ScreenOn_Mode: %d", (uint8_t *)&buf, 0xEu);
                }
                int v45 = sub_100B7A958(a1, v42);
                uint64_t v48 = *(void *)(v2 + 72);
                uint64_t v47 = v2 + 72;
                uint64_t v46 = v48;
                if (!v48) {
                  goto LABEL_68;
                }
                uint64_t v49 = v47;
                do
                {
                  int v50 = *(_DWORD *)(v46 + 28);
                  BOOL v51 = v50 < v45;
                  if (v50 >= v45) {
                    v52 = (uint64_t *)v46;
                  }
                  else {
                    v52 = (uint64_t *)(v46 + 8);
                  }
                  if (!v51) {
                    uint64_t v49 = v46;
                  }
                  uint64_t v46 = *v52;
                }
                while (*v52);
                if (v49 != v47 && v45 >= *(_DWORD *)(v49 + 28))
                {
                  int v53 = *(_DWORD *)(v49 + 32);
                  if (v53 == 2 || v53 == 9) {
                    goto LABEL_86;
                  }
                }
                else
                {
LABEL_68:
                  int v53 = 11;
                }
                v54 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v55 = asString();
                  int buf = 136315138;
                  *(void *)buf_4 = v55;
                  _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I eScreenOn_FD_IfCapable under %s, don't send Dormancy Request.", (uint8_t *)&buf, 0xCu);
                }
LABEL_86:
                if (v53 != 9 && v53 != 2) {
                  return;
                }
LABEL_80:
                operator new();
              }
            }
          }
        }
      }
      v56 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        int v58 = sub_100B7A958(a1, v57);
        BOOL v59 = sub_100B7AE38(*(void *)(a1 + 112), v58);
        uint64_t v60 = asStringBool(v59);
        int v62 = sub_100B7A958(a1, v61);
        uint64_t v63 = *(void *)(*(void *)(a1 + 112) + 48);
        if (v63)
        {
          do
          {
            if (*(_DWORD *)(v63 + 28) >= v62) {
              v64 = (uint64_t *)v63;
            }
            else {
              v64 = (uint64_t *)(v63 + 8);
            }
            uint64_t v63 = *v64;
          }
          while (*v64);
        }
        uint64_t v65 = asString();
        int buf = 136315394;
        *(void *)buf_4 = v60;
        *(_WORD *)&buf_4[8] = 2080;
        *(void *)&buf_4[10] = v65;
        uint64_t v5 = "#I prepareDormancyRequest: data is not ready or not supported: attached=%s, dataMode=%s";
        uint64_t v6 = v56;
        uint32_t v7 = 22;
        goto LABEL_11;
      }
    }
  }
  else
  {
    char v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I prepareDormancyRequest: modem power off", (uint8_t *)&buf, 2u);
    }
    SendRadioNotReadyEvent();
  }
}

void sub_100B7BCF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group, uint64_t a11, std::__shared_weak_count *a12)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B7BD3C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I baseband on", v4, 2u);
  }
  return sub_100B7BDA8(a1);
}

uint64_t sub_100B7BDA8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Exiting Low Power Mode", buf, 2u);
  }
  **(unsigned char **)(a1 + 112) = 0;
  uint64_t v15 = 0;
  sub_100B7AAE0((capabilities::radio *)a1, 0, &v15);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 80));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint32_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_12:
    v17[3] = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v12 + 560))(v12, 1, 2, v17);
    sub_10003B34C(v17);
  }
LABEL_13:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 56))(*(void *)(a1 + 96));
}

void sub_100B7BF80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10003B34C((uint64_t *)va);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B7BFB8(uint64_t a1)
{
  return sub_100B7BD3C(a1 - 48);
}

void sub_100B7BFC0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I baseband off", v3, 2u);
  }
  *(unsigned char *)(*(void *)(a1 + 112) + 3) = 0;
}

void sub_100B7C02C(uint64_t a1)
{
}

void sub_100B7C034(uint64_t a1)
{
  if (**(unsigned char **)(a1 + 112))
  {
    uint64_t v1 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v2) = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I In Low Power Mode already. Ignoring.", (uint8_t *)&v2, 2u);
    }
  }
  else
  {
    sub_100068A94(&v2);
    (*(void (**)(uint64_t))(*(void *)v2 + 368))(v2);
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
}

void sub_100B7C0E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B7C100(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I handlePowerModeChangeToLow", buf, 2u);
  }
  if (a2)
  {
    dispatch_retain(a2);
    dispatch_retain(a2);
    dispatch_group_enter(a2);
    dispatch_release(a2);
  }
  char v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      p_shared_weak_owners = &v6->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v6);
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      if (a2)
      {
        dispatch_retain(a2);
        dispatch_group_enter(a2);
        dispatch_retain(a2);
        dispatch_group_enter(a2);
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        dispatch_retain(a2);
        dispatch_group_enter(a2);
      }
      else
      {
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      }
      uint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
      if (v8)
      {
        if (std::__shared_weak_count::lock(v8)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_100B7C31C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B7C340(uint64_t a1, NSObject *a2)
{
}

void sub_100B7C348(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I handlePowerModeChangeToNormal", buf, 2u);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B7C464(uint64_t a1)
{
}

void sub_100B7C46C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B7C54C(uint64_t a1)
{
}

void sub_100B7C554(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      uint32_t v7 = "true";
    }
    else {
      uint32_t v7 = "false";
    }
    int v8 = 136315394;
    unsigned int v9 = v7;
    __int16 v10 = 2080;
    uint64_t v11 = asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I DormancyStatus event, success:%s, status:%s", (uint8_t *)&v8, 0x16u);
  }
  if (a2)
  {
    *(unsigned char *)(*(void *)(a1 + 112) + 88) = a3;
    if (a3 == 4 || a3 == 2) {
      sub_100B7C034(a1);
    }
  }
}

void sub_100B7C658(uint64_t a1, int a2, int a3)
{
}

uint64_t sub_100B7C660(ApplePDPHelperInterface *a1, unsigned int a2, unsigned int a3, unsigned __int16 *a4, unsigned int a5, unint64_t *a6)
{
  Instance = (ApplePDPHelperInterface *)ApplePDPHelperInterface::getInstance(a1);

  return ApplePDPHelperInterface::getOpenPortsExt(Instance, a2, a3, a4, a5, a6);
}

uint64_t sub_100B7C6C8(ApplePDPHelperInterface *a1, unsigned int a2, unsigned int a3, unsigned __int16 *a4, unsigned int a5, unint64_t *a6)
{
  Instance = (ApplePDPHelperInterface *)ApplePDPHelperInterface::getInstance(a1);

  return ApplePDPHelperInterface::getOpenPortsExt(Instance, a2, a3, a4, a5, a6);
}

uint64_t sub_100B7C740@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_100B7A958(a1 - 48, a2);
}

uint64_t sub_100B7C748@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_100B7AE8C(a1 - 48, a2);
}

void sub_100B7C750(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 80));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    char v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (!v8)
  {
    std::mutex::unlock(v3);
    return;
  }
  uint64_t v10 = v8[3];
  unsigned int v9 = (std::__shared_weak_count *)v8[4];
  if (!v9)
  {
    std::mutex::unlock(v3);
    if (!v10) {
      return;
    }
LABEL_10:
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 760))(v10);
    unsigned int v59 = -1;
    unsigned int valuePtr = 0;
    CFNumberRef number = 0;
    uint64_t v12 = (std::mutex *)Registry::getServiceMap((uint64_t *)0xFFFFFFFFLL, *(Registry **)(a1 + 80));
    char v13 = v12;
    uint64_t v15 = v14;
    if (v14 < 0)
    {
      uint64_t v16 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(v12);
    *(void *)int buf = v15;
    int v19 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
    if (v19)
    {
      uint64_t v21 = v19[3];
      BOOL v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v13);
    BOOL v20 = 0;
    char v22 = 1;
LABEL_18:
    (*(void (**)(CFNumberRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v21 + 96))(&v57, v21, v11, 1, @"DormancyInactivity", 0, 0);
    sub_1000842D0(&number, (CFTypeRef *)&v57);
    sub_1000577C4((const void **)&v57);
    if ((v22 & 1) == 0) {
      sub_10004D2C8(v20);
    }
    if (number) {
      int v23 = sub_100081E58;
    }
    else {
      int v23 = 0;
    }
    if (!v23 || !CFNumberGetValue(number, kCFNumberIntType, &valuePtr))
    {
      BOOL v35 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I sync with CB: dormancyInactivity empty", buf, 2u);
      }
LABEL_47:
      CFNumberRef v57 = 0;
      long long v39 = (std::mutex *)Registry::getServiceMap(v36, *(Registry **)(a1 + 80));
      uint64_t v40 = v39;
      if (v14 < 0)
      {
        long long v41 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v42 = 5381;
        do
        {
          uint64_t v14 = v42;
          unsigned int v43 = *v41++;
          uint64_t v42 = (33 * v42) ^ v43;
        }
        while (v43);
      }
      std::mutex::lock(v39);
      *(void *)int buf = v14;
      int v44 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)buf);
      if (v44)
      {
        uint64_t v46 = v44[3];
        int v45 = (std::__shared_weak_count *)v44[4];
        if (v45)
        {
          atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v40);
          atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v45);
          char v47 = 0;
          goto LABEL_55;
        }
      }
      else
      {
        uint64_t v46 = 0;
      }
      std::mutex::unlock(v40);
      int v45 = 0;
      char v47 = 1;
LABEL_55:
      (*(void (**)(CFNumberRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v46 + 96))(&v57, v46, v11, 1, @"SuspendFastDormancyAllowed", kCFBooleanTrue, 0);
      if ((v47 & 1) == 0) {
        sub_10004D2C8(v45);
      }
      uint64_t v48 = (BOOL *)v57;
      BOOL v49 = 1;
      buf[0] = 1;
      if (v57)
      {
        CFTypeID v50 = CFGetTypeID(v57);
        if (v50 == CFBooleanGetTypeID())
        {
          ctu::cf::assign((ctu::cf *)buf, v48, v51);
          BOOL v49 = buf[0] != 0;
        }
        else
        {
          BOOL v49 = 1;
        }
      }
      SuspendDormancyAssertion::allow_suspend_dormancy = v49;
      sub_100058DB0(__p, "suspend dormancy");
      int v52 = sub_100C65458((long long *)__p);
      int v53 = v52;
      if (v55 < 0)
      {
        operator delete(__p[0]);
        if (!v53) {
          goto LABEL_67;
        }
      }
      else if (!v52)
      {
        goto LABEL_67;
      }
      sub_100068A94(buf);
      (*(void (**)(void, BOOL))(**(void **)buf + 288))(*(void *)buf, v49);
      if (v62) {
        sub_10004D2C8(v62);
      }
LABEL_67:
      sub_1000577C4((const void **)&v57);
      sub_1000570E8((const void **)&number);
      if (!v9) {
        return;
      }
      goto LABEL_68;
    }
    CFNumberRef v57 = 0;
    uint64_t v25 = (std::mutex *)Registry::getServiceMap(v24, *(Registry **)(a1 + 80));
    uint64_t v26 = v25;
    uint64_t v27 = v14;
    if (v14 < 0)
    {
      uint64_t v28 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        uint64_t v27 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(v25);
    *(void *)int buf = v27;
    long long v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
    if (v31)
    {
      uint64_t v33 = v31[3];
      uint64_t v32 = (std::__shared_weak_count *)v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v26);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        char v34 = 0;
LABEL_35:
        (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v33 + 96))(&v56, v33, v11, 1, @"DormancyInhibit", 0, 0);
        sub_1000842D0(&v57, &v56);
        sub_1000577C4(&v56);
        if ((v34 & 1) == 0) {
          sub_10004D2C8(v32);
        }
        if (v57) {
          int v37 = sub_100081E58;
        }
        else {
          int v37 = 0;
        }
        if (v37) {
          CFNumberGetValue(v57, kCFNumberIntType, &v59);
        }
        uint64_t v38 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 67109376;
          *(_DWORD *)&buf[4] = v59;
          LOWORD(v62) = 1024;
          *(_DWORD *)((char *)&v62 + 2) = valuePtr;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I sync with CB: dormancyInhibit=%d, dormancyInactivity = %u", buf, 0xEu);
        }
        sub_100068A94(buf);
        (*(void (**)(void, void, void))(**(void **)buf + 272))(*(void *)buf, v59, valuePtr);
        if (v62) {
          sub_10004D2C8(v62);
        }
        sub_1000570E8((const void **)&v57);
        goto LABEL_47;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    std::mutex::unlock(v26);
    uint64_t v32 = 0;
    char v34 = 1;
    goto LABEL_35;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  if (v10) {
    goto LABEL_10;
  }
LABEL_68:
  sub_10004D2C8(v9);
}

void sub_100B7CDB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, const void *a18, const void *a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  sub_1000570E8(&a18);
  sub_1000570E8(&a19);
  if (v22) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

void sub_100B7CEC8(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 80));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  double valuePtr = *(double *)&v5;
  unsigned int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&valuePtr);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_38;
    }
LABEL_10:
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 776))(v11);
    CFArrayRef theArray = 0;
    uint64_t v15 = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(a1 + 80));
    uint64_t v16 = v15;
    if ((v17 & 0x8000000000000000) != 0)
    {
      unsigned int v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        unint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(v15);
    double valuePtr = *(double *)&v17;
    uint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)&valuePtr);
    if (v21)
    {
      uint64_t v23 = v21[3];
      char v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v24 = 0;
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    char v22 = 0;
    char v24 = 1;
LABEL_18:
    (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v23 + 96))(&v33, v23, v13, 1, @"pdpTimeout", 0, 0);
    sub_100044D6C(&theArray, &v33);
    sub_1000577C4(&v33);
    if ((v24 & 1) == 0) {
      sub_10004D2C8(v22);
    }
    if (theArray) {
      uint64_t v25 = sub_100083F10;
    }
    else {
      uint64_t v25 = 0;
    }
    if (!v25) {
      goto LABEL_35;
    }
    CFIndex Count = CFArrayGetCount(theArray);
    unint64_t v27 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)Count);
    if ((v27 & 0x8000000000000000) != 0) {
      __assert_rtn("updatePDPTimeouts_sync", "DormancyController.cpp", 820, "capabilities::ct::supportedPDPContextCount() <= std::numeric_limits<long>::max()");
    }
    uint64_t v28 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v27);
    if (Count >= v28) {
      CFIndex Count = v28;
    }
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        double valuePtr = 0.0;
        CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(theArray, i);
        CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
        v32.n128_u64[0] = 0x7FEFFFFFFFFFFFFFLL;
        if (valuePtr == 0.0)
        {
          v31.n128_f64[0] = 0.0;
        }
        else
        {
          v32.n128_f64[0] = valuePtr * 60.0;
          v31.n128_f64[0] = 10.0;
        }
        (*(void (**)(uint64_t, uint64_t, CFIndex, __n128, __n128))(*(void *)v11 + 192))(v11, v13, i, v32, v31);
      }
      if (Count > 4) {
        goto LABEL_37;
      }
    }
    else
    {
LABEL_35:
      CFIndex Count = 0;
    }
    do
    {
      (*(void (**)(uint64_t, uint64_t, CFIndex, double, double))(*(void *)v11 + 192))(v11, v13, Count, dbl_10154B6E0[Count], 0.0);
      ++Count;
    }
    while (Count != 5);
LABEL_37:
    sub_100044D00((const void **)&theArray);
    goto LABEL_38;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (v11) {
    goto LABEL_10;
  }
LABEL_38:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100B7D24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100044D00((const void **)va);
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(a1);
}

void sub_100B7D2B0(uint64_t a1, int a2, uint64_t a3)
{
  int v5 = a2;
  sub_1008DC004((uint64_t)v6, a3);
  v6[4] = a1;
  char v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B7D3F8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100B7D410(uint64_t a1, int a2, long long *a3, uint64_t a4)
{
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  *(_OWORD *)uint64_t v15 = 0u;
  *(_OWORD *)char v12 = 0u;
  long long v13 = 0u;
  long long v8 = a3[1];
  long long v10 = *a3;
  long long v11 = v8;
  sub_100522ECC((uint64_t)v12, (uint64_t)(a3 + 2));
  sub_100522ECC((uint64_t)&v15[1], (uint64_t)a3 + 88);
  *(void *)&long long v19 = *((void *)a3 + 18);
  *(void *)((char *)&v19 + 6) = *(void *)((char *)a3 + 150);
  DataIPFilter::adjust((DataIPFilter *)&v10);
  long long v20 = v10;
  long long v21 = v11;
  sub_100522ECC((uint64_t)&v22, (uint64_t)v12);
  sub_100522ECC((uint64_t)&__p, (uint64_t)&v15[1]);
  v24[0] = v19;
  *(void *)((char *)v24 + 6) = *(void *)((char *)&v19 + 6);
  int v25 = a2;
  sub_1000DFC90((uint64_t)v26, a4);
  v26[4] = a1;
  unsigned int v9 = *(std::__shared_weak_count **)(a1 + 16);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B7D760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,char a47,uint64_t a48,uint64_t a49,char a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56,char a57,uint64_t a58,uint64_t a59,char a60)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100B7D828(uint64_t a1, int a2, long long *a3, uint64_t a4)
{
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  *(_OWORD *)uint64_t v15 = 0u;
  *(_OWORD *)char v12 = 0u;
  long long v13 = 0u;
  long long v8 = a3[1];
  long long v10 = *a3;
  long long v11 = v8;
  sub_100522ECC((uint64_t)v12, (uint64_t)(a3 + 2));
  sub_100522ECC((uint64_t)&v15[1], (uint64_t)a3 + 88);
  *(void *)&long long v19 = *((void *)a3 + 18);
  *(void *)((char *)&v19 + 6) = *(void *)((char *)a3 + 150);
  DataIPFilter::adjust((DataIPFilter *)&v10);
  long long v20 = v10;
  long long v21 = v11;
  sub_100522ECC((uint64_t)&v22, (uint64_t)v12);
  sub_100522ECC((uint64_t)&__p, (uint64_t)&v15[1]);
  v24[0] = v19;
  *(void *)((char *)v24 + 6) = *(void *)((char *)&v19 + 6);
  int v25 = a2;
  sub_1000DFC90((uint64_t)v26, a4);
  v26[4] = a1;
  unsigned int v9 = *(std::__shared_weak_count **)(a1 + 16);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B7DB78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,char a47,uint64_t a48,uint64_t a49,char a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56,char a57,uint64_t a58,uint64_t a59,char a60)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100B7DC40(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)int buf = 134218240;
    *(void *)&buf[4] = a1;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "filterRuleInfo=0x%lx context=0x%lx", buf, 0x16u);
  }
  if (!a1)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)int buf = 0;
    unsigned int v9 = "ifnet_traffic_descriptor_inet: no filterRuleInfo in FilterRuleCallback";
    goto LABEL_19;
  }
  char v4 = *(_OWORD **)a1;
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)int buf = 134217984;
    *(void *)&buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "td=0x%lx", buf, 0xCu);
  }
  if (!v4)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)int buf = 0;
    unsigned int v9 = "ifnet_traffic_descriptor_inet: no filterRule in FilterRuleCallback";
    goto LABEL_19;
  }
  if (a2)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
    {
      int v5 = *(_DWORD *)(a1 + 8);
      int v6 = *(_DWORD *)(a1 + 12);
      uint64_t v7 = *(void *)(a1 + 16);
      *(_DWORD *)int buf = 67109632;
      *(_DWORD *)&buf[4] = v5;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v6;
      *(_WORD *)&buf[14] = 2048;
      *(void *)&uint8_t buf[16] = v7;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "ifnet_traffic_descriptor_inet: state=%d,  interfaceID=%d, queueSetID=%llu", buf, 0x18u);
    }
    *(_OWORD *)int buf = *v4;
    *(_OWORD *)&uint8_t buf[16] = v4[1];
    long long v11 = v4[2];
    long long v8 = *(std::__shared_weak_count **)(a2 + 16);
    if (v8)
    {
      if (std::__shared_weak_count::lock(v8)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    unsigned int v9 = "ifnet_traffic_descriptor_inet: no context in FilterRuleCallback";
LABEL_19:
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, v9, buf, 2u);
  }
}

void sub_100B7DF50(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B7DF60(uint64_t a1, __n128 *a2)
{
  if (*(unsigned char *)(a1 + 48))
  {
    sub_100179CB0(a1, a2);
    unint64_t v4 = a2[2].n128_u64[0];
    *(unsigned char *)(a1 + 40) = a2[2].n128_u8[8];
    *(void *)(a1 + 32) = v4;
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 24) = 0;
    if (a2[1].n128_u8[8])
    {
      __n128 v5 = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      *(__n128 *)a1 = v5;
      a2->n128_u64[1] = 0;
      a2[1].n128_u64[0] = 0;
      a2->n128_u64[0] = 0;
      *(unsigned char *)(a1 + 24) = 1;
    }
    unint64_t v6 = a2[2].n128_u64[0];
    *(unsigned char *)(a1 + 40) = a2[2].n128_u8[8];
    *(void *)(a1 + 32) = v6;
    *(unsigned char *)(a1 + 48) = 1;
  }
  return a1;
}

uint64_t sub_100B7DFFC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  sub_100B7E054((char *)a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100B7E03C(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_100B7E054(char *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    unint64_t v4 = a2;
    __n128 v5 = (uint64_t **)result;
    unint64_t v6 = (uint64_t *)(result + 8);
    do
    {
      uint64_t result = sub_100B7E0E0(v5, v6, v4 + 7, (uint64_t)(v4 + 7));
      uint64_t v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          long long v8 = v7;
          uint64_t v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          long long v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          unint64_t v4 = v8;
        }
        while (!v9);
      }
      unint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

char *sub_100B7E0E0(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v10 = 0;
  long long v11 = 0;
  unint64_t v6 = sub_10005CF3C(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (char *)*v6;
  if (!*v6)
  {
    long long v8 = (uint64_t **)v6;
    uint64_t v7 = (char *)operator new(0x28uLL);
    *(void *)(v7 + 28) = *(void *)a4;
    *((_DWORD *)v7 + 9) = *(_DWORD *)(a4 + 8);
    sub_100046C38(a1, (uint64_t)v11, v8, (uint64_t *)v7);
  }
  return v7;
}

void sub_100B7E174(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100B7E174(a1, *a2);
    sub_100B7E174(a1, a2[1]);
    sub_10024D10C((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }
}

uint64_t sub_100B7E1D4(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x199999999999999) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xCCCCCCCCCCCCCCLL) {
    unint64_t v9 = 0x199999999999999;
  }
  else {
    unint64_t v9 = v5;
  }
  long long v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100522FB0(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  long long v13 = v10;
  long long v14 = &v10[160 * v4];
  long long v16 = &v10[160 * v9];
  sub_100B7E2DC((uint64_t)v14, a2);
  uint64_t v15 = v14 + 160;
  sub_100522F38(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1005231F0((uint64_t)&v13);
  return v11;
}

void sub_100B7E2C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1005231F0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B7E2DC(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  sub_100522ECC(a1 + 32, a2 + 32);
  sub_100522ECC(a1 + 88, a2 + 88);
  uint64_t v5 = *(void *)(a2 + 144);
  *(void *)(a1 + 150) = *(void *)(a2 + 150);
  *(void *)(a1 + 144) = v5;
  return a1;
}

void sub_100B7E33C(_Unwind_Exception *a1)
{
  sub_100522D0C(v1);
  _Unwind_Resume(a1);
}

void sub_100B7E354(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100B7E38C(uint64_t a1)
{
}

uint64_t sub_100B7E3A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100B7E3EC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100B7E418(ServiceManager::Service *this)
{
  *(void *)this = off_101A40368;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100B7E474(ServiceManager::Service *this)
{
  *(void *)this = off_101A40368;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100B7E4E4@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "DormancyController");
}

unsigned char *sub_100B7E4F4@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100B7E534(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100B7E634()
{
  return 0;
}

uint64_t sub_100B7E63C()
{
  return 1;
}

uint64_t sub_100B7E644()
{
  return 0;
}

void sub_100B7E650(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B7E730(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (a2 == 3)
  {
    group[0] = *(dispatch_group_t *)(a1 + 8);
    ServiceStage::holdOffStage((uint64_t *)&group[1], this);
    long long v4 = *(std::__shared_weak_count **)(v3 + 16);
    if (v4)
    {
      if (std::__shared_weak_count::lock(v4)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(group[0]) = 136315138;
    *(dispatch_group_t *)((char *)group + 4) = (dispatch_group_t)asString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Not handling unexpected shutdown stage (%s)", (uint8_t *)group, 0xCu);
  }
}

void sub_100B7E8CC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100B7E8E8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void **sub_100B7E920(uint64_t a1)
{
  uint64_t result = *(void ***)(a1 + 24);
  if (result)
  {
    sub_100B7E9AC(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100B7E968(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void **sub_100B7E9AC(void **a1)
{
  return a1;
}

uint64_t sub_100B7E9F4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void *sub_100B7EA40(void *a1)
{
  *a1 = off_101A40480;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B7EA8C(void *a1)
{
  *a1 = off_101A40480;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100B7EAF8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100B7EBA8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B7EBC0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100B7EBE0()
{
}

void *sub_100B7EC4C(void *a1)
{
  *a1 = off_101A404D0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100B7EC98(void *a1)
{
  *a1 = off_101A404D0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100B7ED04()
{
}

uint64_t sub_100B7ED70(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void sub_100B7EDC0()
{
}

__n128 sub_100B7EDD4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A40530;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B7EE28(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A40530;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B7EE60(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = **(unsigned int **)(a1 + 8);
  xpc_object_t object = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  read_rest_value();
  xpc_release(object);
  long long v4 = *(uint64_t (**)(void *, uint64_t))(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 32);
  unint64_t v6 = (void *)(*(void *)(a1 + 16) + (v5 >> 1));
  if (v5) {
    long long v4 = *(uint64_t (**)(void *, uint64_t))(*v6 + v4);
  }
  return v4(v6, v3);
}

void sub_100B7EF1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_100B7EF38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B7EF78()
{
}

void sub_100B7EF88()
{
}

__n128 sub_100B7EF9C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A405B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B7EFF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A405B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B7F028(uint64_t *a1, xpc_object_t *a2)
{
  sub_10003447C(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100B7F0A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B7F0E4()
{
}

void sub_100B7F0F4()
{
}

__n128 sub_100B7F108(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A40630;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B7F15C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A40630;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B7F194(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    int *v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  unint64_t v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    unint64_t v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100B7F284(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B7F2C4()
{
}

void sub_100B7F2D4()
{
}

__n128 sub_100B7F2E8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A406B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B7F33C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A406B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B7F374(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    int *v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  unint64_t v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    unint64_t v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100B7F464(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B7F4A4()
{
}

void sub_100B7F4B4()
{
}

__n128 sub_100B7F4C8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A40730;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B7F51C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A40730;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B7F554(uint64_t *a1, xpc_object_t *a2)
{
  sub_10008AAD8(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100B7F5D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B7F610()
{
}

void sub_100B7F620()
{
}

__n128 sub_100B7F634(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A407B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B7F688(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A407B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B7F6C0(void *a1, xpc_object_t *a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = (uint64_t **)a1[1];
  uint64_t v5 = v3 + 1;
  uint64_t v4 = v3[1];
  v61 = *v3;
  int v62 = v4;
  if (v3[2])
  {
    v4[2] = (uint64_t)&v62;
    *uint64_t v3 = (uint64_t *)v5;
    *uint64_t v5 = 0;
    v3[2] = 0;
  }
  else
  {
    v61 = (uint64_t *)&v62;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_100B7E174((uint64_t)v3, v3[1]);
  v3[1] = 0;
  v3[2] = 0;
  *uint64_t v3 = (uint64_t *)v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    sub_100048BF4(&v69, &object, 0);
    xpc_release(object);
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    xpc_object_t v57 = v6;
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    int v58 = v3;
    v56 = v2;
    sub_100048BF4(v68, &object, count);
    xpc_release(object);
    for (CFIndex i = v70; ; CFIndex i = ++v70)
    {
      if (i == v68[1] && v69 == v68[0])
      {
        xpc_release(v69);
        xpc_release(v69);
        uint64_t v2 = v56;
        xpc_object_t v6 = v57;
        goto LABEL_143;
      }
      xpc_object_t v67 = 0;
      xpc_object_t object = &v69;
      v75 = i;
      sub_10003FBDC((uint64_t)&object, &v67);
      if (xpc_get_type(v67) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_141:
      xpc_release(v67);
    }
    uint64_t v64 = 0;
    long long v66 = 0u;
    uint64_t v65 = &v66;
    xpc_object_t v9 = v67;
    if (v67)
    {
      xpc_retain(v67);
      xpc_object_t v73 = v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v73 = v9;
      if (!v9)
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v60 = 0;
        goto LABEL_29;
      }
    }
    xpc_object_t v60 = v9;
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
LABEL_30:
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t object = &v73;
        v75 = "first";
        sub_100048BAC((uint64_t)&object, v88);
        xpc_type_t type = xpc_get_type(*(xpc_object_t *)v88);
        if (type == (xpc_type_t)&_xpc_type_string)
        {
          LODWORD(v86) = v64;
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v86, v88, v11);
          LODWORD(v64) = v86;
        }
        else if (type == (xpc_type_t)&_xpc_type_BOOL {
               || type == (xpc_type_t)&_xpc_type_int64
        }
               || type == (xpc_type_t)&_xpc_type_uint64)
        {
          LODWORD(v64) = xpc::dyn_cast_or_default((xpc *)v88, 0, (uint64_t)v11);
        }
        xpc_release(*(xpc_object_t *)v88);
        v71[0] = &v73;
        v71[1] = "second";
        sub_100048BAC((uint64_t)v71, &v72);
        if (v72 && (xpc_object_t xarray = v72, xpc_get_type(v72) == (xpc_type_t)&_xpc_type_array)) {
          xpc_retain(xarray);
        }
        else {
          xpc_object_t xarray = xpc_null_create();
        }
        sub_10024D10C((uint64_t)&v65, (void *)v66);
        long long v66 = 0uLL;
        uint64_t v65 = &v66;
        if (xpc_get_type(xarray) == (xpc_type_t)&_xpc_type_array)
        {
          xpc_object_t object = xarray;
          if (xarray) {
            xpc_retain(xarray);
          }
          else {
            xpc_object_t object = xpc_null_create();
          }
          sub_100048BF4(&v79, &object, 0);
          xpc_release(object);
          xpc_object_t object = xarray;
          if (xarray) {
            xpc_retain(xarray);
          }
          else {
            xpc_object_t object = xpc_null_create();
          }
          if (xpc_get_type(xarray) == (xpc_type_t)&_xpc_type_array) {
            char v12 = (void *)xpc_array_get_count(xarray);
          }
          else {
            char v12 = 0;
          }
          sub_100048BF4(v78, &object, v12);
          xpc_release(object);
          int v13 = v80;
          while (2)
          {
            if (v13 == v78[1] && v79 == v78[0])
            {
              xpc_release(v79);
              xpc_release(v79);
              break;
            }
            xpc_object_t v77 = 0;
            xpc_object_t object = &v79;
            v75 = v13;
            sub_10003FBDC((uint64_t)&object, &v77);
            if (xpc_get_type(v77) == (xpc_type_t)&_xpc_type_dictionary)
            {
              xpc_object_t object = 0;
              long long v76 = 0u;
              v75 = (const char *)&v76;
              xpc_object_t v14 = v77;
              if (v77)
              {
                xpc_retain(v77);
                xpc_object_t v83 = v14;
                goto LABEL_58;
              }
              xpc_object_t v14 = xpc_null_create();
              xpc_object_t v83 = v14;
              if (v14)
              {
LABEL_58:
                if (xpc_get_type(v14) != (xpc_type_t)&_xpc_type_dictionary)
                {
                  xpc_object_t v15 = xpc_null_create();
                  goto LABEL_62;
                }
                xpc_retain(v14);
                xpc_object_t v15 = v14;
              }
              else
              {
                xpc_object_t v15 = xpc_null_create();
                xpc_object_t v14 = 0;
LABEL_62:
                xpc_object_t v83 = v15;
              }
              if (xpc_get_type(v15) == (xpc_type_t)&_xpc_type_dictionary)
              {
                *(void *)v88 = &v83;
                v89 = "first";
                sub_100048BAC((uint64_t)v88, &v86);
                LODWORD(object) = xpc::dyn_cast_or_default((xpc *)&v86, 0, v16);
                xpc_release(v86);
                v81[0] = &v83;
                v81[1] = "second";
                sub_100048BAC((uint64_t)v81, &v82);
                xpc_object_t v17 = v82;
                if (v82 && xpc_get_type(v82) == (xpc_type_t)&_xpc_type_array) {
                  xpc_retain(v17);
                }
                else {
                  xpc_object_t v17 = xpc_null_create();
                }
                sub_1000346F8((uint64_t)&v75, (void *)v76);
                long long v76 = 0uLL;
                v75 = (const char *)&v76;
                if (xpc_get_type(v17) == (xpc_type_t)&_xpc_type_array)
                {
                  *(void *)v88 = v17;
                  if (v17) {
                    xpc_retain(v17);
                  }
                  else {
                    *(void *)v88 = xpc_null_create();
                  }
                  sub_100048BF4(&v86, (void **)v88, 0);
                  xpc_release(*(xpc_object_t *)v88);
                  *(void *)v88 = v17;
                  if (v17) {
                    xpc_retain(v17);
                  }
                  else {
                    *(void *)v88 = xpc_null_create();
                  }
                  if (xpc_get_type(v17) == (xpc_type_t)&_xpc_type_array) {
                    long long v18 = (void *)xpc_array_get_count(v17);
                  }
                  else {
                    long long v18 = 0;
                  }
                  sub_100048BF4(v85, (void **)v88, v18);
                  xpc_release(*(xpc_object_t *)v88);
                  long long v19 = v87;
                  while (2)
                  {
                    if (v19 == v85[1] && v86 == v85[0])
                    {
                      xpc_release(v86);
                      xpc_release(v86);
                      break;
                    }
                    xpc_object_t v84 = 0;
                    *(void *)v88 = &v86;
                    v89 = v19;
                    sub_10003FBDC((uint64_t)v88, &v84);
                    if (xpc_get_type(v84) == (xpc_type_t)&_xpc_type_dictionary)
                    {
                      xpc_object_t v20 = v84;
                      if (v84)
                      {
                        xpc_retain(v84);
                        xpc_object_t v91 = v20;
                        goto LABEL_85;
                      }
                      xpc_object_t v20 = xpc_null_create();
                      xpc_object_t v91 = v20;
                      if (v20)
                      {
LABEL_85:
                        if (xpc_get_type(v20) != (xpc_type_t)&_xpc_type_dictionary)
                        {
                          xpc_object_t v21 = xpc_null_create();
                          goto LABEL_89;
                        }
                        xpc_retain(v20);
                        xpc_object_t v21 = v20;
                      }
                      else
                      {
                        xpc_object_t v21 = xpc_null_create();
                        xpc_object_t v20 = 0;
LABEL_89:
                        xpc_object_t v91 = v21;
                      }
                      if (xpc_get_type(v21) == (xpc_type_t)&_xpc_type_dictionary)
                      {
                        *(void *)v88 = &v91;
                        v89 = "first";
                        sub_100048BAC((uint64_t)v88, v90);
                        xpc_type_t v24 = xpc_get_type(*(xpc_object_t *)v90);
                        if (v24 == (xpc_type_t)&_xpc_type_string)
                        {
                          v92[0] = 0;
                          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v92, v90, v25);
                          int v23 = v92[0];
                        }
                        else if (v24 == (xpc_type_t)&_xpc_type_BOOL {
                               || v24 == (xpc_type_t)&_xpc_type_int64
                        }
                               || v24 == (xpc_type_t)&_xpc_type_uint64)
                        {
                          int v23 = xpc::dyn_cast_or_default((xpc *)v90, 0, (uint64_t)v25);
                        }
                        else
                        {
                          int v23 = 0;
                        }
                        xpc_release(*(xpc_object_t *)v90);
                        *(void *)v88 = &v91;
                        v89 = "second";
                        sub_100048BAC((uint64_t)v88, v90);
                        char v22 = xpc::dyn_cast_or_default((xpc *)v90, 0, v26);
                        xpc_release(*(xpc_object_t *)v90);
                        xpc_object_t v21 = v91;
                      }
                      else
                      {
                        char v22 = 0;
                        int v23 = 0;
                      }
                      xpc_release(v21);
                      xpc_release(v20);
                      uint64_t v27 = v76;
                      uint64_t v28 = &v76;
                      uint64_t v29 = &v76;
                      if ((void)v76)
                      {
                        while (1)
                        {
                          while (1)
                          {
                            uint64_t v29 = (long long *)v27;
                            int v30 = *(_DWORD *)(v27 + 28);
                            if (v30 <= v23) {
                              break;
                            }
                            uint64_t v27 = *(void *)v29;
                            uint64_t v28 = v29;
                            if (!*(void *)v29) {
                              goto LABEL_107;
                            }
                          }
                          if (v30 >= v23) {
                            break;
                          }
                          uint64_t v27 = *((void *)v29 + 1);
                          if (!v27)
                          {
                            uint64_t v28 = (long long *)((char *)v29 + 8);
                            goto LABEL_107;
                          }
                        }
                      }
                      else
                      {
LABEL_107:
                        __n128 v31 = operator new(0x28uLL);
                        v31[7] = v23;
                        *((unsigned char *)v31 + 32) = v22;
                        *(void *)__n128 v31 = 0;
                        *((void *)v31 + 1) = 0;
                        *((void *)v31 + 2) = v29;
                        *(void *)uint64_t v28 = v31;
                        if (*(void *)v75)
                        {
                          v75 = *(const char **)v75;
                          __n128 v31 = *(_DWORD **)v28;
                        }
                        sub_100046C90((uint64_t *)v76, (uint64_t *)v31);
                        ++*((void *)&v76 + 1);
                      }
                    }
                    xpc_release(v84);
                    long long v19 = ++v87;
                    continue;
                  }
                }
                xpc_release(v17);
                xpc_release(v82);
                xpc_object_t v15 = v83;
              }
              xpc_release(v15);
              xpc_release(v14);
              int v32 = (int)object;
              uint64_t v33 = (uint64_t *)v66;
              char v34 = (uint64_t **)&v66;
              BOOL v35 = (uint64_t **)&v66;
              if ((void)v66)
              {
                while (1)
                {
                  while (1)
                  {
                    BOOL v35 = (uint64_t **)v33;
                    int v36 = *((_DWORD *)v33 + 8);
                    if (v36 <= (int)object) {
                      break;
                    }
                    uint64_t v33 = *v35;
                    char v34 = v35;
                    if (!*v35) {
                      goto LABEL_120;
                    }
                  }
                  if (v36 >= (int)object) {
                    break;
                  }
                  uint64_t v33 = v35[1];
                  if (!v33)
                  {
                    char v34 = v35 + 1;
                    goto LABEL_120;
                  }
                }
              }
              else
              {
LABEL_120:
                int v37 = (uint64_t *)operator new(0x40uLL);
                uint64_t v38 = v37;
                uint64_t v40 = v75;
                uint64_t v39 = v76;
                v37[6] = v76;
                long long v41 = (char *)(v37 + 6);
                *((_DWORD *)v37 + 8) = v32;
                v37[5] = (uint64_t)v40;
                uint64_t v42 = *((void *)&v76 + 1);
                v37[7] = *((void *)&v76 + 1);
                if (v42)
                {
                  *(void *)(v39 + 16) = v41;
                  v75 = (const char *)&v76;
                  long long v76 = 0uLL;
                }
                else
                {
                  v37[5] = (uint64_t)v41;
                }
                *int v37 = 0;
                v37[1] = 0;
                v37[2] = (uint64_t)v35;
                *char v34 = v37;
                if (*(void *)v65)
                {
                  uint64_t v65 = *(long long **)v65;
                  uint64_t v38 = *v34;
                }
                sub_100046C90((uint64_t *)v66, v38);
                ++*((void *)&v66 + 1);
              }
              sub_1000346F8((uint64_t)&v75, (void *)v76);
            }
            xpc_release(v77);
            int v13 = ++v80;
            continue;
          }
        }
        xpc_release(xarray);
        xpc_release(v72);
        xpc_object_t v9 = v73;
      }
      xpc_release(v9);
      xpc_release(v60);
      int v43 = v64;
      int v44 = v5;
      while (1)
      {
        int v45 = *v44;
        uint64_t v46 = v44;
        if (!*v44) {
          break;
        }
        while (1)
        {
          int v44 = (uint64_t **)v45;
          int v47 = *((_DWORD *)v45 + 8);
          if (v47 > (int)v64) {
            break;
          }
          if (v47 >= (int)v64) {
            goto LABEL_140;
          }
          int v45 = v44[1];
          if (!v45)
          {
            uint64_t v46 = v44 + 1;
            goto LABEL_136;
          }
        }
      }
LABEL_136:
      uint64_t v48 = operator new(0x40uLL);
      CFTypeID v50 = v65;
      uint64_t v49 = v66;
      v48[6] = v66;
      CFBooleanRef v51 = (char *)(v48 + 6);
      *((_DWORD *)v48 + 8) = v43;
      v48[5] = v50;
      uint64_t v52 = *((void *)&v66 + 1);
      v48[7] = *((void *)&v66 + 1);
      if (v52)
      {
        *(void *)(v49 + 16) = v51;
        uint64_t v65 = &v66;
        long long v66 = 0uLL;
      }
      else
      {
        v48[5] = v51;
      }
      sub_100046C38(v58, (uint64_t)v44, v46, v48);
LABEL_140:
      sub_10024D10C((uint64_t)&v65, (void *)v66);
      goto LABEL_141;
    }
    xpc_object_t v9 = xpc_null_create();
LABEL_29:
    xpc_object_t v73 = v9;
    goto LABEL_30;
  }
LABEL_143:
  xpc_release(v6);
  int v53 = (void (*)(void *, uint64_t **))v2[3];
  uint64_t v54 = v2[4];
  char v55 = (void *)(v2[2] + (v54 >> 1));
  if (v54) {
    int v53 = *(void (**)(void *, uint64_t **))(*v55 + v53);
  }
  v53(v55, &v61);
  sub_100B7E174((uint64_t)&v61, v62);
}

void sub_100B801AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t a15, xpc_object_t a16, uint64_t a17, char a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,xpc_object_t a26,xpc_object_t a27,uint64_t a28,xpc_object_t a29,uint64_t a30,uint64_t a31,uint64_t a32,xpc_object_t a33,xpc_object_t a34,xpc_object_t object,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,xpc_object_t a40)
{
  xpc_object_t object = 0;
  xpc_release(a29);
  xpc_release(a11);
  sub_100B7E174((uint64_t)&a18, a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100B80490(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B804D0()
{
}

void sub_100B804E0()
{
}

__n128 sub_100B804F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A40830;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B80548(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A40830;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B80580(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100B805C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B80608()
{
}

uint64_t sub_100B80614(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100B80624(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B80640(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t *sub_100B80650(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 136));
  for (uint64_t i = *(void *)(v2 + 64); i != v2 + 56; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(v2 + 56));
  uint64_t v5 = *(void *)(v2 + 96);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 80))(v5);
  }
  sub_100088C88(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100B80730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100B80750(void *a1)
{
  uint64_t v1 = (uint64_t *)*a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I initializing", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v2 + 96) + 24))(*(void *)(v2 + 96));
  operator new();
}

void sub_100B81194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100B8134C(uint64_t **a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I starting", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v1 + 96) + 32))(*(void *)(v1 + 96));
  uint64_t v3 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I started", v5, 2u);
  }
  operator delete();
}

void sub_100B81444()
{
}

uint64_t *sub_100B81470(uint64_t *a1)
{
  if (!*a1) {
    goto LABEL_17;
  }
  unsigned int v2 = *((_DWORD *)a1 + 2);
  uint64_t v3 = sub_10001C8F4(8);
  uint64_t v5 = (wis::WISServerConnection *)*v3;
  uint64_t v4 = (std::__shared_weak_count *)v3[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5)
  {
    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
    uint64_t v7 = (wis *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v2);
    uint64_t v8 = v7;
    if (v7)
    {
      uint64_t v9 = *a1;
      *a1 = 0;
      if (v9)
      {
        if (*(unsigned char *)(v9 + 52))
        {
          unint64_t WISTimestamp = *(void *)(v9 + 8);
        }
        else
        {
          unint64_t WISTimestamp = wis::getWISTimestamp(v7);
          *(_DWORD *)(v9 + 52) |= 1u;
          *(void *)(v9 + 8) = WISTimestamp;
        }
        wis::MetricContainer::storeMetric(v8, WISTimestamp, *(_DWORD *)v8, (const wireless_diagnostics::google::protobuf::MessageLite *)v9);
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
      wis::WISServerConnection::SubmitMetric(v5, v8);
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v11 = *a1;
  *a1 = 0;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = *a1;
    *a1 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  else
  {
LABEL_17:
    *a1 = 0;
  }
  return a1;
}

void sub_100B815D0(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

void sub_100B81620(uint64_t **a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = 0;
  sub_100B7B638(**a1);
  operator delete();
}

void sub_100B81678()
{
}

void sub_100B816A4(uint64_t **a1)
{
  uint64_t v5 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = asStringBool(*((unsigned char *)v1 + 8));
    *(_DWORD *)int buf = 136315138;
    uint64_t v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Setting Dormancy to: %s", buf, 0xCu);
  }
  *(unsigned char *)(v2 + 128) = *((unsigned char *)v1 + 8);
  operator delete();
}

void sub_100B81780()
{
}

void sub_100B817AC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100B81814(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_100B81840(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100B81878(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_100B81898(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_100B818DC(uint64_t **a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v21 = a1;
  v22[0] = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Entering Low Power Mode", buf, 2u);
  }
  **(unsigned char **)(v2 + 112) = 1;
  uint64_t v4 = v1[1];
  v22[1] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  sub_100B7B638(v2);
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(v2 + 80));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_21;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  int v13 = 0;
  char v15 = 1;
  if (!v14) {
    goto LABEL_21;
  }
LABEL_16:
  uint64_t v17 = v1[2];
  uint64_t v16 = v1[3];
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 16), 1uLL, memory_order_relaxed);
  }
  long long v18 = v1[4];
  if (v18)
  {
    dispatch_retain(v18);
    dispatch_group_enter(v18);
  }
  xpc_type_t v24 = 0;
  long long v19 = operator new(0x20uLL);
  void *v19 = off_101A40960;
  v19[1] = v17;
  v19[2] = v16;
  v19[3] = v18;
  xpc_type_t v24 = v19;
  (*(void (**)(uint64_t, void, uint64_t, uint8_t *))(*(void *)v14 + 560))(v14, 0, 2, buf);
  sub_10003B34C(buf);
LABEL_21:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  sub_100B81BD8(v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_100B81B3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  sub_10003B34C((uint64_t *)va2);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  sub_100B81BD8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B81BD8(void *result)
{
  uint64_t v1 = (void *)*result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = v1[4];
    if (v2)
    {
      dispatch_group_leave(v2);
      char v3 = v1[4];
      if (v3) {
        dispatch_release(v3);
      }
    }
    uint64_t v4 = (std::__shared_weak_count *)v1[3];
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
    uint64_t v5 = v1[1];
    if (v5)
    {
      dispatch_group_leave(v5);
      xpc_object_t v6 = v1[1];
      if (v6) {
        dispatch_release(v6);
      }
    }
    operator delete();
  }
  return result;
}

void *sub_100B81C5C(void *a1)
{
  *a1 = off_101A40960;
  uint64_t v2 = a1[3];
  if (v2)
  {
    dispatch_group_leave(v2);
    char v3 = a1[3];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_100B81CC0(void *a1)
{
  *a1 = off_101A40960;
  uint64_t v2 = a1[3];
  if (v2)
  {
    dispatch_group_leave(v2);
    char v3 = a1[3];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void *sub_100B81D44(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x20uLL);
  *uint64_t v2 = off_101A40960;
  sub_100B81F88(v2 + 1, v1);
  return v2;
}

void *sub_100B81D98(uint64_t a1, void *a2)
{
  *a2 = off_101A40960;
  return sub_100B81F88(a2 + 1, (void *)(a1 + 8));
}

void sub_100B81DC4(uint64_t a1)
{
}

void sub_100B81DCC(void *a1)
{
  sub_100B81FE0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B81E08(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v5 = *(NSObject **)(a1 + 24);
        if (v5)
        {
          dispatch_retain(*(dispatch_object_t *)(a1 + 24));
          dispatch_group_enter(v5);
        }
        xpc_object_t v6 = *(std::__shared_weak_count **)(v4 + 16);
        if (v6)
        {
          if (std::__shared_weak_count::lock(v6)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100B81F3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B81F7C()
{
}

void *sub_100B81F88(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[2];
  a1[2] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = a1[2];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  return a1;
}

void sub_100B81FE0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t *sub_100B8203C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(capabilities::radio **)v1;
  uint64_t v3 = *(NSObject **)(v1 + 16);
  uint64_t v7 = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  sub_100B7AAE0(v2, 1, &v7);
  if (v3)
  {
    dispatch_group_leave(v3);
    dispatch_release(v3);
  }
  sub_100B820EC(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100B820BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (v11)
  {
    dispatch_group_leave(v11);
    dispatch_release(v11);
  }
  sub_100B820EC(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B820EC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(NSObject **)(v1 + 16);
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = *(NSObject **)(v1 + 16);
      if (v3) {
        dispatch_release(v3);
      }
    }
    uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
    if (v4) {
      sub_10004D2C8(v4);
    }
    operator delete();
  }
  return result;
}

void sub_100B82158(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100B7BDA8(**a1);
  operator delete();
}

void sub_100B821AC()
{
}

void sub_100B821D8(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100B7C034(**a1);
  operator delete();
}

void sub_100B8222C()
{
}

uint64_t sub_100B82258(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100B822D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  (*(void (**)(void *__return_ptr))(**(void **)(*(void *)(v1 + 40) + 96) + 104))(v6);
  uint64_t v2 = *(void *)(v1 + 32);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void *))(*(void *)v2 + 48))(v2, v6);
  uint64_t v7 = (void **)v6;
  sub_100523284(&v7);
  sub_100B823C4(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100B82390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100B823C4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100523F74((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_100B82414(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v22 = a1;
  uint64_t v23 = v1;
  uint64_t v2 = *(void *)(v1 + 200);
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  *(_OWORD *)long long __p = 0u;
  *(_OWORD *)BOOL v26 = 0u;
  long long v27 = 0u;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v24 = *(_OWORD *)v1;
  long long v25 = v3;
  sub_100522ECC((uint64_t)v26, v1 + 32);
  sub_100522ECC((uint64_t)&__p[1], v1 + 88);
  uint64_t v4 = *(uint64_t **)(v1 + 144);
  *(void *)((char *)&v33 + 6) = *(void *)(v1 + 150);
  *(void *)&long long v33 = v4;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 80));
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  char v34 = (unsigned int *)v7;
  unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v34);
  if (!v11)
  {
    std::mutex::unlock(v6);
    goto LABEL_26;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v6);
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    if (!v13)
    {
LABEL_25:
      sub_10004D2C8(v12);
      goto LABEL_26;
    }
  }
  else
  {
    std::mutex::unlock(v6);
    if (!v13) {
      goto LABEL_26;
    }
  }
  subscriber::makeSimSlotRange();
  char v15 = v34;
  uint64_t v14 = v35;
  if (v34 != v35)
  {
    uint64_t v16 = v36;
    while ((v16(*v15) & 1) == 0)
    {
      if (++v15 == v14)
      {
        char v15 = v14;
        break;
      }
    }
    uint64_t v17 = v35;
LABEL_16:
    while (v15 != v17)
    {
      if ((*(unsigned int (**)(uint64_t, void, uint64_t))(*(void *)v13 + 952))(v13, *v15, 17) == *(_DWORD *)(v1 + 160))
      {
        LOWORD(v25) = 257;
        break;
      }
      long long v18 = v15 + 1;
      char v15 = v14;
      if (v18 != v14)
      {
        char v15 = v18;
        while ((v16(*v15) & 1) == 0)
        {
          if (++v15 == v14)
          {
            char v15 = v14;
            goto LABEL_16;
          }
        }
      }
    }
  }
  if (v12) {
    goto LABEL_25;
  }
LABEL_26:
  uint64_t v19 = *(void *)(v2 + 96);
  if (v19)
  {
    uint64_t v20 = *(unsigned int *)(v1 + 160);
    sub_1000DFC90((uint64_t)&v34, v1 + 168);
    (*(void (**)(uint64_t, uint64_t, long long *, unsigned int **))(*(void *)v19 + 88))(v19, v20, &v24, &v34);
    sub_100060644(&v34);
  }
  else
  {
    sub_1000607A8(v1 + 168, 0);
  }
  if (BYTE8(v32) && (_BYTE)v31 && SHIBYTE(v30) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]) && BYTE8(v27) && SBYTE7(v27) < 0) {
    operator delete(v26[0]);
  }
  sub_100B827B4(&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_100B82700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,char a34)
{
  if (v34) {
    sub_10004D2C8(v34);
  }
  if (a34) {
    BOOL v36 = a31 == 0;
  }
  else {
    BOOL v36 = 1;
  }
  if (!v36 && a30 < 0) {
    operator delete(__p);
  }
  if (a24 && a21 && a20 < 0) {
    operator delete(a15);
  }
  sub_100B827B4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B827B4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 168));
    sub_100522D0C(v1 + 88);
    sub_100522D0C(v1 + 32);
    operator delete();
  }
  return result;
}

uint64_t *sub_100B82814(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v22 = a1;
  uint64_t v23 = v1;
  uint64_t v2 = *(void *)(v1 + 200);
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  *(_OWORD *)long long __p = 0u;
  *(_OWORD *)BOOL v26 = 0u;
  long long v27 = 0u;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v24 = *(_OWORD *)v1;
  long long v25 = v3;
  sub_100522ECC((uint64_t)v26, v1 + 32);
  sub_100522ECC((uint64_t)&__p[1], v1 + 88);
  uint64_t v4 = *(uint64_t **)(v1 + 144);
  *(void *)((char *)&v33 + 6) = *(void *)(v1 + 150);
  *(void *)&long long v33 = v4;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 80));
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  char v34 = (unsigned int *)v7;
  unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v34);
  if (!v11)
  {
    std::mutex::unlock(v6);
    goto LABEL_26;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v6);
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    if (!v13)
    {
LABEL_25:
      sub_10004D2C8(v12);
      goto LABEL_26;
    }
  }
  else
  {
    std::mutex::unlock(v6);
    if (!v13) {
      goto LABEL_26;
    }
  }
  subscriber::makeSimSlotRange();
  char v15 = v34;
  uint64_t v14 = v35;
  if (v34 != v35)
  {
    uint64_t v16 = v36;
    while ((v16(*v15) & 1) == 0)
    {
      if (++v15 == v14)
      {
        char v15 = v14;
        break;
      }
    }
    uint64_t v17 = v35;
LABEL_16:
    while (v15 != v17)
    {
      if ((*(unsigned int (**)(uint64_t, void, uint64_t))(*(void *)v13 + 952))(v13, *v15, 17) == *(_DWORD *)(v1 + 160))
      {
        LOWORD(v25) = 257;
        break;
      }
      long long v18 = v15 + 1;
      char v15 = v14;
      if (v18 != v14)
      {
        char v15 = v18;
        while ((v16(*v15) & 1) == 0)
        {
          if (++v15 == v14)
          {
            char v15 = v14;
            goto LABEL_16;
          }
        }
      }
    }
  }
  if (v12) {
    goto LABEL_25;
  }
LABEL_26:
  uint64_t v19 = *(void *)(v2 + 96);
  if (v19)
  {
    uint64_t v20 = *(unsigned int *)(v1 + 160);
    sub_1000DFC90((uint64_t)&v34, v1 + 168);
    (*(void (**)(uint64_t, uint64_t, long long *, unsigned int **))(*(void *)v19 + 96))(v19, v20, &v24, &v34);
    sub_100060644(&v34);
  }
  else
  {
    sub_1000607A8(v1 + 168, 0);
  }
  if (BYTE8(v32) && (_BYTE)v31 && SHIBYTE(v30) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]) && BYTE8(v27) && SBYTE7(v27) < 0) {
    operator delete(v26[0]);
  }
  sub_100B827B4(&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_100B82B00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,char a34)
{
  if (v34) {
    sub_10004D2C8(v34);
  }
  if (a34) {
    BOOL v36 = a31 == 0;
  }
  else {
    BOOL v36 = 1;
  }
  if (!v36 && a30 < 0) {
    operator delete(__p);
  }
  if (a24 && a21 && a20 < 0) {
    operator delete(a15);
  }
  sub_100B827B4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100B82BB4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  long long v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *((_DWORD *)v1 + 14);
    int v5 = *((_DWORD *)v1 + 15);
    uint64_t v6 = v1[8];
    *(_DWORD *)int buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = v4;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v5;
    *(_WORD *)&buf[14] = 2048;
    *(void *)&long long v105 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I ifnet_traffic_descriptor_inet: state=%d, interfaceID=%d, queueSetID=%llu", buf, 0x18u);
    long long v3 = *(NSObject **)(v2 + 40);
  }
  uint64_t v75 = 0;
  unint64_t v76 = 0;
  unint64_t v77 = 0;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *((unsigned __int8 *)v1 + 8);
    int v8 = *((_DWORD *)v1 + 3);
    int v9 = *((unsigned __int8 *)v1 + 16);
    int v10 = *((unsigned __int8 *)v1 + 17);
    int v11 = *((unsigned __int8 *)v1 + 18);
    unsigned int v12 = bswap32(*((unsigned __int16 *)v1 + 26)) >> 16;
    unsigned int v13 = bswap32(*((unsigned __int16 *)v1 + 27)) >> 16;
    *(_DWORD *)int buf = 67110656;
    *(_DWORD *)&uint8_t buf[4] = v7;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v8;
    *(_WORD *)&buf[14] = 1024;
    LODWORD(v105) = v9;
    WORD2(v105) = 1024;
    *(_DWORD *)((char *)&v105 + 6) = v10;
    WORD5(v105) = 1024;
    HIDWORD(v105) = v11;
    LOWORD(v106) = 1024;
    *(_DWORD *)((char *)&v106 + 2) = v12;
    WORD3(v106) = 1024;
    DWORD2(v106) = v13;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I ifnet_traffic_descriptor_inet: itd_type=%u, itd_flags=0x%x, mask=0x%x, ipver=%u, proto=%u, lport=%u, rport=%u", buf, 0x2Cu);
  }
  int v14 = *((unsigned __int8 *)v1 + 8);
  if (v14 == 2)
  {
    int v15 = *((_DWORD *)v1 + 3);
    if ((v15 & 3) != 0)
    {
      long long v112 = 0u;
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      long long v108 = 0u;
      long long v109 = 0u;
      long long v106 = 0u;
      long long v107 = 0u;
      *(_OWORD *)int buf = 0u;
      long long v105 = 0u;
      WORD6(v113) = 257;
      long long v90 = 0u;
      long long v91 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      *(_OWORD *)v87 = 0u;
      *(_OWORD *)xpc_object_t v84 = 0u;
      long long v85 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      WORD6(v91) = 256;
      char v16 = *((unsigned char *)v1 + 16);
      if (v16)
      {
        unsigned __int32 v17 = *((unsigned __int8 *)v1 + 17);
        if (v17 == 96)
        {
          HIDWORD(v105) = 41;
          HIDWORD(v83) = 41;
          if ((v16 & 4) != 0)
          {
            uint64_t v79 = 0;
            uint64_t v80 = 0;
            uint64_t v81 = 0;
            CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v79);
            CSIPacketAddress::setIPv6Address((CSIPacketAddress *)&v79, (const unsigned __int8 *)v1 + 20, 0x10uLL);
            memset(&__p, 0, sizeof(__p));
            CSIPacketAddress::operator std::string();
            long long v27 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              p_p = &__p;
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              v96.n128_u32[0] = 136315138;
              *(unint64_t *)((char *)v96.n128_u64 + 4) = (unint64_t)p_p;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I ifnet_traffic_descriptor_inet: laddr=%s", (uint8_t *)&v96, 0xCu);
            }
            if (!(_BYTE)v109)
            {
              v96.n128_u8[0] = 0;
              char v98 = 0;
              __int16 v99 = 0;
              char v100 = 0;
              char v101 = 0;
              char v102 = 0;
              char v103 = 0;
              sub_100B7DF60((uint64_t)&v106, &v96);
              if (v98 && v97 < 0) {
                operator delete((void *)v96.n128_u64[0]);
              }
              if (!(_BYTE)v109) {
                goto LABEL_227;
              }
            }
            sub_100093B44((std::string *)&v106, &__p);
            if (!(_BYTE)v109) {
              sub_10016C840();
            }
            if (!BYTE1(v108)) {
              BYTE1(v108) = 1;
            }
            LOBYTE(v108) = 0x80;
            if (!BYTE8(v90))
            {
              v96.n128_u8[0] = 0;
              char v98 = 0;
              __int16 v99 = 0;
              char v100 = 0;
              char v101 = 0;
              char v102 = 0;
              char v103 = 0;
              sub_100B7DF60((uint64_t)&v87[1], &v96);
              if (v98 && v97 < 0) {
                operator delete((void *)v96.n128_u64[0]);
              }
              if (!BYTE8(v90)) {
LABEL_227:
              }
                sub_10016C840();
            }
            sub_100093B44((std::string *)&v87[1], &__p);
            if (!BYTE8(v90)) {
              sub_10016C840();
            }
            if (!BYTE9(v89)) {
              BYTE9(v89) = 1;
            }
            BYTE8(v89) = 0x80;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            char v16 = *((unsigned char *)v1 + 16);
          }
          if ((v16 & 8) == 0) {
            goto LABEL_112;
          }
          uint64_t v79 = 0;
          uint64_t v80 = 0;
          uint64_t v81 = 0;
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v79);
          CSIPacketAddress::setIPv6Address((CSIPacketAddress *)&v79, (const unsigned __int8 *)v1 + 36, 0x10uLL);
          memset(&__p, 0, sizeof(__p));
          CSIPacketAddress::operator std::string();
          uint64_t v29 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            long long v30 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              long long v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            v96.n128_u32[0] = 136315138;
            *(unint64_t *)((char *)v96.n128_u64 + 4) = (unint64_t)v30;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I ifnet_traffic_descriptor_inet: raddr=%s", (uint8_t *)&v96, 0xCu);
          }
          if (!BYTE8(v112))
          {
            v96.n128_u8[0] = 0;
            char v98 = 0;
            __int16 v99 = 0;
            char v100 = 0;
            char v101 = 0;
            char v102 = 0;
            char v103 = 0;
            sub_100B7DF60((uint64_t)&v109 + 8, &v96);
            if (v98 && v97 < 0) {
              operator delete((void *)v96.n128_u64[0]);
            }
            if (!BYTE8(v112)) {
              goto LABEL_229;
            }
          }
          sub_100093B44((std::string *)((char *)&v109 + 8), &__p);
          if (!BYTE8(v112)) {
            sub_10016C840();
          }
          if (!BYTE9(v111)) {
            BYTE9(v111) = 1;
          }
          BYTE8(v111) = 0x80;
          if (!LOBYTE(v87[0]))
          {
            v96.n128_u8[0] = 0;
            char v98 = 0;
            __int16 v99 = 0;
            char v100 = 0;
            char v101 = 0;
            char v102 = 0;
            char v103 = 0;
            sub_100B7DF60((uint64_t)v84, &v96);
            if (v98 && v97 < 0) {
              operator delete((void *)v96.n128_u64[0]);
            }
            if (!LOBYTE(v87[0])) {
LABEL_229:
            }
              sub_10016C840();
          }
          sub_100093B44((std::string *)v84, &__p);
          if (!LOBYTE(v87[0])) {
            sub_10016C840();
          }
          if (!BYTE1(v86)) {
            BYTE1(v86) = 1;
          }
          char v22 = 0x80;
          goto LABEL_108;
        }
        if (v17 != 4)
        {
          long long v31 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            v96.n128_u32[0] = 67109120;
            v96.n128_u32[1] = v17;
            _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "ifnet_traffic_descriptor_inet: wrong inet_ipver value: %d", (uint8_t *)&v96, 8u);
          }
          goto LABEL_112;
        }
        HIDWORD(v105) = 4;
        HIDWORD(v83) = 4;
        if ((v16 & 4) != 0)
        {
          uint64_t v79 = 0;
          uint64_t v80 = 0;
          uint64_t v81 = 0;
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v79);
          CSIPacketAddress::setIPv4Address((CSIPacketAddress *)&v79, *((_DWORD *)v1 + 8));
          memset(&__p, 0, sizeof(__p));
          CSIPacketAddress::operator std::string();
          long long v18 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v19 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            v96.n128_u32[0] = 136315138;
            *(unint64_t *)((char *)v96.n128_u64 + 4) = (unint64_t)v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I ifnet_traffic_descriptor_inet: laddr=%s", (uint8_t *)&v96, 0xCu);
          }
          if (!(_BYTE)v109)
          {
            v96.n128_u8[0] = 0;
            char v98 = 0;
            __int16 v99 = 0;
            char v100 = 0;
            char v101 = 0;
            char v102 = 0;
            char v103 = 0;
            sub_100B7DF60((uint64_t)&v106, &v96);
            if (v98 && v97 < 0) {
              operator delete((void *)v96.n128_u64[0]);
            }
            if (!(_BYTE)v109) {
              goto LABEL_226;
            }
          }
          sub_100093B44((std::string *)&v106, &__p);
          if (!(_BYTE)v109) {
            sub_10016C840();
          }
          if (!BYTE1(v108)) {
            BYTE1(v108) = 1;
          }
          LOBYTE(v108) = 32;
          if (!BYTE8(v90))
          {
            v96.n128_u8[0] = 0;
            char v98 = 0;
            __int16 v99 = 0;
            char v100 = 0;
            char v101 = 0;
            char v102 = 0;
            char v103 = 0;
            sub_100B7DF60((uint64_t)&v87[1], &v96);
            if (v98 && v97 < 0) {
              operator delete((void *)v96.n128_u64[0]);
            }
            if (!BYTE8(v90)) {
LABEL_226:
            }
              sub_10016C840();
          }
          sub_100093B44((std::string *)&v87[1], &__p);
          if (!BYTE8(v90)) {
            sub_10016C840();
          }
          if (!BYTE9(v89)) {
            BYTE9(v89) = 1;
          }
          BYTE8(v89) = 32;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          char v16 = *((unsigned char *)v1 + 16);
        }
        if ((v16 & 8) != 0)
        {
          uint64_t v79 = 0;
          uint64_t v80 = 0;
          uint64_t v81 = 0;
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v79);
          CSIPacketAddress::setIPv4Address((CSIPacketAddress *)&v79, *((_DWORD *)v1 + 12));
          memset(&__p, 0, sizeof(__p));
          CSIPacketAddress::operator std::string();
          uint64_t v20 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            xpc_object_t v21 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              xpc_object_t v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            v96.n128_u32[0] = 136315138;
            *(unint64_t *)((char *)v96.n128_u64 + 4) = (unint64_t)v21;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I ifnet_traffic_descriptor_inet: raddr=%s", (uint8_t *)&v96, 0xCu);
          }
          if (!BYTE8(v112))
          {
            v96.n128_u8[0] = 0;
            char v98 = 0;
            __int16 v99 = 0;
            char v100 = 0;
            char v101 = 0;
            char v102 = 0;
            char v103 = 0;
            sub_100B7DF60((uint64_t)&v109 + 8, &v96);
            if (v98 && v97 < 0) {
              operator delete((void *)v96.n128_u64[0]);
            }
            if (!BYTE8(v112)) {
              goto LABEL_228;
            }
          }
          sub_100093B44((std::string *)((char *)&v109 + 8), &__p);
          if (!BYTE8(v112)) {
            sub_10016C840();
          }
          if (!BYTE9(v111)) {
            BYTE9(v111) = 1;
          }
          BYTE8(v111) = 32;
          if (!LOBYTE(v87[0]))
          {
            v96.n128_u8[0] = 0;
            char v98 = 0;
            __int16 v99 = 0;
            char v100 = 0;
            char v101 = 0;
            char v102 = 0;
            char v103 = 0;
            sub_100B7DF60((uint64_t)v84, &v96);
            if (v98 && v97 < 0) {
              operator delete((void *)v96.n128_u64[0]);
            }
            if (!LOBYTE(v87[0])) {
LABEL_228:
            }
              sub_10016C840();
          }
          sub_100093B44((std::string *)v84, &__p);
          if (!LOBYTE(v87[0])) {
            sub_10016C840();
          }
          if (!BYTE1(v86)) {
            BYTE1(v86) = 1;
          }
          char v22 = 32;
LABEL_108:
          LOBYTE(v86) = v22;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
      }
LABEL_112:
      char v32 = *((unsigned char *)v1 + 16);
      if ((v32 & 2) == 0) {
        goto LABEL_121;
      }
      unsigned __int32 v33 = *((unsigned __int8 *)v1 + 18);
      if (v33 == 17)
      {
        int v34 = 17;
LABEL_117:
        DWORD2(v105) = v34;
        DWORD2(v83) = v34;
        if ((v32 & 0x10) == 0) {
          goto LABEL_118;
        }
LABEL_122:
        unsigned int v36 = *((unsigned __int16 *)v1 + 26);
        if (!(_BYTE)v109)
        {
          v96.n128_u8[0] = 0;
          char v98 = 0;
          __int16 v99 = 0;
          char v100 = 0;
          char v101 = 0;
          char v102 = 0;
          char v103 = 0;
          sub_100B7DF60((uint64_t)&v106, &v96);
          if (v98 && v97 < 0) {
            operator delete((void *)v96.n128_u64[0]);
          }
          if (!(_BYTE)v109) {
            sub_10016C840();
          }
        }
        unsigned int v37 = bswap32(v36);
        unsigned int v38 = HIWORD(v37);
        WORD1(v108) = HIWORD(v37);
        BYTE4(v108) = 1;
        if (!BYTE8(v90))
        {
          v96.n128_u8[0] = 0;
          char v98 = 0;
          __int16 v99 = 0;
          char v100 = 0;
          char v101 = 0;
          char v102 = 0;
          char v103 = 0;
          sub_100B7DF60((uint64_t)&v87[1], &v96);
          if (v98 && v97 < 0) {
            operator delete((void *)v96.n128_u64[0]);
          }
          if (!BYTE8(v90)) {
            sub_10016C840();
          }
        }
        WORD5(v89) = v38;
        BYTE12(v89) = 1;
        if ((v1[2] & 8) == 0)
        {
LABEL_144:
          uint64_t v75 = 0;
          unint64_t v76 = 0;
          unint64_t v77 = 0;
          if ((v15 & 2) != 0)
          {
            if (!sub_1005B0478((uint64_t)buf))
            {
              unint64_t v76 = sub_100B7E1D4(&v75, (uint64_t)buf);
              if (v15)
              {
LABEL_146:
                if (sub_1005B0478((uint64_t)&v82))
                {
                  uint64_t v42 = *(NSObject **)(v2 + 40);
                  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
                  {
                    v96.n128_u16[0] = 0;
                    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#E ifnet_traffic_descriptor_inet: downlink filter empty", (uint8_t *)&v96, 2u);
                  }
                }
                else
                {
                  unint64_t v44 = v76;
                  if (v76 >= v77)
                  {
                    uint64_t v45 = sub_100B7E1D4(&v75, (uint64_t)&v82);
                  }
                  else
                  {
                    sub_100B7E2DC(v76, (uint64_t)&v82);
                    uint64_t v45 = v44 + 160;
                  }
                  unint64_t v76 = v45;
                }
              }
LABEL_159:
              if (BYTE8(v90) && (_BYTE)v89 && SHIBYTE(v88) < 0) {
                operator delete(v87[1]);
              }
              if (LOBYTE(v87[0]) && BYTE8(v85) && SBYTE7(v85) < 0) {
                operator delete(v84[0]);
              }
              if (BYTE8(v112) && (_BYTE)v111 && SHIBYTE(v110) < 0) {
                operator delete(*((void **)&v109 + 1));
              }
              if ((_BYTE)v109 && BYTE8(v107) && SBYTE7(v107) < 0) {
                operator delete((void *)v106);
              }
              uint64_t v26 = v75;
              unint64_t v25 = v76;
              if (v75 != v76)
              {
                uint64_t v46 = v1[8];
                uint64_t v47 = v75;
                do
                {
                  *(void *)(v47 + 8) = v46;
                  v47 += 160;
                }
                while (v47 != v25);
              }
LABEL_178:
              uint64_t v48 = *(NSObject **)(v2 + 40);
              BOOL v49 = os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT);
              if (v49)
              {
                *(_DWORD *)int buf = 134217984;
                *(void *)&uint8_t buf[4] = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v25 - v26) >> 5);
                _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I ifnet_traffic_descriptor_inet: filters size = %lu", buf, 0xCu);
              }
              if (capabilities::ct::supportsDataQMIExtensions((capabilities::ct *)v49))
              {
                uint64_t v51 = v75;
                for (unint64_t i = v76; v51 != i; v51 += 160)
                {
                  int v53 = *((_DWORD *)v1 + 14);
                  if (v53)
                  {
                    if (v53 != 1)
                    {
                      xpc_object_t v57 = *(NSObject **)(v2 + 40);
                      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)int buf = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "ifnet_traffic_descriptor_inet: wrong llFilter state", buf, 2u);
                      }
                      continue;
                    }
                    uint64_t v54 = *((unsigned int *)v1 + 15);
                    v95[0] = off_101A409E0;
                    v95[1] = v2;
                    v95[3] = v95;
                    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v2 + 56))(v2, v54, v51, v95);
                    char v55 = v95;
                  }
                  else
                  {
                    uint64_t v56 = *((unsigned int *)v1 + 15);
                    v94[0] = off_101A40A60;
                    v94[1] = v2;
                    v94[3] = v94;
                    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v2 + 64))(v2, v56, v51, v94);
                    char v55 = v94;
                  }
                  sub_100060644(v55);
                }
LABEL_209:
                *(void *)int buf = &v75;
                sub_100523284((void ***)buf);
                operator delete();
              }
              ServiceMap = (std::mutex *)Registry::getServiceMap(v50, *(Registry **)(v2 + 80));
              unsigned int v59 = ServiceMap;
              if (v60 < 0)
              {
                v61 = (unsigned __int8 *)(v60 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v62 = 5381;
                do
                {
                  uint64_t v60 = v62;
                  unsigned int v63 = *v61++;
                  uint64_t v62 = (33 * v62) ^ v63;
                }
                while (v63);
              }
              std::mutex::lock(ServiceMap);
              *(void *)int buf = v60;
              uint64_t v64 = sub_10004D37C(&v59[1].__m_.__sig, (unint64_t *)buf);
              if (v64)
              {
                uint64_t v66 = v64[3];
                uint64_t v65 = (std::__shared_weak_count *)v64[4];
                if (v65)
                {
                  atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v59);
                  atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v65);
                  char v67 = 0;
                  if (!v66)
                  {
LABEL_207:
                    if (v67) {
                      goto LABEL_209;
                    }
                    goto LABEL_208;
                  }
LABEL_200:
                  int v68 = *((_DWORD *)v1 + 14);
                  if (v68)
                  {
                    if (v68 != 1)
                    {
                      v74 = *(NSObject **)(v2 + 40);
                      if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_207;
                      }
                      *(_WORD *)int buf = 0;
                      _os_log_error_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_ERROR, "ifnet_traffic_descriptor_inet: wrong llFilter state", buf, 2u);
                      if (v67) {
                        goto LABEL_209;
                      }
LABEL_208:
                      sub_10004D2C8(v65);
                      goto LABEL_209;
                    }
                    uint64_t v69 = *((unsigned int *)v1 + 15);
                    uint64_t v70 = v1[8];
                    v93[0] = off_101A40AE0;
                    v93[1] = v2;
                    v93[3] = v93;
                    (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, void *))(*(void *)v66 + 880))(v66, v69, &v75, v70, v93);
                    v71 = v93;
                  }
                  else
                  {
                    uint64_t v72 = *((unsigned int *)v1 + 15);
                    uint64_t v73 = v1[8];
                    v92[0] = off_101A40B60;
                    v92[1] = v2;
                    v92[3] = v92;
                    (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, void *))(*(void *)v66 + 888))(v66, v72, &v75, v73, v92);
                    v71 = v92;
                  }
                  sub_100060644(v71);
                  if (v67) {
                    goto LABEL_209;
                  }
                  goto LABEL_208;
                }
              }
              else
              {
                uint64_t v66 = 0;
              }
              std::mutex::unlock(v59);
              uint64_t v65 = 0;
              char v67 = 1;
              if (!v66) {
                goto LABEL_207;
              }
              goto LABEL_200;
            }
            int v43 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              v96.n128_u16[0] = 0;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#E ifnet_traffic_descriptor_inet: uplink filter empty", (uint8_t *)&v96, 2u);
            }
          }
          if (v15) {
            goto LABEL_146;
          }
          goto LABEL_159;
        }
LABEL_133:
        unsigned int v39 = *((unsigned __int16 *)v1 + 27);
        if (!BYTE8(v112))
        {
          v96.n128_u8[0] = 0;
          char v98 = 0;
          __int16 v99 = 0;
          char v100 = 0;
          char v101 = 0;
          char v102 = 0;
          char v103 = 0;
          sub_100B7DF60((uint64_t)&v109 + 8, &v96);
          if (v98 && v97 < 0) {
            operator delete((void *)v96.n128_u64[0]);
          }
          if (!BYTE8(v112)) {
            sub_10016C840();
          }
        }
        unsigned int v40 = bswap32(v39);
        unsigned int v41 = HIWORD(v40);
        WORD5(v111) = HIWORD(v40);
        BYTE12(v111) = 1;
        if (!LOBYTE(v87[0]))
        {
          v96.n128_u8[0] = 0;
          char v98 = 0;
          __int16 v99 = 0;
          char v100 = 0;
          char v101 = 0;
          char v102 = 0;
          char v103 = 0;
          sub_100B7DF60((uint64_t)v84, &v96);
          if (v98 && v97 < 0) {
            operator delete((void *)v96.n128_u64[0]);
          }
          if (!LOBYTE(v87[0])) {
            sub_10016C840();
          }
        }
        WORD1(v86) = v41;
        BYTE4(v86) = 1;
        goto LABEL_144;
      }
      if (v33 == 6)
      {
        int v34 = 6;
        goto LABEL_117;
      }
      BOOL v35 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        v96.n128_u32[0] = 67109120;
        v96.n128_u32[1] = v33;
        _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "ifnet_traffic_descriptor_inet: wrong inet_proto value: %d", (uint8_t *)&v96, 8u);
        char v32 = *((unsigned char *)v1 + 16);
        if ((v32 & 0x10) != 0) {
          goto LABEL_122;
        }
      }
      else
      {
LABEL_121:
        if ((v32 & 0x10) != 0) {
          goto LABEL_122;
        }
      }
LABEL_118:
      if ((v32 & 8) == 0) {
        goto LABEL_144;
      }
      goto LABEL_133;
    }
    uint64_t v23 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v15;
      long long v24 = "#E ifnet_traffic_descriptor_inet: wrong flags: 0x%x";
      goto LABEL_60;
    }
  }
  else
  {
    uint64_t v23 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v14;
      long long v24 = "#E ifnet_traffic_descriptor_inet: wrong type: %d";
LABEL_60:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v24, buf, 8u);
    }
  }
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v75 = 0;
  unint64_t v76 = 0;
  unint64_t v77 = 0;
  goto LABEL_178;
}

void sub_100B83D4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,uint64_t a33,uint64_t a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,char a42,uint64_t a43,uint64_t a44,char a45)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a45 && a42 && a41 < 0) {
    operator delete(a36);
  }
  if (a35 && a32 && a31 < 0) {
    operator delete(a26);
  }
  if (*(unsigned char *)(v45 - 120) && *(unsigned char *)(v45 - 144) && *(char *)(v45 - 145) < 0) {
    operator delete(*(void **)(v45 - 168));
  }
  if (*(unsigned char *)(v45 - 176) && *(unsigned char *)(v45 - 200) && *(char *)(v45 - 201) < 0) {
    operator delete(*(void **)(v45 - 224));
  }
  operator delete();
}

void sub_100B83F04()
{
}

void *sub_100B83F18(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A409E0;
  result[1] = v3;
  return result;
}

uint64_t sub_100B83F60(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A409E0;
  a2[1] = v2;
  return result;
}

void sub_100B83F8C(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (!v4) {
      return;
    }
    __int16 v8 = 0;
    int v5 = "#I ifnet_traffic_descriptor_inet: added llFilter";
    uint64_t v6 = (uint8_t *)&v8;
  }
  else
  {
    if (!v4) {
      return;
    }
    __int16 v7 = 0;
    int v5 = "#E ifnet_traffic_descriptor_inet: failed to add llFilter";
    uint64_t v6 = (uint8_t *)&v7;
  }
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
}

uint64_t sub_100B84018(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B84058()
{
}

void sub_100B84068()
{
}

void *sub_100B8407C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A40A60;
  result[1] = v3;
  return result;
}

uint64_t sub_100B840C4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A40A60;
  a2[1] = v2;
  return result;
}

void sub_100B840F0(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (!v4) {
      return;
    }
    __int16 v8 = 0;
    int v5 = "#I ifnet_traffic_descriptor_inet: deleted llFilter";
    uint64_t v6 = (uint8_t *)&v8;
  }
  else
  {
    if (!v4) {
      return;
    }
    __int16 v7 = 0;
    int v5 = "#E ifnet_traffic_descriptor_inet: failed to delete llFilter";
    uint64_t v6 = (uint8_t *)&v7;
  }
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
}

uint64_t sub_100B8417C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B841BC()
{
}

void sub_100B841CC()
{
}

void *sub_100B841E0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A40AE0;
  result[1] = v3;
  return result;
}

uint64_t sub_100B84228(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A40AE0;
  a2[1] = v2;
  return result;
}

void sub_100B84254(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (!v4) {
      return;
    }
    __int16 v8 = 0;
    int v5 = "#I ifnet_traffic_descriptor_inet: added llFilter";
    uint64_t v6 = (uint8_t *)&v8;
  }
  else
  {
    if (!v4) {
      return;
    }
    __int16 v7 = 0;
    int v5 = "#E ifnet_traffic_descriptor_inet: failed to add llFilter";
    uint64_t v6 = (uint8_t *)&v7;
  }
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
}

uint64_t sub_100B842E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B84320()
{
}

void sub_100B84330()
{
}

void *sub_100B84344(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A40B60;
  result[1] = v3;
  return result;
}

uint64_t sub_100B8438C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A40B60;
  a2[1] = v2;
  return result;
}

void sub_100B843B8(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (!v4) {
      return;
    }
    __int16 v8 = 0;
    int v5 = "#I ifnet_traffic_descriptor_inet: deleted llFilter";
    uint64_t v6 = (uint8_t *)&v8;
  }
  else
  {
    if (!v4) {
      return;
    }
    __int16 v7 = 0;
    int v5 = "#E ifnet_traffic_descriptor_inet: failed to delete llFilter";
    uint64_t v6 = (uint8_t *)&v7;
  }
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
}

uint64_t sub_100B84444(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B84484()
{
}

void sub_100B84490(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, NSObject **a5, uint64_t a6)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, "5wi.wifi");
  a1[2] = 0;
  a1[3] = 0;
  int v9 = *a5;
  a1[4] = *a5;
  if (v9) {
    dispatch_retain(v9);
  }
  a1[5] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v12);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 6), (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
  uint64_t v10 = *(void *)(a6 + 8);
  if (v10)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 16), 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 16), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_100B847CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, char a11, int a12, __int16 a13, char a14, char a15, uint64_t a16)
{
  uint64_t v20 = (std::__shared_weak_count *)*((void *)v16 + 18);
  if (v20) {
    sub_10004D2C8(v20);
  }
  xpc_object_t v21 = (std::__shared_weak_count *)*((void *)v16 + 16);
  if (v21) {
    sub_10004D2C8(v21);
  }
  char v22 = (std::__shared_weak_count *)*((void *)v16 + 14);
  if (v22) {
    sub_10004D2C8(v22);
  }
  uint64_t v23 = (std::__shared_weak_count *)*((void *)v16 + 12);
  if (v23) {
    sub_10004D2C8(v23);
  }
  long long v24 = (std::__shared_weak_count *)*((void *)v16 + 10);
  if (v24) {
    sub_10004D2C8(v24);
  }
  uint64_t v25 = *((void *)v16 + 7);
  *((void *)v16 + 7) = 0;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  ctu::OsLogLogger::~OsLogLogger(a10);
  sub_100087E88(v18);
  sd::IMSConnectivityHelperEventDelegate::~IMSConnectivityHelperEventDelegate(v17);
  sd::IMSConnectivityHelperInterface::~IMSConnectivityHelperInterface(v16);
  _Unwind_Resume(a1);
}

void sub_100B848FC(uint64_t a1)
{
  *(void *)a1 = off_101A40BE0;
  int v2 = (sd::IMSConnectivityHelperEventDelegate *)(a1 + 8);
  *(void *)(a1 + 8) = off_101A40D18;
  uint64_t v3 = *(void *)(a1 + 224);
  *(void *)(a1 + 224) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 208);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 144);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 128);
  if (v6) {
    sub_10004D2C8(v6);
  }
  __int16 v7 = *(std::__shared_weak_count **)(a1 + 112);
  if (v7) {
    sub_10004D2C8(v7);
  }
  __int16 v8 = *(std::__shared_weak_count **)(a1 + 96);
  if (v8) {
    sub_10004D2C8(v8);
  }
  int v9 = *(std::__shared_weak_count **)(a1 + 80);
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 48));
  sub_100087E88((void *)(a1 + 16));
  sd::IMSConnectivityHelperEventDelegate::~IMSConnectivityHelperEventDelegate(v2);

  sd::IMSConnectivityHelperInterface::~IMSConnectivityHelperInterface((sd::IMSConnectivityHelperInterface *)a1);
}

void sub_100B84A4C(uint64_t a1)
{
}

void sub_100B84A54(uint64_t a1)
{
  sub_100B848FC(a1);

  operator delete();
}

void sub_100B84A8C(uint64_t a1)
{
  sub_100B848FC(a1 - 8);

  operator delete();
}

void sub_100B84AC8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100B84B64(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B84BA0(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 104) + 176))(&v7);
  int v2 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v7 + 52));
  uint64_t v3 = (capabilities::ct *)*((void *)&v7 + 1);
  if (*((void *)&v7 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v7 + 1));
  }
  BOOL v4 = (capabilities::ct *)capabilities::ct::supportsVoiceCall(v3);
  if (!v4 || (capabilities::ct::supportsCellRadio(v4) & 1) == 0)
  {
    int v5 = *v2;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = asString();
      LODWORD(v7) = 136315138;
      *(void *)((char *)&v7 + 4) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Forcing TransportType on this device: %s", (uint8_t *)&v7, 0xCu);
    }
    *(_DWORD *)(a1 + 160) = 1;
  }
}

void sub_100B84CCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B84CEC(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 144);
  *(void *)(a1 + 136) = v5;
  *(void *)(a1 + 144) = v4;
  if (v6) {
    sub_10004D2C8(v6);
  }
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 104) + 176))(&v15);
  long long v7 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v15 + 52));
  if (v16) {
    sub_10004D2C8(v16);
  }
  __int16 v8 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v15) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I start using IMSConnectivityHelperWifi", (uint8_t *)&v15, 2u);
  }
  uint64_t v9 = *a2;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 104) + 176))(&v15);
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 24);
  if (v10)
  {
    uint64_t v11 = v15;
    uint64_t v12 = *(void *)(a1 + 16);
    unsigned int v13 = std::__shared_weak_count::lock(v10);
    if (v13)
    {
      uint64_t v14 = v12 + 8;
      if (!v12) {
        uint64_t v14 = 0;
      }
      *(void *)int buf = v14;
      long long v18 = v13;
      (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v9 + 40))(v9, v11 + 24, buf);
      if (v18) {
        sub_10004D2C8(v18);
      }
      if (v16) {
        sub_10004D2C8(v16);
      }
      sub_100B8538C(a1);
    }
  }
  sub_100088B9C();
}

void sub_100B852B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  sub_1000346F8((uint64_t)&a9, a10);
  if (v22) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

void sub_100B8538C(uint64_t a1)
{
  (*(void (**)(unsigned int **__return_ptr))(**(void **)(a1 + 104) + 176))(&v25);
  int v2 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), v25[13]);
  if (v26) {
    sub_10004D2C8(v26);
  }
  uint64_t v3 = *v2;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v25) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I resend IMS Pref and proxy", (uint8_t *)&v25, 2u);
  }
  *(_DWORD *)(a1 + 156) = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 72));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    __int16 v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  char v32 = (char *)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v32);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_13:
  (*(void (**)(char **__return_ptr))(**(void **)(a1 + 104) + 176))(&v32);
  (*(void (**)(unsigned int **__return_ptr, uint64_t, char *))(*(void *)v13 + 40))(&v25, v13, v32 + 24);
  if (__dst) {
    sub_10004D2C8((std::__shared_weak_count *)__dst);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (v25)
  {
    uint64_t v15 = (sd *)(*(uint64_t (**)(unsigned int *, uint64_t))(*(void *)v25 + 152))(v25, 3);
    int v17 = sd::imsServiceMaskFromUint(v15, v16);
  }
  else
  {
    int v17 = 0;
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
  char v32 = 0;
  __dst = 0;
  unint64_t v34 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v31 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 120) + 96))(__p);
  long long v18 = (void *)HIBYTE(v31);
  if (v31 < 0) {
    long long v18 = __p[1];
  }
  uint64_t v19 = __dst;
  if (v18)
  {
    if ((unint64_t)__dst >= v34)
    {
      uint64_t v19 = (_OWORD *)sub_100048008((uint64_t *)&v32, (long long *)__p);
    }
    else
    {
      if (SHIBYTE(v31) < 0)
      {
        sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        long long v20 = *(_OWORD *)__p;
        *((void *)__dst + 2) = v31;
        _OWORD *v19 = v20;
      }
      uint64_t v19 = (_OWORD *)((char *)v19 + 24);
    }
    __dst = v19;
  }
  uint64_t v25 = (unsigned int *)a1;
  LODWORD(v26) = v17;
  uint64_t v28 = 0;
  long long v27 = 0uLL;
  sub_1000302C0((char *)&v27, (long long *)v32, v19, 0xAAAAAAAAAAAAAAABLL * (((char *)v19 - v32) >> 3));
  xpc_object_t v21 = *(std::__shared_weak_count **)(a1 + 24);
  if (v21)
  {
    char v22 = *(std::__shared_weak_count **)(a1 + 16);
    uint64_t v23 = std::__shared_weak_count::lock(v21);
    if (v23)
    {
      v29[0] = v22;
      v29[1] = v23;
      atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      long long v24 = *(std::__shared_weak_count **)(a1 + 24);
      if (v24)
      {
        if (std::__shared_weak_count::lock(v24)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_100B857F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  a9 = &a23;
  sub_100047F64((void ***)&a9);
  _Unwind_Resume(a1);
}

void sub_100B858A0(void **a1, uint64_t *a2)
{
  (*(void (**)(uint8_t *__return_ptr))(*a1[13] + 176))(buf);
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void *, void))(*a1[7] + 16))(a1[7], *(unsigned int *)(*(void *)buf + 52));
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I stop using IMSConnectivityHelperWifi", buf, 2u);
  }
  uint64_t v6 = *a2;
  (*(void (**)(uint8_t *__return_ptr))(*a1[13] + 176))(buf);
  uint64_t v7 = *(void *)buf;
  uint64_t v8 = ((uint64_t (*)(void **))(*a1)[2])(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 48))(v6, v7 + 24, v8);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100B85D98((uint64_t)a1);
}

void sub_100B85D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11, uint64_t a12, char a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  sub_1000346F8((uint64_t)&a10, a11);
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_1000346F8((uint64_t)&a13, a14);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(a1);
}

void sub_100B85D98(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v3);
      uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
      if (v4)
      {
        if (std::__shared_weak_count::lock(v4)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_100B85EB0(uint64_t a1)
{
  *(_DWORD *)(a1 + 196) = 2;
  int v2 = *(std::__shared_weak_count **)(a1 + 208);
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100B85ED0(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 104) + 176))(&v4);
  int v2 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v4 + 52));
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v3 = *v2;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Throttling PDN bringup", (uint8_t *)&v4, 2u);
  }
  ++*(_DWORD *)(a1 + 156);
}

void sub_100B85FAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B85FC4(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 104) + 176))(&v4);
  int v2 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v4 + 52));
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v3 = *v2;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Reset PDN bringup throttling", (uint8_t *)&v4, 2u);
  }
  *(_DWORD *)(a1 + 156) = 0;
}

void sub_100B86098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B860B0(uint64_t a1)
{
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 104) + 176))(buf);
  int v2 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)buf + 52));
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (validContextType())
  {
    os_log_t v3 = *v2;
    if (!os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v4 = asString();
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    uint64_t v5 = "#I PdnBringUp: Data is in activating or already up on %s";
    uint64_t v6 = v3;
    uint32_t v7 = 12;
    goto LABEL_13;
  }
  if (((*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 152))(a1, 0) & 1) == 0)
  {
    os_log_t v8 = *v2;
    if (!os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)int buf = 0;
    uint64_t v5 = "#N PdnBringUp: No connectivity to activate PDN right now.";
    goto LABEL_12;
  }
  if (*(void *)(a1 + 224))
  {
    os_log_t v8 = *v2;
    if (!os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)int buf = 0;
    uint64_t v5 = "#I PdnBringUp: There is already Pdn bring up request on the queue. Do nothing";
LABEL_12:
    uint64_t v6 = v8;
    uint32_t v7 = 2;
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, buf, v7);
    return;
  }
  unsigned int v9 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 120) + 440))(*(void *)(a1 + 120), *(unsigned int *)(a1 + 156));
  unsigned int v10 = *v2;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = asString();
    int v12 = *(_DWORD *)(a1 + 156);
    *(_DWORD *)int buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = v9;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = v11;
    __int16 v25 = 1024;
    int v26 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: Attempting pdn bring up after %u seconds. Attempt [%s] # %u", buf, 0x18u);
  }
  Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 72));
  uint64_t v13 = *(void *)buf;
  sub_100058DB0(__p, "PDP Retry timer");
  char v14 = *(NSObject **)(a1 + 32);
  dispatch_object_t object = v14;
  if (v14) {
    dispatch_retain(v14);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100B864D4;
  aBlock[3] = &unk_101A40DA8;
  aBlock[4] = a1;
  char v19 = _Block_copy(aBlock);
  sub_100118A44(v13, (uint64_t)__p, 1, 1000000 * v9, &object, &v19);
  uint64_t v15 = v23;
  uint64_t v23 = 0;
  uint64_t v16 = *(void *)(a1 + 224);
  *(void *)(a1 + 224) = v15;
  if (v16)
  {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    uint64_t v17 = v23;
    uint64_t v23 = 0;
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    }
  }
  if (v19) {
    _Block_release(v19);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_100B86468(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B864D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 224);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    uint64_t v3 = *(void *)(v1 + 224);
    *(void *)(v1 + 224) = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  if (!(*(unsigned int (**)(void))(**(void **)(v1 + 104) + 104))(*(void *)(v1 + 104)))
  {
    *(_DWORD *)(v1 + 156) = 0;
    return;
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v1 + 104) + 176))(buf);
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v1 + 56) + 16))(*(void *)(v1 + 56), *(unsigned int *)(*(void *)buf + 52));
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (validContextType())
  {
    int v5 = *(_DWORD *)(v1 + 160);
  }
  else
  {
    int v5 = *(unsigned __int8 *)(v1 + 152);
    *(_DWORD *)(v1 + 160) = v5;
  }
  uint64_t v6 = (uint64_t *)(*(_DWORD *)(v1 + 156) + 1);
  *(_DWORD *)(v1 + 156) = v6;
  if (!v5)
  {
    memset(buf, 0, sizeof(buf));
    ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(v1 + 72));
    os_log_t v8 = ServiceMap;
    if ((v9 & 0x8000000000000000) != 0)
    {
      unsigned int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        unint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v40 = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v40);
    if (v13)
    {
      uint64_t v15 = v13[3];
      char v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    char v14 = 0;
    char v16 = 1;
LABEL_27:
    (*(void (**)(unint64_t *__return_ptr))(**(void **)(v1 + 104) + 176))(&v40);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, unint64_t))(*(void *)v15 + 40))(buf, v15, v40 + 24);
    if (v41) {
      sub_10004D2C8(v41);
    }
    if ((v16 & 1) == 0) {
      sub_10004D2C8(v14);
    }
    if (*(void *)buf)
    {
      char v23 = (*(uint64_t (**)(void))(**(void **)buf + 56))(*(void *)buf);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if ((v23 & 1) != 0 && *(unsigned char *)(v1 + 216))
      {
        *(_DWORD *)(v1 + 196) = *(_DWORD *)(v1 + 160);
        long long v24 = *(uint64_t **)(v1 + 200);
        if (!v24) {
          sub_1011DEFFC(buf);
        }
        __int16 v25 = (std::mutex *)Registry::getServiceMap(v24, *(Registry **)(v1 + 72));
        int v26 = v25;
        if (v27 < 0)
        {
          uint64_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v29 = 5381;
          do
          {
            uint64_t v27 = v29;
            unsigned int v30 = *v28++;
            uint64_t v29 = (33 * v29) ^ v30;
          }
          while (v30);
        }
        std::mutex::lock(v25);
        *(void *)int buf = v27;
        uint64_t v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
        if (!v31)
        {
          std::mutex::unlock(v26);
          return;
        }
        uint64_t v33 = v31[3];
        char v32 = (std::__shared_weak_count *)v31[4];
        if (v32)
        {
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v26);
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v32);
          if (!v33) {
            goto LABEL_66;
          }
        }
        else
        {
          std::mutex::unlock(v26);
          if (!v33) {
            return;
          }
        }
        LODWORD(v40) = (*(uint64_t (**)(uint64_t))(*(void *)v33 + 776))(v33);
        uint64_t v36 = *(void *)(v1 + 136);
        if (v36 && (*(unsigned int (**)(uint64_t, unint64_t *))(*(void *)v36 + 408))(v36, &v40))
        {
          unsigned int v37 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)int buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: Cellular Internet connection is already up.", buf, 2u);
          }
          *(_DWORD *)(v1 + 192) = 2;
        }
        if (*(_DWORD *)(v1 + 192) == 2)
        {
          sub_100B86BD4(v1, *(unsigned int *)(v1 + 196));
        }
        else
        {
          unsigned int v38 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)int buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: Attempting to activate Cellular Internet.", buf, 2u);
          }
          uint64_t v39 = v40;
          sub_100058DB0(buf, "Activating internet for SIP/TLS");
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint8_t *, void, void))(*(void *)v33 + 80))(v33, v39, 1, 1, buf, 0, 0);
          if (v43 < 0) {
            operator delete(*(void **)buf);
          }
        }
        if (!v32) {
          return;
        }
LABEL_66:
        sub_10004D2C8(v32);
        return;
      }
    }
    else if (*(void *)&buf[8])
    {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    unint64_t v34 = *v4;
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v35 = asString();
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v35;
    char v19 = "#I PdnBringUp: Current iRat preference is %s, but thumper over cellular is not supported.";
    long long v20 = v34;
    goto LABEL_48;
  }
  if (v5 != 1)
  {
    os_log_t v17 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v18 = asString();
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v18;
    char v19 = "#I PdnBringUp: Current iRat preference is %s, cannot activate.";
    long long v20 = v17;
LABEL_48:
    uint32_t v22 = 12;
    goto LABEL_49;
  }
  if (*(unsigned char *)(v1 + 152))
  {
    *(_DWORD *)(v1 + 196) = 1;
    sub_100B86BD4(v1, 1);
    return;
  }
  os_log_t v21 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    char v19 = "#I PdnBringUp: iRat Suggest wifi, but Wifi is not available, cannot activate.";
    long long v20 = v21;
    uint32_t v22 = 2;
LABEL_49:
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v22);
  }
}

void sub_100B86B44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B86BD4(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 196) == a2)
  {
    (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 104) + 176))(&v8);
    uint64_t v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v8 + 52));
    if (*((void *)&v8 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
    }
    int v5 = *v4;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = asString();
      LODWORD(v8) = 136315138;
      *(void *)((char *)&v8 + 4) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Data Connection %s is Up", (uint8_t *)&v8, 0xCu);
    }
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 104) + 48))(*(void *)(a1 + 104), 1, a2);
    sub_100B879B0(a1, v7);
  }
}

void sub_100B86D38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B86D58()
{
  return 0;
}

void sub_100B86D60(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  uint64_t v4 = (uint64_t *)*(unsigned int *)(a1 + 196);
  if (v4)
  {
    if (v4 == 1) {
      std::string::operator=(a2, (const std::string *)(a1 + 168));
    }
    goto LABEL_19;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 72));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    long long v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_12:
    std::mutex::unlock(v6);
    unsigned int v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_17;
    }
LABEL_13:
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 104) + 176))(&v19);
    uint64_t v15 = PersonalityIDToSimSlot();
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, void))(*(void *)v13 + 120))(buf, v13, v15, 0);
    if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0) {
      operator delete(a2->__r_.__value_.__l.__data_);
    }
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)buf;
    a2->__r_.__value_.__r.__words[2] = v22;
    HIBYTE(v22) = 0;
    buf[0] = 0;
    if (v20) {
      sub_10004D2C8(v20);
    }
    goto LABEL_17;
  }
  uint64_t v13 = v11[3];
  unsigned int v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (v13) {
    goto LABEL_13;
  }
LABEL_17:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
LABEL_19:
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 104) + 176))(buf);
  char v16 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)buf + 52));
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  os_log_t v17 = *v16;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v18 = a2;
    }
    else {
      uint64_t v18 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I IMSNetworkInterface: %s", buf, 0xCu);
  }
}

void sub_100B87010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (*(char *)(v12 + 23) < 0) {
    operator delete(*(void **)v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B8707C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void sub_100B87088(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t sub_100B87094@<X0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, uint64_t *a6@<X8>)
{
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a6, *(Registry **)(a1 + 72));
  uint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    char v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v24 = v13;
  os_log_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v24);
  if (v17)
  {
    uint64_t v19 = v17[3];
    uint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v18 = 0;
  char v20 = 1;
LABEL_9:
  (*(void (**)(unint64_t *__return_ptr))(**(void **)(a1 + 104) + 176))(&v24);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, unint64_t))(*(void *)v19 + 40))(&v26, v19, v24 + 24);
  if (v25) {
    sub_10004D2C8(v25);
  }
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  if (v26)
  {
    unsigned int v21 = 0;
    if (!a4 && a3 && a5) {
      unsigned int v21 = (*(uint64_t (**)(void))(*(void *)v26 + 56))();
    }
  }
  else
  {
    unsigned int v21 = 0;
  }
  if (v27) {
    sub_10004D2C8(v27);
  }
  if (a4 == 1) {
    int v22 = a2;
  }
  else {
    int v22 = 0;
  }
  return v22 | v21;
}

void sub_100B87260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B872A0(uint64_t a1, int a2)
{
  uint64_t v4 = sub_100B87094(a1, *(unsigned __int8 *)(a1 + 152), *(unsigned __int8 *)(a1 + 153), *(_DWORD *)(a1 + 160), *(unsigned __int8 *)(a1 + 216), __stack_chk_guard);
  if (a2)
  {
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 104) + 176))(v13);
    int v5 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v13 + 52));
    if (*(void *)&v13[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v13[8]);
    }
    uint64_t v6 = *v5;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = asStringBool(v4);
      uint64_t v8 = asStringBool(*(unsigned char *)(a1 + 152));
      uint64_t v9 = asStringBool(*(unsigned char *)(a1 + 153));
      uint64_t v10 = asString();
      uint64_t v11 = asStringBool(*(unsigned char *)(a1 + 216));
      *(_DWORD *)unint64_t v13 = 136316162;
      *(void *)&v13[4] = v7;
      *(_WORD *)&v13[12] = 2080;
      *(void *)&v13[14] = v8;
      __int16 v14 = 2080;
      uint64_t v15 = v9;
      __int16 v16 = 2080;
      uint64_t v17 = v10;
      __int16 v18 = 2080;
      uint64_t v19 = v11;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Connectivity(%s): [WiFiAvailable(%s), CellInternetAvailable(%s), CurrentIMSIRatTransportType(%s), UserAllowsIWLanOverCell(%s)]", v13, 0x34u);
    }
  }
  return v4;
}

void sub_100B87444(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B87464(void **a1, int a2, int a3, int a4, int a5)
{
  (*(void (**)(unsigned char *__return_ptr))(*a1[13] + 176))(buf);
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void *, void))(*a1[7] + 16))(a1[7], *(unsigned int *)(*(void *)buf + 52));
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = asStringBool(*((unsigned char *)a1 + 152));
    uint64_t v10 = asStringBool(a2);
    uint64_t v11 = asStringBool(*((unsigned char *)a1 + 153));
    uint64_t v12 = asStringBool(a3);
    uint64_t v13 = asString();
    uint64_t v14 = asString();
    uint64_t v15 = asStringBool(*((unsigned char *)a1 + 216));
    uint64_t v16 = asStringBool(a5);
    *(_DWORD *)int buf = 136316930;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v10;
    __int16 v41 = 2080;
    uint64_t v42 = v11;
    __int16 v43 = 2080;
    uint64_t v44 = v12;
    __int16 v45 = 2080;
    uint64_t v46 = v13;
    __int16 v47 = 2080;
    uint64_t v48 = v14;
    __int16 v49 = 2080;
    uint64_t v50 = v15;
    __int16 v51 = 2080;
    uint64_t v52 = v16;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Change Wifi Connectivity: WiFi: %s -> %s, cellInternetAvailable: %s -> %s, iRatTransportType: %s -> %s, userAllowsIWLanOverCell: %s -> %s", buf, 0x52u);
  }
  *(void *)int buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, (Registry *)a1[9]);
  __int16 v18 = ServiceMap;
  if ((v19 & 0x8000000000000000) != 0)
  {
    char v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      unint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v38 = v19;
  char v23 = sub_10004D37C(&v18[1].__m_.__sig, &v38);
  if (v23)
  {
    uint64_t v25 = v23[3];
    unint64_t v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v18);
  unint64_t v24 = 0;
  char v26 = 1;
LABEL_13:
  (*(void (**)(unint64_t *__return_ptr))(*a1[13] + 176))(&v38);
  (*(void (**)(unsigned char *__return_ptr, uint64_t, unint64_t))(*(void *)v25 + 40))(buf, v25, v38 + 24);
  if (v39) {
    sub_10004D2C8(v39);
  }
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  uint64_t v27 = "NOT Supported";
  if (*(void *)buf && (*(unsigned int (**)(void))(**(void **)buf + 56))(*(void *)buf)) {
    uint64_t v27 = "Supported";
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v28 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v27;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Over Cellular is %s", buf, 0xCu);
  }
  int v29 = ((uint64_t (*)(void **, void))(*a1)[19])(a1, 0);
  uint64_t v31 = (capabilities::ct *)sub_100B87094((uint64_t)a1, a2, a3, a4, a5, v30);
  int v32 = (int)v31;
  *((unsigned char *)a1 + 152) = a2;
  *((unsigned char *)a1 + 153) = a3;
  uint64_t result = capabilities::ct::supportsCellRadio(v31);
  if (result) {
    *((_DWORD *)a1 + 40) = a4;
  }
  *((unsigned char *)a1 + 216) = a5;
  if (v29 != v32) {
    return sub_100B878BC(a1);
  }
  return result;
}

void sub_100B87858(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B878BC(void **a1)
{
  int v2 = ((uint64_t (*)(void **, void))(*a1)[19])(a1, 0);
  uint64_t v3 = *a1[13];
  if (v2)
  {
    (*(void (**)(void))(v3 + 16))();
    uint64_t v4 = *(uint64_t (**)(void))(*a1[13] + 32);
    return v4();
  }
  else
  {
    uint64_t v6 = *(uint64_t (**)(void))(v3 + 24);
    return v6();
  }
}

void sub_100B879B0(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 72));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v16);
  if (!v9)
  {
    std::mutex::unlock(v4);
    return;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v4);
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
    if (!v11)
    {
LABEL_16:
      sub_10004D2C8(v10);
      return;
    }
  }
  else
  {
    std::mutex::unlock(v4);
    if (!v11) {
      return;
    }
  }
  unint64_t v16 = 0;
  uint64_t v17 = 0;
  (*(void (**)(unint64_t *__return_ptr, uint64_t))(*(void *)v11 + 432))(&v16, v11);
  unint64_t v12 = v16;
  if (v16)
  {
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 104) + 176))(&v14);
    uint64_t v13 = PersonalityIDToSimSlot();
    (*(void (**)(unint64_t, uint64_t, uint64_t, uint64_t, void, const char *))(*(void *)v12 + 56))(v12, v13, 17, 1, *(unsigned int *)(a1 + 196), "ims");
    if (v15) {
      sub_10004D2C8(v15);
    }
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (v10) {
    goto LABEL_16;
  }
}

void sub_100B87B70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B87BB4(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 196) == a2)
  {
    (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 104) + 176))(&v8);
    uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v8 + 52));
    if (*((void *)&v8 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
    }
    uint64_t v4 = *v3;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = asString();
      LODWORD(v8) = 136315138;
      *(void *)((char *)&v8 + 4) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Data Connection %s is Down", (uint8_t *)&v8, 0xCu);
    }
    *(_DWORD *)(a1 + 196) = 2;
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 208);
    *(void *)(a1 + 200) = 0;
    *(void *)(a1 + 208) = 0;
    if (v6) {
      sub_10004D2C8(v6);
    }
    (*(void (**)(void))(**(void **)(a1 + 104) + 56))(*(void *)(a1 + 104));
    sub_100B879B0(a1, v7);
  }
}

void sub_100B87D1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B87D3C(uint64_t a1, int a2, uint64_t a3)
{
  memset(&__p, 0, sizeof(__p));
  if (a2 && *(void *)a3 != *(void *)(a3 + 8))
  {
    std::string::operator=(&__p, *(const std::string **)a3);
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 104) + 176))(buf);
    uint64_t v5 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)buf + 52));
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    uint64_t v6 = *v5;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = (void *)(a1 + 168);
      if (*(char *)(a1 + 191) < 0) {
        uint64_t v7 = (void *)*v7;
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fWifiInterfaceName changes from %s to %s", buf, 0x16u);
    }
    std::string::operator=((std::string *)(a1 + 168), &__p);
  }
  sub_100B87464((void **)a1, a2, *(unsigned __int8 *)(a1 + 153), *(_DWORD *)(a1 + 160), *(unsigned __int8 *)(a1 + 216));
  if ((a2 & 1) == 0)
  {
    sub_100B87BB4(a1, 1);
    if (!*(_DWORD *)(a1 + 160))
    {
      uint64_t v9 = *(std::__shared_weak_count **)(a1 + 24);
      if (v9)
      {
        uint64_t v10 = std::__shared_weak_count::lock(v9);
        if (v10)
        {
          atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v10);
          uint64_t v11 = *(std::__shared_weak_count **)(a1 + 24);
          if (v11)
          {
            if (std::__shared_weak_count::lock(v11)) {
              operator new();
            }
          }
          sub_100088B9C();
        }
      }
      sub_100088B9C();
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100B87FD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B88020(uint64_t a1, int a2, uint64_t a3)
{
}

void sub_100B88028(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (*(_DWORD *)(a1 + 64) == a2)
  {
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 104) + 176))(v18);
    uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v18 + 52));
    if (*(void *)&v18[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v18[8]);
    }
    uint64_t v7 = *v6;
    BOOL v8 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      uint64_t v9 = asString();
      *(_DWORD *)__int16 v18 = 136315138;
      *(void *)&v18[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Got iRatChange event with dataTransportType %s", v18, 0xCu);
    }
    if (a4 == 2)
    {
      if (capabilities::ct::supportsCellRadio((capabilities::ct *)v8))
      {
        a4 = 2;
      }
      else
      {
        uint64_t v10 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = asString();
          uint64_t v12 = asString();
          *(_DWORD *)__int16 v18 = 136315394;
          *(void *)&v18[4] = v11;
          *(_WORD *)&v18[12] = 2080;
          *(void *)&v18[14] = v12;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Forcing TransportType on this device: %s-->%s", v18, 0x16u);
        }
        a4 = 1;
      }
    }
    sub_100B87464((void **)a1, *(unsigned __int8 *)(a1 + 152), *(unsigned __int8 *)(a1 + 153), a4, *(unsigned __int8 *)(a1 + 216));
    if (validContextType() && validContextType() && a4 != *(_DWORD *)(a1 + 196))
    {
      char v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 136))(*(void *)(a1 + 104));
      uint64_t v14 = *v6;
      BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
      if (v13)
      {
        if (v15)
        {
          *(_WORD *)__int16 v18 = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I handleiRatChange_sync: There is an active call, do nothing", v18, 2u);
        }
      }
      else
      {
        if (v15)
        {
          uint64_t v16 = asString();
          uint64_t v17 = asString();
          *(_DWORD *)__int16 v18 = 136315394;
          *(void *)&v18[4] = v16;
          *(_WORD *)&v18[12] = 2080;
          *(void *)&v18[14] = v17;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I iRat transport type type Changed to %s, but current transport type is %s, try to bring down IMS", v18, 0x16u);
        }
        (*(void (**)(void, void))(**(void **)(a1 + 104) + 112))(*(void *)(a1 + 104), 0);
      }
    }
  }
}

void sub_100B88308(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B88328(uint64_t a1, int a2, uint64_t a3, int a4)
{
}

uint64_t sub_100B88330(uint64_t a1)
{
  uint64_t result = validContextType();
  if (result && *(_DWORD *)(a1 + 160) != *(_DWORD *)(a1 + 196))
  {
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 104) + 176))(v7);
    uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v7 + 52));
    if (*(void *)&v7[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v7[8]);
    }
    uint64_t v4 = *v3;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = asString();
      uint64_t v6 = asString();
      *(_DWORD *)uint64_t v7 = 136315394;
      *(void *)&v7[4] = v5;
      *(_WORD *)&v7[12] = 2080;
      *(void *)&v7[14] = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I iRat transport type has Changed to %s, but current transport type is %s, bring down IMS", v7, 0x16u);
    }
    return (*(uint64_t (**)(void, void))(**(void **)(a1 + 104) + 112))(*(void *)(a1 + 104), 0);
  }
  return result;
}

void sub_100B884AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B884CC(uint64_t a1)
{
  return sub_100B88330(a1 - 8);
}

uint64_t sub_100B884D4(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 104) + 176))(&v4);
  sd::isSimPersonality();
  int isFaceTimeAllowedOverCellByUser = DataUtils::isFaceTimeAllowedOverCellByUser();
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t result = sub_100B87464((void **)a1, *(unsigned __int8 *)(a1 + 152), *(unsigned __int8 *)(a1 + 153), *(_DWORD *)(a1 + 160), isFaceTimeAllowedOverCellByUser);
  if ((isFaceTimeAllowedOverCellByUser & 1) == 0 && !*(_DWORD *)(a1 + 196)) {
    return (*(uint64_t (**)(void, void))(**(void **)(a1 + 104) + 112))(*(void *)(a1 + 104), 0);
  }
  return result;
}

void sub_100B885B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B885CC(uint64_t a1)
{
  return sub_100B884D4(a1 - 8);
}

uint64_t sub_100B885D4(uint64_t a1)
{
  int v2 = ConnectionAvailabilityContainer::available();
  uint64_t v3 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "NOT available.";
    if (v2) {
      uint64_t v4 = "available.";
    }
    int v6 = 136315138;
    uint64_t v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Cellular Internet is %s", (uint8_t *)&v6, 0xCu);
  }
  return sub_100B87464((void **)a1, *(unsigned __int8 *)(a1 + 152), v2, *(_DWORD *)(a1 + 160), *(unsigned __int8 *)(a1 + 216));
}

uint64_t sub_100B886B8(uint64_t a1)
{
  return sub_100B885D4(a1 - 8);
}

void sub_100B886C0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v2 = a2 + 8;
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v6 = v2;
    do
    {
      int v7 = *(_DWORD *)(v3 + 32);
      BOOL v8 = v7 < 0;
      if (v7 >= 0) {
        uint64_t v9 = (uint64_t *)v3;
      }
      else {
        uint64_t v9 = (uint64_t *)(v3 + 8);
      }
      if (!v8) {
        uint64_t v6 = v3;
      }
      uint64_t v3 = *v9;
    }
    while (*v9);
    if (v6 != v2 && *(int *)(v6 + 32) <= 0)
    {
      int v10 = *(_DWORD *)(v6 + 44);
      int v11 = *(_DWORD *)(a1 + 192);
      if (v10 != v11)
      {
        uint64_t v12 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = 136315394;
          uint64_t v14 = asString();
          __int16 v15 = 2080;
          uint64_t v16 = asString();
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Cellular Internet %s->%s", (uint8_t *)&v13, 0x16u);
          int v11 = *(_DWORD *)(a1 + 192);
          int v10 = *(_DWORD *)(v6 + 44);
        }
        *(_DWORD *)(a1 + 192) = v10;
        if (v10 == 2)
        {
          sub_100B86BD4(a1, 0);
        }
        else if (v11 == 2)
        {
          sub_100B87BB4(a1, 0);
        }
      }
    }
  }
}

void sub_100B88810(uint64_t a1, uint64_t a2)
{
}

void sub_100B88818(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 8) & 1) != 0 && !*(_DWORD *)(a1 + 196))
  {
    (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 104) + 176))(&v6);
    uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v6 + 52));
    if (*((void *)&v6 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v6 + 1));
    }
    uint64_t v4 = *v3;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = CSIErrorString();
      LODWORD(v6) = 136315138;
      *(void *)((char *)&v6 + 4) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Activate error for internet Pdn = %s", (uint8_t *)&v6, 0xCu);
    }
    sub_100B87BB4(a1, 0);
  }
}

void sub_100B88954(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B88974(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100B8897C(uint64_t a1)
{
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 104) + 176))(buf);
  uint64_t v2 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)buf + 52));
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v3 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136315394;
    *(void *)&uint8_t buf[4] = "IMSConnectivityHelperWifi";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "IMSConnectivityHelperWifi";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I 5wi.wifi:: ----------------- %s %s ==>> -------------------", buf, 0x16u);
  }
  uint64_t v74 = 0;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v63 = 0u;
  long long v61 = 0u;
  *(_OWORD *)uint64_t v62 = 0u;
  long long v60 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_10004DE24((uint64_t)buf);
  uint64_t v4 = sub_10004B96C(buf, (uint64_t)"\t", 1);
  uint64_t v5 = sub_10004B96C(v4, (uint64_t)"AccountId", 9);
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 104) + 176))(__p);
  uint64_t v6 = *(void *)__p + 24;
  uint64_t v7 = *(unsigned __int8 *)(*(void *)__p + 47);
  int v8 = (char)v7;
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *(void *)(*(void *)__p + 32);
  }
  if (v8 < 0) {
    uint64_t v6 = *(void *)(*(void *)__p + 24);
  }
  if (v7) {
    uint64_t v9 = (const char *)v6;
  }
  else {
    uint64_t v9 = "<invalid>";
  }
  size_t v10 = strlen(v9);
  int v11 = sub_10004B96C(v5, (uint64_t)v9, v10);
  uint64_t v12 = sub_10004B96C(v11, (uint64_t)", ", 2);
  int v13 = sub_10004B96C(v12, (uint64_t)"\t", 1);
  uint64_t v14 = sub_10004B96C(v13, (uint64_t)"fIsWifiAvailable=", 17);
  __int16 v15 = (const char *)asStringBool(*(unsigned char *)(a1 + 152));
  size_t v16 = strlen(v15);
  uint64_t v17 = sub_10004B96C(v14, (uint64_t)v15, v16);
  __int16 v18 = sub_10004B96C(v17, (uint64_t)", ", 2);
  unint64_t v19 = sub_10004B96C(v18, (uint64_t)"\t", 1);
  char v20 = sub_10004B96C(v19, (uint64_t)"fIsCellInternetAvailable=", 25);
  uint64_t v21 = (const char *)asStringBool(*(unsigned char *)(a1 + 153));
  size_t v22 = strlen(v21);
  char v23 = sub_10004B96C(v20, (uint64_t)v21, v22);
  unint64_t v24 = sub_10004B96C(v23, (uint64_t)", ", 2);
  uint64_t v25 = sub_10004B96C(v24, (uint64_t)"\t", 1);
  char v26 = sub_10004B96C(v25, (uint64_t)"fCurrentIMSIRatTransportType=", 29);
  uint64_t v27 = (const char *)asString();
  size_t v28 = strlen(v27);
  int v29 = sub_10004B96C(v26, (uint64_t)v27, v28);
  unsigned int v30 = sub_10004B96C(v29, (uint64_t)", ", 2);
  uint64_t v31 = sub_10004B96C(v30, (uint64_t)"\t", 1);
  int v32 = sub_10004B96C(v31, (uint64_t)"fWifiInterfaceName=", 19);
  int v33 = *(char *)(a1 + 191);
  if (v33 >= 0) {
    uint64_t v34 = a1 + 168;
  }
  else {
    uint64_t v34 = *(void *)(a1 + 168);
  }
  if (v33 >= 0) {
    uint64_t v35 = *(unsigned __int8 *)(a1 + 191);
  }
  else {
    uint64_t v35 = *(void *)(a1 + 176);
  }
  uint64_t v36 = sub_10004B96C(v32, v34, v35);
  unsigned int v37 = sub_10004B96C(v36, (uint64_t)", ", 2);
  unint64_t v38 = sub_10004B96C(v37, (uint64_t)"\t", 1);
  sub_10004B96C(v38, (uint64_t)"fInternetConnectionState=", 25);
  uint64_t v39 = (void *)std::ostream::operator<<();
  unint64_t v40 = sub_10004B96C(v39, (uint64_t)", ", 2);
  __int16 v41 = sub_10004B96C(v40, (uint64_t)"\t", 1);
  uint64_t v42 = sub_10004B96C(v41, (uint64_t)"fCurrentTransportType=", 22);
  __int16 v43 = (const char *)asString();
  size_t v44 = strlen(v43);
  __int16 v45 = sub_10004B96C(v42, (uint64_t)v43, v44);
  uint64_t v46 = sub_10004B96C(v45, (uint64_t)", ", 2);
  __int16 v47 = sub_10004B96C(v46, (uint64_t)"\t", 1);
  uint64_t v48 = sub_10004B96C(v47, (uint64_t)"fUserAllowsIWLanOverCell=", 25);
  __int16 v49 = (const char *)asStringBool(*(unsigned char *)(a1 + 216));
  size_t v50 = strlen(v49);
  __int16 v51 = sub_10004B96C(v48, (uint64_t)v49, v50);
  std::ios_base::getloc((const std::ios_base *)((char *)v51 + *(void *)(*v51 - 24)));
  uint64_t v52 = std::locale::use_facet(v58, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v52->__vftable[2].~facet_0)(v52, 10);
  std::locale::~locale(v58);
  std::ostream::put();
  std::ostream::flush();
  if (*(void *)&__p[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
  }
  int v53 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)&buf[8], __p);
    if (v57 >= 0) {
      uint64_t v54 = (std::locale::__imp *)__p;
    }
    else {
      uint64_t v54 = *(std::locale::__imp **)__p;
    }
    LODWORD(v58[0].__locale_) = 136315138;
    *(std::locale::__imp **)((char *)&v58[0].__locale_ + 4) = v54;
    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I 5wi.wifi:: %s", (uint8_t *)v58, 0xCu);
    if (v57 < 0) {
      operator delete(*(void **)__p);
    }
    int v53 = *v2;
  }
  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = "IMSConnectivityHelperWifi";
    *(_WORD *)&__p[12] = 2080;
    *(void *)&__p[14] = "IMSConnectivityHelperWifi";
    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I 5wi.wifi:: ------------ <<== %s %s ------------------------", __p, 0x16u);
  }
  if (SHIBYTE(v63) < 0) {
    operator delete(v62[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100B88FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::locale a15, uint64_t a16, char a17, uint64_t a18)
{
}

uint64_t sub_100B8904C()
{
  return 1;
}

uint64_t sub_100B89058()
{
  return 0;
}

uint64_t sub_100B8908C()
{
  return 1;
}

void *sub_100B890B4(void *a1)
{
  *a1 = off_101A40EB0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B89100(void *a1)
{
  *a1 = off_101A40EB0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100B8916C(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A40EB0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B891C8(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A40EB0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B89200(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B89210(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

const char *sub_100B89250(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(unsigned __int8 **)(a1 + 8);
      if (!v4) {
        goto LABEL_9;
      }
      int v5 = *((_DWORD *)v4 + 1);
      if (v5 < 0)
      {
        uint64_t v7 = "5wi.wifi.x.X";
        goto LABEL_12;
      }
      int v6 = *v4;
      if (v6 == 2)
      {
        uint64_t v7 = "5wi.wifi.M";
        goto LABEL_12;
      }
      if (v6 == 1) {
        uint64_t v7 = off_101A40F10[v5 & 0xF];
      }
      else {
LABEL_9:
      }
        uint64_t v7 = "5wi.wifi.?";
LABEL_12:
      sub_10004D2C8(v3);
      return v7;
    }
  }
  return "5wi.wifi.?";
}

uint64_t sub_100B892EC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B8932C()
{
}

void sub_100B89338(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100B89404(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[4], v1, (dispatch_function_t)sub_100B894DC);
  __cxa_rethrow();
}

void sub_100B8942C(_Unwind_Exception *a1)
{
}

void sub_100B89444(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100B8947C(uint64_t a1)
{
}

uint64_t sub_100B89498(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100B894DC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_100B89508(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100B89560(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100B89548(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100B89560(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    int v5 = (uint64_t **)result;
    int v6 = result + 1;
    do
    {
      uint64_t result = sub_100602B88(v5, v6, v4 + 7, v4 + 7);
      uint64_t v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          uint64_t v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100B895EC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v19 = a1;
  uint64_t v20 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 40);
  if (v2)
  {
    uint64_t v3 = *(Registry ***)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      int v6 = *(uint64_t **)(v1 + 32);
      if (!v6)
      {
LABEL_14:
        sub_10004D2C8(v5);
        goto LABEL_15;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v6, v3[9]);
      int v8 = ServiceMap;
      if ((v9 & 0x8000000000000000) != 0)
      {
        size_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          unint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v21 = v9;
      int v13 = sub_10004D37C(&v8[1].__m_.__sig, &v21);
      if (v13)
      {
        uint64_t v15 = v13[3];
        uint64_t v14 = (std::__shared_weak_count *)v13[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          char v16 = 0;
          goto LABEL_12;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v8);
      uint64_t v14 = 0;
      char v16 = 1;
LABEL_12:
      uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 16))(v15);
      (*((void (**)(Registry **, uint64_t, uint64_t))*v3 + 32))(v3, v17, v1 + 8);
      if ((v16 & 1) == 0) {
        sub_10004D2C8(v14);
      }
      goto LABEL_14;
    }
  }
LABEL_15:
  sub_100B897A8(&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_100B89770(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v6 = va_arg(va1, void);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  sub_10004D2C8(v2);
  sub_100B897A8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B897A8(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 40);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    char v3 = (void **)(v1 + 8);
    sub_100047F64(&v3);
    operator delete();
  }
  return result;
}

uint64_t *sub_100B89814(void **a1)
{
  uint64_t v1 = *a1;
  int v8 = a1;
  unint64_t v9 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (v1[1])
      {
        uint64_t v6 = *(void *)(v3 + 104);
        uint64_t v10 = 2;
        int v11 = 0;
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 72))(v6, &v10);
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100004A84((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100B898BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B898E0(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  int v8 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (v1[1]) {
        sub_100B87BB4(v3, *(_DWORD *)(v3 + 196));
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100004A84((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100B89958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B8997C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (*(void *)(v1 + 40))
      {
        uint64_t v6 = *(void *)(v3 + 104);
        std::string __p = (void *)1;
        int v12 = *(_DWORD *)(v1 + 8);
        (*(void (**)(uint64_t, void **))(*(void *)v6 + 72))(v6, &__p);
        uint64_t v7 = *(void *)(v3 + 104);
        sub_100058DB0(&__p, "");
        (*(void (**)(uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v7 + 96))(v7, v1 + 16, 1, &__p, 0, 0);
        if (v13 < 0) {
          operator delete(__p);
        }
        sub_100B878BC((void **)v3);
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100B89AD4(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_100B89A90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  sub_10004D2C8(v17);
  sub_100B89AD4(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B89AD4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 48);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    uint64_t v3 = (void **)(v1 + 16);
    sub_100047F64(&v3);
    operator delete();
  }
  return result;
}

uint64_t *sub_100B89B40(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  int v8 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (v1[1] && *(_DWORD *)(v3 + 192) == 2) {
        sub_100B860B0(v3);
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100004A84((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100B89BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100B89BE4(Registry **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *a1);
  int v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
  if (!v13)
  {
    std::mutex::unlock(v8);
    return;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v8);
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v14);
    if (!v15)
    {
LABEL_34:
      sub_10004D2C8(v14);
      return;
    }
  }
  else
  {
    std::mutex::unlock(v8);
    if (!v15) {
      return;
    }
  }
  CFTypeRef cf = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v29 = *(void *)(a2 + 16);
  }
  (*(void (**)(void **__return_ptr, uint64_t, void **, uint64_t, const __CFString *, void, uint64_t))(*(void *)v15 + 24))(v25, v15, __p, a3, @"EnhancedThroughput", 0, 4);
  sub_100044D6C(&cf, (CFTypeRef *)v25);
  sub_1000577C4((const void **)v25);
  if (SHIBYTE(v29) < 0) {
    operator delete(__p[0]);
  }
  if (cf) {
    char v16 = sub_100083F10;
  }
  else {
    char v16 = 0;
  }
  if (v16)
  {
    CFTypeID v17 = CFGetTypeID(cf);
    if (v17 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, i);
          if (ValueAtIndex)
          {
            CFTypeID v21 = CFGetTypeID(ValueAtIndex);
            if (v21 == CFStringGetTypeID())
            {
              v25[0] = 0;
              v25[1] = 0;
              uint64_t v26 = 0;
              __p[0] = 0;
              __p[1] = 0;
              uint64_t v29 = 0;
              ctu::cf::assign();
              *(_OWORD *)uint64_t v25 = *(_OWORD *)__p;
              uint64_t v26 = v29;
              unint64_t v22 = a4[1];
              if (v22 >= a4[2])
              {
                uint64_t v24 = sub_1000D8CE8(a4, (long long *)v25);
              }
              else
              {
                if (SHIBYTE(v26) < 0)
                {
                  sub_10004FC84((unsigned char *)a4[1], v25[0], (unint64_t)v25[1]);
                }
                else
                {
                  long long v23 = *(_OWORD *)v25;
                  *(void *)(v22 + 16) = v26;
                  *(_OWORD *)unint64_t v22 = v23;
                }
                uint64_t v24 = v22 + 24;
                a4[1] = v22 + 24;
              }
              a4[1] = v24;
              if (SHIBYTE(v26) < 0) {
                operator delete(v25[0]);
              }
            }
          }
        }
      }
    }
  }
  sub_100044D00(&cf);
  if (v14) {
    goto LABEL_34;
  }
}

void sub_100B89E90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_100044D00(&a15);
  if (v21) {
    sub_10004D2C8(v21);
  }
  sub_100047F64((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_100B89F38(Registry **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, long long **a4@<X3>, uint64_t *a5@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a5, *a1);
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)__p);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_36;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
  if (!v16) {
    goto LABEL_36;
  }
LABEL_10:
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  unint64_t v19 = *a4;
  __int16 v18 = a4[1];
  while (v19 != v18)
  {
    uint64_t v24 = 0;
    if (*((char *)v19 + 23) < 0)
    {
      sub_10004FC84(v22, *(void **)v19, *((void *)v19 + 1));
    }
    else
    {
      long long v20 = *v19;
      uint64_t v23 = *((void *)v19 + 2);
      *(_OWORD *)unint64_t v22 = v20;
    }
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(__dst, v22[0], (unint64_t)v22[1]);
    }
    else
    {
      *(_OWORD *)__dst = *(_OWORD *)v22;
      uint64_t v28 = v23;
    }
    uint64_t v26 = 0;
    if (SHIBYTE(v28) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v30 = v28;
    }
    uint64_t v31 = 0;
    if (ctu::cf::convert_copy())
    {
      CFTypeID v21 = v26;
      uint64_t v26 = v31;
      int v32 = v21;
      sub_1000558F4(&v32);
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v24 = v26;
    uint64_t v26 = 0;
    sub_1000558F4(&v26);
    if (SHIBYTE(v28) < 0) {
      operator delete(__dst[0]);
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(v22[0]);
    }
    CFArrayAppendValue(Mutable, v24);
    sub_1000558F4(&v24);
    unint64_t v19 = (long long *)((char *)v19 + 24);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v30 = *(void *)(a2 + 16);
  }
  (*(void (**)(uint64_t, void **, uint64_t, __CFArray *, const __CFString *, void, uint64_t, void))(*(void *)v16 + 16))(v16, __p, a3, Mutable, @"EnhancedThroughput", 0, 4, 0);
  if (SHIBYTE(v30) < 0) {
    operator delete(__p[0]);
  }
  sub_1000440D4((const void **)&Mutable);
LABEL_36:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_100B8A1F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  sub_1000440D4(&a17);
  if ((v34 & 1) == 0) {
    sub_10004D2C8(v33);
  }
  _Unwind_Resume(a1);
}

void sub_100B8A2A0(std::string *a1, uint64_t a2)
{
  md = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10008E4E8(&md, 0x20uLL);
  if (*(char *)(a2 + 23) < 0)
  {
    int v5 = *(const void **)a2;
    uint64_t v4 = *(void *)(a2 + 8);
  }
  else
  {
    LODWORD(v4) = *(unsigned __int8 *)(a2 + 23);
    int v5 = (const void *)a2;
  }
  if (CC_SHA256(v5, v4, md))
  {
    ctu::base64::encode();
  }
  else
  {
    unint64_t v6 = sub_100206390((uint64_t)&v7, a2);
    std::to_string(a1, v6);
  }
  if (md)
  {
    uint64_t v9 = md;
    operator delete(md);
  }
}

void sub_100B8A338(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B8A358(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)__p, kCtLoggingSystemName, "lazuli.store");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v19, (const OsLogContext *)__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)__p);
  v20[0] = off_101999E18;
  v20[1] = sub_100B8A79C;
  v20[3] = v20;
  *(void *)(a1 + 8) = 0;
  if ((capabilities::ct::supportsGemini(v12) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 8)) {
    operator new();
  }
  sub_10008863C(v20);
  *(_DWORD *)(a1 + 16) = a2;
  unsigned int v13 = *(Registry **)a3;
  *(void *)(a1 + 24) = *(void *)a3;
  uint64_t v14 = *(void *)(a3 + 8);
  *(void *)(a1 + 32) = v14;
  if (v14)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
    uint64_t v15 = *(std::__shared_weak_count **)(a1 + 32);
    char v17 = *(Registry **)(a1 + 24);
    __int16 v18 = v15;
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    char v17 = v13;
    __int16 v18 = 0;
  }
  sub_100562274(&v17, (uint64_t)__p);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)__p;
  *(void *)(a1 + 56) = v22;
  __p[1] = 0;
  uint64_t v22 = 0;
  __p[0] = 0;
  ctu::path_join_impl();
  ctu::path_join_impl();
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  Registry::getFileSystemInterface((uint64_t *)(a1 + 88), *(Registry **)(a1 + 24));
  *(void *)(a1 + 104) = a6;
  *(void *)(a1 + 112) = a7;
  if (!*(void *)(a1 + 88)) {
    __TUAssertTrigger();
  }
  return a1;
}

void sub_100B8A644(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

const char *sub_100B8A79C(int a1)
{
  uint64_t v1 = "lazuli.store.?";
  if (a1 == 2) {
    uint64_t v1 = "lazuli.store.2";
  }
  if (a1 == 1) {
    return "lazuli.store.1";
  }
  else {
    return v1;
  }
}

void sub_100B8A7C8(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 40);
  uint64_t v3 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 112))(*(void *)(a1 + 88), a1 + 40);
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 63) < 0) {
        uint64_t v2 = (void *)*v2;
      }
      int v5 = 136446466;
      unint64_t v6 = v2;
      __int16 v7 = 2048;
      uint64_t v8 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Erase failed: %{public}s with error: %ld", (uint8_t *)&v5, 0x16u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 63) < 0) {
      uint64_t v2 = (void *)*v2;
    }
    int v5 = 136446210;
    unint64_t v6 = v2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Erased: %{public}s", (uint8_t *)&v5, 0xCu);
  }
}

const void **sub_100B8A938(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v4 = *a2;
  unsigned int v13 = 0;
  *(void *)dispatch_object_t object = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    *(void *)dispatch_object_t object = xpc_null_create();
  }
  xpc::bridge((uint64_t *)__p, (xpc *)object, v5);
  sub_10004EFE4(&v13, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  xpc_release(*(xpc_object_t *)object);
  if (v13) {
    unint64_t v6 = sub_100080778;
  }
  else {
    unint64_t v6 = 0;
  }
  if (v6)
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v12 = 0;
    if (*(char *)(a1 + 63) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 40);
      uint64_t v12 = *(void *)(a1 + 56);
    }
    ctu::path_join_impl();
    if ((*(uint64_t (**)(void, void **, const void *))(**(void **)(a1 + 88) + 184))(*(void *)(a1 + 88), __p, v13))goto LABEL_18; {
    __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    }
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      goto LABEL_18;
    }
    *(_DWORD *)dispatch_object_t object = 138477827;
    *(void *)&object[4] = v13;
    uint64_t v9 = "Failed to store: %{private}@";
  }
  else
  {
    __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return sub_100057D78(&v13);
    }
    sub_100120074(a2, __p);
    if (v12 >= 0) {
      uint64_t v8 = __p;
    }
    else {
      uint64_t v8 = (void **)__p[0];
    }
    *(_DWORD *)dispatch_object_t object = 136380675;
    *(void *)&object[4] = v8;
    uint64_t v9 = "Failed to convert to CF type: %{private}s";
  }
  _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v9, object, 0xCu);
LABEL_18:
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  return sub_100057D78(&v13);
}

void sub_100B8AB8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, xpc_object_t object)
{
}

void sub_100B8AC04(uint64_t a1, uint64_t a2, xpc_object_t *a3)
{
  xpc_object_t v27 = 0;
  sub_100B8B028(a1, &v27);
  xpc_type_t type = xpc_get_type(*a3);
  __int16 v7 = *(uint64_t (**)(void))(**(void **)(a1 + 8) + 16);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v9 = *(NSObject **)v7();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) < 0) {
        sub_10004FC84(&__dst, *(void **)a2, *(void *)(a2 + 8));
      }
      else {
        std::string __dst = *(std::string *)a2;
      }
      int v16 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
      std::string::size_type v17 = __dst.__r_.__value_.__r.__words[0];
      sub_100B8A2A0(&__p, a2);
      p_dst = &__dst;
      if (v16 < 0) {
        p_dst = (std::string *)v17;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int buf = 136380931;
      uint64_t v29 = p_dst;
      __int16 v30 = 2081;
      uint64_t v31 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Storing [%{private}s] => [%{private}s]", buf, 0x16u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    xpc_object_t v20 = *a3;
    xpc_object_t v23 = v20;
    if (v20) {
      xpc_retain(v20);
    }
    else {
      xpc_object_t v23 = xpc_null_create();
    }
    sub_100B8A2A0(&__dst, a2);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFTypeID v21 = &__dst;
    }
    else {
      CFTypeID v21 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v27;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)v21;
    sub_10014E03C((uint64_t)&__p, &v23, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    xpc_release(v23);
    xpc_object_t v23 = 0;
  }
  else
  {
    uint64_t v8 = *(NSObject **)v7();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) < 0) {
        sub_10004FC84(&__dst, *(void **)a2, *(void *)(a2 + 8));
      }
      else {
        std::string __dst = *(std::string *)a2;
      }
      int v10 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = __dst.__r_.__value_.__r.__words[0];
      sub_100B8A2A0(&__p, a2);
      uint64_t v12 = &__dst;
      if (v10 < 0) {
        uint64_t v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unsigned int v13 = &__p;
      }
      else {
        unsigned int v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int buf = 136380931;
      uint64_t v29 = v12;
      __int16 v30 = 2081;
      uint64_t v31 = v13;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Erasing [%{private}s] => [%{private}s]", buf, 0x16u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    xpc_object_t v14 = v27;
    sub_100B8A2A0(&__dst, a2);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v15 = &__dst;
    }
    else {
      uint64_t v15 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    xpc_dictionary_set_value(v14, (const char *)v15, 0);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  xpc_object_t v22 = v27;
  if (v27) {
    xpc_retain(v27);
  }
  else {
    xpc_object_t v22 = xpc_null_create();
  }
  sub_100B8A938(a1, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v27);
}

void sub_100B8AF7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,xpc_object_t object)
{
}

const void **sub_100B8B028@<X0>(uint64_t a1@<X0>, void **a2@<X8>)
{
  xpc_object_t v4 = (uint64_t *)(a1 + 40);
  if (((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 88))(*(void *)(a1 + 88), a1 + 40) & 1) == 0)
  {
    uint64_t v5 = a1 + 40;
    if (*(char *)(a1 + 63) < 0) {
      uint64_t v5 = *v4;
    }
    int v6 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 88) + 72))(*(void *)(a1 + 88), v5, 511, 1);
    __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (v6)
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        uint64_t v8 = a1 + 40;
        if (*(char *)(a1 + 63) < 0) {
          uint64_t v8 = *v4;
        }
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = v8;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed creating storage: %{public}s error: %d", buf, 0x12u);
      }
    }
    else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = a1 + 40;
      if (*(char *)(a1 + 63) < 0) {
        uint64_t v9 = *v4;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Directory created: %{public}s", buf, 0xCu);
    }
  }
  *a2 = 0;
  xpc_object_t v10 = xpc_null_create();
  *a2 = v10;
  CFTypeID v21 = 0;
  memset(buf, 0, sizeof(buf));
  uint64_t v11 = *(void *)(a1 + 88);
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(buf, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    *(_OWORD *)int buf = *(_OWORD *)v4;
    *(void *)&uint8_t buf[16] = *(void *)(a1 + 56);
  }
  ctu::path_join_impl();
  (*(void (**)(ctu **__return_ptr, uint64_t, uint8_t *))(*(void *)v11 + 152))(&v21, v11, buf);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  if (v21) {
    unsigned int v13 = sub_100080778;
  }
  else {
    unsigned int v13 = 0;
  }
  if (v13)
  {
    ctu::cf_to_xpc((uint64_t *)buf, v21, v12);
    xpc_object_t v14 = *(xpc_object_t *)buf;
    if (*(void *)buf && xpc_get_type(*(xpc_object_t *)buf) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_retain(v14);
    }
    else {
      xpc_object_t v14 = xpc_null_create();
    }
    xpc_object_t v17 = xpc_null_create();
    *a2 = v14;
    xpc_release(v10);
    xpc_release(v17);
    xpc_release(*(xpc_object_t *)buf);
  }
  else
  {
    xpc_object_t v15 = xpc_dictionary_create(0, 0, 0);
    if (v15 || (xpc_object_t v15 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v15) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v15);
        xpc_object_t v16 = v15;
      }
      else
      {
        xpc_object_t v16 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v16 = xpc_null_create();
      xpc_object_t v15 = 0;
    }
    xpc_release(v15);
    xpc_object_t v18 = xpc_null_create();
    unint64_t v19 = *a2;
    *a2 = v16;
    xpc_release(v19);
    xpc_release(v18);
  }
  return sub_100057D78((const void **)&v21);
}

void sub_100B8B398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100B8B41C(uint64_t a1@<X0>, uint64_t a2@<X1>, xpc_object_t *a3@<X8>)
{
  xpc_object_t object = 0;
  sub_100B8B028(a1, &object);
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    *a3 = xpc_null_create();
    goto LABEL_28;
  }
  memset(&__p, 0, sizeof(__p));
  sub_100B8A2A0(&__p, a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  v12[0] = &object;
  v12[1] = p_p;
  sub_100048BAC((uint64_t)v12, &v13);
  xpc_object_t v6 = xpc_null_create();
  xpc_object_t v7 = v13;
  if (v13 && xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  if (xpc_get_type(v7) != (xpc_type_t)&_xpc_type_dictionary)
  {
    if (v6)
    {
      xpc_retain(v6);
      xpc_object_t v8 = v6;
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
    }
    xpc_release(v7);
    xpc_object_t v7 = v8;
  }
  xpc_release(v6);
  xpc_release(v13);
  if (xpc_get_type(v7) != (xpc_type_t)&_xpc_type_dictionary)
  {
    *a3 = xpc_null_create();
    goto LABEL_26;
  }
  xpc_object_t v9 = xpc_copy(v7);
  xpc_object_t v10 = v9;
  if (v9)
  {
    *a3 = v9;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    *a3 = v10;
    if (!v10)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v10 = 0;
      goto LABEL_24;
    }
  }
  if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v11 = xpc_null_create();
LABEL_24:
    *a3 = v11;
    goto LABEL_25;
  }
  xpc_retain(v10);
LABEL_25:
  xpc_release(v10);
LABEL_26:
  xpc_release(v7);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_28:
  xpc_release(object);
}

void sub_100B8B5E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, xpc_object_t object)
{
  xpc_release(v19);
  if (a18 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_100B8B688(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = xpc_null_create();
  xpc_object_t v5 = v4;
  sub_100B8AC04(a1, a2, &v5);
  xpc_release(v4);
}

void sub_100B8B6E4(_Unwind_Exception *a1)
{
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_100B8B700(uint64_t a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t object = 0;
  sub_100B8B41C(a1, a2, &object);
  xpc_object_t v6 = object;
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a3;
      uint64_t v11 = *(void *)(a3 + 16);
    }
    if (v11 >= 0) {
      xpc_object_t v7 = __p;
    }
    else {
      xpc_object_t v7 = (void **)__p[0];
    }
    xpc_dictionary_set_value(v6, (const char *)v7, 0);
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[0]);
    }
    xpc_object_t v9 = v6;
    if (v6)
    {
      xpc_retain(v6);
      xpc_object_t v8 = v6;
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v9 = v8;
    }
    sub_100B8AC04(a1, a2, &v9);
    xpc_release(v8);
    xpc_object_t v9 = 0;
  }
  xpc_release(v6);
}

void sub_100B8B800(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_100B8B858(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_100B8B920((os_log_t *)a1, a2, a3);
  char v8 = v7;
  unint64_t v9 = sub_100B8BAB0((os_log_t *)a1, a2, a3);
  if (v8)
  {
    if (v10)
    {
      int64_t v11 = v9;
      uint64_t v12 = *(std::__shared_weak_count **)(a1 + 32);
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v13 = (uint64_t)((double)std::chrono::system_clock::now().__d_.__rep_ / 1000000.0);
      if (v12) {
        sub_10004D2C8(v12);
      }
      BOOL v14 = (uint64_t)(v13 - v6) >= v11;
    }
    else
    {
      BOOL v14 = 0;
    }
    int v15 = 1;
  }
  else
  {
    BOOL v14 = 0;
    int v15 = 0;
  }
  return v14 | (v15 << 8);
}

unint64_t sub_100B8B920(os_log_t *a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t xdict = 0;
  uint64_t v17 = 0;
  sub_100B8BCF4(a1, a2, a3, (uint64_t)&xdict);
  if (!(_BYTE)v17)
  {
    uint64_t v6 = 0;
LABEL_19:
    unint64_t v10 = 0;
    goto LABEL_20;
  }
  sub_100058DB0(__p, "created");
  if (v15 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  xpc_object_t value = xpc_dictionary_get_value(xdict, (const char *)v3);
  xpc_object_t v5 = value;
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if (!v5) {
      goto LABEL_18;
    }
  }
  else if (!value)
  {
    goto LABEL_18;
  }
  if (!(_BYTE)v17) {
    sub_10016C840();
  }
  sub_100058DB0(__p, "created");
  if (v15 >= 0) {
    char v7 = __p;
  }
  else {
    char v7 = (void **)__p[0];
  }
  v12[0] = &xdict;
  v12[1] = v7;
  sub_100048BAC((uint64_t)v12, &object);
  uint64_t v9 = xpc::dyn_cast_or_default((xpc *)&object, 0, v8);
  xpc_release(object);
  xpc_object_t object = 0;
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if (v9) {
      goto LABEL_16;
    }
LABEL_18:
    uint64_t v6 = 0;
    goto LABEL_19;
  }
  if (!v9) {
    goto LABEL_18;
  }
LABEL_16:
  unint64_t v10 = v9 & 0xFFFFFFFFFFFFFF00;
  uint64_t v6 = v9;
LABEL_20:
  sub_100179294((uint64_t)&xdict);
  return v10 | v6;
}

void sub_100B8BA60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100179294((uint64_t)&a18);
  _Unwind_Resume(a1);
}

unint64_t sub_100B8BAB0(os_log_t *a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t xdict = 0;
  uint64_t v17 = 0;
  sub_100B8BCF4(a1, a2, a3, (uint64_t)&xdict);
  if (!(_BYTE)v17)
  {
    uint64_t v6 = 0;
LABEL_19:
    unint64_t v10 = 0;
    goto LABEL_20;
  }
  sub_100058DB0(__p, "validity");
  if (v15 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  xpc_object_t value = xpc_dictionary_get_value(xdict, (const char *)v3);
  xpc_object_t v5 = value;
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if (!v5) {
      goto LABEL_18;
    }
  }
  else if (!value)
  {
    goto LABEL_18;
  }
  if (!(_BYTE)v17) {
    sub_10016C840();
  }
  sub_100058DB0(__p, "validity");
  if (v15 >= 0) {
    char v7 = __p;
  }
  else {
    char v7 = (void **)__p[0];
  }
  v12[0] = &xdict;
  v12[1] = v7;
  sub_100048BAC((uint64_t)v12, &object);
  uint64_t v9 = xpc::dyn_cast_or_default((xpc *)&object, 0, v8);
  xpc_release(object);
  xpc_object_t object = 0;
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if (v9) {
      goto LABEL_16;
    }
LABEL_18:
    uint64_t v6 = 0;
    goto LABEL_19;
  }
  if (!v9) {
    goto LABEL_18;
  }
LABEL_16:
  unint64_t v10 = v9 & 0xFFFFFFFFFFFFFF00;
  uint64_t v6 = v9;
LABEL_20:
  sub_100179294((uint64_t)&xdict);
  return v10 | v6;
}

void sub_100B8BBF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100179294((uint64_t)&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_100B8BC40(os_log_t *a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t object = 0;
  uint64_t v9 = 0;
  sub_100B8BCF4(a1, a2, a3, (uint64_t)&object);
  if ((_BYTE)v9)
  {
    xpc_object_t v5 = object;
    xpc_object_t v7 = object;
    if (object)
    {
      xpc_retain(object);
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v7 = v5;
    }
    sub_100B8AC04((uint64_t)a1, a2, &v7);
    xpc_release(v5);
  }
  return sub_100179294((uint64_t)&object);
}

void sub_100B8BCD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  xpc_release(v11);
  sub_100179294((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_100B8BCF4(os_log_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v28 = *(void *)(a2 + 16);
    }
    int v9 = SHIBYTE(v28);
    unint64_t v10 = (void **)__dst[0];
    sub_100B8A2A0(&__p, a2);
    int64_t v11 = __dst;
    if (v9 < 0) {
      int64_t v11 = v10;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int buf = 136315394;
    *(void *)&uint8_t buf[4] = v11;
    __int16 v30 = 2080;
    uint64_t v31 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Reading key: [%s] ==> [%s]", buf, 0x16u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v28) < 0) {
      operator delete(__dst[0]);
    }
  }
  xpc_object_t object = 0;
  sub_100B8B41C((uint64_t)a1, a2, &object);
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary) {
    goto LABEL_15;
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a3;
    uint64_t v28 = *(void *)(a3 + 16);
  }
  if (v28 >= 0) {
    uint64_t v13 = __dst;
  }
  else {
    uint64_t v13 = (void **)__dst[0];
  }
  xpc_object_t value = xpc_dictionary_get_value(object, (const char *)v13);
  if (SHIBYTE(v28) < 0) {
    operator delete(__dst[0]);
  }
  if (value)
  {
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a3;
      uint64_t v28 = *(void *)(a3 + 16);
    }
    char v15 = __dst;
    if (v28 < 0) {
      char v15 = (void **)__dst[0];
    }
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&object;
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)v15;
    sub_100048BAC((uint64_t)&__p, buf);
    xpc_object_t v16 = xpc_null_create();
    xpc_object_t v17 = *(xpc_object_t *)buf;
    if (*(void *)buf && xpc_get_type(*(xpc_object_t *)buf) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_retain(v17);
    }
    else {
      xpc_object_t v17 = xpc_null_create();
    }
    if (xpc_get_type(v17) != (xpc_type_t)&_xpc_type_dictionary)
    {
      if (v16)
      {
        xpc_retain(v16);
        xpc_object_t v18 = v16;
      }
      else
      {
        xpc_object_t v18 = xpc_null_create();
      }
      xpc_release(v17);
      xpc_object_t v17 = v18;
    }
    xpc_release(v16);
    xpc_release(*(xpc_object_t *)buf);
    *(void *)int buf = 0;
    if (SHIBYTE(v28) < 0) {
      operator delete(__dst[0]);
    }
    if (xpc_get_type(v17) == (xpc_type_t)&_xpc_type_dictionary)
    {
      *(void *)a4 = v17;
      xpc_object_t v17 = xpc_null_create();
      char v20 = 1;
    }
    else
    {
      unint64_t v19 = *a1;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a3 + 23) < 0)
        {
          sub_10004FC84(__dst, *(void **)a3, *(void *)(a3 + 8));
        }
        else
        {
          *(_OWORD *)std::string __dst = *(_OWORD *)a3;
          uint64_t v28 = *(void *)(a3 + 16);
        }
        int v21 = SHIBYTE(v28);
        xpc_object_t v22 = (void **)__dst[0];
        xpc::object::to_string((uint64_t *)&__p, (xpc::object *)&object);
        xpc_object_t v23 = __dst;
        if (v21 < 0) {
          xpc_object_t v23 = v22;
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v24 = &__p;
        }
        else {
          uint64_t v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)int buf = 136380931;
        *(void *)&uint8_t buf[4] = v23;
        __int16 v30 = 2081;
        uint64_t v31 = v24;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid key (not stored as dict) %{private}s in %{private}s", buf, 0x16u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v28) < 0) {
          operator delete(__dst[0]);
        }
      }
      char v20 = 0;
      *(unsigned char *)a4 = 0;
    }
    *(unsigned char *)(a4 + 8) = v20;
    xpc_release(v17);
  }
  else
  {
LABEL_15:
    *(unsigned char *)a4 = 0;
    *(unsigned char *)(a4 + 8) = 0;
  }
  xpc_release(object);
}

void sub_100B8C0C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, xpc_object_t a20)
{
  xpc_release(v20);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_100B8C1B4()
{
}

uint64_t sub_100B8C1C8(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_100B8C1D0@<X0>(int *a1@<X1>, uint64_t *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t *a5@<X5>, void *a6@<X8>)
{
  uint64_t v12 = operator new(0x90uLL);
  uint64_t result = sub_100B8C25C(v12, a1, a2, a3, a4, a5);
  *a6 = v12 + 3;
  a6[1] = v12;
  return result;
}

void sub_100B8C248(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100B8C25C(void *a1, int *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A41050;
  sub_100B8C3CC((uint64_t)(a1 + 3), a2, a3, a4, a5, a6);
  return a1;
}

void sub_100B8C2A4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100B8C2B8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A41050;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100B8C2D8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A41050;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100B8C32C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 120);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
}

uint64_t sub_100B8C3CC(uint64_t a1, int *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  int v7 = *a2;
  uint64_t v8 = (std::__shared_weak_count *)a3[1];
  uint64_t v10 = *a3;
  int64_t v11 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100B8A358(a1, v7, (uint64_t)&v10, a4, a5, *a6, a6[1]);
  if (v11) {
    sub_10004D2C8(v11);
  }
  return a1;
}

void sub_100B8C434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B8C44C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100B1800C(a1, a2, "GroupChat");
  *(_OWORD *)(v4 + 216) = 0u;
  *(void *)uint64_t v4 = off_101A410A0;
  *(unsigned char *)(v4 + 384) = 0;
  *(unsigned char *)(v4 + 392) = 0;
  *(unsigned char *)(v4 + 416) = 0;
  *(unsigned char *)(v4 + 424) = 0;
  *(unsigned char *)(v4 + 496) = 0;
  *(void *)(v4 + 520) = 0;
  *(void *)(v4 + 504) = 0;
  *(void *)(v4 + 512) = 0;
  *(_OWORD *)(v4 + 232) = 0u;
  *(_OWORD *)(v4 + 248) = 0u;
  *(unsigned char *)(v4 + 312) = 0;
  *(_OWORD *)(v4 + 264) = 0u;
  *(_OWORD *)(v4 + 280) = 0u;
  *(_OWORD *)(v4 + 296) = 0u;
  *(_DWORD *)(v4 + 528) = -1;
  *(unsigned char *)(v4 + 712) = 0;
  *(unsigned char *)(v4 + 720) = 0;
  *(unsigned char *)(v4 + 568) = 0;
  *(_OWORD *)(v4 + 536) = 0u;
  *(_OWORD *)(v4 + 552) = 0u;
  *(_OWORD *)BOOL v14 = 0u;
  long long v15 = 0u;
  sub_100B19268(v4, (uint64_t)v14);
  xpc_object_t v5 = (_OWORD *)(a2 + 24);
  if ((*(char *)(a2 + 47) & 0x80000000) == 0)
  {
    *(_OWORD *)uint64_t v8 = *v5;
    uint64_t v9 = *(void *)(a2 + 40);
LABEL_4:
    long long v10 = *v5;
    uint64_t v11 = *(void *)(a2 + 40);
    goto LABEL_5;
  }
  sub_10004FC84(v8, *(void **)(a2 + 24), *(void *)(a2 + 32));
  if ((*(char *)(a2 + 47) & 0x80000000) == 0) {
    goto LABEL_4;
  }
  sub_10004FC84(&v10, *(void **)(a2 + 24), *(void *)(a2 + 32));
LABEL_5:
  if (BYTE8(v15))
  {
    if (SBYTE7(v15) < 0)
    {
      sub_10004FC84(&__p, v14[0], (unint64_t)v14[1]);
    }
    else
    {
      long long __p = *(_OWORD *)v14;
      uint64_t v13 = v15;
    }
  }
  else
  {
    sub_100058DB0(&__p, "");
  }
  sub_1002B05A8(a1 + 312, (long long *)v8);
  if (SHIBYTE(v13) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)v10);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[0]);
  }
  if (BYTE8(v15))
  {
    if (SBYTE7(v15) < 0)
    {
      sub_10004FC84(v8, v14[0], (unint64_t)v14[1]);
    }
    else
    {
      *(_OWORD *)uint64_t v8 = *(_OWORD *)v14;
      uint64_t v9 = v15;
    }
  }
  else
  {
    sub_100058DB0(v8, "");
  }
  uint64_t v6 = (void **)(a1 + 168);
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*v6);
  }
  *(_OWORD *)uint64_t v6 = *(_OWORD *)v8;
  *(void *)(a1 + 184) = v9;
  if (BYTE8(v15) && SBYTE7(v15) < 0) {
    operator delete(v14[0]);
  }
  return a1;
}

void sub_100B8C674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a31)
  {
    if (a30 < 0) {
      operator delete(a25);
    }
  }
  sub_100B8E674(v31 + 568);
  sub_100B8C6FC(v32);
  sub_100B18808(v31);
  _Unwind_Resume(a1);
}

uint64_t sub_100B8C6FC(uint64_t a1)
{
  if (*(char *)(a1 + 343) < 0) {
    operator delete(*(void **)(a1 + 320));
  }

  return sub_1002B26E8(a1);
}

std::string *sub_100B8C740(std::string *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_100B18514((uint64_t)a1, a2, a3, "GroupChat");
  *(_OWORD *)(v6 + 216) = 0u;
  *(void *)uint64_t v6 = off_101A410A0;
  *(unsigned char *)(v6 + 384) = 0;
  *(unsigned char *)(v6 + 392) = 0;
  *(unsigned char *)(v6 + 416) = 0;
  *(unsigned char *)(v6 + 424) = 0;
  *(unsigned char *)(v6 + 496) = 0;
  *(void *)(v6 + 520) = 0;
  *(void *)(v6 + 504) = 0;
  *(void *)(v6 + 512) = 0;
  *(_OWORD *)(v6 + 232) = 0u;
  *(_OWORD *)(v6 + 248) = 0u;
  *(unsigned char *)(v6 + 312) = 0;
  *(_OWORD *)(v6 + 264) = 0u;
  *(_OWORD *)(v6 + 280) = 0u;
  *(_OWORD *)(v6 + 296) = 0u;
  *(_DWORD *)(v6 + 528) = -1;
  *(unsigned char *)(v6 + 712) = 0;
  *(unsigned char *)(v6 + 720) = 0;
  *(unsigned char *)(v6 + 568) = 0;
  *(_OWORD *)(v6 + 536) = 0u;
  *(_OWORD *)(v6 + 552) = 0u;
  int v7 = (_OWORD *)(a2 + 24);
  if ((*(char *)(a2 + 47) & 0x80000000) == 0)
  {
    *(_OWORD *)uint64_t v9 = *v7;
    uint64_t v10 = *(void *)(a2 + 40);
LABEL_4:
    long long v11 = *v7;
    uint64_t v12 = *(void *)(a2 + 40);
    goto LABEL_5;
  }
  sub_10004FC84(v9, *(void **)(a2 + 24), *(void *)(a2 + 32));
  if ((*(char *)(a2 + 47) & 0x80000000) == 0) {
    goto LABEL_4;
  }
  sub_10004FC84(&v11, *(void **)(a2 + 24), *(void *)(a2 + 32));
LABEL_5:
  if (*(char *)(a3 + 39) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a3 + 16), *(void *)(a3 + 24));
  }
  else
  {
    long long __p = *(_OWORD *)(a3 + 16);
    uint64_t v14 = *(void *)(a3 + 32);
  }
  sub_1002B05A8((uint64_t)&a1[13], (long long *)v9);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)v11);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[0]);
  }
  sub_100B8C940(a1, (const std::string *)(a3 + 16));
  return a1;
}

void sub_100B8C8D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100B8E674(v20 + 568);
  sub_100B8C6FC(v21);
  sub_100B18808(v20);
  _Unwind_Resume(a1);
}

void sub_100B8C940(std::string *a1, const std::string *a2)
{
  sub_100B18904((uint64_t)a1, (uint64_t)a2);
  if (a1[16].__r_.__value_.__s.__data_[0])
  {
    std::string::operator=(a1 + 15, a2);
  }
}

BOOL sub_100B8C994(uint64_t a1, uint64_t a2)
{
  long long __src = 0uLL;
  uint64_t v89 = 0;
  *(void *)int buf = a2;
  *(void *)&uint8_t buf[8] = ims::lazuli::kSubject;
  sub_100048BAC((uint64_t)buf, object);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v91 = 0;
  xpc::dyn_cast_or_default();
  if (SBYTE7(v91) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object[0]);
  v86[0] = 0;
  v86[1] = 0;
  uint64_t v87 = 0;
  *(void *)int buf = a2;
  *(void *)&uint8_t buf[8] = ims::lazuli::kResourceXml;
  sub_100048BAC((uint64_t)buf, object);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v91 = 0;
  xpc::dyn_cast_or_default();
  if (SBYTE7(v91) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object[0]);
  uint64_t v4 = (void *)HIBYTE(v87);
  if (v87 < 0) {
    uint64_t v4 = v86[1];
  }
  if (v4)
  {
    uint64_t v85 = 0;
    memset(v84, 0, sizeof(v84));
    long long v91 = 0u;
    memset(v92, 0, 24);
    *(_OWORD *)long long __p = 0u;
    sub_1010E6514("\r\n\r\n", (uint64_t)v86, (uint64_t)__p);
    if (v92[16])
    {
      *(_OWORD *)xpc_object_t object = 0u;
      *(_OWORD *)long long v68 = 0u;
      sub_1010E6690((uint64_t)__p, (uint64_t)object);
      if (v68[8] && *(void *)v68)
      {
        *(_OWORD *)uint64_t v81 = 0u;
        *(_OWORD *)long long v82 = 0u;
        sub_100058DB0(v76, "Content-Type");
        if (SBYTE7(v77) < 0)
        {
          sub_10004FC84(buf, v76[0], (unint64_t)v76[1]);
        }
        else
        {
          *(_OWORD *)int buf = *(_OWORD *)v76;
          *(void *)&uint8_t buf[16] = v77;
        }
        sub_1010E7200(object, (uint64_t)buf, (uint64_t)v81);
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        if (SBYTE7(v77) < 0) {
          operator delete(v76[0]);
        }
        if (LOBYTE(v82[1]))
        {
          sub_100720B70((char *)buf, (long long *)v81, (long long *)((char *)&v91 + 8));
          v84[0] = *(_OWORD *)buf;
          *(long long *)((char *)&v84[1] + 8) = *(_OWORD *)&buf[24];
          *(void *)&v84[1] = *(void *)&buf[16];
          *((void *)&v84[2] + 1) = *(void *)&buf[40];
          LOBYTE(v85) = 1;
        }
        else
        {
          uint64_t v9 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)int buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Missing Content-type in incoming XML", buf, 2u);
          }
          LOBYTE(v84[0]) = 0;
          LOBYTE(v85) = 0;
        }
        if (LOBYTE(v82[1]) && SHIBYTE(v82[0]) < 0) {
          operator delete(v81[0]);
        }
      }
      else
      {
        uint64_t v8 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          __int16 v49 = v86;
          if (v87 < 0) {
            __int16 v49 = (void **)v86[0];
          }
          *(_DWORD *)int buf = 141558275;
          *(void *)&uint8_t buf[4] = 1752392040;
          *(_WORD *)&unsigned char buf[12] = 2085;
          *(void *)&buf[14] = v49;
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to decode XML message - Could not convert to KV list: %{sensitive, mask.hash}s", buf, 0x16u);
        }
        LOBYTE(v84[0]) = 0;
        LOBYTE(v85) = 0;
      }
      if (v68[8]) {
        sub_10010C0E0((uint64_t)object, (void *)object[1]);
      }
    }
    else
    {
      int v7 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        uint64_t v48 = v86;
        if (v87 < 0) {
          uint64_t v48 = (void **)v86[0];
        }
        *(_DWORD *)int buf = 141558275;
        *(void *)&uint8_t buf[4] = 1752392040;
        *(_WORD *)&unsigned char buf[12] = 2085;
        *(void *)&buf[14] = v48;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to decode XML message - Missing CRLF_2: %{sensitive, mask.hash}s", buf, 0x16u);
      }
      LOBYTE(v84[0]) = 0;
      LOBYTE(v85) = 0;
    }
    sub_10013E528((uint64_t)__p);
    if (!(_BYTE)v85)
    {
      uint64_t v13 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Ignoring incoming XML", (uint8_t *)__p, 2u);
      }
      BOOL v6 = 0;
      goto LABEL_163;
    }
    *(_OWORD *)long long v82 = 0u;
    long long v83 = 0u;
    *(_OWORD *)uint64_t v81 = 0u;
    sub_10000451C((char *)v81, v84);
    sub_100058DB0(__p, "application/resource-lists+xml");
    BOOL v10 = sub_1010E5F80((uint64_t)v81, (uint64_t)__p);
    BOOL v11 = v10;
    if (SBYTE7(v91) < 0)
    {
      operator delete(__p[0]);
      if (v11)
      {
LABEL_37:
        long long v110 = 0u;
        long long v111 = 0u;
        long long v109 = 0u;
        memset(buf, 0, sizeof(buf));
        uint64_t v12 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
        sub_100CC8650(__p, (uint64_t)&v82[1]);
        sub_10071F6A8((Registry **)(a1 + 32), v12, (uint64_t *)__p, (uint64_t)buf);
        if (SBYTE7(v91) < 0) {
          operator delete(__p[0]);
        }
        if (!BYTE8(v111))
        {
          uint64_t v26 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Incoming Resource-XML dropped...", (uint8_t *)__p, 2u);
          }
          BOOL v6 = 0;
          goto LABEL_120;
        }
        *(_OWORD *)uint64_t v79 = 0u;
        long long v80 = 0u;
        if ((SHIBYTE(v89) & 0x80000000) == 0)
        {
          if (!HIBYTE(v89)) {
            goto LABEL_69;
          }
          *(_OWORD *)long long __p = __src;
          *(void *)&long long v91 = v89;
          goto LABEL_43;
        }
        if (*((void *)&__src + 1))
        {
          sub_10004FC84(__p, (void *)__src, *((unint64_t *)&__src + 1));
          if (!BYTE8(v80))
          {
LABEL_43:
            *(_OWORD *)uint64_t v79 = *(_OWORD *)__p;
            *(void *)&long long v80 = v91;
            BYTE8(v80) = 1;
            goto LABEL_69;
          }
          if (SBYTE7(v80) < 0) {
            operator delete(v79[0]);
          }
          *(_OWORD *)uint64_t v79 = *(_OWORD *)__p;
          *(void *)&long long v80 = v91;
        }
LABEL_69:
        long long v77 = 0u;
        long long v78 = 0u;
        *(_OWORD *)unint64_t v76 = 0u;
        xpc_object_t v27 = *(long long **)&buf[24];
        for (i = *(long long **)&buf[32]; v27 != i; xpc_object_t v27 = (long long *)((char *)v27 + 24))
        {
          if (*((char *)v27 + 23) < 0)
          {
            sub_10004FC84(object, *(void **)v27, *((void *)v27 + 1));
          }
          else
          {
            long long v29 = *v27;
            *(void *)long long v68 = *((void *)v27 + 2);
            *(_OWORD *)xpc_object_t object = v29;
          }
          *(_DWORD *)&v68[8] = 0;
          uint64_t v30 = v78;
          if ((unint64_t)v78 >= *((void *)&v78 + 1))
          {
            uint64_t v32 = (uint64_t)(v78 - *((void *)&v77 + 1)) >> 5;
            unint64_t v33 = v32 + 1;
            if ((unint64_t)(v32 + 1) >> 59) {
              sub_10006A748();
            }
            uint64_t v34 = *((void *)&v78 + 1) - *((void *)&v77 + 1);
            if ((uint64_t)(*((void *)&v78 + 1) - *((void *)&v77 + 1)) >> 4 > v33) {
              unint64_t v33 = v34 >> 4;
            }
            if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v35 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v35 = v33;
            }
            *(void *)v92 = (char *)&v78 + 8;
            uint64_t v36 = (char *)sub_1000F5A68((uint64_t)&v78 + 8, v35);
            unsigned int v37 = &v36[32 * v32];
            __p[0] = v36;
            __p[1] = v37;
            *((void *)&v91 + 1) = &v36[32 * v38];
            long long v39 = *(_OWORD *)object;
            *((void *)v37 + 2) = *(void *)v68;
            *(_OWORD *)unsigned int v37 = v39;
            object[1] = 0;
            *(void *)long long v68 = 0;
            object[0] = 0;
            *((_DWORD *)v37 + 6) = *(_DWORD *)&v68[8];
            *(void *)&long long v91 = v37 + 32;
            sub_1002B2D2C((uint64_t *)&v77 + 1, __p);
            uint64_t v40 = v78;
            sub_1002B2ED0((uint64_t)__p);
            *(void *)&long long v78 = v40;
            if ((v68[7] & 0x80000000) != 0) {
              operator delete(object[0]);
            }
          }
          else
          {
            long long v31 = *(_OWORD *)object;
            *(void *)(v78 + 16) = *(void *)v68;
            *(_OWORD *)uint64_t v30 = v31;
            object[1] = 0;
            *(void *)long long v68 = 0;
            object[0] = 0;
            *(_DWORD *)(v30 + 24) = *(_DWORD *)&v68[8];
            *(void *)&long long v78 = v30 + 32;
          }
        }
        *(_OWORD *)uint64_t v74 = 0u;
        long long v75 = 0u;
        sub_100B19268(a1, (uint64_t)v74);
        BOOL v6 = BYTE8(v75) != 0;
        if (!BYTE8(v75))
        {
          __int16 v41 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "No conversation ID found...", (uint8_t *)__p, 2u);
          }
          goto LABEL_114;
        }
        __dst[0] = 0;
        __dst[1] = 0;
        uint64_t v73 = 0;
        if (*(char *)(a1 + 191) < 0)
        {
          sub_10004FC84(__dst, *(void **)(a1 + 168), *(void *)(a1 + 176));
        }
        else
        {
          *(_OWORD *)std::string __dst = *(_OWORD *)(a1 + 168);
          uint64_t v73 = *(void *)(a1 + 184);
        }
        __p[0] = 0;
        __p[1] = 0;
        *(void *)&long long v91 = 0;
        sub_1000302C0((char *)__p, (long long *)v76[0], (long long *)v76[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v76[1] - (char *)v76[0]) >> 3));
        *((void *)&v91 + 1) = 0;
        *(_OWORD *)v92 = 0uLL;
        sub_1002B2788((void *)&v91 + 1, *((long long **)&v77 + 1), (long long *)v78, (uint64_t)(v78 - *((void *)&v77 + 1)) >> 5);
        memset(&v92[16], 0, 48);
        uint64_t v42 = (_OWORD *)(a1 + 48);
        if (*(char *)(a1 + 71) < 0)
        {
          sub_10004FC84(object, *(void **)(a1 + 48), *(void *)(a1 + 56));
          if (*(char *)(a1 + 71) < 0)
          {
            sub_10004FC84(&v68[8], *(void **)(a1 + 48), *(void *)(a1 + 56));
            goto LABEL_94;
          }
        }
        else
        {
          *(_OWORD *)xpc_object_t object = *v42;
          *(void *)long long v68 = *(void *)(a1 + 64);
        }
        *(_OWORD *)&v68[8] = *v42;
        uint64_t v69 = *(void *)(a1 + 64);
LABEL_94:
        if (SHIBYTE(v73) < 0)
        {
          sub_10004FC84(&v70, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          long long v70 = *(_OWORD *)__dst;
          uint64_t v71 = v73;
        }
        long long v93 = *(_OWORD *)object;
        uint64_t v94 = *(void *)v68;
        object[1] = 0;
        memset(v68, 0, sizeof(v68));
        object[0] = 0;
        uint64_t v96 = v69;
        long long v95 = *(_OWORD *)&v68[8];
        uint64_t v69 = 0;
        long long v97 = v70;
        uint64_t v98 = v71;
        uint64_t v71 = 0;
        long long v70 = 0uLL;
        char v99 = 1;
        sub_1002B250C((uint64_t)v100, (long long *)v79);
        v100[32] = 0;
        v100[104] = 0;
        uint64_t v103 = 0;
        uint64_t v101 = 0;
        uint64_t v102 = 0;
        int v104 = -1;
        if (SHIBYTE(v87) < 0)
        {
          sub_10004FC84(&v105, v86[0], (unint64_t)v86[1]);
        }
        else
        {
          long long v105 = *(_OWORD *)v86;
          uint64_t v106 = v87;
        }
        __int16 v43 = *(std::__shared_weak_count **)(a1 + 40);
        if (v43) {
          atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v107 = (uint64_t)((double)std::chrono::system_clock::now().__d_.__rep_ / 1000000.0);
        sub_1004570E8(a1 + 216, (uint64_t)__p);
        size_t v44 = (void **)(a1 + 536);
        if (*(char *)(a1 + 559) < 0) {
          operator delete(*v44);
        }
        *(_OWORD *)size_t v44 = v105;
        *(void *)(a1 + 552) = v106;
        HIBYTE(v106) = 0;
        LOBYTE(v105) = 0;
        *(void *)(a1 + 560) = v107;
        sub_1002B26E8((uint64_t)__p);
        if (v43) {
          sub_10004D2C8(v43);
        }
        if (SHIBYTE(v71) < 0) {
          operator delete((void *)v70);
        }
        if (SHIBYTE(v69) < 0) {
          operator delete(*(void **)&v68[8]);
        }
        if ((v68[7] & 0x80000000) != 0) {
          operator delete(object[0]);
        }
        if (SHIBYTE(v73) < 0) {
          operator delete(__dst[0]);
        }
LABEL_114:
        if (BYTE8(v75) && SBYTE7(v75) < 0) {
          operator delete(v74[0]);
        }
        __p[0] = (char *)&v77 + 8;
        sub_1000D82FC((void ***)__p);
        __p[0] = v76;
        sub_100047F64((void ***)__p);
        if (BYTE8(v80) && SBYTE7(v80) < 0) {
          operator delete(v79[0]);
        }
LABEL_120:
        sub_100B8E6FC((uint64_t)buf);
LABEL_159:
        if (SHIBYTE(v83) < 0) {
          operator delete(v82[1]);
        }
        if (SHIBYTE(v82[0]) < 0) {
          operator delete(v81[0]);
        }
LABEL_163:
        sub_10013E528((uint64_t)v84);
        goto LABEL_164;
      }
    }
    else if (v10)
    {
      goto LABEL_37;
    }
    sub_100058DB0(__p, "application/conference-info+xml");
    BOOL v14 = sub_1010E5F80((uint64_t)v81, (uint64_t)__p);
    BOOL v15 = v14;
    if (SBYTE7(v91) < 0)
    {
      operator delete(__p[0]);
      if (v15) {
        goto LABEL_50;
      }
    }
    else if (v14)
    {
LABEL_50:
      xpc_object_t v16 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
      sub_100CC8650(buf, (uint64_t)&v82[1]);
      sub_10071FB34((Registry **)(a1 + 32), v16, (uint64_t *)buf, (uint64_t)__p);
      xpc_object_t v17 = (uint64_t *)(a1 + 568);
      if (*(unsigned __int8 *)(a1 + 712) == v97)
      {
        if (*(unsigned char *)(a1 + 712))
        {
          uint64_t v18 = a1 + 576;
          sub_100720C08(a1 + 568, *(void **)(a1 + 576));
          unint64_t v19 = __p[1];
          *(void **)(a1 + 568) = __p[0];
          *(void *)(a1 + 576) = v19;
          uint64_t v20 = v91;
          *(void *)(a1 + 584) = v91;
          if (v20)
          {
            v19[2] = v18;
            __p[0] = &__p[1];
            __p[1] = 0;
            *(void *)&long long v91 = 0;
          }
          else
          {
            uint64_t *v17 = v18;
          }
          uint64_t v50 = a1 + 600;
          sub_100720C08(a1 + 592, *(void **)(a1 + 600));
          uint64_t v51 = *(void *)v92;
          *(void *)(a1 + 592) = *((void *)&v91 + 1);
          *(void *)(a1 + 600) = v51;
          uint64_t v52 = *(void *)&v92[8];
          *(void *)(a1 + 608) = *(void *)&v92[8];
          if (v52)
          {
            *(void *)(v51 + 16) = v50;
            *((void *)&v91 + 1) = v92;
            *(_OWORD *)v92 = 0uLL;
          }
          else
          {
            *(void *)(a1 + 592) = v50;
          }
          uint64_t v53 = a1 + 624;
          sub_10005CD2C(a1 + 616, *(char **)(a1 + 624));
          uint64_t v54 = *(void *)&v92[24];
          *(void *)(a1 + 616) = *(void *)&v92[16];
          *(void *)(a1 + 624) = v54;
          uint64_t v55 = *(void *)&v92[32];
          *(void *)(a1 + 632) = *(void *)&v92[32];
          if (v55)
          {
            *(void *)(v54 + 16) = v53;
            *(void *)&v92[16] = &v92[24];
            *(void *)&v92[24] = 0;
            *(void *)&v92[32] = 0;
          }
          else
          {
            *(void *)(a1 + 616) = v53;
          }
          sub_10005CBB4((uint64_t *)(a1 + 640));
          *(_OWORD *)(a1 + 640) = *(_OWORD *)&v92[40];
          *(void *)(a1 + 656) = *(void *)&v92[56];
          memset(&v92[40], 0, 24);
          sub_10071F624(a1 + 664, &v93);
        }
      }
      else if (*(unsigned char *)(a1 + 712))
      {
        sub_100B8E760(a1 + 568);
      }
      else
      {
        __int16 v45 = __p[1];
        *(void **)(a1 + 568) = __p[0];
        uint64_t v46 = a1 + 576;
        *(void *)(a1 + 576) = v45;
        uint64_t v47 = v91;
        *(void *)(a1 + 584) = v91;
        if (v47)
        {
          v45[2] = v46;
          __p[0] = &__p[1];
          __p[1] = 0;
          *(void *)&long long v91 = 0;
        }
        else
        {
          uint64_t *v17 = v46;
        }
        uint64_t v57 = *(void *)v92;
        *(void *)(a1 + 592) = *((void *)&v91 + 1);
        uint64_t v58 = a1 + 600;
        *(void *)(a1 + 600) = v57;
        uint64_t v59 = *(void *)&v92[8];
        *(void *)(a1 + 608) = *(void *)&v92[8];
        if (v59)
        {
          *(void *)(v57 + 16) = v58;
          *((void *)&v91 + 1) = v92;
          *(_OWORD *)v92 = 0uLL;
        }
        else
        {
          *(void *)(a1 + 592) = v58;
        }
        uint64_t v60 = *(void *)&v92[24];
        *(void *)(a1 + 616) = *(void *)&v92[16];
        uint64_t v61 = a1 + 624;
        *(void *)(a1 + 624) = v60;
        uint64_t v62 = *(void *)&v92[32];
        *(void *)(a1 + 632) = *(void *)&v92[32];
        if (v62)
        {
          *(void *)(v60 + 16) = v61;
          *(void *)&v92[16] = &v92[24];
          *(void *)&v92[24] = 0;
          *(void *)&v92[32] = 0;
        }
        else
        {
          *(void *)(a1 + 616) = v61;
        }
        *(_OWORD *)(a1 + 640) = *(_OWORD *)&v92[40];
        *(void *)(a1 + 656) = *(void *)&v92[56];
        long long v63 = v93;
        *(void *)&long long v93 = 0;
        memset(&v92[40], 0, 24);
        uint64_t v64 = v96;
        *(void *)(a1 + 680) = v94;
        *(_OWORD *)(a1 + 664) = v63;
        *((void *)&v93 + 1) = 0;
        uint64_t v94 = 0;
        *(_OWORD *)(a1 + 688) = v95;
        *(void *)(a1 + 704) = v64;
        long long v95 = 0uLL;
        uint64_t v96 = 0;
        *(unsigned char *)(a1 + 712) = 1;
      }
      sub_100B8E674((uint64_t)__p);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      if (*(unsigned char *)(a1 + 712))
      {
        BOOL v6 = 1;
        goto LABEL_159;
      }
      long long v65 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
      if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
LABEL_158:
        BOOL v6 = 0;
        goto LABEL_159;
      }
      LOWORD(__p[0]) = 0;
      xpc_object_t v23 = "Incoming Conference-XML dropped...";
      uint64_t v24 = v65;
      uint32_t v25 = 2;
LABEL_170:
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v23, (uint8_t *)__p, v25);
      goto LABEL_158;
    }
    uint64_t v21 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_158;
    }
    xpc_object_t v22 = v81;
    if (SHIBYTE(v82[0]) < 0) {
      xpc_object_t v22 = (void **)v81[0];
    }
    LODWORD(__p[0]) = 136446210;
    *(void **)((char *)__p + 4) = v22;
    xpc_object_t v23 = "Incoming XML dropped of type: %{public}s";
    uint64_t v24 = v21;
    uint32_t v25 = 12;
    goto LABEL_170;
  }
  xpc_object_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a1 + 48);
      *(void *)&long long v91 = *(void *)(a1 + 64);
    }
    uint64_t v56 = __p;
    if (SBYTE7(v91) < 0) {
      uint64_t v56 = (void **)__p[0];
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = v56;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Invalid group XML (missing recipient list) with focus: %{public}s", buf, 0xCu);
    if (SBYTE7(v91) < 0) {
      operator delete(__p[0]);
    }
  }
  BOOL v6 = 0;
LABEL_164:
  if (SHIBYTE(v87) < 0) {
    operator delete(v86[0]);
  }
  if (SHIBYTE(v89) < 0) {
    operator delete((void *)__src);
  }
  return v6;
}

void sub_100B8D924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *a63)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a77 < 0) {
    operator delete(a76);
  }
  if (a75 < 0) {
    operator delete(a74);
  }
  sub_1002B0A2C(&a73);
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a35 && a34 < 0) {
    operator delete(a29);
  }
  sub_1002B0A2C(&a36);
  if (a48 && a47 < 0) {
    operator delete(a42);
  }
  sub_100B8E6FC(v77 - 192);
  sub_1001085D8((uint64_t)&a49);
  sub_10013E528((uint64_t)&a55);
  if (a68 < 0) {
    operator delete(a63);
  }
  if (a72 < 0) {
    operator delete(a69);
  }
  _Unwind_Resume(a1);
}

void sub_100B8DBF8(uint64_t a1, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    *(_OWORD *)int v7 = *a2;
    uint64_t v8 = *((void *)a2 + 2);
  }
  uint64_t v4 = (void **)(a1 + 48);
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*v4);
  }
  *(_OWORD *)uint64_t v4 = *(_OWORD *)v7;
  *(void *)(a1 + 64) = v8;
  xpc_object_t v5 = (void **)(a1 + 312);
  if (*(unsigned char *)(a1 + 384))
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(v7, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      *(_OWORD *)int v7 = *a2;
      uint64_t v8 = *((void *)a2 + 2);
    }
    if (*(char *)(a1 + 335) < 0) {
      operator delete(*v5);
    }
    *(_OWORD *)xpc_object_t v5 = *(_OWORD *)v7;
    *(void *)(a1 + 328) = v8;
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(v7, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      *(_OWORD *)int v7 = *a2;
      uint64_t v8 = *((void *)a2 + 2);
    }
    BOOL v6 = (void **)(a1 + 336);
    if (*(char *)(a1 + 359) < 0) {
      operator delete(*v6);
    }
    *(_OWORD *)BOOL v6 = *(_OWORD *)v7;
    *(void *)(a1 + 352) = v8;
    return;
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a2, *((void *)a2 + 1));
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(&v9, *(void **)a2, *((void *)a2 + 1));
      goto LABEL_22;
    }
  }
  else
  {
    *(_OWORD *)int v7 = *a2;
    uint64_t v8 = *((void *)a2 + 2);
  }
  long long v9 = *a2;
  uint64_t v10 = *((void *)a2 + 2);
LABEL_22:
  long long __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_1002B05A8((uint64_t)v5, (long long *)v7);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)v9);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[0]);
  }
}

void sub_100B8DDBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_100B8DDE8(uint64_t a1, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v6, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    uint64_t v7 = *((void *)a2 + 2);
  }
  int v3 = -1;
  int v8 = -1;
  uint64_t v4 = (void **)(a1 + 504);
  if (*(char *)(a1 + 527) < 0)
  {
    operator delete(*v4);
    int v3 = v8;
  }
  double result = *(double *)&v6;
  *(_OWORD *)uint64_t v4 = v6;
  *(void *)(a1 + 520) = v7;
  *(_DWORD *)(a1 + 528) = v3;
  return result;
}

void sub_100B8DE70(uint64_t a1, std::string::size_type a2)
{
  memset(&v32, 0, sizeof(v32));
  if (*(unsigned char *)(a1 + 384)) {
    std::string::operator=(&v32, (const std::string *)(a1 + 360));
  }
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(char *)(a2 + 23);
    std::string::size_type v6 = *(void *)a2;
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a1 + 48);
      *(void *)&__p[16] = *(void *)(a1 + 64);
    }
    if (v5 >= 0) {
      std::string::size_type v7 = a2;
    }
    else {
      std::string::size_type v7 = v6;
    }
    int v8 = __p;
    if (__p[23] < 0) {
      int v8 = *(unsigned char **)__p;
    }
    long long v9 = &v32;
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      long long v9 = (std::string *)v32.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446722;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v7;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v8;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2082;
    unint64_t v35 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [: === :] %{public}s focus:[%{public}s] conversationID:[%{public}s]", (uint8_t *)&buf, 0x20u);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }
  if (*(unsigned char *)(a1 + 712))
  {
    if (*(void *)(a1 + 584))
    {
      uint64_t v10 = *(void **)(a1 + 568);
      if (v10 != (void *)(a1 + 576))
      {
        do
        {
          BOOL v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = v10 + 4;
            if (*((char *)v10 + 55) < 0) {
              uint64_t v12 = (void *)*v12;
            }
            sub_100062B40((std::string *)v10[7], (std::string *)v10[8], ",", 1uLL, &buf);
            if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              p_std::string buf = &buf;
            }
            else {
              p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)long long __p = 136380931;
            *(void *)&__p[4] = v12;
            *(_WORD *)&__p[12] = 2081;
            *(void *)&__p[14] = p_buf;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I AddedParticipant: [%{private}s] [= referred by =>] [%{private}s]", __p, 0x16u);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
          }
          BOOL v14 = (void *)v10[1];
          if (v14)
          {
            do
            {
              BOOL v15 = v14;
              BOOL v14 = (void *)*v14;
            }
            while (v14);
          }
          else
          {
            do
            {
              BOOL v15 = (void *)v10[2];
              BOOL v16 = *v15 == (void)v10;
              uint64_t v10 = v15;
            }
            while (!v16);
          }
          uint64_t v10 = v15;
        }
        while (v15 != (void *)(a1 + 576));
      }
    }
    if (*(void *)(a1 + 608))
    {
      xpc_object_t v17 = *(void **)(a1 + 592);
      if (v17 != (void *)(a1 + 600))
      {
        do
        {
          uint64_t v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v19 = v17 + 4;
            if (*((char *)v17 + 55) < 0) {
              unint64_t v19 = (void *)*v19;
            }
            sub_100062B40((std::string *)v17[7], (std::string *)v17[8], ",", 1uLL, &buf);
            if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v20 = &buf;
            }
            else {
              uint64_t v20 = (std::string *)buf.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)long long __p = 136380931;
            *(void *)&__p[4] = v19;
            *(_WORD *)&__p[12] = 2081;
            *(void *)&__p[14] = v20;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I RemovedParticipant: [%{private}s] [= referred by =>] [%{private}s]", __p, 0x16u);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
          }
          uint64_t v21 = (void *)v17[1];
          if (v21)
          {
            do
            {
              xpc_object_t v22 = v21;
              uint64_t v21 = (void *)*v21;
            }
            while (v21);
          }
          else
          {
            do
            {
              xpc_object_t v22 = (void *)v17[2];
              BOOL v16 = *v22 == (void)v17;
              xpc_object_t v17 = v22;
            }
            while (!v16);
          }
          xpc_object_t v17 = v22;
        }
        while (v22 != (void *)(a1 + 600));
      }
    }
    if (*(void *)(a1 + 632))
    {
      xpc_object_t v23 = *(void **)(a1 + 616);
      if (v23 != (void *)(a1 + 624))
      {
        do
        {
          uint64_t v24 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            uint32_t v25 = v23 + 4;
            if (*((char *)v23 + 55) < 0) {
              uint32_t v25 = (void *)*v25;
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 136380675;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I DisconnectedParticipant: [%{private}s]", (uint8_t *)&buf, 0xCu);
          }
          uint64_t v26 = (void *)v23[1];
          if (v26)
          {
            do
            {
              xpc_object_t v27 = v26;
              uint64_t v26 = (void *)*v26;
            }
            while (v26);
          }
          else
          {
            do
            {
              xpc_object_t v27 = (void *)v23[2];
              BOOL v16 = *v27 == (void)v23;
              xpc_object_t v23 = v27;
            }
            while (!v16);
          }
          xpc_object_t v23 = v27;
        }
        while (v27 != (void *)(a1 + 624));
      }
    }
    if (*(char *)(a1 + 687) < 0)
    {
      if (!*(void *)(a1 + 672)) {
        goto LABEL_71;
      }
    }
    else if (!*(unsigned char *)(a1 + 687))
    {
      goto LABEL_71;
    }
    uint64_t v28 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      long long v29 = (void *)(a1 + 664);
      if (*(char *)(a1 + 687) < 0) {
        long long v29 = (void *)*v29;
      }
      uint64_t v30 = (void *)(a1 + 688);
      if (*(char *)(a1 + 711) < 0) {
        uint64_t v30 = (void *)*v30;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136380931;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v30;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I SubjectMutated: [%{private}s] [= referred by =>] [%{private}s]", (uint8_t *)&buf, 0x16u);
    }
  }
LABEL_71:
  long long v31 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [: === :] [: === :] [: === :]", (uint8_t *)&buf, 2u);
  }
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
}

void sub_100B8E480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B8E4C0(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(v1, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    *(_OWORD *)uint64_t v1 = *(_OWORD *)(a1 + 48);
    uint64_t v2 = *(void *)(a1 + 64);
  }
  sub_100CC7114(&__p, (uint64_t)v1);
  sub_100CC786C();
}

void sub_100B8E54C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B8E580(uint64_t a1)
{
  *(void *)a1 = off_101A410A0;
  sub_100B8E674(a1 + 568);
  if (*(char *)(a1 + 559) < 0) {
    operator delete(*(void **)(a1 + 536));
  }
  sub_1002B26E8(a1 + 216);

  return sub_100B18808(a1);
}

void sub_100B8E5F0(uint64_t a1)
{
  *(void *)a1 = off_101A410A0;
  sub_100B8E674(a1 + 568);
  if (*(char *)(a1 + 559) < 0) {
    operator delete(*(void **)(a1 + 536));
  }
  sub_1002B26E8(a1 + 216);
  sub_100B18808(a1);

  operator delete();
}

uint64_t sub_100B8E674(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 144))
  {
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    if (*(char *)(a1 + 119) < 0) {
      operator delete(*(void **)(a1 + 96));
    }
    int v3 = (void **)(a1 + 72);
    sub_100047F64(&v3);
    sub_10005CD2C(a1 + 48, *(char **)(a1 + 56));
    sub_100720C08(a1 + 24, *(void **)(a1 + 32));
    sub_100720C08(a1, *(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_100B8E6FC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88))
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    int v3 = (void **)(a1 + 24);
    sub_100047F64(&v3);
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

void sub_100B8E760(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 144))
  {
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    if (*(char *)(a1 + 119) < 0) {
      operator delete(*(void **)(a1 + 96));
    }
    uint64_t v2 = (void **)(a1 + 72);
    sub_100047F64(&v2);
    sub_10005CD2C(a1 + 48, *(char **)(a1 + 56));
    sub_100720C08(a1 + 24, *(void **)(a1 + 32));
    sub_100720C08(a1, *(void **)(a1 + 8));
    *(unsigned char *)(a1 + 144) = 0;
  }
}

unsigned char *sub_100B8E7E8(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[144] = 0;
  if (*(unsigned char *)(a2 + 144))
  {
    sub_100B8E840((uint64_t)a1, a2);
    a1[144] = 1;
  }
  return a1;
}

void sub_100B8E82C(_Unwind_Exception *a1)
{
  sub_100B8E674(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B8E840(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100B8E930((uint64_t *)a1, a2);
  sub_100B8E930(v4 + 3, a2 + 24);
  sub_1000C6BDC((uint64_t *)(a1 + 48), a2 + 48);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  sub_1000302C0((char *)(a1 + 72), *(long long **)(a2 + 72), *(long long **)(a2 + 80), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 80) - *(void *)(a2 + 72)) >> 3));
  sub_10000451C((char *)(a1 + 96), (long long *)(a2 + 96));
  return a1;
}

void sub_100B8E8DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100047F64((void ***)va);
  sub_10005CD2C(v4, *(char **)(v2 + 56));
  sub_100720C08(v3, *(void **)(v2 + 32));
  sub_100720C08(v2, *(void **)(v2 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100B8E930(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100B8E988(a1, *(void ***)a2, (void **)(a2 + 8));
  return a1;
}

void sub_100B8E970(_Unwind_Exception *a1)
{
  sub_100720C08(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100B8E988(uint64_t *result, void **a2, void **a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    int v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t)(result + 1);
    do
    {
      double result = sub_100B8EA14(v5, v6, v4 + 4, (long long *)v4 + 2);
      std::string::size_type v7 = (void **)v4[1];
      if (v7)
      {
        do
        {
          int v8 = v7;
          std::string::size_type v7 = (void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (void **)v4[2];
          BOOL v9 = *v8 == v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100B8EA14(uint64_t **a1, uint64_t a2, void **a3, long long *a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v6 = sub_1000C6D50(a1, a2, &v12, &v11, a3);
  std::string::size_type v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_100B8EAB8((uint64_t)a1, a4, v10);
    sub_100046C38(a1, (uint64_t)v12, v8, v10[0]);
    std::string::size_type v7 = v10[0];
    v10[0] = 0;
    sub_100720EB4((uint64_t)v10, 0);
  }
  return v7;
}

unsigned char *sub_100B8EAB8@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  double result = sub_100B8EB2C(v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100B8EB14(_Unwind_Exception *a1)
{
  sub_100720EB4(v1, 0);
  _Unwind_Resume(a1);
}

unsigned char *sub_100B8EB2C(unsigned char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  *((void *)__dst + 3) = 0;
  *((void *)__dst + 4) = 0;
  *((void *)__dst + 5) = 0;
  sub_1000302C0(__dst + 24, *((long long **)a2 + 3), *((long long **)a2 + 4), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 4) - *((void *)a2 + 3)) >> 3));
  return __dst;
}

void sub_100B8EBA4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B8EBC0(uint64_t a1)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "lazuli.cpim");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v3, &v4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)&v3);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  v4.var0 = 0;
  v4.var1.fRef = 0;
  uint64_t v5 = 0;
  sub_100CC7114((void *)(a1 + 8), (uint64_t)&v4);
  v4.var0 = 0;
  v4.var1.fRef = 0;
  uint64_t v5 = 0;
  sub_100CC7114((void *)(a1 + 32), (uint64_t)&v4);
  *(_DWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_DWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_DWORD *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = a1 + 208;
  *(unsigned char *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 464) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(unsigned char *)(a1 + 296) = 0;
  *(void *)(a1 + 288) = 0;
  return a1;
}

void sub_100B8ECB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v10[31] < 0) {
    operator delete(*v11);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100B8ED00(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, "lazuli.cpim");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v18, &v17);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v18);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v18);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v8;
  }
  if (*(char *)(a2 + 191) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 168), *(void *)(a2 + 176));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 168);
    *(void *)(a1 + 48) = *(void *)(a2 + 184);
    *(_OWORD *)(a1 + 32) = v9;
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v10 = *a3;
    *(void *)(a1 + 72) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 56) = v10;
  }
  uint64_t v11 = *((void *)a3 + 3);
  *(_DWORD *)(a1 + 88) = *((_DWORD *)a3 + 8);
  *(void *)(a1 + 80) = v11;
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 96), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v12 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 112) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 96) = v12;
  }
  uint64_t v13 = *(void *)(a2 + 80);
  int v14 = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 136) = 0u;
  *(_DWORD *)(a1 + 128) = v14;
  *(void *)(a1 + 120) = v13;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_DWORD *)(a1 + 168) = 0;
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 176), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v15 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 192) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 176) = v15;
  }
  sub_100B964AC(a1 + 200, a4);
  *(unsigned char *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 464) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 272) = 0;
  *(unsigned char *)(a1 + 296) = 0;
  return a1;
}

void sub_100B8EEE0(_Unwind_Exception *a1)
{
  if (v1[159] < 0) {
    operator delete(*v6);
  }
  if (v1[119] < 0) {
    operator delete(*v5);
  }
  if (v1[79] < 0) {
    operator delete(*v4);
  }
  if (v1[55] < 0) {
    operator delete(*v3);
  }
  if (v1[31] < 0) {
    operator delete(*v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v1);
  _Unwind_Resume(a1);
}

void sub_100B8EF9C(uint64_t a1)
{
  uint64_t v16 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  *(_OWORD *)OsLogContext v4 = 0u;
  long long v5 = 0u;
  memset(v3, 0, sizeof(v3));
  sub_10004BD84((uint64_t)v3);
  sub_100058DB0(__p, "imdn <urn:ietf:params:imdn>");
  uint64_t v2 = (void **)(a1 + 272);
  if (*(char *)(a1 + 295) < 0) {
    operator delete(*v2);
  }
  *(_OWORD *)uint64_t v2 = *(_OWORD *)__p;
  *(void *)(a1 + 288) = v18;
  sub_100CC79E8();
}

void sub_100B8F518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,std::bad_cast a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a63 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  if (a49 < 0) {
    operator delete(a44);
  }
  sub_10008248C((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_100B8F608(uint64_t a1, uint64_t a2, const std::string *a3)
{
  OsLogContext v4 = (void *)(a1 + 16);
  uint64_t v5 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    uint64_t v6 = v5;
  }
  long long v7 = sub_10004B96C(v4, a2, v6);
  long long v8 = sub_10004B96C(v7, (uint64_t)": ", 2);
  memset(&v12, 0, sizeof(v12));
  std::string::operator=(&v12, a3);
  if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v9 = &v12;
  }
  else {
    long long v9 = (std::string *)v12.__r_.__value_.__r.__words[0];
  }
  if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v12.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v12.__r_.__value_.__l.__size_;
  }
  long long v11 = sub_10004B96C(v8, (uint64_t)v9, size);
  sub_10004B96C(v11, (uint64_t)"\r\n", 2);
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
}

void sub_100B8F6C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B8F6E4(uint64_t a1, Registry **a2, uint64_t a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a2);
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    long long v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v7;
  long long v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    std::string v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  std::string v12 = 0;
  char v14 = 1;
LABEL_9:
  long long v15 = *(NSObject **)a1;
  uint64_t v16 = *(NSObject **)a1;
  if (!v13)
  {
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to parse CPIM message - client factory not present", buf, 2u);
    }
    BOOL v25 = 0;
    if ((v14 & 1) == 0) {
      goto LABEL_196;
    }
    return v25;
  }
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Decoding CPIM message using BlastDoor", buf, 2u);
  }
  CFDataRef v115 = 0;
  int v17 = *(char *)(a3 + 23);
  if (v17 >= 0) {
    long long v18 = (const UInt8 *)a3;
  }
  else {
    long long v18 = *(const UInt8 **)a3;
  }
  if (v17 >= 0) {
    CFIndex v19 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    CFIndex v19 = *(void *)(a3 + 8);
  }
  CFDataRef v20 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v18, v19, kCFAllocatorNull);
  std::string::size_type v114 = 0;
  CFDataRef v115 = v20;
  uint64_t v112 = 0;
  long long v113 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v13 + 16))(&v112, v13);
  long long v110 = 0u;
  long long v111 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v107 = 0u;
  memset(v106, 0, sizeof(v106));
  *(_OWORD *)long long v105 = 0u;
  *(_OWORD *)std::string buf = 0u;
  memset(v104, 0, sizeof(v104));
  __dst.__r_.__value_.__r.__words[0] = 0;
  __dst.__r_.__value_.__l.__size_ = (std::string::size_type)&v114;
  (*(void (**)(uint8_t *__return_ptr))(*(void *)v112 + 88))(buf);
  uint64_t v21 = sub_100128064((const void **)&__dst.__r_.__value_.__l.__data_);
  std::string::size_type v22 = v114;
  if (v114) {
    xpc_object_t v23 = sub_10039195C;
  }
  else {
    xpc_object_t v23 = 0;
  }
  if (v23)
  {
    uint64_t v24 = *(NSObject **)a1;
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
LABEL_23:
      BOOL v25 = 0;
      goto LABEL_182;
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 138412290;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v22;
    uint64_t v48 = "Failed to unpack CPIM message: %@";
    __int16 v49 = v24;
    uint32_t v50 = 12;
LABEL_119:
    _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, v48, (uint8_t *)&__dst, v50);
    goto LABEL_23;
  }
  if (!BYTE8(v111))
  {
    uint64_t v47 = *(NSObject **)a1;
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
    uint64_t v48 = "CPIM message unpacking succeeded, but there was no payload";
    __int16 v49 = v47;
    uint32_t v50 = 2;
    goto LABEL_119;
  }
  sub_100CC85C0(v21, (uint64_t)buf);
  uint64_t v26 = (void **)(a1 + 8);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*v26);
  }
  *(_OWORD *)uint64_t v26 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
  *(void *)(a1 + 24) = *((void *)&__dst.__r_.__value_.__l + 2);
  sub_100CC7114(&__dst, (uint64_t)&v104[1]);
  xpc_object_t v27 = (void **)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*v27);
  }
  *(_OWORD *)xpc_object_t v27 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
  *(void *)(a1 + 48) = *((void *)&__dst.__r_.__value_.__l + 2);
  sub_100CC89EC(&__dst, (uint64_t)v105);
  uint64_t v28 = (void **)(a1 + 96);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*v28);
  }
  *(_OWORD *)uint64_t v28 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
  uint64_t v29 = v120;
  *(void *)(a1 + 112) = *((void *)&__dst.__r_.__value_.__l + 2);
  *(void *)(a1 + 120) = v29;
  *(_DWORD *)(a1 + 128) = v121;
  uint64_t v30 = (const void **)*((void *)&v108 + 1);
  if (*((void *)&v108 + 1) != (void)v109)
  {
    if (*(char *)(*((void *)&v108 + 1) + 23) >= 0) {
      size_t v31 = *(unsigned __int8 *)(*((void *)&v108 + 1) + 23);
    }
    else {
      size_t v31 = *(void *)(*((void *)&v108 + 1) + 8);
    }
    memset(&v102, 0, sizeof(v102));
    std::string v32 = &v102;
    sub_1000C140C((uint64_t)&v102, v31 + 2);
    if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string v32 = (std::string *)v102.__r_.__value_.__r.__words[0];
    }
    if (v31)
    {
      if (*((char *)v30 + 23) >= 0) {
        unint64_t v33 = v30;
      }
      else {
        unint64_t v33 = *v30;
      }
      memmove(v32, v33, v31);
    }
    strcpy((char *)v32 + v31, " <");
    uint64_t v36 = (const std::string::value_type *)v30[3];
    unint64_t v35 = v30 + 3;
    uint64_t v34 = v36;
    int v37 = *((char *)v35 + 23);
    if (v37 >= 0) {
      uint64_t v38 = (const std::string::value_type *)v35;
    }
    else {
      uint64_t v38 = v34;
    }
    if (v37 >= 0) {
      std::string::size_type v39 = *((unsigned __int8 *)v35 + 23);
    }
    else {
      std::string::size_type v39 = (std::string::size_type)v35[1];
    }
    uint64_t v40 = std::string::append(&v102, v38, v39);
    long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
    __dst.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v41;
    v40->__r_.__value_.__l.__size_ = 0;
    v40->__r_.__value_.__r.__words[2] = 0;
    v40->__r_.__value_.__r.__words[0] = 0;
    uint64_t v42 = std::string::append(&__dst, ">", 1uLL);
    std::string::size_type v43 = v42->__r_.__value_.__r.__words[0];
    *(void *)&long long v117 = v42->__r_.__value_.__l.__size_;
    *(void *)((char *)&v117 + 7) = *(std::string::size_type *)((char *)&v42->__r_.__value_.__r.__words[1] + 7);
    char v44 = HIBYTE(v42->__r_.__value_.__r.__words[2]);
    v42->__r_.__value_.__l.__size_ = 0;
    v42->__r_.__value_.__r.__words[2] = 0;
    v42->__r_.__value_.__r.__words[0] = 0;
    if (*(char *)(a1 + 295) < 0) {
      operator delete(*(void **)(a1 + 272));
    }
    uint64_t v45 = v117;
    *(void *)(a1 + 272) = v43;
    *(void *)(a1 + 280) = v45;
    *(void *)(a1 + 287) = *(void *)((char *)&v117 + 7);
    *(unsigned char *)(a1 + 295) = v44;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v102.__r_.__value_.__l.__data_);
    }
  }
  *(_OWORD *)&v102.__r_.__value_.__r.__words[1] = 0uLL;
  v102.__r_.__value_.__r.__words[0] = (std::string::size_type)&v102.__r_.__value_.__l.__size_;
  uint64_t v46 = HIBYTE(v106[3]);
  if (v106[3] < 0) {
    uint64_t v46 = v106[2];
  }
  if (v46)
  {
    if (SHIBYTE(v106[3]) < 0) {
      sub_10004FC84(&__dst, (void *)v106[1], v106[2]);
    }
    else {
      std::string __dst = *(std::string *)&v106[1];
    }
    sub_100058DB0(__p, "imdn.Message-ID");
    if (SHIBYTE(v101) < 0)
    {
      sub_10004FC84(&v117, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v117 = *(_OWORD *)__p;
      uint64_t v118 = v101;
    }
    v116 = &v117;
    uint64_t v51 = sub_100B96810((uint64_t **)&v102, (void **)&v117, &v116);
    uint64_t v52 = (void **)v51 + 7;
    if (*((char *)v51 + 79) < 0) {
      operator delete(*v52);
    }
    *(std::string *)uint64_t v52 = __dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
    __dst.__r_.__value_.__s.__data_[0] = 0;
    if (SHIBYTE(v118) < 0) {
      operator delete((void *)v117);
    }
    if (SHIBYTE(v101) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v53 = BYTE7(v108);
  if (SBYTE7(v108) < 0) {
    uint64_t v53 = *((void *)&v107 + 1);
  }
  if (v53)
  {
    if (SBYTE7(v108) < 0)
    {
      sub_10004FC84(&__dst, (void *)v107, *((unint64_t *)&v107 + 1));
    }
    else
    {
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v107;
      __dst.__r_.__value_.__r.__words[2] = v108;
    }
    sub_100058DB0(__p, "imdn.Disposition-Notification");
    if (SHIBYTE(v101) < 0)
    {
      sub_10004FC84(&v117, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v117 = *(_OWORD *)__p;
      uint64_t v118 = v101;
    }
    v116 = &v117;
    uint64_t v54 = sub_100B96810((uint64_t **)&v102, (void **)&v117, &v116);
    uint64_t v55 = (void **)v54 + 7;
    if (*((char *)v54 + 79) < 0) {
      operator delete(*v55);
    }
    *(std::string *)uint64_t v55 = __dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
    __dst.__r_.__value_.__s.__data_[0] = 0;
    if (SHIBYTE(v118) < 0) {
      operator delete((void *)v117);
    }
    if (SHIBYTE(v101) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  sub_100B964AC((uint64_t)v98, (uint64_t)&v102);
  sub_100B964AC((uint64_t)&__dst, (uint64_t)v98);
  uint64_t v56 = a1 + 208;
  sub_10010C0E0(a1 + 200, *(void **)(a1 + 208));
  std::string::size_type size = (void *)__dst.__r_.__value_.__l.__size_;
  *(void *)(a1 + 200) = __dst.__r_.__value_.__r.__words[0];
  *(void *)(a1 + 208) = size;
  std::string::size_type v58 = __dst.__r_.__value_.__r.__words[2];
  *(void *)(a1 + 216) = *((void *)&__dst.__r_.__value_.__l + 2);
  if (v58)
  {
    size[2] = v56;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst.__r_.__value_.__l.__size_;
    *(_OWORD *)&__dst.__r_.__value_.__r.__words[1] = 0uLL;
    std::string::size_type size = 0;
  }
  else
  {
    *(void *)(a1 + 200) = v56;
  }
  sub_10010C0E0((uint64_t)&__dst, size);
  sub_10010C0E0((uint64_t)v98, v99);
  BOOL v25 = v110 != *((void *)&v110 + 1);
  if ((void)v110 == *((void *)&v110 + 1))
  {
    long long v72 = *(NSObject **)a1;
    if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "Decoded CPIM message with no content", (uint8_t *)&__dst, 2u);
    }
    goto LABEL_181;
  }
  uint64_t v59 = (uint8_t *)(a1 + 296);
  if (*(unsigned __int8 *)(a1 + 464) != BYTE8(v111))
  {
    if (*(unsigned char *)(a1 + 464))
    {
      sub_100B9630C(a1 + 296);
      *(unsigned char *)(a1 + 464) = 0;
    }
    else
    {
      if (SHIBYTE(v104[0]) < 0)
      {
        sub_10004FC84((unsigned char *)(a1 + 296), *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        *(_OWORD *)uint64_t v59 = *(_OWORD *)buf;
        *(void **)(a1 + 312) = v104[0];
      }
      if (SHIBYTE(v104[3]) < 0)
      {
        sub_10004FC84((unsigned char *)(a1 + 320), v104[1], (unint64_t)v104[2]);
      }
      else
      {
        *(_OWORD *)(a1 + 320) = *(_OWORD *)&v104[1];
        *(void **)(a1 + 336) = v104[3];
      }
      if (SHIBYTE(v106[0]) < 0)
      {
        sub_10004FC84((unsigned char *)(a1 + 344), v105[0], (unint64_t)v105[1]);
      }
      else
      {
        *(_OWORD *)(a1 + 344) = *(_OWORD *)v105;
        *(void *)(a1 + 360) = v106[0];
      }
      if (SHIBYTE(v106[3]) < 0)
      {
        sub_10004FC84((unsigned char *)(a1 + 368), (void *)v106[1], v106[2]);
      }
      else
      {
        *(_OWORD *)(a1 + 368) = *(_OWORD *)&v106[1];
        *(void *)(a1 + 384) = v106[3];
      }
      if (SBYTE7(v108) < 0)
      {
        sub_10004FC84((unsigned char *)(a1 + 392), (void *)v107, *((unint64_t *)&v107 + 1));
      }
      else
      {
        *(_OWORD *)(a1 + 392) = v107;
        *(void *)(a1 + 408) = v108;
      }
      *(void *)(a1 + 416) = 0;
      *(void *)(a1 + 424) = 0;
      *(void *)(a1 + 432) = 0;
      uint64_t v74 = *((void *)&v108 + 1);
      uint64_t v75 = v109;
      __dst.__r_.__value_.__r.__words[0] = a1 + 416;
      if ((void)v109 != *((void *)&v108 + 1))
      {
        __dst.__r_.__value_.__l.__size_ = 0;
        sub_100B9118C((void *)(a1 + 416), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v109 - *((void *)&v108 + 1)) >> 4));
        *(void *)(a1 + 424) = sub_100B911DC(v74, v75, *(void *)(a1 + 424));
      }
      *(void *)(a1 + 440) = 0;
      *(void *)(a1 + 448) = 0;
      *(void *)(a1 + 456) = 0;
      long long v76 = v110;
      __dst.__r_.__value_.__r.__words[0] = a1 + 440;
      if (*((void *)&v110 + 1) != (void)v110)
      {
        __dst.__r_.__value_.__l.__size_ = 0;
        sub_100B912D4((void *)(a1 + 440), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v110 + 1) - v110) >> 7));
        *(void *)(a1 + 448) = sub_100B91324(v76, *((uint64_t *)&v76 + 1), *(void *)(a1 + 448));
      }
      *(unsigned char *)(a1 + 464) = 1;
    }
    goto LABEL_167;
  }
  if (!*(unsigned char *)(a1 + 464)) {
    goto LABEL_167;
  }
  std::string::operator=((std::string *)(a1 + 296), (const std::string *)buf);
  std::string::operator=((std::string *)(a1 + 320), (const std::string *)&v104[1]);
  std::string::operator=((std::string *)(a1 + 344), (const std::string *)v105);
  std::string::operator=((std::string *)(a1 + 368), (const std::string *)&v106[1]);
  std::string::operator=((std::string *)(a1 + 392), (const std::string *)&v107);
  if (v59 == buf) {
    goto LABEL_167;
  }
  uint64_t v61 = *((void *)&v108 + 1);
  uint64_t v60 = v109;
  unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v109 - *((void *)&v108 + 1)) >> 4);
  uint64_t v63 = *(void *)(a1 + 432);
  uint64_t v64 = *(void *)(a1 + 416);
  if (0xAAAAAAAAAAAAAAABLL * ((v63 - v64) >> 4) >= v62)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 424) - v64) >> 4) >= v62)
    {
      uint64_t v77 = sub_1001FA758(*((std::string **)&v108 + 1), (std::string *)v109, *(std::string **)(a1 + 416));
      for (uint64_t i = *(void *)(a1 + 424); (std::string *)i != v77; sub_1000FECD4(i))
        i -= 48;
      *(void *)(a1 + 424) = v77;
      goto LABEL_147;
    }
    uint64_t v73 = (std::string *)(*((void *)&v108 + 1) + 16 * ((*(void *)(a1 + 424) - v64) >> 4));
    sub_1001FA758(*((std::string **)&v108 + 1), v73, *(std::string **)(a1 + 416));
    uint64_t v71 = sub_100B911DC((uint64_t)v73, v60, *(void *)(a1 + 424));
  }
  else
  {
    long long v65 = (void **)(a1 + 416);
    if (v64)
    {
      uint64_t v66 = *(void *)(a1 + 424);
      long long v67 = *(void **)(a1 + 416);
      if (v66 != v64)
      {
        do
        {
          v66 -= 48;
          sub_1000FECD4(v66);
        }
        while (v66 != v64);
        long long v67 = *v65;
      }
      *(void *)(a1 + 424) = v64;
      operator delete(v67);
      uint64_t v63 = 0;
      *long long v65 = 0;
      *(void *)(a1 + 424) = 0;
      *(void *)(a1 + 432) = 0;
    }
    if (v62 > 0x555555555555555) {
      sub_10006A748();
    }
    unint64_t v68 = 0xAAAAAAAAAAAAAAABLL * (v63 >> 4);
    uint64_t v69 = 2 * v68;
    if (2 * v68 <= v62) {
      uint64_t v69 = v62;
    }
    if (v68 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v70 = 0x555555555555555;
    }
    else {
      unint64_t v70 = v69;
    }
    sub_100B9118C((void *)(a1 + 416), v70);
    uint64_t v71 = sub_100B911DC(v61, v60, *(void *)(a1 + 424));
  }
  *(void *)(a1 + 424) = v71;
LABEL_147:
  long long v79 = v110;
  unint64_t v80 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v110 + 1) - v110) >> 7);
  uint64_t v81 = *(void *)(a1 + 456);
  uint64_t v82 = *(void *)(a1 + 440);
  if (0xAAAAAAAAAAAAAAABLL * ((v81 - v82) >> 7) >= v80)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 448) - v82) >> 7) >= v80)
    {
      long long v91 = sub_100B935C0((std::string *)v110, *((std::string **)&v110 + 1), *(std::string **)(a1 + 440));
      for (uint64_t j = *(void *)(a1 + 448); (std::string *)j != v91; sub_100B93570(j))
        j -= 384;
      *(void *)(a1 + 448) = v91;
      goto LABEL_167;
    }
    long long v90 = (std::string *)(v110 + ((*(void *)(a1 + 448) - v82) >> 7 << 7));
    sub_100B935C0((std::string *)v110, v90, *(std::string **)(a1 + 440));
    uint64_t v89 = sub_100B91324((uint64_t)v90, *((uint64_t *)&v79 + 1), *(void *)(a1 + 448));
  }
  else
  {
    long long v83 = (void **)(a1 + 440);
    if (v82)
    {
      uint64_t v84 = *(void *)(a1 + 448);
      uint64_t v85 = *(void **)(a1 + 440);
      if (v84 != v82)
      {
        do
        {
          v84 -= 384;
          sub_100B93570(v84);
        }
        while (v84 != v82);
        uint64_t v85 = *v83;
      }
      *(void *)(a1 + 448) = v82;
      operator delete(v85);
      uint64_t v81 = 0;
      *long long v83 = 0;
      *(void *)(a1 + 448) = 0;
      *(void *)(a1 + 456) = 0;
    }
    if (v80 > 0xAAAAAAAAAAAAAALL) {
      sub_10006A748();
    }
    unint64_t v86 = 0xAAAAAAAAAAAAAAABLL * (v81 >> 7);
    uint64_t v87 = 2 * v86;
    if (2 * v86 <= v80) {
      uint64_t v87 = v80;
    }
    if (v86 >= 0x55555555555555) {
      unint64_t v88 = 0xAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v88 = v87;
    }
    sub_100B912D4((void *)(a1 + 440), v88);
    uint64_t v89 = sub_100B91324(v79, *((uint64_t *)&v79 + 1), *(void *)(a1 + 448));
  }
  *(void *)(a1 + 448) = v89;
LABEL_167:
  uint64_t v93 = v110;
  if (*((void *)&v110 + 1) - (void)v110 == 384)
  {
    sub_100CC8650(&__dst, v110);
  }
  else
  {
    sub_100058DB0(&__dst, "application/vnd.gsma.botsuggestion.v1.0+json");
    BOOL v94 = sub_1010E5F80(v93, (uint64_t)&__dst);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (v94)
    {
      sub_100CC8650(&__dst, v93);
      sub_100B90744(a1 + 224, (long long *)&__dst);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      sub_100CC8650(&__dst, v93 + 384);
    }
    else
    {
      sub_100CC8650(&__dst, v93 + 384);
      sub_100B90744(a1 + 224, (long long *)&__dst);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      sub_100CC8650(&__dst, v93);
    }
  }
  long long v95 = (void **)(a1 + 136);
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*v95);
  }
  *(_OWORD *)long long v95 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
  uint64_t v96 = v120;
  *(void *)(a1 + 152) = *((void *)&__dst.__r_.__value_.__l + 2);
  *(void *)(a1 + 160) = v96;
  *(_DWORD *)(a1 + 168) = v121;
LABEL_181:
  sub_10010C0E0((uint64_t)&v102, (void *)v102.__r_.__value_.__l.__size_);
LABEL_182:
  if (BYTE8(v111))
  {
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v110;
    sub_100B963A8((void ***)&__dst);
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v108 + 8;
    sub_100155410((void ***)&__dst);
    if (SBYTE7(v108) < 0) {
      operator delete((void *)v107);
    }
    if (SHIBYTE(v106[3]) < 0) {
      operator delete((void *)v106[1]);
    }
    if (SHIBYTE(v106[0]) < 0) {
      operator delete(v105[0]);
    }
    if (SHIBYTE(v104[3]) < 0) {
      operator delete(v104[1]);
    }
    if (SHIBYTE(v104[0]) < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (v113) {
    sub_10004D2C8(v113);
  }
  sub_100127D74((const void **)&v114);
  sub_100030068((const void **)&v115);
  if ((v14 & 1) == 0) {
LABEL_196:
  }
    sub_10004D2C8(v12);
  return v25;
}

void sub_100B90504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,void *a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  *(void *)(v49 + 448) = v50;
  sub_10010C0E0((uint64_t)&a21, a22);
  if (a48) {
    sub_100B9630C((uint64_t)&a27);
  }
  uint64_t v54 = *(std::__shared_weak_count **)(v52 - 208);
  if (v54) {
    sub_10004D2C8(v54);
  }
  sub_100127D74((const void **)(v52 - 200));
  sub_100030068((const void **)(v52 - 192));
  if ((v51 & 1) == 0) {
    sub_10004D2C8(v48);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B90744(uint64_t a1, long long *a2)
{
  if (*(unsigned char *)(a1 + 40))
  {
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    long long v4 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v4;
    *((unsigned char *)a2 + 23) = 0;
    *(unsigned char *)a2 = 0;
    uint64_t v5 = *((void *)a2 + 3);
    *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
    *(void *)(a1 + 24) = v5;
  }
  else
  {
    long long v6 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v6;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    uint64_t v7 = *((void *)a2 + 3);
    *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
    *(void *)(a1 + 24) = v7;
    *(unsigned char *)(a1 + 40) = 1;
  }
  return a1;
}

void sub_100B907E0(uint64_t a1, int a2)
{
  long long v4 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "[Incoming]";
    if (!a2) {
      uint64_t v5 = "[Outgoing]";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I CPIM message: %{public}s", (uint8_t *)&buf, 0xCu);
    long long v4 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 31) < 0) {
      sub_10004FC84(&buf, *(void **)(a1 + 8), *(void *)(a1 + 16));
    }
    else {
      std::string buf = *(std::string *)(a1 + 8);
    }
    p_std::string buf = &buf;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int v37 = 136380675;
    uint64_t v38 = (uint64_t)p_buf;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ==== From: [%{private}s]", v37, 0xCu);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    long long v4 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 55) < 0) {
      sub_10004FC84(&buf, *(void **)(a1 + 32), *(void *)(a1 + 40));
    }
    else {
      std::string buf = *(std::string *)(a1 + 32);
    }
    uint64_t v7 = &buf;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v7 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int v37 = 136380675;
    uint64_t v38 = (uint64_t)v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ====   To: [%{private}s]", v37, 0xCu);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    long long v4 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    long long v8 = (void *)(a1 + 272);
    if (*(char *)(a1 + 295) < 0) {
      long long v8 = (void *)*v8;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136380675;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ====   NS: [%{private}s]", (uint8_t *)&buf, 0xCu);
    long long v4 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = (void *)(a1 + 96);
    if (*(char *)(a1 + 119) < 0) {
      uint64_t v9 = (void *)*v9;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136380675;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ==== Date: [%{private}s]", (uint8_t *)&buf, 0xCu);
    long long v4 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v10 = (void *)(a1 + 136);
    if (*(char *)(a1 + 159) < 0) {
      unsigned int v10 = (void *)*v10;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136380675;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ==== Inner content type: [%{private}s]", (uint8_t *)&buf, 0xCu);
  }
  if (*(unsigned char *)(a1 + 264))
  {
    long long v11 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      std::string v12 = (void *)(a1 + 224);
      if (*(char *)(a1 + 247) < 0) {
        std::string v12 = (void *)*v12;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136380675;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I ==== Additional Content Type: %{private}s", (uint8_t *)&buf, 0xCu);
    }
  }
  uint64_t v13 = *(void **)(a1 + 200);
  if (v13 != (void *)(a1 + 208))
  {
    do
    {
      char v14 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v15 = v13[4];
        if (*((char *)v13 + 55) >= 0) {
          std::string::size_type v15 = (std::string::size_type)(v13 + 4);
        }
        std::string::size_type v16 = (std::string::size_type)(v13 + 7);
        if (*((char *)v13 + 79) < 0) {
          std::string::size_type v16 = v13[7];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136380931;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v15;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2081;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I --- [%{private}s]: [%{private}s]", (uint8_t *)&buf, 0x16u);
      }
      int v17 = (void *)v13[1];
      if (v17)
      {
        do
        {
          long long v18 = v17;
          int v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          long long v18 = (void *)v13[2];
          BOOL v19 = *v18 == (void)v13;
          uint64_t v13 = v18;
        }
        while (!v19);
      }
      uint64_t v13 = v18;
    }
    while (v18 != (void *)(a1 + 208));
  }
  CFDataRef v20 = (void **)(a1 + 56);
  if (*(char *)(a1 + 79) < 0)
  {
    unint64_t v21 = *(void *)(a1 + 64);
    if (!v21) {
      return;
    }
    memset(&buf, 0, sizeof(buf));
    sub_10004FC84(&buf, *v20, v21);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 79)) {
      return;
    }
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)v20;
    buf.__r_.__value_.__r.__words[2] = *(void *)(a1 + 72);
  }
  uint64_t v22 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  char v23 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  std::string::size_type size = buf.__r_.__value_.__l.__size_;
  std::string::size_type v24 = buf.__r_.__value_.__r.__words[0];
  uint64_t v26 = &buf;
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    xpc_object_t v27 = &buf;
  }
  else {
    xpc_object_t v27 = (std::string *)buf.__r_.__value_.__r.__words[0];
  }
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v28 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v28 = buf.__r_.__value_.__l.__size_;
  }
  uint64_t v29 = (std::string *)((char *)v27 + v28);
  if (v28)
  {
    std::string::size_type v30 = v28 - 1;
    while (v27->__r_.__value_.__s.__data_[0] != 13)
    {
      xpc_object_t v27 = (std::string *)((char *)v27 + 1);
      --v30;
      if (v27 == v29) {
        goto LABEL_77;
      }
    }
    if (v27 == v29 || (std::string *)((char *)&v27->__r_.__value_.__l.__data_ + 1) == v29)
    {
      uint64_t v29 = v27;
    }
    else
    {
      uint64_t v31 = 1;
      uint64_t v29 = v27;
      do
      {
        int v32 = v27->__r_.__value_.__s.__data_[v31];
        if (v32 != 13)
        {
          v29->__r_.__value_.__s.__data_[0] = v32;
          uint64_t v29 = (std::string *)((char *)v29 + 1);
        }
        ++v31;
        --v30;
      }
      while (v30);
      uint64_t v22 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      std::string::size_type size = buf.__r_.__value_.__l.__size_;
      std::string::size_type v24 = buf.__r_.__value_.__r.__words[0];
      char v23 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    }
  }
LABEL_77:
  unint64_t v33 = (char *)(v24 + size);
  uint64_t v34 = (char *)&buf + v22;
  if (v23 < 0)
  {
    uint64_t v34 = v33;
    uint64_t v26 = (std::string *)v24;
  }
  std::string::erase(&buf, (char *)v29 - (char *)v26, v34 - (char *)v29);
  unint64_t v35 = *(NSObject **)a1;
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v36 = &buf;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v36 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)int v37 = 141558275;
    uint64_t v38 = 1752392040;
    __int16 v39 = 2085;
    uint64_t v40 = v36;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I ==== Content: \n%{sensitive, mask.hash}s", v37, 0x16u);
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
}

void sub_100B90D94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

BOOL sub_100B90DB8(uint64_t a1)
{
  uint64_t v1 = a1 + 136;
  sub_100058DB0(__p, "text/plain");
  BOOL v2 = sub_100CC8758(v1, (char *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_100B90E14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B90E30(uint64_t a1)
{
  uint64_t v1 = a1 + 136;
  sub_100058DB0(__p, "application/vnd.gsma.rcspushlocation+xml");
  BOOL v2 = sub_100CC8758(v1, (char *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_100B90E8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B90EA8(uint64_t a1)
{
  uint64_t v1 = a1 + 136;
  sub_100058DB0(__p, "message/imdn+xml");
  BOOL v2 = sub_100CC8758(v1, (char *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_100B90F04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B90F20(uint64_t a1)
{
  uint64_t v1 = a1 + 136;
  sub_100058DB0(__p, "application/im-iscomposing+xml");
  BOOL v2 = sub_100CC8758(v1, (char *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_100B90F7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B90F98(uint64_t a1)
{
  uint64_t v1 = a1 + 136;
  sub_100058DB0(__p, "application/vnd.gsma.rcs-ft-http+xml");
  BOOL v2 = sub_100CC8758(v1, (char *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_100B90FF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B91010(uint64_t a1)
{
  uint64_t v1 = a1 + 136;
  sub_100058DB0(__p, "application/vnd.gsma.botmessage.v1.0+json");
  BOOL v2 = sub_100CC8758(v1, (char *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_100B9106C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B91088(uint64_t a1)
{
  uint64_t v1 = a1 + 136;
  sub_100058DB0(__p, "application/vnd.oma.cpm-groupdata+xml");
  BOOL v2 = sub_100CC8758(v1, (char *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_100B910E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B91100@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*((unsigned char *)result + 464) || (v4 = (long long *)result[55], char v5 = (long long *)result[56], v4 == v5))
  {
LABEL_5:
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 384) = 0;
  }
  else
  {
    while (1)
    {
      double result = (void *)sub_1010E5F80(a2, (uint64_t)v4);
      if (result) {
        break;
      }
      v4 += 24;
      if (v4 == v5) {
        goto LABEL_5;
      }
    }
    return sub_100B9642C((void *)a3, v4);
  }
  return result;
}

char *sub_100B9118C(void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    sub_10006A748();
  }
  uint64_t v3 = 3 * a2;
  double result = (char *)operator new(48 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v3];
  return result;
}

uint64_t sub_100B911DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a3 + v6;
      long long v8 = (long long *)(a1 + v6);
      if (*(char *)(a1 + v6 + 23) < 0)
      {
        sub_10004FC84((unsigned char *)v7, *(void **)v8, *((void *)v8 + 1));
      }
      else
      {
        long long v9 = *v8;
        *(void *)(v7 + 16) = *((void *)v8 + 2);
        *(_OWORD *)uint64_t v7 = v9;
      }
      unsigned int v10 = (unsigned char *)(a3 + v6 + 24);
      long long v11 = (void **)(a1 + v6 + 24);
      if (*(char *)(a1 + v6 + 47) < 0)
      {
        sub_10004FC84(v10, *v11, *(void *)(a1 + v6 + 32));
      }
      else
      {
        long long v12 = *(_OWORD *)v11;
        *(void *)(a3 + v6 + 40) = *(void *)(a1 + v6 + 40);
        *(_OWORD *)unsigned int v10 = v12;
      }
      v6 += 48;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_100B91294(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + v2 + 23) < 0) {
    operator delete(*(void **)(v1 + v2));
  }
  if (v2)
  {
    uint64_t v4 = v1 - 48;
    do
    {
      sub_1000FECD4(v4 + v2);
      v2 -= 48;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100B912D4(void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAABLL) {
    sub_10006A748();
  }
  uint64_t v3 = 3 * a2;
  double result = (char *)operator new(384 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[128 * v3];
  return result;
}

uint64_t sub_100B91324(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a3 + v6;
      long long v8 = (long long *)(a1 + v6);
      if (*(char *)(a1 + v6 + 23) < 0)
      {
        sub_10004FC84((unsigned char *)v7, *(void **)v8, *((void *)v8 + 1));
      }
      else
      {
        long long v9 = *v8;
        *(void *)(v7 + 16) = *((void *)v8 + 2);
        *(_OWORD *)uint64_t v7 = v9;
      }
      sub_100B913FC(a3 + v6 + 32, a1 + v6 + 32);
      v6 += 384;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_100B913C0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 384;
    do
    {
      sub_100B93570(v4 + v2);
      v2 -= 384;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B913FC(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 344) = -1;
  sub_100B91444(a1, a2);
  return a1;
}

void sub_100B91430(_Unwind_Exception *a1)
{
  sub_100B93514(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B91444(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 344);
  if (v4 != -1) {
    double result = ((uint64_t (*)(char *, uint64_t))off_101A410E8[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 344) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 344);
  if (v5 != -1)
  {
    double result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_101A411B0 + v5))(&v6, v3, a2);
    *(_DWORD *)(v3 + 344) = v5;
  }
  return result;
}

void sub_100B914D8(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_100B914EC(uint64_t a1, uint64_t a2)
{
  sub_100B9164C(a2 + 144);
  if (*(char *)(a2 + 127) < 0) {
    operator delete(*(void **)(a2 + 104));
  }
  if (*(char *)(a2 + 103) < 0) {
    operator delete(*(void **)(a2 + 80));
  }
  if (*(char *)(a2 + 79) < 0) {
    operator delete(*(void **)(a2 + 56));
  }
  if (*(unsigned char *)(a2 + 48) && *(char *)(a2 + 47) < 0)
  {
    uint64_t v3 = *(void **)(a2 + 24);
    operator delete(v3);
  }
}

uint64_t sub_100B91574(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 336)) {
    return sub_100B916C0(a2);
  }
  return result;
}

void sub_100B91588(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 55) < 0) {
    operator delete(*(void **)(a2 + 32));
  }
  if (*(char *)(a2 + 31) < 0)
  {
    uint64_t v3 = *(void **)(a2 + 8);
    operator delete(v3);
  }
}

void sub_100B915E0(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 55) < 0) {
    operator delete(*(void **)(a2 + 32));
  }
  if (*(char *)(a2 + 31) < 0)
  {
    uint64_t v3 = *(void **)(a2 + 8);
    operator delete(v3);
  }
}

void sub_100B91638(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

uint64_t sub_100B9164C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 144))
  {
    if (*(char *)(a1 + 127) < 0) {
      operator delete(*(void **)(a1 + 104));
    }
    if (*(char *)(a1 + 103) < 0) {
      operator delete(*(void **)(a1 + 80));
    }
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
  }
  return a1;
}

uint64_t sub_100B916C0(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 328);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_101A41120[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 328) = -1;
  return a1;
}

void sub_100B9171C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 320))
  {
    uint64_t v3 = (void **)(a2 + 296);
    sub_100B91828(&v3);
  }
  if (*(unsigned char *)(a2 + 288) && *(char *)(a2 + 287) < 0) {
    operator delete(*(void **)(a2 + 264));
  }
  if (*(unsigned char *)(a2 + 256) && *(char *)(a2 + 255) < 0) {
    operator delete(*(void **)(a2 + 232));
  }
  sub_1004563E8(a2 + 48);
  if (*(unsigned char *)(a2 + 40))
  {
    if (*(char *)(a2 + 39) < 0) {
      operator delete(*(void **)(a2 + 16));
    }
  }
}

void sub_100B917B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void **)(a2 + 48);
  sub_100B91D78(&v3);
  if (*(unsigned char *)(a2 + 40))
  {
    if (*(char *)(a2 + 39) < 0) {
      operator delete(*(void **)(a2 + 16));
    }
  }
}

void sub_100B91800(uint64_t a1, void **a2)
{
  uint64_t v2 = a2;
  sub_100B91828(&v2);
}

void sub_100B91828(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    char v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        char v6 = v4 - 232;
        sub_100B918B0((uint64_t)(v4 - 224));
        char v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100B918B0(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 216);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_101A41138[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 216) = -1;
  return a1;
}

void sub_100B9190C(uint64_t a1, uint64_t a2)
{
  sub_100B919D4(a2 + 72);
  if (*(unsigned char *)(a2 + 56) && *(char *)(a2 + 55) < 0) {
    operator delete(*(void **)(a2 + 32));
  }
  if (*(char *)(a2 + 31) < 0)
  {
    uint64_t v3 = *(void **)(a2 + 8);
    operator delete(v3);
  }
}

void sub_100B91974(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 48) && *(char *)(a2 + 47) < 0) {
    operator delete(*(void **)(a2 + 24));
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

uint64_t sub_100B919D4(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 136);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_101A41148[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 136) = -1;
  return a1;
}

void sub_100B91A30(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 55) < 0) {
    operator delete(*(void **)(a2 + 32));
  }
  if (*(char *)(a2 + 31) < 0)
  {
    uint64_t v3 = *(void **)(a2 + 8);
    operator delete(v3);
  }
}

void sub_100B91A88(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_100B91A9C(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 47) < 0) {
    operator delete(*(void **)(a2 + 24));
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

void sub_100B91AF4(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_100B91B08(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void sub_100B91B1C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 112) && *(char *)(a2 + 111) < 0) {
    operator delete(*(void **)(a2 + 88));
  }
  if (*(unsigned char *)(a2 + 80) && *(char *)(a2 + 79) < 0) {
    operator delete(*(void **)(a2 + 56));
  }
  if (*(unsigned char *)(a2 + 48) && *(char *)(a2 + 47) < 0)
  {
    uint64_t v3 = *(void **)(a2 + 24);
    operator delete(v3);
  }
}

void sub_100B91BA0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 128) && *(char *)(a2 + 127) < 0) {
    operator delete(*(void **)(a2 + 104));
  }
  if (*(unsigned char *)(a2 + 96) && *(char *)(a2 + 95) < 0) {
    operator delete(*(void **)(a2 + 72));
  }
  if (*(char *)(a2 + 71) < 0) {
    operator delete(*(void **)(a2 + 48));
  }
  if (*(char *)(a2 + 47) < 0) {
    operator delete(*(void **)(a2 + 24));
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

void sub_100B91C38(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 48) && *(char *)(a2 + 47) < 0) {
    operator delete(*(void **)(a2 + 24));
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

void sub_100B91C98(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 80) && *(char *)(a2 + 79) < 0) {
    operator delete(*(void **)(a2 + 56));
  }
  if (*(unsigned char *)(a2 + 48) && *(char *)(a2 + 47) < 0) {
    operator delete(*(void **)(a2 + 24));
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

void sub_100B91D10(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 48) && *(char *)(a2 + 47) < 0) {
    operator delete(*(void **)(a2 + 24));
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v3 = *(void **)a2;
    operator delete(v3);
  }
}

void sub_100B91D78(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 280;
        sub_100B91DFC(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100B91DFC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 272))
  {
    uint64_t v3 = (void **)(a1 + 248);
    sub_100B91828(&v3);
  }
  if (*(unsigned char *)(a1 + 240) && *(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  if (*(unsigned char *)(a1 + 208) && *(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  return sub_1004563E8(a1);
}

__n128 sub_100B91E74(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

void *sub_100B91E80(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    __n128 result = sub_10004FC84(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    __dst[2] = *((void *)a3 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  __dst[3] = *((void *)a3 + 3);
  return result;
}

unsigned char *sub_100B91ED4(uint64_t a1, uint64_t a2, long long *a3)
{
  return sub_100B9223C((unsigned char *)(a2 + 144), (uint64_t)(a3 + 9));
}

void sub_100B91F10(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 127) < 0) {
    operator delete(*(void **)(v1 + 104));
  }
  if (*(char *)(v1 + 103) < 0) {
    operator delete(*(void **)(v1 + 80));
  }
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*(void **)(v1 + 56));
  }
  if (*(unsigned char *)(v1 + 48))
  {
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100B91F64(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  return sub_100B92294(a2, a3);
}

unsigned char *sub_100B91F70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a2 = *(_DWORD *)a3;
  long long v5 = (unsigned char *)(a2 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(v5, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(a3 + 8);
    *(void *)(a2 + 24) = *(void *)(a3 + 24);
    *(_OWORD *)long long v5 = v6;
  }
  __n128 result = (unsigned char *)(a2 + 32);
  if (*(char *)(a3 + 55) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }
  else
  {
    long long v8 = *(_OWORD *)(a3 + 32);
    *(void *)(a2 + 48) = *(void *)(a3 + 48);
    *(_OWORD *)__n128 result = v8;
  }
  *(void *)(a2 + 56) = *(void *)(a3 + 56);
  return result;
}

void sub_100B92008(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100B92024(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a2 = *(_DWORD *)a3;
  long long v5 = (unsigned char *)(a2 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(v5, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(a3 + 8);
    *(void *)(a2 + 24) = *(void *)(a3 + 24);
    *(_OWORD *)long long v5 = v6;
  }
  __n128 result = (unsigned char *)(a2 + 32);
  if (*(char *)(a3 + 55) < 0) {
    return sub_10004FC84(result, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }
  long long v8 = *(_OWORD *)(a3 + 32);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  *(_OWORD *)__n128 result = v8;
  return result;
}

void sub_100B920B4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B920D0(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0) {
    return sub_10004FC84(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  long long v3 = *a3;
  __dst[2] = *((void *)a3 + 2);
  *(_OWORD *)std::string __dst = v3;
  return result;
}

uint64_t sub_100B920FC(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  sub_1000593FC(a1 + 24, (long long *)((char *)a2 + 24));
  if (*((char *)a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *((void **)a2 + 7), *((void *)a2 + 8));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 56);
    *(void *)(a1 + 72) = *((void *)a2 + 9);
    *(_OWORD *)(a1 + 56) = v5;
  }
  if (*((char *)a2 + 103) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 80), *((void **)a2 + 10), *((void *)a2 + 11));
  }
  else
  {
    long long v6 = a2[5];
    *(void *)(a1 + 96) = *((void *)a2 + 12);
    *(_OWORD *)(a1 + 80) = v6;
  }
  char v7 = (unsigned char *)(a1 + 104);
  if (*((char *)a2 + 127) < 0)
  {
    sub_10004FC84(v7, *((void **)a2 + 13), *((void *)a2 + 14));
  }
  else
  {
    long long v8 = *(long long *)((char *)a2 + 104);
    *(void *)(a1 + 120) = *((void *)a2 + 15);
    *(_OWORD *)char v7 = v8;
  }
  *(_OWORD *)(a1 + 128) = a2[8];
  return a1;
}

void sub_100B921E8(_Unwind_Exception *exception_object)
{
  if (v1[103] < 0) {
    operator delete(*v4);
  }
  if (v1[79] < 0) {
    operator delete(*v3);
  }
  if (v1[48])
  {
    if (v1[47] < 0) {
      operator delete(*v2);
    }
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100B9223C(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[144] = 0;
  if (*(unsigned char *)(a2 + 144))
  {
    sub_100B920FC((uint64_t)a1, (long long *)a2);
    a1[144] = 1;
  }
  return a1;
}

void sub_100B92280(_Unwind_Exception *a1)
{
  sub_100B9164C(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_100B92294(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[336] = 0;
  if (*(unsigned char *)(a2 + 336))
  {
    sub_100B922F4((uint64_t)a1, a2);
    a1[336] = 1;
  }
  return a1;
}

void sub_100B922D8(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 336)) {
    sub_100B916C0(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B922F4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 328) = -1;
  uint64_t v3 = *(unsigned int *)(a2 + 328);
  if (v3 != -1)
  {
    ((void (*)(char *, uint64_t, uint64_t))off_101A411E8[v3])(&v5, a1, a2);
    *(_DWORD *)(a1 + 328) = v3;
  }
  return a1;
}

void sub_100B92358(_Unwind_Exception *a1)
{
  sub_100B916C0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B9236C(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  return sub_100B92448(a2, a3);
}

void *sub_100B92378(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  *(_DWORD *)(a2 + 8) = *((_DWORD *)a3 + 2);
  *(void *)a2 = v5;
  sub_100B92544((unsigned char *)(a2 + 16), (long long *)a3 + 1);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  return sub_100B93324((void *)(a2 + 48), a3[6], a3[7], 0xAF8AF8AF8AF8AF8BLL * ((a3[7] - a3[6]) >> 3));
}

void sub_100B923F4(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 40))
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*v2);
    }
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B92418(uint64_t a1, void *a2, uint64_t *a3)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_100B92920(a2, *a3, a3[1], 0x34F72C234F72C235 * ((a3[1] - *a3) >> 3));
}

uint64_t sub_100B92448(uint64_t a1, _OWORD *a2)
{
  *(_OWORD *)a1 = *a2;
  sub_100B92544((unsigned char *)(a1 + 16), a2 + 1);
  sub_100B925D0((char *)(a1 + 48), (uint64_t)(a2 + 3));
  sub_100B92770((unsigned char *)(a1 + 232), (_OWORD *)((char *)a2 + 232));
  sub_100B927FC((unsigned char *)(a1 + 264), (_OWORD *)((char *)a2 + 264));
  sub_100B92888(a1 + 296, (uint64_t)a2 + 296);
  return a1;
}

void sub_100B924D0(_Unwind_Exception *a1)
{
  if (v2[288] && v2[287] < 0) {
    operator delete(*v5);
  }
  if (v2[256] && v2[255] < 0) {
    operator delete(*v4);
  }
  sub_1004563E8(v3);
  if (v2[40])
  {
    if (v2[39] < 0) {
      operator delete(*v1);
    }
  }
  _Unwind_Resume(a1);
}

unsigned char *sub_100B92544(unsigned char *__dst, long long *a2)
{
  void *__dst = 0;
  __dst[24] = 0;
  if (*((unsigned char *)a2 + 24))
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v3 = *a2;
      *((void *)__dst + 2) = *((void *)a2 + 2);
      *(_OWORD *)std::string __dst = v3;
    }
    __dst[24] = 1;
  }
  return __dst;
}

void sub_100B925AC(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

char *sub_100B925D0(char *__dst, uint64_t a2)
{
  void *__dst = 0;
  __dst[176] = 0;
  if (*(unsigned char *)(a2 + 176))
  {
    sub_100B92628(__dst, (long long *)a2);
    __dst[176] = 1;
  }
  return __dst;
}

void sub_100B92614(_Unwind_Exception *a1)
{
  sub_1004563E8(v1);
  _Unwind_Resume(a1);
}

char *sub_100B92628(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  *((void *)__dst + 6) = *((void *)a2 + 6);
  sub_1000593FC((uint64_t)(__dst + 56), (long long *)((char *)a2 + 56));
  sub_1000593FC((uint64_t)(__dst + 88), (long long *)((char *)a2 + 88));
  long long v6 = *(long long *)((char *)a2 + 120);
  *((_DWORD *)__dst + 34) = *((_DWORD *)a2 + 34);
  *(_OWORD *)(__dst + 120) = v6;
  sub_1000593FC((uint64_t)(__dst + 144), a2 + 9);
  return __dst;
}

void sub_100B926FC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100B92770(unsigned char *__dst, long long *a2)
{
  void *__dst = 0;
  __dst[24] = 0;
  if (*((unsigned char *)a2 + 24))
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v3 = *a2;
      *((void *)__dst + 2) = *((void *)a2 + 2);
      *(_OWORD *)std::string __dst = v3;
    }
    __dst[24] = 1;
  }
  return __dst;
}

void sub_100B927D8(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100B927FC(unsigned char *__dst, long long *a2)
{
  void *__dst = 0;
  __dst[24] = 0;
  if (*((unsigned char *)a2 + 24))
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v3 = *a2;
      *((void *)__dst + 2) = *((void *)a2 + 2);
      *(_OWORD *)std::string __dst = v3;
    }
    __dst[24] = 1;
  }
  return __dst;
}

void sub_100B92864(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B92888(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_100B92920((void *)a1, *(void *)a2, *(void *)(a2 + 8), 0x34F72C234F72C235 * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_100B92900(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (*(unsigned char *)(v10 + 24))
  {
    a10 = v10;
    sub_100B91828((void ***)&a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B92920(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_100B929A4(result, a4);
    __n128 result = (void *)sub_100B929FC(a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100B92984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100B91828(&a9);
  _Unwind_Resume(a1);
}

char *sub_100B929A4(void *a1, unint64_t a2)
{
  if (a2 >= 0x11A7B9611A7B962) {
    sub_10006A748();
  }
  uint64_t v3 = 232 * a2;
  __n128 result = (char *)operator new(232 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[v3];
  return result;
}

uint64_t sub_100B929FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      char v7 = (_DWORD *)(a3 + v6);
      uint64_t v8 = a1 + v6;
      *char v7 = *(_DWORD *)(a1 + v6);
      *(unsigned char *)(a3 + v6 + 8) = 0;
      v7[56] = -1;
      uint64_t v9 = *(unsigned int *)(a1 + v6 + 224);
      if (v9 != -1)
      {
        ((void (*)(char *, uint64_t, uint64_t))*(&off_101A41200 + v9))(&v11, a3 + v6 + 8, v8 + 8);
        v7[56] = v9;
      }
      v6 += 232;
    }
    while (v8 + 232 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_100B92AB8(_Unwind_Exception *a1)
{
  sub_100B918B0(v1 + v2 + 8);
  if (v2)
  {
    uint64_t v4 = v1 - 224;
    do
    {
      sub_100B918B0(v4 + v2);
      v2 -= 232;
    }
    while (v2);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B92AE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a2 = *(_DWORD *)a3;
  long long v5 = (unsigned char *)(a2 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(v5, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(a3 + 8);
    *(void *)(a2 + 24) = *(void *)(a3 + 24);
    *(_OWORD *)long long v5 = v6;
  }
  sub_100B92C18((unsigned char *)(a2 + 32), (long long *)(a3 + 32));
  return sub_100B92CA4(a2 + 72, a3 + 72);
}

void sub_100B92B68(_Unwind_Exception *exception_object)
{
  if (v2[56] && v2[55] < 0) {
    operator delete(*v3);
  }
  if (v2[31] < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100B92BA4(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    __dst[2] = *((void *)a3 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  return sub_100B92C18((unsigned char *)__dst + 24, (long long *)((char *)a3 + 24));
}

void sub_100B92BFC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100B92C18(unsigned char *__dst, long long *a2)
{
  void *__dst = 0;
  __dst[24] = 0;
  if (*((unsigned char *)a2 + 24))
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v3 = *a2;
      *((void *)__dst + 2) = *((void *)a2 + 2);
      *(_OWORD *)std::string __dst = v3;
    }
    __dst[24] = 1;
  }
  return __dst;
}

void sub_100B92C80(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B92CA4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 136) = -1;
  uint64_t v3 = *(unsigned int *)(a2 + 136);
  if (v3 != -1)
  {
    ((void (*)(char *, uint64_t, uint64_t))*(&off_101A41210 + v3))(&v5, a1, a2);
    *(_DWORD *)(a1 + 136) = v3;
  }
  return a1;
}

void sub_100B92D08(_Unwind_Exception *a1)
{
  sub_100B919D4(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_100B92D1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a2 = *(_DWORD *)a3;
  char v5 = (unsigned char *)(a2 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_10004FC84(v5, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(a3 + 8);
    *(void *)(a2 + 24) = *(void *)(a3 + 24);
    *(_OWORD *)char v5 = v6;
  }
  __n128 result = (unsigned char *)(a2 + 32);
  if (*(char *)(a3 + 55) < 0) {
    return sub_10004FC84(result, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }
  long long v8 = *(_OWORD *)(a3 + 32);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  *(_OWORD *)__n128 result = v8;
  return result;
}

void sub_100B92DAC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B92DC8(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0) {
    return sub_10004FC84(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  long long v3 = *a3;
  __dst[2] = *((void *)a3 + 2);
  *(_OWORD *)std::string __dst = v3;
  return result;
}

unsigned char *sub_100B92DF4(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    __dst[2] = *((void *)a3 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  __n128 result = __dst + 3;
  if (*((char *)a3 + 47) < 0) {
    return sub_10004FC84(result, *((void **)a3 + 3), *((void *)a3 + 4));
  }
  long long v7 = *(long long *)((char *)a3 + 24);
  __dst[5] = *((void *)a3 + 5);
  *(_OWORD *)__n128 result = v7;
  return result;
}

void sub_100B92E6C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B92E88(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0) {
    return sub_10004FC84(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  long long v3 = *a3;
  __dst[2] = *((void *)a3 + 2);
  *(_OWORD *)std::string __dst = v3;
  return result;
}

void *sub_100B92EB4(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0) {
    return sub_10004FC84(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  long long v3 = *a3;
  __dst[2] = *((void *)a3 + 2);
  *(_OWORD *)std::string __dst = v3;
  return result;
}

uint64_t sub_100B92EE0(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v5;
  sub_100B93150((unsigned char *)(a2 + 24), (long long *)((char *)a3 + 24));
  sub_1000593FC(a2 + 56, (long long *)((char *)a3 + 56));
  return sub_1000593FC(a2 + 88, (long long *)((char *)a3 + 88));
}

void sub_100B92F48(_Unwind_Exception *exception_object)
{
  if (v2[80] && v2[79] < 0) {
    operator delete(*v3);
  }
  if (v2[48])
  {
    if (v2[47] < 0) {
      operator delete(*v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100B92F8C(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *a2 = *a3;
}

char *sub_100B92F98(int a1, char *__dst, long long *a3)
{
  return sub_100B931DC(__dst, a3);
}

uint64_t sub_100B92FA4(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    __dst[2] = *((void *)a3 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  return sub_1000593FC((uint64_t)(__dst + 3), (long long *)((char *)a3 + 24));
}

void sub_100B92FFC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B93018(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    __dst[2] = *((void *)a3 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  sub_1000593FC((uint64_t)(__dst + 3), (long long *)((char *)a3 + 24));
  return sub_1000593FC((uint64_t)(__dst + 7), (long long *)((char *)a3 + 56));
}

void sub_100B93088(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 48) && *(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B930C4(int a1, void *__dst, long long *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    __dst[2] = *((void *)a3 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  return sub_1000593FC((uint64_t)(__dst + 3), (long long *)((char *)a3 + 24));
}

void sub_100B9311C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B93138(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void sub_100B93144(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

unsigned char *sub_100B93150(unsigned char *__dst, long long *a2)
{
  void *__dst = 0;
  __dst[24] = 0;
  if (*((unsigned char *)a2 + 24))
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v3 = *a2;
      *((void *)__dst + 2) = *((void *)a2 + 2);
      *(_OWORD *)std::string __dst = v3;
    }
    __dst[24] = 1;
  }
  return __dst;
}

void sub_100B931B8(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

char *sub_100B931DC(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(__dst + 48, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *((_OWORD *)__dst + 3) = v6;
  }
  sub_1000593FC((uint64_t)(__dst + 72), (long long *)((char *)a2 + 72));
  sub_1000593FC((uint64_t)(__dst + 104), (long long *)((char *)a2 + 104));
  return __dst;
}

void sub_100B932B8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B93324(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_100B933A8(result, a4);
    __n128 result = (void *)sub_100B93400(a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100B93388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100B91D78(&a9);
  _Unwind_Resume(a1);
}

char *sub_100B933A8(void *a1, unint64_t a2)
{
  if (a2 >= 0xEA0EA0EA0EA0EBLL) {
    sub_10006A748();
  }
  uint64_t v3 = 280 * a2;
  __n128 result = (char *)operator new(280 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[v3];
  return result;
}

uint64_t sub_100B93400(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      long long v7 = sub_100B925D0((char *)(a3 + v6), a1 + v6);
      sub_100B92770(v7 + 184, (long long *)(a1 + v6 + 184));
      sub_100B927FC((unsigned char *)(a3 + v6 + 216), (long long *)(a1 + v6 + 216));
      sub_100B92888(a3 + v6 + 248, a1 + v6 + 248);
      v6 += 280;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_100B93498(_Unwind_Exception *a1)
{
  uint64_t v4 = v1 + v2;
  if (*(unsigned char *)(v1 + v2 + 240) && *(char *)(v4 + 239) < 0) {
    operator delete(*(void **)(v4 + 216));
  }
  uint64_t v5 = v1 + v2;
  if (*(unsigned char *)(v1 + v2 + 208) && *(char *)(v5 + 207) < 0) {
    operator delete(*(void **)(v5 + 184));
  }
  sub_1004563E8(v1 + v2);
  if (v2)
  {
    uint64_t v6 = v1 - 280;
    do
    {
      sub_100B91DFC(v6 + v2);
      v2 -= 280;
    }
    while (v2);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B93514(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 344);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_101A410E8[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 344) = -1;
  return a1;
}

void sub_100B93570(uint64_t a1)
{
  sub_100B93514(a1 + 32);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

std::string *sub_100B935C0(std::string *__str, std::string *a2, std::string *this)
{
  if (__str != a2)
  {
    for (uint64_t i = __str; i != a2; i += 16)
    {
      std::string::operator=(this, i);
      uint64_t v6 = LODWORD(this[15].__r_.__value_.__r.__words[2]);
      uint64_t v7 = LODWORD(i[15].__r_.__value_.__r.__words[2]);
      if (v6 == -1)
      {
        if (v7 != -1)
        {
LABEL_7:
          uint64_t v9 = &this[1].__r_.__value_.__s.__data_[8];
          ((void (*)(std::string::value_type **))*(&off_101A41278 + v7))(&v9);
        }
      }
      else
      {
        if (v7 != -1) {
          goto LABEL_7;
        }
        ((void (*)(char *, std::string::size_type *))off_101A410E8[v6])(&v10, &this[1].__r_.__value_.__r.__words[1]);
        LODWORD(this[15].__r_.__value_.__r.__words[2]) = -1;
      }
      this += 16;
    }
  }
  return this;
}

__n128 sub_100B9368C(__n128 **a1, __n128 *a2, __n128 *a3)
{
  char v4 = *a1;
  uint64_t v5 = (*a1)[21].n128_u32[2];
  if (v5 != -1)
  {
    if (!v5)
    {
      __n128 result = *a3;
      *a2 = *a3;
      return result;
    }
    ((void (*)(char *, __n128 *))off_101A410E8[v5])(&v7, v4);
  }
  v4[21].n128_u32[2] = -1;
  __n128 result = *a3;
  __n128 *v4 = *a3;
  v4[21].n128_u32[2] = 0;
  return result;
}

double sub_100B93704(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  int v5 = *(_DWORD *)(*a1 + 344);
  if (v5 == 1)
  {
    std::string::operator=(this, __str);
    std::string::value_type v8 = __str[1].__r_.__value_.__s.__data_[4];
    LODWORD(this[1].__r_.__value_.__l.__data_) = __str[1].__r_.__value_.__l.__data_;
    this[1].__r_.__value_.__s.__data_[4] = v8;
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(&v11, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
      int v5 = *(_DWORD *)(v4 + 344);
    }
    else
    {
      std::string v11 = *__str;
    }
    std::string::pointer data = __str[1].__r_.__value_.__l.__data_;
    long long v12 = data;
    if (v5 != -1)
    {
      ((void (*)(char *, uint64_t))off_101A410E8[v5])(&v13, v4);
      std::string::pointer data = v12;
    }
    double result = *(double *)&v11.__r_.__value_.__l.__data_;
    std::string::size_type v10 = v11.__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v4 = *(_OWORD *)&v11.__r_.__value_.__l.__data_;
    *(void *)(v4 + 16) = v10;
    *(void *)(v4 + 24) = data;
    *(_DWORD *)(v4 + 344) = 1;
  }
  return result;
}

void sub_100B937DC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 344) == 2)
  {
    long long v6 = *(_OWORD *)a3;
    *(void *)(a2 + 16) = *(void *)(a3 + 16);
    *(_OWORD *)a2 = v6;
    sub_100179AF8((std::string *)(a2 + 24), (const std::string *)(a3 + 24));
    std::string::operator=((std::string *)(a2 + 56), (const std::string *)(a3 + 56));
    std::string::operator=((std::string *)(a2 + 80), (const std::string *)(a3 + 80));
    std::string::operator=((std::string *)(a2 + 104), (const std::string *)(a3 + 104));
    uint64_t v7 = *(void *)(a3 + 128);
    *(unsigned char *)(a2 + 136) = *(unsigned char *)(a3 + 136);
    *(void *)(a2 + 128) = v7;
    std::string::value_type v8 = (long long *)(a2 + 144);
    uint64_t v9 = (long long *)(a3 + 144);
    if (*(unsigned __int8 *)(a2 + 288) == *(unsigned __int8 *)(a3 + 288))
    {
      if (*(unsigned char *)(a2 + 288))
      {
        long long v10 = *v9;
        *(void *)(a2 + 160) = *(void *)(a3 + 160);
        *std::string::value_type v8 = v10;
        sub_100179AF8((std::string *)(a2 + 168), (const std::string *)(a3 + 168));
        std::string::operator=((std::string *)(a2 + 200), (const std::string *)(a3 + 200));
        std::string::operator=((std::string *)(a2 + 224), (const std::string *)(a3 + 224));
        std::string::operator=((std::string *)(a2 + 248), (const std::string *)(a3 + 248));
        char v11 = *(unsigned char *)(a3 + 280);
        *(void *)(a2 + 272) = *(void *)(a3 + 272);
        *(unsigned char *)(a2 + 280) = v11;
      }
    }
    else if (*(unsigned char *)(a2 + 288))
    {
      if (*(char *)(a2 + 271) < 0) {
        operator delete(*(void **)(a2 + 248));
      }
      if (*(char *)(a2 + 247) < 0) {
        operator delete(*(void **)(a2 + 224));
      }
      if (*(char *)(a2 + 223) < 0) {
        operator delete(*(void **)(a2 + 200));
      }
      if (*(unsigned char *)(a2 + 192) && *(char *)(a2 + 191) < 0) {
        operator delete(*(void **)(a2 + 168));
      }
      *(unsigned char *)(a2 + 288) = 0;
    }
    else
    {
      sub_100B920FC((uint64_t)v8, v9);
      *(unsigned char *)(a2 + 288) = 1;
    }
  }
  else
  {
    sub_100B920FC((uint64_t)&v23, (long long *)a3);
    sub_100B9223C(&v35, a3 + 144);
    uint64_t v12 = *(unsigned int *)(v4 + 344);
    if (v12 != -1) {
      ((void (*)(char *, uint64_t))off_101A410E8[v12])(&v48, v4);
    }
    *(_DWORD *)(v4 + 344) = -1;
    uint64_t v13 = v24;
    *(_OWORD *)uint64_t v4 = v23;
    *(void *)(v4 + 16) = v13;
    *(unsigned char *)(v4 + 24) = 0;
    *(unsigned char *)(v4 + 48) = 0;
    if (v27)
    {
      long long v14 = *(_OWORD *)v25;
      *(void *)(v4 + 40) = v26;
      *(_OWORD *)(v4 + 24) = v14;
      v25[1] = 0;
      uint64_t v26 = 0;
      v25[0] = 0;
      *(unsigned char *)(v4 + 48) = 1;
    }
    long long v15 = *(_OWORD *)v28;
    *(void *)(v4 + 72) = v29;
    *(_OWORD *)(v4 + 56) = v15;
    v28[0] = 0;
    v28[1] = 0;
    uint64_t v16 = v31;
    *(_OWORD *)(v4 + 80) = *(_OWORD *)v30;
    *(void *)(v4 + 96) = v16;
    uint64_t v29 = 0;
    v30[0] = 0;
    v30[1] = 0;
    uint64_t v31 = 0;
    long long v17 = *(_OWORD *)__p;
    *(void *)(v4 + 120) = v33;
    *(_OWORD *)(v4 + 104) = v17;
    __p[1] = 0;
    uint64_t v33 = 0;
    __p[0] = 0;
    *(_OWORD *)(v4 + 128) = v34;
    *(unsigned char *)(v4 + 144) = 0;
    *(unsigned char *)(v4 + 288) = 0;
    if (v47)
    {
      long long v18 = v35;
      *(void *)(v4 + 160) = v36;
      *(_OWORD *)(v4 + 144) = v18;
      *(unsigned char *)(v4 + 168) = 0;
      *(unsigned char *)(v4 + 192) = 0;
      if (v39)
      {
        long long v19 = v37;
        *(void *)(v4 + 184) = v38;
        *(_OWORD *)(v4 + 168) = v19;
        uint64_t v38 = 0;
        long long v37 = 0uLL;
        *(unsigned char *)(v4 + 192) = 1;
      }
      long long v20 = v40;
      *(void *)(v4 + 216) = v41;
      *(_OWORD *)(v4 + 200) = v20;
      long long v40 = 0uLL;
      uint64_t v21 = v43;
      *(_OWORD *)(v4 + 224) = v42;
      *(void *)(v4 + 240) = v21;
      uint64_t v41 = 0;
      long long v42 = 0uLL;
      uint64_t v43 = 0;
      long long v22 = v44;
      *(void *)(v4 + 264) = v45;
      *(_OWORD *)(v4 + 248) = v22;
      uint64_t v45 = 0;
      long long v44 = 0uLL;
      *(_OWORD *)(v4 + 272) = v46;
      *(unsigned char *)(v4 + 288) = 1;
    }
    *(_DWORD *)(v4 + 344) = 2;
    sub_100B9164C((uint64_t)&v35);
    if (SHIBYTE(v33) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v31) < 0) {
      operator delete(v30[0]);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete(v28[0]);
    }
    if (v27 && SHIBYTE(v26) < 0) {
      operator delete(v25[0]);
    }
  }
}

void sub_100B93B30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  if (a18)
  {
    if (a17 < 0) {
      operator delete(a12);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B93B84(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)result;
  if (*(_DWORD *)(*(void *)result + 344) != 3)
  {
    double result = (uint64_t)sub_100B92294(v11, a3);
    uint64_t v7 = *(unsigned int *)(v3 + 344);
    if (v7 != -1) {
      double result = ((uint64_t (*)(char *, uint64_t))off_101A410E8[v7])(&v10, v3);
    }
    *(_DWORD *)(v3 + 344) = -1;
    *(unsigned char *)uint64_t v3 = 0;
    *(unsigned char *)(v3 + 336) = 0;
    if (!v13)
    {
      *(_DWORD *)(v3 + 344) = 3;
      return result;
    }
    *(_DWORD *)(v3 + 328) = -1;
    int v8 = v12;
    if (v12 == -1)
    {
      *(unsigned char *)(v3 + 336) = 1;
      *(_DWORD *)(v3 + 344) = 3;
    }
    else
    {
      double result = ((uint64_t (*)(char *, uint64_t, void *))off_101A413A8[v12])(&v10, v3, v11);
      *(_DWORD *)(v3 + 328) = v8;
      int v9 = v13;
      *(unsigned char *)(v3 + 336) = 1;
      *(_DWORD *)(v3 + 344) = 3;
      if (!v9) {
        return result;
      }
    }
    return sub_100B916C0((uint64_t)v11);
  }
  if (*(unsigned __int8 *)(a2 + 336) == *(unsigned __int8 *)(a3 + 336))
  {
    if (!*(unsigned char *)(a2 + 336)) {
      return result;
    }
    uint64_t v5 = *(unsigned int *)(a2 + 328);
    uint64_t v6 = *(unsigned int *)(a3 + 328);
    if (v5 == -1)
    {
      if (v6 == -1) {
        return result;
      }
    }
    else if (v6 == -1)
    {
      double result = ((uint64_t (*)(void *, uint64_t))off_101A41120[v5])(v11, a2);
      *(_DWORD *)(a2 + 328) = -1;
      return result;
    }
    v11[0] = a2;
    return ((uint64_t (*)(void *, uint64_t))off_101A412B0[v6])(v11, a2);
  }
  else if (*(unsigned char *)(a2 + 336))
  {
    double result = sub_100B916C0(a2);
    *(unsigned char *)(a2 + 336) = 0;
  }
  else
  {
    double result = sub_100B922F4(a2, a3);
    *(unsigned char *)(a2 + 336) = 1;
  }
  return result;
}

void sub_100B93D4C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

double sub_100B93D68(uint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 344) == 4)
  {
    *(_DWORD *)a2 = *a3;
    std::string::operator=((std::string *)(a2 + 8), (const std::string *)(a3 + 2));
    std::string::operator=((std::string *)(a2 + 32), (const std::string *)(a3 + 8));
    *(void *)(a2 + 56) = *((void *)a3 + 7);
  }
  else
  {
    int v11 = *a3;
    if (*((char *)a3 + 31) < 0)
    {
      sub_10004FC84(&v12, *((void **)a3 + 1), *((void *)a3 + 2));
    }
    else
    {
      long long v12 = *(_OWORD *)(a3 + 2);
      uint64_t v13 = *((void *)a3 + 3);
    }
    if (*((char *)a3 + 55) < 0)
    {
      sub_10004FC84(&v14, *((void **)a3 + 4), *((void *)a3 + 5));
    }
    else
    {
      long long v14 = *((_OWORD *)a3 + 2);
      uint64_t v15 = *((void *)a3 + 6);
    }
    uint64_t v7 = *((void *)a3 + 7);
    uint64_t v16 = v7;
    uint64_t v8 = *(unsigned int *)(v4 + 344);
    if (v8 != -1)
    {
      ((void (*)(char *, uint64_t))off_101A410E8[v8])(&v17, v4);
      uint64_t v7 = v16;
    }
    *(_DWORD *)uint64_t v4 = v11;
    long long v9 = v12;
    *(void *)(v4 + 24) = v13;
    *(_OWORD *)(v4 + 8) = v9;
    double result = *(double *)&v14;
    uint64_t v10 = v15;
    *(_OWORD *)(v4 + 32) = v14;
    *(void *)(v4 + 48) = v10;
    *(void *)(v4 + 56) = v7;
    *(_DWORD *)(v4 + 344) = 4;
  }
  return result;
}

void sub_100B93EA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100B93EC8(uint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 344) == 5)
  {
    *(_DWORD *)a2 = *a3;
    std::string::operator=((std::string *)(a2 + 8), (const std::string *)(a3 + 2));
    std::string::operator=((std::string *)(a2 + 32), (const std::string *)(a3 + 8));
  }
  else
  {
    int v9 = *a3;
    if (*((char *)a3 + 31) < 0)
    {
      sub_10004FC84(&v10, *((void **)a3 + 1), *((void *)a3 + 2));
    }
    else
    {
      long long v10 = *(_OWORD *)(a3 + 2);
      uint64_t v11 = *((void *)a3 + 3);
    }
    if (*((char *)a3 + 55) < 0)
    {
      sub_10004FC84(&v12, *((void **)a3 + 4), *((void *)a3 + 5));
    }
    else
    {
      __n128 v12 = *((__n128 *)a3 + 2);
      uint64_t v13 = *((void *)a3 + 6);
    }
    uint64_t v7 = *(unsigned int *)(v4 + 344);
    if (v7 != -1) {
      ((void (*)(char *, uint64_t))off_101A410E8[v7])(&v14, v4);
    }
    *(_DWORD *)uint64_t v4 = v9;
    long long v8 = v10;
    *(void *)(v4 + 24) = v11;
    *(_OWORD *)(v4 + 8) = v8;
    __n128 result = v12;
    *(void *)(v4 + 48) = v13;
    *(__n128 *)(v4 + 32) = result;
    *(_DWORD *)(v4 + 344) = 5;
  }
  return result;
}

void sub_100B94010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100B94030(__n128 **a1, std::string *this, std::string *__str)
{
  uint64_t v3 = *a1;
  unsigned __int32 v4 = (*a1)[21].n128_u32[2];
  if (v4 == 6)
  {
    std::string::operator=(this, __str);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(&v6, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
      unsigned __int32 v4 = v3[21].n128_u32[2];
    }
    else
    {
      std::string v6 = *__str;
    }
    if (v4 != -1) {
      ((void (*)(char *, __n128 *))off_101A410E8[v4])(&v7, v3);
    }
    __n128 result = *(__n128 *)&v6.__r_.__value_.__l.__data_;
    v3[1].n128_u64[0] = v6.__r_.__value_.__r.__words[2];
    *uint64_t v3 = result;
    v3[21].n128_u32[2] = 6;
  }
  return result;
}

void sub_100B940F4(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 328))
  {
    sub_100B92448((uint64_t)v7, (_OWORD *)a3);
    uint64_t v5 = *(unsigned int *)(v4 + 328);
    if (v5 != -1) {
      ((void (*)(void ***, uint64_t))off_101A41120[v5])(&v19, v4);
    }
    sub_100B96010(v4, (uint64_t)v7);
    *(_DWORD *)(v4 + 328) = 0;
    if (v18[24])
    {
      long long v19 = (void **)v18;
      sub_100B91828(&v19);
    }
    if (v17 && v16 < 0) {
      operator delete(__p);
    }
    if (v14 && v13 < 0) {
      operator delete(v12);
    }
    sub_1004563E8((uint64_t)&v11);
    if (v10)
    {
      if (v9 < 0) {
        operator delete(v8);
      }
    }
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)a3;
    sub_100179AF8((std::string *)(a2 + 16), (const std::string *)(a3 + 16));
    sub_100B9469C((char *)(a2 + 48), (std::string *)(a3 + 48));
    sub_100179AF8((std::string *)(a2 + 232), (const std::string *)(a3 + 232));
    sub_100179AF8((std::string *)(a2 + 264), (const std::string *)(a3 + 264));
    sub_100B947C8(a2 + 296, a3 + 296);
  }
}

void sub_100B94250(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 328) == 1)
  {
    uint64_t v6 = *a3;
    *(_DWORD *)(a2 + 8) = *((_DWORD *)a3 + 2);
    *(void *)a2 = v6;
    sub_100179AF8((std::string *)(a2 + 16), (const std::string *)(a3 + 2));
    if ((uint64_t *)a2 != a3)
    {
      char v7 = (void **)(a2 + 48);
      uint64_t v8 = *(void *)(a2 + 48);
      uint64_t v10 = a3[6];
      uint64_t v9 = a3[7];
      unint64_t v11 = 0xAF8AF8AF8AF8AF8BLL * ((v9 - v10) >> 3);
      uint64_t v12 = *(void *)(a2 + 64);
      if (0xAF8AF8AF8AF8AF8BLL * ((v12 - v8) >> 3) < v11)
      {
        if (v8)
        {
          uint64_t v13 = *(void *)(a2 + 56);
          char v14 = *(void **)(a2 + 48);
          if (v13 != v8)
          {
            do
            {
              v13 -= 280;
              sub_100B91DFC(v13);
            }
            while (v13 != v8);
            char v14 = *v7;
          }
          *(void *)(a2 + 56) = v8;
          operator delete(v14);
          uint64_t v12 = 0;
          *char v7 = 0;
          *(void *)(a2 + 56) = 0;
          *(void *)(a2 + 64) = 0;
        }
        if (v11 > 0xEA0EA0EA0EA0EALL) {
          sub_10006A748();
        }
        unint64_t v15 = 0xAF8AF8AF8AF8AF8BLL * (v12 >> 3);
        uint64_t v16 = 2 * v15;
        if (2 * v15 <= v11) {
          uint64_t v16 = 0xAF8AF8AF8AF8AF8BLL * ((v9 - v10) >> 3);
        }
        if (v15 >= 0x75075075075075) {
          unint64_t v17 = 0xEA0EA0EA0EA0EALL;
        }
        else {
          unint64_t v17 = v16;
        }
        sub_100B933A8((void *)(a2 + 48), v17);
        uint64_t v18 = sub_100B93400(v10, v9, *(void *)(a2 + 56));
        goto LABEL_25;
      }
      if (0xAF8AF8AF8AF8AF8BLL * ((*(void *)(a2 + 56) - v8) >> 3) < v11)
      {
        uint64_t v21 = (std::string *)(v10 + 8 * ((*(void *)(a2 + 56) - v8) >> 3));
        sub_100B961F8((std::string *)a3[6], v21, *(char **)(a2 + 48));
        uint64_t v18 = sub_100B93400((uint64_t)v21, v9, *(void *)(a2 + 56));
LABEL_25:
        *(void *)(a2 + 56) = v18;
        return;
      }
      long long v22 = sub_100B961F8((std::string *)a3[6], (std::string *)a3[7], *(char **)(a2 + 48));
      for (uint64_t i = *(void *)(a2 + 56); (char *)i != v22; sub_100B91DFC(i))
        i -= 280;
      *(void *)(a2 + 56) = v22;
    }
  }
  else
  {
    uint64_t v24 = *a3;
    int v25 = *((_DWORD *)a3 + 2);
    sub_100B92544(&__p, (long long *)a3 + 1);
    long long v29 = 0uLL;
    uint64_t v30 = 0;
    sub_100B93324(&v29, a3[6], a3[7], 0xAF8AF8AF8AF8AF8BLL * ((a3[7] - a3[6]) >> 3));
    uint64_t v19 = *(unsigned int *)(v4 + 328);
    if (v19 != -1) {
      ((void (*)(void ***, uint64_t))off_101A41120[v19])(&v31, v4);
    }
    *(_DWORD *)(v4 + 328) = -1;
    *(void *)uint64_t v4 = v24;
    *(_DWORD *)(v4 + 8) = v25;
    *(unsigned char *)(v4 + 16) = 0;
    *(unsigned char *)(v4 + 40) = 0;
    if (v28)
    {
      long long v20 = __p;
      *(void *)(v4 + 32) = v27;
      *(_OWORD *)(v4 + 16) = v20;
      uint64_t v27 = 0;
      long long __p = 0uLL;
      *(unsigned char *)(v4 + 40) = 1;
    }
    *(_OWORD *)(v4 + 48) = v29;
    *(void *)(v4 + 64) = v30;
    long long v29 = 0uLL;
    uint64_t v30 = 0;
    *(_DWORD *)(v4 + 328) = 1;
    uint64_t v31 = (void **)&v29;
    sub_100B91D78(&v31);
    if (v28 && SHIBYTE(v27) < 0) {
      operator delete((void *)__p);
    }
  }
}

void sub_100B94554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  *(void *)(v17 + 56) = v18;
  _Unwind_Resume(exception_object);
}

void sub_100B94594(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a1;
  if (*(_DWORD *)(*a1 + 328) == 2)
  {
    if (a2 != a3)
    {
      uint64_t v5 = *a3;
      uint64_t v4 = a3[1];
      sub_100B948A8(a2, v5, v4, 0x34F72C234F72C235 * ((v4 - v5) >> 3));
    }
  }
  else
  {
    uint64_t v6 = *a3;
    uint64_t v7 = a3[1];
    long long v9 = 0uLL;
    uint64_t v10 = 0;
    sub_100B92920(&v9, v6, v7, 0x34F72C234F72C235 * ((v7 - v6) >> 3));
    uint64_t v8 = *(unsigned int *)(v3 + 328);
    if (v8 != -1) {
      ((void (*)(void ***, uint64_t))off_101A41120[v8])(&v11, v3);
    }
    *(_OWORD *)uint64_t v3 = v9;
    *(void *)(v3 + 16) = v10;
    long long v9 = 0uLL;
    uint64_t v10 = 0;
    unint64_t v11 = (void **)&v9;
    *(_DWORD *)(v3 + 328) = 2;
    sub_100B91828(&v11);
  }
}

void sub_100B9469C(char *__dst, std::string *__str)
{
  if (__dst[176] == __str[7].__r_.__value_.__s.__data_[8])
  {
    if (__dst[176])
    {
      std::string::operator=((std::string *)__dst, __str);
      std::string::operator=((std::string *)__dst + 1, __str + 1);
      *((void *)__dst + 6) = __str[2].__r_.__value_.__l.__data_;
      sub_100179AF8((std::string *)(__dst + 56), (std::string *)((char *)__str + 56));
      sub_100179AF8((std::string *)(__dst + 88), (std::string *)((char *)__str + 88));
      long long v4 = *(_OWORD *)&__str[5].__r_.__value_.__l.__data_;
      *((_DWORD *)__dst + 34) = __str[5].__r_.__value_.__r.__words[2];
      *(_OWORD *)(__dst + 120) = v4;
      sub_100179AF8((std::string *)__dst + 6, __str + 6);
    }
  }
  else if (__dst[176])
  {
    if (__dst[168] && __dst[167] < 0) {
      operator delete(*((void **)__dst + 18));
    }
    if (__dst[112] && __dst[111] < 0) {
      operator delete(*((void **)__dst + 11));
    }
    if (__dst[80] && __dst[79] < 0) {
      operator delete(*((void **)__dst + 7));
    }
    if (__dst[47] < 0) {
      operator delete(*((void **)__dst + 3));
    }
    if (__dst[23] < 0) {
      operator delete(*(void **)__dst);
    }
    __dst[176] = 0;
  }
  else
  {
    sub_100B92628(__dst, (long long *)__str);
    __dst[176] = 1;
  }
}

void sub_100B947C8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 24))
    {
      uint64_t v3 = *(void *)(a2 + 8);
      unint64_t v4 = 0x34F72C234F72C235 * ((v3 - *(void *)a2) >> 3);
      uint64_t v5 = *(void *)a2;
      sub_100B948A8((void *)a1, v5, v3, v4);
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v6 = (void **)a1;
    sub_100B91828(&v6);
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_100B92920((void *)a1, *(void *)a2, *(void *)(a2 + 8), 0x34F72C234F72C235 * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
    *(unsigned char *)(a1 + 24) = 1;
  }
}

uint64_t sub_100B948A8(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1[2];
  long long v9 = (_DWORD *)*a1;
  if (0x34F72C234F72C235 * ((v8 - *a1) >> 3) < a4)
  {
    if (v9)
    {
      uint64_t v10 = (_DWORD *)a1[1];
      unint64_t v11 = (_DWORD *)*a1;
      if (v10 != v9)
      {
        do
        {
          uint64_t v12 = v10 - 58;
          sub_100B918B0((uint64_t)(v10 - 56));
          uint64_t v10 = v12;
        }
        while (v12 != v9);
        unint64_t v11 = (_DWORD *)*a1;
      }
      a1[1] = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x11A7B9611A7B961) {
      sub_10006A748();
    }
    unint64_t v13 = 0x34F72C234F72C235 * (v8 >> 3);
    uint64_t v14 = 2 * v13;
    if (2 * v13 <= a4) {
      uint64_t v14 = a4;
    }
    if (v13 >= 0x8D3DCB08D3DCB0) {
      unint64_t v15 = 0x11A7B9611A7B961;
    }
    else {
      unint64_t v15 = v14;
    }
    sub_100B929A4(a1, v15);
    uint64_t result = sub_100B929FC(a2, a3, a1[1]);
    goto LABEL_16;
  }
  if (0x34F72C234F72C235 * ((uint64_t)(a1[1] - (void)v9) >> 3) < a4)
  {
    uint64_t v17 = a2 + 8 * ((uint64_t)(a1[1] - (void)v9) >> 3);
    sub_100B94A64(a2, v17, v9);
    uint64_t result = sub_100B929FC(v17, a3, a1[1]);
LABEL_16:
    a1[1] = result;
    return result;
  }
  uint64_t result = (uint64_t)sub_100B94A64(a2, a3, v9);
  uint64_t v18 = result;
  uint64_t v19 = a1[1];
  if (v19 != result)
  {
    do
    {
      uint64_t v20 = v19 - 232;
      uint64_t result = sub_100B918B0(v19 - 224);
      uint64_t v19 = v20;
    }
    while (v20 != v18);
  }
  a1[1] = v18;
  return result;
}

void sub_100B94A54(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100B94A5C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

_DWORD *sub_100B94A64(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1 + 8;
    do
    {
      uint64_t v6 = v5 - 8;
      *a3 = *(_DWORD *)(v5 - 8);
      uint64_t v7 = a3[56];
      uint64_t v8 = *(unsigned int *)(v5 + 216);
      if (v7 == -1)
      {
        if (v8 != -1)
        {
LABEL_7:
          uint64_t v10 = a3 + 2;
          ((void (*)(_DWORD **))*(&off_101A412C8 + v8))(&v10);
        }
      }
      else
      {
        if (v8 != -1) {
          goto LABEL_7;
        }
        ((void (*)(char *, _DWORD *))off_101A41138[v7])(&v11, a3 + 2);
        a3[56] = -1;
      }
      a3 += 58;
      v5 += 232;
    }
    while (v6 + 232 != a2);
  }
  return a3;
}

void sub_100B94B3C(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 216))
  {
    LODWORD(v13) = *(_DWORD *)a3;
    if (*(char *)(a3 + 31) < 0)
    {
      sub_10004FC84(&v14, *(void **)(a3 + 8), *(void *)(a3 + 16));
    }
    else
    {
      long long v14 = *(_OWORD *)(a3 + 8);
      uint64_t v15 = *(void *)(a3 + 24);
    }
    sub_100B92C18(&__p, (long long *)(a3 + 32));
    sub_100B92CA4((uint64_t)v19, a3 + 72);
    uint64_t v8 = *(unsigned int *)(v4 + 216);
    if (v8 != -1) {
      ((void (*)(char *, uint64_t))off_101A41138[v8])(&v12, v4);
    }
    *(_DWORD *)(v4 + 216) = -1;
    *(_DWORD *)uint64_t v4 = v13;
    long long v9 = v14;
    *(void *)(v4 + 24) = v15;
    *(_OWORD *)(v4 + 8) = v9;
    uint64_t v15 = 0;
    long long v14 = 0uLL;
    *(unsigned char *)(v4 + 32) = 0;
    *(unsigned char *)(v4 + 56) = 0;
    if (v18)
    {
      long long v10 = __p;
      *(void *)(v4 + 48) = v17;
      *(_OWORD *)(v4 + 32) = v10;
      uint64_t v17 = 0;
      long long __p = 0uLL;
      *(unsigned char *)(v4 + 56) = 1;
    }
    *(unsigned char *)(v4 + 72) = 0;
    *(_DWORD *)(v4 + 208) = -1;
    int v11 = v20;
    if (v20 != -1)
    {
      ((void (*)(char *))off_101A41340[v20])(&v12);
      *(_DWORD *)(v4 + 208) = v11;
    }
    *(_DWORD *)(v4 + 216) = 0;
    sub_100B919D4((uint64_t)v19);
    if (v18 && SHIBYTE(v17) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v15) < 0) {
      operator delete((void *)v14);
    }
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)a3;
    std::string::operator=((std::string *)(a2 + 8), (const std::string *)(a3 + 8));
    sub_100179AF8((std::string *)(a2 + 32), (const std::string *)(a3 + 32));
    uint64_t v6 = *(unsigned int *)(a2 + 208);
    uint64_t v7 = *(unsigned int *)(a3 + 208);
    if (v6 == -1)
    {
      if (v7 == -1) {
        return;
      }
    }
    else if (v7 == -1)
    {
      ((void (*)(uint64_t *, uint64_t))off_101A41148[v6])(&v13, a2 + 72);
      *(_DWORD *)(a2 + 208) = -1;
      return;
    }
    uint64_t v13 = a2 + 72;
    ((void (*)(uint64_t *))*(&off_101A412D8 + v7))(&v13);
  }
}

void sub_100B94D84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B94DE0(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 216) == 1)
  {
    std::string::operator=(this, __str);
    sub_100179AF8(this + 1, __str + 1);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v9, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }
    else {
      std::string v9 = *__str;
    }
    sub_100B92C18(&v10, (long long *)&__str[1]);
    uint64_t v6 = *(unsigned int *)(v4 + 216);
    if (v6 != -1) {
      ((void (*)(char *, uint64_t))off_101A41138[v6])(&v13, v4);
    }
    *(_DWORD *)(v4 + 216) = -1;
    std::string::size_type v7 = v9.__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v4 = *(_OWORD *)&v9.__r_.__value_.__l.__data_;
    *(void *)(v4 + 16) = v7;
    *(unsigned char *)(v4 + 24) = 0;
    *(unsigned char *)(v4 + 48) = 0;
    if (v12)
    {
      long long v8 = v10;
      *(void *)(v4 + 40) = v11;
      *(_OWORD *)(v4 + 24) = v8;
      *(unsigned char *)(v4 + 48) = 1;
    }
    *(_DWORD *)(v4 + 216) = 1;
  }
}

void sub_100B94F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100B94F28(uint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 136))
  {
    int v9 = *a3;
    if (*((char *)a3 + 31) < 0)
    {
      sub_10004FC84(&v10, *((void **)a3 + 1), *((void *)a3 + 2));
    }
    else
    {
      long long v10 = *(_OWORD *)(a3 + 2);
      uint64_t v11 = *((void *)a3 + 3);
    }
    if (*((char *)a3 + 55) < 0)
    {
      sub_10004FC84(&v12, *((void **)a3 + 4), *((void *)a3 + 5));
    }
    else
    {
      __n128 v12 = *((__n128 *)a3 + 2);
      uint64_t v13 = *((void *)a3 + 6);
    }
    uint64_t v7 = *(unsigned int *)(v4 + 136);
    if (v7 != -1) {
      ((void (*)(char *, uint64_t))off_101A41148[v7])(&v14, v4);
    }
    *(_DWORD *)uint64_t v4 = v9;
    long long v8 = v10;
    *(void *)(v4 + 24) = v11;
    *(_OWORD *)(v4 + 8) = v8;
    __n128 result = v12;
    *(void *)(v4 + 48) = v13;
    *(__n128 *)(v4 + 32) = result;
    *(_DWORD *)(v4 + 136) = 0;
  }
  else
  {
    *(_DWORD *)a2 = *a3;
    std::string::operator=((std::string *)(a2 + 8), (const std::string *)(a3 + 2));
    std::string::operator=((std::string *)(a2 + 32), (const std::string *)(a3 + 8));
  }
  return result;
}

void sub_100B95068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100B95088(__n128 **a1, std::string *this, std::string *__str)
{
  uint64_t v3 = *a1;
  unsigned __int32 v4 = (*a1)[8].n128_u32[2];
  if (v4 == 1)
  {
    std::string::operator=(this, __str);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(&v6, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
      unsigned __int32 v4 = v3[8].n128_u32[2];
    }
    else
    {
      std::string v6 = *__str;
    }
    if (v4 != -1) {
      ((void (*)(char *, __n128 *))off_101A41148[v4])(&v7, v3);
    }
    __n128 result = *(__n128 *)&v6.__r_.__value_.__l.__data_;
    v3[1].n128_u64[0] = v6.__r_.__value_.__r.__words[2];
    *uint64_t v3 = result;
    v3[8].n128_u32[2] = 1;
  }
  return result;
}

__n128 sub_100B9514C(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 136) == 2)
  {
    std::string::operator=(this, __str);
    std::string::operator=(this + 1, __str + 1);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v9, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }
    else {
      std::string v9 = *__str;
    }
    if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(&v10, __str[1].__r_.__value_.__l.__data_, __str[1].__r_.__value_.__l.__size_);
    }
    else
    {
      __n128 v10 = *(__n128 *)&__str[1].__r_.__value_.__l.__data_;
      std::string::size_type v11 = __str[1].__r_.__value_.__r.__words[2];
    }
    uint64_t v7 = *(unsigned int *)(v4 + 136);
    if (v7 != -1) {
      ((void (*)(char *, uint64_t))off_101A41148[v7])(&v12, v4);
    }
    long long v8 = *(_OWORD *)&v9.__r_.__value_.__l.__data_;
    *(void *)(v4 + 16) = *((void *)&v9.__r_.__value_.__l + 2);
    *(_OWORD *)uint64_t v4 = v8;
    __n128 result = v10;
    *(void *)(v4 + 40) = v11;
    *(__n128 *)(v4 + 24) = result;
    *(_DWORD *)(v4 + 136) = 2;
  }
  return result;
}

void sub_100B95270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100B95290(__n128 **a1, std::string *this, std::string *__str)
{
  uint64_t v3 = *a1;
  unsigned __int32 v4 = (*a1)[8].n128_u32[2];
  if (v4 == 3)
  {
    std::string::operator=(this, __str);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(&v6, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
      unsigned __int32 v4 = v3[8].n128_u32[2];
    }
    else
    {
      std::string v6 = *__str;
    }
    if (v4 != -1) {
      ((void (*)(char *, __n128 *))off_101A41148[v4])(&v7, v3);
    }
    __n128 result = *(__n128 *)&v6.__r_.__value_.__l.__data_;
    v3[1].n128_u64[0] = v6.__r_.__value_.__r.__words[2];
    *uint64_t v3 = result;
    v3[8].n128_u32[2] = 3;
  }
  return result;
}

__n128 sub_100B95354(__n128 **a1, std::string *this, std::string *__str)
{
  uint64_t v3 = *a1;
  unsigned __int32 v4 = (*a1)[8].n128_u32[2];
  if (v4 == 4)
  {
    std::string::operator=(this, __str);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(&v6, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
      unsigned __int32 v4 = v3[8].n128_u32[2];
    }
    else
    {
      std::string v6 = *__str;
    }
    if (v4 != -1) {
      ((void (*)(char *, __n128 *))off_101A41148[v4])(&v7, v3);
    }
    __n128 result = *(__n128 *)&v6.__r_.__value_.__l.__data_;
    v3[1].n128_u64[0] = v6.__r_.__value_.__r.__words[2];
    *uint64_t v3 = result;
    v3[8].n128_u32[2] = 4;
  }
  return result;
}

void sub_100B95418(__n128 **a1, uint64_t a2, long long *a3)
{
  unsigned __int32 v4 = *a1;
  if ((*a1)[8].n128_u32[2] == 5)
  {
    long long v6 = *a3;
    *(unsigned char *)(a2 + 16) = *((unsigned char *)a3 + 16);
    *(_OWORD *)a2 = v6;
    char v7 = (std::string *)(a2 + 24);
    long long v8 = (const std::string *)((char *)a3 + 24);
    if (*(unsigned __int8 *)(a2 + 48) == *((unsigned __int8 *)a3 + 48))
    {
      if (*(unsigned char *)(a2 + 48)) {
        std::string::operator=(v7, v8);
      }
    }
    else if (*(unsigned char *)(a2 + 48))
    {
      if (*(char *)(a2 + 47) < 0) {
        operator delete(v7->__r_.__value_.__l.__data_);
      }
      *(unsigned char *)(a2 + 48) = 0;
    }
    else
    {
      if (*((char *)a3 + 47) < 0)
      {
        sub_10004FC84(v7, *((void **)a3 + 3), *((void *)a3 + 4));
      }
      else
      {
        long long v10 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
        v7->__r_.__value_.__r.__words[2] = *((void *)a3 + 5);
        *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v10;
      }
      *(unsigned char *)(a2 + 48) = 1;
    }
    sub_100179AF8((std::string *)(a2 + 56), (const std::string *)((char *)a3 + 56));
    sub_100179AF8((std::string *)(a2 + 88), (const std::string *)((char *)a3 + 88));
  }
  else
  {
    long long v11 = *a3;
    uint64_t v12 = *((void *)a3 + 2);
    sub_100B93150(&v13, (long long *)((char *)a3 + 24));
    sub_1000593FC((uint64_t)&v16, (long long *)((char *)a3 + 56));
    sub_1000593FC((uint64_t)&__p, (long long *)((char *)a3 + 88));
    uint64_t v9 = v4[8].n128_u32[2];
    if (v9 != -1) {
      ((void (*)(char *, __n128 *))off_101A41148[v9])(&v22, v4);
    }
    sub_100B95D3C(v4, (uint64_t)&v11);
    v4[8].n128_u32[2] = 5;
    if (v21 && v20 < 0) {
      operator delete(__p);
    }
    if (v18 && v17 < 0) {
      operator delete(v16);
    }
    if (v15 && v14 < 0) {
      operator delete(v13);
    }
  }
}

void sub_100B955CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25)
{
  if (a25 && a24 < 0) {
    operator delete(__p);
  }
  if (a18)
  {
    if (a17 < 0) {
      operator delete(a12);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B95610(uint64_t result, unsigned char *a2, unsigned char *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 136);
  if (v5 != -1)
  {
    if (v5 == 6)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, uint64_t))off_101A41148[v5])(&v6, v4);
  }
  *(unsigned char *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 136) = 6;
  return result;
}

void sub_100B95688(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 136) == 7)
  {
    std::string::operator=(this, __str);
    std::string::operator=(this + 1, __str + 1);
    std::string::operator=(this + 2, __str + 2);
    sub_100179AF8(this + 3, __str + 3);
    sub_100179AF8((std::string *)((char *)this + 104), (std::string *)((char *)__str + 104));
  }
  else
  {
    sub_100B931DC((char *)v7, (long long *)__str);
    uint64_t v6 = *(unsigned int *)(v4 + 136);
    if (v6 != -1) {
      ((void (*)(char *, uint64_t))off_101A41148[v6])(&v19, v4);
    }
    sub_1001FBE80(v4, (long long *)v7);
    *(_DWORD *)(v4 + 136) = 7;
    if (v18 && v17 < 0) {
      operator delete(__p);
    }
    if (v15 && v14 < 0) {
      operator delete(v13);
    }
    if (v12 < 0) {
      operator delete(v11);
    }
    if (v10 < 0) {
      operator delete(v9);
    }
    if (v8 < 0) {
      operator delete(v7[0]);
    }
  }
}

void sub_100B957D0(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 136) == 8)
  {
    std::string::operator=(this, __str);
    sub_100179AF8(this + 1, __str + 1);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v9, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }
    else {
      std::string v9 = *__str;
    }
    sub_1000593FC((uint64_t)&v10, (long long *)&__str[1]);
    uint64_t v6 = *(unsigned int *)(v4 + 136);
    if (v6 != -1) {
      ((void (*)(char *, uint64_t))off_101A41148[v6])(&v13, v4);
    }
    *(_DWORD *)(v4 + 136) = -1;
    std::string::size_type v7 = v9.__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v4 = *(_OWORD *)&v9.__r_.__value_.__l.__data_;
    *(void *)(v4 + 16) = v7;
    *(unsigned char *)(v4 + 24) = 0;
    *(unsigned char *)(v4 + 48) = 0;
    if (v12)
    {
      long long v8 = v10;
      *(void *)(v4 + 40) = v11;
      *(_OWORD *)(v4 + 24) = v8;
      *(unsigned char *)(v4 + 48) = 1;
    }
    *(_DWORD *)(v4 + 136) = 8;
  }
}

void sub_100B958FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B95918(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 136) == 9)
  {
    std::string::operator=(this, __str);
    sub_100179AF8(this + 1, __str + 1);
    sub_100179AF8((std::string *)((char *)this + 56), (std::string *)((char *)__str + 56));
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v11, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }
    else {
      std::string v11 = *__str;
    }
    sub_1000593FC((uint64_t)&__p, (long long *)&__str[1]);
    sub_1000593FC((uint64_t)&v15, (long long *)&__str[2].__r_.__value_.__r.__words[1]);
    uint64_t v6 = *(unsigned int *)(v4 + 136);
    if (v6 != -1) {
      ((void (*)(char *, uint64_t))off_101A41148[v6])(&v18, v4);
    }
    *(_DWORD *)(v4 + 136) = -1;
    long long v7 = *(_OWORD *)&v11.__r_.__value_.__l.__data_;
    *(void *)(v4 + 16) = *((void *)&v11.__r_.__value_.__l + 2);
    *(_OWORD *)uint64_t v4 = v7;
    memset(&v11, 0, sizeof(v11));
    *(unsigned char *)(v4 + 24) = 0;
    *(unsigned char *)(v4 + 48) = 0;
    int v8 = v14;
    if (v14)
    {
      long long v9 = __p;
      *(void *)(v4 + 40) = v13;
      *(_OWORD *)(v4 + 24) = v9;
      uint64_t v13 = 0;
      long long __p = 0uLL;
      *(unsigned char *)(v4 + 48) = 1;
    }
    *(unsigned char *)(v4 + 56) = 0;
    *(unsigned char *)(v4 + 80) = 0;
    if (v17)
    {
      long long v10 = v15;
      *(void *)(v4 + 72) = v16;
      *(_OWORD *)(v4 + 56) = v10;
      uint64_t v16 = 0;
      long long v15 = 0uLL;
      *(unsigned char *)(v4 + 80) = 1;
    }
    *(_DWORD *)(v4 + 136) = 9;
    if (v8)
    {
      if (SHIBYTE(v13) < 0)
      {
        operator delete((void *)__p);
        if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v11.__r_.__value_.__l.__data_);
        }
      }
    }
  }
}

void sub_100B95AC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a21 && a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B95B04(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v4 = *a1;
  if (*(_DWORD *)(*a1 + 136) == 10)
  {
    std::string::operator=(this, __str);
    sub_100179AF8(this + 1, __str + 1);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v9, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }
    else {
      std::string v9 = *__str;
    }
    sub_1000593FC((uint64_t)&v10, (long long *)&__str[1]);
    uint64_t v6 = *(unsigned int *)(v4 + 136);
    if (v6 != -1) {
      ((void (*)(char *, uint64_t))off_101A41148[v6])(&v13, v4);
    }
    *(_DWORD *)(v4 + 136) = -1;
    std::string::size_type v7 = v9.__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v4 = *(_OWORD *)&v9.__r_.__value_.__l.__data_;
    *(void *)(v4 + 16) = v7;
    *(unsigned char *)(v4 + 24) = 0;
    *(unsigned char *)(v4 + 48) = 0;
    if (v12)
    {
      long long v8 = v10;
      *(void *)(v4 + 40) = v11;
      *(_OWORD *)(v4 + 24) = v8;
      *(unsigned char *)(v4 + 48) = 1;
    }
    *(_DWORD *)(v4 + 136) = 10;
  }
}

void sub_100B95C30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B95C4C(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 136);
  if (v5 != -1)
  {
    if (v5 == 11)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))off_101A41148[v5])(&v6, v4);
  }
  _DWORD *v4 = *a3;
  v4[34] = 11;
  return result;
}

uint64_t sub_100B95CC4(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v4 = *(_DWORD **)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 136);
  if (v5 != -1)
  {
    if (v5 == 12)
    {
      *a2 = *a3;
      return result;
    }
    __n128 result = ((uint64_t (*)(char *, _DWORD *))off_101A41148[v5])(&v6, v4);
  }
  _DWORD *v4 = *a3;
  v4[34] = 12;
  return result;
}

__n128 sub_100B95D3C(__n128 *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  a1[1].n128_u64[0] = *(void *)(a2 + 16);
  *a1 = result;
  a1[1].n128_u8[8] = 0;
  a1[3].n128_u8[0] = 0;
  if (*(unsigned char *)(a2 + 48))
  {
    __n128 result = *(__n128 *)(a2 + 24);
    a1[2].n128_u64[1] = *(void *)(a2 + 40);
    *(__n128 *)((char *)a1 + 24) = result;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 24) = 0;
    a1[3].n128_u8[0] = 1;
  }
  a1[3].n128_u8[8] = 0;
  a1[5].n128_u8[0] = 0;
  if (*(unsigned char *)(a2 + 80))
  {
    __n128 result = *(__n128 *)(a2 + 56);
    a1[4].n128_u64[1] = *(void *)(a2 + 72);
    *(__n128 *)((char *)a1 + 56) = result;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 56) = 0;
    a1[5].n128_u8[0] = 1;
  }
  a1[5].n128_u8[8] = 0;
  a1[7].n128_u8[0] = 0;
  if (*(unsigned char *)(a2 + 112))
  {
    __n128 result = *(__n128 *)(a2 + 88);
    a1[6].n128_u64[1] = *(void *)(a2 + 104);
    *(__n128 *)((char *)a1 + 88) = result;
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 88) = 0;
    a1[7].n128_u8[0] = 1;
  }
  return result;
}

__n128 sub_100B95DEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a2 = *(_DWORD *)a3;
  long long v3 = *(_OWORD *)(a3 + 8);
  *(void *)(a2 + 24) = *(void *)(a3 + 24);
  *(_OWORD *)(a2 + 8) = v3;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + 8) = 0;
  __n128 result = *(__n128 *)(a3 + 32);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  *(__n128 *)(a2 + 32) = result;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 32) = 0;
  return result;
}

__n128 sub_100B95E28(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  a3->n128_u64[0] = 0;
  return result;
}

__n128 sub_100B95E44(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v3 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v3;
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  *(void *)a3 = 0;
  __n128 result = *(__n128 *)((char *)a3 + 24);
  *(void *)(a2 + 40) = *((void *)a3 + 5);
  *(__n128 *)(a2 + 24) = result;
  *((void *)a3 + 4) = 0;
  *((void *)a3 + 5) = 0;
  *((void *)a3 + 3) = 0;
  return result;
}

__n128 sub_100B95E78(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  a3->n128_u64[0] = 0;
  return result;
}

__n128 sub_100B95E94(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  a3->n128_u64[0] = 0;
  return result;
}

double sub_100B95EB0(uint64_t a1, __n128 *a2, uint64_t a3)
{
  *(void *)&double result = sub_100B95D3C(a2, a3).n128_u64[0];
  return result;
}

void sub_100B95EBC(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *a2 = *a3;
}

double sub_100B95EC8(uint64_t a1, uint64_t a2, long long *a3)
{
  *(void *)&double result = sub_1001FBE80(a2, a3).n128_u64[0];
  return result;
}

__n128 sub_100B95ED4(uint64_t a1, __n128 *a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  a2[1].n128_u64[0] = *(void *)(a3 + 16);
  *a2 = result;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  a2[1].n128_u8[8] = 0;
  a2[3].n128_u8[0] = 0;
  if (*(unsigned char *)(a3 + 48))
  {
    __n128 result = *(__n128 *)(a3 + 24);
    a2[2].n128_u64[1] = *(void *)(a3 + 40);
    *(__n128 *)((char *)a2 + 24) = result;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 24) = 0;
    a2[3].n128_u8[0] = 1;
  }
  return result;
}

__n128 sub_100B95F24(uint64_t a1, __n128 *a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  a2[1].n128_u64[0] = *(void *)(a3 + 16);
  *a2 = result;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  a2[1].n128_u8[8] = 0;
  a2[3].n128_u8[0] = 0;
  if (*(unsigned char *)(a3 + 48))
  {
    __n128 result = *(__n128 *)(a3 + 24);
    a2[2].n128_u64[1] = *(void *)(a3 + 40);
    *(__n128 *)((char *)a2 + 24) = result;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 24) = 0;
    a2[3].n128_u8[0] = 1;
  }
  a2[3].n128_u8[8] = 0;
  a2[5].n128_u8[0] = 0;
  if (*(unsigned char *)(a3 + 80))
  {
    __n128 result = *(__n128 *)(a3 + 56);
    a2[4].n128_u64[1] = *(void *)(a3 + 72);
    *(__n128 *)((char *)a2 + 56) = result;
    *(void *)(a3 + 64) = 0;
    *(void *)(a3 + 72) = 0;
    *(void *)(a3 + 56) = 0;
    a2[5].n128_u8[0] = 1;
  }
  return result;
}

__n128 sub_100B95FA8(uint64_t a1, __n128 *a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  a2[1].n128_u64[0] = *(void *)(a3 + 16);
  *a2 = result;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  a2[1].n128_u8[8] = 0;
  a2[3].n128_u8[0] = 0;
  if (*(unsigned char *)(a3 + 48))
  {
    __n128 result = *(__n128 *)(a3 + 24);
    a2[2].n128_u64[1] = *(void *)(a3 + 40);
    *(__n128 *)((char *)a2 + 24) = result;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 24) = 0;
    a2[3].n128_u8[0] = 1;
  }
  return result;
}

void sub_100B95FF8(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

void sub_100B96004(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
}

uint64_t sub_100B96010(uint64_t result, uint64_t a2)
{
  *(_OWORD *)__n128 result = *(_OWORD *)a2;
  *(unsigned char *)(result + 16) = 0;
  *(unsigned char *)(result + 40) = 0;
  if (*(unsigned char *)(a2 + 40))
  {
    long long v2 = *(_OWORD *)(a2 + 16);
    *(void *)(result + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(result + 16) = v2;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(result + 40) = 1;
  }
  *(unsigned char *)(result + 48) = 0;
  *(unsigned char *)(result + 224) = 0;
  if (*(unsigned char *)(a2 + 224))
  {
    long long v3 = *(_OWORD *)(a2 + 48);
    *(void *)(result + 64) = *(void *)(a2 + 64);
    *(_OWORD *)(result + 48) = v3;
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 48) = 0;
    long long v4 = *(_OWORD *)(a2 + 72);
    *(void *)(result + 88) = *(void *)(a2 + 88);
    *(_OWORD *)(result + 72) = v4;
    *(void *)(a2 + 80) = 0;
    *(void *)(a2 + 88) = 0;
    *(void *)(a2 + 72) = 0;
    uint64_t v5 = *(void *)(a2 + 96);
    *(unsigned char *)(result + 104) = 0;
    *(void *)(result + 96) = v5;
    *(unsigned char *)(result + 128) = 0;
    if (*(unsigned char *)(a2 + 128))
    {
      long long v6 = *(_OWORD *)(a2 + 104);
      *(void *)(result + 120) = *(void *)(a2 + 120);
      *(_OWORD *)(result + 104) = v6;
      *(void *)(a2 + 112) = 0;
      *(void *)(a2 + 120) = 0;
      *(void *)(a2 + 104) = 0;
      *(unsigned char *)(result + 128) = 1;
    }
    *(unsigned char *)(result + 136) = 0;
    *(unsigned char *)(result + 160) = 0;
    if (*(unsigned char *)(a2 + 160))
    {
      long long v7 = *(_OWORD *)(a2 + 136);
      *(void *)(result + 152) = *(void *)(a2 + 152);
      *(_OWORD *)(result + 136) = v7;
      *(void *)(a2 + 144) = 0;
      *(void *)(a2 + 152) = 0;
      *(void *)(a2 + 136) = 0;
      *(unsigned char *)(result + 160) = 1;
    }
    long long v8 = *(_OWORD *)(a2 + 168);
    int v9 = *(_DWORD *)(a2 + 184);
    *(unsigned char *)(result + 192) = 0;
    *(_DWORD *)(result + 184) = v9;
    *(_OWORD *)(result + 168) = v8;
    *(unsigned char *)(result + 216) = 0;
    if (*(unsigned char *)(a2 + 216))
    {
      long long v10 = *(_OWORD *)(a2 + 192);
      *(void *)(result + 208) = *(void *)(a2 + 208);
      *(_OWORD *)(result + 192) = v10;
      *(void *)(a2 + 200) = 0;
      *(void *)(a2 + 208) = 0;
      *(void *)(a2 + 192) = 0;
      *(unsigned char *)(result + 216) = 1;
    }
    *(unsigned char *)(result + 224) = 1;
  }
  *(unsigned char *)(result + 232) = 0;
  *(unsigned char *)(result + 256) = 0;
  if (*(unsigned char *)(a2 + 256))
  {
    long long v11 = *(_OWORD *)(a2 + 232);
    *(void *)(result + 248) = *(void *)(a2 + 248);
    *(_OWORD *)(result + 232) = v11;
    *(void *)(a2 + 240) = 0;
    *(void *)(a2 + 248) = 0;
    *(void *)(a2 + 232) = 0;
    *(unsigned char *)(result + 256) = 1;
  }
  *(unsigned char *)(result + 264) = 0;
  *(unsigned char *)(result + 288) = 0;
  if (*(unsigned char *)(a2 + 288))
  {
    long long v12 = *(_OWORD *)(a2 + 264);
    *(void *)(result + 280) = *(void *)(a2 + 280);
    *(_OWORD *)(result + 264) = v12;
    *(void *)(a2 + 272) = 0;
    *(void *)(a2 + 280) = 0;
    *(void *)(a2 + 264) = 0;
    *(unsigned char *)(result + 288) = 1;
  }
  *(unsigned char *)(result + 296) = 0;
  *(unsigned char *)(result + 320) = 0;
  if (*(unsigned char *)(a2 + 320))
  {
    *(void *)(result + 296) = 0;
    *(void *)(result + 304) = 0;
    *(void *)(result + 312) = 0;
    uint64_t v13 = *(void *)(a2 + 304);
    *(void *)(result + 296) = *(void *)(a2 + 296);
    *(void *)(result + 304) = v13;
    *(void *)(result + 312) = *(void *)(a2 + 312);
    *(void *)(a2 + 296) = 0;
    *(void *)(a2 + 304) = 0;
    *(void *)(a2 + 312) = 0;
    *(unsigned char *)(result + 320) = 1;
  }
  return result;
}

char *sub_100B961F8(std::string *__str, std::string *a2, char *__dst)
{
  if (__str != a2)
  {
    uint64_t v5 = __str;
    do
    {
      sub_100B9469C(__dst, v5);
      sub_100179AF8((std::string *)(__dst + 184), (std::string *)((char *)v5 + 184));
      sub_100179AF8((std::string *)__dst + 9, v5 + 9);
      sub_100B947C8((uint64_t)(__dst + 248), (uint64_t)&v5[10].__r_.__value_.__l.__size_);
      __dst += 280;
      uint64_t v5 = (std::string *)((char *)v5 + 280);
    }
    while (v5 != a2);
  }
  return __dst;
}

uint64_t sub_100B96274(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100B96010(a2, a3);
}

__n128 sub_100B96280(uint64_t a1, uint64_t a2, __n128 *a3)
{
  unint64_t v3 = a3->n128_u64[0];
  *(_DWORD *)(a2 + 8) = a3->n128_u32[2];
  *(void *)a2 = v3;
  *(unsigned char *)(a2 + 16) = 0;
  *(unsigned char *)(a2 + 40) = 0;
  if (a3[2].n128_u8[8])
  {
    __n128 v4 = a3[1];
    *(void *)(a2 + 32) = a3[2].n128_u64[0];
    *(__n128 *)(a2 + 16) = v4;
    a3[1].n128_u64[1] = 0;
    a3[2].n128_u64[0] = 0;
    a3[1].n128_u64[0] = 0;
    *(unsigned char *)(a2 + 40) = 1;
  }
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  __n128 result = a3[3];
  *(__n128 *)(a2 + 48) = result;
  *(void *)(a2 + 64) = a3[4].n128_u64[0];
  a3[3].n128_u64[0] = 0;
  a3[3].n128_u64[1] = 0;
  a3[4].n128_u64[0] = 0;
  return result;
}

__n128 sub_100B962E8(uint64_t a1, __n128 *a2, __n128 *a3)
{
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  __n128 result = *a3;
  *a2 = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  return result;
}

uint64_t sub_100B9630C(uint64_t a1)
{
  unint64_t v3 = (void **)(a1 + 144);
  sub_100B963A8(&v3);
  unint64_t v3 = (void **)(a1 + 120);
  sub_100155410(&v3);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100B963A8(void ***a1)
{
  uint64_t v1 = *a1;
  long long v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 384;
        sub_100B93570(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_100B9642C(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  sub_100B913FC((uint64_t)(__dst + 4), (uint64_t)(a2 + 2));
  *((unsigned char *)__dst + 384) = 1;
  return __dst;
}

void sub_100B96490(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B964AC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  sub_100B96504((char *)a1, *(void ***)a2, (void **)(a2 + 8));
  return a1;
}

void sub_100B964EC(_Unwind_Exception *a1)
{
  sub_10010C0E0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_100B96504(char *result, void **a2, void **a3)
{
  if (a2 != a3)
  {
    long long v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t)(result + 8);
    do
    {
      __n128 result = sub_100B96590(v5, v6, v4 + 4, (long long *)v4 + 2);
      long long v7 = (void **)v4[1];
      if (v7)
      {
        do
        {
          long long v8 = v7;
          long long v7 = (void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          long long v8 = (void **)v4[2];
          BOOL v9 = *v8 == v4;
          long long v4 = v8;
        }
        while (!v9);
      }
      long long v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

char *sub_100B96590(uint64_t **a1, uint64_t a2, void **a3, long long *a4)
{
  uint64_t v11 = 0;
  long long v12 = 0;
  uint64_t v6 = sub_1000C6D50(a1, a2, &v12, &v11, a3);
  long long v7 = (char *)*v6;
  if (!*v6)
  {
    long long v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1008DD590((uint64_t)a1, a4, v10);
    sub_100046C38(a1, (uint64_t)v12, v8, (uint64_t *)v10[0]);
    long long v7 = v10[0];
    v10[0] = 0;
    sub_10010E764((uint64_t)v10, 0);
  }
  return v7;
}

uint64_t sub_100B96634(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }

  return std::streambuf::~streambuf();
}

void sub_100B96694(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  std::streambuf::~streambuf();

  operator delete();
}

void *sub_100B96708(void *result, uint64_t a2, uint64_t a3)
{
  result[2] = a2;
  result[3] = a2;
  result[4] = a2 + a3;
  return result;
}

double sub_100B96718@<D0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  if ((a4 & 0x10) != 0)
  {
    uint64_t v7 = -1;
    goto LABEL_19;
  }
  uint64_t v5 = a1[2];
  uint64_t v6 = a1[4] - v5;
  if (!a3)
  {
    uint64_t v7 = -1;
    if (a2 < 0 || v6 < a2) {
      goto LABEL_19;
    }
    uint64_t v9 = v5 + a2;
LABEL_15:
    uint64_t v8 = a1[4];
    goto LABEL_16;
  }
  if (a3 == 1)
  {
    uint64_t v7 = -1;
    uint64_t v10 = a1[3] - v5 + a2;
    if (v10 < 0 || v10 > v6) {
      goto LABEL_19;
    }
    uint64_t v9 = a1[3] + a2;
    goto LABEL_15;
  }
  if (a3 != 2)
  {
    uint64_t v9 = a1[3];
    goto LABEL_18;
  }
  uint64_t v7 = -1;
  if ((a2 & 0x8000000000000000) == 0 && v6 >= a2)
  {
    uint64_t v8 = a1[4];
    uint64_t v9 = v8 - a2;
LABEL_16:
    a1[3] = v9;
    a1[4] = v8;
LABEL_18:
    uint64_t v7 = v9 - v5;
  }
LABEL_19:
  double result = 0.0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(void *)(a5 + 128) = v7;
  return result;
}

double sub_100B967C8@<D0>(void *a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  if ((a3 & 0x10) == 0)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = *(void *)(a2 + 128);
    if (v5 <= a1[4] - v4)
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = a1[4];
      a1[3] = v6;
      a1[4] = v7;
    }
  }
  double result = 0.0;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(void *)(a4 + 128) = -1;
  return result;
}

_OWORD *sub_100B96810(uint64_t **a1, void **a2, _OWORD **a3)
{
  uint64_t v12 = 0;
  uint64_t v5 = (void **)sub_100046ED4((uint64_t)a1, &v12, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    v11[2] = 1;
    uint64_t v6 = operator new(0x50uLL);
    v11[1] = a1 + 1;
    uint64_t v8 = *a3;
    uint64_t v9 = *((void *)*a3 + 2);
    v6[2] = **a3;
    *((void *)v6 + 6) = v9;
    v8[1] = 0;
    uint64_t v8[2] = 0;
    *uint64_t v8 = 0;
    *((void *)v6 + 7) = 0;
    *((void *)v6 + 8) = 0;
    *((void *)v6 + 9) = 0;
    sub_100046C38(a1, v12, v7, (uint64_t *)v6);
    v11[0] = 0;
    sub_10010E764((uint64_t)v11, 0);
  }
  return v6;
}

void sub_100B968D0(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100B9693C()
{
}

ctu::OsLogLogger *sub_100B96960(ctu::OsLogLogger *a1, void *a2)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, "vvm.mdl");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, &v6);
  ctu::OsLogLogger::OsLogLogger(a1, (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 3) = *a2;
  uint64_t v4 = a2[1];
  *((void *)a1 + 4) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100B969F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void sub_100B96A1C(ctu::OsLogLogger *this)
{
  long long v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  ctu::OsLogLogger::~OsLogLogger(this);
}

void sub_100B96A68(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  OsLogContext v6 = operator new(0x10uLL);
  char v19 = v6 + 2;
  char v20 = v6 + 2;
  *OsLogContext v6 = @"com.apple.voicemail.imap";
  v6[1] = @"BeaconAddress";
  long long __p = v6;
  *a3 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v21);
  if (v13)
  {
    uint64_t v15 = v13[3];
    unsigned __int8 v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  unsigned __int8 v14 = 0;
  char v16 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v15 + 104))(&v17, v15, a2, 1, &__p, 0, 0);
  sub_100056248(a3, &v17);
  sub_1000577C4(&v17);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (__p)
  {
    char v19 = __p;
    operator delete(__p);
  }
}

void sub_100B96BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12)
{
  sub_1000577C4(&a10);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (__p)
  {
    a12 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100B96C28(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100B96CB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B96D94((ctu::OsLogLogger **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100B96CD0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

ctu::OsLogLogger *sub_100B96D08(uint64_t a1)
{
  double result = *(ctu::OsLogLogger **)(a1 + 24);
  if (result)
  {
    sub_100B96A1C(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100B96D50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

ctu::OsLogLogger *sub_100B96D94(ctu::OsLogLogger **a1, ctu::OsLogLogger *a2)
{
  double result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_100B96A1C(result);
    operator delete();
  }
  return result;
}

void RegistrationController::setupEvents_sync(dispatch_object_t *this, group_session a2)
{
  uint64_t v3 = this + 1;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100B9E338;
  aBlock[3] = &unk_101A416A0;
  aBlock[4] = this + 1;
  void aBlock[5] = sub_100B98A3C;
  aBlock[6] = 0;
  uint64_t v5 = _Block_copy(aBlock);
  sub_10003E168(v4, v3);
  sub_1001644F8(&v8, &v5, this[3]);
  sub_100164540(&v7, &v8);
  sub_100B9E384((uint64_t)&v7, v4[0], v4[1]);
}

void sub_100B987B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B98A3C(RegistrationController *a1)
{
  long long v2 = *((void *)a1 + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Querying current serving system after exiting low power", buf, 2u);
  }
  RegistrationController::sendGetServingSystemReq_sync(a1);
  uint64_t v3 = *((void *)a1 + 5);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Querying encryption status after exiting low power", v5, 2u);
  }
  return RegistrationController::getEncryptionStatus_sync(a1);
}

void sub_100B98AEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  aBlock[6] = a5;
  uint64_t v8 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100B9EA64;
  aBlock[3] = &unk_101A417D0;
  aBlock[4] = a2;
  void aBlock[5] = a4;
  uint64_t v8 = _Block_copy(aBlock);
  sub_10003E168(v6, (void *)a2);
  sub_1001644F8(v9, &v8, *(dispatch_object_t *)(a2 + 16));
  sub_100164540(v10, v9);
  sub_100B9E384((uint64_t)v10, v6[0], v6[1]);
}

void sub_100B98C04(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_10016578C((uint64_t)va);
  sub_10006A6AC(a1);
}

void sub_100B98C34(RegistrationController *a1)
{
  long long v2 = *((void *)a1 + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I New Call in ECBM, exit ECBM mode", v3, 2u);
  }
  RegistrationController::setECBM_sync(a1, 0);
}

void sub_100B98CA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  aBlock[6] = a5;
  unint64_t v9 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100B9EAB0;
  aBlock[3] = &unk_101A417F0;
  aBlock[4] = a2;
  void aBlock[5] = a4;
  unint64_t v9 = _Block_copy(aBlock);
  sub_10003E168(&v6, (void *)a2);
  sub_10097FEF0(v10, &v9, *(dispatch_object_t *)(a2 + 16));
  sub_10097FF38(&v11, v10);
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_100B98EE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22)
{
  if (a2)
  {
    sub_100163BC8(v23 - 64);
    uint64_t v25 = *(void *)(v23 - 72);
    if (v25) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    }
    if (v22) {
      std::__shared_weak_count::__release_weak(v22);
    }
    sub_10097F2DC((uint64_t)&a21);
    sub_100980DC8((uint64_t)&a19);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B98F9C(uint64_t a1, char a2)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 104) + 160))(*(void *)(a1 + 104)))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Already sent baseband online request, initiating network attach", buf, 2u);
    }
    return (*(uint64_t (**)(void))(**(void **)(a1 + 232) + 120))(*(void *)(a1 + 232));
  }
  else
  {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 104) + 152))(*(void *)(a1 + 104), 1);
    uint64_t result = subscriber::makeSimSlotRange();
    uint64_t v5 = v13;
    if (v13 != v14)
    {
      while (1)
      {
        uint64_t result = v15(*v5);
        if (result) {
          break;
        }
        if (++v5 == v14)
        {
          uint64_t v5 = v14;
          break;
        }
      }
      while (v5 != v14)
      {
        uint64_t v6 = *v5;
        RegistrationController::sendVolteEnabledSettingToBaseband_sync(a1, v6);
        uint64_t v7 = *(void *)(a1 + 216);
        sub_10003E168(buf, (void *)(a1 + 8));
        uint64_t v8 = *(void *)buf;
        unint64_t v9 = v17;
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v9);
        }
        uint64_t v10 = operator new(0x38uLL);
        *uint64_t v10 = off_101A41540;
        v10[1] = a1;
        *((_DWORD *)v10 + 4) = v6;
        _OWORD v10[3] = v8;
        v10[4] = v9;
        void v10[5] = a1;
        *((unsigned char *)v10 + 48) = a2;
        char v18 = v10;
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v7 + 72))(v7, v6, buf);
        uint64_t result = (uint64_t)sub_10041A970(buf);
        long long v11 = v5 + 1;
        uint64_t v5 = v14;
        if (v11 != v14)
        {
          uint64_t v5 = v11;
          while (1)
          {
            uint64_t result = v15(*v5);
            if (result) {
              break;
            }
            if (++v5 == v14)
            {
              uint64_t v5 = v14;
              break;
            }
          }
        }
      }
    }
  }
  return result;
}

void sub_100B99208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10041A970((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100B99238(uint64_t a1)
{
  long long v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Radio has been reset", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(a1 + 120) + 56))(*(void *)(a1 + 120));
  uint64_t v3 = *(void **)(a1 + 64);
  if (v3 != (void *)(a1 + 72))
  {
    do
    {
      (*(void (**)(void, uint64_t, uint64_t))(*(void *)v3[5] + 552))(v3[5], 1, 11);
      uint64_t v4 = (std::__shared_weak_count *)v3[6];
      uint64_t v8 = v3[5];
      unint64_t v9 = v4;
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      RegistrationController::setRegistrationStatus_sync(a1, &v8, 1, 0);
      if (v9) {
        sub_10004D2C8(v9);
      }
      uint64_t v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }
        while (!v7);
      }
      uint64_t v3 = v6;
    }
    while (v6 != (void *)(a1 + 72));
  }
}

void sub_100B99384(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9939C(uint64_t a1)
{
  long long v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Radio has been disabled", buf, 2u);
  }
  uint64_t v3 = *(void **)(a1 + 64);
  if (v3 != (void *)(a1 + 72))
  {
    do
    {
      (*(void (**)(void, uint64_t, uint64_t))(*(void *)v3[5] + 552))(v3[5], 1, 11);
      uint64_t v4 = (std::__shared_weak_count *)v3[6];
      uint64_t v8 = v3[5];
      unint64_t v9 = v4;
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      RegistrationController::setRegistrationStatus_sync(a1, &v8, 1, 0);
      if (v9) {
        sub_10004D2C8(v9);
      }
      uint64_t v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }
        while (!v7);
      }
      uint64_t v3 = v6;
    }
    while (v6 != (void *)(a1 + 72));
  }
}

void sub_100B994C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B994D8(uint64_t a1)
{
  long long v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Baseband is switched on", v5, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 104);
  v6[0] = off_101A429A8;
  v6[1] = a1;
  void v6[3] = v6;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 136))(v3, 1, v6);
  return sub_10003B34C(v6);
}

void sub_100B995C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B995D8(uint64_t a1)
{
  long long v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Baseband is switched off", v5, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 104);
  v6[0] = off_101A42A28;
  v6[1] = a1;
  void v6[3] = v6;
  (*(void (**)(uint64_t, void, void *))(*(void *)v3 + 136))(v3, 0, v6);
  return sub_10003B34C(v6);
}

void sub_100B996C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B996D8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 40))();
}

void sub_100B99700(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "false";
    if (a2) {
      uint64_t v5 = "true";
    }
    int v6 = 136315138;
    BOOL v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I LTE preference is being changed to %s", (uint8_t *)&v6, 0xCu);
  }
  RegistrationController::sendLteEnabledSetting_sync(a1, 1, a2, 2);
}

void sub_100B997D4(Registry **a1, int a2)
{
}

void sub_100B997DC(uint64_t a1)
{
  long long v2 = *(void **)(a1 + 64);
  uint64_t v3 = (void *)(a1 + 72);
  if (v2 != (void *)(a1 + 72))
  {
    do
    {
      (*(void (**)(void))(*(void *)v2[5] + 48))(v2[5]);
      uint64_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          long long v2 = v5;
        }
        while (!v6);
      }
      long long v2 = v5;
    }
    while (v5 != v3);
  }
  (*(void (**)(void))(**(void **)(a1 + 104) + 32))(*(void *)(a1 + 104));
  (*(void (**)(void))(**(void **)(a1 + 296) + 56))(*(void *)(a1 + 296));
  (*(void (**)(void))(**(void **)(a1 + 120) + 64))(*(void *)(a1 + 120));
  BOOL v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 376)) {
      uint64_t v8 = "true";
    }
    else {
      uint64_t v8 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v15 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Enable only home network: %s", buf, 0xCu);
  }
  unint64_t v9 = *(void **)(a1 + 912);
  if (v9 != (void *)(a1 + 920))
  {
    do
    {
      uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v9 + 7));
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = *((unsigned __int8 *)v9 + 32);
        *(_DWORD *)std::string buf = 67109120;
        LODWORD(v15) = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I 5G SA Capability: %d", buf, 8u);
      }
      unsigned int v12 = (void *)v9[1];
      if (v12)
      {
        do
        {
          char v13 = v12;
          unsigned int v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          char v13 = (void *)v9[2];
          BOOL v6 = *v13 == (void)v9;
          unint64_t v9 = v13;
        }
        while (!v6);
      }
      unint64_t v9 = v13;
    }
    while (v13 != (void *)(a1 + 920));
  }
}

uint64_t sub_100B99A5C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 256))();
}

void sub_100B99A8C(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 440) == a2) {
    return;
  }
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = asString();
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I CMAS camp only mode has changed from %s to %s", buf, 0x16u);
  }
  if (a2 != 2)
  {
    if (a2)
    {
      int v5 = *(_DWORD *)(a1 + 440);
    }
    else
    {
      int v5 = *(_DWORD *)(a1 + 440);
      if (v5 == 3)
      {
        BOOL v6 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = asString();
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I CMAS camp only mode is already %s", buf, 0xCu);
        }
        subscriber::makeSimSlotRange();
        unint64_t v9 = *(unsigned int **)buf;
        uint64_t v8 = *(unsigned int **)&buf[8];
        if (*(void *)buf != *(void *)&buf[8])
        {
          uint64_t v10 = *(uint64_t (**)(void))&buf[16];
          while ((v10(*v9) & 1) == 0)
          {
            if (++v9 == v8)
            {
              unint64_t v9 = v8;
              break;
            }
          }
          if (v9 != *(unsigned int **)&buf[8]) {
            RegistrationController::handleSetCampOnlyModeResult(a1);
          }
        }
        return;
      }
    }
    goto LABEL_28;
  }
  int v5 = *(_DWORD *)(a1 + 440);
  if (v5 != 1)
  {
LABEL_28:
    if ((v5 | 2) == 2)
    {
      subscriber::makeSimSlotRange();
      char v17 = *(int **)buf;
      char v16 = *(int **)&buf[8];
      if (*(void *)buf != *(void *)&buf[8])
      {
        char v18 = *(uint64_t (**)(void))&buf[16];
        while ((v18(*v17) & 1) == 0)
        {
          if (++v17 == v16)
          {
            char v17 = v16;
            break;
          }
        }
        char v19 = *(int **)&buf[8];
        while (v17 != v19)
        {
          int v24 = 0;
          int v24 = *v17;
          char v20 = sub_1000FD774(a1 + 64, &v24);
          unint64_t v21 = (std::__shared_weak_count *)v20[1];
          v23[0] = *v20;
          v23[1] = v21;
          if (v21) {
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          RegistrationController::reevaluateDataMode_sync(a1, v23);
          if (v21) {
            sub_10004D2C8(v21);
          }
          char v22 = v17 + 1;
          char v17 = v16;
          if (v22 != v16)
          {
            char v17 = v22;
            while ((v18(*v17) & 1) == 0)
            {
              if (++v17 == v16)
              {
                char v17 = v16;
                break;
              }
            }
          }
        }
      }
    }
    else
    {
      RegistrationController::sendCampOnlyModeSetting_sync((RegistrationController *)a1);
    }
    return;
  }
  int v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I CMAS camp only mode is already %s", buf, 0xCu);
  }
  subscriber::makeSimSlotRange();
  unsigned __int8 v14 = *(unsigned int **)buf;
  char v13 = *(unsigned int **)&buf[8];
  if (*(void *)buf != *(void *)&buf[8])
  {
    uint64_t v15 = *(uint64_t (**)(void))&buf[16];
    while ((v15(*v14) & 1) == 0)
    {
      if (++v14 == v13)
      {
        unsigned __int8 v14 = v13;
        break;
      }
    }
    if (v14 != *(unsigned int **)&buf[8]) {
      RegistrationController::handleSetCampOnlyModeResult(a1);
    }
  }
}

void sub_100B99E40(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B99E60(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 528))
  {
    uint64_t v3 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v4 = *(void **)(a1 + 512);
    int v5 = v4;
    while (1)
    {
      BOOL v6 = *((_DWORD *)v3 + 7) == *((_DWORD *)v5 + 7) && *((_DWORD *)v3 + 8) == *((_DWORD *)v5 + 8);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v3[1];
      uint64_t v8 = v3;
      if (v7)
      {
        do
        {
          uint64_t v3 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v8[2];
          BOOL v6 = *v3 == (void)v8;
          uint64_t v8 = v3;
        }
        while (!v6);
      }
      unint64_t v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          unint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          int v5 = v10;
        }
        while (!v6);
      }
      int v5 = v10;
      if (v3 == a2 + 1) {
        return;
      }
    }
  }
  else
  {
    uint64_t v4 = *(void **)(a1 + 512);
  }
  int v11 = (void *)(a1 + 520);
  if (v4 != (void *)(a1 + 520))
  {
    uint64_t v12 = a2 + 1;
    while (1)
    {
      uint64_t v13 = *v12;
      uint64_t v14 = *((unsigned int *)v4 + 7);
      if (!*v12) {
        break;
      }
      uint64_t v15 = v12;
      do
      {
        int v16 = *(_DWORD *)(v13 + 28);
        BOOL v17 = v16 < (int)v14;
        if (v16 >= (int)v14) {
          char v18 = (uint64_t *)v13;
        }
        else {
          char v18 = (uint64_t *)(v13 + 8);
        }
        if (!v17) {
          uint64_t v15 = (void *)v13;
        }
        uint64_t v13 = *v18;
      }
      while (*v18);
      if (v15 == v12 || (int)v14 < *((_DWORD *)v15 + 7)) {
        break;
      }
      uint64_t v19 = *((unsigned int *)v4 + 8);
      if (*((_DWORD *)v15 + 8) != v19) {
        goto LABEL_35;
      }
LABEL_51:
      uint64_t v25 = (void *)v4[1];
      if (v25)
      {
        do
        {
          uint64_t v26 = v25;
          uint64_t v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          uint64_t v26 = (void *)v4[2];
          BOOL v6 = *v26 == (void)v4;
          uint64_t v4 = v26;
        }
        while (!v6);
      }
      uint64_t v4 = v26;
      if (v26 == v11) {
        return;
      }
    }
    uint64_t v19 = *((unsigned int *)v4 + 8);
LABEL_35:
    char v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v4 + 7));
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      asStringUiMask((uint64_t *)__p, v19);
      unint64_t v21 = v28 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 136446210;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I DataUiModifier changed to %{public}s", buf, 0xCu);
      if (v28 < 0) {
        operator delete(__p[0]);
      }
    }
    __p[0] = 0;
    __p[1] = 0;
    RegistrationController::getModel_sync(a1, v14, __p);
    char v22 = __p[0];
    if (__p[0])
    {
      uint64_t v23 = (std::__shared_weak_count *)__p[1];
      *(_OWORD *)std::string buf = *(_OWORD *)__p;
      if (__p[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)__p[1] + 1, 1uLL, memory_order_relaxed);
      }
      RegistrationController::reevaluateDataMode_sync(a1, buf);
      if (v23) {
        sub_10004D2C8(v23);
      }
      (*(void (**)(void *, uint64_t))(*(void *)v22 + 872))(v22, v19);
    }
    else
    {
      int v24 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find model for updating DataUiModifier", buf, 2u);
      }
    }
    if (__p[1]) {
      sub_10004D2C8((std::__shared_weak_count *)__p[1]);
    }
    goto LABEL_51;
  }
}

void sub_100B9A1D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9A210(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t v6 = *(unsigned int *)(a2 + 104);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v10 = *(void *)(a2 + 16);
  }
  uint64_t v7 = *(unsigned int *)(a2 + 24);
  sub_10005EA44((MCC *)v8, a2 + 32);
  (*(void (**)(uint64_t, uint64_t, void **, uint64_t, unsigned char *, uint64_t))(*(void *)v5 + 248))(v5, v6, __p, v7, v8, a3);
  sub_100021FF4((uint64_t)v8);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100B9A2E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100B9A30C(uint64_t a1, uint64_t a2)
{
  void (***v11)(uint64_t *__return_ptr, void, uint64_t);
  void *v12;
  os_log_t *v13;
  void **v14;
  void **v15;
  int v16;
  int v17;
  NSObject *v18;
  capabilities::ct *v19;
  const char *v20;
  uint64_t v21;
  int v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  std::mutex *v30;
  std::mutex *v31;
  uint64_t v32;
  unsigned __int8 *v33;
  uint64_t v34;
  unsigned int v35;
  void *v36;
  GestaltUtilityInterface *v37;
  std::__shared_weak_count *v38;
  os_log_t v39;
  const char *v40;
  uint64_t v41;
  int v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  const char *v47;
  uint32_t v48;
  int isWatch;
  char v50;
  NSObject *v51;
  os_log_t *v52;
  unsigned int v53;
  NSObject *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  NSObject *v59;
  NSObject *v60;
  os_log_t *v61;
  int v62;
  os_log_t v63;
  const char *v64;
  void *v65;
  void *v66;
  BOOL v67;
  std::__shared_weak_count *v68;
  uint64_t v69;
  os_log_t *v70;
  char v71;
  void **v72;
  void *__p;
  void *v75;
  uint64_t v76;
  void *v77;
  unsigned char *v78;
  uint64_t v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  uint64_t v82;
  std::__shared_weak_count *v83;
  uint8_t v84[4];
  uint64_t v85;
  __int16 v86;
  uint64_t v87;
  uint8_t buf[32];
  __int16 v89;
  uint64_t v90;
  __int16 v91;
  uint64_t v92;
  __int16 v93;
  uint64_t v94;
  __int16 v95;
  uint64_t v96;

  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  unint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (!v9)
  {
    int v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    unint64_t v68 = 0;
    uint64_t v71 = 1;
    if (!v11) {
      goto LABEL_84;
    }
    goto LABEL_10;
  }
  int v11 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v68 = v10;
  sub_10004D2C8(v10);
  uint64_t v71 = 0;
  if (v11)
  {
LABEL_10:
    uint64_t v12 = *(void **)(a1 + 624);
    if (v12 == (void *)(a1 + 632)) {
      goto LABEL_84;
    }
    long long v72 = (void **)(a2 + 8);
    uint64_t v69 = a2;
    while (1)
    {
      uint64_t v82 = 0;
      long long v83 = 0;
      (**v11)(&v82, v11, (uint64_t)(v12 + 4));
      if (!v82 || *(unsigned char *)(v82 + 49)) {
        goto LABEL_76;
      }
      uint64_t v13 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(v82 + 52));
      uint64_t v14 = sub_100046F68(a2, (void **)v12 + 4);
      uint64_t v15 = v14;
      if (v72 != v14) {
        break;
      }
      char v39 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        long long v40 = (const char *)(v82 + 24);
        uint64_t v41 = *(unsigned __int8 *)(v82 + 47);
        long long v42 = (char)v41;
        if ((v41 & 0x80u) != 0) {
          uint64_t v41 = *(void *)(v82 + 32);
        }
        if (v42 < 0) {
          long long v40 = *(const char **)(v82 + 24);
        }
        if (v41) {
          uint64_t v43 = v40;
        }
        else {
          uint64_t v43 = "<invalid>";
        }
        long long v44 = sd::asString();
        uint64_t v45 = sd::asString();
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = v43;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v44;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v45;
        long long v46 = v39;
        char v47 = "#I IMS feature state added for Personality: %s - cell [%s] wifi [%s]";
        char v48 = 32;
        goto LABEL_74;
      }
LABEL_75:
      RegistrationController::sendVolteEnabledSettingToBaseband_sync(a1, *(unsigned int *)(v82 + 52));
LABEL_76:
      if (v83) {
        sub_10004D2C8(v83);
      }
      long long v65 = (void *)v12[1];
      if (v65)
      {
        do
        {
          uint64_t v66 = v65;
          long long v65 = (void *)*v65;
        }
        while (v65);
      }
      else
      {
        do
        {
          uint64_t v66 = (void *)v12[2];
          long long v67 = *v66 == (void)v12;
          uint64_t v12 = v66;
        }
        while (!v67);
      }
      uint64_t v12 = v66;
      if (v66 == (void *)(a1 + 632)) {
        goto LABEL_84;
      }
    }
    int v16 = *((_DWORD *)v14 + 14);
    BOOL v17 = *((_DWORD *)v12 + 14);
    if (v16 == v17
      && *((_DWORD *)v14 + 15) == *((_DWORD *)v12 + 15)
      && *((unsigned __int8 *)v14 + 64) == *((unsigned __int8 *)v12 + 64))
    {
      goto LABEL_76;
    }
    char v18 = *v13;
    uint64_t v19 = (capabilities::ct *)os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT);
    if (v19)
    {
      unint64_t v70 = v13;
      char v20 = (const char *)(v82 + 24);
      unint64_t v21 = *(unsigned __int8 *)(v82 + 47);
      char v22 = (char)v21;
      if ((v21 & 0x80u) != 0) {
        unint64_t v21 = *(void *)(v82 + 32);
      }
      if (v22 < 0) {
        char v20 = *(const char **)(v82 + 24);
      }
      if (v21) {
        uint64_t v23 = v20;
      }
      else {
        uint64_t v23 = "<invalid>";
      }
      int v24 = sd::asString();
      uint64_t v25 = sd::asString();
      uint64_t v26 = asStringBool(*((unsigned char *)v15 + 64));
      uint64_t v27 = sd::asString();
      char v28 = sd::asString();
      long long v29 = asStringBool(*((unsigned char *)v12 + 64));
      *(_DWORD *)std::string buf = 136316674;
      *(void *)&uint8_t buf[4] = v23;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v24;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v25;
      uint64_t v89 = 2080;
      long long v90 = v26;
      long long v91 = 2080;
      v92 = v27;
      uint64_t v93 = 2080;
      BOOL v94 = v28;
      long long v95 = 2080;
      uint64_t v96 = v29;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I IMS feature state for Personality: %s changed from cell [%s] wifi [%s] 5gVoice: %s to cell [%s] wifi [%s] 5gVoice: %s", buf, 0x48u);
      int v16 = *((_DWORD *)v15 + 14);
      BOOL v17 = *((_DWORD *)v12 + 14);
      a2 = v69;
      uint64_t v13 = v70;
    }
    if (v16 == v17) {
      goto LABEL_66;
    }
    if (capabilities::ct::supports5G(v19))
    {
LABEL_48:
      char v51 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I IMS Pref adjustment for IMS feature state enabled", buf, 2u);
      }
      unint64_t v80 = 0;
      uint64_t v81 = 0;
      RegistrationController::getModel_sync(a1, *(_DWORD *)(v82 + 52), &v80);
      if (v80)
      {
        memset(buf, 0, sizeof(buf));
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v80 + 752))(buf);
        uint64_t v52 = v13;
        uint64_t v77 = 0;
        long long v78 = 0;
        long long v79 = 0;
        sub_1003FB56C(&v77, *(const void **)buf, *(uint64_t *)&buf[8], (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 2);
        uint64_t v53 = RegistrationController::checkAndSetSmsServiceMask_sync(a1, *(unsigned int *)(v82 + 52), &v77, *(unsigned int *)&buf[24]);
        uint64_t v54 = *v13;
        if (os_log_type_enabled(*v52, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v55 = sd::asString();
          uint64_t v56 = sd::asString();
          *(_DWORD *)uint64_t v84 = 136315394;
          uint64_t v85 = v55;
          unint64_t v86 = 2080;
          uint64_t v87 = v56;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I IMS Pref service mask is adjusted: [%s] -> [%s]", v84, 0x16u);
        }
        uint64_t v57 = *(void *)(a1 + 344);
        std::string::size_type v58 = *(unsigned int *)(v82 + 52);
        uint64_t v75 = 0;
        long long v76 = 0;
        long long __p = 0;
        sub_1003FB56C(&__p, v77, (uint64_t)v78, (v78 - (unsigned char *)v77) >> 2);
        (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v57 + 96))(v57, v58, &__p, v53);
        if (__p)
        {
          uint64_t v75 = __p;
          operator delete(__p);
        }
        uint64_t v13 = v52;
        if (v77)
        {
          long long v78 = v77;
          operator delete(v77);
        }
        if (*(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
      }
      else
      {
        uint64_t v59 = *v13;
        if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I No model is found", buf, 2u);
        }
      }
      uint64_t v19 = (capabilities::ct *)v81;
      if (v81) {
        sub_10004D2C8(v81);
      }
      goto LABEL_66;
    }
    uint64_t v30 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
    uint64_t v31 = v30;
    if (v32 < 0)
    {
      uint64_t v33 = (unsigned __int8 *)(v32 & 0x7FFFFFFFFFFFFFFFLL);
      long long v34 = 5381;
      do
      {
        int v32 = v34;
        long long v35 = *v33++;
        long long v34 = (33 * v34) ^ v35;
      }
      while (v35);
    }
    std::mutex::lock(v30);
    *(void *)std::string buf = v32;
    uint64_t v36 = sub_10004D37C(&v31[1].__m_.__sig, (unint64_t *)buf);
    if (v36)
    {
      long long v37 = (GestaltUtilityInterface *)v36[3];
      uint64_t v38 = (std::__shared_weak_count *)v36[4];
      if (v38)
      {
        atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v31);
        atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v38);
LABEL_46:
        isWatch = GestaltUtilityInterface::isWatch(v37);
        uint64_t v50 = isWatch;
        if (v38)
        {
          sub_10004D2C8(v38);
          a2 = v69;
          if (v50) {
            goto LABEL_48;
          }
        }
        else
        {
          a2 = v69;
          if (isWatch) {
            goto LABEL_48;
          }
        }
        uint64_t v60 = *v13;
        uint64_t v19 = (capabilities::ct *)os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT);
        if (v19)
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I IMS Pref adjustment for IMS feature state is not enabled", buf, 2u);
        }
LABEL_66:
        if (!capabilities::ct::supportsVoNR(v19)
          || (v61 = v13, unint64_t v62 = *((unsigned __int8 *)v12 + 64), *((unsigned __int8 *)v15 + 64) == v62))
        {
          if (v16 == v17) {
            goto LABEL_76;
          }
          goto LABEL_75;
        }
        uint64_t v63 = *v61;
        if (os_log_type_enabled(*v61, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v64 = "en";
          if (!v62) {
            uint64_t v64 = "dis";
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v64;
          long long v46 = v63;
          char v47 = "#I IMS feature VoNR %sabled";
          char v48 = 12;
LABEL_74:
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, v47, buf, v48);
          goto LABEL_75;
        }
        goto LABEL_75;
      }
    }
    else
    {
      long long v37 = 0;
    }
    std::mutex::unlock(v31);
    uint64_t v38 = 0;
    goto LABEL_46;
  }
LABEL_84:
  if ((v71 & 1) == 0) {
    sub_10004D2C8(v68);
  }
}

void sub_100B9AB08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,int a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,std::__shared_weak_count *a33,uint64_t a34,std::__shared_weak_count *a35)
{
  if (__p) {
    operator delete(__p);
  }
  if (a29) {
    operator delete(a29);
  }
  long long v37 = *(void **)(v35 - 176);
  if (v37)
  {
    *(void *)(v35 - 168) = v37;
    operator delete(v37);
  }
  if (a33) {
    sub_10004D2C8(a33);
  }
  if (a35) {
    sub_10004D2C8(a35);
  }
  if ((a22 & 1) == 0) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9ABCC(uint64_t a1, uint64_t a2)
{
  long long v2 = *(unsigned int **)(a1 + 488);
  uint64_t v3 = *(unsigned int **)(a1 + 496);
  if (v2 != v3)
  {
    do
    {
      uint64_t v6 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *v2);
      if ((subscriber::isSimAbsent() & 1) != 0 || subscriber::isSimUnreadable())
      {
        (*(void (**)(void, void, void, uint64_t))(**(void **)(a1 + 344) + 168))(*(void *)(a1 + 344), *v2, 0, 11);
        (*(void (**)(void, void, void, uint64_t, void, void))(**(void **)(a1 + 344) + 160))(*(void *)(a1 + 344), *v2, 0, 11, 0, 0);
        uint64_t v7 = *v6;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v28 = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Clearing network_rejects", v28, 2u);
        }
      }
      v2 += 42;
    }
    while (v2 != v3);
    unsigned int v8 = *(_DWORD **)(a1 + 488);
    unint64_t v9 = *(_DWORD **)(a1 + 496);
    if (v8 != v9)
    {
      uint64_t v10 = *(_DWORD **)a2;
      int v11 = *(_DWORD **)(a2 + 8);
      while (*v8 != 1)
      {
        v8 += 42;
        if (v8 == v9) {
          goto LABEL_33;
        }
      }
      int v12 = v8[3];
      while (v10 != v11)
      {
        if (*v10 == 1)
        {
          if (v10[3] == v12) {
            goto LABEL_33;
          }
          break;
        }
        v10 += 42;
      }
      uint64_t v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = subscriber::asString();
        *(_DWORD *)char v28 = 136315138;
        *(void *)&v28[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Handling SIM tray state (%s)", v28, 0xCu);
      }
      if ((v12 | 2) == 3)
      {
        uint64_t v15 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v28 = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Event was SIM tray removal", v28, 2u);
        }
        *(_DWORD *)char v28 = 1;
        int v16 = sub_1000FD774(a1 + 64, (int *)v28);
        uint64_t v18 = *v16;
        BOOL v17 = (std::__shared_weak_count *)v16[1];
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 168) + 168))(*(void *)(a1 + 168), 1) == 1)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18 + 552))(v18, 6, 11);
          *(void *)char v28 = v18;
          *(void *)&v28[8] = v17;
          if (v17) {
            atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          RegistrationController::setRegistrationStatus_sync(a1, v28, 6, 1);
          if (*(void *)&v28[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v28[8]);
          }
        }
        else
        {
          uint64_t v19 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)char v28 = 0;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Bundle type was not SIM based; not clearing registration status or notifying clients even though we may be MM roaming",
              v28,
              2u);
          }
        }
        if (v17) {
          sub_10004D2C8(v17);
        }
      }
    }
LABEL_33:
    if (*(void *)(a1 + 496) == *(void *)(a1 + 488)) {
      sub_10015B728();
    }
    if (subscriber::isSimReady())
    {
      uint64_t v20 = *(void *)(a1 + 600);
      if (v20)
      {
        uint64_t v21 = a1 + 600;
        do
        {
          int v22 = *(_DWORD *)(v20 + 28);
          BOOL v23 = v22 < 1;
          if (v22 >= 1) {
            int v24 = (uint64_t *)v20;
          }
          else {
            int v24 = (uint64_t *)(v20 + 8);
          }
          if (!v23) {
            uint64_t v21 = v20;
          }
          uint64_t v20 = *v24;
        }
        while (*v24);
        if (v21 != a1 + 600 && *(int *)(v21 + 28) <= 1 && *(_DWORD *)(v21 + 32) == 1)
        {
          int v25 = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 88))(*(void *)(a1 + 104));
          uint64_t v26 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v27 = "false";
            if (v25) {
              uint64_t v27 = "true";
            }
            *(_DWORD *)char v28 = 136315394;
            *(void *)&v28[4] = "kGSM_Only";
            *(_WORD *)&v28[12] = 2080;
            *(void *)&v28[14] = v27;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I SIM became ready and device type is %s, ECBM active: %s", v28, 0x16u);
          }
          if (v25) {
            RegistrationController::setECBM_sync((RegistrationController *)a1, 0);
          }
        }
      }
    }
  }
}

void sub_100B9B07C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9B0B0(uint64_t a1, RatSelectionType *this, unsigned char *a3)
{
  uint64_t v15 = 0;
  int v16 = 0;
  int SimSlot = RatSelectionType::getSimSlot(this);
  Model_sync = (capabilities::ct *)RegistrationController::getModel_sync(a1, SimSlot, &v15);
  uint64_t v8 = v15;
  if (v15)
  {
    if (capabilities::ct::supports5G(Model_sync)) {
      int v9 = 211;
    }
    else {
      int v9 = 19;
    }
    *(void *)std::string buf = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 592))(v8);
    if (v9 == RatSelectionType::getSelection((RatSelectionType *)buf)
      && v9 == RatSelectionType::getSelection(this))
    {
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Requested RAT selection already matches current GWL selection", buf, 2u);
      }
      *a3 = 1;
    }
    else
    {
      uint64_t v13 = v8;
      uint64_t v14 = v16;
      if (v16) {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *a3 = RegistrationController::setRatSelection_sync(a1, &v13, this);
      if (v14) {
        sub_10004D2C8(v14);
      }
    }
  }
  else
  {
    int v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      RatSelectionType::getSimSlot(this);
      uint64_t v12 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Could not find %s model for RAT selection request", buf, 0xCu);
    }
    *a3 = 0;
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_100B9B294(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9B2C8(uint64_t a1, uint64_t a2)
{
  if ((rest::operator==() & 1) == 0)
  {
    uint64_t v4 = *(void **)(a1 + 536);
    if (v4 != (void *)(a1 + 544))
    {
      uint64_t v5 = (void *)(a2 + 8);
      while (1)
      {
        uint64_t v6 = v4 + 5;
        (*(void (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v4 + 8));
        uint64_t v7 = *v5;
        uint64_t v8 = *((unsigned int *)v4 + 8);
        if (!*v5) {
          goto LABEL_16;
        }
        int v9 = v5;
        do
        {
          int v10 = *(_DWORD *)(v7 + 32);
          BOOL v11 = v10 < (int)v8;
          if (v10 >= (int)v8) {
            uint64_t v12 = (uint64_t *)v7;
          }
          else {
            uint64_t v12 = (uint64_t *)(v7 + 8);
          }
          if (!v11) {
            int v9 = (void *)v7;
          }
          uint64_t v7 = *v12;
        }
        while (*v12);
        if (v9 == v5 || (int)v8 < *((_DWORD *)v9 + 8)) {
          goto LABEL_16;
        }
        if ((rest::operator==() & 1) == 0) {
          break;
        }
LABEL_64:
        uint64_t v31 = (void *)v4[1];
        if (v31)
        {
          do
          {
            int v32 = v31;
            uint64_t v31 = (void *)*v31;
          }
          while (v31);
        }
        else
        {
          do
          {
            int v32 = (void *)v4[2];
            BOOL v33 = *v32 == (void)v4;
            uint64_t v4 = v32;
          }
          while (!v33);
        }
        uint64_t v4 = v32;
        if (v32 == (void *)(a1 + 544)) {
          return;
        }
      }
      uint64_t v8 = *((unsigned int *)v4 + 8);
LABEL_16:
      uint64_t v13 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v8);
      uint64_t v38 = 0;
      char v39 = 0;
      uint64_t Model_sync = RegistrationController::getModel_sync(a1, v8, &v38);
      uint64_t v15 = v38;
      if (v38)
      {
        if (*v6)
        {
          int v16 = *v13;
          if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = asString();
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v17;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle changed: %s", buf, 0xCu);
          }
          (*(void (**)(uint64_t))(*(void *)v15 + 864))(v15);
          if (*v6 == 2)
          {
            if (((*(uint64_t (**)(uint64_t))(*(void *)v15 + 152))(v15) & 1) != 0
              || (*(unsigned int (**)(uint64_t))(*(void *)v15 + 528))(v15))
            {
              uint64_t v18 = *v13;
              if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Carrier has changed, and the device is CS or PS attached, sending out the New Serving Network event", buf, 2u);
              }
              uint64_t v36 = v15;
              long long v37 = v39;
              if (v39) {
                atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              RegistrationController::handleNewServingNetwork_sync(a1, &v36);
              uint64_t v19 = (capabilities::ct *)v37;
              if (v37) {
                sub_10004D2C8(v37);
              }
            }
            else
            {
              (*(void (**)(uint64_t))(*(void *)v15 + 392))(v15);
              uint64_t v19 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 400))(v15);
            }
            if (capabilities::ct::supports5G(v19))
            {
              int v22 = *v13;
              if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
              {
                BOOL v23 = v4 + 6;
                if (*((char *)v4 + 71) < 0) {
                  BOOL v23 = (void *)v4[6];
                }
                *(_DWORD *)std::string buf = 136446210;
                *(void *)&uint8_t buf[4] = v23;
                _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle %{public}s changed. Sending down 5G preference with roaming", buf, 0xCu);
              }
              RegistrationController::send5GEnabledSettingFromPreference_sync(a1, v8, 3);
            }
          }
          (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v15 + 664))(buf, v15);
          (*(void (**)(void))(**(void **)buf + 104))(*(void *)buf);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          uint64_t v50 = 0;
          *(_OWORD *)long long __p = 0u;
          long long v49 = 0u;
          long long v46 = 0u;
          long long v47 = 0u;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          *(_OWORD *)std::string buf = 0u;
          long long v41 = 0u;
          uint64_t Model_sync = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 464))(v15);
          if (Model_sync <= 8 && ((1 << Model_sync) & 0x138) != 0)
          {
            uint64_t v24 = *(void *)(a1 + 384);
            (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v15 + 664))(&v34, v15);
            uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 464))(v15);
            (*(void (**)(uint64_t, uint64_t *, uint64_t, uint8_t *))(*(void *)v24 + 16))(v24, &v34, v25, buf);
            uint64_t Model_sync = (uint64_t)v35;
            if (v35) {
              sub_10004D2C8(v35);
            }
          }
          if (BYTE8(v49))
          {
            uint64_t Model_sync = (uint64_t)__p[0];
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
          }
          if (BYTE8(v47)) {
            sub_100058F18((uint64_t)&v46, *((void **)&v46 + 1));
          }
          if ((_BYTE)v42) {
            sub_100058FDC((uint64_t)&buf[8], (void *)v41);
          }
        }
        if (capabilities::ct::supports5G((capabilities::ct *)Model_sync))
        {
          int v26 = (*(uint64_t (**)(uint64_t, void))(*(void *)v15 + 848))(v15, (char)*v6);
          uint64_t v27 = *v13;
          BOOL v28 = os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT);
          if (v26)
          {
            if (v28)
            {
              long long v29 = v4 + 6;
              if (*((char *)v4 + 71) < 0) {
                long long v29 = (void *)v4[6];
              }
              *(_DWORD *)std::string buf = 136446210;
              *(void *)&uint8_t buf[4] = v29;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Re-evaluating 5G Standalone support for %{public}s", buf, 0xCu);
            }
            RegistrationController::send5GStandaloneEnabledSettingFromPreference_sync(a1, v8, 3);
            RegistrationController::update5GSACapabilityRestProperty_sync((capabilities::ct *)a1, v8);
          }
          else if (v28)
          {
            uint64_t v30 = v4 + 6;
            if (*((char *)v4 + 71) < 0) {
              uint64_t v30 = (void *)v4[6];
            }
            *(_DWORD *)std::string buf = 136446210;
            *(void *)&uint8_t buf[4] = v30;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I No change in %{public}s 5G Standalone support", buf, 0xCu);
          }
        }
      }
      else
      {
        uint64_t v20 = *v13;
        if (os_log_type_enabled(*v13, OS_LOG_TYPE_ERROR))
        {
          uint64_t v21 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v21;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Could not find model %s for carrier bundle change", buf, 0xCu);
        }
      }
      if (v39) {
        sub_10004D2C8(v39);
      }
      goto LABEL_64;
    }
  }
}

void sub_100B9B9E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,void *__p,uint64_t a38,uint64_t a39,char a40)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9BA8C(uint64_t a1, uint64_t a2)
{
  if ((rest::operator==() & 1) == 0)
  {
    uint64_t v4 = *(void **)(a1 + 560);
    if (v4 != (void *)(a1 + 568))
    {
      uint64_t v5 = (void *)(a2 + 8);
      while (1)
      {
        (*(void (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v4 + 8));
        uint64_t v6 = *v5;
        uint64_t v7 = *((unsigned int *)v4 + 8);
        if (!*v5) {
          break;
        }
        uint64_t v8 = v5;
        do
        {
          int v9 = *(_DWORD *)(v6 + 32);
          BOOL v10 = v9 < (int)v7;
          if (v9 >= (int)v7) {
            BOOL v11 = (uint64_t *)v6;
          }
          else {
            BOOL v11 = (uint64_t *)(v6 + 8);
          }
          if (!v10) {
            uint64_t v8 = (void *)v6;
          }
          uint64_t v6 = *v11;
        }
        while (*v11);
        if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
          break;
        }
        if ((rest::operator==() & 1) == 0)
        {
          int v12 = 0;
          uint64_t v7 = *((unsigned int *)v4 + 8);
LABEL_15:
          uint64_t v13 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
          int v14 = capabilities::ct::supports5G(v13);
          int v15 = v14;
          if (*((unsigned char *)v4 + 40))
          {
            int v16 = *(NSObject **)v13;
            BOOL v17 = os_log_type_enabled(*(os_log_t *)v13, OS_LOG_TYPE_DEFAULT);
            if (v15)
            {
              if (v17)
              {
                if (*((char *)v4 + 71) >= 0) {
                  uint64_t v18 = (const char *)(v4 + 6);
                }
                else {
                  uint64_t v18 = (const char *)v4[6];
                }
                uint64_t v19 = asString();
                *(_DWORD *)std::string buf = 136446466;
                int v32 = v18;
                __int16 v33 = 2080;
                uint64_t v34 = v19;
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Operator Bundle %{public}s changed: %s. Sending down 5G preference with roaming", buf, 0x16u);
              }
              RegistrationController::send5GEnabledSettingFromPreference_sync(a1, v7, 3);
            }
            else if (v17)
            {
              if (*((char *)v4 + 71) >= 0) {
                BOOL v23 = (const char *)(v4 + 6);
              }
              else {
                BOOL v23 = (const char *)v4[6];
              }
              uint64_t v24 = asString();
              *(_DWORD *)std::string buf = 136446466;
              int v32 = v23;
              __int16 v33 = 2080;
              uint64_t v34 = v24;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Operator Bundle %{public}s changed: %s", buf, 0x16u);
            }
            int v25 = capabilities::ct::supportsGemini((capabilities::ct *)v17);
            if (RegistrationController::carrierBlocksCallsOverCS_sync(a1, v7, 1) || v25)
            {
              int v26 = *(NSObject **)v13;
              if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v27 = "Operator blocks calls over CS";
                if (v25) {
                  uint64_t v27 = "Dual-SIM device";
                }
                *(_DWORD *)std::string buf = 136315138;
                int v32 = v27;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s. Sending LTE setting to BB", buf, 0xCu);
              }
              RegistrationController::sendLteEnabledSettingFromPreference_sync(a1, v7, 1);
            }
          }
          else
          {
            int v20 = v12 & v14;
            uint64_t v21 = *(NSObject **)v13;
            BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
            if (v20 == 1)
            {
              if (v22)
              {
                *(_WORD *)std::string buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Operator Bundle did not change, sending down 5G preference with roaming before bailing out", buf, 2u);
              }
              RegistrationController::send5GEnabledSettingFromPreference_sync(a1, v7, 3);
            }
            else if (v22)
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Operator Bundle did not change, bailing out", buf, 2u);
            }
          }
        }
        BOOL v28 = (void *)v4[1];
        if (v28)
        {
          do
          {
            long long v29 = v28;
            BOOL v28 = (void *)*v28;
          }
          while (v28);
        }
        else
        {
          do
          {
            long long v29 = (void *)v4[2];
            BOOL v30 = *v29 == (void)v4;
            uint64_t v4 = v29;
          }
          while (!v30);
        }
        uint64_t v4 = v29;
        if (v29 == (void *)(a1 + 568)) {
          return;
        }
      }
      int v12 = 1;
      goto LABEL_15;
    }
  }
}

void sub_100B9BE40(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 584);
  if (v2 != a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = "false";
      if (a2) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      if (v2) {
        uint64_t v6 = "true";
      }
      int v8 = 136315394;
      int v9 = v7;
      __int16 v10 = 2080;
      BOOL v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Cellular data setting has changed from %s to %s", (uint8_t *)&v8, 0x16u);
      int v2 = *(unsigned __int8 *)(a1 + 584);
    }
    if (v2) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 376))(a1, 1);
    }
  }
}

void *sub_100B9BF5C(void *result, void *a2)
{
  if (a2[2] == result[90])
  {
    uint64_t v4 = (void *)*a2;
    int v2 = a2 + 1;
    uint64_t v3 = v4;
    if (v4 == v2) {
      return result;
    }
    uint64_t v5 = (void *)result[88];
    while (1)
    {
      BOOL v6 = *((_DWORD *)v3 + 7) == *((_DWORD *)v5 + 7) && *((unsigned __int8 *)v3 + 32) == *((unsigned __int8 *)v5 + 32);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v3[1];
      int v8 = v3;
      if (v7)
      {
        do
        {
          uint64_t v3 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v8[2];
          BOOL v6 = *v3 == (void)v8;
          int v8 = v3;
        }
        while (!v6);
      }
      int v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          __int16 v10 = v9;
          int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          __int16 v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v6);
      }
      uint64_t v5 = v10;
      if (v3 == v2) {
        return result;
      }
    }
  }
  BOOL v11 = (void *)result[8];
  int v12 = result + 9;
  if (v11 != result + 9)
  {
    uint64_t v13 = result + 89;
    do
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        int v15 = *((_DWORD *)v11 + 8);
        int v16 = v13;
        do
        {
          int v17 = *(_DWORD *)(v14 + 28);
          BOOL v18 = v17 < v15;
          if (v17 >= v15) {
            uint64_t v19 = (uint64_t *)v14;
          }
          else {
            uint64_t v19 = (uint64_t *)(v14 + 8);
          }
          if (!v18) {
            int v16 = (void *)v14;
          }
          uint64_t v14 = *v19;
        }
        while (*v19);
        if (v16 != v13 && v15 >= *((_DWORD *)v16 + 7)) {
          uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)v11[5] + 776))(v11[5], *((unsigned __int8 *)v16 + 32));
        }
      }
      int v20 = (void *)v11[1];
      if (v20)
      {
        do
        {
          uint64_t v21 = v20;
          int v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (void *)v11[2];
          BOOL v6 = *v21 == (void)v11;
          BOOL v11 = v21;
        }
        while (!v6);
      }
      BOOL v11 = v21;
    }
    while (v21 != v12);
  }
  return result;
}

void sub_100B9C0E8(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/t911_preferences");
  v4[0] = off_101A42140;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100B9C19C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B9C1C8(uint64_t a1, uint64_t a2)
{
  if (capabilities::ct::supports5G((capabilities::ct *)a1)) {
    uint64_t v4 = *(unsigned int *)(a1 + 816);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *(void *)(a1 + 88);
  int v6 = *(unsigned __int8 *)(a2 + 24);
  int v7 = *(unsigned __int8 *)(a2 + 25);
  if (subscriber::isValidSimSlot())
  {
    uint64_t v8 = *(unsigned int *)(a1 + 936);
  }
  else
  {
    int v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Defaulting data preferred sub to sim#1, since the data SIM preference is invalid", v13, 2u);
    }
    uint64_t v8 = 1;
  }
  uint64_t v10 = *(unsigned __int8 *)(a1 + 1344);
  BOOL v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, BOOL, BOOL, uint64_t, uint64_t))(*(void *)v5 + 208);

  return v11(v5, v4, a2, v6 != 0, v7 != 0, v8, v10);
}

uint64_t sub_100B9C2D8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 216))();
}

void sub_100B9C300(uint64_t a1, int a2)
{
  uint64_t v8 = 0;
  int v9 = 0;
  RegistrationController::getModel_sync(a1, a2, &v8);
  uint64_t v3 = v8;
  if (!v8)
  {
    uint64_t v4 = v9;
    if (!v9) {
      return;
    }
    goto LABEL_7;
  }
  uint64_t v4 = v9;
  uint64_t v6 = v8;
  int v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 64))(v3);
  RegistrationController::setRegistrationStatus_sync(a1, &v6, v5, 0);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v4) {
LABEL_7:
  }
    sub_10004D2C8(v4);
}

void sub_100B9C3B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9C3D4(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 1072) != *(_DWORD *)a2 || *(unsigned __int8 *)(a1 + 1076) != *(unsigned __int8 *)(a2 + 4))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 1076)) {
        uint64_t v4 = "True";
      }
      else {
        uint64_t v4 = "False";
      }
      int v11 = 136315138;
      int v12 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I enabled 5G by MDM changed to %s", (uint8_t *)&v11, 0xCu);
    }
    uint64_t v5 = *(void **)(a1 + 64);
    if (v5 != (void *)(a1 + 72))
    {
      do
      {
        if ((*(unsigned int (**)(void, uint64_t))(*(void *)v5[5] + 824))(v5[5], a1 + 1072))
        {
          RegistrationController::send5GStandaloneEnabledSettingFromPreference_sync(a1, *((unsigned int *)v5 + 8), 3);
          uint64_t v6 = *(void *)(a1 + 328);
          uint64_t v7 = *((unsigned int *)v5 + 8);
          RegistrationController::getNRStatus_sync(a1, *((_DWORD *)v5 + 8), (NRStatus *)&v11);
          (*(void (**)(uint64_t, uint64_t, int *))(*(void *)v6 + 144))(v6, v7, &v11);
          RegistrationController::update5GSACapabilityRestProperty_sync((capabilities::ct *)a1, *((unsigned int *)v5 + 8));
        }
        uint64_t v8 = (void *)v5[1];
        if (v8)
        {
          do
          {
            int v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            int v9 = (void *)v5[2];
            BOOL v10 = *v9 == (void)v5;
            uint64_t v5 = v9;
          }
          while (!v10);
        }
        uint64_t v5 = v9;
      }
      while (v9 != (void *)(a1 + 72));
    }
  }
}

void sub_100B9C5A4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Baseband refresh complete received. Trigger sending of IMS states", v5, 2u);
  }
  RegistrationController::sendVolteEnabledSettingToBaseband_sync(a1, a2);
}

void sub_100B9C648(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 1264))
  {
    uint64_t v4 = (unsigned __int8 *)(a2 + 1);
    uint64_t v5 = (unsigned __int8 *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v6 = *(unsigned __int8 **)(a1 + 1248);
    while (sub_10001D294(v5 + 32, v6 + 32) && sub_1003B27B4((uint64_t)(v5 + 56), (uint64_t)(v6 + 56)))
    {
      uint64_t v7 = (unsigned __int8 *)*((void *)v5 + 1);
      uint64_t v8 = v5;
      if (v7)
      {
        do
        {
          uint64_t v5 = v7;
          uint64_t v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v5 = (unsigned __int8 *)*((void *)v8 + 2);
          BOOL v9 = *(void *)v5 == (void)v8;
          uint64_t v8 = v5;
        }
        while (!v9);
      }
      BOOL v10 = (unsigned __int8 *)*((void *)v6 + 1);
      if (v10)
      {
        do
        {
          int v11 = v10;
          BOOL v10 = *(unsigned __int8 **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v11 = (unsigned __int8 *)*((void *)v6 + 2);
          BOOL v9 = *(void *)v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v9);
      }
      uint64_t v6 = v11;
      if (v5 == v4) {
        return;
      }
    }
  }
  int v12 = *(void ***)(a1 + 1248);
  if (v12 != (void **)(a1 + 1256))
  {
    do
    {
      uint64_t v13 = sub_100046F68((uint64_t)a2, v12 + 4);
      if (a2 + 1 == v13 || (sub_1003B27B4((uint64_t)(v13 + 7), (uint64_t)(v12 + 7)) & 1) == 0)
      {
        uint64_t v14 = SlotIdFromPersonalityId();
        int v15 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
        uint64_t v26 = 0;
        uint64_t v27 = 0;
        RegistrationController::getModel_sync(a1, v14, &v26);
        if (v26)
        {
          int v16 = (char *)v12[9];
          if (v16)
          {
            int v17 = (int *)(v12 + 9);
            do
            {
              int v18 = *((_DWORD *)v16 + 7);
              BOOL v19 = v18 < 15;
              if (v18 >= 15) {
                int v20 = (char **)v16;
              }
              else {
                int v20 = (char **)(v16 + 8);
              }
              if (!v19) {
                int v17 = (int *)v16;
              }
              int v16 = *v20;
            }
            while (*v20);
            if (v17 != (int *)(v12 + 9)
              && v17[7] <= 15
              && (v17[8] - 1) < 2
              && (*(unsigned int (**)(void))(*(void *)v26 + 880))())
            {
              uint64_t v21 = *v15;
              if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)int v25 = 0;
                _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I 5G Standalone changed due to entitlements. Sending 5G Standalone user setting to baseband", v25, 2u);
              }
              RegistrationController::send5GStandaloneEnabledSettingFromPreference_sync(a1, v14, 3);
              uint64_t v22 = *(void *)(a1 + 328);
              RegistrationController::getNRStatus_sync(a1, v14, (NRStatus *)v25);
              (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v22 + 144))(v22, v14, v25);
              RegistrationController::update5GSACapabilityRestProperty_sync((capabilities::ct *)a1, v14);
            }
          }
        }
        if (v27) {
          sub_10004D2C8(v27);
        }
      }
      BOOL v23 = (void **)v12[1];
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          BOOL v23 = (void **)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          uint64_t v24 = (void **)v12[2];
          BOOL v9 = *v24 == v12;
          int v12 = v24;
        }
        while (!v9);
      }
      int v12 = v24;
    }
    while (v24 != (void **)(a1 + 1256));
  }
}

void sub_100B9C94C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9C968(void *a1, void *a2)
{
  if (a2[2] == a1[161])
  {
    uint64_t v4 = a2 + 1;
    uint64_t v5 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v6 = (void *)a1[159];
    while (*((_DWORD *)v5 + 7) == *((_DWORD *)v6 + 7) && rest::operator==())
    {
      uint64_t v7 = (void *)v5[1];
      uint64_t v8 = v5;
      if (v7)
      {
        do
        {
          uint64_t v5 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v8[2];
          BOOL v9 = *v5 == (void)v8;
          uint64_t v8 = v5;
        }
        while (!v9);
      }
      BOOL v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          int v11 = v10;
          BOOL v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v9);
      }
      uint64_t v6 = v11;
      if (v5 == v4) {
        return;
      }
    }
  }
  int v12 = (void *)a1[159];
  if (v12 != a1 + 160)
  {
    uint64_t v13 = a2 + 1;
    do
    {
      uint64_t v14 = *v13;
      uint64_t v15 = *((unsigned int *)v12 + 7);
      if (!*v13) {
        goto LABEL_30;
      }
      int v16 = a2 + 1;
      do
      {
        int v17 = *(_DWORD *)(v14 + 28);
        BOOL v18 = v17 < (int)v15;
        if (v17 >= (int)v15) {
          BOOL v19 = (uint64_t *)v14;
        }
        else {
          BOOL v19 = (uint64_t *)(v14 + 8);
        }
        if (!v18) {
          int v16 = (uint64_t *)v14;
        }
        uint64_t v14 = *v19;
      }
      while (*v19);
      if (v16 != v13 && (int)v15 >= *((_DWORD *)v16 + 7))
      {
        if (rest::operator==()) {
          goto LABEL_32;
        }
        uint64_t v15 = *((unsigned int *)v12 + 7);
        uint64_t v21 = (uint64_t)a1;
        uint64_t v20 = (uint64_t)(v12 + 4);
      }
      else
      {
LABEL_30:
        uint64_t v20 = (uint64_t)(v12 + 4);
        uint64_t v21 = (uint64_t)a1;
      }
      sub_100BA360C(v21, v15, v20);
LABEL_32:
      uint64_t v22 = (void *)v12[1];
      if (v22)
      {
        do
        {
          BOOL v23 = v22;
          uint64_t v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          BOOL v23 = (void *)v12[2];
          BOOL v9 = *v23 == (void)v12;
          int v12 = v23;
        }
        while (!v9);
      }
      int v12 = v23;
    }
    while (v23 != a1 + 160);
  }
}

void sub_100B9CB0C(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 1312))
  {
    uint64_t v3 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v4 = *(void **)(a1 + 1296);
    uint64_t v5 = v4;
    while (1)
    {
      BOOL v6 = *((_DWORD *)v3 + 7) == *((_DWORD *)v5 + 7) && *((unsigned __int8 *)v3 + 32) == *((unsigned __int8 *)v5 + 32);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v3[1];
      uint64_t v8 = v3;
      if (v7)
      {
        do
        {
          uint64_t v3 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v8[2];
          BOOL v6 = *v3 == (void)v8;
          uint64_t v8 = v3;
        }
        while (!v6);
      }
      BOOL v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v6);
      }
      uint64_t v5 = v10;
      if (v3 == a2 + 1) {
        return;
      }
    }
  }
  else
  {
    uint64_t v4 = *(void **)(a1 + 1296);
  }
  int v11 = (void *)(a1 + 1304);
  if (v4 != (void *)(a1 + 1304))
  {
    int v12 = a2 + 1;
    while (1)
    {
      uint64_t v13 = *v12;
      int v14 = *((_DWORD *)v4 + 7);
      if (!*v12) {
        break;
      }
      uint64_t v15 = v12;
      do
      {
        int v16 = *(_DWORD *)(v13 + 28);
        BOOL v17 = v16 < v14;
        if (v16 >= v14) {
          BOOL v18 = (uint64_t *)v13;
        }
        else {
          BOOL v18 = (uint64_t *)(v13 + 8);
        }
        if (!v17) {
          uint64_t v15 = (void *)v13;
        }
        uint64_t v13 = *v18;
      }
      while (*v18);
      if (v15 == v12 || v14 < *((_DWORD *)v15 + 7)) {
        break;
      }
      if (*((unsigned __int8 *)v15 + 32) != *((unsigned __int8 *)v4 + 32))
      {
        uint64_t v21 = 0;
        uint64_t v22 = 0;
        RegistrationController::getModel_sync(a1, v14, &v21);
        if (v21) {
LABEL_35:
        }
          (*(void (**)(void))(*(void *)v21 + 896))();
LABEL_36:
        if (v22) {
          sub_10004D2C8(v22);
        }
      }
      BOOL v19 = (void *)v4[1];
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          BOOL v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (void *)v4[2];
          BOOL v6 = *v20 == (void)v4;
          uint64_t v4 = v20;
        }
        while (!v6);
      }
      uint64_t v4 = v20;
      if (v20 == v11) {
        return;
      }
    }
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    RegistrationController::getModel_sync(a1, v14, &v21);
    if (v21) {
      goto LABEL_35;
    }
    goto LABEL_36;
  }
}

void sub_100B9CD40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9CD5C(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 1336))
  {
    uint64_t v4 = a2 + 1;
    uint64_t v5 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    BOOL v6 = *(void **)(a1 + 1320);
    while (*((_DWORD *)v5 + 7) == *((_DWORD *)v6 + 7) && rest::operator==())
    {
      uint64_t v7 = (void *)v5[1];
      uint64_t v8 = v5;
      if (v7)
      {
        do
        {
          uint64_t v5 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v8[2];
          BOOL v9 = *v5 == (void)v8;
          uint64_t v8 = v5;
        }
        while (!v9);
      }
      BOOL v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          int v11 = v10;
          BOOL v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          BOOL v6 = v11;
        }
        while (!v9);
      }
      BOOL v6 = v11;
      if (v5 == v4) {
        return;
      }
    }
  }
  int v12 = *(void **)(a1 + 1320);
  if (v12 != (void *)(a1 + 1328))
  {
    uint64_t v13 = a2 + 1;
    while (1)
    {
      uint64_t v14 = *v13;
      int v15 = *((_DWORD *)v12 + 7);
      if (!*v13) {
        break;
      }
      int v16 = a2 + 1;
      do
      {
        int v17 = *(_DWORD *)(v14 + 28);
        BOOL v18 = v17 < v15;
        if (v17 >= v15) {
          BOOL v19 = (uint64_t *)v14;
        }
        else {
          BOOL v19 = (uint64_t *)(v14 + 8);
        }
        if (!v18) {
          int v16 = (uint64_t *)v14;
        }
        uint64_t v14 = *v19;
      }
      while (*v19);
      if (v16 == v13 || v15 < *((_DWORD *)v16 + 7)) {
        break;
      }
      if ((rest::operator==() & 1) == 0)
      {
        int v23 = *((_DWORD *)v12 + 7);
        uint64_t v24 = 0;
        int v25 = 0;
        RegistrationController::getModel_sync(a1, v23, &v24);
        uint64_t v20 = v24;
        if (v24) {
LABEL_31:
        }
          (*(void (**)(uint64_t, void *))(*(void *)v24 + 904))(v20, v12 + 4);
LABEL_32:
        if (v25) {
          sub_10004D2C8(v25);
        }
      }
      uint64_t v21 = (void *)v12[1];
      if (v21)
      {
        do
        {
          uint64_t v22 = v21;
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          uint64_t v22 = (void *)v12[2];
          BOOL v9 = *v22 == (void)v12;
          int v12 = v22;
        }
        while (!v9);
      }
      int v12 = v22;
      if (v22 == (void *)(a1 + 1328)) {
        return;
      }
    }
    uint64_t v24 = 0;
    int v25 = 0;
    RegistrationController::getModel_sync(a1, v15, &v24);
    uint64_t v20 = v24;
    if (v24) {
      goto LABEL_31;
    }
    goto LABEL_32;
  }
}

void sub_100B9CF90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::handleECBMTimerExpired(RegistrationController *this)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100B9D0B8;
  v3[3] = &unk_101A41510;
  v3[4] = this;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_10003E168(&v6, (void *)this + 1);
  int v2 = *((void *)this + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059514;
  block[3] = &unk_101A42968;
  block[5] = v6;
  uint64_t v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100B9D0B8(uint64_t a1)
{
  uint64_t v1 = *(RegistrationController **)(a1 + 32);
  int v2 = *((void *)v1 + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ECBM Timer expired, exit ECBM mode", v3, 2u);
  }
  RegistrationController::setECBM_sync(v1, 0);
}

BOOL RegistrationController::carrierBlocksCallsOverCS_sync(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (a3)
  {
    uint64_t v7 = *(void *)(a1 + 1032);
    if (v7)
    {
      uint64_t v8 = a1 + 1032;
      uint64_t v9 = a1 + 1032;
      do
      {
        int v10 = *(_DWORD *)(v7 + 28);
        BOOL v11 = v10 < a2;
        if (v10 >= a2) {
          int v12 = (uint64_t *)v7;
        }
        else {
          int v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          uint64_t v9 = v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      goto LABEL_19;
    }
LABEL_21:
    BOOL v17 = 0;
    goto LABEL_22;
  }
  uint64_t v13 = *(void *)(a1 + 1008);
  if (!v13) {
    goto LABEL_21;
  }
  uint64_t v8 = a1 + 1008;
  uint64_t v9 = a1 + 1008;
  do
  {
    int v14 = *(_DWORD *)(v13 + 28);
    BOOL v15 = v14 < a2;
    if (v14 >= a2) {
      int v16 = (uint64_t *)v13;
    }
    else {
      int v16 = (uint64_t *)(v13 + 8);
    }
    if (!v15) {
      uint64_t v9 = v13;
    }
    uint64_t v13 = *v16;
  }
  while (*v16);
LABEL_19:
  if (v9 == v8 || *(_DWORD *)(v9 + 28) > a2) {
    goto LABEL_21;
  }
  BOOL v17 = *(unsigned __int8 *)(v9 + 32) != 0;
LABEL_22:
  BOOL v18 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      BOOL v19 = "Operator";
    }
    else {
      BOOL v19 = "Carrier";
    }
    int v21 = 136315394;
    uint64_t v22 = v19;
    __int16 v23 = 2080;
    uint64_t v24 = asStringBool(v17);
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %sBlocksCallsOverCS: %s", (uint8_t *)&v21, 0x16u);
  }
  return v17;
}

void RegistrationController::handleCellularFallback_sync(RegistrationController *this, uint64_t a2)
{
  int v11 = 1;
  uint64_t v4 = sub_1000FD774((uint64_t)this + 64, &v11);
  uint64_t v6 = *v4;
  uint64_t v5 = (std::__shared_weak_count *)v4[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 280))(v6) != a2)
  {
    uint64_t v7 = *((void *)this + 5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 280))(v6);
      uint64_t v9 = "false";
      if (v8) {
        int v10 = "true";
      }
      else {
        int v10 = "false";
      }
      if (a2) {
        uint64_t v9 = "true";
      }
      int v11 = 136315394;
      int v12 = v10;
      __int16 v13 = 2080;
      int v14 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Cellular fallback changed from %s to %s", (uint8_t *)&v11, 0x16u);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 288))(v6, a2);
    (*(void (**)(uint64_t))(*(void *)v6 + 352))(v6);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_100B9D488(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B9D4AC(void *a1)
{
  *a1 = off_101A41540;
  int v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B9D4F8(void *a1)
{
  *a1 = off_101A41540;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

__n128 sub_100B9D564(uint64_t a1)
{
  int v2 = (char *)operator new(0x38uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)int v2 = off_101A41540;
  *((void *)v2 + 1) = v3;
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 32);
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  *((void *)v2 + 4) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 sub_100B9D5D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41540;
  uint64_t v2 = *(void *)(a1 + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(void *)(a2 + 32) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

void sub_100B9D624(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B9D634(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100B9D674(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      int v8 = v7;
      if (*(void *)(a1 + 24))
      {
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 1174405120;
        dispatch_object_t v10[2] = sub_100B9D87C;
        _OWORD v10[3] = &unk_101A415A0;
        v10[4] = v6;
        long long v11 = *(_OWORD *)(a1 + 40);
        int v15 = *(_DWORD *)(a1 + 16);
        __int16 v13 = 0;
        uint64_t v14 = 0;
        long long __p = 0;
        sub_1003A10E0(&__p, v3, v4, (v4 - (uint64_t)v3) >> 1);
        uint64_t v18 = 0;
        BOOL v19 = 0;
        sub_10003E168(&v18, (void *)(v6 + 8));
        uint64_t v9 = *(NSObject **)(v6 + 24);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100059514;
        block[3] = &unk_101A42968;
        block[5] = v18;
        BOOL v17 = v19;
        if (v19) {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        block[4] = v10;
        dispatch_async(v9, block);
        if (v17) {
          sub_10004D2C8(v17);
        }
        if (v19) {
          sub_10004D2C8(v19);
        }
        if (__p)
        {
          __int16 v13 = __p;
          operator delete(__p);
        }
      }
      sub_10004D2C8(v8);
    }
  }
  if (v3) {
    operator delete(v3);
  }
}

void sub_100B9D810(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B9D830(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9D870()
{
}

void sub_100B9D87C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(v2 + 136));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (!v9)
  {
    std::mutex::unlock(v4);
    goto LABEL_9;
  }
  uint64_t v11 = v9[3];
  int v10 = (std::__shared_weak_count *)v9[4];
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v4);
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
    if (!v11)
    {
      BOOL v19 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "File a radar! Could not get CDMA roaming handler", buf, 2u);
      }
      goto LABEL_25;
    }
    int v12 = *(_DWORD *)(a1 + 80);
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_13;
  }
  std::mutex::unlock(v4);
  if (!v11)
  {
LABEL_9:
    __int16 v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "File a radar! Could not get CDMA roaming handler", buf, 2u);
    }
    return;
  }
  int v12 = *(_DWORD *)(a1 + 80);
LABEL_13:
  uint64_t v20 = 0;
  int v21 = 0;
  uint64_t v22 = 0;
  sub_1003A10E0(&v20, *(const void **)(a1 + 56), *(void *)(a1 + 64), (uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 1);
  *(void *)std::string buf = *(void *)(a1 + 40);
  int v24 = v12;
  sub_10003E168(&v29, (void *)(*(void *)buf + 8));
  uint64_t v14 = v30;
  v25[0] = v29;
  v25[1] = v30;
  if (v30)
  {
    atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v14);
  }
  __p[1] = 0;
  uint64_t v27 = 0;
  __p[0] = 0;
  sub_1003A10E0(__p, v20, (uint64_t)v21, (v21 - (unsigned char *)v20) >> 1);
  char v15 = *(unsigned char *)(a1 + 48);
  char v28 = v15;
  uint64_t v31 = 0;
  int v16 = (char *)operator new(0x48uLL);
  long long v17 = *(_OWORD *)__p;
  *(_OWORD *)(v16 + 24) = *(_OWORD *)v25;
  uint64_t v18 = *(void *)buf;
  *(void *)int v16 = off_101A415E0;
  *((void *)v16 + 1) = v18;
  *((_DWORD *)v16 + 4) = v24;
  v25[0] = 0;
  v25[1] = 0;
  *(_OWORD *)(v16 + 40) = v17;
  *((void *)v16 + 7) = v27;
  __p[1] = 0;
  uint64_t v27 = 0;
  __p[0] = 0;
  v16[64] = v15;
  uint64_t v31 = v16;
  (*(void (**)(uint64_t, std::__shared_weak_count **))(*(void *)v11 + 24))(v11, &v29);
  sub_100B9E2B4(&v29);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v25[1]) {
    std::__shared_weak_count::__release_weak(v25[1]);
  }
  if (v20)
  {
    int v21 = v20;
    operator delete(v20);
  }
  if (v10)
  {
    sub_10004D2C8(v10);
LABEL_25:
    sub_10004D2C8(v10);
  }
}

void sub_100B9DB68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  sub_100B9E2B4(&a22);
  sub_100B9DC1C(&a13);
  if (__p) {
    operator delete(__p);
  }
  if (v22)
  {
    sub_10004D2C8(v22);
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

void *sub_100B9DBE8(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  uint64_t v2 = (void *)(a1 + 56);
  v2[2] = 0;
  return sub_1003A10E0(v2, *(const void **)(a2 + 56), *(void *)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 1);
}

void sub_100B9DC04(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
}

void *sub_100B9DC1C(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void *sub_100B9DC5C(void *a1)
{
  *a1 = off_101A415E0;
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B9DCB8(void *a1)
{
  *a1 = off_101A415E0;
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_100B9DD34(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A415E0;
  sub_100B9DFE4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B9DD88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B9DD9C(uint64_t a1, void *a2)
{
  *a2 = off_101A415E0;
  return sub_100B9DFE4((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_100B9DDC8(uint64_t a1)
{
}

void sub_100B9DDD0(void *a1)
{
  sub_100B9E070(a1 + 1);

  operator delete(a1);
}

void sub_100B9DE0C(uint64_t a1, int *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (*(void *)(a1 + 24))
      {
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 1174405120;
        dispatch_object_t v10[2] = sub_100B9E0C4;
        _OWORD v10[3] = &unk_101A41650;
        int v8 = *(_DWORD *)(a1 + 16);
        int v14 = v4;
        int v15 = v8;
        v10[4] = v5;
        long long __p = 0;
        int v12 = 0;
        uint64_t v13 = 0;
        sub_1003A10E0(&__p, *(const void **)(a1 + 40), *(void *)(a1 + 48), (uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 1);
        char v16 = *(unsigned char *)(a1 + 64);
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        sub_10003E168(&v19, (void *)(v5 + 8));
        uint64_t v9 = *(NSObject **)(v5 + 24);
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100059514;
        block[3] = &unk_101A42968;
        block[5] = v19;
        uint64_t v18 = v20;
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        block[4] = v10;
        dispatch_async(v9, block);
        if (v18) {
          sub_10004D2C8(v18);
        }
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (__p)
        {
          int v12 = __p;
          operator delete(__p);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100B9DF84(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B9DF98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9DFD8()
{
}

uint64_t sub_100B9DFE4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a1 = v4;
  uint64_t v5 = a2[3];
  *(void *)(a1 + 16) = a2[2];
  *(void *)(a1 + 24) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_1003A10E0((void *)(a1 + 32), (const void *)a2[4], a2[5], (a2[5] - a2[4]) >> 1);
  *(unsigned char *)(a1 + 56) = *((unsigned char *)a2 + 56);
  return a1;
}

void sub_100B9E058(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B9E070(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100B9E0C4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315138;
    uint64_t v8 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I CDMA International Roaming is %s", (uint8_t *)&v7, 0xCu);
  }
  int v4 = *(_DWORD *)(a1 + 64);
  if ((v4 - 1) <= 1) {
    (*(void (**)(void, void, BOOL, uint64_t))(**(void **)(v2 + 88) + 88))(*(void *)(v2 + 88), *(unsigned int *)(a1 + 68), v4 == 1, a1 + 40);
  }
  if (*(unsigned char *)(v2 + 376) && *(unsigned char *)(a1 + 72)) {
    RegistrationController::sendEnableOnlyHomeNetwork_sync((RegistrationController *)v2);
  }
  uint64_t v5 = *(void *)(v2 + 232);
  uint64_t v6 = *(NSObject **)(v2 + 40);
  if (v5)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Baseband activated, initiating network attach", (uint8_t *)&v7, 2u);
      uint64_t v5 = *(void *)(v2 + 232);
    }
    (*(void (**)(uint64_t))(*(void *)v5 + 120))(v5);
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v7) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "File a radar! No network list controller to bring baseband online!", (uint8_t *)&v7, 2u);
  }
}

void *sub_100B9E280(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v2 = (void *)(a1 + 40);
  v2[2] = 0;
  return sub_1003A10E0(v2, *(const void **)(a2 + 40), *(void *)(a2 + 48), (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 1);
}

void sub_100B9E29C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void *sub_100B9E2B4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100B9E338(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void sub_100B9E384(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 16), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_100B9E4F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100163BC8((uint64_t)va);
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 8))(a3);
  }
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(a1);
}

void *sub_100B9E560(void *a1)
{
  *a1 = off_101A416D0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B9E5AC(void *a1)
{
  *a1 = off_101A416D0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100B9E618(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100B9E6C8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B9E6E0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100B9E700()
{
}

void *sub_100B9E76C(void *a1)
{
  *a1 = off_101A41720;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100B9E7B8(void *a1)
{
  *a1 = off_101A41720;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100B9E824()
{
}

void sub_100B9E894()
{
}

__n128 sub_100B9E8A8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A41760;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B9E8FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41760;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B9E934(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  uint64_t v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_100B9EA18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9EA58()
{
}

uint64_t sub_100B9EA64(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100B9EAB0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100B9EAFC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void sub_100B9EB4C()
{
}

__n128 sub_100B9EB60(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A41840;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B9EBB4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41840;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B9EBEC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100B9EC34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9EC74()
{
}

void sub_100B9EC84()
{
}

__n128 sub_100B9EC98(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A418C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B9ECEC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A418C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B9ED24(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  uint64_t v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_100B9EE08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9EE48()
{
}

void sub_100B9EE58()
{
}

__n128 sub_100B9EE6C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A41940;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B9EEC0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41940;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B9EEF8(void *a1, xpc_object_t *a2)
{
  int v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  int v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100B9EFF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9F030()
{
}

void sub_100B9F040()
{
}

__n128 sub_100B9F054(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A419C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B9F0A8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A419C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B9F0E0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  int v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10096DD7C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100B9F1A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100B9F1B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9F1F8()
{
}

void sub_100B9F208()
{
}

__n128 sub_100B9F21C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A41A40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B9F270(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41A40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B9F2A8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  int v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10031571C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100B9F368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100B9F380(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9F3C0()
{
}

void sub_100B9F3D0()
{
}

__n128 sub_100B9F3E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A41AC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B9F438(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41AC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B9F470(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  uint64_t v16 = 0;
  long long v17 = 0uLL;
  sub_1001F299C(&v16, a2);
  uint64_t v4 = *v3;
  int v15 = *((_DWORD *)v3 + 2);
  uint64_t v14 = v4;
  uint64_t v12 = v16;
  long long v13 = v17;
  uint64_t v16 = 0;
  long long v17 = 0uLL;
  if (v12 != (void)v13)
  {
    uint64_t v5 = *(void **)(v13 - 8);
    xpc_object_t v21 = v5;
    if (v5) {
      xpc_retain(v5);
    }
    else {
      xpc_object_t v21 = xpc_null_create();
    }
    uint64_t v18 = &v21;
    uint64_t v19 = "kCallSubType";
    sub_100048BAC((uint64_t)&v18, &v20);
    *(unsigned char *)uint64_t v3 = xpc::dyn_cast_or_default((xpc *)&v20, (const object *)1, v6);
    xpc_release(v20);
    uint64_t v18 = &v21;
    uint64_t v19 = "kCallSimSlot";
    sub_100048BAC((uint64_t)&v18, &v20);
    *((_DWORD *)v3 + 1) = xpc::dyn_cast_or_default((xpc *)&v20, (const object *)1, v7);
    xpc_release(v20);
    uint64_t v18 = &v21;
    uint64_t v19 = "kCallType";
    sub_100048BAC((uint64_t)&v18, &v20);
    *((_DWORD *)v3 + 2) = xpc::dyn_cast_or_default((xpc *)&v20, (const object *)1, v8);
    xpc_release(v20);
    xpc_release(v21);
  }
  uint64_t v18 = (void **)&v12;
  sub_1001F1FAC(&v18);
  if (LastCallSubType::operator!=())
  {
    uint64_t v9 = (void (*)(void *, uint64_t *))a1[3];
    uint64_t v10 = a1[4];
    uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
    if (v10) {
      uint64_t v9 = *(void (**)(void *, uint64_t *))(*v11 + v9);
    }
    v9(v11, &v14);
  }
  uint64_t v18 = (void **)&v16;
  sub_1001F1FAC(&v18);
}

void sub_100B9F624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  xpc_release(*(xpc_object_t *)(v14 - 32));
  xpc_release(*(xpc_object_t *)(v14 - 24));
  *(void *)(v14 - 48) = &a9;
  sub_1001F1FAC((void ***)(v14 - 48));
  *(void *)(v14 - 48) = &a14;
  sub_1001F1FAC((void ***)(v14 - 48));
  _Unwind_Resume(a1);
}

uint64_t sub_100B9F6B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9F6F8()
{
}

void sub_100B9F708()
{
}

__n128 sub_100B9F71C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A41B40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B9F770(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41B40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B9F7A8(void *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  *a3 = 0;
  a3[1] = 0;
  long long v17 = 0u;
  memset(v18, 0, sizeof(v18));
  *(_OWORD *)long long __p = 0u;
  read_rest_value();
  uint64_t v6 = (void (*)(void *, void **, unsigned char *))a1[2];
  uint64_t v7 = a1[3];
  uint64_t v8 = (void *)(a1[1] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void **, unsigned char *))(*v8 + v6);
  }
  v9[0] = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v10 = 0;
  int v13 = 0;
  uint64_t v14 = v5;
  uint64_t v15 = v4;
  v6(v8, __p, v9);
  sub_100B9F968((uint64_t)v9);
  sub_100021FF4((uint64_t)v18);
  if (SBYTE7(v17) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100B9F888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_100B9F968((uint64_t)&a10);
  sub_100021FF4(v22);
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B9F8E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9F920()
{
}

uint64_t sub_100B9F92C(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100B9F968(uint64_t a1)
{
  if (*(void *)(a1 + 40))
  {
    write_rest_value();
    uint64_t v2 = *(void ***)(a1 + 40);
    uint64_t v3 = *v2;
    *uint64_t v2 = v6;
    xpc_release(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100B9F9EC()
{
}

__n128 sub_100B9FA00(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A41BC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B9FA54(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41BC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B9FA8C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100169118((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100B9FB4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100B9FB64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9FBA4()
{
}

void sub_100B9FBB4()
{
}

__n128 sub_100B9FBC8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A41C40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B9FC1C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41C40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B9FC54(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1002430C8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100B9FD14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100B9FD2C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9FD6C()
{
}

void sub_100B9FD7C()
{
}

__n128 sub_100B9FD90(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A41CC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B9FDE4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41CC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B9FE1C(void *a1, void **a2)
{
  uint64_t v7 = 0;
  sub_1000271F8((int *)&v7, a2);
  uint64_t v3 = (uint64_t (*)(void *, uint64_t *))a1[2];
  uint64_t v4 = a1[3];
  uint64_t v5 = (void *)(a1[1] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t *))(*v5 + v3);
  }
  return v3(v5, &v7);
}

uint64_t sub_100B9FE9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B9FEDC()
{
}

void sub_100B9FEEC()
{
}

__n128 sub_100B9FF00(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A41D40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B9FF54(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41D40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B9FF8C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100256368((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100BA004C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100BA0064(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA00A4()
{
}

void sub_100BA00B4()
{
}

__n128 sub_100BA00C8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A41DC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA011C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41DC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BA0154(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  long long v7 = *(_OWORD *)v3;
  uint64_t v8 = v3[2];
  *uint64_t v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  sub_100089CF0(v3, a2);
  uint64_t v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  uint64_t v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  uint64_t v9 = (void **)&v7;
  sub_10008A88C(&v9);
}

void sub_100BA01F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100BA0214(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA0254()
{
}

void sub_100BA0264()
{
}

__n128 sub_100BA0278(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A41E40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100BA02CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41E40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BA0304(void *a1, void **a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  *a3 = 0;
  a3[1] = 0;
  uint64_t v14 = 0;
  RatSelectionType::RatSelectionType((RatSelectionType *)&v14);
  sub_10014EC78((RatSelectionType *)&v14, a2);
  long long v7 = (void (*)(void *, uint64_t *, unsigned char *))a1[2];
  uint64_t v8 = a1[3];
  uint64_t v9 = (void *)(a1[1] + (v8 >> 1));
  if (v8) {
    long long v7 = *(void (**)(void *, uint64_t *, unsigned char *))(*v9 + v7);
  }
  v11[0] = 0;
  uint64_t v12 = v6;
  uint64_t v13 = v5;
  v7(v9, &v14, v11);
  return sub_1001F2378((uint64_t)v11);
}

void sub_100BA03B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100BA03E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA0420()
{
}

void sub_100BA0430()
{
}

__n128 sub_100BA0444(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A41EC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA0498(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41EC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BA04D0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100BA0590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100BA05A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA05E8()
{
}

void sub_100BA05F8()
{
}

__n128 sub_100BA060C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A41F40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA0660(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41F40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BA0698(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100BA0758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100BA0770(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA07B0()
{
}

void sub_100BA07C0()
{
}

__n128 sub_100BA07D4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A41FC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA0828(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A41FC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BA0860(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100BA08FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA093C()
{
}

void sub_100BA094C()
{
}

__n128 sub_100BA0960(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A42040;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA09B4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A42040;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BA09EC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10031B0B4((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100BA0AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100BA0AC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA0B04()
{
}

void sub_100BA0B14()
{
}

__n128 sub_100BA0B28(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A420C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA0B7C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A420C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BA0BB4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1001A789C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10019D5B8((uint64_t)&v9, v10);
}

void sub_100BA0C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100BA0C8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA0CCC()
{
}

void sub_100BA0CDC()
{
}

void *sub_100BA0CF0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A42140;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA0D38(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A42140;
  a2[1] = v2;
  return result;
}

uint64_t sub_100BA0D64(uint64_t a1)
{
  return read_rest_value(*(void *)(a1 + 8));
}

uint64_t sub_100BA0D6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA0DAC()
{
}

void sub_100BA0DBC()
{
}

__n128 sub_100BA0DD0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A421C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100BA0E24(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A421C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BA0E5C(void *a1)
{
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  read_rest_value();
  uint64_t v2 = (void (*)(void *, void **))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, void **))(*v4 + v2);
  }
  v2(v4, __p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_100BA0EF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BA0F0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA0F4C()
{
}

void sub_100BA0F5C()
{
}

__n128 sub_100BA0F70(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A42240;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100BA0FC4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A42240;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BA0FFC(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  uint64_t v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_100BA10E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA1120()
{
}

void sub_100BA1130()
{
}

__n128 sub_100BA1144(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A422C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100BA1198(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A422C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BA11D0(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  uint64_t v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_100BA12B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA12F4()
{
}

void sub_100BA1304()
{
}

__n128 sub_100BA1318(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A42340;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA136C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A42340;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BA13A4(uint64_t a1)
{
  uint64_t v6 = **(void **)(a1 + 8);
  rest::read_rest_value();
  uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = (void *)(*(void *)(a1 + 16) + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_100BA1428(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA1468()
{
}

void sub_100BA1478()
{
}

__n128 sub_100BA148C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A423C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100BA14E0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A423C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BA1518(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v6 + v4);
  }
  return v4(v6, a3, a4);
}

uint64_t sub_100BA1568(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA15A8()
{
}

void sub_100BA15B8()
{
}

void *sub_100BA15CC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A42440;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA1614(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A42440;
  a2[1] = v2;
  return result;
}

void sub_100BA1640(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v29 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v29 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v29 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v27, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v29;
      __int16 v23 = "first";
      sub_100035E70((uint64_t)&__p, &v27, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v27);
      xpc_object_t v27 = 0;
      uint64_t v14 = (ctu::rest::detail *)*((unsigned __int8 *)v6 + 32);
      unint64_t v15 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v25, v14, v15, v16);
      long long __p = &v29;
      __int16 v23 = "second";
      sub_100035E70((uint64_t)&__p, &v25, &v26);
      xpc_release(v26);
      xpc_object_t v26 = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      xpc_object_t v17 = v29;
      if (v29) {
        xpc_retain(v29);
      }
      else {
        xpc_object_t v17 = xpc_null_create();
      }
      xpc_release(v29);
      xpc_array_append_value(v4, v17);
      xpc_release(v17);
      uint64_t v18 = (void *)v6[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v6[2];
          BOOL v20 = *v19 == (void)v6;
          uint64_t v6 = v19;
        }
        while (!v20);
      }
      uint64_t v6 = v19;
    }
    while (v19 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v21 = v4;
  }
  else
  {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/reg_type_of_evo");
  xpc_object_t v29 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (v24 < 0) {
    operator delete(__p);
  }
  xpc_release(v21);
}

void sub_100BA1918(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100BA19D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA1A10()
{
}

void sub_100BA1A20()
{
}

void *sub_100BA1A34(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A424D0;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA1A7C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A424D0;
  a2[1] = v2;
  return result;
}

uint64_t sub_100BA1AA8(uint64_t a1, xpc *this, unsigned int a3)
{
  uint64_t v3 = *(_DWORD **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_100BA1AD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA1B18()
{
}

void sub_100BA1B28()
{
}

__n128 sub_100BA1B3C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A42550;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100BA1B90(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A42550;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BA1BC8(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  xpc_object_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  int v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    xpc_object_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_100BA1CAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA1CEC()
{
}

void sub_100BA1CFC()
{
}

void *sub_100BA1D10(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A425D0;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA1D58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A425D0;
  a2[1] = v2;
  return result;
}

void sub_100BA1D84(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      BOOL v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value((const NRDisableStatus *)(v6 + 4));
      long long __p = &v26;
      BOOL v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      unint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          unint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/nr_disable_status");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_100BA204C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100BA2104(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA2144()
{
}

void sub_100BA2154()
{
}

void *sub_100BA2168(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A42660;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA21B0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A42660;
  a2[1] = v2;
  return result;
}

void sub_100BA21DC(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/sa_capability_status");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100BA2280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100BA22C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA2304()
{
}

void sub_100BA2314()
{
}

__n128 sub_100BA2328(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A426E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA237C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A426E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BA23B4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  char v4 = v3 + 1;
  xpc_object_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_10031A644((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10030AAD0((uint64_t)&v9, v10);
}

void sub_100BA2474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100BA248C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA24CC()
{
}

void sub_100BA24DC()
{
}

__n128 sub_100BA24F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A42760;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA2544(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A42760;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BA257C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  char v4 = v3 + 1;
  xpc_object_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_100BA26A4((uint64_t)v3, *a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100BA2640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100BA2658(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA2698()
{
}

void sub_100BA26A4(uint64_t a1, xpc_object_t object)
{
  if (object && (xpc_object_t v3 = object, xpc_get_type(object) == (xpc_type_t)&_xpc_type_array)) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  char v4 = (uint64_t **)(a1 + 8);
  sub_1000346F8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_object_t objecta = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t objecta = xpc_null_create();
    }
    sub_100048BF4(&v21, &objecta, 0);
    xpc_release(objecta);
    xpc_object_t objecta = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t objecta = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v20, &objecta, count);
    xpc_release(objecta);
    for (uint64_t i = v22; ; uint64_t i = ++v22)
    {
      if (i == v20[1] && v21 == v20[0])
      {
        xpc_release(v21);
        xpc_release(v21);
        goto LABEL_45;
      }
      xpc_object_t v19 = 0;
      xpc_object_t objecta = &v21;
      xpc_object_t v24 = i;
      sub_10003FBDC((uint64_t)&objecta, &v19);
      if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_43:
      xpc_release(v19);
    }
    uint64_t v18 = 0;
    xpc_object_t v7 = v19;
    if (v19)
    {
      xpc_retain(v19);
      xpc_object_t v26 = v7;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v26 = v7;
      if (!v7)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v7;
      goto LABEL_27;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_26:
    xpc_object_t v26 = v8;
LABEL_27:
    if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t objecta = &v26;
      xpc_object_t v24 = "first";
      sub_100048BAC((uint64_t)&objecta, &v25);
      xpc_type_t type = xpc_get_type(v25);
      if (type == (xpc_type_t)&_xpc_type_string)
      {
        int v27 = v18;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v27, (int *)&v25, v10);
        LODWORD(v18) = v27;
      }
      else if (type == (xpc_type_t)&_xpc_type_BOOL {
             || type == (xpc_type_t)&_xpc_type_int64
      }
             || type == (xpc_type_t)&_xpc_type_uint64)
      {
        LODWORD(v18) = xpc::dyn_cast_or_default((xpc *)&v25, 0, (uint64_t)v10);
      }
      xpc_release(v25);
      xpc_object_t objecta = &v26;
      xpc_object_t v24 = "second";
      sub_100048BAC((uint64_t)&objecta, &v25);
      rest::read_rest_value((rest *)((char *)&v18 + 4), (rest::SlicingSupportInfo *)&v25, v11);
      xpc_release(v25);
      xpc_object_t v8 = v26;
    }
    xpc_release(v8);
    xpc_release(v7);
    uint64_t v17 = v18;
    uint64_t v12 = *v4;
    unsigned int v13 = (uint64_t **)(a1 + 8);
    xpc_object_t v14 = (uint64_t **)(a1 + 8);
    if (*v4)
    {
      while (1)
      {
        while (1)
        {
          xpc_object_t v14 = (uint64_t **)v12;
          int v15 = *((_DWORD *)v12 + 7);
          if (v15 <= (int)v18) {
            break;
          }
          uint64_t v12 = *v14;
          unsigned int v13 = v14;
          if (!*v14) {
            goto LABEL_42;
          }
        }
        if (v15 >= (int)v18) {
          break;
        }
        uint64_t v12 = v14[1];
        if (!v12)
        {
          unsigned int v13 = v14 + 1;
          goto LABEL_42;
        }
      }
    }
    else
    {
LABEL_42:
      uint64_t v16 = (uint64_t *)operator new(0x28uLL);
      *(uint64_t *)((char *)v16 + 28) = v17;
      sub_100046C38((uint64_t **)a1, (uint64_t)v14, v13, v16);
    }
    goto LABEL_43;
  }
LABEL_45:
  xpc_release(v3);
}

void sub_100BA2A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, xpc_object_t object, uint64_t a19, xpc_object_t a20,xpc_object_t a21)
{
  xpc_release(object);
  xpc_release(a16);
  xpc_release(v21);
  _Unwind_Resume(a1);
}

void sub_100BA2B18()
{
}

__n128 sub_100BA2B2C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A427E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA2B80(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A427E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BA2BB8(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  char v4 = v3 + 1;
  xpc_object_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *xpc_object_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100BA2C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100BA2C90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA2CD0()
{
}

void sub_100BA2CE0()
{
}

__n128 sub_100BA2CF4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A42860;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BA2D48(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A42860;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BA2D80(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  char v4 = v3 + 1;
  xpc_object_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *xpc_object_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_100BA26A4((uint64_t)v3, *a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100BA2E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100BA2E5C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA2E9C()
{
}

void sub_100BA2EAC()
{
}

void *sub_100BA2EC0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A428E0;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA2F08(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A428E0;
  a2[1] = v2;
  return result;
}

void sub_100BA2F34(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v27 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v27 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v27 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v25, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v27;
      xpc_object_t v21 = "first";
      sub_100035E70((uint64_t)&__p, &v25, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      rest::write_rest_value((rest *)(v6 + 5), v14);
      long long __p = &v27;
      xpc_object_t v21 = "second";
      sub_100035E70((uint64_t)&__p, &v23, &v24);
      xpc_release(v24);
      xpc_object_t v24 = 0;
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_object_t v15 = v27;
      if (v27) {
        xpc_retain(v27);
      }
      else {
        xpc_object_t v15 = xpc_null_create();
      }
      xpc_release(v27);
      xpc_array_append_value(v4, v15);
      xpc_release(v15);
      uint64_t v16 = (void *)v6[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (void *)v6[2];
          BOOL v18 = *v17 == (void)v6;
          uint64_t v6 = v17;
        }
        while (!v18);
      }
      uint64_t v6 = v17;
    }
    while (v17 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v19 = v4;
  }
  else
  {
    xpc_object_t v19 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/geo_plmns");
  xpc_object_t v27 = v19;
  if (v19) {
    xpc_retain(v19);
  }
  else {
    xpc_object_t v27 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v22 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
}

void sub_100BA31FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100BA32B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BA32F4()
{
}

void sub_100BA3304()
{
}

void *sub_100BA3318(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A429A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA3360(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A429A8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100BA338C(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 104) + 64))(*(void *)(*(void *)(a1 + 8) + 104), 1);
}

uint64_t sub_100BA33BC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100BA33FC()
{
}

void sub_100BA340C()
{
}

void *sub_100BA3420(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A42A28;
  result[1] = v3;
  return result;
}

uint64_t sub_100BA3468(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A42A28;
  a2[1] = v2;
  return result;
}

void sub_100BA3494(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  (*(void (**)(void, uint64_t))(**(void **)(v1 + 104) + 40))(*(void *)(v1 + 104), 1);
  uint64_t v2 = *(void **)(v1 + 64);
  if (v2 != (void *)(v1 + 72))
  {
    do
    {
      (*(void (**)(void, uint64_t, uint64_t))(*(void *)v2[5] + 552))(v2[5], 1, 11);
      uint64_t v3 = (std::__shared_weak_count *)v2[6];
      uint64_t v7 = v2[5];
      xpc_object_t v8 = v3;
      if (v3) {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      RegistrationController::setRegistrationStatus_sync(v1, &v7, 1, 0);
      if (v8) {
        sub_10004D2C8(v8);
      }
      xpc_object_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          xpc_object_t v5 = v4;
          xpc_object_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          xpc_object_t v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
    }
    while (v5 != (void *)(v1 + 72));
  }
}

void sub_100BA35A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BA35C0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100BA3600()
{
}

void sub_100BA360C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v10 = 0;
  int v11 = 0;
  RegistrationController::getModel_sync(a1, a2, &v10);
  if (v10 && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v10 + 888))(v10, a3))
  {
    uint64_t v7 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)xpc_object_t v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I 5G Standalone changed due to slicing config. Sending 5G Standalone user setting to baseband", v9, 2u);
    }
    RegistrationController::send5GStandaloneEnabledSettingFromPreference_sync(a1, a2, 3);
    uint64_t v8 = *(void *)(a1 + 328);
    RegistrationController::getNRStatus_sync(a1, a2, (NRStatus *)v9);
    (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v8 + 144))(v8, a2, v9);
    RegistrationController::update5GSACapabilityRestProperty_sync((capabilities::ct *)a1, a2);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100BA3768(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BA38E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

const void **sub_100BA38FC(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = *(void **)(a2 + 32);
  if (v4) {
    xpc_object_t v4 = _Block_copy(v4);
  }
  *(void *)(a1 + 32) = v4;
  sub_100058198((const void **)(a1 + 40), (const void **)(a2 + 40));

  return sub_100062740((const void **)(a1 + 48), (const void **)(a2 + 48));
}

void sub_100BA3958(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 40);
  sub_100044D00((const void **)(a1 + 48));
  sub_100057D78(v2);
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
    _Block_release(v3);
  }
}

void sub_100BA3B64()
{
}

void sub_100BA3D28(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BA3D40(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) dictionaryRepresentation];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100BA3DE4;
  v5[3] = &unk_1019B3420;
  xpc_object_t v4 = *(NSObject **)(a1 + 48);
  v5[4] = *(void *)(a1 + 40);
  v5[5] = v3;
  dispatch_async(v4, v5);
}

void sub_100BA3DE4(uint64_t a1)
{
  id v3 = **(NSObject ***)(*(void *)(a1 + 32) + 24);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I iCloud KVS store has:", buf, 2u);
  }
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  xpc_object_t v4 = *(void **)(a1 + 40);
  id v5 = [v4 countByEnumeratingWithState:&v13 objects:v19 count:16];
  if (v5)
  {
    id v7 = v5;
    uint64_t v8 = *(void *)v14;
    *(void *)&long long v6 = 136315138;
    long long v12 = v6;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v8) {
          objc_enumerationMutation(v4);
        }
        uint64_t v10 = **(NSObject ***)(*(void *)(a1 + 32) + 24);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          id v11 = [*(id *)(*((void *)&v13 + 1) + 8 * i) UTF8String];
          *(_DWORD *)std::string buf = v12;
          id v18 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I   %s", buf, 0xCu);
        }
      }
      id v7 = [v4 countByEnumeratingWithState:&v13 objects:v19 count:16];
    }
    while (v7);
  }
  objc_msgSend(*(id *)(a1 + 32), "invokeCallbackWithDict:changedKeys:", *(void *)(a1 + 40), 0, v12);
}

void sub_100BA3FA4(uint64_t a1, uint64_t a2)
{
  id v3 = *(NSObject **)(a2 + 48);
  *(void *)(a1 + 48) = v3;
  if (v3) {
    dispatch_retain(v3);
  }
}

void sub_100BA3FBC(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (v1) {
    dispatch_release(v1);
  }
}

uint64_t sub_100BA4910(uint64_t a1)
{
  *(void *)a1 = off_101A42B10;
  [*(id *)(a1 + 8) dealloc];
  *(void *)(a1 + 8) = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100BA4970(uint64_t a1)
{
  sub_100BA4910(a1);

  operator delete();
}

void sub_100BA49A8()
{
}

id sub_100BA4A1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 8) updateICloudKey:a2 withValue:a3];
}

id sub_100BA4A2C(uint64_t a1)
{
  return [*(id *)(a1 + 8) updateICloudComplete];
}

id sub_100BA4A34(uint64_t a1)
{
  return [*(id *)(a1 + 8) forceCleanUp];
}

void sub_100BA4A44(void *a1@<X8>)
{
  *a1 = 0;
}

ICloudSync *sub_100BA4A4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = [[ICloudSync alloc] initWithCallback:a3 queue:a2 registry:a1 + 16];
  *(void *)(a1 + 8) = result;
  return result;
}

id sub_100BA4A9C(uint64_t a1)
{
  return [*(id *)(a1 + 8) forceCompleteReverseUpdate];
}

id sub_100BA4AA4(uint64_t a1)
{
  return [*(id *)(a1 + 8) dumpState];
}

const char *sub_100BA4AAC()
{
  return "KVS";
}

void *sub_100BA4AB8(void *a1, char *a2, void *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, a2);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 1), (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  *a1 = off_101A42B98;
  a1[2] = *a3;
  uint64_t v5 = a3[1];
  a1[3] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  a1[6] = 0;
  a1[5] = 0;
  a1[4] = a1 + 5;
  return a1;
}

void sub_100BA4B74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void sub_100BA4B98(uint64_t a1, void **a2, uint64_t a3)
{
  xpc_object_t v4 = a2;
  *(void *)std::string buf = a2;
  *((_DWORD *)sub_100BA51AC((uint64_t **)(a1 + 32), a2, (uint64_t)&unk_10144E20E, (long long **)buf) + 14) = a3;
  (*(void (**)(uint64_t, void **, uint64_t))(*(void *)a1 + 24))(a1, v4, a3);
  long long v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)v4 + 23) < 0) {
      xpc_object_t v4 = (void **)*v4;
    }
    uint64_t v7 = asString();
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = v4;
    __int16 v9 = 2082;
    uint64_t v10 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setting user notification state for bundle id: %{public}s to %{public}s", buf, 0x16u);
  }
}

void sub_100BA4CBC(uint64_t a1)
{
  long long v47 = 0;
  uint64_t v48 = 0;
  long long v46 = &v47;
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v29 = a1;
  uint64_t v2 = (void *)(a1 + 40);
  if (v1 != (void *)(a1 + 40))
  {
    do
    {
      uint64_t v3 = v47;
      xpc_object_t v4 = &v47;
      uint64_t v5 = &v47;
      if (v47)
      {
        int v6 = *((_DWORD *)v1 + 14);
        do
        {
          while (1)
          {
            uint64_t v5 = (uint64_t **)v3;
            int v7 = *((_DWORD *)v3 + 8);
            if (v7 <= v6) {
              break;
            }
            uint64_t v3 = *v5;
            xpc_object_t v4 = v5;
            if (!*v5) {
              goto LABEL_11;
            }
          }
          if (v7 >= v6)
          {
            __int16 v9 = (char *)v5;
            goto LABEL_14;
          }
          uint64_t v3 = v5[1];
        }
        while (v3);
        xpc_object_t v4 = v5 + 1;
      }
LABEL_11:
      __int16 v9 = (char *)operator new(0x40uLL);
      *((_DWORD *)v9 + 8) = *((_DWORD *)v1 + 14);
      *((void *)v9 + 7) = 0;
      *((void *)v9 + 6) = 0;
      *((void *)v9 + 5) = v9 + 48;
      *(void *)__int16 v9 = 0;
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = v5;
      void *v4 = (uint64_t *)v9;
      uint64_t v8 = (uint64_t *)v9;
      if (*v46)
      {
        long long v46 = (uint64_t **)*v46;
        uint64_t v8 = *v4;
      }
      sub_100046C90(v47, v8);
      ++v48;
LABEL_14:
      sub_100046BAC((uint64_t **)v9 + 5, (void **)v1 + 4, (uint64_t)(v1 + 4));
      uint64_t v10 = (void *)v1[1];
      if (v10)
      {
        do
        {
          id v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          id v11 = (void *)v1[2];
          BOOL v12 = *v11 == (void)v1;
          uint64_t v1 = v11;
        }
        while (!v12);
      }
      uint64_t v1 = v11;
    }
    while (v11 != v2);
  }
  uint64_t v45 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  *(_OWORD *)__int16 v33 = 0u;
  long long v34 = 0u;
  memset(v32, 0, sizeof(v32));
  long long v31 = 0u;
  sub_10004BD84((uint64_t)&v31);
  long long v13 = v46;
  if (v46 != &v47)
  {
    do
    {
      long long v14 = sub_10004B96C(v32, (uint64_t)"Apps with user state ", 21);
      long long v15 = (const char *)asString();
      size_t v16 = strlen(v15);
      uint64_t v17 = sub_10004B96C(v14, (uint64_t)v15, v16);
      sub_10004B96C(v17, (uint64_t)": ", 2);
      sub_1000E8F34((std::string *)v13[5], (std::string *)v13 + 2, ", ", 2uLL, &__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      sub_10004B96C(v32, (uint64_t)p_p, size);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      __p.__r_.__value_.__s.__data_[0] = 10;
      sub_10004B96C(v32, (uint64_t)&__p, 1);
      BOOL v20 = v13[1];
      if (v20)
      {
        do
        {
          xpc_object_t v21 = (uint64_t **)v20;
          BOOL v20 = (uint64_t *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          xpc_object_t v21 = (uint64_t **)v13[2];
          BOOL v12 = *v21 == (uint64_t *)v13;
          long long v13 = v21;
        }
        while (!v12);
      }
      long long v13 = v21;
    }
    while (v21 != &v47);
  }
  memset(&__p, 0, sizeof(__p));
  sub_10004BC98((uint64_t)v32 + 8, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__p.__r_.__value_.__l.__size_)
    {
LABEL_45:
      operator delete(__p.__r_.__value_.__l.__data_);
      goto LABEL_46;
    }
    uint64_t v22 = __p.__r_.__value_.__l.__size_ - 1;
    xpc_object_t v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
    --__p.__r_.__value_.__l.__size_;
  }
  else
  {
    if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
      goto LABEL_46;
    }
    uint64_t v22 = HIBYTE(__p.__r_.__value_.__r.__words[2]) - 1;
    --*((unsigned char *)&__p.__r_.__value_.__s + 23);
    xpc_object_t v23 = &__p;
  }
  v23->__r_.__value_.__s.__data_[v22] = 0;
  xpc_object_t v24 = *(NSObject **)(v29 + 8);
  BOOL v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
  char v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if (v25)
  {
    xpc_object_t v27 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      xpc_object_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 136446210;
    uint64_t v50 = v27;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %{public}s", buf, 0xCu);
    char v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  if (v26 < 0) {
    goto LABEL_45;
  }
LABEL_46:
  *(void *)((char *)&v32[-1]
  *(void *)&v32[0] = v28;
  if (SHIBYTE(v34) < 0) {
    operator delete(v33[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  sub_100BA5304(v47);
}

void sub_100BA515C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_10008248C((uint64_t)&a16);
  sub_100BA5304(*(void **)(v16 - 144));
  _Unwind_Resume(a1);
}

uint64_t *sub_100BA51AC(uint64_t **a1, void **a2, uint64_t a3, long long **a4)
{
  uint64_t v9 = 0;
  int v6 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v9, a2);
  __n128 result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_100BA5250((uint64_t)a1, a4, v8);
    sub_100046C38(a1, v9, v6, v8[0]);
    return v8[0];
  }
  return result;
}

unsigned char *sub_100BA5250@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  int v6 = a3 + 1;
  int v7 = (char *)operator new(0x40uLL);
  *a3 = v7;
  *int v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = v7 + 32;
  uint64_t v9 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)v9, *((void *)v9 + 1));
  }
  else
  {
    long long v10 = *v9;
    *((void *)v7 + 6) = *((void *)v9 + 2);
    *(_OWORD *)__n128 result = v10;
  }
  *((_DWORD *)v7 + 14) = 0;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100BA52E8(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

void sub_100BA5304(void *a1)
{
  if (a1)
  {
    sub_100BA5304(*a1);
    sub_100BA5304(a1[1]);
    sub_10005CD2C((uint64_t)(a1 + 5), (char *)a1[6]);
    operator delete(a1);
  }
}

uint64_t sub_100BA535C@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = capabilities::ct::defaultVinylCardTypeToGSMA(a1);
  *a2 = 0;
  a2[1] = 0;
  if (result) {
    operator new();
  }
  return result;
}

void sub_100BA5488(_Unwind_Exception *exception_object)
{
  if (v3)
  {
    sub_10004D2C8(v3);
    if (!v2)
    {
LABEL_3:
      if (!v1) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if (!v2)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v2);
  if (!v1)
  {
LABEL_4:
    if (v4) {
      goto LABEL_5;
    }
    goto LABEL_6;
  }
LABEL_9:
  dispatch_release(v1);
  if (v4) {
LABEL_5:
  }
    operator delete();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_100BA54E4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void *sub_100BA55C4(void *a1, NSObject **a2, void *a3, void *a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v16, kCtLoggingSystemName, "cp.sub.push");
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v8 = *a2;
  a1[3] = *a2;
  if (v8) {
    dispatch_retain(v8);
  }
  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v17, &v16);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v17);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v17);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v16);
  *a1 = &off_101A42C10;
  a1[6] = off_101A42C48;
  a1[7] = *a3;
  uint64_t v9 = a3[1];
  a1[8] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 16), 1uLL, memory_order_relaxed);
  }
  a1[9] = *a4;
  uint64_t v10 = a4[1];
  a1[10] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  a1[11] = 0;
  a1[12] = 0;
  sub_100058DB0(&__p, "CellularPlanSubscriptionPush");
  id v11 = a1[3];
  long long v13 = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  ctu::RestModule::RestModule();
  if (v13) {
    dispatch_release(v13);
  }
  if (v15 < 0) {
    operator delete(__p);
  }
  return a1;
}

void sub_100BA5754(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_object_t v23 = (std::__shared_weak_count *)*((void *)v19 + 12);
  if (v23) {
    sub_10004D2C8(v23);
  }
  xpc_object_t v24 = (std::__shared_weak_count *)*((void *)v19 + 10);
  if (v24) {
    sub_10004D2C8(v24);
  }
  BOOL v25 = (std::__shared_weak_count *)*((void *)v19 + 8);
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  push::PushMessageListenerInterface::~PushMessageListenerInterface(v19);
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

push::PushMessageListenerInterface *sub_100BA57F4(push::PushMessageListenerInterface *this)
{
  *(void *)this = &off_101A42C10;
  *((void *)this + 6) = off_101A42C48;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  push::PushMessageListenerInterface::~PushMessageListenerInterface(this);
  ctu::OsLogLogger::~OsLogLogger((push::PushMessageListenerInterface *)((char *)this + 40));
  sub_100087E88((void *)this + 1);
  return this;
}

push::PushMessageListenerInterface *sub_100BA58A4(uint64_t a1)
{
  return sub_100BA57F4((push::PushMessageListenerInterface *)(a1 - 48));
}

void sub_100BA58AC(push::PushMessageListenerInterface *a1)
{
  sub_100BA57F4(a1);

  operator delete();
}

void sub_100BA58E4(uint64_t a1)
{
  sub_100BA57F4((push::PushMessageListenerInterface *)(a1 - 48));

  operator delete();
}

void sub_100BA5920(uint64_t a1, const void **a2, const void **a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v7);
      sub_100083DA4((const void **)&v9, a2);
      sub_100058198((const void **)&v9 + 1, a3);
      uint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
      if (v8)
      {
        if (std::__shared_weak_count::lock(v8)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_100BA5AA4(uint64_t a1, const void **a2, const void **a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v7);
      sub_10002FD9C((const void **)&v9, a2);
      sub_100083DA4((const void **)&v9 + 1, a3);
      uint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
      if (v8)
      {
        if (std::__shared_weak_count::lock(v8)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_100BA5C28(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100BA5CF4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100BA5DCC);
  __cxa_rethrow();
}

void sub_100BA5D1C(_Unwind_Exception *a1)
{
}

void sub_100BA5D34(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BA5D6C(uint64_t a1)
{
}

uint64_t sub_100BA5D88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BA5DCC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100BA5DF8(uint64_t **a1)
{
  uint64_t v1 = **a1;
  (***(void (****)(uint8_t *__return_ptr))(v1 + 72))(buf);
  Registry::createRestModuleOneTimeUseConnection(&v21, *(Registry **)buf);
  ctu::RestModule::connect();
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I CellularPlanSubscriptionPushObserver::initialize", buf, 2u);
  }
  pthread_mutex_lock(&stru_101B09E48);
  uint64_t v3 = (void *)off_101B09E88;
  if (!off_101B09E88) {
    sub_1012D6D0C(buf);
  }
  int v4 = (std::__shared_weak_count *)*(&off_101B09E88 + 1);
  if (*(&off_101B09E88 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_101B09E88 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_101B09E48);
  CFStringRef v20 = @"com.apple.commcenter.sim-provisioning";
  CFRetain(@"com.apple.commcenter.sim-provisioning");
  CFStringRef v19 = @"com.apple.commcenter.sim-provisioning";
  CFRetain(@"com.apple.commcenter.sim-provisioning");
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5)
  {
    uint64_t v6 = *(void *)(v1 + 8);
    int v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      uint64_t v8 = v7;
      *(void *)std::string buf = v6;
      *(void *)&uint8_t buf[8] = v7;
      sub_1012D7700(v3, (const void **)&v19, (uint64_t)buf);
      sub_10004D2C8(v8);
      sub_1000558F4((const void **)&v19);
      long long v9 = *(std::__shared_weak_count **)(v1 + 16);
      if (v9)
      {
        uint64_t v10 = *(void *)(v1 + 72);
        uint64_t v11 = *(void *)(v1 + 8);
        BOOL v12 = std::__shared_weak_count::lock(v9);
        if (v12)
        {
          uint64_t v13 = v11 + 48;
          if (!v11) {
            uint64_t v13 = 0;
          }
          uint64_t v16 = v13;
          uint64_t v17 = v12;
          (*(void (**)(long long *__return_ptr, uint64_t, uint64_t *))(*(void *)v10 + 568))(&v18, v10, &v16);
          long long v14 = v18;
          long long v18 = 0uLL;
          char v15 = *(std::__shared_weak_count **)(v1 + 96);
          *(_OWORD *)(v1 + 88) = v14;
          if (v15)
          {
            sub_10004D2C8(v15);
            if (*((void *)&v18 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v18 + 1));
            }
          }
          if (v17) {
            sub_10004D2C8(v17);
          }
          sub_1000558F4((const void **)&v20);
          if (v4) {
            sub_10004D2C8(v4);
          }
          operator delete();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_100BA6074()
{
}

uint64_t *sub_100BA6128(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v27 = a1;
  uint64_t v28 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(v1 + 8))
      {
        if (*(void *)(v1 + 24)) {
          uint64_t v6 = sub_1000810B8;
        }
        else {
          uint64_t v6 = 0;
        }
        if (v6 && CFEqual(*(CFTypeRef *)(v1 + 24), @"com.apple.commcenter.sim-provisioning"))
        {
          uint64_t v29 = 0;
          ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v29);
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v1 + 32), @"aps");
          CFDictionaryRef v8 = Value;
          if (Value && (CFTypeID v9 = CFGetTypeID(Value), v9 == CFDictionaryGetTypeID()))
          {
            CFDictionaryGetValue(v8, @"alert");
            memset(buf, 0, sizeof(buf));
            int64_t v33 = 0;
            ctu::cf::assign();
            uint64_t v31 = v33;
            *(_OWORD *)std::string __p = *(_OWORD *)buf;
            unint64_t v10 = HIBYTE(v33);
            int v11 = SHIBYTE(v33);
            if (v33 < 0) {
              unint64_t v10 = *(void *)&buf[8];
            }
            if (v10 == 21)
            {
              char v15 = __p;
              if (v33 < 0) {
                char v15 = (void **)__p[0];
              }
              uint64_t v16 = *v15;
              uint64_t v17 = v15[1];
              uint64_t v18 = *(uint64_t *)((char *)v15 + 13);
              if (v16 == (void *)0x6176416B63656843
                && v17 == (void *)0x704F656C62616C69
                && v18 == 0x736E6F6974704F65)
              {
                sub_100BA65A4();
                (*(void (**)(void))(**(void **)(v3 + 88) + 224))(*(void *)(v3 + 88));
                xpc_object_t v23 = *(std::__shared_weak_count **)(v3 + 64);
                if (v23)
                {
                  xpc_object_t v24 = std::__shared_weak_count::lock(v23);
                  if (v24)
                  {
                    BOOL v25 = v24;
                    uint64_t v26 = *(void *)(v3 + 56);
                    if (v26)
                    {
                      uint64_t v34 = 0;
                      (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *))(*(void *)v26 + 24))(v26, 1, 1, buf);
                      sub_10032493C(buf);
                    }
                    sub_10004D2C8(v25);
                  }
                }
              }
            }
            else if (!v10)
            {
              BOOL v12 = *(NSObject **)(v3 + 40);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#E handlePushMessage: Missing 'alert'", buf, 2u);
              }
            }
            if (v11 < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            uint64_t v13 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E handlePushMessage: Malformed message", buf, 2u);
            }
          }
          ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v29);
        }
        else
        {
          memset(buf, 0, sizeof(buf));
          int64_t v33 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = 0u;
          uint64_t v31 = 0;
          long long v14 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            uint64_t v22 = __p;
            if (v31 < 0) {
              uint64_t v22 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v22;
            _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Topic mismatch [%s]", buf, 0xCu);
          }
          if (SHIBYTE(v31) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100BA6540(&v28);
  return sub_100046B58((uint64_t *)&v27);
}

void sub_100BA64A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  uint64_t v28 = v25;
  sub_10032493C(&__p);
  sub_10004D2C8(v28);
  if (v27 < 0) {
    operator delete(v26);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&a12);
  sub_10004D2C8(v24);
  sub_100BA6540(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BA6540(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100057D78((const void **)(v1 + 32));
    sub_1000558F4((const void **)(v1 + 24));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100BA65A4()
{
  sub_100058DB0(&__p, "/cc/events/pending_install_plan_push_notification_received");
  xpc_object_t object = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
}

void sub_100BA6614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_100BA6644(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFStringRef v20 = a1;
  uint64_t v21 = v1;
  char v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void **)v1;
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(v1 + 8))
      {
        if (*(void *)(v1 + 32)) {
          uint64_t v6 = sub_1000810B8;
        }
        else {
          uint64_t v6 = 0;
        }
        if (v6 && CFEqual(*(CFTypeRef *)(v1 + 32), @"com.apple.commcenter.sim-provisioning"))
        {
          if (*(void *)(v1 + 24)) {
            int v7 = sub_10008324C;
          }
          else {
            int v7 = 0;
          }
          if (v7)
          {
            CFDictionaryRef v8 = (std::__shared_weak_count *)v3[8];
            if (v8)
            {
              CFTypeID v9 = std::__shared_weak_count::lock(v8);
              if (v9)
              {
                unint64_t v10 = v9;
                uint64_t v11 = v3[7];
                if (v11)
                {
                  memset(v26, 0, sizeof(v26));
                  uint64_t v27 = 0;
                  BytePtr = (char *)CFDataGetBytePtr(*(CFDataRef *)(v1 + 24));
                  CFIndex Length = CFDataGetLength(*(CFDataRef *)(v1 + 24));
                  sub_10006E4A8(v26, BytePtr, &BytePtr[Length], Length);
                  __p[0] = 0;
                  __p[1] = 0;
                  uint64_t v23 = 0;
                  ctu::hex();
                  long long v14 = v3[5];
                  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
                  {
                    char v15 = __p;
                    if (v23 < 0) {
                      char v15 = (void **)__p[0];
                    }
                    *(_DWORD *)std::string buf = 136315138;
                    *(void *)&uint8_t buf[4] = v15;
                    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I handleTokenUpdate: [%s]", buf, 0xCu);
                  }
                  if (SHIBYTE(v23) < 0)
                  {
                    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
                  }
                  else
                  {
                    *(_OWORD *)std::string buf = *(_OWORD *)__p;
                    uint64_t v25 = v23;
                  }
                  (*(void (**)(uint64_t, uint8_t *))(*(void *)v11 + 16))(v11, buf);
                  if (SHIBYTE(v25) < 0) {
                    operator delete(*(void **)buf);
                  }
                  if (SHIBYTE(v23) < 0) {
                    operator delete(__p[0]);
                  }
                  if (*(void *)v26)
                  {
                    *(void *)&v26[8] = *(void *)v26;
                    operator delete(*(void **)v26);
                  }
                }
                sub_10004D2C8(v10);
              }
            }
          }
          else
          {
            uint64_t v17 = v3[5];
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t v26 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "handleTokenUpdate: No token", v26, 2u);
            }
          }
        }
        else
        {
          memset(v26, 0, sizeof(v26));
          uint64_t v27 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = 0u;
          uint64_t v23 = 0;
          uint64_t v16 = v3[5];
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            uint64_t v18 = __p;
            if (v23 < 0) {
              uint64_t v18 = (void **)__p[0];
            }
            *(_DWORD *)uint64_t v26 = 136315138;
            *(void *)&v26[4] = v18;
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "handleTokenUpdate: Topic mismatch [%s]", v26, 0xCu);
          }
          if (SHIBYTE(v23) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100BA69EC(&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_100BA695C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a25)
  {
    a26 = (uint64_t)a25;
    operator delete(a25);
  }
  sub_10004D2C8(v31);
  sub_10004D2C8(v30);
  sub_100BA69EC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BA69EC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1000558F4((const void **)(v1 + 32));
    sub_100030068((const void **)(v1 + 24));
    char v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100BA6A50()
{
  if ((byte_101B09E98 & 1) == 0)
  {
    byte_101B09E98 = 1;
    return __cxa_atexit((void (*)(void *))sub_10021691C, &stru_101B09E48, (void *)&_mh_execute_header);
  }
  return result;
}

void *AnalyticsEvent::AnalyticsEvent(void *a1, long long *a2, void *a3)
{
  *a1 = &off_101A42DB0;
  uint64_t v5 = a1 + 1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(v5, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    v5[2] = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v5 = v6;
  }
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (v7)
  {
    a1[4] = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    a1[4] = v8;
    if (!v8)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_11;
    }
  }
  if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v8);
    goto LABEL_12;
  }
  xpc_object_t v9 = xpc_null_create();
LABEL_11:
  a1[4] = v9;
LABEL_12:
  xpc_release(v8);
  uint64_t v10 = a3[1];
  a1[5] = *a3;
  a1[6] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void AnalyticsEvent::~AnalyticsEvent(void **this)
{
  *this = &off_101A42DB0;
  AnalyticsEvent::submit((AnalyticsEvent *)this);
  char v2 = (std::__shared_weak_count *)this[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(this[4]);
  this[4] = 0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

void AnalyticsEvent::submit(AnalyticsEvent *this)
{
  if (xpc_get_type(*((xpc_object_t *)this + 4)) == (xpc_type_t)&_xpc_type_dictionary)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*((Registry **)this + 5));
    uint64_t v3 = ServiceMap;
    if ((v4 & 0x8000000000000000) != 0)
    {
      uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v6 = 5381;
      do
      {
        unint64_t v4 = v6;
        unsigned int v7 = *v5++;
        uint64_t v6 = (33 * v6) ^ v7;
      }
      while (v7);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v18 = v4;
    xpc_object_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v18);
    if (v8)
    {
      uint64_t v10 = v8[3];
      xpc_object_t v9 = (std::__shared_weak_count *)v8[4];
      if (v9)
      {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v3);
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        char v11 = 0;
        if (!v10)
        {
LABEL_17:
          if ((v11 & 1) == 0) {
            sub_10004D2C8(v9);
          }
          return;
        }
LABEL_11:
        BOOL v12 = (void *)((char *)this + 8);
        if (*((char *)this + 31) < 0) {
          BOOL v12 = (void *)*v12;
        }
        uint64_t v13 = (void *)*((void *)this + 4);
        xpc_object_t object = v13;
        if (v13) {
          xpc_retain(v13);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        (*(void (**)(uint64_t, void *, xpc_object_t *))(*(void *)v10 + 16))(v10, v12, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_object_t v14 = xpc_null_create();
        xpc_object_t v15 = xpc_null_create();
        uint64_t v16 = (void *)*((void *)this + 4);
        *((void *)this + 4) = v14;
        xpc_release(v16);
        xpc_release(v15);
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v10 = 0;
    }
    std::mutex::unlock(v3);
    xpc_object_t v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_17;
    }
    goto LABEL_11;
  }
}

void sub_100BA6DA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_100BA6DDC(void **a1)
{
  AnalyticsEvent::~AnalyticsEvent(a1);

  operator delete();
}

uint64_t sub_100BA6E14@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = capabilities::ct::supportsThumperService(a1);
  if (result)
  {
    memset(v4, 0, sizeof(v4));
    sub_100919420(v4);
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void sub_100BA6F18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a13;
  sub_100047F64(&a16);
  _Unwind_Resume(a1);
}

void *sub_100BA6F7C(void *a1, void *a2, NSObject **a3, long long **a4, uint64_t *a5)
{
  xpc_object_t v9 = *a3;
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  char v10 = (std::__shared_weak_count *)a5[1];
  uint64_t v12 = *a5;
  uint64_t v13 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  v15[0] = off_101999E18;
  v15[1] = sub_100BA70D8;
  v15[3] = v15;
  sub_1009198DC((uint64_t)a1, a2, &object, a4, "iCloudEmergencyNumbers", "call.em.iCloud", &v12, (uint64_t)v15);
  sub_10008863C(v15);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  if (object) {
    dispatch_release(object);
  }
  *a1 = off_101A42DE0;
  return a1;
}

void sub_100BA70AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, dispatch_object_t object, uint64_t a12)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(a1);
}

const char *sub_100BA70D8(int a1)
{
  uint64_t v1 = "call.em.iCloud.?";
  if (a1 == 2) {
    uint64_t v1 = "call.em.iCloud.2";
  }
  if (a1 == 1) {
    return "call.em.iCloud.1";
  }
  else {
    return v1;
  }
}

void sub_100BA7108(uint64_t a1)
{
  sub_10091A030(a1);

  operator delete();
}

void sub_100BA7140(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100BA7228(uint64_t a1, uint64_t a2, long long **a3, int a4)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v7 = 0;
  long long v6 = 0uLL;
  sub_1000302C0((char *)&v6, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  int v8 = a4;
  v9[0] = 0;
  v9[1] = 0;
  sub_10003E168(v9, v5);
  operator new();
}

void sub_100BA738C(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100BA7468(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v4 = (void *)(a1 + 8);
  sub_10009DB3C((uint64_t)&v5, a2);
  int v6 = a3;
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, v4);
  operator new();
}

BOOL sub_100BA7614(uint64_t a1, _DWORD *a2)
{
  return *a2 == 2;
}

void sub_100BA7628(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100BA76F4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100BA77CC);
  __cxa_rethrow();
}

void sub_100BA771C(_Unwind_Exception *a1)
{
}

void sub_100BA7734(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BA776C(uint64_t a1)
{
}

uint64_t sub_100BA7788(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BA77CC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t *sub_100BA77F8(void *a1)
{
  char v2 = a1;
  if (*a1) {
    operator delete();
  }
  return sub_100046B58((uint64_t *)&v2);
}

uint64_t *sub_100BA783C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v4 = a1;
  uint64_t v5 = v1;
  char v2 = *(void **)v1;
  sub_10091AE64(*(void *)v1, *(_DWORD *)(v1 + 8), (long long **)(v1 + 16), *(unsigned int *)(v1 + 40));
  sub_10091B394(v2);
  sub_100BA78B8(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100BA789C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100BA78B8(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    char v2 = (void **)(v1 + 16);
    sub_100047F64(&v2);
    operator delete();
  }
  return result;
}

void sub_100BA7918(uint64_t **a1)
{
  unsigned int v1 = 0;
  uint64_t v2 = **a1;
  while (1)
  {
    if (v1 != 8)
    {
      subscriber::makeSimSlotRange();
      uint64_t v3 = v5;
      if (v5 != v6)
      {
        do
        {
          if (v7(*v3)) {
            goto LABEL_7;
          }
          ++v3;
        }
        while (v3 != v6);
        uint64_t v3 = v6;
LABEL_7:
        while (v3 != v6)
        {
          sub_10091CC90(v2, *v3, v1);
          unint64_t v4 = v3 + 1;
          uint64_t v3 = v6;
          if (v4 != v6)
          {
            uint64_t v3 = v4;
            do
            {
              if (v7(*v3)) {
                goto LABEL_7;
              }
              ++v3;
            }
            while (v3 != v6);
            uint64_t v3 = v6;
          }
        }
      }
    }
    if (++v1 == 13) {
      operator delete();
    }
  }
}

void sub_100BA7A28()
{
}

uint64_t *sub_100BA7A60(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1 + 104;
  xpc_object_t v9 = (_DWORD *)(v1 + 144);
  uint64_t v3 = sub_100BA7BC0(v2, (int *)(v1 + 144), (uint64_t)&unk_10144E20E, &v9);
  void v3[5] = *(void *)(v1 + 8);
  std::string::operator=((std::string *)v3 + 2, (const std::string *)(v1 + 16));
  std::string::operator=((std::string *)v3 + 3, (const std::string *)(v1 + 40));
  int v4 = *(_DWORD *)(v1 + 64);
  *((unsigned char *)v3 + 100) = *(unsigned char *)(v1 + 68);
  *((_DWORD *)v3 + 24) = v4;
  std::string::operator=((std::string *)(v3 + 13), (const std::string *)(v1 + 72));
  std::string::operator=((std::string *)(v3 + 16), (const std::string *)(v1 + 96));
  long long v5 = *(_OWORD *)(v1 + 120);
  *((unsigned char *)v3 + 168) = *(unsigned char *)(v1 + 136);
  *(_OWORD *)(v3 + 19) = v5;
  sub_100BA7B38(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100BA7B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100BA7B38(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 119) < 0) {
      operator delete(*(void **)(v1 + 96));
    }
    if (*(char *)(v1 + 95) < 0) {
      operator delete(*(void **)(v1 + 72));
    }
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100BA7BC0(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  int v6 = (uint64_t **)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t *)v5;
        int v9 = *(_DWORD *)(v5 + 32);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        int v6 = (uint64_t **)v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        int v6 = (uint64_t **)(v8 + 1);
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = (uint64_t *)(a1 + 8);
LABEL_10:
    memset(v11, 0, sizeof(v11));
    sub_100BA7C94(a1, a4, v11);
    sub_100046C38((uint64_t **)a1, (uint64_t)v8, v6, v11[0]);
    uint64_t v8 = v11[0];
    v11[0] = 0;
    sub_100BA7D10((uint64_t)v11, 0);
  }
  return v8;
}

void sub_100BA7C94(uint64_t a1@<X0>, _DWORD **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  int v6 = (char *)operator new(0xB0uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  *((_DWORD *)v6 + 8) = **a2;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(v6 + 40));
  *((unsigned char *)a3 + 16) = 1;
}

void sub_100BA7CF8(_Unwind_Exception *a1)
{
  sub_100BA7D10(v1, 0);
  _Unwind_Resume(a1);
}

void sub_100BA7D10(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10091ECC8((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t sub_100BA7D68(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = a3;
  uint64_t valuePtr = a2;
  pthread_mutex_lock(&stru_101B0B128);
  CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &v8);
  values[0] = v4;
  values[1] = v5;
  keys[0] = @"value";
  keys[1] = @"starttimestamp";
  CFDictionaryRef v6 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFPreferencesSetValue(a1, v6, @"com.apple.CommCenter.counts", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFRelease(v4);
  CFRelease(v5);
  CFRelease(v6);
  CFPreferencesSynchronize(@"com.apple.CommCenter.counts", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  return pthread_mutex_unlock(&stru_101B0B128);
}

const void **sub_100BA7EC4(const __CFString *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  pthread_mutex_lock(&stru_101B0B128);
  CFDictionaryRef theDict = 0;
  v16.tv_sec = (__darwin_time_t)CFPreferencesCopyValue(a1, @"com.apple.CommCenter.counts", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100084068(&theDict, (CFTypeRef *)&v16);
  *a2 = 0;
  *a3 = 0;
  if (theDict
    && (Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"value"), (CFNumberRef v9 = Value) != 0)
    && (CFTypeID v10 = CFGetTypeID(Value), v10 == CFNumberGetTypeID())
    && CFNumberGetValue(v9, kCFNumberSInt64Type, a2)
    && (v11 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"starttimestamp"), (CFNumberRef v12 = v11) != 0)
    && (CFTypeID v13 = CFGetTypeID(v11), v13 == CFNumberGetTypeID())
    && CFNumberGetValue(v12, kCFNumberSInt64Type, a3))
  {
    pthread_mutex_unlock(&stru_101B0B128);
  }
  else
  {
    *a2 = (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
    v16.tv_sec = 0;
    *(void *)&v16.tv_usec = 0;
    gettimeofday(&v16, 0);
    *a3 = 1000 * v16.tv_sec + v16.tv_usec / 0x3E8uLL;
    pthread_mutex_unlock(&stru_101B0B128);
    sub_100BA7D68(a1, *a2, *a3);
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_100BA806C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100BA8080(uint64_t a1, void *a2)
{
  *(void *)a1 = off_101A42F18;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "awd");
  CFNumberRef v4 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  CFNumberRef v5 = dispatch_queue_create("MetricCounters", v4);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = v5;
  if (v5)
  {
    CFDictionaryRef v6 = v5;
    dispatch_retain(v5);
    *(void *)(a1 + 32) = 0;
    dispatch_release(v6);
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v8, &v9);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *(void *)a1 = off_101A42F18;
  *(void *)(a1 + 48) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 56) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 300) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  operator new();
}

void sub_100BA8848(_Unwind_Exception *a1)
{
  uint64_t v5 = v2[49];
  v2[49] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = v2[48];
  v2[48] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = v2[47];
  v2[47] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = v2[46];
  v2[46] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = v2[45];
  v2[45] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = v2[44];
  v2[44] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = v2[43];
  v2[43] = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = v2[42];
  v2[42] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = v2[41];
  v2[41] = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  uint64_t v14 = v2[40];
  v2[40] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  xpc_object_t v15 = (std::__shared_weak_count *)v2[7];
  if (v15) {
    sub_10004D2C8(v15);
  }
  ctu::OsLogLogger::~OsLogLogger(v3);
  sub_100087E88(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100BA8CE0()
{
  return sub_100BA8CE8(1);
}

uint64_t sub_100BA8CE8(int a1)
{
  uint64_t v11 = 0;
  int v2 = getifaddrs(&v11);
  uint64_t v3 = 0;
  CFNumberRef v4 = v11;
  if (!v2 && v11)
  {
    uint64_t v3 = 0;
    uint64_t v5 = v11;
    do
    {
      ifa_addr = v5->ifa_addr;
      if (!ifa_addr || ifa_addr->sa_family != 18 || strncmp(v5->ifa_name, "pdp_ip", 6uLL)) {
        goto LABEL_14;
      }
      ifa_std::string::pointer data = (char *)v5->ifa_data;
      if (a1 == 2)
      {
        uint64_t v8 = (unsigned int *)(ifa_data + 40);
      }
      else
      {
        if (a1 != 1)
        {
          uint64_t v9 = 0;
          goto LABEL_13;
        }
        uint64_t v8 = (unsigned int *)(ifa_data + 44);
      }
      uint64_t v9 = *v8;
LABEL_13:
      v3 += v9;
LABEL_14:
      uint64_t v5 = v5->ifa_next;
    }
    while (v5);
  }
  if (v4) {
    freeifaddrs(v4);
  }
  return v3;
}

uint64_t sub_100BA8DBC()
{
  return sub_100BA8CE8(2);
}

void sub_100BA8DC4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 64));
  uint64_t v2 = sub_100BA8CE8(1);
  uint64_t v3 = *(void *)(v1 + 408);
  uint64_t v4 = v2 - *(void *)(v1 + 416) + *(void *)(v1 + 400);
  *(void *)(v1 + 400) = 0;
  *(void *)(v1 + 416) = v2;
  v13.tv_sec = 0;
  *(void *)&v13.tv_usec = 0;
  gettimeofday(&v13, 0);
  uint64_t v5 = 1000 * v13.tv_sec + v13.tv_usec / 0x3E8uLL;
  *(void *)(v1 + 408) = v5;
  sub_100BA7D68(@"CellularBytesSent", *(void *)(v1 + 400), v5);
  uint64_t v6 = (wis::MetricFactory *)pthread_mutex_unlock((pthread_mutex_t *)(v1 + 64));
  v13.tv_sec = (__darwin_time_t)_NSConcreteStackBlock;
  *(void *)&v13.tv_usec = 0x40000000;
  uint64_t v14 = sub_100BA97D8;
  xpc_object_t v15 = &unk_101A42FA8;
  uint64_t v16 = v4;
  uint64_t v17 = v3;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v6);
  uint64_t v8 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x80027u);
  if (v8)
  {
    uint64_t v9 = (wis::MetricContainer *)v8;
    uint64_t v10 = sub_10001C8F4(8);
    uint64_t v12 = *v10;
    uint64_t v11 = (std::__shared_weak_count *)v10[1];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v12) {
      operator new();
    }
    if (v11) {
      sub_10004D2C8(v11);
    }
    wis::MetricContainer::~MetricContainer(v9);
    operator delete();
  }
}

void sub_100BA8FCC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BA906C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 64));
  uint64_t v2 = sub_100BA8CE8(2);
  uint64_t v3 = *(void *)(v1 + 432);
  uint64_t v4 = v2 - *(void *)(v1 + 440) + *(void *)(v1 + 424);
  *(void *)(v1 + 424) = 0;
  *(void *)(v1 + 440) = v2;
  v13.tv_sec = 0;
  *(void *)&v13.tv_usec = 0;
  gettimeofday(&v13, 0);
  uint64_t v5 = 1000 * v13.tv_sec + v13.tv_usec / 0x3E8uLL;
  *(void *)(v1 + 432) = v5;
  sub_100BA7D68(@"CellularBytesRecved", *(void *)(v1 + 424), v5);
  uint64_t v6 = (wis::MetricFactory *)pthread_mutex_unlock((pthread_mutex_t *)(v1 + 64));
  v13.tv_sec = (__darwin_time_t)_NSConcreteStackBlock;
  *(void *)&v13.tv_usec = 0x40000000;
  uint64_t v14 = sub_100BA97F8;
  xpc_object_t v15 = &unk_101A42FC8;
  uint64_t v16 = v4;
  uint64_t v17 = v3;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v6);
  uint64_t v8 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x80028u);
  if (v8)
  {
    uint64_t v9 = (wis::MetricContainer *)v8;
    uint64_t v10 = sub_10001C8F4(8);
    uint64_t v12 = *v10;
    uint64_t v11 = (std::__shared_weak_count *)v10[1];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v12) {
      operator new();
    }
    if (v11) {
      sub_10004D2C8(v11);
    }
    wis::MetricContainer::~MetricContainer(v9);
    operator delete();
  }
}

void sub_100BA9274(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100BA9314(void *a1)
{
  *a1 = off_101A42F18;
  uint64_t v2 = a1[56];
  a1[56] = 0;
  if (v2) {
    operator delete();
  }
  uint64_t v3 = a1[49];
  a1[49] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[48];
  a1[48] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = a1[47];
  a1[47] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = a1[46];
  a1[46] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = a1[45];
  a1[45] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = a1[44];
  a1[44] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = a1[43];
  a1[43] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = a1[42];
  a1[42] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = a1[41];
  a1[41] = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = a1[40];
  a1[40] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  timeval v13 = (std::__shared_weak_count *)a1[7];
  if (v13) {
    sub_10004D2C8(v13);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100BA9578(void *a1)
{
  sub_100BA9314(a1);

  operator delete();
}

uint64_t sub_100BA95B0(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 320) + 16))(*(void *)(a1 + 320));
  (*(void (**)(void))(**(void **)(a1 + 328) + 16))(*(void *)(a1 + 328));
  (*(void (**)(void))(**(void **)(a1 + 336) + 16))(*(void *)(a1 + 336));
  (*(void (**)(void))(**(void **)(a1 + 344) + 16))(*(void *)(a1 + 344));
  (*(void (**)(void))(**(void **)(a1 + 352) + 16))(*(void *)(a1 + 352));
  (*(void (**)(void))(**(void **)(a1 + 360) + 16))(*(void *)(a1 + 360));
  (*(void (**)(void))(**(void **)(a1 + 368) + 16))(*(void *)(a1 + 368));
  (*(void (**)(void))(**(void **)(a1 + 376) + 16))(*(void *)(a1 + 376));
  (*(void (**)(void))(**(void **)(a1 + 384) + 16))(*(void *)(a1 + 384));
  (*(void (**)(void))(**(void **)(a1 + 392) + 16))(*(void *)(a1 + 392));
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 64));
  uint64_t v2 = sub_100BA8CE8(1);
  uint64_t v3 = *(void *)(a1 + 408);
  uint64_t v4 = *(void *)(a1 + 400) + v2 - *(void *)(a1 + 416);
  *(void *)(a1 + 400) = v4;
  *(void *)(a1 + 416) = v2;
  sub_100BA7D68(@"CellularBytesSent", v4, v3);
  uint64_t v5 = sub_100BA8CE8(2);
  uint64_t v6 = *(void *)(a1 + 432);
  uint64_t v7 = *(void *)(a1 + 424) + v5 - *(void *)(a1 + 440);
  *(void *)(a1 + 424) = v7;
  *(void *)(a1 + 440) = v5;
  sub_100BA7D68(@"CellularBytesRecved", v7, v6);

  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 64));
}

uint64_t sub_100BA97D8(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 36);
  *(void *)(a2 + 8) = *(void *)(result + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 36) = v2 | 3;
  *(void *)(a2 + 16) = v3;
  return result;
}

uint64_t sub_100BA97F8(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 36);
  *(void *)(a2 + 8) = *(void *)(result + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 36) = v2 | 3;
  *(void *)(a2 + 16) = v3;
  return result;
}

uint64_t sub_100BA9818(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    uint64_t v4 = (wis::MetricContainer *)v3;
    uint64_t v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    uint64_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100BA9974(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

__n128 sub_100BA99F8(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD **)(a1 + 32);
  int v3 = *(_DWORD *)(a2 + 136);
  int v4 = v2[53];
  *(_DWORD *)(a2 + 136) = v3 | 0x80;
  int v5 = v2[69];
  *(_DWORD *)(a2 + 136) = v3 | 0x800080;
  LODWORD(v6) = v2[52];
  *(_DWORD *)(a2 + 136) = v3 | 0x8000C0;
  int v7 = v2[55];
  *(_DWORD *)(a2 + 136) = v3 | 0x8002C0;
  int v8 = v2[51];
  *(_DWORD *)(a2 + 136) = v3 | 0x8002E0;
  LODWORD(v9) = v2[48];
  *(_DWORD *)(a2 + 136) = v3 | 0x8002E4;
  DWORD1(v9) = v2[49];
  *(_DWORD *)(a2 + 136) = v3 | 0x8002EC;
  DWORD2(v9) = v2[50];
  *(_DWORD *)(a2 + 136) = v3 | 0x8002FC;
  HIDWORD(v9) = v8;
  *(_OWORD *)(a2 + 24) = v9;
  DWORD1(v6) = v4;
  DWORD2(v6) = v2[54];
  *(_DWORD *)(a2 + 136) = v3 | 0x8003FC;
  HIDWORD(v6) = v7;
  *(_OWORD *)(a2 + 40) = v6;
  v3 |= 0x8203FCu;
  int v10 = v3 | 0x90000;
  int v11 = v3 | 0x98000;
  int v12 = v3 | 0x99000;
  int v13 = v3 | 0x9B000;
  int v14 = v3 | 0x9F000;
  int v15 = v3 | 0xDF000;
  unsigned __int32 v16 = v2[63];
  *(_DWORD *)(a2 + 136) = v3;
  result.n128_u32[0] = v2[62];
  *(_DWORD *)(a2 + 136) = v3 | 0x10000;
  unsigned __int32 v17 = v2[65];
  *(_DWORD *)(a2 + 136) = v10;
  int v18 = v2[61];
  *(_DWORD *)(a2 + 136) = v11;
  LODWORD(v9) = v2[58];
  *(_DWORD *)(a2 + 136) = v12;
  DWORD1(v9) = v2[59];
  *(_DWORD *)(a2 + 136) = v13;
  DWORD2(v9) = v2[60];
  *(_DWORD *)(a2 + 136) = v14;
  HIDWORD(v9) = v18;
  *(_OWORD *)(a2 + 64) = v9;
  result.n128_u32[1] = v16;
  result.n128_u32[2] = v2[64];
  *(_DWORD *)(a2 + 136) = v15;
  result.n128_u32[3] = v17;
  *(__n128 *)(a2 + 80) = result;
  int v20 = v2[78] + v2[75] + v2[76] + v2[74] + v2[71] + v2[72] + v2[73] + v2[70];
  v2[70] = v20;
  *(_DWORD *)(a2 + 136) |= 0x1000000u;
  *(_DWORD *)(a2 + 108) = v5;
  *(_DWORD *)(a2 + 112) = v20;
  return result;
}

uint64_t sub_100BA9BAC(uint64_t a1, int a2, int a3, char a4, int a5, int a6, int a7)
{
  int v14 = (pthread_mutex_t *)(a1 + 128);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
  switch(a6)
  {
    case 0:
      if (a5)
      {
        *(_DWORD *)(a1 + 212) += a2;
      }
      else if (a7)
      {
        *(_DWORD *)(a1 + 252) += a2;
      }
      else
      {
        *(_DWORD *)(a1 + 304) += a2;
      }
      break;
    case 2:
      if (a5)
      {
        *(_DWORD *)(a1 + 220) += a2;
      }
      else if (a7)
      {
        *(_DWORD *)(a1 + 260) += a2;
      }
      else
      {
        *(_DWORD *)(a1 + 312) += a2;
      }
      break;
    case 3:
      if (!a5)
      {
        if (a3 == 13) {
          int v16 = 0;
        }
        else {
          int v16 = a2;
        }
        if (a3 == 13) {
          int v17 = a2;
        }
        else {
          int v17 = 0;
        }
        if (a7)
        {
          *(_DWORD *)(a1 + 232) += v16;
          goto LABEL_48;
        }
        *(_DWORD *)(a1 + 284) += v16;
        goto LABEL_66;
      }
      if (a3 == 13) {
        goto LABEL_22;
      }
      *(_DWORD *)(a1 + 192) += a2;
      break;
    case 4:
      if (a5)
      {
        if (a3 == 13) {
          goto LABEL_22;
        }
        *(_DWORD *)(a1 + 196) += a2;
      }
      else
      {
        if (a3 == 13) {
          int v18 = 0;
        }
        else {
          int v18 = a2;
        }
        if (a3 == 13) {
          int v17 = a2;
        }
        else {
          int v17 = 0;
        }
        if ((a7 & 1) == 0)
        {
          *(_DWORD *)(a1 + 288) += v18;
          goto LABEL_66;
        }
        *(_DWORD *)(a1 + 236) += v18;
LABEL_48:
        *(_DWORD *)(a1 + 244) += v17;
      }
      break;
    case 5:
      if (a5)
      {
        if (a3 == 13) {
LABEL_22:
        }
          *(_DWORD *)(a1 + 204) += a2;
        else {
          *(_DWORD *)(a1 + 200) += a2;
        }
      }
      else
      {
        if (a3 == 13) {
          int v19 = 0;
        }
        else {
          int v19 = a2;
        }
        if (a3 == 13) {
          int v17 = a2;
        }
        else {
          int v17 = 0;
        }
        if (a7)
        {
          int v20 = *(_DWORD *)(a1 + 244) + v17;
          *(_DWORD *)(a1 + 240) += v19;
          *(_DWORD *)(a1 + 244) = v20;
        }
        else
        {
          *(_DWORD *)(a1 + 292) += v19;
LABEL_66:
          *(_DWORD *)(a1 + 296) += v17;
        }
      }
      break;
    case 7:
    case 8:
      if ((a4 & 1) != 0 && a5)
      {
        *(_DWORD *)(a1 + 276) += a2;
      }
      else if ((a4 & 2) != 0 && a5)
      {
        *(_DWORD *)(a1 + 208) += a2;
      }
      else if (a7)
      {
        *(_DWORD *)(a1 + 248) += a2;
      }
      else
      {
        *(_DWORD *)(a1 + 300) += a2;
      }
      break;
    case 9:
      if (a5)
      {
        *(_DWORD *)(a1 + 216) += a2;
      }
      else if (a7)
      {
        *(_DWORD *)(a1 + 256) += a2;
      }
      else
      {
        *(_DWORD *)(a1 + 308) += a2;
      }
      break;
    default:
      if (a7) {
        int v15 = a2;
      }
      else {
        int v15 = 0;
      }
      *(_DWORD *)(a1 + 280) += v15;
      break;
  }

  return pthread_mutex_unlock(v14);
}

uint64_t sub_100BA9E84(uint64_t a1, int a2)
{
  *(void *)a1 = off_101A43018;
  *(_DWORD *)(a1 + 8) = a2;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 16), 0);
  sub_10017B514();
  return a1;
}

uint64_t sub_100BA9F34(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 16));
  uint64_t v2 = *(void *)(v1 + 80);
  uint64_t v3 = *(void *)(v1 + 88);
  *(void *)(v1 + 80) = 0;
  v7.tv_sec = 0;
  *(void *)&v7.tv_usec = 0;
  gettimeofday(&v7, 0);
  *(void *)(v1 + 88) = 1000 * v7.tv_sec + v7.tv_usec / 0x3E8uLL;
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 16));
  uint64_t v4 = *(unsigned int *)(v1 + 8);
  int v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v1 + 24);

  return v5(v1, v4, v2, v3);
}

uint64_t sub_100BAA000(uint64_t a1)
{
  *(void *)a1 = off_101A43018;
  uint64_t v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_destroy(v2);
  return a1;
}

uint64_t sub_100BAA060(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (wis::MetricFactory *)pthread_mutex_lock((pthread_mutex_t *)v1);
  int v10 = _NSConcreteStackBlock;
  uint64_t v11 = 0x40000000;
  int v12 = sub_100BAA788;
  int v13 = &unk_101A43098;
  uint64_t v14 = v1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v2);
  uint64_t v4 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x8002Bu);
  if (v4)
  {
    int v5 = (wis::MetricContainer *)v4;
    long long v6 = sub_10001C8F4(8);
    uint64_t v8 = *v6;
    timeval v7 = (std::__shared_weak_count *)v6[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v8) {
      operator new();
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
    wis::MetricContainer::~MetricContainer(v5);
    operator delete();
  }
  *(_DWORD *)(v1 + 120) = 0;
  *(_OWORD *)(v1 + 104) = 0u;
  *(_OWORD *)(v1 + 88) = 0u;
  return pthread_mutex_unlock((pthread_mutex_t *)v1);
}

void sub_100BAA204(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAA2A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (wis::MetricFactory *)pthread_mutex_lock((pthread_mutex_t *)v1);
  int v10 = _NSConcreteStackBlock;
  uint64_t v11 = 0x40000000;
  int v12 = sub_100BAA814;
  int v13 = &unk_101A430B8;
  uint64_t v14 = v1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v2);
  uint64_t v4 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x80032u);
  if (v4)
  {
    int v5 = (wis::MetricContainer *)v4;
    long long v6 = sub_10001C8F4(8);
    uint64_t v8 = *v6;
    timeval v7 = (std::__shared_weak_count *)v6[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v8) {
      operator new();
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
    wis::MetricContainer::~MetricContainer(v5);
    operator delete();
  }
  *(_OWORD *)(v1 + 152) = 0u;
  *(_OWORD *)(v1 + 140) = 0u;
  *(_OWORD *)(v1 + 124) = 0u;
  *(void *)(v1 + 176) = time(0);
  return pthread_mutex_unlock((pthread_mutex_t *)v1);
}

void sub_100BAA454(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAA4F4(uint64_t a1, char a2)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  *(unsigned char *)(a1 + 65) = a2;
  sub_100BAA53C(a1);

  return pthread_mutex_unlock((pthread_mutex_t *)a1);
}

time_t sub_100BAA53C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64) || *(unsigned char *)(a1 + 65))
  {
    *(void *)(a1 + 76) = -1;
    *(void *)(a1 + 68) = -1;
  }
  time_t result = time(0);
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  if ((v3 & 0x80000000) == 0)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 76);
    if ((v4 & 0x80000000) == 0)
    {
      unsigned int v5 = *(_DWORD *)(a1 + 72);
      if ((v5 & 0x80000000) == 0 && v5 <= 5 && v4 <= 5 && v3 <= 5)
      {
        unsigned int v6 = *(_DWORD *)(a1 + 68);
        if ((v6 & 0x80000000) == 0 && result - *(void *)(a1 + 168) <= 30)
        {
          uint64_t v7 = 0;
          char v8 = 1;
          if (v4 > v3 && v5 < v4 && v6 > v5)
          {
            switch(v4)
            {
              case 1u:
                char v8 = 0;
                uint64_t v7 = 2;
                break;
              case 2u:
                char v8 = 0;
                uint64_t v7 = 3;
                break;
              case 3u:
                char v8 = 0;
                uint64_t v7 = 4;
                break;
              case 4u:
                char v8 = 0;
                uint64_t v7 = 5;
                break;
              default:
                uint64_t v7 = 0;
                break;
            }
          }
          if (v4 >= v3 || v5 <= v4 || v6 >= v5 || (uint64_t v9 = v4 - 1, v9 >= 4))
          {
            if (v8) {
              goto LABEL_28;
            }
          }
          else
          {
            uint64_t v7 = v9 + 6;
          }
          ++*(_DWORD *)(a1 + 4 * v7 + 124);
        }
      }
    }
  }
LABEL_28:
  uint64_t v10 = *(void *)(a1 + 168);
  if (v10)
  {
    uint64_t v11 = a1 + 4 * *(unsigned int *)(a1 + 84);
    *(_DWORD *)(v11 + 88) += result - v10;
  }
  *(void *)(a1 + 168) = result;
  if (*(unsigned char *)(a1 + 64))
  {
    int v12 = 2;
  }
  else
  {
    if (v3 >= 6) {
      int v12 = 0;
    }
    else {
      int v12 = v3 + 3;
    }
    if (*(unsigned char *)(a1 + 65)) {
      int v12 = 1;
    }
  }
  *(_DWORD *)(a1 + 84) = v12;
  return result;
}

uint64_t sub_100BAA6EC(uint64_t a1, int a2)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  *(void *)(a1 + 68) = *(void *)(a1 + 72);
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = a2;
  sub_100BAA53C(a1);

  return pthread_mutex_unlock((pthread_mutex_t *)a1);
}

uint64_t sub_100BAA740(uint64_t a1, char a2)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  *(unsigned char *)(a1 + 64) = a2;
  sub_100BAA53C(a1);

  return pthread_mutex_unlock((pthread_mutex_t *)a1);
}

uint64_t sub_100BAA788(uint64_t result, _DWORD *a2)
{
  uint64_t v2 = *(_DWORD **)(result + 32);
  int v3 = v2[25];
  int v4 = a2[13];
  a2[13] = v4 | 2;
  a2[4] = v3;
  int v5 = v2[26];
  a2[13] = v4 | 6;
  a2[5] = v5;
  int v6 = v2[27];
  a2[13] = v4 | 0xE;
  a2[6] = v6;
  int v7 = v2[28];
  a2[13] = v4 | 0x1E;
  a2[7] = v7;
  int v8 = v2[29];
  a2[13] = v4 | 0x3E;
  a2[8] = v8;
  int v9 = v2[30];
  a2[13] = v4 | 0x7E;
  a2[9] = v9;
  int v10 = v2[23];
  a2[13] = v4 | 0xFE;
  a2[10] = v10;
  LODWORD(v2) = v2[24];
  a2[13] = v4 | 0x1FE;
  a2[11] = v2;
  return result;
}

uint64_t sub_100BAA814(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 32);
  int v3 = *(_DWORD *)(v2 + 128);
  int v4 = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 68) = v4 | 4;
  *(_DWORD *)(a2 + 24) = v3;
  int v5 = *(_DWORD *)(v2 + 132);
  *(_DWORD *)(a2 + 68) = v4 | 0xC;
  *(_DWORD *)(a2 + 28) = v5;
  int v6 = *(_DWORD *)(v2 + 136);
  *(_DWORD *)(a2 + 68) = v4 | 0x1C;
  *(_DWORD *)(a2 + 32) = v6;
  int v7 = *(_DWORD *)(v2 + 140);
  *(_DWORD *)(a2 + 68) = v4 | 0x3C;
  *(_DWORD *)(a2 + 36) = v7;
  int v8 = *(_DWORD *)(v2 + 144);
  *(_DWORD *)(a2 + 68) = v4 | 0x7C;
  *(_DWORD *)(a2 + 40) = v8;
  int v9 = *(_DWORD *)(v2 + 148);
  *(_DWORD *)(a2 + 68) = v4 | 0xFC;
  *(_DWORD *)(a2 + 44) = v9;
  int v10 = *(_DWORD *)(v2 + 152);
  *(_DWORD *)(a2 + 68) = v4 | 0x1FC;
  *(_DWORD *)(a2 + 48) = v10;
  int v11 = *(_DWORD *)(v2 + 156);
  *(_DWORD *)(a2 + 68) = v4 | 0x3FC;
  *(_DWORD *)(a2 + 52) = v11;
  int v12 = *(_DWORD *)(v2 + 160);
  *(_DWORD *)(a2 + 68) = v4 | 0x7FC;
  *(_DWORD *)(a2 + 56) = v12;
  int v13 = *(_DWORD *)(v2 + 164);
  *(_DWORD *)(a2 + 68) = v4 | 0xFFC;
  *(_DWORD *)(a2 + 60) = v13;
  uint64_t v14 = *(void *)(v2 + 176);
  if (v14)
  {
    *(_DWORD *)(a2 + 68) = v4 | 0xFFE;
    *(void *)(a2 + 16) = v14;
  }
  return result;
}

void sub_100BAA8D4(uint64_t a1, void *a2)
{
  int v3 = operator new(0x1E0uLL);
  sub_100BAA948(v3, a2);
}

void sub_100BAA934(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_100BAA948(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A43190;
  sub_100BA8080((uint64_t)(a1 + 3), a2);
}

void sub_100BAA990(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100BAA9A4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A43190;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BAA9C4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A43190;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BAAA18(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

unint64_t sub_100BAAA40(id a1)
{
  return 0;
}

void sub_100BAAA4C(uint64_t a1)
{
  sub_100BAA000(a1);

  operator delete();
}

uint64_t sub_100BAAA84(uint64_t a1)
{
  return sub_100BA7D68(*(const __CFString **)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88));
}

void sub_100BAAA94(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v7 = (wis::MetricFactory *)sub_100BA7D68(*(const __CFString **)(a1 + 96), a3, a4);
  uint64_t v14 = _NSConcreteStackBlock;
  uint64_t v15 = 0x40000000;
  int v16 = sub_100BAACCC;
  int v17 = &unk_101A43258;
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v7);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v9)
  {
    int v10 = (wis::MetricContainer *)v9;
    int v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
}

void sub_100BAAC2C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAACCC(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 24) = *(void *)(result + 32);
  *(_DWORD *)(a2 + 32) = v2 | 3;
  *(void *)(a2 + 8) = v3;
  return result;
}

unint64_t sub_100BAACE8(id a1)
{
  return 0;
}

void sub_100BAACF4(uint64_t a1)
{
  sub_100BAA000(a1);

  operator delete();
}

uint64_t sub_100BAAD2C(uint64_t a1)
{
  return sub_100BA7D68(*(const __CFString **)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88));
}

void sub_100BAAD3C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v7 = (wis::MetricFactory *)sub_100BA7D68(*(const __CFString **)(a1 + 96), a3, a4);
  uint64_t v14 = _NSConcreteStackBlock;
  uint64_t v15 = 0x40000000;
  int v16 = sub_100BAAF74;
  int v17 = &unk_101A43300;
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v7);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v9)
  {
    int v10 = (wis::MetricContainer *)v9;
    int v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
}

void sub_100BAAED4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAAF74(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 24) = *(void *)(result + 32);
  *(_DWORD *)(a2 + 32) = v2 | 3;
  *(void *)(a2 + 8) = v3;
  return result;
}

unint64_t sub_100BAAF90(id a1)
{
  return 0;
}

void sub_100BAAF9C(uint64_t a1)
{
  sub_100BAA000(a1);

  operator delete();
}

uint64_t sub_100BAAFD4(uint64_t a1)
{
  return sub_100BA7D68(*(const __CFString **)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88));
}

void sub_100BAAFE4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v7 = (wis::MetricFactory *)sub_100BA7D68(*(const __CFString **)(a1 + 96), a3, a4);
  uint64_t v14 = _NSConcreteStackBlock;
  uint64_t v15 = 0x40000000;
  int v16 = sub_100BAB21C;
  int v17 = &unk_101A433A8;
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v7);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v9)
  {
    int v10 = (wis::MetricContainer *)v9;
    int v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
}

void sub_100BAB17C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAB21C(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 24) = *(void *)(result + 32);
  *(_DWORD *)(a2 + 32) = v2 | 3;
  *(void *)(a2 + 8) = v3;
  return result;
}

unint64_t sub_100BAB238(id a1)
{
  return 0;
}

void sub_100BAB244(uint64_t a1)
{
  sub_100BAA000(a1);

  operator delete();
}

uint64_t sub_100BAB27C(uint64_t a1)
{
  return sub_100BA7D68(*(const __CFString **)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88));
}

void sub_100BAB28C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v7 = (wis::MetricFactory *)sub_100BA7D68(*(const __CFString **)(a1 + 96), a3, a4);
  uint64_t v14 = _NSConcreteStackBlock;
  uint64_t v15 = 0x40000000;
  int v16 = sub_100BAB4C4;
  int v17 = &unk_101A43450;
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v7);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v9)
  {
    int v10 = (wis::MetricContainer *)v9;
    int v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
}

void sub_100BAB424(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAB4C4(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 24) = *(void *)(result + 32);
  *(_DWORD *)(a2 + 32) = v2 | 3;
  *(void *)(a2 + 8) = v3;
  return result;
}

unint64_t sub_100BAB4E0(id a1)
{
  return 0;
}

void sub_100BAB4EC(uint64_t a1)
{
  sub_100BAA000(a1);

  operator delete();
}

uint64_t sub_100BAB524(uint64_t a1)
{
  return sub_100BA7D68(*(const __CFString **)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88));
}

void sub_100BAB534(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v7 = (wis::MetricFactory *)sub_100BA7D68(*(const __CFString **)(a1 + 96), a3, a4);
  uint64_t v14 = _NSConcreteStackBlock;
  uint64_t v15 = 0x40000000;
  int v16 = sub_100BAB76C;
  int v17 = &unk_101A434F8;
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v7);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v9)
  {
    int v10 = (wis::MetricContainer *)v9;
    int v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
}

void sub_100BAB6CC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAB76C(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 24) = *(void *)(result + 32);
  *(_DWORD *)(a2 + 32) = v2 | 3;
  *(void *)(a2 + 8) = v3;
  return result;
}

unint64_t sub_100BAB788(id a1)
{
  return 0;
}

void sub_100BAB794(uint64_t a1)
{
  sub_100BAA000(a1);

  operator delete();
}

uint64_t sub_100BAB7CC(uint64_t a1)
{
  return sub_100BA7D68(*(const __CFString **)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88));
}

void sub_100BAB7DC(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v7 = (wis::MetricFactory *)sub_100BA7D68(*(const __CFString **)(a1 + 96), a3, a4);
  uint64_t v14 = _NSConcreteStackBlock;
  uint64_t v15 = 0x40000000;
  int v16 = sub_100BABA14;
  int v17 = &unk_101A435A0;
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v7);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v9)
  {
    int v10 = (wis::MetricContainer *)v9;
    int v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
}

void sub_100BAB974(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BABA14(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 24) = *(void *)(result + 32);
  *(_DWORD *)(a2 + 32) = v2 | 3;
  *(void *)(a2 + 8) = v3;
  return result;
}

unint64_t sub_100BABA30(id a1)
{
  return 0;
}

void sub_100BABA3C(uint64_t a1)
{
  sub_100BAA000(a1);

  operator delete();
}

uint64_t sub_100BABA74(uint64_t a1)
{
  return sub_100BA7D68(*(const __CFString **)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88));
}

void sub_100BABA84(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v7 = (wis::MetricFactory *)sub_100BA7D68(*(const __CFString **)(a1 + 96), a3, a4);
  uint64_t v14 = _NSConcreteStackBlock;
  uint64_t v15 = 0x40000000;
  int v16 = sub_100BABCBC;
  int v17 = &unk_101A43648;
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v7);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v9)
  {
    int v10 = (wis::MetricContainer *)v9;
    int v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
}

void sub_100BABC1C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BABCBC(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 24) = *(void *)(result + 32);
  *(_DWORD *)(a2 + 32) = v2 | 3;
  *(void *)(a2 + 8) = v3;
  return result;
}

unint64_t sub_100BABCD8(id a1)
{
  return 0;
}

void sub_100BABCE4(uint64_t a1)
{
  sub_100BAA000(a1);

  operator delete();
}

uint64_t sub_100BABD1C(uint64_t a1)
{
  return sub_100BA7D68(*(const __CFString **)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88));
}

void sub_100BABD2C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v7 = (wis::MetricFactory *)sub_100BA7D68(*(const __CFString **)(a1 + 96), a3, a4);
  uint64_t v14 = _NSConcreteStackBlock;
  uint64_t v15 = 0x40000000;
  int v16 = sub_100BABF64;
  int v17 = &unk_101A436F0;
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v7);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v9)
  {
    int v10 = (wis::MetricContainer *)v9;
    int v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
}

void sub_100BABEC4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BABF64(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 24) = *(void *)(result + 32);
  *(_DWORD *)(a2 + 32) = v2 | 3;
  *(void *)(a2 + 8) = v3;
  return result;
}

unint64_t sub_100BABF80(id a1)
{
  return 0;
}

void sub_100BABF8C(uint64_t a1)
{
  sub_100BAA000(a1);

  operator delete();
}

uint64_t sub_100BABFC4(uint64_t a1)
{
  return sub_100BA7D68(*(const __CFString **)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88));
}

void sub_100BABFD4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v7 = (wis::MetricFactory *)sub_100BA7D68(*(const __CFString **)(a1 + 96), a3, a4);
  uint64_t v14 = _NSConcreteStackBlock;
  uint64_t v15 = 0x40000000;
  int v16 = sub_100BAC20C;
  int v17 = &unk_101A43798;
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v7);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v9)
  {
    int v10 = (wis::MetricContainer *)v9;
    int v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
}

void sub_100BAC16C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAC20C(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 24) = *(void *)(result + 32);
  *(_DWORD *)(a2 + 32) = v2 | 3;
  *(void *)(a2 + 8) = v3;
  return result;
}

unint64_t sub_100BAC228(id a1)
{
  return 0;
}

void sub_100BAC234(uint64_t a1)
{
  sub_100BAA000(a1);

  operator delete();
}

uint64_t sub_100BAC26C(uint64_t a1)
{
  return sub_100BA7D68(*(const __CFString **)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88));
}

void sub_100BAC27C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v7 = (wis::MetricFactory *)sub_100BA7D68(*(const __CFString **)(a1 + 96), a3, a4);
  uint64_t v14 = _NSConcreteStackBlock;
  uint64_t v15 = 0x40000000;
  int v16 = sub_100BAC4B4;
  int v17 = &unk_101A43840;
  uint64_t v18 = a3;
  uint64_t v19 = a4;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(v7);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v9)
  {
    int v10 = (wis::MetricContainer *)v9;
    int v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
}

void sub_100BAC414(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BAC4B4(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  uint64_t v3 = *(void *)(result + 40);
  *(_DWORD *)(a2 + 24) = *(void *)(result + 32);
  *(_DWORD *)(a2 + 32) = v2 | 3;
  *(void *)(a2 + 8) = v3;
  return result;
}

uint64_t sub_100BAC4D0(char *a1, size_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return vsnprintf(a1, a2, a3, &a9);
}

const void **sub_100BAC4FC@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = 0;
  *(void *)&long long v4 = MGCopyAnswer();
  sub_100225AE0(&v3, (CFTypeRef *)&v4);
  long long v4 = 0uLL;
  uint64_t v5 = 0;
  ctu::cf::assign();
  *(_OWORD *)a1 = v4;
  *(void *)(a1 + 16) = v5;
  return sub_1000558F4(&v3);
}

void sub_100BAC574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)&a9);
  _Unwind_Resume(a1);
}

const void **sub_100BAC598@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = 0;
  *(void *)&long long v4 = MGCopyAnswer();
  sub_100225AE0(&v3, (CFTypeRef *)&v4);
  long long v4 = 0uLL;
  uint64_t v5 = 0;
  ctu::cf::assign();
  *(_OWORD *)a1 = v4;
  *(void *)(a1 + 16) = v5;
  return sub_1000558F4(&v3);
}

void sub_100BAC610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)&a9);
  _Unwind_Resume(a1);
}

const void **sub_100BAC634@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = 0;
  *(void *)&long long v4 = MGCopyAnswer();
  sub_100225AE0(&v3, (CFTypeRef *)&v4);
  long long v4 = 0uLL;
  uint64_t v5 = 0;
  ctu::cf::assign();
  *(_OWORD *)a1 = v4;
  *(void *)(a1 + 16) = v5;
  return sub_1000558F4(&v3);
}

void sub_100BAC6AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)&a9);
  _Unwind_Resume(a1);
}

const void **sub_100BAC6D0@<X0>(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  int v6 = 0;
  uint64_t v7 = MGCopyAnswer();
  sub_100225AE0(&v6, (CFTypeRef *)&v7);
  if (v6) {
    int v2 = sub_1000810B8;
  }
  else {
    int v2 = 0;
  }
  if (v2)
  {
    uint64_t v7 = 0;
    long long v8 = 0uLL;
    ctu::cf::assign();
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)((char *)&v8 + 7);
    *(void *)a1 = v7;
    *(void *)(a1 + 8) = v3;
    *(void *)(a1 + 15) = v4;
    *(unsigned char *)(a1 + 23) = HIBYTE(v8);
  }
  return sub_1000558F4(&v6);
}

void sub_100BAC774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100BAC798()
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  size_t v1 = 16;
  if (!sysctlbyname("kern.boottime", &v2, &v1, 0, 0)) {
    return v2;
  }
  uint64_t result = 0;
  LODWORD(v3) = 0;
  return result;
}

const void **sub_100BAC7F4@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  CFDataRef theData = 0;
  uint64_t v6 = MGCopyAnswer();
  sub_1000171E8(&theData, (CFTypeRef *)&v6);
  if (theData) {
    uint64_t v2 = sub_10008324C;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2 && CFDataGetLength(theData))
  {
    BytePtr = (char *)CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    sub_10006E4A8(a1, BytePtr, &BytePtr[Length], Length);
  }
  return sub_100030068((const void **)&theData);
}

void sub_100BAC8A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100030068((const void **)va);
  uint64_t v4 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

const void **sub_100BAC8C8@<X0>(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  memset(&v16, 0, sizeof(v16));
  uint64_t result = (const void **)stat("/System/Library/CoreServices/SystemVersion.plist", &v16);
  if (!result)
  {
    CFURLRef v3 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, @"/System/Library/CoreServices/SystemVersion.plist", kCFURLPOSIXPathStyle, 0);
    CFURLRef v15 = v3;
    if (v3) {
      uint64_t v4 = sub_1000FCC20;
    }
    else {
      uint64_t v4 = 0;
    }
    if (v4)
    {
      uint64_t v5 = CFReadStreamCreateWithFile(kCFAllocatorDefault, v3);
      CFReadStreamRef stream = v5;
      if (v5) {
        uint64_t v6 = sub_1007EEA34;
      }
      else {
        uint64_t v6 = 0;
      }
      if (v6)
      {
        CFReadStreamOpen(v5);
        CFDictionaryRef theDict = 0;
        CFPropertyListFormat format = 0;
        CFTypeRef Value = CFPropertyListCreateWithStream(kCFAllocatorDefault, stream, 0, 0, &format, 0);
        sub_100084068(&theDict, &Value);
        if (theDict) {
          uint64_t v7 = sub_100080778;
        }
        else {
          uint64_t v7 = 0;
        }
        if (v7)
        {
          int v11 = 0;
          CFTypeRef Value = CFDictionaryGetValue(theDict, @"ProductBuildVersion");
          sub_100056248(&v11, &Value);
          if (v11) {
            long long v8 = sub_1000810B8;
          }
          else {
            long long v8 = 0;
          }
          if (v8)
          {
            CFTypeRef Value = 0;
            long long v18 = 0uLL;
            ctu::cf::assign();
            uint64_t v9 = v18;
            uint64_t v10 = *(void *)((char *)&v18 + 7);
            *(void *)a1 = Value;
            *(void *)(a1 + 8) = v9;
            *(void *)(a1 + 15) = v10;
            *(unsigned char *)(a1 + 23) = HIBYTE(v18);
          }
          sub_1000558F4(&v11);
        }
        sub_100057D78((const void **)&theDict);
      }
      sub_1007EF408((const void **)&stream);
    }
    return sub_1000FE824((const void **)&v15);
  }
  return result;
}

void sub_100BACA7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  uint64_t v8 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v9 = va_arg(va3, const void *);
  if (*(char *)(v2 - 33) < 0) {
    operator delete(*(void **)(v2 - 56));
  }
  sub_1000558F4((const void **)va);
  sub_100057D78((const void **)va1);
  sub_1007EF408((const void **)va2);
  sub_1000FE824((const void **)va3);
  _Unwind_Resume(a1);
}

BOOL ImsSmsCommandDriverDelegate::setMessageDelegate(ImsSmsCommandDriverDelegate *this)
{
  uint64_t v2 = (Registry **)((char *)this + 32);
  if (subscriber::isValidSimSlot())
  {
    CFURLRef v3 = (std::__shared_weak_count *)*((void *)this + 7);
    if (v3)
    {
      uint64_t v5 = std::__shared_weak_count::lock(v3);
      if (v5)
      {
        uint64_t v6 = *((void *)this + 6);
        if (v6)
        {
          uint64_t v34 = 0;
          long long v35 = 0;
          ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *v2);
          uint64_t v8 = ServiceMap;
          if (v9 < 0)
          {
            uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v11 = 5381;
            do
            {
              uint64_t v9 = v11;
              unsigned int v12 = *v10++;
              uint64_t v11 = (33 * v11) ^ v12;
            }
            while (v12);
          }
          std::mutex::lock(ServiceMap);
          __p[0] = (void *)v9;
          uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
          if (v13)
          {
            uint64_t v15 = v13[3];
            uint64_t v14 = (std::__shared_weak_count *)v13[4];
            if (v14)
            {
              atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v8);
              atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v14);
              char v16 = 0;
LABEL_23:
              PersonalityIdFromSlotId();
              (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v15 + 24))(&v34, v15, __p);
              if (v33 < 0) {
                operator delete(__p[0]);
              }
              if ((v16 & 1) == 0) {
                sub_10004D2C8(v14);
              }
              uint64_t v21 = v34;
              BOOL v18 = v34 != 0;
              if (v34)
              {
                uint64_t v22 = (std::__shared_weak_count *)*((void *)this + 2);
                if (!v22 || (uint64_t v23 = *((void *)this + 1), (v24 = std::__shared_weak_count::lock(v22)) == 0)) {
                  sub_100088B9C();
                }
                uint64_t v25 = v24;
                int v26 = *((_DWORD *)this + 6);
                uint64_t v27 = "ims.sms.?";
                if (v26 == 2) {
                  uint64_t v27 = "ims.sms.2";
                }
                if (v26 == 1) {
                  uint64_t v28 = "ims.sms.1";
                }
                else {
                  uint64_t v28 = (char *)v27;
                }
                sub_100058DB0(__p, v28);
                uint64_t v30 = v23;
                uint64_t v31 = v25;
                atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
                (*(void (**)(uint64_t, void **, uint64_t *, void))(*(void *)v21 + 144))(v21, __p, &v30, *(void *)(v6 + 24));
                if (v31) {
                  sub_10004D2C8(v31);
                }
                if (v33 < 0) {
                  operator delete(__p[0]);
                }
                sub_10004D2C8(v25);
              }
              else
              {
                uint64_t v29 = **((void **)this + 8);
                if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(__p[0]) = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Failed to set delegate as unable to get client handle.", (uint8_t *)__p, 2u);
                }
              }
              if (v35) {
                sub_10004D2C8(v35);
              }
LABEL_18:
              if (v5) {
                sub_10004D2C8(v5);
              }
              return v18;
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          std::mutex::unlock(v8);
          uint64_t v14 = 0;
          char v16 = 1;
          goto LABEL_23;
        }
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
    uint64_t v19 = **((void **)this + 8);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to set delegate as controller reference is invalid.", (uint8_t *)__p, 2u);
    }
    BOOL v18 = 0;
    goto LABEL_18;
  }
  int v17 = **((void **)this + 8);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to set delegate as slot is invalid", (uint8_t *)__p, 2u);
  }
  return 0;
}

void sub_100BACE10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v20);
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

void sub_100BACE98(uint64_t a1, uint64_t a2)
{
  CFURLRef v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 48);
      if (v6) {
        ImsSmsCommandDriver::handleMessageSendFailure(v6, *(unsigned int *)(a1 + 24), a2);
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v7 = **(NSObject ***)(a1 + 64);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to get reference to Controller while handling SMS Send failure", v8, 2u);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_100BACF4C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100BACF60(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2)
  {
    CFURLRef v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 48);
      if (v4) {
        ImsSmsCommandDriver::handleMessageSendSuccess(v4);
      }
    }
  }
  else
  {
    CFURLRef v3 = 0;
  }
  uint64_t v5 = **(NSObject ***)(a1 + 64);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to get reference to Controller while handling SMS Send success", v6, 2u);
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100BAD004(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100BAD018(uint64_t a1, long long *a2)
{
  CFURLRef v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 48);
      if (v6)
      {
        *(_OWORD *)std::string __p = 0u;
        long long v16 = 0u;
        long long v13 = 0u;
        *(_OWORD *)uint64_t v14 = 0u;
        *(_OWORD *)uint64_t v11 = 0u;
        *(_OWORD *)unsigned int v12 = 0u;
        *(_OWORD *)uint64_t v9 = 0u;
        long long v10 = 0u;
        *(_OWORD *)uint64_t v8 = 0u;
        sub_100BAD4EC((char *)v8, a2);
        ImsSmsCommandDriver::handleMessageReceived(v6, *(unsigned int *)(a1 + 24), (long long *)v8);
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v7 = **(NSObject ***)(a1 + 64);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v8[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to get reference to Controller while handling SMS Send success", (uint8_t *)v8, 2u);
    if (!v5) {
      return;
    }
  }
  else if (!v5)
  {
    return;
  }
  sub_10004D2C8(v5);
}

void sub_100BAD158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100BAD17C((uint64_t)&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_100BAD17C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  if (v2)
  {
    *(void *)(a1 + 128) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void ImsSmsCommandDriverDelegate::sendSms(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a7, *(Registry **)(a1 + 32));
  uint64_t v14 = ServiceMap;
  if (v15 < 0)
  {
    long long v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v15;
  uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
  if (v19)
  {
    uint64_t v21 = v19[3];
    int v20 = (std::__shared_weak_count *)v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v22 = 0;
      if (!v21) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v14);
  int v20 = 0;
  char v22 = 1;
  if (!v21)
  {
LABEL_7:
    uint64_t v23 = **(NSObject ***)(a1 + 64);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "SystemDetermination interface is nil", buf, 2u);
    }
    goto LABEL_19;
  }
LABEL_11:
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  PersonalityIdFromSlotId();
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint8_t *))(*(void *)v21 + 24))(&v27, v21, buf);
  if (v26 < 0) {
    operator delete(*(void **)buf);
  }
  if (v27)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v27 + 288))(v27, a2, a3, a4, a5, a6);
  }
  else
  {
    xpc_object_t v24 = **(NSObject ***)(a1 + 64);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "imsClient is nil", buf, 2u);
    }
  }
  if (v28) {
    sub_10004D2C8(v28);
  }
LABEL_19:
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
}

void sub_100BAD460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BAD4AC(void *a1)
{
  sub_100BAD6A0(a1);

  operator delete();
}

char *sub_100BAD4EC(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(__dst + 48, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *((_OWORD *)__dst + 3) = v6;
  }
  if (*((char *)a2 + 95) < 0)
  {
    sub_10004FC84(__dst + 72, *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v7 = *(long long *)((char *)a2 + 72);
    *((void *)__dst + 11) = *((void *)a2 + 11);
    *(_OWORD *)(__dst + 72) = v7;
  }
  if (*((char *)a2 + 119) < 0)
  {
    sub_10004FC84(__dst + 96, *((void **)a2 + 12), *((void *)a2 + 13));
  }
  else
  {
    long long v8 = a2[6];
    *((void *)__dst + 14) = *((void *)a2 + 14);
    *((_OWORD *)__dst + 6) = v8;
  }
  *((void *)__dst + 15) = 0;
  *((void *)__dst + 16) = 0;
  *((void *)__dst + 17) = 0;
  sub_10005C928((void *)__dst + 15, *((const void **)a2 + 15), *((void *)a2 + 16), *((void *)a2 + 16) - *((void *)a2 + 15));
  return __dst;
}

void sub_100BAD624(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*v4);
  }
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100BAD6A0(void *a1)
{
  *a1 = off_101A43870;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  CFURLRef v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_100BAD82C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100BAD888(void *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_100BAE050(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    if (v3 != v7)
    {
      do
      {
        uint64_t v8 = v3 - 24;
        sub_1000346F8(v3 - 24, *(void **)(v3 - 16));
        uint64_t v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

uint64_t sub_100BAD92C(void *a1, unsigned int a2, unint64_t a3, unsigned int a4, uint64_t a5)
{
  unint64_t v12 = a3;
  uint64_t v5 = *a1 + 24 * a2;
  unint64_t v6 = *(void **)(v5 + 8);
  if (v6)
  {
    uint64_t v7 = v5 + 8;
    do
    {
      unint64_t v8 = v6[4];
      BOOL v9 = v8 >= a3;
      if (v8 >= a3) {
        long long v10 = v6;
      }
      else {
        long long v10 = v6 + 1;
      }
      if (v9) {
        uint64_t v7 = (uint64_t)v6;
      }
      unint64_t v6 = (void *)*v10;
    }
    while (*v10);
    if (v7 != v5 + 8 && *(void *)(v7 + 32) <= a3 && *(_DWORD *)(v7 + 40) == a4) {
      return 0;
    }
  }
  long long v13 = &v12;
  sub_100BAE280((uint64_t **)v5, &v12, (uint64_t)&unk_10144E20E, (uint64_t **)&v13)[5] = a4 | (unint64_t)(a5 << 32);
  return 1;
}

void sub_100BAD9EC(void *a1)
{
  uint64_t v1 = a1[1];
  if (*a1 != v1)
  {
    uint64_t v2 = *a1 + 8;
    do
    {
      sub_1000346F8(v2 - 8, *(void **)v2);
      *(void *)(v2 - 8) = v2;
      *(void *)uint64_t v2 = 0;
      *(void *)(v2 + 8) = 0;
      uint64_t v3 = v2 + 16;
      v2 += 24;
    }
    while (v3 != v1);
  }
}

void sub_100BADA3C(void *a1, unsigned int a2, std::string *a3)
{
  if (*(void *)(*a1 + 24 * a2 + 16))
  {
    uint64_t v5 = (char *)desenseClientAsString();
    unint64_t v6 = (std::string *)sub_100058DB0(v42, v5);
    uint64_t v7 = std::string::append(v6, ":\n", 2uLL);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    *(void *)&v28[0] = *((void *)&v7->__r_.__value_.__l + 2);
    *(_OWORD *)std::string __p = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    if ((SBYTE7(v28[0]) & 0x80u) == 0) {
      BOOL v9 = __p;
    }
    else {
      BOOL v9 = (void **)__p[0];
    }
    if ((SBYTE7(v28[0]) & 0x80u) == 0) {
      std::string::size_type v10 = BYTE7(v28[0]);
    }
    else {
      std::string::size_type v10 = (std::string::size_type)__p[1];
    }
    std::string::append(a3, (const std::string::value_type *)v9, v10);
    if (SBYTE7(v28[0]) < 0) {
      operator delete(__p[0]);
    }
    if ((char)v43 < 0) {
      operator delete(v42[0]);
    }
    uint64_t v11 = (void *)(*a1 + 24 * a2);
    uint64_t v14 = (void *)*v11;
    long long v13 = v11 + 1;
    unint64_t v12 = v14;
    if (v14 != v13)
    {
      do
      {
        uint64_t v41 = 0;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        long long v31 = 0u;
        long long v32 = 0u;
        *(_OWORD *)uint64_t v29 = 0u;
        long long v30 = 0u;
        memset(v28, 0, sizeof(v28));
        *(_OWORD *)std::string __p = 0u;
        sub_10004BD84((uint64_t)__p);
        uint64_t v17 = (void *)std::ostream::operator<<();
        sub_10004B96C(v17, (uint64_t)"\t", 1);
        unsigned int v18 = (void *)std::ostream::operator<<();
        sub_10004B96C(v18, (uint64_t)"\t", 1);
        uint64_t v19 = (void *)std::ostream::operator<<();
        sub_10004B96C(v19, (uint64_t)"\n", 1);
        sub_10004BC98((uint64_t)v28 + 8, v42);
        if ((v43 & 0x80u) == 0) {
          char v20 = (const std::string::value_type *)v42;
        }
        else {
          char v20 = (const std::string::value_type *)v42[0];
        }
        if ((v43 & 0x80u) == 0) {
          std::string::size_type v21 = v43;
        }
        else {
          std::string::size_type v21 = (std::string::size_type)v42[1];
        }
        std::string::append(a3, v20, v21);
        if ((char)v43 < 0) {
          operator delete(v42[0]);
        }
        __p[0] = v25;
        *(void **)((char *)__p + *((void *)v25 - 3)) = v15;
        *(void *)&v28[0] = v16;
        if (SHIBYTE(v30) < 0) {
          operator delete(v29[1]);
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        std::ios::~ios();
        char v22 = (void *)v12[1];
        if (v22)
        {
          do
          {
            uint64_t v23 = v22;
            char v22 = (void *)*v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            uint64_t v23 = (void *)v12[2];
            BOOL v24 = *v23 == (void)v12;
            unint64_t v12 = v23;
          }
          while (!v24);
        }
        unint64_t v12 = v23;
      }
      while (v23 != v13);
    }
  }
}

void sub_100BADD70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v16 - 97) < 0) {
    operator delete(*(void **)(v16 - 120));
  }
  _Unwind_Resume(exception_object);
}

void sub_100BADDD0(void *a1, std::string *a2)
{
  if (a1[1] != *a1)
  {
    unint64_t v4 = 0;
    do
      sub_100BADA3C(a1, v4++, a2);
    while (v4 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 3));
  }
}

uint64_t *sub_100BADE40(uint64_t *result, unsigned int a2, uint64_t **a3, uint64_t a4)
{
  unint64_t v4 = (void *)(*result + 24 * a2);
  uint64_t v7 = (void *)*v4;
  uint64_t v5 = v4 + 1;
  unint64_t v6 = v7;
  if (v7 != v5)
  {
    BOOL v9 = (void *)(a4 + 8);
    do
    {
      std::string::size_type v10 = v6 + 4;
      uint64_t v11 = (void *)*v9;
      if (!*v9) {
        goto LABEL_14;
      }
      unint64_t v12 = *v10;
      long long v13 = v9;
      do
      {
        unint64_t v14 = v11[4];
        BOOL v15 = v14 >= v12;
        if (v14 >= v12) {
          uint64_t v16 = v11;
        }
        else {
          uint64_t v16 = v11 + 1;
        }
        if (v15) {
          long long v13 = v11;
        }
        uint64_t v11 = (void *)*v16;
      }
      while (*v16);
      if (v13 == v9 || v12 < v13[4])
      {
LABEL_14:
        char v20 = v6 + 4;
        uint64_t result = sub_100BAE280(a3, v10, (uint64_t)&unk_10144E20E, &v20);
        result[5] = v6[5];
      }
      uint64_t v17 = (void *)v6[1];
      if (v17)
      {
        do
        {
          unsigned int v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          unsigned int v18 = (void *)v6[2];
          BOOL v19 = *v18 == (void)v6;
          unint64_t v6 = v18;
        }
        while (!v19);
      }
      unint64_t v6 = v18;
    }
    while (v18 != v5);
  }
  return result;
}

uint64_t *sub_100BADF38(uint64_t *result, unsigned int a2, uint64_t **a3, void *a4)
{
  unint64_t v4 = a4 + 1;
  uint64_t v5 = (void *)*a4;
  if ((void *)*a4 != a4 + 1)
  {
    uint64_t v7 = result;
    do
    {
      BOOL v9 = v5 + 4;
      uint64_t v10 = *v7 + 24 * a2;
      long long v13 = *(void **)(v10 + 8);
      uint64_t v11 = v10 + 8;
      unint64_t v12 = v13;
      if (!v13) {
        goto LABEL_15;
      }
      unint64_t v14 = *v9;
      BOOL v15 = (void *)v11;
      do
      {
        unint64_t v16 = v12[4];
        BOOL v17 = v16 >= v14;
        if (v16 >= v14) {
          unsigned int v18 = v12;
        }
        else {
          unsigned int v18 = v12 + 1;
        }
        if (v17) {
          BOOL v15 = v12;
        }
        unint64_t v12 = (void *)*v18;
      }
      while (*v18);
      if (v15 == (void *)v11 || v14 < v15[4] || *((_DWORD *)v15 + 10) != *((_DWORD *)v5 + 10))
      {
LABEL_15:
        char v22 = v5 + 4;
        uint64_t result = sub_100BAE280(a3, v9, (uint64_t)&unk_10144E20E, &v22);
        result[5] = v5[5];
      }
      BOOL v19 = (void *)v5[1];
      if (v19)
      {
        do
        {
          char v20 = v19;
          BOOL v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          char v20 = (void *)v5[2];
          BOOL v21 = *v20 == (void)v5;
          uint64_t v5 = v20;
        }
        while (!v21);
      }
      uint64_t v5 = v20;
    }
    while (v20 != v4);
  }
  return result;
}

void *sub_100BAE050(void *result, unint64_t a2)
{
  uint64_t v3 = (char **)result;
  uint64_t v4 = result[2];
  uint64_t v5 = result[1];
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v11 = v5 + 24 * a2;
      uint64_t v12 = 24 * a2;
      long long v13 = (void *)(v5 + 8);
      do
      {
        void *v13 = 0;
        v13[1] = 0;
        *(v13 - 1) = v13;
        v13 += 3;
        v12 -= 24;
      }
      while (v12);
    }
    else
    {
      uint64_t v11 = result[1];
    }
    result[1] = v11;
  }
  else
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *result) >> 3);
    unint64_t v7 = v6 + a2;
    if (v6 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_10006A748();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *result) >> 3);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0x555555555555555) {
      unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v9 = v7;
    }
    long long v32 = result + 2;
    if (v9)
    {
      if (v9 > 0xAAAAAAAAAAAAAAALL) {
        sub_10006A7CC();
      }
      uint64_t v10 = (char *)operator new(24 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    unint64_t v14 = &v10[24 * v6];
    BOOL v15 = &v10[24 * v9];
    long long v31 = v15;
    unint64_t v16 = &v14[24 * a2];
    uint64_t v17 = 24 * a2;
    unsigned int v18 = v14 + 8;
    do
    {
      void *v18 = 0;
      v18[1] = 0;
      *(v18 - 1) = v18;
      v18 += 3;
      v17 -= 24;
    }
    while (v17);
    v30.i64[1] = (uint64_t)&v14[24 * a2];
    char v20 = *v3;
    unint64_t v19 = (unint64_t)v3[1];
    if ((char *)v19 == *v3)
    {
      int64x2_t v27 = vdupq_n_s64(v19);
    }
    else
    {
      uint64_t v21 = 0;
      do
      {
        char v22 = &v14[v21];
        *((void *)v22 - 3) = *(void *)(v19 + v21 - 24);
        uint64_t v23 = (uint64_t *)(v19 + v21 - 16);
        uint64_t v24 = *v23;
        *(void *)&v14[v21 - 16] = *v23;
        uint64_t v25 = (uint64_t)&v14[v21 - 16];
        uint64_t v26 = *(void *)(v19 + v21 - 8);
        *((void *)v22 - 1) = v26;
        if (v26)
        {
          *(void *)(v24 + 16) = v25;
          *(void *)(v19 + v21 - 24) = v23;
          *uint64_t v23 = 0;
          *(void *)(v19 + v21 - 8) = 0;
        }
        else
        {
          *((void *)v22 - 3) = v25;
        }
        v21 -= 24;
      }
      while ((char *)(v19 + v21) != v20);
      int64x2_t v27 = *(int64x2_t *)v3;
      v14 += v21;
      unint64_t v16 = (char *)v30.i64[1];
      BOOL v15 = v31;
    }
    *uint64_t v3 = v14;
    v3[1] = v16;
    int64x2_t v30 = v27;
    uint64_t v28 = v3[2];
    v3[2] = v15;
    long long v31 = v28;
    uint64_t v29 = v27.i64[0];
    return (void *)sub_100BAE22C((uint64_t)&v29);
  }
  return result;
}

uint64_t sub_100BAE22C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    sub_1000346F8(i - 24, *(void **)(i - 16));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *sub_100BAE280(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    sub_100046C38(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t sub_100BAE340(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      unint64_t v7 = v2;
    }
    else {
      unint64_t v7 = v2 + 1;
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4]) {
    return 0;
  }
  sub_10006C514((uint64_t **)a1, v4);
  operator delete(v4);
  return 1;
}

void sub_100BAE6C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_100BAE748(_Unwind_Exception *a1)
{
}

void sub_100BAEBD0(_Unwind_Exception *exception_object)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

id sub_100BAEC44(Registry *a1, std::__shared_weak_count *a2, void *a3, void *a4)
{
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v5 = sub_100BB35BC(a1, kAlertDialogLocalizationTable, a3, a4, (uint64_t *)&kAlertDialogLocalizationTable);
  if (a2) {
    sub_10004D2C8(a2);
  }
  return v5;
}

void sub_100BAEC98(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BAFF24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,xpc_object_t object,xpc_object_t a35,xpc_object_t a36,char a37,uint64_t a38,xpc_object_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (v46) {
    sub_10004D2C8(v46);
  }
  if ((v47 & 1) == 0) {
    sub_10004D2C8(v45);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BB050C(__CFUserNotification *a1, uint64_t a2)
{
  if (a2 == 1) {
    [+[CellDataActivationFailureAlertState sharedInstance] handleActionResponse];
  }
  if (a1)
  {
    CFUserNotificationCancel(a1);
    CFRelease(a1);
  }
  [+[CellDataActivationFailureAlertState sharedInstance] unlockScheduled];
}

uint64_t DataActivationFailureEventObserver::DataActivationFailureEventObserver(uint64_t a1, void *a2)
{
  *(void *)a1 = off_101A43910;
  uint64_t v4 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v16, kCtLoggingSystemName, "dafEvent");
  id v5 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  BOOL v6 = dispatch_queue_create("DataActivationFailureEventObserver", v5);
  void *v4 = 0;
  v4[1] = 0;
  *(void *)(a1 + 24) = v6;
  if (v6)
  {
    unint64_t v7 = v6;
    dispatch_retain(v6);
    *(void *)(a1 + 32) = 0;
    dispatch_release(v7);
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v17, &v16);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v17);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v17);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v16);
  *(void *)a1 = off_101A43910;
  *(void *)(a1 + 48) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 56) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 64) = 0;
  *(void *)(a1 + 68) = -1;
  sub_100058DB0(&__p, "DataActivationFailureEventObserver");
  unint64_t v9 = *(NSObject **)(a1 + 24);
  long long v13 = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  unint64_t v10 = *(NSObject **)(a1 + 32);
  dispatch_object_t object = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v13) {
    dispatch_release(v13);
  }
  if (v15 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 152) = a1 + 160;
  *(void *)(a1 + 168) = 0;
  *(unsigned char *)(a1 + 176) = 1;
  *(_DWORD *)(a1 + 180) = 0;
  *(unsigned char *)(a1 + 184) = 0;
  *(void *)(a1 + 186) = 0;
  *(void *)(a1 + 192) = 0;
  [+[CellDataActivationFailureAlertState sharedInstance] appInit];
  return a1;
}

void sub_100BB07F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  uint64_t v23 = (std::__shared_weak_count *)*((void *)v19 + 7);
  if (v23) {
    sub_10004D2C8(v23);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  CSIEventObserverInterface::~CSIEventObserverInterface(v19);
  _Unwind_Resume(a1);
}

void sub_100BB08C0(uint64_t a1)
{
  *(void *)a1 = off_101A43910;
  sub_1000346F8(a1 + 152, *(void **)(a1 + 160));
  sub_1000886C0(a1 + 128, *(char **)(a1 + 136));
  uint64_t v4 = (void **)(a1 + 96);
  sub_1000C56F4(&v4);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  CSIEventObserverInterface::~CSIEventObserverInterface((CSIEventObserverInterface *)a1);
}

void sub_100BB0960(uint64_t a1)
{
  sub_100BB08C0(a1);

  operator delete();
}

void sub_100BB0998(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/cellular_data_setting");
  v4[0] = off_101A43BF8;
  v4[1] = a1;
  uint64_t v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100BB0A4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100BB0A78(uint64_t a1, uint64_t a2, xpc_object_t *a3)
{
  if (*a3) {
    xpc_retain(*a3);
  }
  else {
    xpc_null_create();
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BB0BA8(uint64_t a1, void *a2)
{
  unsigned int v215 = 0;
  BOOL v214 = 0;
  std::string __p = 0;
  long long v213 = 0uLL;
  int v218 = -1;
  int v183 = *(unsigned __int8 *)(a1 + 176);
  char v217 = 0;
  *(void *)std::string buf = a2;
  *(void *)&uint8_t buf[8] = "kNotificationFlag";
  sub_100048BAC((uint64_t)buf, object);
  int v4 = xpc::dyn_cast_or_default((xpc *)object, 0, v3);
  xpc_release(object[0]);
  if (v4)
  {
    memset(buf, 0, 128);
    v247.__r_.__value_.__r.__words[0] = 0;
    object[0] = a2;
    object[1] = "kArgs";
    sub_10005107C((uint64_t)object, &v247);
    if (xpc_get_type(v247.__r_.__value_.__l.__data_) == (xpc_type_t)&_xpc_type_array)
    {
      int64_t count = xpc_array_get_count(v247.__r_.__value_.__l.__data_);
      if (count >= 16) {
        uint64_t v5 = 16;
      }
      else {
        uint64_t v5 = count;
      }
      if (count >= 1)
      {
        uint64_t v8 = 0;
        if (v5 <= 1) {
          uint64_t v9 = 1;
        }
        else {
          uint64_t v9 = v5;
        }
        do
        {
          object[0] = &v247;
          object[1] = v8;
          sub_1000492E0((uint64_t)object, &v245);
          *(void *)&buf[8 * (void)v8] = (int)xpc::dyn_cast_or_default((xpc *)&v245, 0, v10);
          xpc_release(v245.__r_.__value_.__l.__data_);
          uint64_t v8 = (char *)v8 + 1;
        }
        while ((void *)v9 != v8);
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
    xpc_release(v247.__r_.__value_.__l.__data_);
    sub_100BB2FDC((uint64_t)a2, &v215, &v214, (uint64_t)&__p, &v218, &v217);
    if (v5 >= 4)
    {
      int v218 = *(_DWORD *)buf;
      if (*(void *)&buf[24])
      {
        unsigned int v215 = *(_DWORD *)&buf[24];
        switch(*(void *)&buf[24])
        {
          case 0xFFFFFFFFFFFFFFFCLL:
            memset(object, 0, 24);
            ctu::cf::assign();
            xpc_object_t v11 = object[0];
            v247.__r_.__value_.__l.__data_ = (std::string::pointer)object[1];
            *(std::string::size_type *)((char *)v247.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&object[1] + 7);
            char v12 = HIBYTE(object[2]);
            if (SHIBYTE(v213) < 0) {
              operator delete(__p);
            }
            std::string __p = v11;
            *(void *)&long long v213 = v247.__r_.__value_.__r.__words[0];
            *(void *)((char *)&v213 + 7) = *(std::string::size_type *)((char *)v247.__r_.__value_.__r.__words + 7);
            HIBYTE(v213) = v12;
            BOOL v214 = 1;
            break;
          case 0xFFFFFFFFFFFFFFFDLL:
          case 0xFFFFFFFFFFFFFFFELL:
          case 0xFFFFFFFFFFFFFFFFLL:
            memset(object, 0, 24);
            ctu::cf::assign();
            xpc_object_t v13 = object[0];
            v247.__r_.__value_.__l.__data_ = (std::string::pointer)object[1];
            *(std::string::size_type *)((char *)v247.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&object[1] + 7);
            char v14 = HIBYTE(object[2]);
            if (SHIBYTE(v213) < 0) {
              operator delete(__p);
            }
            std::string __p = v13;
            *(void *)&long long v213 = v247.__r_.__value_.__r.__words[0];
            *(void *)((char *)&v213 + 7) = *(std::string::size_type *)((char *)v247.__r_.__value_.__r.__words + 7);
            HIBYTE(v213) = v14;
            break;
          default:
            break;
        }
      }
    }
    char v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(object[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I old style dict", (uint8_t *)object, 2u);
    }
  }
  else
  {
    object[0] = 0;
    *(void *)std::string buf = a2;
    *(void *)&uint8_t buf[8] = "kNotificationDict";
    sub_10000CB28((uint64_t)buf, object);
    if (xpc_get_type(object[0]) == (xpc_type_t)&_xpc_type_dictionary) {
      sub_100BB2FDC((uint64_t)object, &v215, &v214, (uint64_t)&__p, &v218, &v217);
    }
    BOOL v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I new style dict", buf, 2u);
    }
    xpc_release(object[0]);
  }
  if (v217)
  {
    uint64_t v16 = 1;
    char isStewieActive = 1;
  }
  else
  {
    char isStewieActive = StewieFeatureState::isStewieActive((StewieFeatureState *)(a1 + 186));
  }
  memset(object, 0, 24);
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v16, *(Registry **)(a1 + 48));
  unsigned int v18 = ServiceMap;
  if (v19 < 0)
  {
    char v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v19;
  uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
  if (v23)
  {
    uint64_t v25 = v23[3];
    uint64_t v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      goto LABEL_39;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v18);
  uint64_t v24 = 0;
  char v26 = 1;
LABEL_39:
  v192 = v24;
  if (v25)
  {
    unsigned int v193 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 64))(v25);
    (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v25 + 40))(buf, v25);
    sub_10005CBB4((uint64_t *)object);
    *(_OWORD *)dispatch_object_t object = *(_OWORD *)buf;
    xpc_object_t object[2] = *(xpc_object_t *)&buf[16];
    memset(buf, 0, 24);
    v247.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
    sub_100047F64((void ***)&v247);
    *(_DWORD *)v205 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 56))(v25);
    *(_DWORD *)v194 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 168))(v25);
  }
  else
  {
    *(_DWORD *)v205 = 0;
    unsigned int v193 = -1;
    *(_DWORD *)v194 = 0;
  }
  char v204 = v26;
  uint64_t v208 = a1;
  memset(&v247, 0, sizeof(v247));
  int64x2_t v27 = (char *)object[0];
  uint64_t v28 = (char *)object[1];
  if (object[0] == object[1])
  {
    uint64_t v29 = 0;
  }
  else
  {
    uint64_t v29 = 0;
    do
    {
      memset(buf, 0, 24);
      if (v27[23] < 0)
      {
        sub_10004FC84(buf, *(void **)v27, *((void *)v27 + 1));
      }
      else
      {
        long long v30 = *(_OWORD *)v27;
        *(void *)&uint8_t buf[16] = *((void *)v27 + 2);
        *(_OWORD *)std::string buf = v30;
      }
      if (v25) {
        v29 |= (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v25 + 48))(v25, buf);
      }
      if ((v247.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t size = HIBYTE(v247.__r_.__value_.__r.__words[2]);
      }
      else {
        size_t size = v247.__r_.__value_.__l.__size_;
      }
      if (size)
      {
        memset(&v245, 0, sizeof(v245));
        sub_1000C140C((uint64_t)&v245, size + 2);
        if ((v245.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v32 = &v245;
        }
        else {
          long long v32 = (std::string *)v245.__r_.__value_.__r.__words[0];
        }
        if ((v247.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v33 = &v247;
        }
        else {
          long long v33 = (std::string *)v247.__r_.__value_.__r.__words[0];
        }
        memmove(v32, v33, size);
        strcpy((char *)v32 + size, ", ");
        if (buf[23] >= 0) {
          long long v34 = buf;
        }
        else {
          long long v34 = *(const std::string::value_type **)buf;
        }
        if (buf[23] >= 0) {
          std::string::size_type v35 = buf[23];
        }
        else {
          std::string::size_type v35 = *(void *)&buf[8];
        }
        long long v36 = std::string::append(&v245, v34, v35);
        std::string::size_type v37 = v36->__r_.__value_.__r.__words[0];
        v246[0] = v36->__r_.__value_.__l.__size_;
        *(void *)((char *)v246 + 7) = *(std::string::size_type *)((char *)&v36->__r_.__value_.__r.__words[1] + 7);
        char v38 = HIBYTE(v36->__r_.__value_.__r.__words[2]);
        v36->__r_.__value_.__l.__size_ = 0;
        v36->__r_.__value_.__r.__words[2] = 0;
        v36->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(v247.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v247.__r_.__value_.__l.__data_);
        }
        v247.__r_.__value_.__r.__words[0] = v37;
        v247.__r_.__value_.__l.__size_ = v246[0];
        *(std::string::size_type *)((char *)&v247.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v246 + 7);
        *((unsigned char *)&v247.__r_.__value_.__s + 23) = v38;
        if (SHIBYTE(v245.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v245.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        std::string::operator=(&v247, (const std::string *)buf);
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      v27 += 24;
    }
    while (v27 != v28);
  }
  uint64_t v191 = v29;
  v246[0] = 0;
  if (v25)
  {
    *(_DWORD *)v201 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 96))(v25);
    uint64_t v39 = a1;
    *(_DWORD *)v200 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 104))(v25);
    uint64_t v40 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v25 + 24))(v25, v246);
    char v41 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 112))(v25);
    *(_DWORD *)&v201[4] = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 16))(v25);
    char v42 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 128))(v25);
    sub_100058DB0(buf, "com.apple.DataActivation");
    char v43 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v25 + 88))(v25, buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    *(void *)v201 = 0;
    *(_DWORD *)v200 = 0;
    uint64_t v40 = 0;
    char v41 = 0;
    char v42 = 0;
    char v43 = 0;
    uint64_t v39 = v208;
  }
  xpc_object_t xdict = 0;
  *(void *)std::string buf = a2;
  *(void *)&uint8_t buf[8] = "kNotificationAdditional";
  sub_10000CB28((uint64_t)buf, &xdict);
  xpc_type_t type = xpc_get_type(xdict);
  uint64_t v45 = (uint64_t *)&_xpc_type_dictionary;
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    if (xpc_dictionary_get_value(xdict, kDataActivateFailureDueToDataPlanKey))
    {
      *(void *)std::string buf = &xdict;
      *(void *)&uint8_t buf[8] = kDataActivateFailureDueToDataPlanKey;
      sub_100048BAC((uint64_t)buf, &v245);
      *(_DWORD *)v196 = xpc::dyn_cast_or_default((xpc *)&v245, 0, v47);
      xpc_release(v245.__r_.__value_.__l.__data_);
    }
    else
    {
      *(_DWORD *)v196 = 0;
    }
    if (xpc_dictionary_get_value(xdict, kDataActivateFailureAlertCallbackKey))
    {
      *(void *)std::string buf = &xdict;
      *(void *)&uint8_t buf[8] = kDataActivateFailureAlertCallbackKey;
      sub_100048BAC((uint64_t)buf, &v245);
      int v46 = xpc::dyn_cast_or_default((xpc *)&v245, 0, v48);
      xpc_release(v245.__r_.__value_.__l.__data_);
    }
    else
    {
      int v46 = 0;
    }
  }
  else
  {
    int v46 = 0;
    *(_DWORD *)v196 = 0;
  }
  long long v49 = (std::mutex *)Registry::getServiceMap(v45, *(Registry **)(v39 + 48));
  uint64_t v50 = v49;
  uint64_t v52 = v51;
  if (v51 < 0)
  {
    uint64_t v53 = (unsigned __int8 *)(v51 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v54 = 5381;
    do
    {
      uint64_t v52 = v54;
      unsigned int v55 = *v53++;
      uint64_t v54 = (33 * v54) ^ v55;
    }
    while (v55);
  }
  std::mutex::lock(v49);
  *(void *)std::string buf = v52;
  uint64_t v56 = sub_10004D37C(&v50[1].__m_.__sig, (unint64_t *)buf);
  int v186 = v46;
  BOOL v187 = v42;
  BOOL v189 = v41;
  if (v56)
  {
    uint64_t v57 = v56[3];
    std::string::size_type v58 = (std::__shared_weak_count *)v56[4];
    if (v58)
    {
      atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v50);
      atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v58);
      char v203 = 0;
      goto LABEL_95;
    }
  }
  else
  {
    uint64_t v57 = 0;
  }
  std::mutex::unlock(v50);
  std::string::size_type v58 = 0;
  char v203 = 1;
LABEL_95:
  uint64_t v60 = (char *)object[0];
  uint64_t v61 = (char *)object[1];
  v202 = v58;
  for (char i = 0; v60 != v61; v60 += 24)
  {
    memset(buf, 0, 24);
    if (v60[23] < 0)
    {
      uint64_t v59 = (capabilities::ct *)sub_10004FC84(buf, *(void **)v60, *((void *)v60 + 1));
    }
    else
    {
      long long v63 = *(_OWORD *)v60;
      *(void *)&uint8_t buf[16] = *((void *)v60 + 2);
      *(_OWORD *)std::string buf = v63;
    }
    if (!(i & 1 | (v57 == 0)))
    {
      uint64_t v59 = (capabilities::ct *)(*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v57 + 64))(v57, 52, buf);
      char i = (char)v59;
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
  if (v57)
  {
    uint64_t v59 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(void *)v57 + 80))(v57);
    BOOL v195 = (int)v59;
    if (v25)
    {
LABEL_106:
      char v64 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 144))(v25);
      uint64_t v59 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(void *)v25 + 152))(v25);
      BOOL v65 = (char)v59;
      goto LABEL_109;
    }
  }
  else
  {
    BOOL v195 = 0;
    if (v25) {
      goto LABEL_106;
    }
  }
  BOOL v65 = 0;
  char v64 = 1;
LABEL_109:
  uint64_t v206 = v40;
  BOOL v184 = v43;
  if ((capabilities::ct::supportsGemini(v59) & 1) == 0)
  {
    BOOL v197 = 0;
    goto LABEL_142;
  }
  BOOL v180 = v65;
  long long v67 = (std::mutex *)Registry::getServiceMap(v66, *(Registry **)(v39 + 48));
  unint64_t v68 = v67;
  if (v69 < 0)
  {
    unint64_t v70 = (unsigned __int8 *)(v69 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v71 = 5381;
    do
    {
      uint64_t v69 = v71;
      unsigned int v72 = *v70++;
      uint64_t v71 = (33 * v71) ^ v72;
    }
    while (v72);
  }
  std::mutex::lock(v67);
  *(void *)std::string buf = v69;
  uint64_t v73 = sub_10004D37C(&v68[1].__m_.__sig, (unint64_t *)buf);
  char v178 = v64;
  if (!v73)
  {
    uint64_t v75 = 0;
LABEL_119:
    std::mutex::unlock(v68);
    uint64_t v74 = 0;
    uint64_t v76 = 1;
    if (!v75) {
      goto LABEL_116;
    }
    goto LABEL_120;
  }
  uint64_t v75 = v73[3];
  uint64_t v74 = (std::__shared_weak_count *)v73[4];
  if (!v74) {
    goto LABEL_119;
  }
  atomic_fetch_add_explicit(&v74->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v68);
  atomic_fetch_add_explicit(&v74->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v74);
  uint64_t v76 = 0;
  if (!v75)
  {
LABEL_116:
    BOOL v77 = 0;
    goto LABEL_139;
  }
LABEL_120:
  char v198 = v76;
  long long v78 = (std::mutex *)Registry::getServiceMap((uint64_t *)v76, *(Registry **)(v39 + 48));
  long long v79 = v78;
  if (v80 < 0)
  {
    uint64_t v81 = (unsigned __int8 *)(v80 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v82 = 5381;
    do
    {
      uint64_t v80 = v82;
      unsigned int v83 = *v81++;
      uint64_t v82 = (33 * v82) ^ v83;
    }
    while (v83);
  }
  std::mutex::lock(v78);
  *(void *)std::string buf = v80;
  uint64_t v84 = sub_10004D37C(&v79[1].__m_.__sig, (unint64_t *)buf);
  if (!v84)
  {
    unint64_t v86 = 0;
LABEL_128:
    std::mutex::unlock(v79);
    uint64_t v85 = 0;
    char v87 = 1;
    if (!v86) {
      goto LABEL_138;
    }
    goto LABEL_129;
  }
  unint64_t v86 = (uint64_t (***)(void))v84[3];
  uint64_t v85 = (std::__shared_weak_count *)v84[4];
  if (!v85) {
    goto LABEL_128;
  }
  atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v79);
  atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v85);
  char v87 = 0;
  if (!v86) {
    goto LABEL_138;
  }
LABEL_129:
  if (((**v86)(v86) & 1) == 0 || (unint64_t v88 = *(void **)(v208 + 152), v88 == (void *)(v208 + 160)))
  {
LABEL_138:
    BOOL v92 = 0;
    BOOL v77 = 0;
    LOBYTE(v76) = v198;
    if (v87) {
      goto LABEL_139;
    }
LABEL_265:
    v148 = v85;
    char v149 = v76;
    sub_10004D2C8(v148);
    BOOL v77 = v92;
    if (v149) {
      goto LABEL_141;
    }
    goto LABEL_140;
  }
  while (1)
  {
    int v89 = *((_DWORD *)v88 + 7);
    if (v89 != (*(unsigned int (**)(uint64_t))(*(void *)v75 + 760))(v75)) {
      break;
    }
    long long v90 = (void *)v88[1];
    if (v90)
    {
      do
      {
        long long v91 = v90;
        long long v90 = (void *)*v90;
      }
      while (v90);
    }
    else
    {
      do
      {
        long long v91 = (void *)v88[2];
        BOOL v142 = *v91 == (void)v88;
        unint64_t v88 = v91;
      }
      while (!v142);
    }
    unint64_t v88 = v91;
    if (v91 == (void *)(v208 + 160)) {
      goto LABEL_138;
    }
  }
  if ((*(unsigned int (**)(uint64_t, void))(*(void *)v75 + 744))(v75, *((unsigned int *)v88 + 7))) {
    BOOL v92 = *((_DWORD *)v88 + 8) == 0;
  }
  else {
    BOOL v92 = 0;
  }
  LOBYTE(v76) = v198;
  BOOL v77 = v92;
  if ((v87 & 1) == 0) {
    goto LABEL_265;
  }
LABEL_139:
  if ((v76 & 1) == 0) {
LABEL_140:
  }
    sub_10004D2C8(v74);
LABEL_141:
  BOOL v197 = v77;
  uint64_t v39 = v208;
  std::string::size_type v58 = v202;
  char v64 = v178;
  BOOL v65 = v180;
LABEL_142:
  uint64_t v93 = (os_log_t *)(v39 + 40);
  BOOL v94 = *(NSObject **)(v39 + 40);
  if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
  {
    v181 = (os_log_t *)(v39 + 40);
    unsigned int v179 = v215;
    uint64_t v177 = CSIErrorString();
    uint64_t v176 = asStringBool(v205[0]);
    int v175 = v218;
    if (v213 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    uint64_t v96 = &v247;
    if ((v247.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v96 = (std::string *)v247.__r_.__value_.__r.__words[0];
    }
    v173 = v96;
    v174 = p_p;
    uint64_t v172 = asStringBool(v214);
    uint64_t v171 = asString();
    uint64_t v170 = asStringBool(v200[0]);
    *(void *)v190 = asStringBool(v189);
    uint64_t v169 = asStringBool(v201[4]);
    *(void *)v188 = asStringBool(v187);
    uint64_t v168 = asStringBool(v64);
    uint64_t v167 = asStringBool(v65);
    uint64_t v166 = asStringBool(i & 1);
    *(void *)v185 = asStringBool(v184);
    uint64_t v97 = asStringBool(v194[0]);
    uint64_t v98 = asStringBool(v195);
    uint64_t v99 = asStringBool(v196[0]);
    uint64_t v100 = *(unsigned int *)(v208 + 72);
    uint64_t v101 = asStringBool(*(unsigned char *)(v208 + 120));
    uint64_t v102 = asStringBool(*(unsigned char *)(v208 + 184));
    uint64_t v103 = asStringBool(v197);
    *(_DWORD *)std::string buf = 67115522;
    *(_DWORD *)&uint8_t buf[4] = v179;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = v177;
    *(_WORD *)&unsigned char buf[18] = 2080;
    *(void *)&buf[20] = v176;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v175;
    *(_WORD *)&buf[34] = 2080;
    *(void *)&buf[36] = v174;
    *(_WORD *)&buf[44] = 2080;
    *(void *)&buf[46] = v173;
    *(_WORD *)&buf[54] = 2048;
    *(void *)&buf[56] = v191;
    *(_WORD *)&buf[64] = 2080;
    *(void *)&buf[66] = v172;
    *(_WORD *)&buf[74] = 2048;
    *(void *)&buf[76] = v193;
    *(_WORD *)&buf[84] = 2080;
    *(void *)&buf[86] = v171;
    *(_WORD *)&buf[94] = 2080;
    *(void *)&buf[96] = v170;
    *(_WORD *)&buf[104] = 2048;
    *(void *)&buf[106] = v206;
    *(_WORD *)&buf[114] = 2080;
    *(void *)&buf[116] = *(void *)v190;
    *(_WORD *)&buf[124] = 2080;
    *(void *)&buf[126] = v169;
    __int16 v221 = 2080;
    uint64_t v222 = *(void *)v188;
    __int16 v223 = 2080;
    uint64_t v224 = v168;
    __int16 v225 = 2080;
    uint64_t v226 = v167;
    __int16 v227 = 2080;
    uint64_t v228 = v166;
    __int16 v229 = 2080;
    uint64_t v230 = *(void *)v185;
    __int16 v231 = 2080;
    uint64_t v232 = v97;
    __int16 v233 = 2080;
    uint64_t v234 = v98;
    __int16 v235 = 2080;
    uint64_t v236 = v99;
    __int16 v237 = 2048;
    uint64_t v238 = v100;
    __int16 v239 = 2080;
    uint64_t v240 = v101;
    __int16 v241 = 2080;
    uint64_t v242 = v102;
    __int16 v243 = 2080;
    uint64_t v244 = v103;
    _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I err_code=%d (%s); lockState = %s; contextId = %d; reason: %s; frontmost app=%s; uses network=%ld; forMMS=%s; ap"
      "pSequence=%lu; simStatus=%s; needsUserIdentificationModule=%s; calls=%lu; fallingBackToCellular=%s; usingWifi=%s; "
      "isBluetoothTethering=%s; isWifiCapable=%s; isWAPICapable=%s; suppressed=%s; DataActivation active = %s; webSheetVi"
      "sibility = %s; dataPlanFailingActivation = %s; failureFromDataPlan = %s; lockSequence = %lu; isVinylAvailable = %s"
      "; fInternetActive = %s, canSwitchToOtherSIM = %s",
      buf,
      0xFEu);
    uint64_t v39 = v208;
    std::string::size_type v58 = v202;
    uint64_t v93 = v181;
  }
  if (v206 && (v206 != 1 || !v246[0]))
  {
    int v104 = *v93;
    int v105 = 0;
    char v106 = v203;
    if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_164;
    }
    *(_WORD *)std::string buf = 0;
    long long v107 = "#I In a call - do not show ";
    goto LABEL_162;
  }
  if (*(_DWORD *)v205)
  {
    int v104 = *v93;
    int v105 = 0;
    char v106 = v203;
    if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_164;
    }
    *(_WORD *)std::string buf = 0;
    long long v107 = "#I UI Locked - do not show ";
    goto LABEL_162;
  }
  int v108 = *(_DWORD *)v200;
  if (*(_DWORD *)v201) {
    int v108 = 0;
  }
  if (v108 == 1)
  {
    int v104 = *v93;
    int v105 = 0;
    char v106 = v203;
    if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_164;
    }
    *(_WORD *)std::string buf = 0;
    long long v107 = "#I Invalid SIM status - do not show ";
    goto LABEL_162;
  }
  if (v215 != 104)
  {
    char v135 = !v197;
    if (v215 == 63) {
      char v135 = 1;
    }
    if ((v135 & 1) == 0)
    {
      int v104 = *v93;
      int v105 = 0;
      char v106 = v203;
      if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_164;
      }
      *(_WORD *)std::string buf = 0;
      long long v107 = "#I Soft error - do not show ";
      goto LABEL_162;
    }
    BOOL v142 = v215 != -5 || *(unsigned char *)(v39 + 184) == 0;
    int v143 = !v142;
    if (v215 == -9 || v143)
    {
      int v104 = *v93;
      int v105 = 0;
      char v106 = v203;
      if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_164;
      }
      *(_WORD *)std::string buf = 0;
      long long v107 = "#I Temprorary Failure - do not show";
      goto LABEL_162;
    }
    if (((!v195 | *(_DWORD *)v196) & 1) == 0)
    {
      int v104 = *v93;
      int v105 = 0;
      char v106 = v203;
      if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_164;
      }
      *(_WORD *)std::string buf = 0;
      long long v107 = "#I Data plan blocking activation - do not show";
      goto LABEL_162;
    }
    char v144 = !v196[0];
    if (!v25) {
      char v144 = 1;
    }
    if ((v144 & 1) == 0)
    {
      int v145 = *(_DWORD *)(v39 + 72);
      if (v145 == (*(unsigned int (**)(uint64_t))(*(void *)v25 + 72))(v25))
      {
        int v104 = *v93;
        int v105 = 0;
        char v106 = v203;
        if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_164;
        }
        *(_WORD *)std::string buf = 0;
        long long v107 = "#I Already shown data plan alert this unlock - do not show ";
        goto LABEL_162;
      }
    }
    if (*(_DWORD *)v194)
    {
      int v104 = *v93;
      int v105 = 0;
      char v106 = v203;
      if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_164;
      }
      *(_WORD *)std::string buf = 0;
      long long v107 = "#I Websheet visible - do not show ";
      goto LABEL_162;
    }
    if (i)
    {
      int v104 = *v93;
      int v105 = 0;
      char v106 = v203;
      if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_164;
      }
      *(_WORD *)std::string buf = 0;
      long long v107 = "#I Suppressed - do not show ";
      goto LABEL_162;
    }
    if (v218 && !v214)
    {
      int v104 = *v93;
      int v105 = 0;
      char v106 = v203;
      if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_164;
      }
      *(_WORD *)std::string buf = 0;
      long long v107 = "#I Not internet and not for MMS - do not show ";
      goto LABEL_162;
    }
    if (v25)
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v25 + 80))(v25))
      {
        int v151 = *(_DWORD *)(v39 + 68);
        if (v151 != -1 && v151 == v193)
        {
          int v104 = *v93;
          int v105 = 0;
          char v106 = v203;
          if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_164;
          }
          *(_WORD *)std::string buf = 0;
          long long v107 = "#I Application event sequeunce is the same - do not show ";
LABEL_162:
          _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, v107, buf, 2u);
LABEL_163:
          int v105 = 0;
          goto LABEL_164;
        }
      }
    }
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_1002A1B14(*(Registry **)(v39 + 48), buf);
    if (*(void *)buf
      && (*(unsigned int (**)(void, uint64_t))(**(void **)buf + 1152))(*(void *)buf, 3))
    {
      v152 = *v93;
      if (os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v245.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEFAULT, "#I Baseband refreshing - do not show ", (uint8_t *)&v245, 2u);
      }
      char v106 = v203;
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      goto LABEL_163;
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    v153 = (char *)object[0];
    v154 = (char *)object[1];
    if (object[0] == object[1]) {
      goto LABEL_325;
    }
    v182 = v93;
    int v155 = 0;
    LOBYTE(v156) = 1;
    BOOL v157 = v214;
    do
    {
      memset(buf, 0, 24);
      if (v153[23] < 0)
      {
        sub_10004FC84(buf, *(void **)v153, *((void *)v153 + 1));
      }
      else
      {
        long long v158 = *(_OWORD *)v153;
        *(void *)&uint8_t buf[16] = *((void *)v153 + 2);
        *(_OWORD *)std::string buf = v158;
      }
      v245.__r_.__value_.__s.__data_[0] = 0;
      if (v156)
      {
        int v156 = sub_100BB2B50(v39, v157, (uint64_t *)buf, &v245);
        int v159 = v245.__r_.__value_.__s.__data_[0];
      }
      else
      {
        int v159 = 0;
        int v156 = 0;
      }
      BOOL v160 = v159 != 0;
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      v155 |= v160;
      v153 += 24;
    }
    while (v153 != v154);
    if ((v156 & v155 & 1) != 0
      && (v161.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_,
          v161.__d_.__rep_ - *(void *)(v39 + 192) >= 0x34630B8A001))
    {
      *(std::chrono::steady_clock::time_point *)(v39 + 192) = v161;
      uint64_t v93 = v182;
    }
    else
    {
      uint64_t v93 = v182;
      if (v156) {
        goto LABEL_325;
      }
    }
    unsigned __int8 v162 = [+[CellDataActivationFailureAlertState sharedInstance] trylockMain];
    v163 = *v93;
    BOOL v164 = os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT);
    if (v162)
    {
      if (v164)
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "#I to show", buf, 2u);
      }
      if (!v25)
      {
        int v105 = 1;
        uint64_t v39 = v208;
        char v106 = v203;
        uint64_t v93 = v182;
        goto LABEL_164;
      }
      uint64_t v39 = v208;
      uint64_t v93 = v182;
      *(_DWORD *)(v208 + 68) = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 64))(v25);
      if (*(_DWORD *)v196) {
        *(_DWORD *)(v208 + 72) = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 72))(v25);
      }
      int v105 = 1;
LABEL_326:
      char v106 = v203;
      goto LABEL_164;
    }
    if (v164)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "#I alert is already being shown, we skip the new alert.", buf, 2u);
    }
LABEL_325:
    int v105 = 0;
    goto LABEL_326;
  }
  char v106 = v203;
  if (![+[CellDataActivationFailureAlertState sharedInstance] trylockMain])
  {
    int v104 = *v93;
    int v105 = 0;
    if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_164;
    }
    *(_WORD *)std::string buf = 0;
    long long v107 = "#I kUncertifiedWifiCallingFatalError alert is already being shown";
    goto LABEL_162;
  }
  memset(buf, 0, 24);
  sub_100058DB0(buf, "com.apple.Preferences");
  char v129 = HIBYTE(v247.__r_.__value_.__r.__words[2]);
  if ((v247.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v130 = HIBYTE(v247.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v130 = v247.__r_.__value_.__l.__size_;
  }
  if (!v130) {
    goto LABEL_275;
  }
  uint64_t v131 = buf[23];
  if (buf[23] < 0) {
    uint64_t v131 = *(void *)&buf[8];
  }
  if (v130 != v131)
  {
LABEL_258:
    v146 = *v93;
    int v105 = 0;
    if (!os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_278;
    }
    if (v129 >= 0) {
      v147 = &v247;
    }
    else {
      v147 = (std::string *)v247.__r_.__value_.__r.__words[0];
    }
    goto LABEL_262;
  }
  if (buf[23] >= 0) {
    v132 = buf;
  }
  else {
    v132 = *(unsigned __int8 **)buf;
  }
  if ((*((unsigned char *)&v247.__r_.__value_.__s + 23) & 0x80) == 0)
  {
    if (*((unsigned char *)&v247.__r_.__value_.__s + 23))
    {
      v133 = &v247;
      uint64_t v134 = HIBYTE(v247.__r_.__value_.__r.__words[2]);
      while (v133->__r_.__value_.__s.__data_[0] == *v132)
      {
        v133 = (std::string *)((char *)v133 + 1);
        ++v132;
        if (!--v134) {
          goto LABEL_275;
        }
      }
      goto LABEL_258;
    }
LABEL_275:
    v150 = *v93;
    if (os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v245.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I kUncertifiedWifiCallingFatalError to show", (uint8_t *)&v245, 2u);
    }
    int v105 = 1;
    goto LABEL_278;
  }
  v147 = (std::string *)v247.__r_.__value_.__r.__words[0];
  if (!memcmp(v247.__r_.__value_.__l.__data_, v132, v247.__r_.__value_.__l.__size_)) {
    goto LABEL_275;
  }
  v146 = *v93;
  int v105 = 0;
  if (os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT))
  {
LABEL_262:
    LODWORD(v245.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v245.__r_.__value_.__r.__words + 4) = (std::string::size_type)v147;
    _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "#I kUncertifiedWifiCallingFatalError displayApps=%s", (uint8_t *)&v245, 0xCu);
    int v105 = 0;
  }
LABEL_278:
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
LABEL_164:
  if ((v106 & 1) == 0) {
    sub_10004D2C8(v58);
  }
  xpc_release(xdict);
  if (SHIBYTE(v247.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v247.__r_.__value_.__l.__data_);
  }
  if ((v204 & 1) == 0) {
    sub_10004D2C8(v192);
  }
  *(void *)std::string buf = object;
  sub_100047F64((void ***)buf);
  if (v105)
  {
    long long v109 = *v93;
    if (os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT))
    {
      long long v110 = v93;
      if (v213 >= 0) {
        long long v111 = &__p;
      }
      else {
        long long v111 = __p;
      }
      unsigned int v112 = v215;
      uint64_t v113 = CSIErrorString();
      uint64_t v114 = asStringBool(v214);
      uint64_t v115 = asStringBool(v201[4]);
      uint64_t v116 = asStringBool(v183 != 0);
      uint64_t v117 = asStringBool(isStewieActive);
      *(_DWORD *)std::string buf = 136316674;
      *(void *)&uint8_t buf[4] = v111;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = (int)v112;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v113;
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = v114;
      *(_WORD *)&buf[42] = 2080;
      *(void *)&buf[44] = v115;
      *(_WORD *)&buf[52] = 2080;
      *(void *)&buf[54] = v116;
      *(_WORD *)&buf[62] = 2080;
      *(void *)&buf[64] = v117;
      _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "#I Entering DataActivationFailureEvent Display Message process with settings: reason=%s; err_code=%ld; err.str=%"
        "s; forMMS=%s; usingWiFi=%s; cellularDataOn=%s; satelliteOn=%s",
        buf,
        0x48u);
      uint64_t v93 = v110;
    }
    if (v186)
    {
      uint64_t v118 = *v93;
      if (os_log_type_enabled(*v93, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "#I show callback alert.", buf, 2u);
      }
      uint64_t v120 = (std::mutex *)Registry::getServiceMap(v119, *(Registry **)(v39 + 48));
      int v121 = v120;
      if (v51 < 0)
      {
        v122 = (unsigned __int8 *)(v51 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v123 = 5381;
        do
        {
          uint64_t v51 = v123;
          unsigned int v124 = *v122++;
          uint64_t v123 = (33 * v123) ^ v124;
        }
        while (v124);
      }
      std::mutex::lock(v120);
      *(void *)std::string buf = v51;
      v125 = sub_10004D37C(&v121[1].__m_.__sig, (unint64_t *)buf);
      if (v125)
      {
        uint64_t v127 = v125[3];
        v126 = (std::__shared_weak_count *)v125[4];
        if (v126)
        {
          atomic_fetch_add_explicit(&v126->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v121);
          atomic_fetch_add_explicit(&v126->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v126);
          if (!v127)
          {
LABEL_218:
            sub_10004D2C8(v126);
            goto LABEL_233;
          }
LABEL_214:
          *(void *)std::string buf = 0;
          (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v127 + 96))(buf, v127);
          if (*(void *)buf)
          {
            (*(void (**)(void))(*(void *)buf + 16))();
            if (*(void *)buf) {
              _Block_release(*(const void **)buf);
            }
          }
          if (!v126) {
            goto LABEL_233;
          }
          goto LABEL_218;
        }
        std::mutex::unlock(v121);
        if (v127) {
          goto LABEL_214;
        }
      }
      else
      {
        std::mutex::unlock(v121);
      }
LABEL_233:
      [+[CellDataActivationFailureAlertState sharedInstance] unlockMain];
      goto LABEL_234;
    }
    if (SHIBYTE(v213) < 0)
    {
      id v136 = 0;
      if (!(void)v213 || (v128 = __p) == 0)
      {
LABEL_223:
        object[0] = 0;
        *(void *)std::string buf = a2;
        *(void *)&uint8_t buf[8] = "kNotificationAdditional";
        sub_10000CB28((uint64_t)buf, object);
        v137 = [CellDataActivationFailureAlertItem alloc];
        uint64_t v138 = v215;
        xpc_object_t v211 = object[0];
        if (object[0]) {
          xpc_retain(object[0]);
        }
        else {
          xpc_object_t v211 = xpc_null_create();
        }
        BOOL v139 = v214;
        v140 = *(std::__shared_weak_count **)(v39 + 56);
        uint64_t v209 = *(void *)(v39 + 48);
        v210 = v140;
        if (v140) {
          atomic_fetch_add_explicit(&v140->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        LOBYTE(v165) = isStewieActive;
        v141 = [(CellDataActivationFailureAlertItem *)v137 initWithErrorCode:v138 reason:v136 additionalData:&v211 suggestWiFi:!v139 cellularDataOn:v183 != 0 wifiOn:*(unsigned int *)&v201[4] satelliteOn:v165 registry:&v209 logger:v93];
        if (v210) {
          sub_10004D2C8(v210);
        }
        xpc_release(v211);
        xpc_object_t v211 = 0;
        if ((isStewieActive & 1) == 0) {
          [(CellDataActivationFailureAlertItem *)v141 button_config:*(unsigned __int8 *)(v39 + 120)];
        }
        [(CellDataActivationFailureAlertItem *)v141 show];
        xpc_release(object[0]);
        goto LABEL_233;
      }
    }
    else
    {
      if (!HIBYTE(v213))
      {
        id v136 = 0;
        goto LABEL_223;
      }
      v128 = &__p;
    }
    id v136 = [objc_alloc((Class)NSString) initWithCString:v128 encoding:4];
    goto LABEL_223;
  }
LABEL_234:
  if (SHIBYTE(v213) < 0) {
    operator delete(__p);
  }
}

void sub_100BB2858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,std::__shared_weak_count *a38,int a39,char a40,__int16 a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,xpc_object_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,xpc_object_t object,uint64_t a57,xpc_object_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *aBlock)
{
  if ((a40 & 1) == 0) {
    sub_10004D2C8(a38);
  }
  xpc_release(object);
  if (*(char *)(v62 - 105) < 0) {
    operator delete(*(void **)(v62 - 128));
  }
  if ((a42 & 1) == 0) {
    sub_10004D2C8(a32);
  }
  aBlock = &a58;
  sub_100047F64((void ***)&aBlock);
  if (a54 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BB2B50(uint64_t a1, int a2, uint64_t *a3, unsigned char *a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 48));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    xpc_object_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_9:
    std::mutex::unlock(v9);
    char v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_30;
    }
    goto LABEL_10;
  }
  uint64_t v16 = v14[3];
  char v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (!v16) {
    goto LABEL_30;
  }
LABEL_10:
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v16 + 48))(v16, a3);
  *a4 = 0;
  uint64_t v19 = *((unsigned __int8 *)a3 + 23);
  int v20 = (char)v19;
  if ((v19 & 0x80u) != 0) {
    uint64_t v19 = a3[1];
  }
  if (v19 == 21)
  {
    uint64_t v21 = v20 >= 0 ? a3 : (uint64_t *)*a3;
    uint64_t v22 = *v21;
    uint64_t v23 = v21[1];
    uint64_t v24 = *(uint64_t *)((char *)v21 + 13);
    BOOL v25 = v22 == 0x6C7070612E6D6F63 && v23 == 0x7265666572502E65;
    if (v25 && v24 == 0x7365636E65726566) {
      goto LABEL_24;
    }
  }
  if (*(_DWORD *)(a1 + 180) == 2
    || ((*(uint64_t (**)(uint64_t))(*(void *)v16 + 112))(v16) & 1) == 0
    && (((*(uint64_t (**)(uint64_t))(*(void *)v16 + 16))(v16) & 1) != 0
     || ((*(uint64_t (**)(uint64_t))(*(void *)v16 + 128))(v16) & 1) != 0))
  {
    goto LABEL_24;
  }
  if (((**(uint64_t (***)(uint64_t, uint64_t))v16)(v16, v18) & 1) == 0
    && (!a2 || ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v16 + 8))(v16, v18) & 1) == 0))
  {
    long long v32 = (std::mutex *)Registry::getServiceMap(v31, *(Registry **)(a1 + 48));
    long long v33 = v32;
    if (v34 < 0)
    {
      std::string::size_type v35 = (unsigned __int8 *)(v34 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v36 = 5381;
      do
      {
        uint64_t v34 = v36;
        unsigned int v37 = *v35++;
        uint64_t v36 = (33 * v36) ^ v37;
      }
      while (v37);
    }
    std::mutex::lock(v32);
    *(void *)std::string buf = v34;
    char v38 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)buf);
    if (v38)
    {
      uint64_t v40 = v38[3];
      uint64_t v39 = v38[4];
      if (v39)
      {
        long long v44 = (std::__shared_weak_count *)v38[4];
        char v41 = (atomic_ullong *)(v39 + 8);
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
        std::mutex::unlock(v33);
        atomic_fetch_add_explicit(v41, 1uLL, memory_order_relaxed);
        char v42 = v44;
        sub_10004D2C8(v44);
        char v43 = 0;
LABEL_49:
        if (v40) {
          *a4 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v40 + 680))(v40, a3);
        }
        if ((v43 & 1) == 0) {
          sub_10004D2C8(v42);
        }
LABEL_24:
        uint64_t v16 = 1;
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v40 = 0;
    }
    std::mutex::unlock(v33);
    char v42 = 0;
    char v43 = 1;
    goto LABEL_49;
  }
  uint64_t v16 = 0;
LABEL_25:
  int64x2_t v27 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      uint64_t v28 = a3;
    }
    else {
      uint64_t v28 = (uint64_t *)*a3;
    }
    int v29 = *a4;
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = v28;
    __int16 v46 = 1024;
    int v47 = v18;
    __int16 v48 = 1024;
    int v49 = v29;
    __int16 v50 = 1024;
    int v51 = a2;
    __int16 v52 = 1024;
    int v53 = v16;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I app %s, data %d, frontAppCanCauseNetworkError %d, mms %d: silent %d", buf, 0x24u);
  }
LABEL_30:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  return v16;
}

void sub_100BB2F98(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BB2FDC(uint64_t a1, _DWORD *a2, unsigned char *a3, uint64_t a4, _DWORD *a5, unsigned char *a6)
{
  uint64_t v32 = 0;
  ctu::cf::assign();
  long long v29 = 0u;
  uint64_t v30 = 0;
  *(void *)&long long v31 = a1;
  *((void *)&v31 + 1) = &v29;
  sub_100048BAC((uint64_t)&v31, object);
  *a3 = xpc::dyn_cast_or_default((xpc *)object, 0, v12);
  xpc_release(object[0]);
  object[0] = 0;
  object[1] = 0;
  uint64_t v28 = 0;
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  ctu::cf::assign();
  *(_OWORD *)dispatch_object_t object = v31;
  uint64_t v28 = v32;
  unsigned int v13 = (xpc_object_t *)v31;
  if (v32 >= 0) {
    unsigned int v13 = object;
  }
  *(void *)&long long v31 = a1;
  *((void *)&v31 + 1) = v13;
  sub_100048BAC((uint64_t)&v31, v25);
  *a5 = xpc::dyn_cast_or_default((xpc *)v25, (const object *)0xFFFFFFFFLL, v14);
  xpc_release(v25[0]);
  v25[0] = 0;
  v25[1] = 0;
  uint64_t v26 = 0;
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  ctu::cf::assign();
  *(_OWORD *)BOOL v25 = v31;
  uint64_t v26 = v32;
  char v15 = (xpc_object_t *)v31;
  if (v32 >= 0) {
    char v15 = v25;
  }
  *(void *)&long long v31 = a1;
  *((void *)&v31 + 1) = v15;
  sub_100048BAC((uint64_t)&v31, __p);
  *a2 = xpc::dyn_cast_or_default((xpc *)__p, 0, v16);
  xpc_release(__p[0]);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v24 = 0;
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v31;
  uint64_t v24 = v32;
  char v17 = (xpc_object_t *)v31;
  if (v32 >= 0) {
    char v17 = __p;
  }
  v19[0] = a1;
  v19[1] = v17;
  sub_100048BAC((uint64_t)v19, &v20);
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v32) < 0) {
    operator delete((void *)v31);
  }
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(_OWORD *)a4 = *(_OWORD *)v21;
  *(void *)(a4 + 16) = v22;
  HIBYTE(v22) = 0;
  LOBYTE(v21[0]) = 0;
  xpc_release(v20);
  *(void *)&long long v31 = a1;
  *((void *)&v31 + 1) = kDataActivateFailureSatelliteSystemKey;
  sub_100048BAC((uint64_t)&v31, v21);
  *a6 = xpc::dyn_cast_or_default((xpc *)v21, 0, v18);
  xpc_release(v21[0]);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[0]);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(object[0]);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete((void *)v29);
  }
}

void sub_100BB32AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, xpc_object_t object, uint64_t a13, uint64_t a14, xpc_object_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,xpc_object_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  xpc_release(object);
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  if (*(char *)(v34 - 89) < 0) {
    operator delete(*(void **)(v34 - 112));
  }
  _Unwind_Resume(a1);
}

void sub_100BB33AC()
{
  if (*(char *)(v0 - 65) < 0) {
    JUMPOUT(0x100BB338CLL);
  }
  JUMPOUT(0x100BB3394);
}

void sub_100BB33C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,xpc_object_t object)
{
}

void sub_100BB33D8()
{
}

void sub_100BB33E0()
{
  if (*(char *)(v0 - 65) < 0) {
    JUMPOUT(0x100BB33A0);
  }
  JUMPOUT(0x100BB33A4);
}

void sub_100BB33F4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BB34D4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100BB35B4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

id sub_100BB35BC@<X0>(Registry *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X3>, uint64_t *a5@<X8>)
{
  if (a4) {
    uint64_t v5 = a4;
  }
  else {
    uint64_t v5 = a3;
  }
  if (!a1) {
    return objc_msgSend(v5, "copy", __p[0]);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(a5, a1);
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    xpc_object_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v29 = v10;
  int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v29);
  if (!v14)
  {
    std::mutex::unlock(v9);
    return objc_msgSend(v5, "copy", __p[0]);
  }
  uint64_t v16 = v14[3];
  char v15 = (std::__shared_weak_count *)v14[4];
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v9);
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
    if (!v16) {
      goto LABEL_30;
    }
  }
  else
  {
    std::mutex::unlock(v9);
    if (!v16) {
      return objc_msgSend(v5, "copy", __p[0]);
    }
  }
  uint64_t v28 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, void *, void *))(*(void *)v16 + 40))(&v28, v16, a2, a3, v5);
  if (v28) {
    char v17 = sub_1000810B8;
  }
  else {
    char v17 = 0;
  }
  if (!v17 || !v28)
  {
    sub_1000558F4(&v28);
    if (v15)
    {
LABEL_30:
      id v24 = 0;
LABEL_35:
      sub_10004D2C8(v15);
      goto LABEL_36;
    }
    return objc_msgSend(v5, "copy", __p[0]);
  }
  long long v29 = 0uLL;
  unint64_t v30 = 0;
  ctu::cf::assign();
  uint64_t v27 = v30;
  *(_OWORD *)std::string __p = v29;
  unint64_t v18 = HIBYTE(v30);
  int v19 = SHIBYTE(v30);
  if ((v30 & 0x8000000000000000) != 0) {
    unint64_t v18 = *((void *)&v29 + 1);
  }
  if (v18
    && ((v20 = objc_alloc((Class)NSString), v19 >= 0) ? (uint64_t v21 = __p) : (uint64_t v21 = (void **)__p[0]),
        (id v22 = objc_msgSend(v20, "initWithCString:encoding:", v21, 4, __p[0], __p[1], v27)) != 0))
  {
    id v23 = v22;
    if ([v23 isEqualToString:a3]) {
      id v24 = 0;
    }
    else {
      id v24 = v23;
    }
  }
  else
  {
    id v24 = 0;
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  sub_1000558F4(&v28);
  if (v15) {
    goto LABEL_35;
  }
LABEL_36:
  if (!v24) {
    return objc_msgSend(v5, "copy", __p[0]);
  }
  return v24;
}

void sub_100BB37D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a16);
  if (v22) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

void sub_100BB3818()
{
  if (!v0) {
    JUMPOUT(0x100BB3810);
  }
  JUMPOUT(0x100BB3808);
}

void sub_100BB382C()
{
}

__n128 sub_100BB3840(uint64_t a1)
{
  char v2 = (char *)operator new(0x18uLL);
  *(void *)char v2 = off_101A439F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100BB388C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A439F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BB38BC(uint64_t a1, xpc_object_t *a2)
{
  sub_10010C4E0(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(void *)(a1 + 16);
  char v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    sub_100480984((const VinylInfo **)(v3 + 96), &object);
    uint64_t v5 = xpc_copy_description(object);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v11 = 0;
    sub_100058DB0(__p, v5);
    free(v5);
    if (v11 >= 0) {
      BOOL v6 = __p;
    }
    else {
      BOOL v6 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    unsigned int v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I vinyl info: %s", buf, 0xCu);
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(object);
  }
  *(unsigned char *)(v3 + 120) = 0;
  uint64_t v7 = *(void *)(v3 + 96);
  uint64_t v8 = *(void *)(v3 + 104);
  if (v7 != v8) {
    *(unsigned char *)(v3 + 120) = *(_DWORD *)(v7 + 88 * ((v8 - v7 - 88) / 0x58uLL) + 12) == 3;
  }
}

void sub_100BB3A14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100BB3A48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BB3A88()
{
}

void sub_100BB3A98()
{
}

void *sub_100BB3AAC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A43A78;
  result[1] = v3;
  return result;
}

uint64_t sub_100BB3AF4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A43A78;
  a2[1] = v2;
  return result;
}

void sub_100BB3B20(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100BB3B28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BB3B68()
{
}

void sub_100BB3B78()
{
}

__n128 sub_100BB3B8C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A43AF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100BB3BD8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A43AF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BB3C08(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  char v4 = v3 + 1;
  uint64_t v5 = v3[1];
  id v20 = (char **)*v3;
  uint64_t v21 = (char *)v5;
  uint64_t v22 = v3[2];
  if (v22)
  {
    *(void *)(v5 + 16) = &v21;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    id v20 = &v21;
  }
  sub_1004CED98((uint64_t)v3, a2);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void **)(v6 + 128);
  if (*(void *)(v6 + 144) == v22)
  {
    if (v7 == (void *)(v6 + 136)) {
      goto LABEL_34;
    }
    uint64_t v8 = v20;
    while (*((_DWORD *)v7 + 8) == *((_DWORD *)v8 + 8) && operator==())
    {
      uint64_t v9 = (void *)v7[1];
      uint64_t v10 = v7;
      if (v9)
      {
        do
        {
          uint64_t v7 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v10[2];
          BOOL v11 = *v7 == (void)v10;
          uint64_t v10 = v7;
        }
        while (!v11);
      }
      uint64_t v12 = v8[1];
      if (v12)
      {
        do
        {
          unsigned int v13 = (char **)v12;
          uint64_t v12 = *(char **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unsigned int v13 = (char **)v8[2];
          BOOL v11 = *v13 == (char *)v8;
          uint64_t v8 = v13;
        }
        while (!v11);
      }
      uint64_t v8 = v13;
      if (v7 == (void *)(v6 + 136)) {
        goto LABEL_34;
      }
    }
    uint64_t v7 = *(void **)(v6 + 128);
  }
  if (v7 != (void *)(v6 + 136))
  {
    do
    {
      if (!*((unsigned char *)v7 + 68))
      {
        int v14 = *((_DWORD *)v7 + 16);
        int v15 = v14 == 2;
        if (*(unsigned __int8 *)(v6 + 184) != v15)
        {
          uint64_t v16 = *(NSObject **)(v6 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = asStringBool(v14 == 2);
            *(_DWORD *)std::string buf = 136315138;
            uint64_t v24 = v17;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I internet active: %s", buf, 0xCu);
          }
          *(unsigned char *)(v6 + 184) = v15;
        }
      }
      unint64_t v18 = (void *)v7[1];
      if (v18)
      {
        do
        {
          int v19 = v18;
          unint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          int v19 = (void *)v7[2];
          BOOL v11 = *v19 == (void)v7;
          uint64_t v7 = v19;
        }
        while (!v11);
      }
      uint64_t v7 = v19;
    }
    while (v19 != (void *)(v6 + 136));
  }
LABEL_34:
  sub_1000886C0((uint64_t)&v20, v21);
}

void sub_100BB3E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char *a13)
{
}

uint64_t sub_100BB3E64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BB3EA4()
{
}

void sub_100BB3EB4()
{
}

void *sub_100BB3EC8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A43B78;
  result[1] = v3;
  return result;
}

uint64_t sub_100BB3F10(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A43B78;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_100BB3F3C(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(int **)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int v8 = *v3;
    xpc_type_t result = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v8, (int *)a2, v5);
    *uint64_t v3 = v8;
  }
  else if (result == (xpc_type_t)&_xpc_type_BOOL {
         || result == (xpc_type_t)&_xpc_type_int64
  }
         || result == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
    *uint64_t v3 = (int)result;
  }
  return result;
}

uint64_t sub_100BB3FD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BB4018()
{
}

void sub_100BB4028()
{
}

void *sub_100BB403C(uint64_t a1)
{
  xpc_type_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *xpc_type_t result = off_101A43BF8;
  result[1] = v3;
  return result;
}

uint64_t sub_100BB4084(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A43BF8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100BB40B0(uint64_t a1, xpc *this, BOOL a3)
{
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_100BB40E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BB4120()
{
}

void sub_100BB4130()
{
}

void *sub_100BB4144(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A43C78;
  result[1] = v3;
  return result;
}

uint64_t sub_100BB418C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A43C78;
  a2[1] = v2;
  return result;
}

uint64_t sub_100BB41B8(uint64_t a1, const xpc::object *a2)
{
  return read_rest_value(*(StewieFeatureState **)(a1 + 8), a2);
}

uint64_t sub_100BB41C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BB4200()
{
}

uint64_t *sub_100BB420C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(unsigned char *)(*(void *)v1 + 64))
  {
    sub_100BB0BA8(v2, (void *)(v1 + 8));
  }
  sub_100BB4294(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100BB4278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100BB4294(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

void sub_100BB42EC(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I bootstrapping", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v18, *(Registry **)(v1 + 48));
  ctu::RestModule::connect();
  if (v19) {
    sub_10004D2C8(v19);
  }
  sub_100058DB0(__p, "/cc/props/vinyl_info");
  *(void *)std::string buf = off_101A439F8;
  id v23 = (std::__shared_weak_count *)(v1 + 96);
  uint64_t v24 = v1;
  BOOL v25 = buf;
  ctu::RestModule::observeProperty();
  uint64_t v3 = (capabilities::ct *)sub_10003F600(buf);
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  if (capabilities::ct::supportsGemini(v3))
  {
    sub_100058DB0(__p, "/cc/props/internet_connection_availability_any_sim");
    *(void *)std::string buf = off_101A43A78;
    id v23 = (std::__shared_weak_count *)(v1 + 152);
    BOOL v25 = buf;
    ctu::RestModule::observeProperty();
    sub_10003F600(buf);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100058DB0(__p, "/cc/props/internal_internet_connection_state");
  *(void *)std::string buf = off_101A43AF8;
  id v23 = (std::__shared_weak_count *)(v1 + 128);
  uint64_t v24 = v1;
  BOOL v25 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/airplane_mode_user_preference");
  *(void *)std::string buf = off_101A43B78;
  id v23 = (std::__shared_weak_count *)(v1 + 180);
  BOOL v25 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  sub_100BB0998(v1 + 176);
  sub_100058DB0(__p, "/cc/props/stewie_feature_state");
  *(void *)std::string buf = off_101A43C78;
  id v23 = (std::__shared_weak_count *)(v1 + 186);
  BOOL v25 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  char v4 = (uint64_t *)v21;
  if ((v4 & 0x80000000) != 0) {
    operator delete(__p[0]);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v1 + 48));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v7;
  BOOL v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_29;
      }
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
  if (!v13) {
    goto LABEL_29;
  }
LABEL_25:
  int v15 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v15 || (v16 = *(void *)(v1 + 8), (uint64_t v17 = std::__shared_weak_count::lock(v15)) == 0)) {
    sub_100088B9C();
  }
  *(void *)std::string buf = v16;
  id v23 = v17;
  (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v13 + 104))(v13, 52, buf);
  if (v23) {
    sub_10004D2C8(v23);
  }
LABEL_29:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  *(void *)(v1 + 192) = std::chrono::steady_clock::now().__d_.__rep_ - 86400000000000;
  *(unsigned char *)(v1 + 64) = 1;
  operator delete();
}

void sub_100BB4700(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_100BB47A4(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I shutting down", buf, 2u);
  }
  if (*(unsigned char *)(v1 + 64))
  {
    sub_100058DB0(buf, "/cc/props/vinyl_info");
    ctu::RestModule::unobserveProperty();
    if (v5 < 0) {
      operator delete(*(void **)buf);
    }
    ctu::RestModule::disconnect((ctu::RestModule *)(v1 + 80));
    *(unsigned char *)(v1 + 64) = 0;
  }
  operator delete();
}

void sub_100BB487C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  operator delete();
}

const __CFDictionary *HTTPRedirectMonitorMode::create@<X0>(NSObject **a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, const void **a5@<X4>, void *a6@<X8>)
{
  CFDictionaryRef result = (const __CFDictionary *)*a5;
  if (*a5) {
    int v8 = sub_100080778;
  }
  else {
    int v8 = 0;
  }
  if (v8)
  {
    uint64_t v75 = a1;
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(result, @"RATOverrides");
    if (Value && (v13 = Value, CFTypeID v14 = CFGetTypeID(Value), v14 == CFArrayGetTypeID()))
    {
      long long v78 = 0;
      uint64_t v79 = 0;
      BOOL v77 = (void **)&v78;
      int v89 = 0;
      uint64_t v90 = 0;
      unint64_t v88 = (void **)&v89;
      BOOL v73 = sub_100C936EC(v13, @"technology-mask");
      CFIndex Count = CFArrayGetCount(v13);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, i);
          CFDictionaryRef v18 = ValueAtIndex;
          if (ValueAtIndex)
          {
            CFTypeID v19 = CFGetTypeID(ValueAtIndex);
            if (v19 == CFDictionaryGetTypeID()) {
              CFDictionaryRef v20 = v18;
            }
            else {
              CFDictionaryRef v20 = 0;
            }
          }
          else
          {
            CFDictionaryRef v20 = 0;
          }
          CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(v20, @"technology-mask");
          CFNumberRef v22 = v21;
          if (v21)
          {
            CFTypeID v23 = CFGetTypeID(v21);
            if (v23 == CFNumberGetTypeID())
            {
              LODWORD(valuePtr[0]) = 0;
              if (CFNumberGetValue(v22, kCFNumberIntType, valuePtr))
              {
                long long __dst = 0uLL;
                uint64_t v92 = 0;
                sub_100C99B64((char)valuePtr[0], v73, &__dst);
                uint64_t v24 = (void *)__dst;
                if ((void)__dst != *((void *)&__dst + 1))
                {
                  CFDictionaryRef v25 = (const __CFDictionary *)CFDictionaryGetValue(v20, @"configuration");
                  CFDictionaryRef v26 = v25;
                  if (v25)
                  {
                    CFTypeID v27 = CFGetTypeID(v25);
                    if (v27 == CFDictionaryGetTypeID())
                    {
                      CFDictionaryRef v28 = (const __CFDictionary *)CFDictionaryGetValue(v26, @"PcoOutOfData");
                      CFDictionaryRef v29 = v28;
                      if (v28)
                      {
                        CFTypeID v30 = CFGetTypeID(v28);
                        if (v30 == CFDictionaryGetTypeID())
                        {
                          long long v31 = (int *)CFDictionaryGetValue(v29, @"ContainerId");
                          uint64_t v32 = v31;
                          LODWORD(__p[0]) = -1;
                          if (v31)
                          {
                            CFTypeID v33 = CFGetTypeID(v31);
                            if (v33 == CFNumberGetTypeID()) {
                              ctu::cf::assign((ctu::cf *)__p, v32, v34);
                            }
                            int v72 = (int)__p[0];
                            if (((uint64_t)__p[0] & 0x80000000) == 0)
                            {
                              CFArrayRef v35 = (const __CFArray *)CFDictionaryGetValue(v29, @"ExpiredValues");
                              CFArrayRef v36 = v35;
                              if (v35)
                              {
                                CFTypeID v37 = CFGetTypeID(v35);
                                if (v37 == CFArrayGetTypeID())
                                {
                                  memset(__p, 0, sizeof(__p));
                                  *(void *)&long long context = __p;
                                  v96.length = CFArrayGetCount(v36);
                                  v96.location = 0;
                                  CFArrayApplyFunction(v36, v96, (CFArrayApplierFunction)sub_1004CE630, &context);
                                  char v38 = __p[0];
                                  uint64_t v71 = __p[1];
                                  if (__p[0] != __p[1])
                                  {
                                    unint64_t v70 = (int *)*((void *)&__dst + 1);
                                    uint64_t v39 = (int *)__dst;
                                    if ((void)__dst != *((void *)&__dst + 1))
                                    {
                                      long long v67 = a3;
                                      unint64_t v68 = ((char *)__p[1] - (char *)__p[0]) >> 2;
                                      uint64_t v69 = __p[0];
                                      do
                                      {
                                        LODWORD(__p[0]) = v72;
                                        xpc_object_t __p[2] = 0;
                                        uint64_t v81 = 0;
                                        __p[1] = 0;
                                        sub_100448664(&__p[1], v38, (uint64_t)v71, v68);
                                        int v40 = *v39;
                                        char v41 = v89;
                                        for (j = &v89; ; char v41 = *j)
                                        {
                                          char v43 = j;
                                          if (!v41) {
                                            break;
                                          }
                                          while (1)
                                          {
                                            uint64_t j = (uint64_t **)v41;
                                            int v44 = *((_DWORD *)v41 + 8);
                                            if (v44 > v40) {
                                              break;
                                            }
                                            if (v44 >= v40) {
                                              goto LABEL_41;
                                            }
                                            char v41 = j[1];
                                            if (!v41)
                                            {
                                              char v43 = j + 1;
                                              goto LABEL_38;
                                            }
                                          }
                                        }
LABEL_38:
                                        uint64_t v45 = operator new(0x48uLL);
                                        v45[8] = v40;
                                        v45[10] = __p[0];
                                        *((_OWORD *)v45 + 3) = *(_OWORD *)&__p[1];
                                        *((void *)v45 + 8) = v81;
                                        xpc_object_t __p[2] = 0;
                                        uint64_t v81 = 0;
                                        __p[1] = 0;
                                        *(void *)uint64_t v45 = 0;
                                        *((void *)v45 + 1) = 0;
                                        *((void *)v45 + 2) = j;
                                        *char v43 = (uint64_t *)v45;
                                        if (*v88)
                                        {
                                          unint64_t v88 = (void **)*v88;
                                          uint64_t v45 = *v43;
                                        }
                                        sub_100046C90(v89, (uint64_t *)v45);
                                        ++v90;
LABEL_41:
                                        if (__p[1])
                                        {
                                          xpc_object_t __p[2] = __p[1];
                                          operator delete(__p[1]);
                                        }
                                        ++v39;
                                        char v38 = v69;
                                        a3 = v67;
                                      }
                                      while (v39 != v70);
                                    }
                                  }
                                  if (v38) {
                                    operator delete(v38);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  uint64_t v24 = (void *)__dst;
                }
                if (v24)
                {
                  *((void *)&__dst + 1) = v24;
                  operator delete(v24);
                }
              }
            }
          }
        }
      }
      sub_100BB69C0(v78);
      __int16 v46 = v89;
      BOOL v77 = v88;
      long long v78 = v89;
      uint64_t v79 = v90;
      if (v90)
      {
        v89[2] = (uint64_t)&v78;
        unint64_t v88 = (void **)&v89;
        int v89 = 0;
        uint64_t v90 = 0;
        __int16 v46 = 0;
      }
      else
      {
        BOOL v77 = (void **)&v78;
      }
      sub_100BB69C0(v46);
    }
    else
    {
      long long v78 = 0;
      uint64_t v79 = 0;
      BOOL v77 = (void **)&v78;
    }
    int v47 = *v75;
    __int16 v48 = (char *)operator new(0x180uLL);
    *((void *)v48 + 1) = 0;
    *((void *)v48 + 2) = 0;
    *(void *)__int16 v48 = off_101A43DD8;
    if (v47) {
      dispatch_retain(v47);
    }
    uint64_t v49 = *a3;
    __int16 v50 = (std::__shared_weak_count *)a3[1];
    if (v50) {
      atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100058198((const void **)&theDict, a5);
    sub_100BB6AF4((uint64_t)valuePtr, &v77);
    BOOL v94 = v47;
    if (v47) {
      dispatch_retain(v47);
    }
    v93[0] = v49;
    v93[1] = v50;
    if (v50) {
      atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(&__dst, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      long long __dst = *(_OWORD *)a4;
      uint64_t v92 = *(void *)(a4 + 16);
    }
    int v51 = v48 + 24;
    sub_10045E7FC((uint64_t)(v48 + 24), &v94, a2, v93, "mm.redirect", &__dst);
    if (SHIBYTE(v92) < 0) {
      operator delete((void *)__dst);
    }
    if (v50) {
      sub_10004D2C8(v50);
    }
    if (v94) {
      dispatch_release(v94);
    }
    *((void *)v48 + 3) = off_101A43CF8;
    sub_100058DB0(&v88, "mm.redirect");
    dispatch_object_t v87 = v47;
    if (v47) {
      dispatch_retain(v47);
    }
    dispatch_object_t v86 = 0;
    ctu::RestModule::RestModule();
    if (v86) {
      dispatch_release(v86);
    }
    if (v87) {
      dispatch_release(v87);
    }
    if (SHIBYTE(v90) < 0) {
      operator delete(v88);
    }
    *((void *)v48 + 31) = v48 + 256;
    *((_DWORD *)v48 + 48) = 0;
    *((void *)v48 + 26) = 0;
    *((void *)v48 + 25) = v48 + 208;
    *((void *)v48 + 27) = 0;
    *((void *)v48 + 29) = 0;
    *((void *)v48 + 28) = v48 + 232;
    *((void *)v48 + 30) = 0;
    *((void *)v48 + 32) = 0;
    *((void *)v48 + 33) = 0;
    CFDictionaryGetValue(theDict, @"DataPlanProbeUrl");
    sub_100058DB0(&context, "http://www.apple.com/library/test/success.html");
    ctu::cf::assign();
    *((_OWORD *)v48 + 17) = context;
    *((void *)v48 + 36) = v85;
    uint64_t v85 = 0;
    long long context = 0uLL;
    __int16 v52 = (double *)CFDictionaryGetValue(theDict, @"DataPlanProbeTimeout");
    int v53 = v52;
    __p[0] = (void *)0x4014000000000000;
    double v54 = 5.0;
    if (v52)
    {
      CFTypeID v55 = CFGetTypeID(v52);
      if (v55 == CFNumberGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)__p, v53, v56);
        double v54 = *(double *)__p;
      }
    }
    *((double *)v48 + 37) = v54;
    uint64_t v57 = (BOOL *)CFDictionaryGetValue(theDict, @"KeepPDPUpOnProbeError");
    std::string::size_type v58 = v57;
    LOBYTE(__p[0]) = 0;
    if (v57 && (CFTypeID v59 = CFGetTypeID(v57), v59 == CFBooleanGetTypeID()))
    {
      ctu::cf::assign((ctu::cf *)__p, v58, v60);
      char v61 = (char)__p[0];
    }
    else
    {
      char v61 = 0;
    }
    v48[304] = v61;
    CFArrayRef v62 = (const __CFArray *)CFDictionaryGetValue(theDict, @"CellularDataPlanNotSubscribedErrors");
    CFArrayRef v63 = v62;
    long long v76 = 0u;
    if (v62 && (CFTypeID v64 = CFGetTypeID(v62), v64 == CFArrayGetTypeID()))
    {
      memset(__p, 0, sizeof(__p));
      long long v95 = __p;
      v97.length = CFArrayGetCount(v63);
      v97.location = 0;
      CFArrayApplyFunction(v63, v97, (CFArrayApplierFunction)sub_1004CE630, &v95);
      long long v76 = *(_OWORD *)__p;
      BOOL v65 = __p[2];
    }
    else
    {
      BOOL v65 = 0;
    }
    *(_OWORD *)(v48 + 312) = v76;
    *((void *)v48 + 41) = v65;
    sub_100BB6AF4((uint64_t)(v48 + 336), valuePtr);
    *((void *)v48 + 45) = 0;
    *((void *)v48 + 46) = 0;
    *((_DWORD *)v48 + 94) = 0;
    sub_100BB69C0((void *)valuePtr[1]);
    sub_100057D78((const void **)&theDict);
    if (v50) {
      sub_10004D2C8(v50);
    }
    if (v47) {
      dispatch_release(v47);
    }
    *((void *)v48 + 3) = off_101A43E28;
    uint64_t v66 = (std::__shared_weak_count *)*((void *)v48 + 5);
    if (v66)
    {
      if (v66->__shared_owners_ != -1) {
        goto LABEL_101;
      }
      atomic_fetch_add_explicit((atomic_ullong *volatile)v48 + 1, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_ullong *volatile)v48 + 2, 1uLL, memory_order_relaxed);
      *((void *)v48 + 4) = v51;
      *((void *)v48 + 5) = v48;
      std::__shared_weak_count::__release_weak(v66);
    }
    else
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)v48 + 1, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_ullong *volatile)v48 + 2, 1uLL, memory_order_relaxed);
      *((void *)v48 + 4) = v51;
      *((void *)v48 + 5) = v48;
    }
    sub_10004D2C8((std::__shared_weak_count *)v48);
LABEL_101:
    __p[0] = 0;
    __p[1] = 0;
    sub_10003E168(__p, (void *)v48 + 4);
    operator new();
  }
  *a6 = 0;
  a6[1] = 0;
  return result;
}

void sub_100BB51EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,void *__p,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (__p) {
    operator delete(__p);
  }
  int v44 = *(void **)(v42 - 160);
  if (v44)
  {
    *(void *)(v42 - 152) = v44;
    operator delete(v44);
  }
  sub_100BB69C0(*(void **)(v42 - 176));
  sub_100BB69C0(a27);
  _Unwind_Resume(a1);
}

CellularPlanProvisioningMonitorModeInterface *sub_100BB53E0(uint64_t a1)
{
  *(void *)a1 = off_101A43CF8;
  uint64_t v2 = (ctu::RestModule *)(a1 + 152);
  sub_1004CD69C();
  sub_100058DB0(&__p, "/cc/props/reg_data_modes");
  ctu::RestModule::unobserveProperty();
  if (v8 < 0) {
    operator delete(__p);
  }
  sub_1004CD70C();
  sub_1004CD77C();
  ctu::RestModule::disconnect(v2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 344);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100BB69C0(*(void **)(a1 + 320));
  char v4 = *(void **)(a1 + 288);
  if (v4)
  {
    *(void *)(a1 + 296) = v4;
    operator delete(v4);
  }
  if (*(char *)(a1 + 271) < 0) {
    operator delete(*(void **)(a1 + 248));
  }
  sub_100088048(a1 + 224, *(void **)(a1 + 232));
  sub_1000346F8(a1 + 200, *(void **)(a1 + 208));
  sub_1000886C0(a1 + 176, *(char **)(a1 + 184));
  char v5 = *(std::__shared_weak_count **)(a1 + 160);
  if (v5) {
    sub_10004D2C8(v5);
  }

  return sub_10045E9DC((CellularPlanProvisioningMonitorModeInterface *)a1);
}

void sub_100BB550C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10006A6AC(a1);
}

void sub_100BB5534(uint64_t a1)
{
  sub_100BB53E0(a1);

  operator delete();
}

void sub_100BB556C(uint64_t a1)
{
  unsigned __int16 v2 = sub_100BB5BA8(a1);
  if (v2 >= 0x100u)
  {
    if (v2 != 3) {
      goto LABEL_27;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    char v5 = ServiceMap;
    if (v6 < 0)
    {
      uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = 5381;
      do
      {
        uint64_t v6 = v8;
        unsigned int v9 = *v7++;
        uint64_t v8 = (33 * v8) ^ v9;
      }
      while (v9);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v6;
    unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
    if (v10)
    {
      uint64_t v12 = v10[3];
      BOOL v11 = (std::__shared_weak_count *)v10[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v13 = 0;
        if (!v12)
        {
LABEL_25:
          if ((v13 & 1) == 0) {
            sub_10004D2C8(v11);
          }
LABEL_27:
          CFDictionaryRef v26 = *(std::__shared_weak_count **)(a1 + 344);
          *(void *)(a1 + 336) = 0;
          *(void *)(a1 + 344) = 0;
          if (!v26) {
            return;
          }
LABEL_53:
          sub_10004D2C8(v26);
          return;
        }
LABEL_23:
        uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 776))(v12);
        sub_100058DB0(v42, "HTTP Redirect Start");
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void **, uint64_t, void))(*(void *)v12 + 80))(v12, v25, 1, 1, v42, 1, 0);
        if (v43 < 0) {
          operator delete(v42[0]);
        }
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    std::mutex::unlock(v5);
    BOOL v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }
  if (!*(void *)(a1 + 336))
  {
    CFTypeID v14 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    int v15 = v14;
    if (v16 < 0)
    {
      uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        uint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(v14);
    *(void *)std::string buf = v16;
    CFDictionaryRef v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
    if (v20)
    {
      uint64_t v22 = v20[3];
      CFNumberRef v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
        if (!v22) {
          goto LABEL_19;
        }
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    CFNumberRef v21 = 0;
    char v23 = 1;
    if (!v22)
    {
LABEL_19:
      uint64_t v24 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "No request factory", buf, 2u);
      }
LABEL_51:
      if (v23) {
        return;
      }
      CFDictionaryRef v26 = v21;
      goto LABEL_53;
    }
LABEL_31:
    if (*(char *)(a1 + 271) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 248), *(void *)(a1 + 256));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 248);
      uint64_t v40 = *(void *)(a1 + 264);
    }
    v38[0] = 0;
    v38[1] = 0;
    *(void *)std::string buf = v38;
    (*(void (**)(long long *__return_ptr, uint64_t, void, void **, uint8_t *))(*(void *)v22 + 16))(&v41, v22, 0, __p, buf);
    long long v27 = v41;
    long long v41 = 0uLL;
    CFDictionaryRef v28 = *(std::__shared_weak_count **)(a1 + 344);
    *(_OWORD *)(a1 + 336) = v27;
    if (v28)
    {
      sub_10004D2C8(v28);
      if (*((void *)&v41 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v41 + 1));
      }
    }
    sub_10010C0E0((uint64_t)buf, v38[0]);
    if (SHIBYTE(v40) < 0) {
      operator delete(__p[0]);
    }
    if (*(void *)(a1 + 288) != *(void *)(a1 + 296)) {
      (*(void (**)(void, void))(**(void **)(a1 + 336) + 104))(*(void *)(a1 + 336), 0);
    }
    (*(void (**)(void, double))(**(void **)(a1 + 336) + 96))(*(void *)(a1 + 336), *(double *)(a1 + 272));
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 336) + 176))(*(void *)(a1 + 336), 1);
    (*(void (**)(void, void))(**(void **)(a1 + 336) + 152))(*(void *)(a1 + 336), kCTDataConnectionServiceTypeInternet);
    sub_10003E168(buf, (void *)(a1 + 8));
    uint64_t v30 = *(void *)buf;
    CFDictionaryRef v29 = (std::__shared_weak_count *)v38[0];
    if (v38[0])
    {
      atomic_fetch_add_explicit(v38[0] + 2, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v29);
    }
    (*(void (**)(void, void))(**(void **)(a1 + 336) + 8))(*(void *)(a1 + 336), *(void *)(a1 + 24));
    uint64_t v31 = *(void *)(a1 + 336);
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 1174405120;
    v35[2] = sub_100BB5D20;
    v35[3] = &unk_101A43D50;
    v35[4] = a1;
    v35[5] = v30;
    CFArrayRef v36 = v29;
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v31 + 16))(v31, v35);
    uint64_t v32 = *(void *)(a1 + 336);
    v33[1] = 0;
    uint64_t v34 = 0;
    v33[0] = 0;
    (*(void (**)(uint64_t, void **))(*(void *)v32 + 40))(v32, v33);
    if (SHIBYTE(v34) < 0) {
      operator delete(v33[0]);
    }
    if (v36) {
      std::__shared_weak_count::__release_weak(v36);
    }
    if (v29) {
      std::__shared_weak_count::__release_weak(v29);
    }
    goto LABEL_51;
  }
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Request already in-flight", buf, 2u);
  }
}

void sub_100BB5AF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BB5BA8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 184);
  if (!v1) {
    goto LABEL_11;
  }
  int v2 = *(_DWORD *)(a1 + 168);
  uint64_t v3 = a1 + 184;
  do
  {
    int v4 = *(_DWORD *)(v1 + 32);
    BOOL v5 = v4 < v2;
    if (v4 >= v2) {
      uint64_t v6 = (uint64_t *)v1;
    }
    else {
      uint64_t v6 = (uint64_t *)(v1 + 8);
    }
    if (!v5) {
      uint64_t v3 = v1;
    }
    uint64_t v1 = *v6;
  }
  while (*v6);
  if (v3 == a1 + 184 || (int v7 = *(_DWORD *)(v3 + 32), v2 < v7))
  {
LABEL_11:
    unsigned __int8 v8 = 0;
LABEL_12:
    unsigned int v9 = 1;
    return v8 | (v9 << 8);
  }
  uint64_t v11 = *(void *)(a1 + 232);
  if (!v11) {
    goto LABEL_39;
  }
  uint64_t v12 = a1 + 232;
  do
  {
    int v13 = *(_DWORD *)(v11 + 32);
    BOOL v14 = v13 < v7;
    if (v13 >= v7) {
      int v15 = (uint64_t *)v11;
    }
    else {
      int v15 = (uint64_t *)(v11 + 8);
    }
    if (!v14) {
      uint64_t v12 = v11;
    }
    uint64_t v11 = *v15;
  }
  while (*v15);
  if (v12 == a1 + 232 || v7 < *(_DWORD *)(v12 + 32)) {
    goto LABEL_39;
  }
  uint64_t v16 = *(unsigned __int8 *)(v12 + 135);
  if ((v16 & 0x80u) == 0) {
    uint64_t v17 = *(unsigned __int8 *)(v12 + 135);
  }
  else {
    uint64_t v17 = *(void *)(v12 + 120);
  }
  uint64_t v18 = *(unsigned __int8 *)(a1 + 87);
  int v19 = (char)v18;
  if ((v18 & 0x80u) != 0) {
    uint64_t v18 = *(void *)(a1 + 72);
  }
  if (v17 != v18) {
    goto LABEL_39;
  }
  CFDictionaryRef v20 = (const void **)(v12 + 112);
  char v23 = *(unsigned __int8 **)(a1 + 64);
  CFNumberRef v21 = (unsigned __int8 *)(a1 + 64);
  uint64_t v22 = v23;
  if (v19 >= 0) {
    uint64_t v24 = v21;
  }
  else {
    uint64_t v24 = v22;
  }
  if ((v16 & 0x80) != 0)
  {
    if (!memcmp(*v20, v24, *(void *)(v12 + 120))) {
      goto LABEL_40;
    }
LABEL_39:
    unsigned __int8 v8 = 1;
    goto LABEL_12;
  }
  if (*(unsigned char *)(v12 + 135))
  {
    while (*(unsigned __int8 *)v20 == *v24)
    {
      CFDictionaryRef v20 = (const void **)((char *)v20 + 1);
      ++v24;
      if (!--v16) {
        goto LABEL_40;
      }
    }
    goto LABEL_39;
  }
LABEL_40:
  if (*(_DWORD *)(v12 + 48) == 5)
  {
    unsigned int v25 = *(_DWORD *)(v3 + 64);
    BOOL v26 = v25 > 3;
    LOBYTE(v25) = 8 * v25;
    unsigned int v27 = 0x3000403u >> v25;
    unsigned int v9 = 0x1000101u >> v25;
    if (v26) {
      unsigned __int8 v8 = 0;
    }
    else {
      unsigned __int8 v8 = v27;
    }
    if (v26) {
      unsigned int v9 = 1;
    }
  }
  else
  {
    unsigned int v9 = 1;
    unsigned __int8 v8 = 2;
  }
  return v8 | (v9 << 8);
}

void sub_100BB5D20(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (!a1[5])
      {
LABEL_40:
        sub_10004D2C8(v7);
        return;
      }
      unsigned __int8 v8 = *(std::__shared_weak_count **)(v5 + 344);
      *(void *)(v5 + 336) = 0;
      *(void *)(v5 + 344) = 0;
      if (v8) {
        sub_10004D2C8(v8);
      }
      if ((*(unsigned int (**)(void))(**(void **)a2 + 16))() == 1)
      {
        if ((*(unsigned int (**)(void))(**(void **)a2 + 24))() == 200)
        {
          int v9 = 0;
          __int16 v10 = 1;
        }
        else
        {
          uint64_t v12 = *(_DWORD **)(v5 + 288);
          int v13 = *(_DWORD **)(v5 + 296);
          if (v12 != v13)
          {
            int v14 = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
            while (*v12 != v14)
            {
              if (++v12 == v13)
              {
                __int16 v10 = 0;
                BOOL v11 = 0;
                goto LABEL_10;
              }
            }
            int v15 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              int v16 = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
              *(_DWORD *)std::string buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v16;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Matched expiry failure code: %d", buf, 8u);
            }
          }
          __int16 v10 = 0;
          int v9 = 1;
        }
        BOOL v11 = 1;
      }
      else
      {
        __int16 v10 = 0;
        BOOL v11 = *(void *)(v5 + 288) == *(void *)(v5 + 296);
LABEL_10:
        int v9 = 1;
      }
      if (!v11) {
        int v9 = 1;
      }
      if (*(unsigned char *)(v5 + 280)) {
        BOOL v17 = 1;
      }
      else {
        BOOL v17 = v9 == 0;
      }
      if (v17)
      {
LABEL_39:
        sub_10045EEC8(v5, v10 | (v11 << 8));
        goto LABEL_40;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v5 + 48));
      int v19 = ServiceMap;
      if (v20 < 0)
      {
        CFNumberRef v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v22 = 5381;
        do
        {
          uint64_t v20 = v22;
          unsigned int v23 = *v21++;
          uint64_t v22 = (33 * v22) ^ v23;
        }
        while (v23);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v20;
      uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
      if (v24)
      {
        uint64_t v26 = v24[3];
        unsigned int v25 = (std::__shared_weak_count *)v24[4];
        if (v25)
        {
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v19);
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v25);
          char v27 = 0;
          if (!v26)
          {
LABEL_37:
            if ((v27 & 1) == 0) {
              sub_10004D2C8(v25);
            }
            goto LABEL_39;
          }
LABEL_35:
          uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 776))(v26);
          sub_100058DB0(__p, "HTTP Redirect Failure");
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void **, uint64_t, void))(*(void *)v26 + 80))(v26, v28, 1, 0, __p, 1, 0);
          if (v30 < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_37;
        }
      }
      else
      {
        uint64_t v26 = 0;
      }
      std::mutex::unlock(v19);
      unsigned int v25 = 0;
      char v27 = 1;
      if (!v26) {
        goto LABEL_37;
      }
      goto LABEL_35;
    }
  }
}

void sub_100BB6090(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100BB60E8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100BB6104(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100BB611C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 184);
  if (!v1) {
    return;
  }
  int v3 = *(_DWORD *)(a1 + 168);
  uint64_t v4 = a1 + 184;
  do
  {
    int v5 = *(_DWORD *)(v1 + 32);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      int v7 = (uint64_t *)v1;
    }
    else {
      int v7 = (uint64_t *)(v1 + 8);
    }
    if (!v6) {
      uint64_t v4 = v1;
    }
    uint64_t v1 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 184) {
    return;
  }
  int v8 = *(_DWORD *)(v4 + 32);
  if (v3 < v8) {
    return;
  }
  uint64_t v9 = *(void *)(a1 + 232);
  if (!v9) {
    return;
  }
  uint64_t v10 = a1 + 232;
  do
  {
    int v11 = *(_DWORD *)(v9 + 32);
    BOOL v12 = v11 < v8;
    if (v11 >= v8) {
      int v13 = (uint64_t *)v9;
    }
    else {
      int v13 = (uint64_t *)(v9 + 8);
    }
    if (!v12) {
      uint64_t v10 = v9;
    }
    uint64_t v9 = *v13;
  }
  while (*v13);
  if (v10 == a1 + 232 || v8 < *(_DWORD *)(v10 + 32)) {
    return;
  }
  uint64_t v14 = *(unsigned __int8 *)(v10 + 135);
  size_t v15 = *(void *)(v10 + 120);
  if ((v14 & 0x80u) == 0) {
    uint64_t v16 = *(unsigned __int8 *)(v10 + 135);
  }
  else {
    uint64_t v16 = *(void *)(v10 + 120);
  }
  uint64_t v17 = *(unsigned __int8 *)(a1 + 87);
  int v18 = (char)v17;
  if ((v17 & 0x80u) != 0) {
    uint64_t v17 = *(void *)(a1 + 72);
  }
  if (v16 != v17) {
    return;
  }
  int v19 = (const void **)(v10 + 112);
  if (v18 >= 0) {
    uint64_t v20 = (unsigned __int8 *)(a1 + 64);
  }
  else {
    uint64_t v20 = *(unsigned __int8 **)(a1 + 64);
  }
  if ((v14 & 0x80) != 0)
  {
    if (memcmp(*v19, v20, v15)) {
      return;
    }
    goto LABEL_36;
  }
  if (!v14)
  {
LABEL_36:
    int v21 = *(_DWORD *)(v4 + 64);
    if (v21)
    {
      if (v21 == 2)
      {
        if (!*(_DWORD *)(a1 + 352)) {
          sub_100BB556C(a1);
        }
        *(_DWORD *)(a1 + 352) = 2;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 352) = 0;
    }
    return;
  }
  while (*(unsigned __int8 *)v19 == *v20)
  {
    int v19 = (const void **)((char *)v19 + 1);
    ++v20;
    if (!--v14) {
      goto LABEL_36;
    }
  }
}

void sub_100BB626C(void *a1, int *a2)
{
  if (a1[41])
  {
    if (a2[2])
    {
      unsigned __int16 v4 = sub_100BB5BA8((uint64_t)a1);
      if (v4 < 0x100u || v4 != 1)
      {
        int v5 = (unsigned __int8 *)*((void *)a2 + 3);
        if (v5 != *((unsigned __int8 **)a2 + 4))
        {
          uint64_t v6 = a1[26];
          if (v6)
          {
            int v7 = *a2;
            int v8 = a1 + 26;
            do
            {
              int v9 = *(_DWORD *)(v6 + 28);
              BOOL v10 = v9 < v7;
              if (v9 >= v7) {
                int v11 = (uint64_t *)v6;
              }
              else {
                int v11 = (uint64_t *)(v6 + 8);
              }
              if (!v10) {
                int v8 = (void *)v6;
              }
              uint64_t v6 = *v11;
            }
            while (*v11);
            if (v8 != a1 + 26 && v7 >= *((_DWORD *)v8 + 7))
            {
              uint64_t v12 = a1[40];
              if (v12)
              {
                int v13 = *((_DWORD *)v8 + 8);
                uint64_t v14 = a1 + 40;
                do
                {
                  int v15 = *(_DWORD *)(v12 + 32);
                  BOOL v16 = v15 < v13;
                  if (v15 >= v13) {
                    uint64_t v17 = (uint64_t *)v12;
                  }
                  else {
                    uint64_t v17 = (uint64_t *)(v12 + 8);
                  }
                  if (!v16) {
                    uint64_t v14 = (void *)v12;
                  }
                  uint64_t v12 = *v17;
                }
                while (*v17);
                if (v14 != a1 + 40 && v13 >= *((_DWORD *)v14 + 8) && a2[4] == *((_DWORD *)v14 + 10))
                {
                  int v19 = (_DWORD *)v14[6];
                  int v18 = (_DWORD *)v14[7];
                  if (v19 != v18)
                  {
                    int v20 = *v5;
                    while (*v19 != v20)
                    {
                      if (++v19 == v18) {
                        return;
                      }
                    }
                    int v21 = a1[5];
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                    {
                      v22[0] = 67109120;
                      v22[1] = v20;
                      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Matched PCO expiry: 0x%02x", (uint8_t *)v22, 8u);
                    }
                    sub_100BB556C((uint64_t)a1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void sub_100BB6418(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned __int16 v4 = (void *)(a1 + 248);
    if (*(char *)(a1 + 271) < 0) {
      unsigned __int16 v4 = (void *)*v4;
    }
    std::string::size_type v5 = *(void *)(a1 + 272);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v4;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v5;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    uint64_t v30 = printers::asString((printers *)(a1 + 280), v3);
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I URL %s - Timeout: %f, Keep PDP up: %s", (uint8_t *)&buf, 0x20u);
  }
  int v7 = *(int **)(a1 + 288);
  uint64_t v6 = *(int **)(a1 + 296);
  if (v7 != v6)
  {
    int v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      memset(&v28, 0, sizeof(v28));
      std::to_string(&buf, *v7);
      std::string v28 = buf;
      for (CFIndex i = v7 + 1; i != v6; ++i)
      {
        *((unsigned char *)&buf.__r_.__value_.__s + 23) = 1;
        strcpy((char *)&buf, ",");
        std::string::append(&v28, (const std::string::value_type *)&buf, 1uLL);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        std::to_string(&buf, *i);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_std::string buf = &buf;
        }
        else {
          p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = buf.__r_.__value_.__l.__size_;
        }
        std::string::append(&v28, (const std::string::value_type *)p_buf, size);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
      uint64_t v12 = &v28;
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v12 = (std::string *)v28.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Expiry HTTP Responses: %{public}s", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
    }
  }
  if (*(void *)(a1 + 328))
  {
    int v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I PCO Expiry Config:", (uint8_t *)&buf, 2u);
    }
    uint64_t v14 = *(void **)(a1 + 312);
    if (v14 != (void *)(a1 + 320))
    {
      do
      {
        int v15 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I {", (uint8_t *)&buf, 2u);
          int v15 = *(NSObject **)(a1 + 40);
        }
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = asString();
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I  Data Mode: %s", (uint8_t *)&buf, 0xCu);
          int v15 = *(NSObject **)(a1 + 40);
        }
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          std::to_string(&buf, *((_DWORD *)v14 + 10));
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v17 = &buf;
          }
          else {
            uint64_t v17 = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          LODWORD(v28.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v28.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I  Technology: %s", (uint8_t *)&v28, 0xCu);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          int v15 = *(NSObject **)(a1 + 40);
        }
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          int v19 = (int *)v14[6];
          int v18 = (int *)v14[7];
          memset(&v28, 0, sizeof(v28));
          if (v19 != v18)
          {
            std::to_string(&buf, *v19);
            std::string v28 = buf;
            while (++v19 != v18)
            {
              *((unsigned char *)&buf.__r_.__value_.__s + 23) = 1;
              strcpy((char *)&buf, ",");
              std::string::append(&v28, (const std::string::value_type *)&buf, 1uLL);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
              std::to_string(&buf, *v19);
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                int v20 = &buf;
              }
              else {
                int v20 = (std::string *)buf.__r_.__value_.__r.__words[0];
              }
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type v21 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type v21 = buf.__r_.__value_.__l.__size_;
              }
              std::string::append(&v28, (const std::string::value_type *)v20, v21);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
            }
          }
          uint64_t v22 = &v28;
          if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint64_t v22 = (std::string *)v28.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v22;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I  Failure Codes: %{public}s", (uint8_t *)&buf, 0xCu);
          if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v28.__r_.__value_.__l.__data_);
          }
          int v15 = *(NSObject **)(a1 + 40);
        }
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I }", (uint8_t *)&buf, 2u);
        }
        unsigned int v23 = (void *)v14[1];
        if (v23)
        {
          do
          {
            uint64_t v24 = v23;
            unsigned int v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            uint64_t v24 = (void *)v14[2];
            BOOL v25 = *v24 == (void)v14;
            uint64_t v14 = v24;
          }
          while (!v25);
        }
        uint64_t v14 = v24;
      }
      while (v24 != (void *)(a1 + 320));
    }
  }
  uint64_t v26 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = asString();
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v27;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Connection State: %s", (uint8_t *)&buf, 0xCu);
  }
  sub_10045EC1C(a1);
}

void sub_100BB6968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BB69C0(void *a1)
{
  if (a1)
  {
    sub_100BB69C0(*a1);
    sub_100BB69C0(a1[1]);
    uint64_t v2 = (void *)a1[6];
    if (v2)
    {
      a1[7] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

void sub_100BB6A1C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A43DD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BB6A3C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A43DD8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BB6A90(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100BB6ABC(uint64_t a1)
{
  sub_100BB53E0(a1);

  operator delete();
}

uint64_t sub_100BB6AF4(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  int v3 = (uint64_t **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  unsigned __int16 v4 = a2 + 1;
  std::string::size_type v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      uint64_t v6 = *(void *)(a1 + 8);
      int v7 = v3;
      if (*(uint64_t ***)a1 == v3) {
        goto LABEL_8;
      }
      uint64_t v8 = *(void *)(a1 + 8);
      int v9 = v3;
      if (v6)
      {
        do
        {
          int v7 = (uint64_t **)v8;
          uint64_t v8 = *(void *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        do
        {
          int v7 = (uint64_t **)v9[2];
          BOOL v10 = *v7 == (uint64_t *)v9;
          int v9 = v7;
        }
        while (v10);
      }
      int v11 = *((_DWORD *)v5 + 8);
      if (*((_DWORD *)v7 + 8) < v11)
      {
LABEL_8:
        if (v6) {
          uint64_t v12 = v7;
        }
        else {
          uint64_t v12 = v3;
        }
        if (v6) {
          int v13 = v7 + 1;
        }
        else {
          int v13 = v3;
        }
        if (*v13) {
          goto LABEL_25;
        }
      }
      else
      {
        int v13 = v3;
        uint64_t v12 = v3;
        if (v6)
        {
          uint64_t v14 = *(uint64_t **)(a1 + 8);
          while (1)
          {
            while (1)
            {
              uint64_t v12 = (uint64_t **)v14;
              int v15 = *((_DWORD *)v14 + 8);
              if (v15 <= v11) {
                break;
              }
              uint64_t v14 = *v12;
              int v13 = v12;
              if (!*v12) {
                goto LABEL_24;
              }
            }
            if (v15 >= v11) {
              goto LABEL_25;
            }
            uint64_t v14 = v12[1];
            if (!v14)
            {
              int v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_24:
      uint64_t v16 = operator new(0x48uLL);
      int v17 = *((_DWORD *)v5 + 8);
      int v18 = *((_DWORD *)v5 + 10);
      v16[6] = 0;
      *((_DWORD *)v16 + 8) = v17;
      *((_DWORD *)v16 + 10) = v18;
      v16[7] = 0;
      v16[8] = 0;
      sub_100448664(v16 + 6, (const void *)v5[6], v5[7], (uint64_t)(v5[7] - v5[6]) >> 2);
      sub_100046C38((uint64_t **)a1, (uint64_t)v12, v13, v16);
LABEL_25:
      int v19 = (void *)v5[1];
      if (v19)
      {
        do
        {
          int v20 = v19;
          int v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          int v20 = (void *)v5[2];
          BOOL v10 = *v20 == (void)v5;
          std::string::size_type v5 = v20;
        }
        while (!v10);
      }
      std::string::size_type v5 = v20;
    }
    while (v20 != v4);
  }
  return a1;
}

void sub_100BB6C7C(_Unwind_Exception *a1)
{
  operator delete(v1);
  sub_100BB69C0(*v2);
  _Unwind_Resume(a1);
}

void sub_100BB6CA4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  Registry::createRestModuleOneTimeUseConnection(&v6, *(Registry **)(v1 + 48));
  ctu::RestModule::connect();
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_10041BCB4(v1 + 168);
  sub_100058DB0(__p, "/cc/props/internal_internet_connection_state");
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A43EA8;
  v2[1] = v1 + 176;
  v2[2] = v1;
  v2[3] = sub_100BB611C;
  v2[4] = 0;
  int v11 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  int v3 = operator new(0x28uLL);
  *int v3 = off_101A43F28;
  v3[1] = v1 + 224;
  v3[2] = v1;
  v3[3] = sub_100BB6FD0;
  v3[4] = 0;
  int v11 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (*(void *)(v1 + 328))
  {
    sub_100256070(v1 + 200);
    sub_100058DB0(__p, "/cc/events/pco_update");
    unsigned __int16 v4 = operator new(0x20uLL);
    void *v4 = off_101A43FA8;
    v4[1] = v1;
    uint64_t v4[2] = sub_100BB626C;
    uint64_t v4[3] = 0;
    int v11 = v4;
    ctu::RestModule::observeEvent();
    sub_10003F600(v10);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  std::string::size_type v5 = operator new(0x20uLL);
  *std::string::size_type v5 = off_101A44028;
  v5[1] = v1;
  v5[2] = sub_1004CEC08;
  v5[3] = 0;
  int v11 = v5;
  ctu::RestModule::observeEvent();
  sub_10003F600(v10);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  operator delete();
}

void sub_100BB6F50(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  operator delete();
}

uint64_t sub_100BB6FD0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

void sub_100BB6FF8()
{
}

__n128 sub_100BB700C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A43EA8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BB7060(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A43EA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BB7098(uint64_t *a1, xpc_object_t *a2)
{
  sub_1004CED98(a1[1], a2);
  int v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  std::string::size_type v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    int v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100BB7114(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BB7154()
{
}

void sub_100BB7164()
{
}

__n128 sub_100BB7178(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A43F28;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BB71CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A43F28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BB7204(void *a1, xpc_object_t *a2)
{
  int v3 = (std::string *)a1[1];
  long long v21 = 0uLL;
  uint64_t v22 = 0;
  sub_100089CF0((uint64_t *)&v21, a2);
  p_std::string::size_type size = &v3->__r_.__value_.__l.__size_;
  std::string::size_type size = (void *)v3->__r_.__value_.__l.__size_;
  int v18 = (void **)v3->__r_.__value_.__r.__words[0];
  int v19 = size;
  std::string::size_type v20 = v3->__r_.__value_.__r.__words[2];
  if (v20)
  {
    size[2] = &v19;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    *p_std::string::size_type size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    int v18 = (void **)&v19;
  }
  long long v16 = v21;
  uint64_t v17 = v22;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v16);
  unsigned int v23 = (void **)&v16;
  sub_10008A88C(&v23);
  if (v20 == v3->__r_.__value_.__r.__words[2])
  {
    uint64_t v6 = v18;
    if (v18 == (void **)&v19) {
      goto LABEL_24;
    }
    int v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      uint64_t v8 = (void **)v6[1];
      char v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          uint64_t v6 = v8;
          uint64_t v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v6 = v9[2];
          BOOL v10 = *v6 == v9;
          char v9 = (void ***)v6;
        }
        while (!v10);
      }
      int v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          int v7 = v12;
        }
        while (!v10);
      }
      int v7 = v12;
      if (v6 == (void **)&v19) {
        goto LABEL_24;
      }
    }
  }
  int v13 = (void (*)(void *))a1[3];
  uint64_t v14 = a1[4];
  int v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    int v13 = *(void (**)(void *))(*v15 + v13);
  }
  v13(v15);
LABEL_24:
  sub_100088048((uint64_t)&v18, v19);
  int v18 = (void **)&v21;
  sub_10008A88C(&v18);
}

void sub_100BB73C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, void *a13, uint64_t a14, char a15)
{
  a12 = (void **)&a15;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100BB740C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BB744C()
{
}

void sub_100BB745C()
{
}

__n128 sub_100BB7470(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A43FA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100BB74C4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A43FA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100BB74FC(void *a1)
{
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  long long v5 = 0u;
  read_rest_value();
  uint64_t v2 = (void (*)(void *, long long *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, long long *))(*v4 + v2);
  }
  v2(v4, &v5);
  if (__p[1])
  {
    *(void **)&long long v7 = __p[1];
    operator delete(__p[1]);
  }
}

void sub_100BB7594(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BB75B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BB75F0()
{
}

void sub_100BB7600()
{
}

__n128 sub_100BB7614(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A44028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100BB7668(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A44028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BB76A0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100BB76E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BB7728()
{
}

void sub_100BB7734(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 64) == 1)
  {
    uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v1 || (uint64_t v2 = std::__shared_weak_count::lock(v1)) == 0) {
      sub_100088B9C();
    }
    uint64_t v3 = v2;
    p_shared_weak_owners = &v2->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    sub_10017B514();
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    sub_10017B514();
    std::__shared_weak_count::__release_weak(v3);
    std::__shared_weak_count::__release_weak(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100BB7888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (a22) {
    std::__shared_weak_count::__release_weak(a22);
  }
  std::__shared_weak_count::__release_weak(v22);
  _Unwind_Resume(a1);
}

void sub_100BB78BC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        long long v5 = *(std::__shared_weak_count **)(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100BB79CC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100BB79E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100BB79F8(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        long long v5 = *(std::__shared_weak_count **)(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100BB7B08(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 32);
  if (*(unsigned char *)(v2 + 712))
  {
    int v3 = *(unsigned __int16 *)(v2 + 688);
    *(_DWORD *)(a2 + 52) |= 5u;
    *(_DWORD *)(a2 + 16) = 3;
    *(_DWORD *)(a2 + 20) = v3;
  }
  uint64_t v4 = *(void **)(v2 + 584);
  long long v7 = (void *)*v4;
  long long v5 = v4 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    int v8 = *(_DWORD *)(a2 + 52);
    do
    {
      if (*((_DWORD *)v6 + 8) == 1)
      {
        int v9 = *((_DWORD *)v6 + 9);
        if (v9 == 1)
        {
          double v11 = *((double *)v6 + 5);
          v8 |= 0x10u;
          *(_DWORD *)(a2 + 52) = v8;
          *(void *)(a2 + 32) = (uint64_t)v11;
        }
        else if (v9 == 2)
        {
          double v10 = *((double *)v6 + 5);
          v8 |= 8u;
          *(_DWORD *)(a2 + 52) = v8;
          *(void *)(a2 + 24) = (uint64_t)v10;
        }
      }
      uint64_t v12 = (void *)v6[1];
      if (v12)
      {
        do
        {
          int v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          int v13 = (void *)v6[2];
          BOOL v14 = *v13 == (void)v6;
          uint64_t v6 = v13;
        }
        while (!v14);
      }
      uint64_t v6 = v13;
    }
    while (v13 != v5);
  }
  return result;
}

void sub_100BB7BCC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v3 + 888))
  {
    *(_DWORD *)(a2 + 64) |= 1u;
    *(_DWORD *)(a2 + 16) = 0;
    formPLMN((const MCC *)(v3 + 808), (const MNC *)(v3 + 840));
    *(_DWORD *)(a2 + 64) |= 2u;
    uint64_t v4 = *(std::string **)(a2 + 8);
    if (v4 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v4, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    int v5 = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(a2 + 56) = *(unsigned __int16 *)(v3 + 874);
    int v6 = *(unsigned __int16 *)(v3 + 876);
    *(_DWORD *)(a2 + 64) = v5 | 0xC;
    *(_DWORD *)(a2 + 20) = v6;
  }
  if (*(unsigned char *)(v3 + 992))
  {
    *(_DWORD *)(a2 + 64) |= 1u;
    *(_DWORD *)(a2 + 16) = 2;
    formPLMN((const MCC *)(v3 + 904), (const MNC *)(v3 + 936));
    *(_DWORD *)(a2 + 64) |= 2u;
    long long v7 = *(std::string **)(a2 + 8);
    if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v7, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    int v8 = *(unsigned __int16 *)(v3 + 970);
    int v9 = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(a2 + 64) = v9 | 8;
    *(_DWORD *)(a2 + 56) = v8;
    int v10 = *(_DWORD *)(v3 + 972);
    *(_DWORD *)(a2 + 64) = v9 | 0xC;
    *(_DWORD *)(a2 + 20) = v10;
  }
  if (*(unsigned char *)(v3 + 1128))
  {
    *(_DWORD *)(a2 + 64) |= 1u;
    *(_DWORD *)(a2 + 16) = 7;
    formPLMN((const MCC *)(v3 + 1008), (const MNC *)(v3 + 1040));
    *(_DWORD *)(a2 + 64) |= 2u;
    double v11 = *(std::string **)(a2 + 8);
    if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v11, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    int v12 = *(_DWORD *)(v3 + 1076);
    int v13 = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(a2 + 64) = v13 | 8;
    *(_DWORD *)(a2 + 56) = v12;
    int v14 = *(_DWORD *)(v3 + 1080);
    *(_DWORD *)(a2 + 64) = v13 | 0xC;
    *(_DWORD *)(a2 + 20) = v14;
  }
  if (*(unsigned char *)(v3 + 1232))
  {
    *(_DWORD *)(a2 + 64) |= 1u;
    *(_DWORD *)(a2 + 16) = 9;
    formPLMN((const MCC *)(v3 + 1144), (const MNC *)(v3 + 1176));
    *(_DWORD *)(a2 + 64) |= 2u;
    int v15 = *(std::string **)(a2 + 8);
    if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v15, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    int v16 = *(unsigned __int16 *)(v3 + 1210);
    int v17 = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(a2 + 64) = v17 | 8;
    *(_DWORD *)(a2 + 56) = v16;
    int v18 = *(_DWORD *)(v3 + 1212);
    *(_DWORD *)(a2 + 64) = v17 | 0xC;
    *(_DWORD *)(a2 + 20) = v18;
  }
  if (*(unsigned char *)(v3 + 1376))
  {
    *(_DWORD *)(a2 + 64) |= 1u;
    *(_DWORD *)(a2 + 16) = 10;
    formPLMN((const MCC *)(v3 + 1248), (const MNC *)(v3 + 1280));
    *(_DWORD *)(a2 + 64) |= 2u;
    int v19 = *(std::string **)(a2 + 8);
    if (v19 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v19, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    int v20 = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(v3 + 1316);
    uint64_t v21 = *(void *)(v3 + 1320);
    *(_DWORD *)(a2 + 64) = v20 | 0xC;
    *(_DWORD *)(a2 + 20) = v21;
  }
  uint64_t v22 = *(void **)(v3 + 584);
  BOOL v25 = (void *)*v22;
  unsigned int v23 = v22 + 1;
  uint64_t v24 = v25;
  if (v25 != v23)
  {
    int v26 = *(_DWORD *)(a2 + 64);
    do
    {
      if (*((_DWORD *)v24 + 8))
      {
        int v27 = *((_DWORD *)v24 + 9);
        switch(v27)
        {
          case 4:
            double v29 = *((double *)v24 + 5);
            v26 |= 0x20u;
            *(_DWORD *)(a2 + 64) = v26;
            *(void *)(a2 + 32) = (uint64_t)v29;
            break;
          case 3:
            double v30 = *((double *)v24 + 5);
            v26 |= 0x40u;
            *(_DWORD *)(a2 + 64) = v26;
            *(void *)(a2 + 40) = (uint64_t)v30;
            break;
          case 0:
            double v28 = *((double *)v24 + 5);
            v26 |= 0x10u;
            *(_DWORD *)(a2 + 64) = v26;
            *(void *)(a2 + 24) = (uint64_t)v28;
            break;
        }
      }
      uint64_t v31 = (void *)v24[1];
      if (v31)
      {
        do
        {
          char v32 = v31;
          uint64_t v31 = (void *)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          char v32 = (void *)v24[2];
          BOOL v33 = *v32 == (void)v24;
          uint64_t v24 = v32;
        }
        while (!v33);
      }
      uint64_t v24 = v32;
    }
    while (v32 != v23);
  }
}

void sub_100BB7FD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BB8004(uint64_t a1, unsigned __int16 **a2, unsigned __int8 **a3, unsigned __int16 **a4, unsigned __int16 **a5, unsigned __int16 **a6, unsigned __int16 **a7, unsigned __int16 **a8)
{
  uint64_t v15 = *(void *)(a1 + 1392);
  if (!v15) {
    operator new();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 32))(v15);
  int v18 = *a2;
  int v17 = a2[1];
  if (v17 != *a2)
  {
    do
    {
      int v19 = *(int **)(a1 + 1392);
      int v20 = v19[13];
      uint64_t v21 = v19[12];
      if ((int)v21 >= v20)
      {
        if (v20 == v19[14])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v19 + 10), v20 + 1);
          int v20 = v19[13];
        }
        v19[13] = v20 + 1;
        operator new();
      }
      uint64_t v22 = *((void *)v19 + 5);
      v19[12] = v21 + 1;
      unsigned int v23 = *(_DWORD **)(v22 + 8 * v21);
      int v24 = v23[7];
      int v25 = v18[1];
      void v23[2] = *(unsigned __int8 *)v18;
      v23[3] = v25;
      int v26 = v18[2];
      int v27 = v18[3];
      v23[7] = v24 | 0xF;
      v23[4] = v26;
      v23[5] = v27;
      v18 += 4;
    }
    while (v18 != v17);
  }
  long long v95 = a8;
  double v29 = *a3;
  double v28 = a3[1];
  if (v28 != *a3)
  {
    do
    {
      double v30 = *(int **)(a1 + 1392);
      int v31 = v30[7];
      uint64_t v32 = v30[6];
      if ((int)v32 >= v31)
      {
        if (v31 == v30[8])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v30 + 4), v31 + 1);
          int v31 = v30[7];
        }
        v30[7] = v31 + 1;
        operator new();
      }
      uint64_t v33 = *((void *)v30 + 2);
      v30[6] = v32 + 1;
      uint64_t v34 = *(void *)(v33 + 8 * v32);
      int v35 = *(_DWORD *)(v34 + 28);
      int v36 = *((unsigned __int16 *)v29 + 1);
      *(_DWORD *)(v34 + 8) = *v29;
      *(_DWORD *)(v34 + 12) = v36;
      *(_DWORD *)(v34 + 28) = v35 | 7;
      uint64_t result = *(void *)(v34 + 16);
      if ((_UNKNOWN *)result == &wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      if (*(char *)(result + 23) < 0)
      {
        *(void *)(result + 8) = 16;
        uint64_t result = *(void *)result;
      }
      else
      {
        *(unsigned char *)(result + 23) = 16;
      }
      *(_OWORD *)uint64_t result = *(_OWORD *)(v29 + 4);
      *(unsigned char *)(result + 16) = 0;
      v29 += 20;
    }
    while (v29 != v28);
  }
  uint64_t v39 = a4;
  char v38 = *a4;
  for (CFIndex i = v39[1]; v38 != i; v38 += 5)
  {
    uint64_t v40 = *(int **)(a1 + 1392);
    int v41 = v40[25];
    uint64_t v42 = v40[24];
    if ((int)v42 >= v41)
    {
      if (v41 == v40[26])
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v40 + 22), v41 + 1);
        int v41 = v40[25];
      }
      v40[25] = v41 + 1;
      sub_100BB86F4();
    }
    uint64_t v43 = *((void *)v40 + 11);
    v40[24] = v42 + 1;
    uint64_t result = *(void *)(v43 + 8 * v42);
    int v44 = *(_DWORD *)(result + 32);
    int v45 = v38[1];
    *(_DWORD *)(result + 8) = *v38;
    *(_DWORD *)(result + 12) = v45;
    int v46 = v38[3];
    *(_DWORD *)(result + 16) = *((unsigned __int8 *)v38 + 4);
    *(_DWORD *)(result + 20) = v46;
    int v47 = v38[4];
    *(_DWORD *)(result + 32) = v44 | 0x1F;
    *(_DWORD *)(result + 24) = v47;
  }
  __int16 v50 = a5;
  uint64_t v49 = *a5;
  for (uint64_t j = v50[1]; v49 != j; v49 += 5)
  {
    int v51 = *(int **)(a1 + 1392);
    int v52 = v51[19];
    uint64_t v53 = v51[18];
    if ((int)v53 >= v52)
    {
      if (v52 == v51[20])
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v51 + 16), v52 + 1);
        int v52 = v51[19];
      }
      v51[19] = v52 + 1;
      sub_100BB86F4();
    }
    uint64_t v54 = *((void *)v51 + 8);
    v51[18] = v53 + 1;
    uint64_t result = *(void *)(v54 + 8 * v53);
    int v55 = *(_DWORD *)(result + 32);
    int v56 = v49[1];
    *(_DWORD *)(result + 8) = *v49;
    *(_DWORD *)(result + 12) = v56;
    int v57 = v49[3];
    *(_DWORD *)(result + 16) = *((unsigned __int8 *)v49 + 4);
    *(_DWORD *)(result + 20) = v57;
    int v58 = v49[4];
    *(_DWORD *)(result + 32) = v55 | 0x1F;
    *(_DWORD *)(result + 24) = v58;
  }
  CFBooleanRef v60 = *a6;
  CFTypeID v59 = a6[1];
  if (v59 != *a6)
  {
    do
    {
      char v61 = *(int **)(a1 + 1392);
      int v62 = v61[31];
      uint64_t v63 = v61[30];
      if ((int)v63 >= v62)
      {
        if (v62 == v61[32])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v61 + 28), v62 + 1);
          int v62 = v61[31];
        }
        v61[31] = v62 + 1;
        operator new();
      }
      uint64_t v64 = *((void *)v61 + 14);
      v61[30] = v63 + 1;
      BOOL v65 = *(_DWORD **)(v64 + 8 * v63);
      int v66 = v65[9];
      int v67 = v60[1];
      v65[2] = *v60;
      v65[3] = v67;
      int v68 = *((unsigned __int8 *)v60 + 4);
      v65[9] = v66 | 7;
      int v69 = *((_DWORD *)v60 + 2);
      v65[4] = v68;
      v65[5] = v69;
      int v70 = *((unsigned __int8 *)v60 + 12);
      v65[9] = v66 | 0x1F;
      v65[6] = v70;
      if (*((unsigned char *)v60 + 14)) {
        v65[6] = *((unsigned __int8 *)v60 + 13);
      }
      v60 += 8;
    }
    while (v60 != v59);
  }
  int v72 = *v95;
  uint64_t v71 = v95[1];
  if (v71 != *v95)
  {
    do
    {
      BOOL v73 = *(int **)(a1 + 1392);
      int v74 = v73[43];
      uint64_t v75 = v73[42];
      if ((int)v75 >= v74)
      {
        if (v74 == v73[44])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v73 + 40), v74 + 1);
          int v74 = v73[43];
        }
        v73[43] = v74 + 1;
        operator new();
      }
      uint64_t v76 = *((void *)v73 + 20);
      v73[42] = v75 + 1;
      BOOL v77 = *(_DWORD **)(v76 + 8 * v75);
      int v78 = v77[10];
      int v79 = v72[1];
      v77[2] = *v72;
      v77[3] = v79;
      int v80 = v72[2];
      v77[10] = v78 | 7;
      int v81 = *((_DWORD *)v72 + 2);
      v77[4] = v80;
      v77[5] = v81;
      int v82 = v72[6];
      v77[10] = v78 | 0x3F;
      int v83 = *((unsigned __int8 *)v72 + 14);
      v77[6] = v82;
      v77[7] = v83;
      int v84 = *((_DWORD *)v72 + 4);
      v77[10] = v78 | 0x7F;
      v77[8] = v84;
      v72 += 10;
    }
    while (v72 != v71);
  }
  dispatch_object_t v86 = *a7;
  uint64_t v85 = a7[1];
  if (v85 != *a7)
  {
    do
    {
      dispatch_object_t v87 = *(int **)(a1 + 1392);
      int v88 = v87[37];
      uint64_t v89 = v87[36];
      if ((int)v89 >= v88)
      {
        if (v88 == v87[38])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v87 + 34), v88 + 1);
          int v88 = v87[37];
        }
        v87[37] = v88 + 1;
        sub_100BB86F4();
      }
      uint64_t v90 = *((void *)v87 + 17);
      v87[36] = v89 + 1;
      uint64_t result = *(void *)(v90 + 8 * v89);
      int v91 = *(_DWORD *)(result + 32);
      int v92 = v86[1];
      *(_DWORD *)(result + 8) = *v86;
      *(_DWORD *)(result + 12) = v92;
      int v93 = v86[3];
      *(_DWORD *)(result + 16) = *((unsigned __int8 *)v86 + 4);
      *(_DWORD *)(result + 20) = v93;
      int v94 = v86[4];
      *(_DWORD *)(result + 32) = v91 | 0x1F;
      *(_DWORD *)(result + 24) = v94;
      v86 += 5;
    }
    while (v86 != v85);
  }
  return result;
}

void sub_100BB8678()
{
}

void sub_100BB86F4()
{
}

void sub_100BB8734()
{
}

void sub_100BB8758(wis::MetricFactory *a1)
{
  long long v7 = a1;
  uint64_t v1 = **(void **)a1;
  int v8 = _NSConcreteStackBlock;
  uint64_t v9 = 0x40000000;
  int v10 = sub_100BB7B08;
  double v11 = &unk_101A440F8;
  uint64_t v12 = v1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x80018u);
  int v13 = v3;
  if (v3)
  {
    uint64_t v4 = sub_10001C8F4(8);
    uint64_t v6 = *v4;
    int v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      operator new();
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
    if (v3)
    {
      wis::MetricContainer::~MetricContainer(v3);
      operator delete();
    }
  }
  operator delete();
}

void sub_100BB890C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  operator delete();
}

void sub_100BB89B8(wis::MetricFactory *a1)
{
  long long v7 = a1;
  uint64_t v1 = **(void **)a1;
  int v8 = _NSConcreteStackBlock;
  uint64_t v9 = 0x40000000;
  int v10 = sub_100BB7BCC;
  double v11 = &unk_101A44118;
  uint64_t v12 = v1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x80017u);
  int v13 = v3;
  if (v3)
  {
    uint64_t v4 = sub_10001C8F4(8);
    uint64_t v6 = *v4;
    int v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      operator new();
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
    if (v3)
    {
      wis::MetricContainer::~MetricContainer(v3);
      operator delete();
    }
  }
  operator delete();
}

void sub_100BB8B6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  operator delete();
}

void sub_100BB8C28(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100BB8CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_1000558F4(&a9);
  sub_1000558F4(&a10);
  if (v10) {
    operator delete();
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BB8D14(uint64_t a1, uint64_t a2, const void **a3, const void **a4)
{
  int v8 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, "cb.cache.util");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v19, &v17);
  ctu::OsLogLogger::OsLogLogger(v8, (const ctu::OsLogLogger *)&v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_101A44170;
  *(void *)(a1 + 32) = *(void *)a2;
  uint64_t v9 = *(void *)(a2 + 8);
  *(void *)(a1 + 40) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  Registry::getFileSystemInterface((uint64_t *)(a1 + 48), *(Registry **)a2);
  sub_100083DA4((const void **)(a1 + 64), a3);
  sub_100083DA4((const void **)(a1 + 72), a4);
  *(void *)(a1 + 80) = 0;
  int v10 = (char **)(a1 + 80);
  CFMutableStringRef theString = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, *(CFStringRef *)(a1 + 72));
  CFStringAppend(theString, @":");
  CFStringAppend(theString, *(CFStringRef *)(a1 + 64));
  CFMutableStringRef v14 = theString;
  if (theString)
  {
    CFRetain(theString);
    CFMutableStringRef v19 = theString;
    CFRetain(theString);
  }
  else
  {
    CFMutableStringRef v19 = 0;
  }
  int v18 = 0;
  v17.var0 = 0;
  sub_100056248(&v17, (CFTypeRef *)&v19);
  if (v17.var0) {
    double v11 = sub_1000810B8;
  }
  else {
    double v11 = 0;
  }
  if (v11) {
    sub_100083EB8((const void **)&v18, (const void **)&v17.var0);
  }
  sub_1000558F4((const void **)&v17.var0);
  uint64_t v12 = v18;
  uint64_t v15 = v18;
  int v18 = 0;
  sub_1000558F4((const void **)&v18);
  sub_10028D988((const void **)&v19);
  if (v10 != &v15)
  {
    v17.var0 = *v10;
    *int v10 = v12;
    uint64_t v15 = 0;
    sub_1000558F4((const void **)&v17.var0);
  }
  sub_1000558F4((const void **)&v15);
  sub_10028D988((const void **)&v14);
  sub_10028D988((const void **)&theString);
  return a1;
}

void sub_100BB8F38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  double v11 = va_arg(va1, const void *);
  uint64_t v13 = va_arg(va1, void);
  va_copy(va2, va1);
  CFMutableStringRef v14 = va_arg(va2, const void *);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  va_copy(va3, va2);
  int v18 = va_arg(va3, const void *);
  sub_1000558F4((const void **)va2);
  sub_10028D988((const void **)va3);
  sub_10028D988((const void **)va);
  sub_10028D988((const void **)va1);
  sub_1000558F4(v4);
  sub_1000558F4(v6);
  sub_1000558F4(v5);
  int v8 = (std::__shared_weak_count *)*((void *)v2 + 7);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)v2 + 5);
  if (v9) {
    sub_10004D2C8(v9);
  }
  int v10 = (std::__shared_weak_count *)*((void *)v2 + 3);
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }
  ctu::OsLogLogger::~OsLogLogger(v3);
  CarrierBundleCacheInterface::~CarrierBundleCacheInterface(v2);
  _Unwind_Resume(a1);
}

void sub_100BB8FF0(uint64_t a1)
{
  *(void *)a1 = off_101A44170;
  sub_1000558F4((const void **)(a1 + 80));
  sub_1000558F4((const void **)(a1 + 72));
  sub_1000558F4((const void **)(a1 + 64));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  CarrierBundleCacheInterface::~CarrierBundleCacheInterface((CarrierBundleCacheInterface *)a1);
}

void sub_100BB9084(uint64_t a1)
{
  sub_100BB8FF0(a1);

  operator delete();
}

void sub_100BB90BC(std::string *a1)
{
  uint64_t v2 = (char *)sub_1003F26A8();
  sub_100058DB0(&v11, v2);
  size_t v3 = strlen(kUserCBDir);
  uint64_t v4 = std::string::append(&v11, kUserCBDir, v3);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v12.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v12.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  long long v13 = 0uLL;
  uint64_t v14 = 0;
  ctu::cf::assign();
  unint64_t v10 = v14;
  *(_OWORD *)std::string __p = v13;
  if (v14 >= 0) {
    uint64_t v6 = __p;
  }
  else {
    uint64_t v6 = (void **)__p[0];
  }
  if ((v10 & 0x8000000000000000) == 0) {
    long long v7 = (void *)HIBYTE(v10);
  }
  else {
    long long v7 = __p[1];
  }
  int v8 = std::string::append(&v12, (const std::string::value_type *)v6, (std::string::size_type)v7);
  *a1 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
}

void sub_100BB91C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BB9220(std::string *a1)
{
  sub_100BB90BC(&v10);
  long long v12 = 0uLL;
  uint64_t v13 = 0;
  ctu::cf::assign();
  unint64_t v9 = v13;
  *(_OWORD *)std::string __p = v12;
  if (v13 >= 0) {
    uint64_t v2 = __p;
  }
  else {
    uint64_t v2 = (void **)__p[0];
  }
  if ((v9 & 0x8000000000000000) == 0) {
    size_t v3 = (void *)HIBYTE(v9);
  }
  else {
    size_t v3 = __p[1];
  }
  uint64_t v4 = std::string::append(&v10, (const std::string::value_type *)v2, (std::string::size_type)v3);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v11.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  size_t v6 = strlen(kPlistExtension);
  long long v7 = std::string::append(&v11, kPlistExtension, v6);
  *a1 = *v7;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_100BB9320(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BB937C(std::string *a1)
{
  WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
  sub_100058DB0(&v4, WirelessUserDirectory);
  size_t v3 = std::string::append(&v4, "/Library/", 9uLL);
  *a1 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
}

void sub_100BB93F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BB940C(std::string *a1)
{
  long long v5 = 0uLL;
  uint64_t v6 = 0;
  ctu::cf::assign();
  memset(&__p, 0, sizeof(__p));
  size_t v2 = strlen(kPlistExtension);
  size_t v3 = std::string::append(&__p, kPlistExtension, v2);
  *a1 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100BB94A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BB94D8(uint64_t a1)
{
  sub_100BB9220(&__p);
  uint64_t v2 = (*(uint64_t (**)(uint64_t, std::string *))(*(void *)a1 + 88))(a1, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v2;
}

void sub_100BB954C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BB9568(const void **a1, uint64_t a2)
{
  size_t v3 = (os_log_t *)(a2 + 8);
  std::string v4 = (Registry **)(a2 + 32);
  sub_100BB9220(&__p);
  sub_1007B946C(v3, v4, (const UInt8 *)&__p, a1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100BB95CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100BB95E8(void *a1, CFDictionaryRef theDict)
{
  *a1 = 0;
  uint64_t result = (const void **)CFDictionaryContainsKey(theDict, @"StoredBundleIdAndIccids");
  if (result)
  {
    CFTypeRef Value = CFDictionaryGetValue(theDict, @"StoredBundleIdAndIccids");
    uint64_t v6 = 0;
    sub_100044D6C(&v6, &Value);
    *a1 = v6;
    uint64_t v6 = 0;
    return sub_100044D00(&v6);
  }
  return result;
}

void sub_100BB9660(_Unwind_Exception *a1)
{
  sub_100044D00(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100BB9678(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  sub_100BB937C(&v49);
  sub_100BB940C(&v48);
  if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v5 = &v48;
  }
  else {
    long long v5 = (std::string *)v48.__r_.__value_.__r.__words[0];
  }
  if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v48.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v48.__r_.__value_.__l.__size_;
  }
  long long v7 = std::string::append(&v49, (const std::string::value_type *)v5, size);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  char v9 = (*(uint64_t (**)(uint64_t, std::string *, uint64_t))(*(void *)v4 + 184))(v4, &__p, a2);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v49.__r_.__value_.__l.__data_);
    if (v9)
    {
LABEL_13:
      memset(&v49, 0, sizeof(v49));
      memset(&__p, 0, sizeof(__p));
      ctu::cf::assign();
      std::string v48 = __p;
      size_t v10 = strlen(kPlistExtension);
      std::string v11 = std::string::append(&v48, kPlistExtension, v10);
      long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      v49.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v48.__r_.__value_.__l.__data_);
      }
      uint64_t v46 = 0;
      int v47 = 0;
      Registry::getMobileHelper(&v46, *(Registry **)(a1 + 32));
      uint64_t v13 = v46;
      if (v46)
      {
        sub_100BB937C(&__p);
        int v14 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        std::string::size_type v15 = __p.__r_.__value_.__r.__words[0];
        sub_100BB90BC(&v48);
        if (v14 >= 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)v15;
        }
        if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v17 = &v48;
        }
        else {
          uint64_t v17 = (std::string *)v48.__r_.__value_.__r.__words[0];
        }
        if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int v18 = &v49;
        }
        else {
          int v18 = (std::string *)v49.__r_.__value_.__r.__words[0];
        }
        int v19 = (*(uint64_t (**)(uint64_t, std::string *, std::string *, std::string *))(*(void *)v13 + 48))(v13, p_p, v17, v18);
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v48.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        int v20 = *(NSObject **)(a1 + 8);
        if (v19)
        {
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            sub_100BB937C(&v48);
            if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v21 = &v49;
            }
            else {
              uint64_t v21 = (std::string *)v49.__r_.__value_.__r.__words[0];
            }
            if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v22 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v22 = v49.__r_.__value_.__l.__size_;
            }
            unsigned int v23 = std::string::append(&v48, (const std::string::value_type *)v21, v22);
            long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v24;
            v23->__r_.__value_.__l.__size_ = 0;
            v23->__r_.__value_.__r.__words[2] = 0;
            v23->__r_.__value_.__r.__words[0] = 0;
            int v25 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
            std::string::size_type v26 = __p.__r_.__value_.__r.__words[0];
            sub_100BB90BC(&v45);
            int v27 = &__p;
            if (v25 < 0) {
              int v27 = (std::string *)v26;
            }
            if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              double v28 = &v45;
            }
            else {
              double v28 = (std::string *)v45.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)std::string buf = 136315394;
            int v52 = v27;
            __int16 v53 = 2082;
            uint64_t v54 = v28;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Moving %s to %{public}s Succeeded", buf, 0x16u);
            if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v45.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v48.__r_.__value_.__l.__data_);
            }
          }
          uint64_t v13 = 1;
          goto LABEL_56;
        }
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          sub_100BB937C(&v48);
          if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            CFTypeID v37 = &v49;
          }
          else {
            CFTypeID v37 = (std::string *)v49.__r_.__value_.__r.__words[0];
          }
          if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v38 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v38 = v49.__r_.__value_.__l.__size_;
          }
          uint64_t v39 = std::string::append(&v48, (const std::string::value_type *)v37, v38);
          long long v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v39->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v40;
          v39->__r_.__value_.__l.__size_ = 0;
          v39->__r_.__value_.__r.__words[2] = 0;
          v39->__r_.__value_.__r.__words[0] = 0;
          int v41 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
          std::string::size_type v42 = __p.__r_.__value_.__r.__words[0];
          sub_100BB90BC(&v45);
          uint64_t v43 = &__p;
          if (v41 < 0) {
            uint64_t v43 = (std::string *)v42;
          }
          if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            int v44 = &v45;
          }
          else {
            int v44 = (std::string *)v45.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315394;
          int v52 = v43;
          __int16 v53 = 2082;
          uint64_t v54 = v44;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Mobile helper failed to move %s to %{public}s", buf, 0x16u);
          if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v45.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v48.__r_.__value_.__l.__data_);
          }
        }
      }
      else
      {
        double v30 = *(NSObject **)(a1 + 8);
        if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
LABEL_56:
          if (v47) {
            sub_10004D2C8(v47);
          }
          uint64_t v31 = *(void *)(a1 + 48);
          sub_100BB937C(&v48);
          sub_100BB940C(&v45);
          if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v32 = &v45;
          }
          else {
            uint64_t v32 = (std::string *)v45.__r_.__value_.__r.__words[0];
          }
          if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v33 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v33 = v45.__r_.__value_.__l.__size_;
          }
          uint64_t v34 = std::string::append(&v48, (const std::string::value_type *)v32, v33);
          long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v35;
          v34->__r_.__value_.__l.__size_ = 0;
          v34->__r_.__value_.__r.__words[2] = 0;
          v34->__r_.__value_.__r.__words[0] = 0;
          (*(void (**)(uint64_t, std::string *))(*(void *)v31 + 112))(v31, &__p);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v45.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v48.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v49.__r_.__value_.__l.__data_);
          }
          return v13;
        }
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#N Could not get MobileHelper", (uint8_t *)&__p, 2u);
      }
      uint64_t v13 = 0;
      goto LABEL_56;
    }
  }
  else if (v9)
  {
    goto LABEL_13;
  }
  double v29 = *(NSObject **)(a1 + 8);
  uint64_t v13 = 0;
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#N Failed to write to plist", (uint8_t *)&__p, 2u);
    return 0;
  }
  return v13;
}

void sub_100BB9C1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BB9D48()
{
}

uint64_t sub_100BB9D50(uint64_t a1, int a2)
{
  uint64_t result = sub_100BB94D8(*(void *)(a1 + 48));
  if (result)
  {
    CFDictionaryRef theDict = 0;
    sub_100BB9568((const void **)&theDict, a1);
    if (theDict) {
      long long v5 = sub_100080778;
    }
    else {
      long long v5 = 0;
    }
    if (v5 && CFDictionaryContainsKey(theDict, @"StoredBundleIdAndIccids"))
    {
      CFArrayRef theArray = 0;
      sub_100BB95E8(&theArray, theDict);
      CFArrayRef v6 = theArray;
      if (theArray) {
        long long v7 = sub_100083F10;
      }
      else {
        long long v7 = 0;
      }
      if (v7)
      {
        if (a2 == 1)
        {
          CFIndex Count = CFArrayGetCount(theArray);
          sub_100083DA4((const void **)&value, (const void **)(a1 + 80));
          v18.location = 0;
          v18.length = Count;
          BOOL v9 = CFArrayContainsValue(v6, v18, value) != 0;
        }
        else
        {
          xpc_object_t value = 0;
          sub_100083DA4((const void **)&value, (const void **)(a1 + 72));
          CFIndex v10 = 0;
          while (v10 < CFArrayGetCount(theArray))
          {
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v10);
            CFStringRef v12 = ValueAtIndex;
            if (ValueAtIndex)
            {
              CFTypeID v13 = CFGetTypeID(ValueAtIndex);
              if (v13 == CFStringGetTypeID()) {
                CFStringRef v14 = v12;
              }
              else {
                CFStringRef v14 = 0;
              }
            }
            else
            {
              CFStringRef v14 = 0;
            }
            ++v10;
            if (CFStringHasPrefix(v14, (CFStringRef)value))
            {
              BOOL v9 = 1;
              goto LABEL_25;
            }
          }
          BOOL v9 = 0;
        }
LABEL_25:
        sub_1000558F4((const void **)&value);
      }
      else
      {
        BOOL v9 = 0;
      }
      sub_100044D00((const void **)&theArray);
    }
    else
    {
      BOOL v9 = 0;
    }
    sub_100057D78((const void **)&theDict);
    return v9;
  }
  return result;
}

void sub_100BB9EE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  size_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  long long v5 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_100044D00((const void **)va1);
  sub_100057D78((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_100BB9F24(uint64_t a1)
{
  return sub_100BB9D50(a1, 1);
}

const void **sub_100BB9F2C(uint64_t a1)
{
  uint64_t result = (const void **)sub_100BB9D50(a1, 0);
  if (result)
  {
    CFDictionaryRef theDict = 0;
    sub_100BB9568((const void **)&theDict, a1);
    CFArrayRef theArray = 0;
    sub_100BB95E8(&theArray, theDict);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFIndex Count = CFArrayGetCount(theArray);
    CFStringRef prefix = 0;
    sub_100083DA4((const void **)&prefix, (const void **)(a1 + 72));
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, i);
        CFStringRef v6 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v7 = CFGetTypeID(ValueAtIndex);
          if (v7 != CFStringGetTypeID()) {
            CFStringRef v6 = 0;
          }
        }
        if (!CFStringHasPrefix(v6, prefix)) {
          CFArrayAppendValue(Mutable, v6);
        }
      }
    }
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
    if (CFArrayGetCount(Mutable)) {
      CFDictionarySetValue(MutableCopy, @"StoredBundleIdAndIccids", Mutable);
    }
    else {
      CFDictionaryRemoveValue(MutableCopy, @"StoredBundleIdAndIccids");
    }
    if ((sub_100BB9678(a1, (uint64_t)MutableCopy) & 1) == 0)
    {
      long long v8 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Failed to write the dictionary to cache plist ", v9, 2u);
      }
    }
    sub_10005717C((const void **)&MutableCopy);
    sub_1000558F4((const void **)&prefix);
    sub_1000440D4((const void **)&Mutable);
    sub_100044D00((const void **)&theArray);
    return sub_100057D78((const void **)&theDict);
  }
  return result;
}

void sub_100BBA0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFStringRef v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  long long v8 = va_arg(va3, const void *);
  sub_1000558F4((const void **)va);
  sub_1000440D4((const void **)va1);
  sub_100044D00((const void **)va2);
  sub_100057D78((const void **)va3);
  _Unwind_Resume(a1);
}

const void **sub_100BBA144(uint64_t a1)
{
  std::string::size_type v15 = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (sub_100BB94D8(*(void *)(a1 + 48)))
  {
    CFDictionaryRef theDict = 0;
    sub_100BB9568((const void **)&theDict, a1);
    if (theDict) {
      uint64_t v2 = sub_100080778;
    }
    else {
      uint64_t v2 = 0;
    }
    if (!v2)
    {
      sub_100057D78((const void **)&theDict);
      goto LABEL_19;
    }
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
    CFArrayRef v4 = v15;
    std::string::size_type v15 = MutableCopy;
    theArray[0] = v4;
    sub_10005717C((const void **)theArray);
    theArray[0] = 0;
    sub_100BB95E8(theArray, theDict);
    if (theArray[0]) {
      long long v5 = sub_100083F10;
    }
    else {
      long long v5 = 0;
    }
    if (v5)
    {
      uint64_t Count = CFArrayGetCount(theArray[0]);
      v17.location = 0;
      v17.length = Count;
      CFArrayAppendArray(Mutable, theArray[0], v17);
      if (Count >= 5)
      {
        uint64_t v7 = Count + 1;
        do
        {
          CFArrayRemoveValueAtIndex(Mutable, 0);
          --v7;
        }
        while (v7 > 5);
      }
    }
    sub_100044D00((const void **)theArray);
    sub_100057D78((const void **)&theDict);
  }
  else
  {
    CFMutableDictionaryRef v8 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFArrayRef v9 = v15;
    std::string::size_type v15 = v8;
    theArray[0] = v9;
    sub_10005717C((const void **)theArray);
  }
  CFIndex v10 = Mutable;
  sub_100083DA4((const void **)theArray, (const void **)(a1 + 80));
  CFArrayAppendValue(v10, theArray[0]);
  sub_1000558F4((const void **)theArray);
  CFDictionarySetValue(v15, @"StoredBundleIdAndIccids", Mutable);
  if ((sub_100BB9678(a1, (uint64_t)v15) & 1) == 0)
  {
    std::string v11 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(theArray[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Failed to write the dictionary to cache plist ", (uint8_t *)theArray, 2u);
    }
  }
LABEL_19:
  sub_1000440D4((const void **)&Mutable);
  return sub_10005717C((const void **)&v15);
}

void sub_100BBA338(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  size_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  long long v5 = va_arg(va2, const void *);
  sub_100057D78((const void **)va);
  sub_1000440D4((const void **)va1);
  sub_10005717C((const void **)va2);
  _Unwind_Resume(a1);
}

BOOL sub_100BBA39C(uint64_t a1, const UInt8 *a2)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 48) + 88))(*(void *)(a1 + 48)))
  {
    CFDictionaryRef theDict = 0;
    sub_1007B946C((os_log_t *)(a1 + 8), (Registry **)(a1 + 32), a2, (const void **)&theDict);
    if (theDict) {
      CFArrayRef v4 = sub_100080778;
    }
    else {
      CFArrayRef v4 = 0;
    }
    if (v4 && CFDictionaryContainsKey(theDict, @"SaveICCIDToCache"))
    {
      CFTypeRef Value = CFDictionaryGetValue(theDict, @"SaveICCIDToCache");
      BOOL v6 = (BOOL)Value;
      char v11 = 0;
      if (!Value)
      {
LABEL_12:
        sub_100057D78((const void **)&theDict);
        return v6;
      }
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)&v11, (BOOL *)v6, v8);
        BOOL v6 = v11 != 0;
        goto LABEL_12;
      }
    }
    BOOL v6 = 0;
    goto LABEL_12;
  }
  return 0;
}

void sub_100BBA4A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_100BBA4B8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100BBA538(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BBA574(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BBA5AC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100BBA5DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100BBA620(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100BBACF8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, ctu::OsLogLogger *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
}

void sub_100BBAD24()
{
  __cxa_free_exception(v0);
  sub_10004D2C8(v1);
  sub_10004D2C8(v1);
  JUMPOUT(0x100BBB010);
}

void sub_100BBAD38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (a21) {
    (*(void (**)(uint64_t))(*(void *)a21 + 8))(a21);
  }
  if (!a26) {
    JUMPOUT(0x100BBAF1CLL);
  }
  JUMPOUT(0x100BBAF18);
}

void sub_100BBAD90()
{
}

void sub_100BBAD98(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,dispatch_object_t object)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 8))(a14);
  }
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x100BBAF1CLL);
}

void sub_100BBADDC(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    dispatch_barrier_async_f(v2[3], v2, (dispatch_function_t)sub_100BC5CE4);
    __cxa_rethrow();
  }
  JUMPOUT(0x100BBB010);
}

void sub_100BBAE10()
{
}

void sub_100BBAE20(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x100BBB010);
}

void sub_100BBAE30(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, ctu::OsLogLogger *a11, void *a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a21) {
    sub_10004D2C8(a21);
  }
  long long v24 = (std::__shared_weak_count *)*((void *)v21 + 10);
  if (v24) {
    sub_10004D2C8(v24);
  }
  int v25 = (std::__shared_weak_count *)*((void *)v21 + 8);
  if (v25) {
    sub_10004D2C8(v25);
  }
  uint64_t v26 = *((void *)v21 + 6);
  *((void *)v21 + 6) = 0;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  }
  ctu::OsLogLogger::~OsLogLogger(a11);
  sub_100087E88(a12);
  PDPConfigInterface::~PDPConfigInterface(v21);
  if (v23)
  {
    dispatch_release(v23);
    if (!v22) {
      goto LABEL_13;
    }
  }
  else if (!v22)
  {
    goto LABEL_13;
  }
  sub_10004D2C8(v22);
LABEL_13:
  operator delete();
}

void sub_100BBAE5C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_object_t object, dispatch_object_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (object) {
    dispatch_release(object);
  }
  if (a20) {
    dispatch_release(a20);
  }
  if (a30 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100BBAF94);
}

void sub_100BBAE8C()
{
}

void sub_100BBAEE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  JUMPOUT(0x100BBAFE0);
}

void sub_100BBAF08()
{
}

void sub_100BBAF28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14)
{
  sub_100BC61EC(*(char **)(v14 + 424));
  sub_10005D144(*(void **)(v14 + 400));
  if (*(char *)(v14 + 383) < 0) {
    operator delete(*(void **)(v14 + 360));
  }
  if (*(char *)(v14 + 359) < 0) {
    operator delete(*a9);
  }
  sub_10005D144(*v16);
  a14 = a10;
  sub_10005CBF0(&a14);
  sub_100BC6188(*v15);
  PersonalitiesTracker::~PersonalitiesTracker(v17);
  JUMPOUT(0x100BBAF88);
}

const char *sub_100BBB034(int a1)
{
  uint64_t v1 = "DATA.dw-apn.?";
  if (a1 == 2) {
    uint64_t v1 = "DATA.dw-apn.2";
  }
  if (a1 == 1) {
    return "DATA.dw-apn.1";
  }
  else {
    return v1;
  }
}

void sub_100BBB060(uint64_t a1, int val)
{
  uint64_t v3 = *(void *)(a1 + 32);
  BOOL is_valid_token = notify_is_valid_token(val);
  long long v5 = *(NSObject **)(v3 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (is_valid_token)
  {
    if (v6)
    {
      LODWORD(v22) = 67109120;
      HIDWORD(v22) = val;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I dnsNotificationHandler: token=%d", (uint8_t *)&v22, 8u);
    }
    CFBooleanRef v8 = *(uint64_t **)(v3 + 288);
    for (CFIndex i = *(uint64_t **)(v3 + 296); v8 != i; v8 += 2)
    {
      uint64_t v10 = *v8;
      char v11 = (std::__shared_weak_count *)v8[1];
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t))(*(void *)v10 + 208))(v10);
      if (v11) {
        sub_10004D2C8(v11);
      }
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(v3 + 56));
    uint64_t v13 = ServiceMap;
    if ((v14 & 0x8000000000000000) != 0)
    {
      uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        unint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v22 = v14;
    CFRange v18 = sub_10004D37C(&v13[1].__m_.__sig, &v22);
    if (v18)
    {
      uint64_t v20 = v18[3];
      int v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
        if (!v20)
        {
LABEL_22:
          if ((v21 & 1) == 0) {
            sub_10004D2C8(v19);
          }
          return;
        }
LABEL_21:
        (*(void (**)(uint64_t))(*(void *)v20 + 1136))(v20);
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    int v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  if (v6)
  {
    LODWORD(v22) = 67109120;
    HIDWORD(v22) = val;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I dnsNotificationHandler: token=%d is not valid", (uint8_t *)&v22, 8u);
  }
}

void sub_100BBB294(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BBB2D0(uint64_t a1, NSObject **a2)
{
  CFArrayRef v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPConfig: bootstrap 1...", buf, 2u);
  }
  long long v5 = *a2;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  BOOL v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BBB438(capabilities::ct *a1, uint64_t a2)
{
  if (capabilities::ct::supportsIPCInterfaceConfig(a1))
  {
    CFArrayRef v4 = (uint64_t *)*((void *)a1 + 36);
    for (CFIndex i = (uint64_t *)*((void *)a1 + 37); v4 != i; v4 += 2)
    {
      uint64_t v6 = *v4;
      CFTypeID v7 = (std::__shared_weak_count *)v4[1];
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 256))(v6, a2);
      if (v7) {
        sub_10004D2C8(v7);
      }
    }
  }
}

void sub_100BBB4DC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BBB4F4(capabilities::ct *a1, uint64_t a2)
{
  if (capabilities::ct::supportsIPCInterfaceConfig(a1))
  {
    CFArrayRef v4 = (uint64_t *)*((void *)a1 + 36);
    for (CFIndex i = (uint64_t *)*((void *)a1 + 37); v4 != i; v4 += 2)
    {
      uint64_t v6 = *v4;
      CFTypeID v7 = (std::__shared_weak_count *)v4[1];
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 264))(v6, a2);
      if (v7) {
        sub_10004D2C8(v7);
      }
    }
  }
}

void sub_100BBB598(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BBB5B0(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v3 = *(void *)(a1 + 272);
  if (v3)
  {
    uint64_t v6 = a1 + 272;
    do
    {
      int v7 = *(_DWORD *)(v3 + 32);
      BOOL v8 = v7 < (int)a2;
      if (v7 >= (int)a2) {
        CFArrayRef v9 = (uint64_t *)v3;
      }
      else {
        CFArrayRef v9 = (uint64_t *)(v3 + 8);
      }
      if (!v8) {
        uint64_t v6 = v3;
      }
      uint64_t v3 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 272 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v12 = "not-given";
        if (a3) {
          CFStringRef v12 = a3;
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I refresh with ID: %s", (uint8_t *)&buf, 0xCu);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)(a1 + 56));
      unint64_t v14 = ServiceMap;
      if (v15 < 0)
      {
        uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v17 = 5381;
        do
        {
          uint64_t v15 = v17;
          unsigned int v18 = *v16++;
          uint64_t v17 = (33 * v17) ^ v18;
        }
        while (v18);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&long long buf = v15;
      int v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)&buf);
      if (v19)
      {
        uint64_t v21 = v19[3];
        uint64_t v20 = (std::__shared_weak_count *)v19[4];
        if (v20)
        {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v14);
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v20);
          char v22 = 0;
          if (!v21)
          {
LABEL_37:
            if ((v22 & 1) == 0) {
              sub_10004D2C8(v20);
            }
            return;
          }
LABEL_24:
          long long buf = 0uLL;
          uint64_t v27 = 0;
          if (a3) {
            unsigned int v23 = a3;
          }
          else {
            unsigned int v23 = "";
          }
          sub_100058DB0(&buf, v23);
          sub_100BBB920(v21, &v24);
          (*(void (**)(uint64_t))(*(void *)v24 + 64))(v24);
          if (v25) {
            sub_10004D2C8(v25);
          }
          sub_1006E3F34(v21, &v24);
          (*(void (**)(uint64_t))(*(void *)v24 + 64))(v24);
          if (v25) {
            sub_10004D2C8(v25);
          }
          sub_1006E4004(v21, &v24);
          if (v25) {
            sub_10004D2C8(v25);
          }
          sub_10022EDC4(v21, &v24);
          (*(void (**)(uint64_t, long long *))(*(void *)v24 + 64))(v24, &buf);
          if (v25) {
            sub_10004D2C8(v25);
          }
          if (SHIBYTE(v27) < 0) {
            operator delete((void *)buf);
          }
          goto LABEL_37;
        }
      }
      else
      {
        uint64_t v21 = 0;
      }
      std::mutex::unlock(v14);
      uint64_t v20 = 0;
      char v22 = 1;
      if (!v21) {
        goto LABEL_37;
      }
      goto LABEL_24;
    }
  }
}

void sub_100BBB8B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BBB920(uint64_t a1@<X0>, void *a2@<X8>)
{
  lpsrc = 0;
  uint64_t v6 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&lpsrc);
  if (lpsrc
  {
    CFArrayRef v4 = v6;
    *a2 = v3;
    a2[1] = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_100BBB9F0(void *a1, CFStringRef key)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  CFStringRef v3 = (const __CFString *)CFPreferencesCopyValue(key, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  if (v3)
  {
    CFStringRef v4 = v3;
    CFIndex Length = CFStringGetLength(v3);
    if (Length)
    {
      CFIndex usedBufLen = 0;
      v14.location = 0;
      v14.length = Length;
      CFStringGetBytes(v4, v14, 0x8000100u, 0, 0, 0, 0, &usedBufLen);
      buffer = 0;
      char v11 = 0;
      uint64_t v12 = 0;
      sub_10008E4E8(&buffer, usedBufLen + 1);
      v15.location = 0;
      v15.length = Length;
      CFStringGetBytes(v4, v15, 0x8000100u, 0, 0, buffer, Length, 0);
      sub_1000D95C8(&__dst, buffer, Length);
      uint64_t v7 = v9;
      uint64_t v6 = buffer;
      *(_OWORD *)a1 = __dst;
      a1[2] = v7;
      if (v6)
      {
        char v11 = v6;
        operator delete(v6);
      }
    }
    CFRelease(v4);
  }
}

void sub_100BBBB14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BBBB54(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 272);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = a1 + 272;
  do
  {
    int v6 = *(_DWORD *)(v3 + 32);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      BOOL v8 = (uint64_t *)v3;
    }
    else {
      BOOL v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == a1 + 272) {
    return 0;
  }
  uint64_t v9 = (uint64_t *)*(unsigned int *)(v5 + 32);
  if ((int)v9 > a2) {
    return 0;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 56));
  uint64_t v13 = ServiceMap;
  if ((v14 & 0x8000000000000000) != 0)
  {
    CFRange v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      unint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v14;
  unsigned int v18 = sub_10004D37C(&v13[1].__m_.__sig, &v22);
  if (!v18)
  {
    uint64_t v20 = 0;
LABEL_21:
    std::mutex::unlock(v13);
    int v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_19;
    }
LABEL_22:
    sub_10022EDC4(v20, &v22);
    uint64_t v10 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v22 + 64))(v22, a3);
    if (v23) {
      sub_10004D2C8(v23);
    }
    goto LABEL_24;
  }
  uint64_t v20 = v18[3];
  int v19 = (std::__shared_weak_count *)v18[4];
  if (!v19) {
    goto LABEL_21;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  char v21 = 0;
  if (v20) {
    goto LABEL_22;
  }
LABEL_19:
  uint64_t v10 = 0;
LABEL_24:
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  return v10;
}

void sub_100BBBCE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BBBD10(uint64_t a1, uint64_t a2, int a3, int a4)
{
  void (***v191)(uint8_t *__return_ptr, void, uint64_t);
  std::__shared_weak_count *v192;
  std::mutex *v193;
  uint64_t v194;
  uint64_t v195;
  unint64_t v196;
  NSObject *v197;
  CFTypeRef *v198;
  unint64_t v199;
  int v200;
  int v201;
  unint64_t v202;
  int v203;
  int v204;
  uint64_t **v205;
  long long v206;
  uint64_t *v207;
  NSObject *v208;
  uint64_t *v209;
  uint64_t **v210;
  std::mutex *v211;
  uint64_t *v212;
  uint64_t *v213;
  uint64_t **v214;
  CFTypeRef *v215;
  std::mutex *v216;
  std::mutex *v217;
  unsigned __int8 *v218;
  uint64_t v219;
  unsigned int v220;
  void *v221;
  uint64_t v222;
  std::__shared_weak_count *v223;
  char v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  NSObject *v228;
  NSObject *v229;
  std::mutex *v230;
  std::mutex *v231;
  uint64_t v232;
  unsigned __int8 *v233;
  uint64_t v234;
  unsigned int v235;
  void *v236;
  uint64_t v237;
  std::__shared_weak_count *v238;
  char v239;
  uint64_t *v240;
  uint64_t v241;
  uint64_t v242;
  unint64_t v243;
  uint64_t v244;
  unint64_t v245;
  uint64_t v246;
  std::mutex *v247;
  std::mutex *v248;
  uint64_t v249;
  unsigned __int8 *v250;
  uint64_t v251;
  unsigned int v252;
  void *v253;
  uint64_t v254;
  std::__shared_weak_count *v255;
  std::__shared_weak_count *v256;
  std::__shared_weak_count *v257;
  std::__shared_weak_count *v258;
  _DWORD *v259;
  WirelessTechnologyList *v260;
  char v261;
  char v262;
  uint64_t v263;
  os_log_t *v264;
  int v265;
  unsigned int v266;
  int v267;
  uint64_t **v268;
  uint64_t v269;
  uint64_t v270;
  std::__shared_weak_count *v271;
  unsigned int v272;
  uint64_t v273;
  std::__shared_weak_count *v274;
  CFTypeRef cf[2];
  char v276;
  unsigned char v277[22];
  uint8_t buf[32];
  uint8_t v279[32];

  v272 = a2;
  uint64_t v4 = *(void *)(a1 + 272);
  if (!v4) {
    return 0;
  }
  uint64_t v7 = a2;
  uint64_t v9 = a1 + 272;
  do
  {
    int v10 = *(_DWORD *)(v4 + 32);
    BOOL v11 = v10 < (int)a2;
    if (v10 >= (int)a2) {
      uint64_t v12 = (uint64_t *)v4;
    }
    else {
      uint64_t v12 = (uint64_t *)(v4 + 8);
    }
    if (!v11) {
      uint64_t v9 = v4;
    }
    uint64_t v4 = *v12;
  }
  while (*v12);
  if (v9 == a1 + 272 || *(_DWORD *)(v9 + 32) > (int)a2) {
    return 0;
  }
  v268 = (uint64_t **)(a1 + 272);
  unint64_t v14 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  CFRange v15 = *v14;
  v269 = a1;
  if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
  {
    WirelessTechnologyAsString();
    uint64_t v16 = *(uint8_t **)v279;
    unsigned int v17 = "false";
    if ((v279[23] & 0x80u) == 0) {
      uint64_t v16 = v279;
    }
    if (a4) {
      unsigned int v17 = "true";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v16;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I reconfigure_sync: tech: %s, forced: %s", buf, 0x16u);
    if ((char)v279[23] < 0) {
      operator delete(*(void **)v279);
    }
  }
  unsigned int v18 = sub_100BC6338((uint64_t **)(a1 + 312), v7, &v272);
  int v19 = v18 + 4;
  v264 = v14;
  if (!a4)
  {
    uint64_t v21 = v269;
    if (!a3 || (*v19 & a3) != 0)
    {
      int v25 = *v14;
      v266 = 0;
      if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
      {
        WirelessTechnologyAsString();
        if ((v279[23] & 0x80u) == 0) {
          uint64_t v26 = v279;
        }
        else {
          uint64_t v26 = *(uint8_t **)v279;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v26;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I reconfigure_sync: skipped - compatible technology (%s), no forced", buf, 0xCu);
        if ((char)v279[23] < 0) {
          operator delete(*(void **)v279);
        }
        goto LABEL_35;
      }
LABEL_36:
      uint64_t v27 = v268;
      goto LABEL_370;
    }
    goto LABEL_37;
  }
  _DWORD *v19 = 0;
  uint64_t v20 = *v14;
  uint64_t v21 = v269;
  if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v279 = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I reconfigure_sync: dropped compatible technologies", v279, 2u);
  }
  if (a3)
  {
LABEL_37:
    unint64_t v22 = (uint64_t *)((char *)v18 + 36);
    v259 = (_DWORD *)v18 + 9;
    int v23 = a3;
    goto LABEL_38;
  }
  unint64_t v22 = (uint64_t *)((char *)v18 + 36);
  int v23 = *((_DWORD *)v18 + 9);
  v259 = (_DWORD *)v18 + 9;
  if (!v23)
  {
    uint64_t v24 = *v14;
    v266 = 0;
    if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v279 = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I reconfigure_sync: skipped - forced but wireless technology is not detected", v279, 2u);
LABEL_35:
      v266 = 0;
      goto LABEL_36;
    }
    goto LABEL_36;
  }
LABEL_38:
  memset(buf, 0, 24);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v22, *(Registry **)(v21 + 56));
  double v29 = ServiceMap;
  if (v30 < 0)
  {
    uint64_t v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v32 = 5381;
    do
    {
      uint64_t v30 = v32;
      unsigned int v33 = *v31++;
      uint64_t v32 = (33 * v32) ^ v33;
    }
    while (v33);
  }
  std::mutex::lock(ServiceMap);
  *(void *)v279 = v30;
  uint64_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)v279);
  v260 = (WirelessTechnologyList *)(v18 + 4);
  if (v34)
  {
    uint64_t v35 = v34[3];
    int v36 = (std::__shared_weak_count *)v34[4];
    if (v36)
    {
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v29);
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v36);
      char v37 = 0;
      goto LABEL_46;
    }
  }
  else
  {
    uint64_t v35 = 0;
  }
  std::mutex::unlock(v29);
  int v36 = 0;
  char v37 = 1;
LABEL_46:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const CFBooleanRef))(*(void *)v35 + 120))(cf, v35, v7, @"AllowsMultiplePDNConnectionsToSameAPN", kCFBooleanFalse);
  std::string::size_type v38 = (BOOL *)cf[0];
  v279[0] = 0;
  if (cf[0])
  {
    CFTypeID v39 = CFGetTypeID(cf[0]);
    if (v39 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)v279, v38, v40);
    }
  }
  *((unsigned char *)v18 + 41) = v279[0];
  sub_1000577C4(cf);
  if ((v37 & 1) == 0) {
    sub_10004D2C8(v36);
  }
  v267 = *((unsigned __int8 *)v18 + 41);
  v270 = 0;
  v271 = 0;
  uint64_t v41 = v272;
  sub_100BBE1DC(&v270, v21, v272);
  uint64_t v42 = v270;
  if (v270) {
    sub_100BBE624(v41, v267 != 0, (uint64_t)buf, 1, v270);
  }
  uint64_t v43 = (uint64_t *)v268;
  int v44 = *v268;
  v265 = v23;
  if (!*v268) {
    goto LABEL_70;
  }
  do
  {
    int v45 = *((_DWORD *)v44 + 8);
    BOOL v46 = v45 < (int)v41;
    if (v45 >= (int)v41) {
      int v47 = (uint64_t **)v44;
    }
    else {
      int v47 = (uint64_t **)(v44 + 1);
    }
    if (!v46) {
      uint64_t v43 = v44;
    }
    int v44 = *v47;
  }
  while (*v47);
  if (v43 == (uint64_t *)v268) {
    goto LABEL_70;
  }
  char v48 = 0;
  if (!v42) {
    goto LABEL_71;
  }
  uint64_t v43 = (uint64_t *)*((unsigned int *)v43 + 8);
  if ((int)v43 > (int)v41) {
    goto LABEL_71;
  }
  uint64_t v43 = (uint64_t *)*(unsigned int *)(v42 + 144);
  if (v43 > 1)
  {
LABEL_70:
    char v48 = 0;
    goto LABEL_71;
  }
  std::string v49 = (std::mutex *)Registry::getServiceMap(v43, *(Registry **)(v21 + 56));
  __int16 v50 = v49;
  if (v51 < 0)
  {
    int v52 = (unsigned __int8 *)(v51 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v53 = 5381;
    do
    {
      uint64_t v51 = v53;
      unsigned int v54 = *v52++;
      uint64_t v53 = (33 * v53) ^ v54;
    }
    while (v54);
  }
  std::mutex::lock(v49);
  *(void *)v279 = v51;
  int v55 = sub_10004D37C(&v50[1].__m_.__sig, (unint64_t *)v279);
  if (v55)
  {
    uint64_t v56 = v55[3];
    int v57 = (std::__shared_weak_count *)v55[4];
    if (v57)
    {
      atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v50);
      atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v57);
      char v58 = 0;
      goto LABEL_202;
    }
  }
  else
  {
    uint64_t v56 = 0;
  }
  std::mutex::unlock(v50);
  int v57 = 0;
  char v58 = 1;
LABEL_202:
  *(void *)v279 = 0;
  *(void *)&v279[8] = 0;
  sub_100BBB920(v56, v279);
  if (*(void *)v279)
  {
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)v279 + 72))(cf);
    char v129 = (unsigned __int8 *)cf[0];
    std::string::size_type v130 = (std::__shared_weak_count *)cf[1];
  }
  else
  {
    char v129 = 0;
    std::string::size_type v130 = 0;
  }
  if (*(void *)&v279[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v279[8]);
  }
  if (!v129) {
    goto LABEL_395;
  }
  uint64_t v43 = (uint64_t *)v129[71];
  if ((char)v43 >= 0) {
    uint64_t v131 = v129[71];
  }
  else {
    uint64_t v131 = *((void *)v129 + 7);
  }
  uint64_t v132 = *(unsigned __int8 *)(v270 + 71);
  int v133 = (char)v132;
  if ((v132 & 0x80u) != 0) {
    uint64_t v132 = *(void *)(v270 + 56);
  }
  if (v131 != v132) {
    goto LABEL_395;
  }
  uint64_t v134 = (const void **)(v129 + 48);
  if (v133 >= 0) {
    char v135 = (unsigned __int8 *)(v270 + 48);
  }
  else {
    char v135 = *(unsigned __int8 **)(v270 + 48);
  }
  if ((v43 & 0x80) != 0)
  {
    if (memcmp(*v134, v135, *((void *)v129 + 7))) {
      goto LABEL_395;
    }
  }
  else if (v129[71])
  {
    while (*(unsigned __int8 *)v134 == *v135)
    {
      uint64_t v134 = (const void **)((char *)v134 + 1);
      ++v135;
      uint64_t v43 = (uint64_t *)((char *)v43 - 1);
      if (!v43) {
        goto LABEL_399;
      }
    }
LABEL_395:
    char v48 = 1;
    if (!v130) {
      goto LABEL_397;
    }
    goto LABEL_396;
  }
LABEL_399:
  char v48 = 0;
  if (v130) {
LABEL_396:
  }
    sub_10004D2C8(v130);
LABEL_397:
  if ((v58 & 1) == 0) {
    sub_10004D2C8(v57);
  }
LABEL_71:
  *((unsigned char *)v18 + 40) = v48;
  CFTypeID v59 = (std::mutex *)Registry::getServiceMap(v43, *(Registry **)(v21 + 56));
  CFBooleanRef v60 = v268;
  char v61 = v59;
  uint64_t v63 = v62;
  if (v62 < 0)
  {
    uint64_t v64 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v65 = 5381;
    do
    {
      uint64_t v63 = v65;
      unsigned int v66 = *v64++;
      uint64_t v65 = (33 * v65) ^ v66;
    }
    while (v66);
  }
  std::mutex::lock(v59);
  *(void *)v279 = v63;
  int v67 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)v279);
  if (!v67)
  {
    std::mutex::unlock(v61);
    goto LABEL_79;
  }
  uint64_t v68 = v67[3];
  int v69 = (std::__shared_weak_count *)v67[4];
  if (!v69)
  {
    std::mutex::unlock(v61);
    if (v68)
    {
LABEL_81:
      *(void *)v279 = 0;
      *(void *)&v279[8] = 0;
      sub_1006E3F34(v68, v279);
      if ((*(unsigned int (**)(void))(**(void **)v279 + 96))(*(void *)v279)) {
        int v70 = (*(uint64_t (**)(void))(**(void **)v279 + 88))(*(void *)v279) ^ 1;
      }
      else {
        int v70 = 0;
      }
      if (*(void *)&v279[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v279[8]);
      }
      if (!v69) {
        goto LABEL_88;
      }
      goto LABEL_87;
    }
LABEL_79:
    int v70 = 0;
    goto LABEL_88;
  }
  atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v61);
  atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v69);
  if (v68) {
    goto LABEL_81;
  }
  int v70 = 0;
LABEL_87:
  sub_10004D2C8(v69);
LABEL_88:
  uint64_t v71 = v271;
  unint64_t v72 = 2;
  do
  {
    if (v70 && (v72 == 16 || v72 == 32 || v72 == 0x8000000))
    {
      BOOL v73 = v71;
    }
    else
    {
      sub_100BBE1DC(v279, v21, v272);
      uint64_t v74 = *(void *)v279;
      BOOL v73 = *(std::__shared_weak_count **)&v279[8];
      *(void *)v279 = 0;
      *(void *)&v279[8] = 0;
      v270 = v74;
      v271 = v73;
      if (v71)
      {
        sub_10004D2C8(v71);
        if (*(void *)&v279[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v279[8]);
        }
      }
      if (v74) {
        sub_100BBE624(v272, v267 != 0, (uint64_t)buf, v72, v270);
      }
      CFBooleanRef v60 = v268;
    }
    unint64_t v75 = v72 >> 35;
    v72 *= 2;
    uint64_t v71 = v73;
  }
  while (!v75);
  if (*(void *)&buf[8] - *(void *)buf >= 0x21uLL)
  {
    unint64_t v76 = 126 - 2 * __clz((*(void *)&buf[8] - (*(void *)buf + 16)) >> 4);
    if (*(void *)&buf[8] == *(void *)buf + 16) {
      uint64_t v77 = 0;
    }
    else {
      uint64_t v77 = v76;
    }
    sub_100BC3B38((void *)(*(void *)buf + 16), *(char **)&buf[8], v77, 1);
  }
  unint64_t v78 = 2;
  do
  {
    memset(v279, 0, sizeof(v279));
    int v79 = *v60;
    if (!*v60) {
      goto LABEL_118;
    }
    int v80 = v60;
    do
    {
      signed int v81 = *((_DWORD *)v79 + 8);
      BOOL v82 = v81 < (int)v272;
      if (v81 >= (int)v272) {
        int v83 = v79;
      }
      else {
        int v83 = v79 + 1;
      }
      if (!v82) {
        int v80 = (uint64_t **)v79;
      }
      int v79 = (uint64_t *)*v83;
    }
    while (*v83);
    if (v80 == v60 || (int v84 = (uint64_t *)*((unsigned int *)v80 + 8), (int)v84 > (int)v272))
    {
LABEL_118:
      memset(v279, 0, sizeof(v279));
      goto LABEL_119;
    }
    dispatch_object_t v86 = (std::mutex *)Registry::getServiceMap(v84, *(Registry **)(v21 + 56));
    dispatch_object_t v87 = v86;
    int v88 = (const void *)v62;
    if (v62 < 0)
    {
      uint64_t v89 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v90 = 5381;
      do
      {
        int v88 = (const void *)v90;
        unsigned int v91 = *v89++;
        uint64_t v90 = (33 * v90) ^ v91;
      }
      while (v91);
    }
    std::mutex::lock(v86);
    cf[0] = v88;
    int v92 = sub_10004D37C(&v87[1].__m_.__sig, (unint64_t *)cf);
    if (!v92)
    {
      uint64_t v94 = 0;
LABEL_132:
      std::mutex::unlock(v87);
      int v93 = 0;
      char v95 = 1;
      goto LABEL_133;
    }
    uint64_t v94 = v92[3];
    int v93 = (std::__shared_weak_count *)v92[4];
    if (!v93) {
      goto LABEL_132;
    }
    atomic_fetch_add_explicit(&v93->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v87);
    atomic_fetch_add_explicit(&v93->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v93);
    char v95 = 0;
LABEL_133:
    cf[0] = 0;
    cf[1] = 0;
    sub_100BBB920(v94, cf);
    if (cf[0])
    {
      (*(void (**)(unsigned char *__return_ptr))(*(void *)cf[0] + 72))(v277);
      uint64_t v96 = *(void *)v277;
      CFRange v97 = *(std::__shared_weak_count **)&v277[8];
    }
    else
    {
      uint64_t v96 = 0;
      CFRange v97 = 0;
    }
    if (cf[1]) {
      sub_10004D2C8((std::__shared_weak_count *)cf[1]);
    }
    cf[0] = 0;
    cf[1] = 0;
    sub_10022EDC4(v94, cf);
    CFTypeRef v98 = cf[0];
    if (cf[0])
    {
      v273 = v96;
      v274 = v97;
      if (v97) {
        atomic_fetch_add_explicit(&v97->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(unsigned char *__return_ptr))(*(void *)v98 + 136))(v277);
      uint64_t v100 = *(void *)v277;
      uint64_t v99 = *(std::__shared_weak_count **)&v277[8];
      *(void *)v277 = 0;
      *(void *)&v277[8] = 0;
      if (v274) {
        sub_10004D2C8(v274);
      }
    }
    else
    {
      uint64_t v100 = 0;
      uint64_t v99 = 0;
    }
    if (cf[1]) {
      sub_10004D2C8((std::__shared_weak_count *)cf[1]);
    }
    if (v100)
    {
      uint64_t v101 = v99;
    }
    else
    {
      if (v97) {
        atomic_fetch_add_explicit(&v97->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v100 = v96;
      uint64_t v101 = v97;
      if (v99)
      {
        sub_10004D2C8(v99);
        uint64_t v100 = v96;
        uint64_t v101 = v97;
      }
    }
    *(void *)v279 = v100;
    *(void *)&v279[8] = v101;
    if (v101) {
      atomic_fetch_add_explicit(&v101->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)&v279[16] = v96;
    *(void *)&v279[24] = v97;
    if (v97) {
      atomic_fetch_add_explicit(&v97->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v101) {
      sub_10004D2C8(v101);
    }
    if (v97) {
      sub_10004D2C8(v97);
    }
    if ((v95 & 1) == 0) {
      sub_10004D2C8(v93);
    }
    CFBooleanRef v60 = v268;
    uint64_t v21 = v269;
    if (*(void *)v279) {
      sub_100BBE71C(v269, v272, v267 != 0, (uint64_t *)buf, v78, (uint64_t *)v279, *(uint64_t *)&v279[16]);
    }
LABEL_119:
    if (*(void *)&v279[24]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v279[24]);
    }
    if (*(void *)&v279[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v279[8]);
    }
    unint64_t v85 = v78 >> 35;
    v78 *= 2;
  }
  while (!v85);
  uint64_t v102 = v272;
  uint64_t v103 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v21 + 48) + 16))(*(void *)(v21 + 48), v272);
  int v105 = (std::mutex *)Registry::getServiceMap(v104, *(Registry **)(v21 + 56));
  char v106 = v105;
  uint64_t v108 = v107;
  if (v107 < 0)
  {
    long long v109 = (unsigned __int8 *)(v107 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v110 = 5381;
    do
    {
      uint64_t v108 = v110;
      unsigned int v111 = *v109++;
      uint64_t v110 = (33 * v110) ^ v111;
    }
    while (v111);
  }
  std::mutex::lock(v105);
  *(void *)v279 = v108;
  unsigned int v112 = sub_10004D37C(&v106[1].__m_.__sig, (unint64_t *)v279);
  v263 = v107;
  if (v112)
  {
    uint64_t v113 = v112[3];
    uint64_t v114 = (std::__shared_weak_count *)v112[4];
    if (v114)
    {
      atomic_fetch_add_explicit(&v114->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v106);
      atomic_fetch_add_explicit(&v114->__shared_owners_, 1uLL, memory_order_relaxed);
      v257 = v114;
      sub_10004D2C8(v114);
      v261 = 0;
      if (!v113) {
        goto LABEL_187;
      }
      goto LABEL_173;
    }
  }
  else
  {
    uint64_t v113 = 0;
  }
  std::mutex::unlock(v106);
  v257 = 0;
  v261 = 1;
  if (!v113) {
    goto LABEL_187;
  }
LABEL_173:
  uint64_t v115 = (*(uint64_t (**)(uint64_t))(*(void *)v113 + 872))(v113);
  if (v115)
  {
    if ((*(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)v115 + 64))(v115, v102, 0))
    {
      uint64_t v116 = *(uint64_t **)buf;
      if (*(void *)&buf[8] != *(void *)buf)
      {
        uint64_t v117 = 0;
        if ((unint64_t)((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 4) <= 1) {
          uint64_t v118 = 1;
        }
        else {
          uint64_t v118 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 4;
        }
        uint64_t v119 = -1;
        do
        {
          uint64_t v120 = *v116;
          v116 += 2;
          if (*(unsigned char *)(v120 + 152)) {
            uint64_t v119 = v117;
          }
          ++v117;
        }
        while (v118 != v117);
        if (v119 != -1)
        {
          *(void *)v277 = 0;
          *(void *)v279 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          sub_1003AA8C0(v277, (CFTypeRef *)v279);
          int v121 = *v103;
          if (os_log_type_enabled(*v103, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v122 = asString();
            *(_DWORD *)v279 = 136315138;
            *(void *)&v279[4] = v122;
            _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_DEFAULT, "#I Generating APN for %s", v279, 0xCu);
          }
          cf[0] = 0;
          cf[1] = 0;
          sub_100BBEBF8();
        }
      }
    }
  }
LABEL_187:
  if ((v261 & 1) == 0) {
    sub_10004D2C8(v257);
  }
  uint64_t v123 = v272;
  unsigned int v124 = (capabilities::ct *)(*(uint64_t (**)(void, void))(**(void **)(v269 + 48) + 16))(*(void *)(v269 + 48), v272);
  v125 = (capabilities::ct *)capabilities::ct::supportsVoiceCall(v124);
  if (v125 && capabilities::ct::supportsEmergencySoSOverCell(v125))
  {
    uint64_t v126 = *(void *)buf;
    if (*(void *)&buf[8] == *(void *)buf)
    {
LABEL_196:
      *(void *)v277 = 0;
      *(void *)v279 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      sub_1003AA8C0(v277, (CFTypeRef *)v279);
      if (*(void *)&buf[8] == *(void *)buf)
      {
        v128 = *(NSObject **)v124;
        if (os_log_type_enabled(*(os_log_t *)v124, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v279 = 0;
          _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "#I Empty APN list, generate a fake internet APN too besides SOS APN", v279, 2u);
        }
        cf[0] = 0;
        cf[1] = 0;
        sub_100BBEC88(cf);
      }
      id v136 = *(NSObject **)v124;
      if (os_log_type_enabled(*(os_log_t *)v124, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v279 = 0;
        _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, "#I No Emergency APN present, generate one", v279, 2u);
      }
      cf[0] = 0;
      cf[1] = 0;
      sub_100BBEC88(cf);
    }
    unint64_t v127 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 4;
    if (v127 <= 1) {
      unint64_t v127 = 1;
    }
    while ((*(unsigned char *)(*(void *)v126 + 154) & 4) == 0)
    {
      v126 += 16;
      if (!--v127) {
        goto LABEL_196;
      }
    }
  }
  v137 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v269 + 48) + 16))(*(void *)(v269 + 48), v123);
  BOOL v139 = (std::mutex *)Registry::getServiceMap(v138, *(Registry **)(v269 + 56));
  v140 = v139;
  uint64_t v141 = v107;
  if (v107 < 0)
  {
    BOOL v142 = (unsigned __int8 *)(v107 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v143 = 5381;
    do
    {
      uint64_t v141 = v143;
      unsigned int v144 = *v142++;
      uint64_t v143 = (33 * v143) ^ v144;
    }
    while (v144);
  }
  std::mutex::lock(v139);
  *(void *)v279 = v141;
  int v145 = sub_10004D37C(&v140[1].__m_.__sig, (unint64_t *)v279);
  if (v145)
  {
    uint64_t v146 = v145[3];
    v147 = (std::__shared_weak_count *)v145[4];
    if (v147)
    {
      atomic_fetch_add_explicit(&v147->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v140);
      atomic_fetch_add_explicit(&v147->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v147);
      char v148 = 0;
      goto LABEL_233;
    }
  }
  else
  {
    uint64_t v146 = 0;
  }
  std::mutex::unlock(v140);
  v147 = 0;
  char v148 = 1;
LABEL_233:
  v258 = v147;
  v262 = v148;
  if (v146)
  {
    __int16 v149 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v146 + 224))(v146, v123);
    int v150 = v149;
    int v151 = HIBYTE(v149);
  }
  else
  {
    int v150 = 0;
    int v151 = 0;
  }
  uint64_t v153 = *(void *)buf;
  uint64_t v152 = *(void *)&buf[8];
  if (*(void *)&buf[8] == *(void *)buf) {
    goto LABEL_266;
  }
  uint64_t v154 = 0;
  unint64_t v155 = 0;
  while (1)
  {
    uint64_t v156 = *(void *)(v153 + v154);
    uint64_t v157 = *(void *)(v156 + 152);
    if ((v157 & 0x8000000) != 0) {
      break;
    }
LABEL_246:
    ++v155;
    v154 += 16;
    if (v155 >= (v152 - v153) >> 4) {
      goto LABEL_261;
    }
  }
  if ((v157 & 0x10) != 0 || !v151 || v150) {
    goto LABEL_271;
  }
  long long v158 = *v137;
  BOOL v159 = os_log_type_enabled(*v137, OS_LOG_TYPE_DEFAULT);
  if (v157 != 0x8000000)
  {
    if (v159)
    {
      *(_WORD *)v279 = 0;
      _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "#I Removing not allowed dedicated low-latency tethering service from APN", v279, 2u);
      uint64_t v153 = *(void *)buf;
      uint64_t v152 = *(void *)&buf[8];
      uint64_t v156 = *(void *)(*(void *)buf + v154);
      uint64_t v157 = *(void *)(v156 + 152);
    }
    *(void *)(v156 + 152) = v157 & 0xFFFFFFFFF7FFFFFFLL;
    goto LABEL_246;
  }
  if (v159)
  {
    *(_WORD *)v279 = 0;
    _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "#I Removing not allowed dedicated low-latency tethering APN", v279, 2u);
    uint64_t v153 = *(void *)buf;
    uint64_t v152 = *(void *)&buf[8];
  }
  uint64_t v160 = v153 + v154;
  uint64_t v161 = v153 + v154 + 16;
  if (v161 == v152)
  {
    uint64_t v164 = v152;
    uint64_t v152 = v160;
  }
  else
  {
    do
    {
      long long v162 = *(_OWORD *)v161;
      *(void *)uint64_t v161 = 0;
      *(void *)(v161 + 8) = 0;
      v163 = *(std::__shared_weak_count **)(v161 - 8);
      *(_OWORD *)(v161 - 16) = v162;
      if (v163) {
        sub_10004D2C8(v163);
      }
      v161 += 16;
    }
    while (v161 != v152);
    uint64_t v164 = *(void *)&buf[8];
    uint64_t v152 = v161 - 16;
  }
  while (v152 != v164)
  {
    uint64_t v165 = *(std::__shared_weak_count **)(v164 - 8);
    if (v165) {
      sub_10004D2C8(v165);
    }
    v164 -= 16;
  }
  *(void *)&uint8_t buf[8] = v152;
  uint64_t v153 = *(void *)buf;
LABEL_261:
  if (v152 == v153)
  {
LABEL_266:
    uint64_t v170 = *v137;
    if (os_log_type_enabled(*v137, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v279 = 0;
      _os_log_impl((void *)&_mh_execute_header, v170, OS_LOG_TYPE_DEFAULT, "#I No Tethering APN present, not adding low-latency tethering", v279, 2u);
    }
    goto LABEL_271;
  }
  uint64_t v166 = 0;
  unint64_t v167 = (v152 - v153) >> 4;
  if (v167 <= 1) {
    unint64_t v167 = 1;
  }
  while (1)
  {
    uint64_t v168 = *(void *)(v153 + v166);
    uint64_t v169 = *(void *)(v168 + 152);
    if ((v169 & 0x10) != 0) {
      break;
    }
    v166 += 16;
    if (!--v167) {
      goto LABEL_266;
    }
  }
  uint64_t v171 = *v137;
  if (os_log_type_enabled(*v137, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v279 = 0;
    _os_log_impl((void *)&_mh_execute_header, v171, OS_LOG_TYPE_DEFAULT, "#I Adding low-latency tethering service to APN", v279, 2u);
    uint64_t v168 = *(void *)(*(void *)buf + v166);
    uint64_t v169 = *(void *)(v168 + 152);
  }
  *(void *)(v168 + 152) = v169 | 0x8000000;
LABEL_271:
  if ((v262 & 1) == 0) {
    sub_10004D2C8(v258);
  }
  uint64_t v172 = *(uint64_t **)buf;
  v173 = *(uint64_t **)&buf[8];
  if (*(void *)buf != *(void *)&buf[8])
  {
    while (2)
    {
      uint64_t v174 = *v172;
      uint64_t v175 = *(void *)(*v172 + 152);
      if (v175 >= 0x40000)
      {
        if (v175 == 0x4000000 || v175 == 0x40000) {
          goto LABEL_280;
        }
      }
      else
      {
        if (v175 != 4 && v175 != 0x20000) {
          goto LABEL_286;
        }
LABEL_280:
        if (!*(unsigned char *)(v174 + 192))
        {
          uint64_t v176 = *(NSObject **)(v269 + 40);
          if (os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v177 = (void *)(v174 + 48);
            if (*(char *)(v174 + 71) < 0) {
              uint64_t v177 = (void *)*v177;
            }
            *(_DWORD *)v279 = 136315394;
            *(void *)&v279[4] = v177;
            *(_WORD *)&v279[12] = 2048;
            *(void *)&v279[14] = v175;
            _os_log_impl((void *)&_mh_execute_header, v176, OS_LOG_TYPE_DEFAULT, "#I APN %s, allowing no DNS for 0x%llx", v279, 0x16u);
            uint64_t v174 = *v172;
          }
          *(unsigned char *)(v174 + 192) = 1;
        }
      }
LABEL_286:
      v172 += 2;
      if (v172 == v173) {
        break;
      }
      continue;
    }
  }
  int v178 = v272;
  uint64_t v27 = v268;
  uint64_t v179 = v263;
  unint64_t v14 = v264;
  int v180 = v265;
  if (v272 == 1)
  {
    v181 = *(uint64_t ***)(v269 + 248);
    int v183 = *v181;
    v182 = v181[1];
    while (1)
    {
      if (v183 == v182) {
        goto LABEL_312;
      }
      if (*(unsigned char *)(*v183 + 49) == 1) {
        break;
      }
      v183 += 2;
    }
    BOOL v184 = (std::mutex *)Registry::getServiceMap(v182, *(Registry **)(v269 + 56));
    v185 = v184;
    if (v186 < 0)
    {
      BOOL v187 = (unsigned __int8 *)(v186 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v188 = 5381;
      do
      {
        uint64_t v186 = v188;
        unsigned int v189 = *v187++;
        uint64_t v188 = (33 * v188) ^ v189;
      }
      while (v189);
    }
    std::mutex::lock(v184);
    *(void *)v279 = v186;
    v190 = sub_10004D37C(&v185[1].__m_.__sig, (unint64_t *)v279);
    int v180 = v265;
    uint64_t v27 = v268;
    if (!v190)
    {
      std::mutex::unlock(v185);
      unint64_t v14 = v264;
      goto LABEL_312;
    }
    uint64_t v191 = (void (***)(uint8_t *__return_ptr, void, uint64_t))v190[3];
    v192 = (std::__shared_weak_count *)v190[4];
    if (v192)
    {
      atomic_fetch_add_explicit(&v192->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v185);
      atomic_fetch_add_explicit(&v192->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v27 = v268;
      uint64_t v179 = v263;
      sub_10004D2C8(v192);
      unint64_t v14 = v264;
      if (!v191)
      {
LABEL_311:
        sub_10004D2C8(v192);
        goto LABEL_312;
      }
    }
    else
    {
      std::mutex::unlock(v185);
      unint64_t v14 = v264;
      if (!v191) {
        goto LABEL_312;
      }
    }
    *(void *)v279 = 0;
    *(void *)&v279[8] = 0;
    (**v191)(v279, v191, *v183 + 24);
    if (*(void *)v279)
    {
      cf[0] = 0;
      cf[1] = 0;
      *(void *)v277 = 0;
      *(void *)&v277[8] = 0;
      (*(void (**)(CFTypeRef *__return_ptr))(**(void **)v279 + 128))(cf);
      if (*(void *)&v277[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v277[8]);
      }
      if (cf[0]) {
        sub_100BBE71C(v269, 1, v267 != 0, (uint64_t *)buf, 0x4000000uLL, (uint64_t *)cf, 0);
      }
      if (cf[1]) {
        sub_10004D2C8((std::__shared_weak_count *)cf[1]);
      }
    }
    if (*(void *)&v279[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v279[8]);
    }
    if (v192) {
      goto LABEL_311;
    }
  }
LABEL_312:
  memset(v279, 0, 24);
  unsigned int v193 = (std::mutex *)sub_1000389F8(*(uint64_t **)(v269 + 272), v178);
  sub_100BBE9D4(v279, v193);
  v194 = *(void *)v279;
  if (*(void *)&buf[8] - *(void *)buf != *(void *)&v279[8] - *(void *)v279)
  {
LABEL_324:
    v199 = sub_100BBEA98(*v27, v178, (uint64_t)buf, 0x30u);
    v201 = v200;
    v202 = sub_100BBEA98(*v27, v178, (uint64_t)buf, 0x8000000u);
    char v204 = v203;
    v205 = sub_100BC6250((uint64_t **)(v269 + 264), v178, &v272);
    std::mutex::lock((std::mutex *)(v205 + 5));
    uint64_t v206 = *(_OWORD *)(v205 + 13);
    *(_OWORD *)(v205 + 13) = *(_OWORD *)buf;
    *(_OWORD *)long long buf = v206;
    v207 = v205[15];
    v205[15] = *(uint64_t **)&buf[16];
    *(void *)&uint8_t buf[16] = v207;
    std::mutex::unlock((std::mutex *)(v205 + 5));
    *(_DWORD *)v260 = v265;
    uint64_t v208 = *v264;
    if (os_log_type_enabled(*v264, OS_LOG_TYPE_DEFAULT))
    {
      v210 = sub_100BC6250((uint64_t **)(v269 + 264), v178, &v272);
      xpc_object_t v211 = (std::mutex *)(v210 + 5);
      std::mutex::lock((std::mutex *)(v210 + 5));
      BOOL v214 = v210 + 13;
      v212 = v210[13];
      long long v213 = v214[1];
      std::mutex::unlock(v211);
      WirelessTechnologyList::asString((uint64_t *)cf, v260);
      if (v276 >= 0) {
        unsigned int v215 = cf;
      }
      else {
        unsigned int v215 = (CFTypeRef *)cf[0];
      }
      *(_DWORD *)v277 = 134218242;
      *(void *)&v277[4] = ((char *)v213 - (char *)v212) >> 4;
      *(_WORD *)&v277[12] = 2080;
      *(void *)&v277[14] = v215;
      _os_log_impl((void *)&_mh_execute_header, v208, OS_LOG_TYPE_DEFAULT, "#I reconfigure_sync: %zu APNs updated, reset compatible technologies: %s", v277, 0x16u);
      uint64_t v209 = (uint64_t *)v276;
      if ((v209 & 0x80000000) != 0) {
        operator delete((void *)cf[0]);
      }
      uint64_t v179 = v263;
    }
    v216 = (std::mutex *)Registry::getServiceMap(v209, *(Registry **)(v269 + 56));
    char v217 = v216;
    if (v179 < 0)
    {
      int v218 = (unsigned __int8 *)(v179 & 0x7FFFFFFFFFFFFFFFLL);
      v219 = 5381;
      do
      {
        uint64_t v179 = v219;
        v220 = *v218++;
        v219 = (33 * v219) ^ v220;
      }
      while (v220);
    }
    std::mutex::lock(v216);
    cf[0] = (CFTypeRef)v179;
    __int16 v221 = sub_10004D37C(&v217[1].__m_.__sig, (unint64_t *)cf);
    if (v221)
    {
      uint64_t v222 = v221[3];
      __int16 v223 = (std::__shared_weak_count *)v221[4];
      if (v223)
      {
        atomic_fetch_add_explicit(&v223->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v217);
        atomic_fetch_add_explicit(&v223->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v223);
        uint64_t v224 = 0;
        if (!v222) {
          goto LABEL_352;
        }
        goto LABEL_340;
      }
    }
    else
    {
      uint64_t v222 = 0;
    }
    std::mutex::unlock(v217);
    __int16 v223 = 0;
    uint64_t v224 = 1;
    if (!v222) {
      goto LABEL_352;
    }
LABEL_340:
    __int16 v225 = (*(uint64_t (**)(uint64_t))(*(void *)v222 + 1128))(v222);
    uint64_t v226 = v225;
    if (v225)
    {
      __int16 v227 = (*(uint64_t (**)(uint64_t))(*(void *)v225 + 56))(v225);
      if (v227 == v272)
      {
        if ((_BYTE)v199)
        {
          uint64_t v228 = *v264;
          if (os_log_type_enabled(*v264, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(cf[0]) = 67109376;
            HIDWORD(cf[0]) = HIDWORD(v199);
            LOWORD(cf[1]) = 1024;
            *(_DWORD *)((char *)&cf[1] + 2) = v201;
            _os_log_impl((void *)&_mh_execute_header, v228, OS_LOG_TYPE_DEFAULT, "#I PHS APN set changed: was 0x%x, become 0x%x", (uint8_t *)cf, 0xEu);
          }
          if (HIDWORD(v199)) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v226 + 24))(v226, v227);
          }
        }
        if ((_BYTE)v202)
        {
          __int16 v229 = *v264;
          if (os_log_type_enabled(*v264, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(cf[0]) = 67109376;
            HIDWORD(cf[0]) = HIDWORD(v202);
            LOWORD(cf[1]) = 1024;
            *(_DWORD *)((char *)&cf[1] + 2) = v204;
            _os_log_impl((void *)&_mh_execute_header, v229, OS_LOG_TYPE_DEFAULT, "#I LL PHS APN set changed: was 0x%x, become 0x%x", (uint8_t *)cf, 0xEu);
          }
          if (HIDWORD(v202)) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v226 + 24))(v226, v227);
          }
        }
      }
    }
LABEL_352:
    if ((v224 & 1) == 0) {
      sub_10004D2C8(v223);
    }
    uint64_t v230 = (std::mutex *)Registry::getServiceMap((uint64_t *)v269, *(Registry **)(v269 + 56));
    int v180 = v265;
    uint64_t v27 = v268;
    __int16 v231 = v230;
    if (v232 < 0)
    {
      __int16 v233 = (unsigned __int8 *)(v232 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v234 = 5381;
      do
      {
        uint64_t v232 = v234;
        __int16 v235 = *v233++;
        uint64_t v234 = (33 * v234) ^ v235;
      }
      while (v235);
    }
    std::mutex::lock(v230);
    cf[0] = (CFTypeRef)v232;
    uint64_t v236 = sub_10004D37C(&v231[1].__m_.__sig, (unint64_t *)cf);
    unint64_t v14 = v264;
    if (v236)
    {
      __int16 v237 = v236[3];
      uint64_t v238 = (std::__shared_weak_count *)v236[4];
      if (v238)
      {
        atomic_fetch_add_explicit(&v238->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v231);
        atomic_fetch_add_explicit(&v238->__shared_owners_, 1uLL, memory_order_relaxed);
        unint64_t v14 = v264;
        sub_10004D2C8(v238);
        __int16 v239 = 0;
        if (!v237) {
          goto LABEL_364;
        }
        goto LABEL_363;
      }
    }
    else
    {
      __int16 v237 = 0;
    }
    std::mutex::unlock(v231);
    uint64_t v238 = 0;
    __int16 v239 = 1;
    if (!v237)
    {
LABEL_364:
      if ((v239 & 1) == 0) {
        sub_10004D2C8(v238);
      }
      v266 = 1;
      goto LABEL_367;
    }
LABEL_363:
    (*(void (**)(uint64_t, void))(*(void *)v237 + 16))(v237, v272);
    goto LABEL_364;
  }
  if (*(void *)&v279[8] != *(void *)v279)
  {
    BOOL v195 = 0;
    v196 = 0;
    while ((sub_100C98FCC(*(void *)(*(void *)buf + v195), *(void *)(v194 + v195)) & 1) != 0)
    {
      ++v196;
      v194 = *(void *)v279;
      v195 += 16;
      if (v196 >= (uint64_t)(*(void *)&v279[8] - *(void *)v279) >> 4) {
        goto LABEL_317;
      }
    }
    goto LABEL_324;
  }
LABEL_317:
  *(_DWORD *)v260 |= v180;
  BOOL v197 = *v14;
  v266 = 0;
  if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
  {
    WirelessTechnologyList::asString((uint64_t *)cf, v260);
    if (v276 >= 0) {
      char v198 = cf;
    }
    else {
      char v198 = (CFTypeRef *)cf[0];
    }
    *(_DWORD *)v277 = 136315138;
    *(void *)&v277[4] = v198;
    _os_log_impl((void *)&_mh_execute_header, v197, OS_LOG_TYPE_DEFAULT, "#I reconfigure_sync: skipped - no changes detected, new compatible technologies: %s", v277, 0xCu);
    if (v276 < 0) {
      operator delete((void *)cf[0]);
    }
    v266 = 0;
  }
LABEL_367:
  *v259 = v180;
  cf[0] = v279;
  sub_10005CBF0((void ***)cf);
  if (v271) {
    sub_10004D2C8(v271);
  }
  *(void *)v279 = buf;
  sub_10005CBF0((void ***)v279);
  uint64_t v7 = v272;
LABEL_370:
  uint64_t v240 = sub_1000389F8(*v27, v7);
  std::mutex::lock((std::mutex *)v240);
  uint64_t v242 = v240[8];
  __int16 v241 = v240[9];
  std::mutex::unlock((std::mutex *)v240);
  if (v241 != v242)
  {
    __int16 v243 = 0;
    if ((unint64_t)((v241 - v242) >> 4) <= 1) {
      uint64_t v244 = 1;
    }
    else {
      uint64_t v244 = (v241 - v242) >> 4;
    }
    do
    {
      sub_100BBEB78(v279, (std::mutex *)v240, v243);
      std::string v245 = *(void *)(*(void *)v279 + 152);
      if (*(void *)&v279[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v279[8]);
      }
      v246 = ConnectionMaskToType(v245);
      if (isSlice())
      {
        std::string v247 = (std::mutex *)Registry::getServiceMap((uint64_t *)v269, *(Registry **)(v269 + 56));
        v248 = v247;
        if (v249 < 0)
        {
          v250 = (unsigned __int8 *)(v249 & 0x7FFFFFFFFFFFFFFFLL);
          v251 = 5381;
          do
          {
            v249 = v251;
            v252 = *v250++;
            v251 = (33 * v251) ^ v252;
          }
          while (v252);
        }
        std::mutex::lock(v247);
        *(void *)v279 = v249;
        v253 = sub_10004D37C(&v248[1].__m_.__sig, (unint64_t *)v279);
        if (v253)
        {
          v254 = v253[3];
          v255 = (std::__shared_weak_count *)v253[4];
          if (v255)
          {
            atomic_fetch_add_explicit(&v255->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v248);
            atomic_fetch_add_explicit(&v255->__shared_owners_, 1uLL, memory_order_relaxed);
            unint64_t v14 = v264;
            sub_10004D2C8(v255);
            if (v254) {
              goto LABEL_390;
            }
            sub_10004D2C8(v255);
          }
          else
          {
            std::mutex::unlock(v248);
            if (v254)
            {
LABEL_390:
              if (((*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)v254 + 232))(v254, v7, v245) & 0xFF00000000) != 0)
              {
                memset(v279, 0, 24);
                (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v254 + 144))(v279, v254, v7, v246);
                *(void *)long long buf = 0;
                *(void *)&uint8_t buf[8] = 0;
                sub_100BBEB78(cf, (std::mutex *)v240, v243);
                sub_100BBEBF8();
              }
              if (!v255) {
                goto LABEL_387;
              }
              v256 = v255;
LABEL_386:
              sub_10004D2C8(v256);
              goto LABEL_387;
            }
          }
        }
        else
        {
          std::mutex::unlock(v248);
        }
      }
      sub_100BBEB78(v279, (std::mutex *)v240, v243);
      sub_100C97DFC(*(uint64_t *)v279, v14, (uint64_t)"");
      v256 = *(std::__shared_weak_count **)&v279[8];
      if (*(void *)&v279[8]) {
        goto LABEL_386;
      }
LABEL_387:
      ++v243;
    }
    while (v243 != v244);
  }
  return v266;
}

void sub_100BBDEE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,uint64_t a26,uint64_t a27,uint64_t a28,void **a29,std::__shared_weak_count *a30)
{
  if (a30) {
    sub_10004D2C8(a30);
  }
  unsigned int v33 = *(std::__shared_weak_count **)(v31 - 136);
  if (v33) {
    sub_10004D2C8(v33);
  }
  if (v30) {
    sub_10004D2C8(v30);
  }
  if (a25) {
    sub_10004D2C8(a25);
  }
  a29 = (void **)(v31 - 176);
  sub_10005CBF0(&a29);
  _Unwind_Resume(a1);
}

void sub_100BBE1DC(void *a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(a2 + 272);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = a2 + 272;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a3;
    if (v6 >= a3) {
      BOOL v8 = (uint64_t *)v4;
    }
    else {
      BOOL v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 == a2 + 272 || (uint64_t v9 = (uint64_t *)*(unsigned int *)(v5 + 32), (int)v9 > a3))
  {
LABEL_11:
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a2 + 56));
  BOOL v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v32 = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v32);
  if (!v16)
  {
    uint64_t v18 = 0;
    goto LABEL_20;
  }
  uint64_t v18 = v16[3];
  unsigned int v17 = (std::__shared_weak_count *)v16[4];
  if (!v17)
  {
LABEL_20:
    std::mutex::unlock(v11);
    unsigned int v17 = 0;
    char v19 = 1;
    goto LABEL_21;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
LABEL_21:
  unint64_t v32 = 0;
  unsigned int v33 = 0;
  sub_100BBB920(v18, &v32);
  if (v32)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v32 + 72))(&v31);
    uint64_t v20 = (std::__shared_weak_count *)*((void *)&v31 + 1);
    uint64_t v21 = v31;
  }
  else
  {
    uint64_t v21 = 0;
    uint64_t v20 = 0;
  }
  if (v33) {
    sub_10004D2C8(v33);
  }
  *a1 = 0;
  a1[1] = 0;
  unint64_t v32 = 0;
  unsigned int v33 = 0;
  sub_10022EDC4(v18, &v32);
  unint64_t v22 = v32;
  if (v32)
  {
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(long long *__return_ptr))(*(void *)v22 + 136))(&v31);
    long long v23 = v31;
    long long v31 = 0uLL;
    uint64_t v24 = (std::__shared_weak_count *)a1[1];
    *(_OWORD *)a1 = v23;
    if (v24)
    {
      sub_10004D2C8(v24);
      if (*((void *)&v31 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v31 + 1));
      }
    }
    if (v20) {
      sub_10004D2C8(v20);
    }
  }
  if (v33) {
    sub_10004D2C8(v33);
  }
  if (!*a1)
  {
    unint64_t v32 = 0;
    unsigned int v33 = 0;
    sub_1006E4004(v18, &v32);
    if (v32)
    {
      (*(void (**)(long long *__return_ptr))(*(void *)v32 + 72))(&v31);
      long long v25 = v31;
      long long v31 = 0uLL;
      uint64_t v26 = (std::__shared_weak_count *)a1[1];
      *(_OWORD *)a1 = v25;
      if (v26)
      {
        sub_10004D2C8(v26);
        if (*((void *)&v31 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v31 + 1));
        }
      }
    }
    if (v33) {
      sub_10004D2C8(v33);
    }
    if (!*a1 && v21)
    {
      unint64_t v32 = 0;
      unsigned int v33 = 0;
      sub_1006E3F34(v18, &v32);
      unint64_t v27 = v32;
      if (v32)
      {
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(long long *__return_ptr))(*(void *)v27 + 72))(&v31);
        long long v28 = v31;
        long long v31 = 0uLL;
        double v29 = (std::__shared_weak_count *)a1[1];
        *(_OWORD *)a1 = v28;
        if (v29)
        {
          sub_10004D2C8(v29);
          if (*((void *)&v31 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v31 + 1));
          }
        }
        if (v20) {
          sub_10004D2C8(v20);
        }
      }
      if (v33) {
        sub_10004D2C8(v33);
      }
      if (!*a1)
      {
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v30 = (std::__shared_weak_count *)a1[1];
        *a1 = v21;
        a1[1] = v20;
        if (v30) {
          sub_10004D2C8(v30);
        }
      }
    }
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_100BBE598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  uint64_t v21 = *(std::__shared_weak_count **)(v16 + 8);
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100BBE624(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v7 = *(uint64_t **)a3;
  uint64_t v8 = *(void *)(a3 + 8) - *(void *)a3;
  unint64_t v9 = v8 >> 4;
  if (v8)
  {
    uint64_t v11 = 0;
    if (v9 <= 1) {
      uint64_t v12 = 1;
    }
    else {
      uint64_t v12 = v8 >> 4;
    }
    while (1)
    {
      uint64_t v13 = *v7;
      BOOL result = sub_100BBF728(a2, a5, *v7);
      if (result) {
        break;
      }
      ++v11;
      v7 += 2;
      if (v12 == v11)
      {
        uint64_t v11 = v12;
        goto LABEL_10;
      }
    }
    *(void *)(v13 + 152) |= a4;
  }
  else
  {
    uint64_t v11 = 0;
  }
LABEL_10:
  if (v11 == v9)
  {
    sub_100BBF7D4();
  }
  return result;
}

void sub_100BBE71C(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, unint64_t a5, uint64_t *a6, uint64_t a7)
{
  BOOL v9 = a7 && (*(void *)(a7 + 152) & a5) != 0 && (*(void *)(a7 + 160) & a5) != 0;
  uint64_t v10 = *a4;
  uint64_t v11 = a4[1] - *a4;
  unint64_t v12 = v11 >> 4;
  if (!v11)
  {
    uint64_t v14 = 0;
    goto LABEL_18;
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = *a6;
  if (v12 <= 1) {
    uint64_t v16 = 1;
  }
  else {
    uint64_t v16 = v11 >> 4;
  }
  while (1)
  {
    uint64_t v17 = *(void *)(v10 + v13);
    if (v9) {
      break;
    }
    if (sub_100BBF728(a3, v15, *(void *)(v10 + v13))) {
      goto LABEL_17;
    }
LABEL_13:
    ++v14;
    v13 += 16;
    if (v16 == v14)
    {
      uint64_t v14 = v16;
      goto LABEL_18;
    }
  }
  if ((*(void *)(v17 + 152) & a5) == 0) {
    goto LABEL_13;
  }
  if (!sub_100BBF728(a3, v15, *(void *)(v10 + v13)))
  {
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      asStringMask((uint64_t *)v31, a5);
      if (v32 >= 0) {
        char v19 = v31;
      }
      else {
        char v19 = (void **)v31[0];
      }
      sub_100C98B0C(*a6, v29);
      int v20 = v30;
      uint64_t v21 = (void **)v29[0];
      sub_100C98B0C(*(void *)(*a4 + v13), __p);
      unint64_t v22 = v29;
      if (v20 < 0) {
        unint64_t v22 = v21;
      }
      if (v28 >= 0) {
        long long v23 = __p;
      }
      else {
        long long v23 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136315650;
      uint64_t v34 = v19;
      __int16 v35 = 2080;
      int v36 = v22;
      __int16 v37 = 2080;
      std::string::size_type v38 = v23;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Service %s requested to be on apn:%s but placed on %s since it already has the service for BB", buf, 0x20u);
      if (v28 < 0) {
        operator delete(__p[0]);
      }
      if (v30 < 0) {
        operator delete(v29[0]);
      }
      if (v32 < 0) {
        operator delete(v31[0]);
      }
      uint64_t v17 = *(void *)(*a4 + v13);
      unint64_t v12 = (a4[1] - *a4) >> 4;
    }
  }
LABEL_17:
  *(void *)(v17 + 160) |= a5;
LABEL_18:
  if (v14 == v12) {
    sub_100BBF7D4();
  }
}

void sub_100BBE998(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BBE9D4(void *a1, std::mutex *this)
{
  std::mutex::lock(this);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sig = (char *)this[1].__m_.__sig;
  uint64_t v5 = *(char **)this[1].__m_.__opaque;
  if (v5 != sig)
  {
    sub_1001577CC(a1, (v5 - sig) >> 4);
    a1[1] = sub_100BC4850((uint64_t)(a1 + 2), sig, v5, (void *)a1[1]);
  }

  std::mutex::unlock(this);
}

void sub_100BBEA70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v10 + 8) = v11;
  sub_10005CBF0(&a9);
  std::mutex::unlock(v9);
  _Unwind_Resume(a1);
}

unint64_t sub_100BBEA98(uint64_t *a1, int a2, uint64_t a3, unsigned int a4)
{
  char v19 = 0;
  int v20 = 0;
  uint64_t v21 = 0;
  int v6 = (std::mutex *)sub_1000389F8(a1, a2);
  sub_100BBE9D4(&v19, v6);
  BOOL v7 = v19;
  if (v20 == v19)
  {
    int v8 = 0;
  }
  else
  {
    int v8 = 0;
    unint64_t v9 = (v20 - v19) >> 4;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    do
    {
      uint64_t v10 = *(void *)v7;
      v7 += 16;
      v8 |= *(_DWORD *)(v10 + 152);
      --v9;
    }
    while (v9);
  }
  unint64_t v12 = *(uint64_t **)a3;
  uint64_t v11 = *(void *)(a3 + 8);
  uint64_t v13 = v11 - *(void *)a3;
  if (v11 == *(void *)a3)
  {
    int v14 = 0;
  }
  else
  {
    int v14 = 0;
    unint64_t v15 = v13 >> 4;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    do
    {
      uint64_t v16 = *v12;
      v12 += 2;
      v14 |= *(_DWORD *)(v16 + 152);
      --v15;
    }
    while (v15);
  }
  unint64_t v17 = ((v8 & a4) != (v14 & a4)) | ((unint64_t)(v8 & a4) << 32);
  unint64_t v22 = &v19;
  sub_10005CBF0((void ***)&v22);
  return v17;
}

void sub_100BBEB78(void *a1, std::mutex *this, unint64_t a3)
{
  std::mutex::lock(this);
  uint64_t sig = this[1].__m_.__sig;
  if (a3 >= (*(void *)this[1].__m_.__opaque - sig) >> 4)
  {
    *a1 = 0;
    a1[1] = 0;
  }
  else
  {
    long long v7 = *(_OWORD *)(sig + 16 * a3);
    *(_OWORD *)a1 = v7;
    if (*((void *)&v7 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v7 + 1) + 8), 1uLL, memory_order_relaxed);
    }
  }

  std::mutex::unlock(this);
}

void sub_100BBEBF8()
{
}

void sub_100BBEC64()
{
}

void sub_100BBEC88(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100BBED28(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BBED60(uint64_t a1, int a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 272);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = (uint64_t *)(a1 + 272);
  uint64_t v5 = v4;
  int v6 = v3;
  do
  {
    int v7 = *((_DWORD *)v6 + 8);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      unint64_t v9 = (uint64_t **)v6;
    }
    else {
      unint64_t v9 = (uint64_t **)(v6 + 1);
    }
    if (!v8) {
      uint64_t v5 = v6;
    }
    int v6 = *v9;
  }
  while (*v9);
  if (v5 == v4 || *((_DWORD *)v5 + 8) > a2) {
    return 0;
  }
  uint64_t v11 = sub_1000389F8(v3, a2);
  std::mutex::lock((std::mutex *)v11);
  uint64_t v10 = (v11[9] - v11[8]) >> 4;
  std::mutex::unlock((std::mutex *)v11);
  return v10;
}

void sub_100BBEDF0(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  int v6 = sub_100BBEEA4(*(Registry **)(a1 + 56), a3);
  int v7 = *(uint64_t **)(a1 + 272);
  if (!v7) {
    goto LABEL_11;
  }
  uint64_t v8 = a1 + 272;
  uint64_t v9 = *(void *)(a1 + 272);
  do
  {
    int v10 = *(_DWORD *)(v9 + 32);
    BOOL v11 = v10 < v6;
    if (v10 >= v6) {
      unint64_t v12 = (uint64_t *)v9;
    }
    else {
      unint64_t v12 = (uint64_t *)(v9 + 8);
    }
    if (!v11) {
      uint64_t v8 = v9;
    }
    uint64_t v9 = *v12;
  }
  while (*v12);
  if (v8 != a1 + 272 && *(_DWORD *)(v8 + 32) <= v6)
  {
    uint64_t v13 = (std::mutex *)sub_1000389F8(v7, v6);
    sub_100BBEB78(a3, v13, a2);
  }
  else
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
  }
}

uint64_t sub_100BBEEA4@<X0>(Registry *a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1);
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v13);
  if (v8)
  {
    uint64_t v9 = v8[3];
    int v10 = (std::__shared_weak_count *)v8[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v11 = 0;
      if (!v9) {
        goto LABEL_7;
      }
LABEL_11:
      LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 776))(v9);
      if (v11) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v3);
  int v10 = 0;
  char v11 = 1;
  if (v9) {
    goto LABEL_11;
  }
LABEL_7:
  if ((v11 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v10);
LABEL_13:
  if (v9) {
    return v3;
  }
  else {
    return 1;
  }
}

void sub_100BBEFC0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BBEFDC(uint64_t a1@<X0>, int a2@<W1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = *(uint64_t **)(a1 + 272);
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v8 = (uint64_t *)(a1 + 272);
  uint64_t v9 = v8;
  int v10 = v6;
  do
  {
    int v11 = *((_DWORD *)v10 + 8);
    BOOL v12 = v11 < a2;
    if (v11 >= a2) {
      unint64_t v13 = (uint64_t **)v10;
    }
    else {
      unint64_t v13 = (uint64_t **)(v10 + 1);
    }
    if (!v12) {
      uint64_t v9 = v10;
    }
    int v10 = *v13;
  }
  while (*v13);
  if (v9 != v8 && *((_DWORD *)v9 + 8) <= a2)
  {
    int v14 = (std::mutex *)sub_1000389F8(v6, a2);
    sub_100BBEB78(a4, v14, a3);
  }
  else
  {
LABEL_11:
    *a4 = 0;
    a4[1] = 0;
  }
}

void sub_100BBF078(uint64_t a1, int a2, unint64_t a3, const std::string *a4)
{
  uint64_t v5 = *(uint64_t **)(a1 + 272);
  if (v5)
  {
    uint64_t v8 = (uint64_t *)(a1 + 272);
    uint64_t v9 = (uint64_t *)(a1 + 272);
    int v10 = v5;
    do
    {
      int v11 = *((_DWORD *)v10 + 8);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        unint64_t v13 = (uint64_t **)v10;
      }
      else {
        unint64_t v13 = (uint64_t **)(v10 + 1);
      }
      if (!v12) {
        uint64_t v9 = v10;
      }
      int v10 = *v13;
    }
    while (*v13);
    if (v9 != v8 && *((_DWORD *)v9 + 8) <= a2)
    {
      int v14 = sub_1000389F8(v5, a2);
      std::mutex::lock((std::mutex *)v14);
      uint64_t v15 = v14[8];
      if (a3 < (v14[9] - v15) >> 4)
      {
        uint64_t v16 = *(std::string **)(v15 + 16 * a3);
        if (v16) {
          std::string::operator=(v16 + 2, a4);
        }
      }
      std::mutex::unlock((std::mutex *)v14);
    }
  }
}

void sub_100BBF144(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_100BBF158(uint64_t a1@<X0>, int a2@<W1>, unsigned char *a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = *(uint64_t **)(a1 + 272);
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v8 = (uint64_t *)(a1 + 272);
  uint64_t v9 = v8;
  int v10 = v6;
  do
  {
    int v11 = *((_DWORD *)v10 + 8);
    BOOL v12 = v11 < a2;
    if (v11 >= a2) {
      unint64_t v13 = (uint64_t **)v10;
    }
    else {
      unint64_t v13 = (uint64_t **)(v10 + 1);
    }
    if (!v12) {
      uint64_t v9 = v10;
    }
    int v10 = *v13;
  }
  while (*v13);
  if (v9 == v8 || *((_DWORD *)v9 + 8) > a2)
  {
LABEL_11:
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  int v14 = sub_1000389F8(v6, a2);
  std::mutex::lock((std::mutex *)v14);
  *a4 = 0;
  a4[1] = 0;
  uint64_t v15 = (void *)v14[8];
  uint64_t v16 = (void *)v14[9];
  if (v15 == v16) {
    goto LABEL_61;
  }
  char v17 = a3[23];
  if (v17 >= 0) {
    uint64_t v18 = a3[23];
  }
  else {
    uint64_t v18 = *((void *)a3 + 1);
  }
  if (v17 >= 0) {
    char v19 = a3;
  }
  else {
    char v19 = *(unsigned __int8 **)a3;
  }
  int v20 = (void *)v14[8];
  while (1)
  {
    uint64_t v21 = *v20;
    uint64_t v22 = *(unsigned __int8 *)(*v20 + 71);
    uint64_t v23 = (v22 & 0x80u) == 0 ? *(unsigned __int8 *)(*v20 + 71) : *(void *)(*v20 + 56);
    if (v23 == v18)
    {
      uint64_t v24 = (const void **)(v21 + 48);
      if ((v22 & 0x80) == 0)
      {
        if (!*(unsigned char *)(*v20 + 71)) {
          break;
        }
        long long v25 = v19;
        while (*(unsigned __int8 *)v24 == *v25)
        {
          uint64_t v24 = (const void **)((char *)v24 + 1);
          ++v25;
          if (!--v22) {
            goto LABEL_33;
          }
        }
        goto LABEL_31;
      }
      if (!memcmp(*v24, v19, *(void *)(*v20 + 56))) {
        break;
      }
    }
LABEL_31:
    v20 += 2;
    if (v20 == v16)
    {
      uint64_t v26 = 0;
LABEL_37:
      if (v15 == v16) {
        goto LABEL_61;
      }
      char v27 = a3[23];
      if (v27 >= 0) {
        uint64_t v28 = a3[23];
      }
      else {
        uint64_t v28 = *((void *)a3 + 1);
      }
      if (v27 < 0) {
        a3 = *(unsigned char **)a3;
      }
      while (1)
      {
        uint64_t v29 = *v15;
        if (*(unsigned char *)(*v15 + 272))
        {
          uint64_t v30 = *(unsigned __int8 *)(v29 + 271);
          uint64_t v31 = (v30 & 0x80u) == 0 ? *(unsigned __int8 *)(v29 + 271) : *(void *)(v29 + 256);
          if (v31 == v28)
          {
            char v32 = (const void **)(v29 + 248);
            if ((v30 & 0x80) != 0)
            {
              if (!memcmp(*v32, a3, *(void *)(v29 + 256)))
              {
LABEL_57:
                uint64_t v34 = v15[1];
                if (v34) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
                }
                *a4 = v29;
                a4[1] = v34;
                if (v26) {
                  sub_10004D2C8(v26);
                }
                goto LABEL_61;
              }
            }
            else
            {
              if (!*(unsigned char *)(v29 + 271)) {
                goto LABEL_57;
              }
              unsigned int v33 = a3;
              while (*(unsigned __int8 *)v32 == *v33)
              {
                char v32 = (const void **)((char *)v32 + 1);
                ++v33;
                if (!--v30) {
                  goto LABEL_57;
                }
              }
            }
          }
        }
        v15 += 2;
        if (v15 == v16) {
          goto LABEL_61;
        }
      }
    }
  }
LABEL_33:
  uint64_t v26 = (std::__shared_weak_count *)v20[1];
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *a4 = v21;
  a4[1] = v26;
  if (!v21)
  {
    uint64_t v15 = (void *)v14[8];
    uint64_t v16 = (void *)v14[9];
    goto LABEL_37;
  }
LABEL_61:

  std::mutex::unlock((std::mutex *)v14);
}

void sub_100BBF3A8(uint64_t a1@<X0>, int a2@<W1>, void **a3@<X8>)
{
  uint64_t v5 = *(uint64_t **)(a1 + 272);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = (uint64_t *)(a1 + 272);
  unsigned int v7 = v6;
  uint64_t v8 = v5;
  do
  {
    int v9 = *((_DWORD *)v8 + 8);
    BOOL v10 = v9 < a2;
    if (v9 >= a2) {
      int v11 = (uint64_t **)v8;
    }
    else {
      int v11 = (uint64_t **)(v8 + 1);
    }
    if (!v10) {
      unsigned int v7 = v8;
    }
    uint64_t v8 = *v11;
  }
  while (*v11);
  if (v7 != v6 && *((_DWORD *)v7 + 8) <= a2)
  {
    BOOL v12 = (std::mutex *)sub_1000389F8(v5, a2);
    sub_100BBE9D4(&v23, v12);
    uint64_t v14 = v23;
    uint64_t v13 = v24;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    v25[0] = a3;
    int64_t v15 = v13 - v14;
    if (v13 != v14)
    {
      v25[1] = 0;
      if (v15 < 0) {
        sub_10006A748();
      }
      uint64_t v16 = (char *)operator new(v13 - v14);
      *a3 = v16;
      a3[2] = &v16[16 * (v15 >> 4)];
      bzero(v16, v15);
      unint64_t v17 = 0;
      a3[1] = &v16[v15];
      do
      {
        uint64_t v18 = (char *)*a3;
        long long v19 = *(_OWORD *)(v14 + 16 * v17);
        uint64_t v20 = *(void *)(v14 + 16 * v17 + 8);
        if (v20) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v21 = &v18[16 * v17];
        uint64_t v22 = (std::__shared_weak_count *)*((void *)v21 + 1);
        *(_OWORD *)uint64_t v21 = v19;
        if (v22) {
          sub_10004D2C8(v22);
        }
        ++v17;
        uint64_t v14 = v23;
      }
      while (v17 < (v24 - v23) >> 4);
    }
    v25[0] = (void **)&v23;
    sub_10005CBF0(v25);
  }
  else
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
}

void sub_100BBF4F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a10;
  sub_10005CBF0(&a13);
  _Unwind_Resume(a1);
}

void *sub_100BBF514(uint64_t a1, uint64_t a2, void *a3)
{
  BOOL result = (void *)a3[3];
  if (result)
  {
    if (result == a3)
    {
      unsigned int v7 = v6;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v6);
    }
    else
    {
      unsigned int v7 = (void *)(*(uint64_t (**)(void *))(*result + 16))(result);
    }
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
    if (v5)
    {
      if (std::__shared_weak_count::lock(v5)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_100BBF70C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100BBF728(int a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(char *)(a2 + 71);
  uint64_t v4 = *(void *)(a2 + 56);
  if (v3 >= 0) {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 71);
  }
  uint64_t v5 = *(unsigned __int8 *)(a3 + 71);
  int v6 = (char)v5;
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a3 + 56);
  }
  if (v4 != v5) {
    return 0;
  }
  if (v3 >= 0) {
    BOOL v10 = (const char *)(a2 + 48);
  }
  else {
    BOOL v10 = *(const char **)(a2 + 48);
  }
  if (v6 >= 0) {
    int v11 = (const char *)(a3 + 48);
  }
  else {
    int v11 = *(const char **)(a3 + 48);
  }
  BOOL v13 = strcasecmp(v10, v11) == 0;
  BOOL result = v13;
  BOOL v13 = !v13 || a1 == 0;
  if (!v13) {
    return *(_DWORD *)(a2 + 148) == *(_DWORD *)(a3 + 148);
  }
  return result;
}

void sub_100BBF7D4()
{
}

void sub_100BBF948(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1006C59A4((void **)va);
  if (a3) {
    sub_10004D2C8(a3);
  }
  _Unwind_Resume(a1);
}

void sub_100BBF970(uint64_t a1)
{
  void (***v50)(unsigned char *__return_ptr, void, uint64_t);
  char v51;
  NSObject *v52;
  void *v53;
  NSObject *v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  void *v60;
  void *v61;
  NSObject *v62;
  void *v63;
  NSObject *v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t *v67;
  NSObject *v68;
  uint64_t *v69;
  int v70;
  int v71;
  uint64_t v72;
  int v73;
  void *v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  void *__p;
  char v80;
  void *v81;
  std::__shared_weak_count *v82;
  char v83;
  unsigned char buf[34];
  uint64_t v85;
  __int16 v86;
  uint64_t v87;

  uint64_t v1 = (os_log_t *)(a1 + 40);
  char v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ---------------DarwinPDPConfig:------------", buf, 2u);
    char v2 = *v1;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = (void *)(a1 + 336);
    if (*(char *)(a1 + 359) < 0) {
      int v3 = (void *)*v3;
    }
    uint64_t v4 = (void *)(a1 + 360);
    if (*(char *)(a1 + 383) < 0) {
      uint64_t v4 = (void *)*v4;
    }
    int v5 = *(_DWORD *)(a1 + 384);
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v4;
    *(_WORD *)&unsigned char buf[22] = 1024;
    *(_DWORD *)&uint8_t buf[24] = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fPrimaryDnsOverride: %s, fSecondaryDnsOverride: %s, fDNSNotificationHandlerToken: %d", buf, 0x1Cu);
  }
  int v6 = *(void **)(a1 + 312);
  unsigned int v7 = (void *)(a1 + 320);
  if (v6 != (void *)(a1 + 320))
  {
    do
    {
      uint64_t v8 = sub_1000389F8(*(uint64_t **)(a1 + 272), *((_DWORD *)v6 + 7));
      std::mutex::lock((std::mutex *)v8);
      uint64_t v10 = v8[8];
      uint64_t v9 = v8[9];
      std::mutex::unlock((std::mutex *)v8);
      int v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t Sim %s:", buf, 0xCu);
        int v11 = *v1;
      }
      unint64_t v13 = (v9 - v10) >> 4;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        WirelessTechnologyList::asString((uint64_t *)&v81, (WirelessTechnologyList *)(v6 + 4));
        unint64_t v76 = v10;
        uint64_t v77 = (v9 - v10) >> 4;
        uint64_t v14 = v9;
        int64_t v15 = v7;
        if (v83 >= 0) {
          uint64_t v16 = &v81;
        }
        else {
          uint64_t v16 = v81;
        }
        WirelessTechnologyAsString();
        if (v80 >= 0) {
          p_p = &__p;
        }
        else {
          p_p = __p;
        }
        uint64_t v18 = asStringBool(*((unsigned char *)v6 + 40));
        uint64_t v19 = asStringBool(*((unsigned char *)v6 + 41));
        *(_DWORD *)long long buf = 134219010;
        *(void *)&uint8_t buf[4] = v77;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v16;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = p_p;
        *(_WORD *)&uint8_t buf[32] = 2080;
        unint64_t v85 = v18;
        dispatch_object_t v86 = 2080;
        dispatch_object_t v87 = v19;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t %lu APN(s) found, fCompatibleTechnologies: %s, fCurrentTechnology: %s, fIsCorporateInternetAPN: %s, fAllowsDupApnNames: %s", buf, 0x34u);
        if (v80 < 0) {
          operator delete(__p);
        }
        unsigned int v7 = v15;
        uint64_t v9 = v14;
        if (v83 < 0) {
          operator delete(v81);
        }
        uint64_t v10 = v76;
        unint64_t v13 = v77;
      }
      if (v9 != v10)
      {
        unint64_t v20 = 0;
        if (v13 <= 1) {
          uint64_t v21 = 1;
        }
        else {
          uint64_t v21 = v13;
        }
        do
        {
          uint64_t v22 = *v1;
          if (os_log_type_enabled(*v1, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 134217984;
            *(void *)&uint8_t buf[4] = v20;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t APNx%zu:", buf, 0xCu);
          }
          sub_100BBEB78(buf, (std::mutex *)v8, v20);
          sub_100C97150(*(uint64_t *)buf, v1);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          ++v20;
        }
        while (v21 != v20);
      }
      uint64_t v23 = (void *)v6[1];
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          uint64_t v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          uint64_t v24 = (void *)v6[2];
          BOOL v25 = *v24 == (void)v6;
          int v6 = v24;
        }
        while (!v25);
      }
      int v6 = v24;
    }
    while (v24 != v7);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)a1, *(Registry **)(a1 + 56));
  char v27 = ServiceMap;
  if (v28 < 0)
  {
    uint64_t v29 = (unsigned __int8 *)(v28 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v30 = 5381;
    do
    {
      uint64_t v28 = v30;
      unsigned int v31 = *v29++;
      uint64_t v30 = (33 * v30) ^ v31;
    }
    while (v31);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v28;
  char v32 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)buf);
  if (!v32)
  {
    uint64_t v34 = 0;
LABEL_47:
    std::mutex::unlock(v27);
    unsigned int v33 = 0;
    char v35 = 1;
    if (!v34) {
      goto LABEL_49;
    }
    goto LABEL_48;
  }
  uint64_t v34 = v32[3];
  unsigned int v33 = (std::__shared_weak_count *)v32[4];
  if (!v33) {
    goto LABEL_47;
  }
  atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v27);
  atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v33);
  char v35 = 0;
  if (v34) {
LABEL_48:
  }
    (*(void (**)(uint64_t))(*(void *)v34 + 40))(v34);
LABEL_49:
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v33);
  }
  int v36 = *(uint64_t **)(a1 + 248);
  uint64_t v37 = *v36;
  uint64_t v38 = v36[1];
  CFTypeID v39 = *(NSObject **)(a1 + 40);
  BOOL v40 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
  if (v37 == v38)
  {
    if (v40)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t no cloud apns", buf, 2u);
    }
  }
  else
  {
    if (v40)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t from cloud:", buf, 2u);
      uint64_t v41 = *(uint64_t **)(a1 + 248);
      uint64_t v37 = *v41;
      uint64_t v38 = v41[1];
    }
    if (v37 != v38)
    {
      while (*(unsigned char *)(*(void *)v37 + 49) != 1)
      {
LABEL_73:
        v37 += 16;
        if (v37 == v38) {
          goto LABEL_77;
        }
      }
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      uint64_t v42 = (std::mutex *)Registry::getServiceMap((uint64_t *)a1, *(Registry **)(a1 + 56));
      uint64_t v43 = v42;
      if (v44 < 0)
      {
        int v45 = (unsigned __int8 *)(v44 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v46 = 5381;
        do
        {
          uint64_t v44 = v46;
          unsigned int v47 = *v45++;
          uint64_t v46 = (33 * v46) ^ v47;
        }
        while (v47);
      }
      std::mutex::lock(v42);
      signed int v81 = (void *)v44;
      char v48 = sub_10004D37C(&v43[1].__m_.__sig, (unint64_t *)&v81);
      if (v48)
      {
        __int16 v50 = (void (***)(unsigned char *__return_ptr, void, uint64_t))v48[3];
        std::string v49 = (std::__shared_weak_count *)v48[4];
        if (v49)
        {
          atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v43);
          atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v49);
          uint64_t v51 = 0;
LABEL_64:
          (**v50)(buf, v50, *(void *)v37 + 24);
          if ((v51 & 1) == 0) {
            sub_10004D2C8(v49);
          }
          if (*(void *)buf)
          {
            signed int v81 = 0;
            BOOL v82 = 0;
            (*(void (**)(void **__return_ptr))(**(void **)buf + 128))(&v81);
            if (v81) {
              sub_100C97150((uint64_t)v81, v1);
            }
            if (v82) {
              sub_10004D2C8(v82);
            }
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          goto LABEL_73;
        }
      }
      else
      {
        __int16 v50 = 0;
      }
      std::mutex::unlock(v43);
      std::string v49 = 0;
      uint64_t v51 = 1;
      goto LABEL_64;
    }
  }
LABEL_77:
  if (*(void *)(a1 + 408))
  {
    int v52 = *v1;
    if (os_log_type_enabled(*v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fIPCContextConfigInfo:", buf, 2u);
    }
    uint64_t v53 = *(void **)(a1 + 392);
    if (v53 != (void *)(a1 + 400))
    {
      do
      {
        unsigned int v54 = *v1;
        if (os_log_type_enabled(*v1, OS_LOG_TYPE_DEFAULT))
        {
          int v55 = *((_DWORD *)v53 + 7);
          uint64_t v56 = *((_DWORD *)v53 + 8);
          int v57 = *((_DWORD *)v53 + 9);
          char v58 = *((_DWORD *)v53 + 10);
          CFTypeID v59 = *((_DWORD *)v53 + 11);
          *(_DWORD *)long long buf = 67110144;
          *(_DWORD *)&uint8_t buf[4] = v55;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v56;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&uint8_t buf[16] = v57;
          *(_WORD *)&buf[20] = 1024;
          *(_DWORD *)&unsigned char buf[22] = v58;
          *(_WORD *)&buf[26] = 1024;
          *(_DWORD *)&buf[28] = v59;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t id=%u c.id=%u maxInterfaces=%u maxUlPipes=%u maxDlPipes=%u ", buf, 0x20u);
        }
        CFBooleanRef v60 = (void *)v53[1];
        if (v60)
        {
          do
          {
            char v61 = v60;
            CFBooleanRef v60 = (void *)*v60;
          }
          while (v60);
        }
        else
        {
          do
          {
            char v61 = (void *)v53[2];
            BOOL v25 = *v61 == (void)v53;
            uint64_t v53 = v61;
          }
          while (!v25);
        }
        uint64_t v53 = v61;
      }
      while (v61 != (void *)(a1 + 400));
    }
  }
  if (*(void *)(a1 + 432))
  {
    uint64_t v62 = *v1;
    if (os_log_type_enabled(*v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fIPCConfigSetInfo:", buf, 2u);
    }
    uint64_t v63 = *(void **)(a1 + 416);
    if (v63 != (void *)(a1 + 424))
    {
      do
      {
        uint64_t v64 = *v1;
        if (os_log_type_enabled(*v1, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v65 = subscriber::asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v65;
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t simSlot=%s", buf, 0xCu);
        }
        int v67 = (uint64_t *)v63[5];
        unsigned int v66 = (uint64_t *)v63[6];
        while (v67 != v66)
        {
          uint64_t v68 = *v1;
          if (os_log_type_enabled(*v1, OS_LOG_TYPE_DEFAULT))
          {
            int v69 = v67;
            if (*((char *)v67 + 23) < 0) {
              int v69 = (uint64_t *)*v67;
            }
            int v70 = *((_DWORD *)v67 + 6);
            uint64_t v71 = *((_DWORD *)v67 + 7);
            unint64_t v72 = v67[4];
            BOOL v73 = *((_DWORD *)v67 + 10);
            *(_DWORD *)long long buf = 136316162;
            *(void *)&uint8_t buf[4] = v69;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v70;
            *(_WORD *)&unsigned char buf[18] = 1024;
            *(_DWORD *)&buf[20] = v71;
            *(_WORD *)&uint8_t buf[24] = 2048;
            *(void *)&buf[26] = v72;
            LOWORD(v85) = 1024;
            *(_DWORD *)((char *)&v85 + 2) = v73;
            _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t\t name=%s dataPath=%u trafficType=%u serviceMask=%llu maxQueueSets=%u ", buf, 0x28u);
          }
          v67 += 6;
        }
        uint64_t v74 = (void *)v63[1];
        if (v74)
        {
          do
          {
            unint64_t v75 = v74;
            uint64_t v74 = (void *)*v74;
          }
          while (v74);
        }
        else
        {
          do
          {
            unint64_t v75 = (void *)v63[2];
            BOOL v25 = *v75 == (void)v63;
            uint64_t v63 = v75;
          }
          while (!v25);
        }
        uint64_t v63 = v75;
      }
      while (v75 != (void *)(a1 + 424));
    }
  }
}

void sub_100BC02C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34)
{
  if ((v34 & 1) == 0) {
    sub_10004D2C8(v35);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100BC0368(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 272);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 272;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      int v6 = (uint64_t *)v2;
    }
    else {
      int v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 == a1 + 272 || *(_DWORD *)(v3 + 32) > a2) {
    return 0;
  }
  uint64_t v8 = *(uint64_t **)(a1 + 320);
  if (!v8) {
LABEL_19:
  }
    sub_1000C14F0("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      int v9 = *((_DWORD *)v8 + 7);
      if (v9 <= a2) {
        break;
      }
      uint64_t v8 = (uint64_t *)*v8;
      if (!v8) {
        goto LABEL_19;
      }
    }
    if (v9 >= a2) {
      return *((unsigned char *)v8 + 40) != 0;
    }
    uint64_t v8 = (uint64_t *)v8[1];
    if (!v8) {
      goto LABEL_19;
    }
  }
}

uint64_t sub_100BC0408@<X0>(Registry *a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1);
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    BOOL v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v13);
  if (v8)
  {
    uint64_t v9 = v8[3];
    uint64_t v10 = (std::__shared_weak_count *)v8[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v11 = 0;
      if (!v9) {
        goto LABEL_7;
      }
LABEL_11:
      LODWORD(v3) = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 760))(v9);
      if (v11) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v10 = 0;
  char v11 = 1;
  if (v9) {
    goto LABEL_11;
  }
LABEL_7:
  if ((v11 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v10);
LABEL_13:
  if (v9) {
    return v3;
  }
  else {
    return 1;
  }
}

void sub_100BC0524(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BC0540(uint64_t a1, uint64_t a2, int a3)
{
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 56));
  unsigned int v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unint64_t v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v14 + 96))(v65, v14, a2, 1, @"MTU", 0, 0);
  sub_100044D6C(&cf, (CFTypeRef *)v65);
  sub_1000577C4((const void **)v65);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  CFArrayRef v16 = (const __CFArray *)cf;
  if (cf) {
    unint64_t v17 = sub_100083F10;
  }
  else {
    unint64_t v17 = 0;
  }
  if (v17)
  {
    CFArrayRef theArray = (CFArrayRef)cf;
    if (cf)
    {
      CFRetain(cf);
      CFArrayRef v16 = theArray;
    }
    unsigned int v68 = 0;
    CFIndex Count = CFArrayGetCount(v16);
    if (Count >= 1)
    {
      int v58 = 0;
      int v59 = a3;
      CFIndex v19 = 0;
      while (1)
      {
        int valuePtr = 0;
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v19);
        CFDictionaryRef v21 = ValueAtIndex;
        if (ValueAtIndex && (CFTypeID v22 = CFGetTypeID(ValueAtIndex), v22 == CFDictionaryGetTypeID()))
        {
          if (CFDictionaryContainsKey(v21, @"size") && CFDictionaryContainsKey(v21, @"technology-mask"))
          {
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v21, @"technology-mask");
            CFNumberRef v24 = Value;
            if (Value)
            {
              CFTypeID v25 = CFGetTypeID(Value);
              if (v25 != CFNumberGetTypeID()) {
                CFNumberRef v24 = 0;
              }
            }
            CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(v21, @"size");
            CFNumberRef v27 = v26;
            if (v26)
            {
              CFTypeID v28 = CFGetTypeID(v26);
              CFTypeID TypeID = CFNumberGetTypeID();
              if (v24)
              {
                if (v28 == TypeID)
                {
                  if (!CFNumberGetValue(v24, kCFNumberIntType, &valuePtr))
                  {
                    uint64_t v43 = *(NSObject **)(a1 + 40);
                    if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_48;
                    }
                    *(_DWORD *)long long buf = 134217984;
                    *(void *)&uint8_t buf[4] = v19;
                    uint64_t v38 = v43;
                    CFTypeID v39 = "#I Item %lu couldn't retrieve from kCFTechMaskKey, continuing to next item!";
                    goto LABEL_46;
                  }
                  if (!valuePtr)
                  {
                    uint64_t v44 = *(NSObject **)(a1 + 40);
                    if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_48;
                    }
                    *(_DWORD *)long long buf = 134218240;
                    *(void *)&uint8_t buf[4] = v19;
                    *(_WORD *)&unsigned char buf[12] = 1024;
                    *(_DWORD *)&buf[14] = 0;
                    uint64_t v38 = v44;
                    CFTypeID v39 = "#I Item %lu kCFTechMaskKey has mask = %u, continuing to next item!";
                    uint32_t v42 = 18;
                    goto LABEL_47;
                  }
                  v58 |= (valuePtr & 0x10) >> 4;
                  if (v59 == 13)
                  {
                    if ((valuePtr & 4) == 0) {
                      goto LABEL_33;
                    }
LABEL_62:
                    int v47 = CFNumberGetValue(v27, kCFNumberIntType, &v68);
                    char v48 = *(NSObject **)(a1 + 40);
                    BOOL v49 = os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT);
                    if (!v47)
                    {
                      if (!v49) {
                        goto LABEL_48;
                      }
                      *(_WORD *)long long buf = 0;
                      uint64_t v38 = v48;
                      CFTypeID v39 = "#E MTU fetching from carrier bundle was a error continuing to next item!";
                      uint32_t v42 = 2;
                      goto LABEL_47;
                    }
                    if (v49)
                    {
                      unsigned int v57 = v68;
                      int v64 = asWirelessTechnology();
                      WirelessTechnologyList::asString((uint64_t *)v65, (WirelessTechnologyList *)&v64);
                      if (v66 >= 0) {
                        __int16 v50 = v65;
                      }
                      else {
                        __int16 v50 = (void **)v65[0];
                      }
                      uint64_t v51 = asString();
                      sub_100C93840(valuePtr, __p);
                      int v52 = __p;
                      if (v63 < 0) {
                        int v52 = (void **)__p[0];
                      }
                      *(_DWORD *)long long buf = 67109890;
                      *(_DWORD *)&uint8_t buf[4] = v57;
                      *(_WORD *)&uint8_t buf[8] = 2082;
                      *(void *)&buf[10] = v50;
                      *(_WORD *)&unsigned char buf[18] = 2082;
                      *(void *)&buf[20] = v51;
                      *(_WORD *)&buf[28] = 2082;
                      *(void *)&buf[30] = v52;
                      char v34 = v48;
                      char v35 = "#I MTU size %d found for wireless technology %{public}s (data mode:%{public}s). CB mask %{public}s";
                      uint32_t v36 = 38;
                      goto LABEL_70;
                    }
                    goto LABEL_48;
                  }
                  int v45 = 4 * (valuePtr & 3);
                  if ((valuePtr & 8) != 0)
                  {
                    if (v58)
                    {
                      v45 |= 0x20u;
                      goto LABEL_57;
                    }
                    int v46 = v45 | 0xE0;
                  }
                  else
                  {
LABEL_57:
                    if ((valuePtr & 0x10) != 0) {
                      int v46 = v45 | 0xC0;
                    }
                    else {
                      int v46 = v45;
                    }
                  }
                  if ((asWirelessTechnology() & v46) == 0)
                  {
LABEL_33:
                    uint64_t v30 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
                    {
                      int v64 = asWirelessTechnology();
                      WirelessTechnologyList::asString((uint64_t *)v65, (WirelessTechnologyList *)&v64);
                      if (v66 >= 0) {
                        unsigned int v31 = v65;
                      }
                      else {
                        unsigned int v31 = (void **)v65[0];
                      }
                      uint64_t v32 = asString();
                      sub_100C93840(valuePtr, __p);
                      unsigned int v33 = __p;
                      if (v63 < 0) {
                        unsigned int v33 = (void **)__p[0];
                      }
                      *(_DWORD *)long long buf = 136446722;
                      *(void *)&uint8_t buf[4] = v31;
                      *(_WORD *)&unsigned char buf[12] = 2082;
                      *(void *)&buf[14] = v32;
                      *(_WORD *)&unsigned char buf[22] = 2082;
                      *(void *)&uint8_t buf[24] = v33;
                      char v34 = v30;
                      char v35 = "#I The current technology %{public}s (data mode:%{public}s) is not in the CB MTU mask %{publ"
                            "ic}s , continuing to next item!";
                      uint32_t v36 = 32;
LABEL_70:
                      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v35, buf, v36);
                      if (v63 < 0) {
                        operator delete(__p[0]);
                      }
                      if (v66 < 0) {
                        operator delete(v65[0]);
                      }
                      goto LABEL_48;
                    }
                    goto LABEL_48;
                  }
                  goto LABEL_62;
                }
              }
            }
            uint64_t v41 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 134217984;
              *(void *)&uint8_t buf[4] = v19;
              uint64_t v38 = v41;
              CFTypeID v39 = "#I Item %lu doesn't have keys kCFMTUSizeKey and kCFTechMaskKey properly formatted, continuing to next item!";
              goto LABEL_46;
            }
          }
          else
          {
            BOOL v40 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 134217984;
              *(void *)&uint8_t buf[4] = v19;
              uint64_t v38 = v40;
              CFTypeID v39 = "#I Item %lu doesn't have keys kCFMTUSizeKey and kCFTechMaskKey , continuing to next item!";
              goto LABEL_46;
            }
          }
        }
        else
        {
          uint64_t v37 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 134217984;
            *(void *)&uint8_t buf[4] = v19;
            uint64_t v38 = v37;
            CFTypeID v39 = "#I Item %lu is not an dictionary, continuing to next item!";
LABEL_46:
            uint32_t v42 = 12;
LABEL_47:
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v39, buf, v42);
          }
        }
LABEL_48:
        if (Count == ++v19) {
          goto LABEL_80;
        }
      }
    }
    int v55 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I MTU value set has zero items, using default value!", buf, 2u);
    }
LABEL_80:
    uint64_t v54 = v68;
    sub_100044D00((const void **)&theArray);
  }
  else
  {
    uint64_t v53 = *(NSObject **)(a1 + 40);
    uint64_t v54 = 0;
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I No MTU value set in carrier plist, using default value!", buf, 2u);
      uint64_t v54 = 0;
    }
  }
  sub_100044D00(&cf);
  return v54;
}

void sub_100BC0C30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,const void *a21,const void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  sub_100044D00(&a21);
  sub_100044D00(&a22);
  _Unwind_Resume(a1);
}

void sub_100BC0CAC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a3 || !a5 || !*(void *)a4) {
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(uint64_t **)a4, *(Registry **)(a1 + 56));
  uint64_t v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v34 = v11;
  char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v34);
  if (!v15)
  {
    std::mutex::unlock(v10);
    return;
  }
  uint64_t v17 = v15[3];
  CFArrayRef v16 = (std::__shared_weak_count *)v15[4];
  if (v16)
  {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v10);
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v16);
    if (!v17)
    {
LABEL_35:
      sub_10004D2C8(v16);
      return;
    }
  }
  else
  {
    std::mutex::unlock(v10);
    if (!v17) {
      return;
    }
  }
  unint64_t v34 = 0;
  char v35 = 0;
  sub_100BBB920(v17, &v34);
  unint64_t v18 = v34;
  if (v34)
  {
    CFIndex v19 = *(std::__shared_weak_count **)(a4 + 8);
    uint64_t v32 = *(uint64_t **)a4;
    unsigned int v33 = v19;
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v21 = (*(uint64_t (**)(unint64_t, uint64_t **, uint64_t))(*(void *)v18 + 88))(v18, &v32, a5);
    if (v33) {
      sub_10004D2C8(v33);
    }
    if (v21)
    {
      CFTypeID v22 = (std::mutex *)Registry::getServiceMap(v20, *(Registry **)(a1 + 56));
      uint64_t v23 = v22;
      if ((v24 & 0x8000000000000000) != 0)
      {
        CFTypeID v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v26 = 5381;
        do
        {
          unint64_t v24 = v26;
          unsigned int v27 = *v25++;
          uint64_t v26 = (33 * v26) ^ v27;
        }
        while (v27);
      }
      std::mutex::lock(v22);
      unint64_t v36 = v24;
      CFTypeID v28 = sub_10004D37C(&v23[1].__m_.__sig, &v36);
      if (v28)
      {
        uint64_t v30 = v28[3];
        uint64_t v29 = (std::__shared_weak_count *)v28[4];
        if (v29)
        {
          atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v23);
          atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v29);
          char v31 = 0;
LABEL_28:
          if (v30) {
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v30 + 640))(v30, a2, 21, 0xFFFFFFFFLL, 0);
          }
          if ((v31 & 1) == 0) {
            sub_10004D2C8(v29);
          }
          goto LABEL_32;
        }
      }
      else
      {
        uint64_t v30 = 0;
      }
      std::mutex::unlock(v23);
      uint64_t v29 = 0;
      char v31 = 1;
      goto LABEL_28;
    }
  }
LABEL_32:
  if (v35) {
    sub_10004D2C8(v35);
  }
  if (v16) {
    goto LABEL_35;
  }
}

void sub_100BC0F24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BC0F7C(uint64_t a1@<X0>, int a2@<W2>, uint64_t *a3@<X8>)
{
  if (a2)
  {
    *a3 = 0;
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 56));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_13:
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_9;
    }
LABEL_14:
    *(void *)long long buf = 0;
    unint64_t v20 = 0;
    sub_10022EDC4(v13, buf);
    uint64_t v16 = *(void *)buf;
    if (*(void *)buf)
    {
      *a3 = 0;
      (*(void (**)(uint64_t))(*(void *)v16 + 88))(v16);
    }
    else
    {
      uint64_t v17 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unint64_t v18 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Error getting UI apn storage", v18, 2u);
      }
      *a3 = 0;
    }
    if (v20) {
      sub_10004D2C8(v20);
    }
    goto LABEL_21;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (v13) {
    goto LABEL_14;
  }
LABEL_9:
  char v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Cannot get apn storage manager", buf, 2u);
  }
  *a3 = 0;
LABEL_21:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_100BC115C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BC118C(uint64_t a1@<X0>, int a2@<W2>, uint64_t *a3@<X8>)
{
  if (a2)
  {
    *a3 = 0;
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 56));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_13:
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_9;
    }
LABEL_14:
    *(void *)long long buf = 0;
    unint64_t v20 = 0;
    sub_10022EDC4(v13, buf);
    uint64_t v16 = *(void *)buf;
    if (*(void *)buf)
    {
      *a3 = 0;
      (*(void (**)(uint64_t))(*(void *)v16 + 80))(v16);
    }
    else
    {
      uint64_t v17 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unint64_t v18 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Error getting UI apn storage", v18, 2u);
      }
      *a3 = 0;
    }
    if (v20) {
      sub_10004D2C8(v20);
    }
    goto LABEL_21;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (v13) {
    goto LABEL_14;
  }
LABEL_9:
  char v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Cannot get apn storage manager", buf, 2u);
  }
  *a3 = 0;
LABEL_21:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_100BC136C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BC139C(capabilities::ct *a1)
{
  uint64_t v1 = a1;
  char v2 = (ApplePDPHelperInterface *)capabilities::ct::supportsIPCInterfaceConfig(a1);
  if (!v2) {
    return;
  }
  if (!ApplePDPHelperInterface::getInstance(v2))
  {
    unint64_t v24 = *((void *)v1 + 5);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "updateIpcConfiguration_sync";
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%s: NO AppleIPAppender INSTANCE", buf, 0xCu);
    }
    return;
  }
  *(void *)&uint8_t buf[8] = 0;
  *(void *)&uint8_t buf[16] = 0;
  *(void *)long long buf = &buf[8];
  uint64_t v3 = *((void *)v1 + 8);
  *(void *)CFArrayRef theArray = *((void *)v1 + 7);
  *(void *)&theArray[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (*(void *)&theArray[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&theArray[8]);
  }
  uint64_t v4 = __p[0].i64[1];
  BOOL v5 = (unsigned int *)__p[0].i64[0];
  if (__p[0].i64[0] != __p[0].i64[1])
  {
    uint64_t v6 = (uint64_t (*)(void))__p[1].i64[0];
    while (1)
    {
      uint64_t v7 = ((uint64_t (*)(void))__p[1].i64[0])(*v5);
      if (v7) {
        break;
      }
      if (++v5 == (unsigned int *)__p[0].i64[1])
      {
        BOOL v5 = (unsigned int *)__p[0].i64[1];
        break;
      }
    }
    uint64_t v8 = __p[0].i64[1];
    while (v5 != (unsigned int *)v8)
    {
      if ((unint64_t)capabilities::ct::supportedPDPContextCount((capabilities::ct *)v7) >> 32) {
        __assert_rtn("defaultSimIpcContextConfig", "DarwinPDPConfig.cpp", 1336, "capabilities::ct::supportedPDPContextCount() <= std::numeric_limits<unsigned>::max()");
      }
      uint64_t v9 = (capabilities::ct *)subscriber::simSlotAsInstance();
      int v10 = (int)v9;
      uint64_t v7 = capabilities::ct::supportedPDPContextCount(v9);
      uint64_t v11 = (v10 + 1);
      *(void *)CFArrayRef theArray = v11 | (v7 << 32);
      *(void *)&theArray[8] = 0x1B00000010;
      if (v10 != -1)
      {
        uint64_t v7 = (uint64_t)sub_100BC7C8C((uint64_t **)buf, v11, theArray);
        *(_OWORD *)(v7 + 32) = *(_OWORD *)theArray;
      }
      uint64_t v12 = v5 + 1;
      BOOL v5 = (unsigned int *)v4;
      if (v12 != (unsigned int *)v4)
      {
        BOOL v5 = v12;
        while (1)
        {
          uint64_t v7 = v6(*v5);
          if (v7) {
            break;
          }
          if (++v5 == (unsigned int *)v4)
          {
            BOOL v5 = (unsigned int *)v4;
            break;
          }
        }
      }
    }
  }
  __p[0] = (int64x2_t)xmmword_101554170;
  char v13 = sub_100BC7C8C((uint64_t **)buf, 8u, __p);
  *((int64x2_t *)v13 + 2) = __p[0];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v14, *((Registry **)v1 + 7));
  uint64_t v16 = ServiceMap;
  if (v17 < 0)
  {
    unint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      uint64_t v17 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(ServiceMap);
  __p[0].i64[0] = v17;
  char v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)__p);
  v246 = v1;
  if (v21)
  {
    uint64_t v22 = v21[3];
    uint64_t v23 = (std::__shared_weak_count *)v21[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v16);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      if (!v22)
      {
LABEL_74:
        sub_10004D2C8(v23);
        goto LABEL_75;
      }
LABEL_33:
      v248 = v23;
      uint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 760))(v22);
      *(void *)CFArrayRef theArray = 0;
      unsigned int v27 = &qword_101B101B8;
      LOBYTE(v27) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B101B8, memory_order_acquire);
      if ((v27 & 1) == 0 && __cxa_guard_acquire(&qword_101B101B8))
      {
        __p[0].i64[0] = @"IPC";
        __p[0].i64[1] = @"IPCContext";
        sub_100367E88(qword_101B101C8, __p, 2uLL);
        __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B101C8, (void *)&_mh_execute_header);
        __cxa_guard_release(&qword_101B101B8);
      }
      CFTypeID v28 = (std::mutex *)Registry::getServiceMap(v27, *((Registry **)v1 + 7));
      uint64_t v29 = v28;
      if (v30 < 0)
      {
        char v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v32 = 5381;
        do
        {
          uint64_t v30 = v32;
          unsigned int v33 = *v31++;
          uint64_t v32 = (33 * v32) ^ v33;
        }
        while (v33);
      }
      std::mutex::lock(v28);
      __p[0].i64[0] = v30;
      unint64_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)__p);
      if (v34)
      {
        uint64_t v36 = v34[3];
        char v35 = (std::__shared_weak_count *)v34[4];
        if (v35)
        {
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v29);
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v35);
          char v37 = 0;
          goto LABEL_42;
        }
      }
      else
      {
        uint64_t v36 = 0;
      }
      std::mutex::unlock(v29);
      char v35 = 0;
      char v37 = 1;
LABEL_42:
      (*(void (**)(int64x2_t *__return_ptr, uint64_t, uint64_t, uint64_t, void *, void, void))(*(void *)v36 + 104))(&v250, v36, v26, 1, qword_101B101C8, 0, 0);
      sub_100044D6C(&theDict, (CFTypeRef *)&v250);
      __p[0].i64[0] = *(void *)theArray;
      *(void *)CFArrayRef theArray = theDict;
      CFDictionaryRef theDict = 0;
      sub_100044D00((const void **)__p);
      sub_100044D00((const void **)&theDict);
      sub_1000577C4((const void **)&v250);
      if ((v37 & 1) == 0) {
        sub_10004D2C8(v35);
      }
      if (*(void *)theArray) {
        uint64_t v38 = sub_100083F10;
      }
      else {
        uint64_t v38 = 0;
      }
      if (v38)
      {
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)theArray);
        if (Count >= 1)
        {
          for (CFIndex i = 0; i != Count; ++i)
          {
            CFDictionaryRef theDict = 0;
            __p[0].i64[0] = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)theArray, i);
            sub_10004EFE4(&theDict, (CFTypeRef *)__p);
            if (theDict) {
              uint64_t v41 = sub_100080778;
            }
            else {
              uint64_t v41 = 0;
            }
            if (v41)
            {
              __p[0] = 0uLL;
              CFNumberRef Value = (unsigned int *)CFDictionaryGetValue(theDict, @"Id");
              uint64_t v43 = Value;
              if (Value)
              {
                v250.i32[0] = 0;
                CFTypeID v44 = CFGetTypeID(Value);
                if (v44 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&v250, v43, v45);
                }
                LODWORD(v43) = v250.i32[0];
                __p[0].i32[0] = v250.i32[0];
              }
              int v46 = (unsigned int *)CFDictionaryGetValue(theDict, @"MaxInterfaces");
              int v47 = v46;
              if (v46)
              {
                v250.i32[0] = 0;
                CFTypeID v48 = CFGetTypeID(v46);
                if (v48 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&v250, v47, v49);
                }
                __p[0].i32[1] = v250.i32[0];
              }
              __int16 v50 = (unsigned int *)CFDictionaryGetValue(theDict, @"MaxUlPipes");
              uint64_t v51 = v50;
              if (v50)
              {
                v250.i32[0] = 0;
                CFTypeID v52 = CFGetTypeID(v50);
                if (v52 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&v250, v51, v53);
                }
                __p[0].i32[2] = v250.i32[0];
              }
              uint64_t v54 = (unsigned int *)CFDictionaryGetValue(theDict, @"MaxDlPipes");
              int v55 = v54;
              if (v54)
              {
                v250.i32[0] = 0;
                CFTypeID v56 = CFGetTypeID(v54);
                if (v56 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&v250, v55, v57);
                }
                __p[0].i32[3] = v250.i32[0];
              }
              if (v43)
              {
                int v58 = sub_100BC7C8C((uint64_t **)buf, v43, __p);
                *((int64x2_t *)v58 + 2) = __p[0];
              }
            }
            sub_100057D78((const void **)&theDict);
          }
        }
      }
      uint64_t v25 = (uint64_t)sub_100044D00((const void **)theArray);
      uint64_t v23 = v248;
      if (!v248) {
        goto LABEL_75;
      }
      goto LABEL_74;
    }
    std::mutex::unlock(v16);
    if (v22) {
      goto LABEL_33;
    }
  }
  else
  {
    std::mutex::unlock(v16);
  }
LABEL_75:
  int v59 = (uint64_t *)*((void *)v1 + 49);
  CFBooleanRef v60 = (uint64_t **)((char *)v1 + 400);
  if (v59 != (uint64_t *)((char *)v1 + 400))
  {
    do
    {
      uint64_t v61 = *(void *)&buf[8];
      unsigned __int32 v62 = *((_DWORD *)v59 + 7);
      if (!*(void *)&buf[8]) {
        goto LABEL_85;
      }
      char v63 = &buf[8];
      do
      {
        int v64 = (uint8_t *)v61;
        uint64_t v65 = v63;
        unsigned __int32 v66 = *(_DWORD *)(v61 + 28);
        int v67 = (uint8_t *)(v61 + 8);
        if (v66 >= v62)
        {
          int v67 = v64;
          char v63 = v64;
        }
        uint64_t v61 = *(void *)v67;
      }
      while (v61);
      if (v63 == &buf[8]) {
        goto LABEL_85;
      }
      if (v66 < v62) {
        int v64 = v65;
      }
      if (v62 < *((_DWORD *)v64 + 7))
      {
LABEL_85:
        *(uint64_t *)((char *)__p[0].i64 + 4) = 0;
        *(uint64_t *)((char *)&__p[0].i64[1] + 4) = 0;
        __p[0].i32[0] = v62;
        uint64_t Instance = ApplePDPHelperInterface::getInstance((ApplePDPHelperInterface *)v25);
        char v69 = (*(uint64_t (**)(uint64_t, int64x2_t *))(*(void *)Instance + 24))(Instance, __p);
        int v70 = *((void *)v1 + 5);
        if (v69)
        {
          uint64_t v25 = os_log_type_enabled(*((os_log_t *)v1 + 5), OS_LOG_TYPE_DEFAULT);
          if (v25)
          {
            int v71 = *((_DWORD *)v59 + 7);
            *(_DWORD *)CFArrayRef theArray = 136315394;
            *(void *)&theArray[4] = "updateIpcContextConfiguration_sync";
            *(_WORD *)&theArray[12] = 1024;
            *(_DWORD *)&theArray[14] = v71;
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I %s: Unconfigured ipcContext %u", theArray, 0x12u);
          }
        }
        else
        {
          uint64_t v25 = os_log_type_enabled(*((os_log_t *)v1 + 5), OS_LOG_TYPE_ERROR);
          if (v25)
          {
            int v75 = *((_DWORD *)v59 + 7);
            *(_DWORD *)CFArrayRef theArray = 136315394;
            *(void *)&theArray[4] = "updateIpcContextConfiguration_sync";
            *(_WORD *)&theArray[12] = 1024;
            *(_DWORD *)&theArray[14] = v75;
            _os_log_error_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "%s: Cannot unconfigure ipcContext %u", theArray, 0x12u);
          }
        }
      }
      unint64_t v72 = (uint64_t *)v59[1];
      if (v72)
      {
        do
        {
          BOOL v73 = (uint64_t **)v72;
          unint64_t v72 = (uint64_t *)*v72;
        }
        while (v72);
      }
      else
      {
        do
        {
          BOOL v73 = (uint64_t **)v59[2];
          BOOL v74 = *v73 == v59;
          int v59 = (uint64_t *)v73;
        }
        while (!v74);
      }
      int v59 = (uint64_t *)v73;
    }
    while (v73 != v60);
  }
  unint64_t v76 = *(uint8_t **)buf;
  if (*(uint8_t **)buf != &buf[8])
  {
    while (1)
    {
      uint64_t v77 = *v60;
      unsigned int v78 = *((_DWORD *)v76 + 7);
      if (!*v60) {
        goto LABEL_110;
      }
      int v79 = (uint64_t **)((char *)v1 + 400);
      do
      {
        unsigned int v80 = *((_DWORD *)v77 + 7);
        BOOL v81 = v80 >= v78;
        if (v80 >= v78) {
          BOOL v82 = v77;
        }
        else {
          BOOL v82 = v77 + 1;
        }
        if (v81) {
          int v79 = (uint64_t **)v77;
        }
        uint64_t v77 = (uint64_t *)*v82;
      }
      while (*v82);
      if (v79 == v60 || v78 < *((_DWORD *)v79 + 7)) {
        goto LABEL_110;
      }
      uint64_t v25 = IPCContextConfig::operator!=();
      if (v25) {
        break;
      }
LABEL_115:
      dispatch_object_t v87 = (uint8_t *)*((void *)v76 + 1);
      if (v87)
      {
        do
        {
          int v88 = v87;
          dispatch_object_t v87 = *(uint8_t **)v87;
        }
        while (v87);
      }
      else
      {
        do
        {
          int v88 = (uint8_t *)*((void *)v76 + 2);
          BOOL v74 = *(void *)v88 == (void)v76;
          unint64_t v76 = v88;
        }
        while (!v74);
      }
      unint64_t v76 = v88;
      if (v88 == &buf[8]) {
        goto LABEL_121;
      }
    }
    unsigned int v78 = *((_DWORD *)v76 + 7);
LABEL_110:
    __p[0].i64[0] = v78 | 0x100000000;
    __p[0].i64[1] = *(void *)(v76 + 36);
    __p[1].i32[0] = *((_DWORD *)v76 + 11);
    uint64_t v83 = ApplePDPHelperInterface::getInstance((ApplePDPHelperInterface *)v25);
    char v84 = (*(uint64_t (**)(uint64_t, int64x2_t *))(*(void *)v83 + 24))(v83, __p);
    unint64_t v85 = *((void *)v1 + 5);
    if (v84)
    {
      uint64_t v25 = os_log_type_enabled(*((os_log_t *)v1 + 5), OS_LOG_TYPE_DEFAULT);
      if (v25)
      {
        int v86 = *((_DWORD *)v76 + 7);
        *(_DWORD *)CFArrayRef theArray = 136315394;
        *(void *)&theArray[4] = "updateIpcContextConfiguration_sync";
        *(_WORD *)&theArray[12] = 1024;
        *(_DWORD *)&theArray[14] = v86;
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I %s: Configured ipcContext %u", theArray, 0x12u);
      }
    }
    else
    {
      uint64_t v25 = os_log_type_enabled(*((os_log_t *)v1 + 5), OS_LOG_TYPE_ERROR);
      if (v25)
      {
        int v89 = *((_DWORD *)v76 + 7);
        *(_DWORD *)CFArrayRef theArray = 136315394;
        *(void *)&theArray[4] = "updateIpcContextConfiguration_sync";
        *(_WORD *)&theArray[12] = 1024;
        *(_DWORD *)&theArray[14] = v89;
        _os_log_error_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_ERROR, "%s: Cannot configure ipcContext %u", theArray, 0x12u);
      }
    }
    goto LABEL_115;
  }
LABEL_121:
  uint64_t v90 = (uint64_t *)((char *)v1 + 392);
  if ((uint8_t *)((char *)v1 + 392) != buf)
  {
    unsigned int v91 = *(uint8_t **)buf;
    if (*((void *)v1 + 51)
      && ((v92 = *v90, *uint64_t v90 = (uint64_t)v60,
                       (*v60)[2] = 0,
                       *CFBooleanRef v60 = 0,
                       *((void *)v1 + 51) = 0,
                       *(void *)(v92 + 8))
        ? (uint64_t v93 = *(void *)(v92 + 8))
        : (uint64_t v93 = v92),
          v93))
    {
      uint64_t v94 = sub_1000EA590(v93);
      if (v91 == &buf[8])
      {
        char v95 = (void *)v93;
        uint64_t v101 = &buf[8];
      }
      else
      {
        do
        {
          char v95 = v94;
          unsigned int v96 = *((_DWORD *)v91 + 7);
          *(_DWORD *)(v93 + 28) = v96;
          *(_OWORD *)(v93 + 32) = *((_OWORD *)v91 + 2);
          CFRange v97 = *v60;
          CFTypeRef v98 = (uint64_t **)((char *)v1 + 400);
          uint64_t v99 = (uint64_t **)((char *)v1 + 400);
          if (*v60)
          {
            do
            {
              while (1)
              {
                CFTypeRef v98 = (uint64_t **)v97;
                if (v96 >= *((_DWORD *)v97 + 7)) {
                  break;
                }
                CFRange v97 = (uint64_t *)*v97;
                uint64_t v99 = v98;
                if (!*v98) {
                  goto LABEL_134;
                }
              }
              CFRange v97 = (uint64_t *)v97[1];
            }
            while (v97);
            uint64_t v99 = v98 + 1;
          }
LABEL_134:
          sub_100046C38((uint64_t **)v1 + 49, (uint64_t)v98, v99, (uint64_t *)v93);
          if (v94) {
            uint64_t v94 = sub_1000EA590((uint64_t)v94);
          }
          else {
            uint64_t v94 = 0;
          }
          uint64_t v100 = (uint8_t *)*((void *)v91 + 1);
          if (v100)
          {
            do
            {
              uint64_t v101 = v100;
              uint64_t v100 = *(uint8_t **)v100;
            }
            while (v100);
          }
          else
          {
            do
            {
              uint64_t v101 = (uint8_t *)*((void *)v91 + 2);
              BOOL v74 = *(void *)v101 == (void)v91;
              unsigned int v91 = v101;
            }
            while (!v74);
          }
          if (!v95) {
            break;
          }
          uint64_t v93 = (uint64_t)v95;
          unsigned int v91 = v101;
        }
        while (v101 != &buf[8]);
      }
      sub_10005D144(v95);
      if (v94)
      {
        for (uint64_t j = (void *)v94[2]; j; uint64_t j = (void *)j[2])
          uint64_t v94 = j;
        sub_10005D144(v94);
      }
    }
    else
    {
      uint64_t v101 = v91;
    }
    if (v101 != &buf[8])
    {
      do
      {
        uint64_t v103 = (char *)operator new(0x30uLL);
        long long v104 = *(_OWORD *)(v101 + 28);
        *((_DWORD *)v103 + 11) = *((_DWORD *)v101 + 11);
        *(_OWORD *)(v103 + 28) = v104;
        int v105 = *v60;
        char v106 = (uint64_t **)((char *)v1 + 400);
        uint64_t v107 = (uint64_t **)((char *)v1 + 400);
        if (*v60)
        {
          do
          {
            while (1)
            {
              char v106 = (uint64_t **)v105;
              if (*((_DWORD *)v103 + 7) >= *((_DWORD *)v105 + 7)) {
                break;
              }
              int v105 = (uint64_t *)*v105;
              uint64_t v107 = v106;
              if (!*v106) {
                goto LABEL_158;
              }
            }
            int v105 = (uint64_t *)v105[1];
          }
          while (v105);
          uint64_t v107 = v106 + 1;
        }
LABEL_158:
        sub_100046C38((uint64_t **)v1 + 49, (uint64_t)v106, v107, (uint64_t *)v103);
        uint64_t v108 = (uint8_t *)*((void *)v101 + 1);
        if (v108)
        {
          do
          {
            long long v109 = v108;
            uint64_t v108 = *(uint8_t **)v108;
          }
          while (v108);
        }
        else
        {
          do
          {
            long long v109 = (uint8_t *)*((void *)v101 + 2);
            BOOL v74 = *(void *)v109 == (void)v101;
            uint64_t v101 = v109;
          }
          while (!v74);
        }
        uint64_t v101 = v109;
      }
      while (v109 != &buf[8]);
    }
  }
  sub_10005D144(*(void **)&buf[8]);
  *(void *)&theArray[8] = 0;
  *(void *)&theArray[16] = 0;
  *(void *)CFArrayRef theArray = &theArray[8];
  uint64_t v110 = *((void *)v1 + 8);
  *(void *)long long buf = *((void *)v1 + 7);
  *(void *)&uint8_t buf[8] = v110;
  if (v110) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v110 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  CFDictionaryRef v111 = theDict;
  CFDictionaryRef v249 = v254;
  if (theDict != v254)
  {
    std::string v247 = v255;
    while ((v247(*(unsigned int *)v111) & 1) == 0)
    {
      CFDictionaryRef v111 = (CFDictionaryRef)((char *)v111 + 4);
      if (v111 == v249)
      {
        CFDictionaryRef v111 = v249;
        break;
      }
    }
    CFDictionaryRef v245 = v254;
    if (v111 != v254)
    {
      while (1)
      {
        int v252 = 0;
        uint64_t v112 = *(unsigned int *)v111;
        int v252 = *(_DWORD *)v111;
        int64x2_t v250 = 0uLL;
        unint64_t v251 = 0;
        CFArrayRef v257 = 0;
        uint64_t v113 = &qword_101B101C0;
        LOBYTE(v113) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B101C0, memory_order_acquire);
        if ((v113 & 1) == 0 && __cxa_guard_acquire(&qword_101B101C0))
        {
          *(void *)long long buf = @"IPC";
          *(void *)&uint8_t buf[8] = @"IPCConfigSet";
          sub_100367E88(qword_101B101E0, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B101E0, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B101C0);
          uint64_t v1 = v246;
        }
        uint64_t v114 = (std::mutex *)Registry::getServiceMap(v113, *((Registry **)v1 + 7));
        uint64_t v115 = v114;
        if (v116 < 0)
        {
          uint64_t v117 = (unsigned __int8 *)(v116 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v118 = 5381;
          do
          {
            uint64_t v116 = v118;
            unsigned int v119 = *v117++;
            uint64_t v118 = (33 * v118) ^ v119;
          }
          while (v119);
        }
        std::mutex::lock(v114);
        *(void *)long long buf = v116;
        uint64_t v120 = sub_10004D37C(&v115[1].__m_.__sig, (unint64_t *)buf);
        if (!v120) {
          break;
        }
        uint64_t v122 = v120[3];
        int v121 = (std::__shared_weak_count *)v120[4];
        if (!v121) {
          goto LABEL_182;
        }
        atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v115);
        atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v121);
        char v123 = 0;
LABEL_183:
        (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, uint64_t, uint64_t, void *, void, void))(*(void *)v122 + 104))(&v256, v122, v112, 1, qword_101B101E0, 0, 0);
        sub_100044D6C(__p, (CFTypeRef *)&v256);
        *(void *)long long buf = v257;
        CFArrayRef v257 = (CFArrayRef)__p[0].i64[0];
        __p[0].i64[0] = 0;
        sub_100044D00((const void **)buf);
        sub_100044D00((const void **)__p);
        sub_1000577C4((const void **)&v256);
        if ((v123 & 1) == 0) {
          sub_10004D2C8(v121);
        }
        if (v257) {
          unsigned int v124 = sub_100083F10;
        }
        else {
          unsigned int v124 = 0;
        }
        if (v124)
        {
          CFIndex v125 = CFArrayGetCount(v257);
          if (v125 >= 1)
          {
            for (CFIndex k = 0; k != v125; ++k)
            {
              CFDictionaryRef v256 = 0;
              *(void *)long long buf = CFArrayGetValueAtIndex(v257, k);
              sub_10004EFE4(&v256, (CFTypeRef *)buf);
              if (v256) {
                unint64_t v127 = sub_100080778;
              }
              else {
                unint64_t v127 = 0;
              }
              if (v127)
              {
                memset(buf, 0, 48);
                if (CFDictionaryGetValue(v256, @"Name"))
                {
                  memset(__p, 0, 24);
                  ctu::cf::assign();
                  v128 = (void *)__p[0].i64[0];
                  *(void *)&buf[15] = *(uint64_t *)((char *)&__p[0].i64[1] + 7);
                  unint64_t v129 = __p[1].u8[7];
                  *(int64x2_t *)long long buf = __p[0];
                  buf[23] = __p[1].u8[7];
                  unint64_t v130 = __p[0].u64[1];
                }
                else
                {
                  v128 = 0;
                  unint64_t v130 = 0;
                  unint64_t v129 = 0;
                }
                int v131 = (char)v129;
                if ((v129 & 0x80u) != 0) {
                  unint64_t v129 = v130;
                }
                if (v129)
                {
                  uint64_t v132 = (unsigned int *)CFDictionaryGetValue(v256, @"DataPathType");
                  int v133 = v132;
                  if (v132)
                  {
                    __p[0].i32[0] = 0;
                    CFTypeID v134 = CFGetTypeID(v132);
                    if (v134 == CFNumberGetTypeID()) {
                      ctu::cf::assign((ctu::cf *)__p, v133, v135);
                    }
                    *(_DWORD *)&uint8_t buf[24] = __p[0].i32[0];
                  }
                  id v136 = (unint64_t *)CFDictionaryGetValue(v256, @"ServiceMask");
                  v137 = v136;
                  if (v136)
                  {
                    __p[0].i64[0] = 0;
                    CFTypeID v138 = CFGetTypeID(v136);
                    if (v138 == CFNumberGetTypeID()) {
                      ctu::cf::assign((ctu::cf *)__p, v137, v139);
                    }
                    *(void *)&uint8_t buf[32] = __p[0].i64[0];
                  }
                  v140 = (unsigned int *)CFDictionaryGetValue(v256, @"TrafficTypeMask");
                  uint64_t v141 = v140;
                  if (v140)
                  {
                    __p[0].i32[0] = 0;
                    CFTypeID v142 = CFGetTypeID(v140);
                    if (v142 == CFNumberGetTypeID()) {
                      ctu::cf::assign((ctu::cf *)__p, v141, v143);
                    }
                    *(_DWORD *)&buf[28] = __p[0].i32[0];
                  }
                  unsigned int v144 = (unsigned int *)CFDictionaryGetValue(v256, @"MaxQueueSets");
                  int v145 = v144;
                  if (v144)
                  {
                    __p[0].i32[0] = 0;
                    CFTypeID v146 = CFGetTypeID(v144);
                    if (v146 == CFNumberGetTypeID()) {
                      ctu::cf::assign((ctu::cf *)__p, v145, v147);
                    }
                    *(_DWORD *)&buf[40] = __p[0].i32[0];
                  }
                  uint64_t v148 = v250.i64[1];
                  if (v250.i64[1] >= v251)
                  {
                    __int16 v149 = sub_100BC5694(&v250, (long long *)buf);
                  }
                  else
                  {
                    if (v131 < 0)
                    {
                      sub_10004FC84((unsigned char *)v250.i64[1], v128, v130);
                    }
                    else
                    {
                      *(_OWORD *)v250.i64[1] = *(_OWORD *)buf;
                      *(void *)(v148 + 16) = *(void *)&buf[16];
                    }
                    *(_OWORD *)(v148 + 24) = *(_OWORD *)&buf[24];
                    *(void *)(v148 + 38) = *(void *)&buf[38];
                    __int16 v149 = (char *)(v148 + 48);
                  }
                  v250.i64[1] = (uint64_t)v149;
                }
                if (v131 < 0) {
                  operator delete(v128);
                }
              }
              sub_100057D78((const void **)&v256);
            }
          }
        }
        sub_100044D00((const void **)&v257);
        int v150 = v252;
        int v151 = (int64x2_t *)(sub_100BC7D38((uint64_t **)theArray, v252, &v252) + 5);
        if (v151 != &v250) {
          sub_100BC5830((uint64_t)v151, (std::string *)v250.i64[0], (long long *)v250.i64[1], 0xAAAAAAAAAAAAAAABLL * ((v250.i64[1] - v250.i64[0]) >> 4));
        }
        *(void *)long long buf = &v250;
        sub_100BC55F0((void ***)buf);
        memset(__p, 0, 24);
        *(_WORD *)&buf[46] = 0;
        *(_OWORD *)&uint8_t buf[8] = 0u;
        *(void *)&uint8_t buf[24] = 0x700000000;
        buf[23] = 12;
        qmemcpy(buf, "__Internet__", 12);
        *(_DWORD *)&buf[40] = 4;
        *(void *)&uint8_t buf[32] = 1;
        *(_WORD *)&buf[44] = 256;
        uint64_t v152 = sub_100BC53F0(__p, (long long *)buf);
        __p[0].i64[1] = (uint64_t)v152;
        *(_WORD *)&buf[46] = 0;
        *(_OWORD *)&uint8_t buf[8] = 0u;
        *(void *)&uint8_t buf[24] = 0x700000000;
        buf[23] = 13;
        qmemcpy(buf, "__Internet2__", 13);
        *(_DWORD *)&buf[40] = 4;
        *(void *)&uint8_t buf[32] = 1;
        *(_WORD *)&buf[44] = 257;
        if ((unint64_t)v152 >= __p[1].i64[0])
        {
          uint64_t v153 = sub_100BC53F0(__p, (long long *)buf);
        }
        else
        {
          *(_OWORD *)uint64_t v152 = *(_OWORD *)buf;
          *((void *)v152 + 2) = *(void *)&buf[16];
          *(_OWORD *)(v152 + 24) = *(_OWORD *)&buf[24];
          *(void *)(v152 + 38) = *(void *)&buf[38];
          uint64_t v153 = v152 + 48;
        }
        __p[0].i64[1] = (uint64_t)v153;
        memset(&buf[16], 0, 32);
        buf[23] = 15;
        strcpy((char *)buf, "__LLTethering__");
        *(_DWORD *)&buf[40] = 2;
        *(_DWORD *)&buf[28] = 3;
        *(void *)&uint8_t buf[32] = 0x8000000;
        if ((unint64_t)v153 >= __p[1].i64[0])
        {
          uint64_t v154 = sub_100BC53F0(__p, (long long *)buf);
        }
        else
        {
          *(_OWORD *)uint64_t v153 = *(_OWORD *)buf;
          *((void *)v153 + 2) = *(void *)&buf[16];
          *(_OWORD *)(v153 + 24) = *(_OWORD *)&buf[24];
          *(void *)(v153 + 38) = *(void *)&buf[38];
          uint64_t v154 = v153 + 48;
        }
        __p[0].i64[1] = (uint64_t)v154;
        *(_DWORD *)&buf[44] = 0;
        *(_OWORD *)&uint8_t buf[8] = 0u;
        *(void *)&uint8_t buf[24] = 0x200000000;
        buf[23] = 13;
        qmemcpy(buf, "__Tethering__", 13);
        *(_DWORD *)&buf[40] = 2;
        *(void *)&uint8_t buf[32] = 16;
        if ((unint64_t)v154 >= __p[1].i64[0])
        {
          unint64_t v155 = sub_100BC53F0(__p, (long long *)buf);
        }
        else
        {
          *(_OWORD *)uint64_t v154 = *(_OWORD *)buf;
          *((void *)v154 + 2) = *(void *)&buf[16];
          *(_OWORD *)(v154 + 24) = *(_OWORD *)&buf[24];
          *(void *)(v154 + 38) = *(void *)&buf[38];
          unint64_t v155 = v154 + 48;
        }
        __p[0].i64[1] = (uint64_t)v155;
        *(_DWORD *)&buf[44] = 0;
        *(_OWORD *)&uint8_t buf[8] = 0u;
        *(void *)&uint8_t buf[24] = 0x100000000;
        buf[23] = 7;
        strcpy((char *)buf, "__IMS__");
        *(_DWORD *)&buf[40] = 2;
        *(void *)&uint8_t buf[32] = 393216;
        if ((unint64_t)v155 >= __p[1].i64[0])
        {
          uint64_t v156 = sub_100BC53F0(__p, (long long *)buf);
        }
        else
        {
          *(_OWORD *)unint64_t v155 = *(_OWORD *)buf;
          *((void *)v155 + 2) = *(void *)&buf[16];
          *(_OWORD *)(v155 + 24) = *(_OWORD *)&buf[24];
          *(void *)(v155 + 38) = *(void *)&buf[38];
          uint64_t v156 = v155 + 48;
        }
        __p[0].i64[1] = (uint64_t)v156;
        memset(&buf[16], 0, 32);
        buf[23] = 16;
        *(_OWORD *)long long buf = *(_OWORD *)"__OtherInitial__";
        *(_DWORD *)&buf[40] = 1;
        if ((unint64_t)v156 >= __p[1].i64[0])
        {
          uint64_t v157 = sub_100BC53F0(__p, (long long *)buf);
        }
        else
        {
          *(_OWORD *)uint64_t v156 = *(_OWORD *)buf;
          *((void *)v156 + 2) = *(void *)&buf[16];
          *(_OWORD *)(v156 + 24) = *(_OWORD *)&buf[24];
          *(void *)(v156 + 38) = *(void *)&buf[38];
          uint64_t v157 = v156 + 48;
        }
        __p[0].i64[1] = (uint64_t)v157;
        *(void *)&buf[40] = 0;
        *(_OWORD *)&uint8_t buf[8] = 0u;
        buf[23] = 12;
        qmemcpy(buf, "__LLFilter__", 12);
        *(void *)&uint8_t buf[24] = 0x100000002;
        *(void *)&uint8_t buf[32] = 134610944;
        if ((unint64_t)v157 >= __p[1].i64[0])
        {
          long long v158 = sub_100BC53F0(__p, (long long *)buf);
        }
        else
        {
          *(_OWORD *)uint64_t v157 = *(_OWORD *)buf;
          *((void *)v157 + 2) = *(void *)&buf[16];
          *(_OWORD *)(v157 + 24) = *(_OWORD *)&buf[24];
          *(void *)(v157 + 38) = *(void *)&buf[38];
          long long v158 = v157 + 48;
        }
        __p[0].i64[1] = (uint64_t)v158;
        memset(&buf[16], 0, 32);
        buf[23] = 15;
        strcpy((char *)buf, "__OtherFilter__");
        *(_DWORD *)&uint8_t buf[24] = 2;
        if ((unint64_t)v158 >= __p[1].i64[0])
        {
          BOOL v159 = sub_100BC53F0(__p, (long long *)buf);
        }
        else
        {
          *(_OWORD *)long long v158 = *(_OWORD *)buf;
          *((void *)v158 + 2) = *(void *)&buf[16];
          *(_OWORD *)(v158 + 24) = *(_OWORD *)&buf[24];
          *(void *)(v158 + 38) = *(void *)&buf[38];
          BOOL v159 = v158 + 48;
        }
        __p[0].i64[1] = (uint64_t)v159;
        *(void *)&buf[40] = 0;
        *(_OWORD *)&uint8_t buf[8] = 0u;
        buf[23] = 9;
        qmemcpy(buf, "__LLDRB__", 9);
        *(void *)&uint8_t buf[24] = 0x100000001;
        *(void *)&uint8_t buf[32] = 134610944;
        if ((unint64_t)v159 >= __p[1].i64[0])
        {
          uint64_t v160 = sub_100BC53F0(__p, (long long *)buf);
        }
        else
        {
          *(_OWORD *)BOOL v159 = *(_OWORD *)buf;
          *((void *)v159 + 2) = *(void *)&buf[16];
          *(_OWORD *)(v159 + 24) = *(_OWORD *)&buf[24];
          *(void *)(v159 + 38) = *(void *)&buf[38];
          uint64_t v160 = v159 + 48;
        }
        __p[0].i64[1] = (uint64_t)v160;
        memset(&buf[8], 0, 40);
        buf[23] = 12;
        qmemcpy(buf, "__OtherDRB__", 12);
        *(_DWORD *)&uint8_t buf[24] = 1;
        if ((unint64_t)v160 >= __p[1].i64[0])
        {
          uint64_t v161 = sub_100BC53F0(__p, (long long *)buf);
        }
        else
        {
          *(_OWORD *)uint64_t v160 = *(_OWORD *)buf;
          *((void *)v160 + 2) = *(void *)&buf[16];
          *(_OWORD *)(v160 + 24) = *(_OWORD *)&buf[24];
          *(void *)(v160 + 38) = *(void *)&buf[38];
          uint64_t v161 = v160 + 48;
        }
        __p[0].i64[1] = (uint64_t)v161;
        for (uint64_t m = __p[0].i64[0]; (char *)m != v161; m += 48)
        {
          v163 = sub_100BC7D38((uint64_t **)theArray, v150, &v252);
          uint64_t v164 = v163;
          uint64_t v165 = v163[6];
          if (v165 >= v163[7])
          {
            unint64_t v167 = sub_100BC5694((int64x2_t *)(v163 + 5), (long long *)m);
          }
          else
          {
            if (*(char *)(m + 23) < 0)
            {
              sub_10004FC84(v163[6], *(void **)m, *(void *)(m + 8));
            }
            else
            {
              long long v166 = *(_OWORD *)m;
              v165[2] = *(void *)(m + 16);
              *(_OWORD *)uint64_t v165 = v166;
            }
            long long v168 = *(_OWORD *)(m + 24);
            *(uint64_t *)((char *)v165 + 38) = *(void *)(m + 38);
            *(_OWORD *)(v165 + 3) = v168;
            unint64_t v167 = (char *)(v165 + 6);
            v164[6] = v165 + 6;
          }
          v164[6] = (uint64_t *)v167;
        }
        *(void *)long long buf = __p;
        sub_100BC55F0((void ***)buf);
        CFDictionaryRef v169 = (CFDictionaryRef)((char *)v111 + 4);
        CFDictionaryRef v111 = v249;
        if (v169 != v249)
        {
          CFDictionaryRef v111 = v169;
          while ((v247(*(unsigned int *)v111) & 1) == 0)
          {
            CFDictionaryRef v111 = (CFDictionaryRef)((char *)v111 + 4);
            if (v111 == v249)
            {
              CFDictionaryRef v111 = v249;
              break;
            }
          }
        }
        if (v111 == v245) {
          goto LABEL_274;
        }
      }
      uint64_t v122 = 0;
LABEL_182:
      std::mutex::unlock(v115);
      int v121 = 0;
      char v123 = 1;
      goto LABEL_183;
    }
  }
LABEL_274:
  uint64_t v170 = (void *)*((void *)v1 + 52);
  uint64_t v171 = (void *)((char *)v1 + 424);
  if (v170 != (void *)((char *)v1 + 424))
  {
    while (1)
    {
      uint64_t v172 = *(uint64_t **)&theArray[8];
      if (*(void *)&theArray[8])
      {
        int v173 = *((_DWORD *)v170 + 8);
        uint64_t v174 = &theArray[8];
        uint64_t v175 = *(uint64_t **)&theArray[8];
        do
        {
          uint64_t v176 = v175;
          uint64_t v177 = v174;
          int v178 = *((_DWORD *)v175 + 8);
          if (v178 >= v173) {
            uint64_t v174 = v175;
          }
          else {
            ++v175;
          }
          uint64_t v175 = (uint64_t *)*v175;
        }
        while (v175);
        if (v174 != &theArray[8])
        {
          if (v178 < v173) {
            uint64_t v176 = v177;
          }
          if (v173 >= *((_DWORD *)v176 + 8)) {
            break;
          }
        }
      }
      uint64_t v179 = *((void *)v1 + 5);
      if (os_log_type_enabled(v179, OS_LOG_TYPE_ERROR))
      {
        uint64_t v200 = subscriber::asString();
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "updateIpcConfigSetConfiguration_sync";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v200;
        _os_log_error_impl((void *)&_mh_execute_header, v179, OS_LOG_TYPE_ERROR, "%s: cannot find new config for %s", buf, 0x16u);
      }
LABEL_287:
      int v180 = (void *)v170[1];
      if (v180)
      {
        do
        {
          v181 = v180;
          int v180 = (void *)*v180;
        }
        while (v180);
      }
      else
      {
        do
        {
          v181 = (void *)v170[2];
          BOOL v74 = *v181 == (void)v170;
          uint64_t v170 = v181;
        }
        while (!v74);
      }
      uint64_t v170 = v181;
      if (v181 == v171) {
        goto LABEL_335;
      }
    }
    while (1)
    {
      while (1)
      {
        int v182 = *((_DWORD *)v172 + 8);
        if (v182 <= v173) {
          break;
        }
        uint64_t v172 = (uint64_t *)*v172;
        if (!v172) {
          goto LABEL_434;
        }
      }
      if (v182 >= v173) {
        break;
      }
      uint64_t v172 = (uint64_t *)v172[1];
      if (!v172) {
LABEL_434:
      }
        sub_1000C14F0("map::at:  key not found");
    }
    BOOL v184 = (const void **)v170[5];
    int v183 = (const void **)v170[6];
    while (1)
    {
      if (v184 == v183) {
        goto LABEL_287;
      }
      uint64_t v186 = v172[5];
      uint64_t v185 = v172[6];
      if (v186 == v185)
      {
LABEL_322:
        if (v186 != v185) {
          goto LABEL_331;
        }
      }
      else
      {
        int v187 = *((char *)v184 + 23);
        if (v187 >= 0) {
          uint64_t v188 = (const void *)*((unsigned __int8 *)v184 + 23);
        }
        else {
          uint64_t v188 = v184[1];
        }
        do
        {
          uint64_t v189 = *(unsigned __int8 *)(v186 + 23);
          if ((v189 & 0x80u) == 0) {
            v190 = (const void *)*(unsigned __int8 *)(v186 + 23);
          }
          else {
            v190 = *(const void **)(v186 + 8);
          }
          if (v190 == v188)
          {
            if (v187 >= 0) {
              uint64_t v191 = (unsigned __int8 *)v184;
            }
            else {
              uint64_t v191 = (unsigned __int8 *)*v184;
            }
            if ((v189 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)v186, v191, *(void *)(v186 + 8))) {
                goto LABEL_322;
              }
            }
            else
            {
              if (!*(unsigned char *)(v186 + 23)) {
                goto LABEL_322;
              }
              uint64_t v192 = 0;
              while (*(unsigned __int8 *)(v186 + v192) == v191[v192])
              {
                if (v189 == ++v192) {
                  goto LABEL_322;
                }
              }
            }
          }
          v186 += 48;
        }
        while (v186 != v185);
      }
      memset(buf, 0, 32);
      unsigned int v193 = (ApplePDPHelperInterface *)subscriber::simSlotAsInstance();
      *(_DWORD *)long long buf = v193 + 1;
      uint8_t buf[16] = 0;
      v194 = (unsigned __int8 *)v184;
      if (*((char *)v184 + 23) < 0) {
        v194 = (unsigned __int8 *)*v184;
      }
      *(void *)&uint8_t buf[8] = v194;
      uint64_t v195 = ApplePDPHelperInterface::getInstance(v193);
      char v196 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v195 + 32))(v195, buf);
      BOOL v197 = *((void *)v1 + 5);
      if (v196)
      {
        if (os_log_type_enabled(*((os_log_t *)v1 + 5), OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v198 = (uint64_t)v184;
          if (*((char *)v184 + 23) < 0) {
            uint64_t v198 = (uint64_t)*v184;
          }
          __p[0].i32[0] = 136315394;
          *(uint64_t *)((char *)__p[0].i64 + 4) = (uint64_t)"updateIpcConfigSetConfiguration_sync";
          __p[0].i16[6] = 2080;
          *(uint64_t *)((char *)&__p[0].i64[1] + 6) = v198;
          _os_log_impl((void *)&_mh_execute_header, v197, OS_LOG_TYPE_DEFAULT, "#I %s: Unconfigured ipcConfigSet %s", (uint8_t *)__p, 0x16u);
        }
      }
      else if (os_log_type_enabled(*((os_log_t *)v1 + 5), OS_LOG_TYPE_ERROR))
      {
        uint64_t v199 = (uint64_t)v184;
        if (*((char *)v184 + 23) < 0) {
          uint64_t v199 = (uint64_t)*v184;
        }
        __p[0].i32[0] = 136315394;
        *(uint64_t *)((char *)__p[0].i64 + 4) = (uint64_t)"updateIpcConfigSetConfiguration_sync";
        __p[0].i16[6] = 2080;
        *(uint64_t *)((char *)&__p[0].i64[1] + 6) = v199;
        _os_log_error_impl((void *)&_mh_execute_header, v197, OS_LOG_TYPE_ERROR, "%s: Cannot unconfigure ipcConfigSet %s", (uint8_t *)__p, 0x16u);
      }
LABEL_331:
      v184 += 6;
    }
  }
LABEL_335:
  v201 = *(unsigned char **)theArray;
  if (*(unsigned char **)theArray != &theArray[8])
  {
    do
    {
      v202 = (int32x2_t *)*((void *)v201 + 5);
      char v203 = (int32x2_t *)*((void *)v201 + 6);
      while (v202 != v203)
      {
        uint64_t v204 = *v171;
        int v205 = *((_DWORD *)v201 + 8);
        if (!*v171) {
          goto LABEL_371;
        }
        uint64_t v206 = v171;
        do
        {
          int v207 = *(_DWORD *)(v204 + 32);
          BOOL v208 = v207 < v205;
          if (v207 >= v205) {
            uint64_t v209 = (uint64_t *)v204;
          }
          else {
            uint64_t v209 = (uint64_t *)(v204 + 8);
          }
          if (!v208) {
            uint64_t v206 = (void *)v204;
          }
          uint64_t v204 = *v209;
        }
        while (*v209);
        if (v206 == v171 || v205 < *((_DWORD *)v206 + 8)) {
          goto LABEL_371;
        }
        uint64_t v211 = v206[5];
        uint64_t v210 = v206[6];
        if (v211 != v210)
        {
          int v212 = v202[2].i8[7];
          if (v212 >= 0) {
            int32x2_t v213 = (int32x2_t)v202[2].u8[7];
          }
          else {
            int32x2_t v213 = v202[1];
          }
          while (1)
          {
            uint64_t v214 = *(unsigned __int8 *)(v211 + 23);
            if ((v214 & 0x80u) == 0) {
              uint64_t v215 = *(unsigned __int8 *)(v211 + 23);
            }
            else {
              uint64_t v215 = *(void *)(v211 + 8);
            }
            if (v215 == *(void *)&v213)
            {
              if (v212 >= 0) {
                v216 = v202;
              }
              else {
                v216 = (int32x2_t *)*v202;
              }
              if ((v214 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)v211, v216, *(void *)(v211 + 8)))
                {
LABEL_368:
                  uint64_t v1 = v246;
                  break;
                }
              }
              else
              {
                if (!*(unsigned char *)(v211 + 23)) {
                  goto LABEL_368;
                }
                uint64_t v217 = 0;
                while (*(unsigned __int8 *)(v211 + v217) == v216->u8[v217])
                {
                  if (v214 == ++v217) {
                    goto LABEL_368;
                  }
                }
              }
            }
            v211 += 48;
            if (v211 == v210)
            {
              uint64_t v1 = v246;
              goto LABEL_371;
            }
          }
        }
        if (v211 == v210 || (IPCConfigSet::operator==() & 1) == 0)
        {
LABEL_371:
          memset(buf, 0, 32);
          int v218 = (ApplePDPHelperInterface *)subscriber::simSlotAsInstance();
          *(_DWORD *)long long buf = v218 + 1;
          uint8_t buf[16] = 1;
          v219 = v202;
          if (v202[2].i8[7] < 0) {
            v219 = (int32x2_t *)*v202;
          }
          *(void *)&uint8_t buf[8] = v219;
          *(int32x2_t *)&buf[20] = vrev64_s32(v202[3]);
          *(_DWORD *)&buf[28] = v202[5].i32[0];
          uint64_t v220 = ApplePDPHelperInterface::getInstance(v218);
          char v221 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v220 + 32))(v220, buf);
          uint64_t v222 = *((void *)v1 + 5);
          if (v221)
          {
            if (os_log_type_enabled(*((os_log_t *)v1 + 5), OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v223 = (uint64_t)v202;
              if (v202[2].i8[7] < 0) {
                uint64_t v223 = (uint64_t)*v202;
              }
              __p[0].i32[0] = 136315394;
              *(uint64_t *)((char *)__p[0].i64 + 4) = (uint64_t)"updateIpcConfigSetConfiguration_sync";
              __p[0].i16[6] = 2080;
              *(uint64_t *)((char *)&__p[0].i64[1] + 6) = v223;
              _os_log_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_DEFAULT, "#I %s: Configured ipcConfigSet %s", (uint8_t *)__p, 0x16u);
            }
          }
          else if (os_log_type_enabled(*((os_log_t *)v1 + 5), OS_LOG_TYPE_ERROR))
          {
            uint64_t v224 = (uint64_t)v202;
            if (v202[2].i8[7] < 0) {
              uint64_t v224 = (uint64_t)*v202;
            }
            __p[0].i32[0] = 136315394;
            *(uint64_t *)((char *)__p[0].i64 + 4) = (uint64_t)"updateIpcConfigSetConfiguration_sync";
            __p[0].i16[6] = 2080;
            *(uint64_t *)((char *)&__p[0].i64[1] + 6) = v224;
            _os_log_error_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_ERROR, "%s: Cannot configure ipcConfigSet %s", (uint8_t *)__p, 0x16u);
          }
        }
        v202 += 6;
      }
      __int16 v225 = (void *)*((void *)v201 + 1);
      if (v225)
      {
        do
        {
          uint64_t v226 = v225;
          __int16 v225 = (void *)*v225;
        }
        while (v225);
      }
      else
      {
        do
        {
          uint64_t v226 = (unsigned char *)*((void *)v201 + 2);
          BOOL v74 = *(void *)v226 == (void)v201;
          v201 = v226;
        }
        while (!v74);
      }
      v201 = v226;
    }
    while (v226 != &theArray[8]);
  }
  __int16 v227 = (uint64_t *)((char *)v1 + 416);
  if ((char *)v1 + 416 != theArray)
  {
    uint64_t v228 = *(unsigned char **)theArray;
    if (*((void *)v1 + 54))
    {
      uint64_t v229 = *v227;
      *__int16 v227 = (uint64_t)v171;
      *(void *)(*v171 + 16) = 0;
      *uint64_t v171 = 0;
      v171[1] = 0;
      if (*(void *)(v229 + 8)) {
        uint64_t v230 = *(void *)(v229 + 8);
      }
      else {
        uint64_t v230 = v229;
      }
      *(void *)long long buf = (char *)v1 + 416;
      *(void *)&uint8_t buf[8] = v230;
      *(void *)&uint8_t buf[16] = v230;
      if (v230)
      {
        *(void *)&uint8_t buf[8] = sub_1000EA590(v230);
        __int16 v231 = &theArray[8];
        if (v228 != &theArray[8])
        {
          do
          {
            *(_DWORD *)(v230 + 32) = *((_DWORD *)v228 + 8);
            if ((unsigned char *)v230 != v228)
            {
              sub_100BC5830(v230 + 40, *((std::string **)v228 + 5), *((long long **)v228 + 6), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v228 + 6) - *((void *)v228 + 5)) >> 4));
              uint64_t v230 = *(void *)&buf[16];
            }
            uint64_t v232 = (uint64_t *)*v171;
            __int16 v233 = (uint64_t **)v171;
            uint64_t v234 = (uint64_t **)v171;
            if (*v171)
            {
              do
              {
                while (1)
                {
                  __int16 v233 = (uint64_t **)v232;
                  if (*(_DWORD *)(v230 + 32) >= *((_DWORD *)v232 + 8)) {
                    break;
                  }
                  uint64_t v232 = (uint64_t *)*v232;
                  uint64_t v234 = v233;
                  if (!*v233) {
                    goto LABEL_404;
                  }
                }
                uint64_t v232 = (uint64_t *)v232[1];
              }
              while (v232);
              uint64_t v234 = v233 + 1;
            }
LABEL_404:
            sub_100046C38((uint64_t **)v1 + 52, (uint64_t)v233, v234, (uint64_t *)v230);
            uint64_t v230 = *(void *)&buf[8];
            *(void *)&uint8_t buf[16] = *(void *)&buf[8];
            if (*(void *)&buf[8]) {
              *(void *)&uint8_t buf[8] = sub_1000EA590(*(uint64_t *)&buf[8]);
            }
            __int16 v235 = (void *)*((void *)v228 + 1);
            if (v235)
            {
              do
              {
                __int16 v231 = v235;
                __int16 v235 = (void *)*v235;
              }
              while (v235);
            }
            else
            {
              do
              {
                __int16 v231 = (unsigned char *)*((void *)v228 + 2);
                BOOL v74 = *(void *)v231 == (void)v228;
                uint64_t v228 = v231;
              }
              while (!v74);
            }
            if (!v230) {
              break;
            }
            uint64_t v228 = v231;
          }
          while (v231 != &theArray[8]);
        }
      }
      else
      {
        __int16 v231 = v228;
      }
      sub_100BC7DE8((uint64_t)buf);
      uint64_t v228 = v231;
    }
    if (v228 != &theArray[8])
    {
      do
      {
        uint64_t v236 = (char *)operator new(0x40uLL);
        int v237 = *((_DWORD *)v228 + 8);
        *((void *)v236 + 5) = 0;
        *((_DWORD *)v236 + 8) = v237;
        *((void *)v236 + 6) = 0;
        *((void *)v236 + 7) = 0;
        uint64_t v238 = (long long *)*((void *)v228 + 5);
        __int16 v239 = (long long *)*((void *)v228 + 6);
        *(void *)long long buf = v236 + 40;
        if (v239 != v238)
        {
          *(void *)&uint8_t buf[8] = 0;
          sub_100B066E4((void *)v236 + 5, 0xAAAAAAAAAAAAAAABLL * (v239 - v238));
          *((void *)v236 + 6) = sub_100BC59B0((uint64_t)(v236 + 56), v238, v239, *((char **)v236 + 6));
        }
        uint64_t v240 = (uint64_t *)*v171;
        __int16 v241 = (uint64_t **)v171;
        uint64_t v242 = (uint64_t **)v171;
        if (*v171)
        {
          do
          {
            while (1)
            {
              __int16 v241 = (uint64_t **)v240;
              if (*((_DWORD *)v236 + 8) >= *((_DWORD *)v240 + 8)) {
                break;
              }
              uint64_t v240 = (uint64_t *)*v240;
              uint64_t v242 = v241;
              if (!*v241) {
                goto LABEL_425;
              }
            }
            uint64_t v240 = (uint64_t *)v240[1];
          }
          while (v240);
          uint64_t v242 = v241 + 1;
        }
LABEL_425:
        sub_100046C38((uint64_t **)v1 + 52, (uint64_t)v241, v242, (uint64_t *)v236);
        __int16 v243 = (void *)*((void *)v228 + 1);
        if (v243)
        {
          do
          {
            uint64_t v244 = v243;
            __int16 v243 = (void *)*v243;
          }
          while (v243);
        }
        else
        {
          do
          {
            uint64_t v244 = (unsigned char *)*((void *)v228 + 2);
            BOOL v74 = *(void *)v244 == (void)v228;
            uint64_t v228 = v244;
          }
          while (!v74);
        }
        uint64_t v228 = v244;
      }
      while (v244 != &theArray[8]);
    }
  }
  sub_100BC61EC(*(char **)&theArray[8]);
}

void sub_100BC3324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,const void *a29)
{
  __cxa_guard_abort(&qword_101B101B8);
  sub_100044D00(&a29);
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_10005D144(*(void **)(v29 - 168));
  _Unwind_Resume(a1);
}

void *sub_100BC358C@<X0>(void *result@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v7 = result;
  uint64_t v9 = result[53];
  if (v9)
  {
    uint64_t v10 = a5;
    char v13 = result + 53;
    do
    {
      int v14 = *(_DWORD *)(v9 + 32);
      BOOL v15 = v14 < a2;
      if (v14 >= a2) {
        uint64_t v16 = (uint64_t *)v9;
      }
      else {
        uint64_t v16 = (uint64_t *)(v9 + 8);
      }
      if (!v15) {
        char v13 = (void *)v9;
      }
      uint64_t v9 = *v16;
    }
    while (*v16);
    if (v13 != result + 53 && *((_DWORD *)v13 + 8) <= a2)
    {
      if ((a5 & 0x8000011) != 0)
      {
        BOOL result = (void *)sub_100BC0408((Registry *)result[7], (uint64_t *)0x8000011);
        int v21 = 0;
        if (a3)
        {
          if (result != a2)
          {
            BOOL result = (void *)sub_100BBEEA4((Registry *)v7[7], 0);
            int v21 = result == a2;
            if (result != a2) {
              v10 &= 0xFFFFFFFFF7FFFFEELL;
            }
          }
        }
      }
      else
      {
        int v21 = 0;
      }
      for (CFIndex i = (long long *)v13[5]; i != (long long *)v13[6]; i += 3)
      {
        if (*((_DWORD *)i + 6) == a4)
        {
          uint64_t v23 = *((void *)i + 4);
          BOOL v24 = v23 && (v23 & v10) == 0;
          if (!v24 && (!*((unsigned char *)i + 45) || v21 == *((unsigned __int8 *)i + 44)))
          {
            if (*((char *)i + 23) < 0)
            {
              unsigned int v27 = *(void **)i;
              unint64_t v28 = *((void *)i + 1);
              return sub_10004FC84((unsigned char *)a6, v27, v28);
            }
            else
            {
              long long v26 = *i;
              *(void *)(a6 + 16) = *((void *)i + 2);
              *(_OWORD *)a6 = v26;
            }
            return result;
          }
        }
      }
      uint64_t v25 = v7[5];
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        return sub_100058DB0((void *)a6, "");
      }
      int v29 = 136315650;
      uint64_t v30 = subscriber::asString();
      __int16 v31 = 1024;
      int v32 = a4;
      __int16 v33 = 2048;
      uint64_t v34 = v10;
      unint64_t v18 = "#E There is no IPC configuration available for %s, data path %d and mask %llu";
      uint64_t v19 = v25;
      uint32_t v20 = 28;
      goto LABEL_13;
    }
  }
  uint64_t v17 = result[5];
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    int v29 = 136315138;
    uint64_t v30 = subscriber::asString();
    unint64_t v18 = "#E There is no IPC configuration available for %s";
    uint64_t v19 = v17;
    uint32_t v20 = 12;
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v29, v20);
  }
  return sub_100058DB0((void *)a6, "");
}

uint64_t sub_100BC3814(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 424);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a4;
  uint64_t v7 = a1 + 424;
  do
  {
    int v8 = *(_DWORD *)(v5 + 32);
    BOOL v9 = v8 < a2;
    if (v8 >= a2) {
      uint64_t v10 = (uint64_t *)v5;
    }
    else {
      uint64_t v10 = (uint64_t *)(v5 + 8);
    }
    if (!v9) {
      uint64_t v7 = v5;
    }
    uint64_t v5 = *v10;
  }
  while (*v10);
  if (v7 == a1 + 424 || *(_DWORD *)(v7 + 32) > a2)
  {
LABEL_11:
    uint64_t v11 = *(NSObject **)(a1 + 40);
    BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v12) {
      return result;
    }
    int v22 = 136315138;
    uint64_t v23 = subscriber::asString();
    int v14 = "#E There is no IPC configuration available for %s";
    BOOL v15 = v11;
    uint32_t v16 = 12;
    goto LABEL_13;
  }
  if ((a4 & 0x8000011) != 0 && sub_100BC0408(*(Registry **)(a1 + 56), (uint64_t *)0x8000011) != a2) {
    v6 &= 0xFFFFFFFFF7FFFFEELL;
  }
  for (uint64_t i = *(void *)(v7 + 40); i != *(void *)(v7 + 48); i += 48)
  {
    if (!*(_DWORD *)(i + 24))
    {
      uint64_t v18 = *(void *)(i + 32);
      if (!v18 || (v18 & v6) != 0) {
        return (*(unsigned __int8 *)(i + 28) >> 2) & 1;
      }
    }
  }
  uint32_t v20 = *(NSObject **)(a1 + 40);
  BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v21)
  {
    int v22 = 136315394;
    uint64_t v23 = subscriber::asString();
    __int16 v24 = 2048;
    uint64_t v25 = v6;
    int v14 = "#E There is no IPC configuration available for %s, and mask %llu";
    BOOL v15 = v20;
    uint32_t v16 = 22;
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v22, v16);
    return 0;
  }
  return result;
}

void sub_100BC39E4(uint64_t a1)
{
  sub_100BC5B48(a1);

  operator delete();
}

char *sub_100BC3A1C@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[359] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 42), *((void *)result + 43));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 21);
  *(void *)(a2 + 16) = *((void *)result + 44);
  return result;
}

char *sub_100BC3A48@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[383] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 45), *((void *)result + 46));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 360);
  *(void *)(a2 + 16) = *((void *)result + 47);
  return result;
}

void *sub_100BC3A74@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = (char *)result[36];
  uint64_t v4 = (char *)result[37];
  uint64_t v5 = v4 - v3;
  if (v4 != v3)
  {
    if (v5 < 0) {
      sub_10006A748();
    }
    uint64_t result = sub_1009C886C(v5 >> 4);
    uint64_t v6 = 0;
    *a2 = result;
    a2[1] = result;
    a2[2] = &result[2 * v7];
    int v8 = result;
    do
    {
      *int v8 = *(void *)v3;
      uint64_t v9 = *((void *)v3 + 1);
      v8[1] = v9;
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
      }
      v6 += 2;
      v3 += 16;
      v8 += 2;
    }
    while (v3 != v4);
    a2[1] = &result[v6];
  }
  return result;
}

void sub_100BC3B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_100BC3B38(void *a1, char *a2, uint64_t a3, char a4)
{
void *sub_100BC4440(void *result, void *a2, void *a3)
{
  uint64_t v3 = *a2;
  int v4 = *(_DWORD *)(*a2 + 148);
  uint64_t v5 = *result;
  uint64_t v6 = *a3;
  int v7 = *(_DWORD *)(*a3 + 148);
  if (v4 < *(_DWORD *)(*result + 148))
  {
    if (v7 >= v4)
    {
      *uint64_t result = v3;
      *a2 = v5;
      uint64_t v12 = result[1];
      result[1] = a2[1];
      a2[1] = v12;
      uint64_t v13 = *a2;
      if (*(_DWORD *)(*a3 + 148) >= *(_DWORD *)(*a2 + 148)) {
        return result;
      }
      *a2 = *a3;
      *a3 = v13;
      int v8 = a3 + 1;
      uint64_t result = a2 + 1;
    }
    else
    {
      *result++ = v6;
      *a3 = v5;
      int v8 = a3 + 1;
    }
    uint64_t v9 = v8;
    goto LABEL_10;
  }
  if (v7 < v4)
  {
    *a2 = v6;
    *a3 = v3;
    uint64_t v9 = a2 + 1;
    uint64_t v10 = a2[1];
    a2[1] = a3[1];
    a3[1] = v10;
    uint64_t v11 = *result;
    if (*(_DWORD *)(*a2 + 148) < *(_DWORD *)(*result + 148))
    {
      *result++ = *a2;
      *a2 = v11;
LABEL_10:
      uint64_t v14 = *result;
      *uint64_t result = *v9;
      *uint64_t v9 = v14;
    }
  }
  return result;
}

BOOL sub_100BC4514(char *a1, char *a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *((void *)a2 - 2);
      uint64_t v7 = *(void *)a1;
      if (*(_DWORD *)(v6 + 148) < *(_DWORD *)(*(void *)a1 + 148))
      {
        *(void *)a1 = v6;
        *((void *)a2 - 2) = v7;
        uint64_t v8 = *((void *)a1 + 1);
        *((void *)a1 + 1) = *((void *)a2 - 1);
        *((void *)a2 - 1) = v8;
      }
      return result;
    case 3:
      sub_100BC4440(a1, (void *)a1 + 2, (void *)a2 - 2);
      return 1;
    case 4:
      sub_100BC4788(a1, (void *)a1 + 2, (void *)a1 + 4, (void *)a2 - 2);
      return 1;
    case 5:
      sub_100BC4788(a1, (void *)a1 + 2, (void *)a1 + 4, (void *)a1 + 6);
      uint64_t v22 = *((void *)a2 - 2);
      uint64_t v23 = *((void *)a1 + 6);
      if (*(_DWORD *)(v22 + 148) < *(_DWORD *)(v23 + 148))
      {
        *((void *)a1 + 6) = v22;
        *((void *)a2 - 2) = v23;
        uint64_t v24 = *((void *)a1 + 7);
        *((void *)a1 + 7) = *((void *)a2 - 1);
        *((void *)a2 - 1) = v24;
        uint64_t v25 = *((void *)a1 + 6);
        int v26 = *(_DWORD *)(v25 + 148);
        uint64_t v27 = *((void *)a1 + 4);
        if (v26 < *(_DWORD *)(v27 + 148))
        {
          uint64_t v28 = *((void *)a1 + 5);
          uint64_t v29 = *((void *)a1 + 7);
          *((void *)a1 + 4) = v25;
          *((void *)a1 + 5) = v29;
          *((void *)a1 + 6) = v27;
          *((void *)a1 + 7) = v28;
          uint64_t v30 = *((void *)a1 + 2);
          if (v26 < *(_DWORD *)(v30 + 148))
          {
            uint64_t v31 = *((void *)a1 + 3);
            *((void *)a1 + 2) = v25;
            *((void *)a1 + 3) = v29;
            *((void *)a1 + 4) = v30;
            *((void *)a1 + 5) = v31;
            uint64_t v32 = *(void *)a1;
            if (v26 < *(_DWORD *)(*(void *)a1 + 148))
            {
              uint64_t v33 = *((void *)a1 + 1);
              *(void *)a1 = v25;
              *((void *)a1 + 1) = v29;
              *((void *)a1 + 2) = v32;
              *((void *)a1 + 3) = v33;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v9 = a1 + 32;
      sub_100BC4440(a1, (void *)a1 + 2, (void *)a1 + 4);
      uint64_t v10 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    uint64_t v13 = *(void *)v10;
    uint64_t v14 = *(void *)v9;
    if (*(_DWORD *)(*(void *)v10 + 148) < *(_DWORD *)(*(void *)v9 + 148))
    {
      uint64_t v15 = *((void *)v10 + 1);
      uint64_t v16 = v11;
      *(void *)uint64_t v10 = 0;
      *((void *)v10 + 1) = 0;
      while (1)
      {
        uint64_t v17 = &a1[v16];
        uint64_t v18 = *(void *)&a1[v16 + 40];
        *((void *)v17 + 4) = 0;
        *((void *)v17 + 5) = 0;
        int v19 = *(std::__shared_weak_count **)&a1[v16 + 56];
        *((void *)v17 + 6) = v14;
        *((void *)v17 + 7) = v18;
        if (v19) {
          sub_10004D2C8(v19);
        }
        if (v16 == -32) {
          break;
        }
        uint64_t v14 = *(void *)&a1[v16 + 16];
        v16 -= 16;
        if (*(_DWORD *)(v13 + 148) >= *(_DWORD *)(v14 + 148))
        {
          uint64_t v20 = &a1[v16 + 48];
          goto LABEL_15;
        }
      }
      uint64_t v20 = a1;
LABEL_15:
      BOOL v21 = (std::__shared_weak_count *)*((void *)v20 + 1);
      *(void *)uint64_t v20 = v13;
      *((void *)v20 + 1) = v15;
      if (v21) {
        sub_10004D2C8(v21);
      }
      if (++v12 == 8) {
        return v10 + 16 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2) {
      return 1;
    }
  }
}

void *sub_100BC4788(void *a1, void *a2, void *a3, void *a4)
{
  BOOL result = sub_100BC4440(a1, a2, a3);
  uint64_t v9 = *a3;
  if (*(_DWORD *)(*a4 + 148) < *(_DWORD *)(*a3 + 148))
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v10 = a3[1];
    a3[1] = a4[1];
    a4[1] = v10;
    uint64_t v11 = *a2;
    if (*(_DWORD *)(*a3 + 148) < *(_DWORD *)(*a2 + 148))
    {
      *a2 = *a3;
      *a3 = v11;
      uint64_t v12 = a2[1];
      a2[1] = a3[1];
      a3[1] = v12;
      uint64_t v13 = *a1;
      if (*(_DWORD *)(*a2 + 148) < *(_DWORD *)(*a1 + 148))
      {
        *a1 = *a2;
        *a2 = v13;
        uint64_t v14 = a1[1];
        a1[1] = a2[1];
        a2[1] = v14;
      }
    }
  }
  return result;
}

void *sub_100BC4850(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v8;
  v7[3] = 1;
  uint64_t v8 = a4;
  void v7[2] = &v9;
  if (a2 != a3)
  {
    do
    {
      void *v4 = *a2;
      uint64_t v5 = a2[1];
      v4[1] = v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      v4 += 2;
      a2 += 2;
    }
    while (a2 != a3);
    uint64_t v9 = v4;
  }
  sub_100BC48DC((uint64_t)v7);
  return v4;
}

uint64_t sub_100BC48DC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10037AA1C(a1);
  }
  return a1;
}

void sub_100BC4914(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100BC4994(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100BC4A6C);
  __cxa_rethrow();
}

void sub_100BC49BC(_Unwind_Exception *a1)
{
}

void sub_100BC49D4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BC4A0C(uint64_t a1)
{
}

uint64_t sub_100BC4A28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BC4A6C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100BC4A98(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100C93B3C(a1);
  *(void *)uint64_t v4 = off_101A4D900;
  *(unsigned char *)(v4 + 180) = 0;
  *(_WORD *)(v4 + 202) = 0;
  *(void *)(v4 + 208) = 0;
  uint64_t v5 = (const void **)(v4 + 208);
  *(void *)(v4 + 224) = 0;
  uint64_t v6 = (uint64_t *)(v4 + 224);
  *(unsigned char *)(v4 + 248) = 0;
  uint64_t v7 = (std::string *)(v4 + 248);
  *(unsigned char *)(v4 + 216) = 0;
  *(unsigned char *)(v4 + 272) = 0;
  uint64_t v8 = (std::string *)(v4 + 280);
  *(unsigned char *)(v4 + 280) = 0;
  *(unsigned char *)(v4 + 304) = 0;
  uint64_t v9 = v4 + 312;
  *(unsigned char *)(v4 + 312) = 0;
  *(unsigned char *)(v4 + 336) = 0;
  *(unsigned char *)(v4 + 344) = 0;
  *(void *)(v4 + 148) = 0;
  *(void *)(v4 + 164) = 0;
  *(void *)(v4 + 156) = 0;
  *(void *)(v4 + 169) = 0;
  *(void *)(v4 + 184) = 0;
  *(void *)(v4 + 192) = 0;
  *(unsigned char *)(v4 + 200) = 0;
  *(void *)(v4 + 232) = 0;
  *(void *)(v4 + 240) = 0;
  sub_100BC4C70((std::string *)v4, (const std::string *)a2);
  long long v10 = *(_OWORD *)(a2 + 144);
  long long v11 = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 172) = *(_OWORD *)(a2 + 172);
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 160) = v11;
  *(_DWORD *)(a1 + 188) = *(_DWORD *)(a2 + 188);
  uint64_t v12 = *(void *)(a2 + 192);
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(a2 + 200);
  *(void *)(a1 + 192) = v12;
  sub_100058140(v5, (const void **)(a2 + 208));
  *(unsigned char *)(a1 + 216) = *(unsigned char *)(a2 + 216);
  if (a1 != a2) {
    sub_100BC4CC8(v6, *(long long **)(a2 + 224), *(long long **)(a2 + 232), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 232) - *(void *)(a2 + 224)) >> 3));
  }
  sub_100179AF8(v7, (const std::string *)(a2 + 248));
  sub_100179AF8(v8, (const std::string *)(a2 + 280));
  sub_100BC50D8(v9, a2 + 312);
  *(unsigned char *)(a1 + 344) = *(unsigned char *)(a2 + 344);
  return a1;
}

void sub_100BC4C00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(unsigned char *)(v2 + 336))
  {
    uint64_t v8 = *v6;
    if (*v6)
    {
      *(void *)(v2 + 320) = v8;
      operator delete(v8);
    }
  }
  if (*(unsigned char *)(v2 + 304) && *(char *)(v2 + 303) < 0) {
    operator delete(*v5);
  }
  if (*(unsigned char *)(v2 + 272))
  {
    if (*(char *)(v2 + 271) < 0) {
      operator delete(*v4);
    }
  }
  sub_100BC5188((void ***)va);
  sub_100057D78(v3);
  sub_100C93C98(v2);
  _Unwind_Resume(a1);
}

std::string *sub_100BC4C70(std::string *a1, const std::string *a2)
{
  std::string::operator=(a1 + 2, a2 + 2);
  std::string::operator=(a1 + 3, a2 + 3);
  std::string::operator=(a1 + 4, a2 + 4);
  std::string::operator=(a1 + 5, a2 + 5);
  return a1;
}

void sub_100BC4CC8(uint64_t *a1, long long *a2, long long *a3, unint64_t a4)
{
  uint64_t v8 = (uint64_t)(a1 + 2);
  uint64_t v9 = *a1;
  if (0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3) < a4)
  {
    sub_100BC4E70(a1);
    if (a4 > 0x492492492492492) {
      sub_10006A748();
    }
    unint64_t v10 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3)) >= 0x249249249249249) {
      unint64_t v11 = 0x492492492492492;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_10034235C(a1, v11);
    uint64_t v12 = sub_100BC4EAC(v8, a2, a3, a1[1]);
    goto LABEL_11;
  }
  if (0x6DB6DB6DB6DB6DB7 * ((a1[1] - v9) >> 3) < a4)
  {
    uint64_t v13 = (long long *)((char *)a2 + 8 * ((a1[1] - v9) >> 3));
    sub_100BC4FF4((uint64_t)&v18, (uint64_t)a2, (uint64_t)v13, v9);
    uint64_t v12 = sub_100BC4EAC(v8, v13, a3, a1[1]);
LABEL_11:
    a1[1] = v12;
    return;
  }
  sub_100BC4FF4((uint64_t)&v19, (uint64_t)a2, (uint64_t)a3, v9);
  uint64_t v15 = v14;
  uint64_t v16 = a1[1];
  if (v16 != v14)
  {
    do
    {
      uint64_t v17 = *(void **)(v16 - 32);
      if (v17)
      {
        *(void *)(v16 - 24) = v17;
        operator delete(v17);
      }
      v16 -= 56;
    }
    while (v16 != v15);
  }
  a1[1] = v15;
}

void sub_100BC4E60(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100BC4E68(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100BC4E70(uint64_t *a1)
{
  if (*a1)
  {
    sub_100BC5088(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_100BC4EAC(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  void v9[2] = &v12;
  uint64_t v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      long long v7 = *v6;
      *(void *)(v4 + 16) = *((void *)v6 + 2);
      *(_OWORD *)uint64_t v4 = v7;
      *(void *)(v4 + 32) = 0;
      *(void *)(v4 + 40) = 0;
      *(void *)(v4 + 24) = 0;
      sub_100448664((void *)(v4 + 24), *((const void **)v6 + 3), *((void *)v6 + 4), (uint64_t)(*((void *)v6 + 4) - *((void *)v6 + 3)) >> 2);
      *(unsigned char *)(v4 + 48) = *((unsigned char *)v6 + 48);
      uint64_t v4 = v12 + 56;
      v12 += 56;
      uint64_t v6 = (long long *)((char *)v6 + 56);
    }
    while (v6 != a3);
  }
  LOBYTE(v10) = 1;
  sub_100BC4F74((uint64_t)v9);
  return v4;
}

void sub_100BC4F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100BC4F74(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100BC4FAC(a1);
  }
  return a1;
}

void sub_100BC4FAC(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)(v1 - 32);
    if (v3)
    {
      *(void *)(v1 - 24) = v3;
      operator delete(v3);
    }
    v1 -= 56;
  }
}

uint64_t sub_100BC4FF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v5 = a3;
  uint64_t v6 = a2 + 32;
  do
  {
    uint64_t v7 = v6 - 32;
    long long v8 = *(_OWORD *)(v6 - 32);
    *(void *)(a4 + 16) = *(void *)(v6 - 16);
    *(_OWORD *)a4 = v8;
    if (a4 != v6 - 32) {
      sub_10008A534((char *)(a4 + 24), *(char **)(v6 - 8), *(void *)v6, (uint64_t)(*(void *)v6 - *(void *)(v6 - 8)) >> 2);
    }
    *(unsigned char *)(a4 + 48) = *(unsigned char *)(v6 + 16);
    a4 += 56;
    v6 += 56;
  }
  while (v7 + 56 != v5);
  return v5;
}

void sub_100BC5088(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 56)
  {
    uint64_t v4 = *(void **)(i - 32);
    if (v4)
    {
      *(void *)(i - 24) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void sub_100BC50D8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 24))
    {
      uint64_t v3 = *(void *)(a2 + 8);
      unint64_t v4 = (v3 - *(void *)a2) >> 2;
      uint64_t v5 = *(char **)a2;
      sub_10008A534((char *)a1, v5, v3, v4);
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v6 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v6;
      operator delete(v6);
    }
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_100448664((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    *(unsigned char *)(a1 + 24) = 1;
  }
}

void sub_100BC5188(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100BC5088((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

uint64_t sub_100BC51DC(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v7 = sub_100C93B3C(a1);
  *(void *)uint64_t v7 = off_101A4D900;
  *(_DWORD *)(v7 + 144) = a3;
  *(_DWORD *)(a1 + 148) = a4 + 100 * a3 + 1000 * subscriber::simSlotAsInstance();
  *(unsigned char *)(a1 + 180) = 0;
  *(_WORD *)(a1 + 202) = 0;
  *(void *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 216) = 0;
  *(unsigned char *)(a1 + 272) = 0;
  *(unsigned char *)(a1 + 280) = 0;
  *(unsigned char *)(a1 + 304) = 0;
  *(unsigned char *)(a1 + 312) = 0;
  *(unsigned char *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 344) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 152) = 0;
  *(unsigned char *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(unsigned char *)(a1 + 248) = 0;
  *(void *)(a1 + 240) = 0;
  return a1;
}

void sub_100BC529C(_Unwind_Exception *a1)
{
  sub_100C93C98(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100BC52B0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100BC5328((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100BC5328(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v12[0] = a1;
  v12[1] = &v13;
  void v12[2] = &v14;
  v12[3] = 1;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v14 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v14;
  }
  sub_100BC53B8((uint64_t)v12);
  return v10;
}

uint64_t sub_100BC53B8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1006C5960(a1);
  }
  return a1;
}

char *sub_100BC53F0(int64x2_t *a1, long long *a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1->i64[1] - a1->i64[0]) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x555555555555555) {
    sub_10006A748();
  }
  uint64_t v6 = a1 + 1;
  if (0x5555555555555556 * ((a1[1].i64[0] - a1->i64[0]) >> 4) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[1].i64[0] - a1->i64[0]) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[1].i64[0] - a1->i64[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v7 = 0x555555555555555;
  }
  else {
    unint64_t v7 = v3;
  }
  int v26 = (uint64_t *)v6;
  if (v7)
  {
    long long v9 = (char *)sub_100A52878(v7);
  }
  else
  {
    long long v9 = 0;
    uint64_t v8 = 0;
  }
  uint64_t v10 = &v9[48 * v2];
  uint64_t v23 = v9;
  v24.i64[0] = (uint64_t)v10;
  v24.i64[1] = (uint64_t)v10;
  uint64_t v25 = &v9[48 * v8];
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(v10, *(void **)a2, *((void *)a2 + 1));
    uint64_t v12 = (char *)v24.i64[1];
    uint64_t v10 = (char *)v24.i64[0];
  }
  else
  {
    long long v11 = *a2;
    *((void *)v10 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v10 = v11;
    uint64_t v12 = &v9[48 * v2];
  }
  long long v13 = &v9[48 * v2];
  long long v14 = *(long long *)((char *)a2 + 24);
  *(void *)(v13 + 38) = *(void *)((char *)a2 + 38);
  *(_OWORD *)(v13 + 24) = v14;
  uint64_t v15 = a1->i64[0];
  unint64_t v16 = a1->u64[1];
  if (v16 == a1->i64[0])
  {
    int64x2_t v19 = vdupq_n_s64(v16);
  }
  else
  {
    do
    {
      long long v17 = *(_OWORD *)(v16 - 48);
      *((void *)v10 - 4) = *(void *)(v16 - 32);
      *((_OWORD *)v10 - 3) = v17;
      *(void *)(v16 - 40) = 0;
      *(void *)(v16 - 32) = 0;
      *(void *)(v16 - 48) = 0;
      long long v18 = *(_OWORD *)(v16 - 24);
      *(void *)(v10 - 10) = *(void *)(v16 - 10);
      *(_OWORD *)(v10 - 24) = v18;
      v10 -= 48;
      v16 -= 48;
    }
    while (v16 != v15);
    int64x2_t v19 = *a1;
  }
  uint64_t v20 = v12 + 48;
  a1->i64[0] = (uint64_t)v10;
  a1->i64[1] = (uint64_t)(v12 + 48);
  int64x2_t v24 = v19;
  BOOL v21 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v25;
  uint64_t v25 = v21;
  uint64_t v23 = (char *)v19.i64[0];
  sub_100BC558C((uint64_t)&v23);
  return v20;
}

void sub_100BC5578(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100BC558C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100BC558C(uint64_t a1)
{
  unint64_t v3 = *(void ***)(a1 + 8);
  unint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      unint64_t v4 = v2 - 6;
      *(void *)(a1 + 16) = v2 - 6;
      if (*((char *)v2 - 25) < 0)
      {
        operator delete(*v4);
        unint64_t v4 = *(void ***)(a1 + 16);
      }
      unint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100BC55F0(void ***a1)
{
  unint64_t v2 = *a1;
  if (*v2)
  {
    sub_100BC5644((uint64_t *)v2);
    unint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_100BC5644(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 48)
  {
    if (*(char *)(i - 25) < 0) {
      operator delete(*(void **)(i - 48));
    }
  }
  a1[1] = v2;
}

char *sub_100BC5694(int64x2_t *a1, long long *a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1->i64[1] - a1->i64[0]) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x555555555555555) {
    sub_10006A748();
  }
  uint64_t v6 = a1 + 1;
  if (0x5555555555555556 * ((a1[1].i64[0] - a1->i64[0]) >> 4) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[1].i64[0] - a1->i64[0]) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[1].i64[0] - a1->i64[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v7 = 0x555555555555555;
  }
  else {
    unint64_t v7 = v3;
  }
  int v26 = (uint64_t *)v6;
  if (v7)
  {
    long long v9 = (char *)sub_100A52878(v7);
  }
  else
  {
    long long v9 = 0;
    uint64_t v8 = 0;
  }
  uint64_t v10 = &v9[48 * v2];
  uint64_t v23 = v9;
  v24.i64[0] = (uint64_t)v10;
  v24.i64[1] = (uint64_t)v10;
  uint64_t v25 = &v9[48 * v8];
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(v10, *(void **)a2, *((void *)a2 + 1));
    uint64_t v12 = (char *)v24.i64[1];
    uint64_t v10 = (char *)v24.i64[0];
  }
  else
  {
    long long v11 = *a2;
    *((void *)v10 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v10 = v11;
    uint64_t v12 = &v9[48 * v2];
  }
  long long v13 = &v9[48 * v2];
  long long v14 = *(long long *)((char *)a2 + 24);
  *(void *)(v13 + 38) = *(void *)((char *)a2 + 38);
  *(_OWORD *)(v13 + 24) = v14;
  uint64_t v15 = a1->i64[0];
  unint64_t v16 = a1->u64[1];
  if (v16 == a1->i64[0])
  {
    int64x2_t v19 = vdupq_n_s64(v16);
  }
  else
  {
    do
    {
      long long v17 = *(_OWORD *)(v16 - 48);
      *((void *)v10 - 4) = *(void *)(v16 - 32);
      *((_OWORD *)v10 - 3) = v17;
      *(void *)(v16 - 40) = 0;
      *(void *)(v16 - 32) = 0;
      *(void *)(v16 - 48) = 0;
      long long v18 = *(_OWORD *)(v16 - 24);
      *(void *)(v10 - 10) = *(void *)(v16 - 10);
      *(_OWORD *)(v10 - 24) = v18;
      v10 -= 48;
      v16 -= 48;
    }
    while (v16 != v15);
    int64x2_t v19 = *a1;
  }
  uint64_t v20 = v12 + 48;
  a1->i64[0] = (uint64_t)v10;
  a1->i64[1] = (uint64_t)(v12 + 48);
  int64x2_t v24 = v19;
  BOOL v21 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v25;
  uint64_t v25 = v21;
  uint64_t v23 = (char *)v19.i64[0];
  sub_100BC558C((uint64_t)&v23);
  return v20;
}

void sub_100BC581C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100BC558C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100BC5830(uint64_t a1, std::string *__str, long long *a3, unint64_t a4)
{
  uint64_t v9 = a1 + 16;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v10 = *(std::string **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)a1) >> 4) < a4)
  {
    if (v10)
    {
      sub_100BC5644((uint64_t *)a1);
      operator delete(*(void **)a1);
      uint64_t v8 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    if (a4 > 0x555555555555555) {
      sub_10006A748();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 4);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= a4) {
      uint64_t v12 = a4;
    }
    if (v11 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v13 = 0x555555555555555;
    }
    else {
      unint64_t v13 = v12;
    }
    sub_100B066E4((void *)a1, v13);
    long long v14 = sub_100BC59B0(v9, (long long *)__str, a3, *(char **)(a1 + 8));
    goto LABEL_13;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v10) >> 4) < a4)
  {
    uint64_t v15 = (std::string *)((char *)__str + 16 * ((uint64_t)(*(void *)(a1 + 8) - (void)v10) >> 4));
    sub_100BC5AE0(__str, v15, v10);
    long long v14 = sub_100BC59B0(v9, (long long *)v15, a3, *(char **)(a1 + 8));
LABEL_13:
    *(void *)(a1 + 8) = v14;
    return;
  }
  unint64_t v16 = sub_100BC5AE0(__str, (std::string *)a3, v10);
  for (uint64_t i = *(std::string **)(a1 + 8); i != v16; i -= 2)
  {
    if (SHIBYTE(i[-2].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(i[-2].__r_.__value_.__l.__data_);
    }
  }
  *(void *)(a1 + 8) = v16;
}

void sub_100BC59A0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100BC59A8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

char *sub_100BC59B0(uint64_t a1, long long *a2, long long *a3, char *__dst)
{
  unint64_t v4 = __dst;
  unint64_t v13 = __dst;
  long long v14 = __dst;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  uint64_t v12 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_10004FC84(v4, *(void **)v6, *((void *)v6 + 1));
        uint64_t v8 = v14;
      }
      else
      {
        long long v7 = *v6;
        *((void *)v4 + 2) = *((void *)v6 + 2);
        *(_OWORD *)unint64_t v4 = v7;
        uint64_t v8 = v4;
      }
      long long v9 = *(long long *)((char *)v6 + 24);
      *(void *)(v4 + 38) = *(void *)((char *)v6 + 38);
      *(_OWORD *)(v4 + 24) = v9;
      v6 += 3;
      unint64_t v4 = v8 + 48;
      long long v14 = v8 + 48;
    }
    while (v6 != a3);
  }
  LOBYTE(v12) = 1;
  sub_100BC5A80((uint64_t)v11);
  return v4;
}

void sub_100BC5A6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100BC5A80(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void **)(a1 + 8);
    for (uint64_t i = **(void **)(a1 + 16); i != v3; i -= 48)
    {
      if (*(char *)(i - 25) < 0) {
        operator delete(*(void **)(i - 48));
      }
    }
  }
  return a1;
}

std::string *sub_100BC5AE0(std::string *__str, std::string *a2, std::string *this)
{
  if (__str != a2)
  {
    uint64_t v5 = __str;
    do
    {
      std::string::operator=(this, v5);
      std::string::size_type v6 = *(std::string::size_type *)((char *)&v5[1].__r_.__value_.__r.__words[1] + 6);
      *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = *(_OWORD *)&v5[1].__r_.__value_.__l.__data_;
      *(std::string::size_type *)((char *)&this[1].__r_.__value_.__r.__words[1] + 6) = v6;
      this += 2;
      v5 += 2;
    }
    while (v5 != a2);
  }
  return this;
}

void sub_100BC5B48(uint64_t a1)
{
  *(void *)a1 = off_101A442A0;
  sub_100BC61EC(*(char **)(a1 + 424));
  sub_10005D144(*(void **)(a1 + 400));
  if (*(char *)(a1 + 383) < 0) {
    operator delete(*(void **)(a1 + 360));
  }
  if (*(char *)(a1 + 359) < 0) {
    operator delete(*(void **)(a1 + 336));
  }
  sub_10005D144(*(void **)(a1 + 320));
  uint64_t v5 = (void **)(a1 + 288);
  sub_10005CBF0(&v5);
  sub_100BC6188(*(char **)(a1 + 272));
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 96));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  PDPConfigInterface::~PDPConfigInterface((PDPConfigInterface *)a1);
}

void sub_100BC5C4C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BC5C84(uint64_t a1)
{
}

uint64_t sub_100BC5CA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BC5CE4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100BC5D10(ServiceManager::Service *this)
{
  *(void *)this = off_101A444C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100BC5D6C(ServiceManager::Service *this)
{
  *(void *)this = off_101A444C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100BC5DDC@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "DarwinPDPConfig");
}

unsigned char *sub_100BC5DEC@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100BC5E28(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  uint64_t v4 = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
    sub_100BBB2D0(v2, &v4);
  }
  sub_100BBB2D0(v2, &v4);
}

uint64_t sub_100BC5EB0()
{
  return 0;
}

uint64_t sub_100BC5EB8()
{
  return 1;
}

uint64_t sub_100BC5EC0()
{
  return 0;
}

void sub_100BC5ECC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPConfig: start 1 ...", buf, 2u);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3 && std::__shared_weak_count::lock(v3))
  {
    uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
    if (v4)
    {
      if (std::__shared_weak_count::lock(v4)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  sub_100088B9C();
}

void sub_100BC6010(uint64_t a1, uint64_t a2, ServiceStage *a3)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  isa = v4[5].isa;
  if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(group[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, isa, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPConfig: shutting down ...", (uint8_t *)group, 2u);
  }
  group[0] = v4;
  ServiceStage::holdOffStage((uint64_t *)&group[1], a3);
  std::string::size_type v6 = (std::__shared_weak_count *)v4[2].isa;
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BC6168()
{
}

uint64_t sub_100BC617C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100BC6188(char *a1)
{
  if (a1)
  {
    sub_100BC6188(*(void *)a1);
    sub_100BC6188(*((void *)a1 + 1));
    uint64_t v2 = (void **)(a1 + 104);
    sub_10005CBF0(&v2);
    std::mutex::~mutex((std::mutex *)(a1 + 40));
    operator delete(a1);
  }
}

void sub_100BC61EC(char *a1)
{
  if (a1)
  {
    sub_100BC61EC(*(void *)a1);
    sub_100BC61EC(*((void *)a1 + 1));
    uint64_t v2 = (void **)(a1 + 40);
    sub_100BC55F0(&v2);
    operator delete(a1);
  }
}

uint64_t **sub_100BC6250(uint64_t **a1, int a2, _DWORD *a3)
{
  std::string::size_type v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        long long v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        std::string::size_type v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        std::string::size_type v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    long long v7 = a1 + 1;
LABEL_9:
    long long v9 = (uint64_t *)v7;
    long long v7 = (uint64_t **)operator new(0x80uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[5] = (uint64_t *)850045863;
    *((_OWORD *)v7 + 3) = 0u;
    *((_OWORD *)v7 + 4) = 0u;
    *((_OWORD *)v7 + 5) = 0u;
    *((_OWORD *)v7 + 6) = 0u;
    *((_OWORD *)v7 + 7) = 0u;
    *long long v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *std::string::size_type v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    unint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t **sub_100BC6338(uint64_t **a1, int a2, _DWORD *a3)
{
  std::string::size_type v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        long long v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        std::string::size_type v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        std::string::size_type v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    long long v7 = a1 + 1;
LABEL_9:
    long long v9 = (uint64_t *)v7;
    long long v7 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v7 + 7) = *a3;
    void v7[4] = 0;
    *((_DWORD *)v7 + 10) = 0;
    *long long v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *std::string::size_type v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    unint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t *sub_100BC640C@<X0>(void **a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *a1;
  uint64_t v22 = a1;
  uint64_t v23 = v2;
  uint64_t v3 = *v2;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(*v2 + 56));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    long long v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  dispatch_group_t group = (dispatch_group_t)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&group);
  if (v10)
  {
    uint64_t v12 = v10[3];
    unint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_16;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  unint64_t v11 = 0;
  char v13 = 1;
  if (!v12) {
    goto LABEL_16;
  }
LABEL_10:
  long long v14 = v2[1];
  dispatch_group_t group = v14;
  if (v14)
  {
    dispatch_retain(v14);
    if (group) {
      dispatch_group_enter(group);
    }
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v12 + 32))(v12, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
LABEL_16:
  int v15 = *(_DWORD *)(v3 + 384);
  if (v15 != -1)
  {
    notify_cancel(v15);
    *(_DWORD *)(v3 + 384) = -1;
  }
  unint64_t v16 = *(uint64_t **)(v3 + 288);
  for (uint64_t i = *(uint64_t **)(v3 + 296); v16 != i; v16 += 2)
  {
    uint64_t v18 = *v16;
    int64x2_t v19 = (std::__shared_weak_count *)v16[1];
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t))(*(void *)v18 + 48))(v18);
    if (v19) {
      sub_10004D2C8(v19);
    }
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v3 + 72));
  uint64_t v20 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPConfig: shut down !", buf, 2u);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  sub_100088C88((uint64_t *)&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_100BC6628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BC6690(void **a1)
{
  uint64_t v1 = *a1;
  CFNumberRef v49 = a1;
  uint64_t v50 = v1;
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  CFTypeID v48 = v1;
  dispatch_group_t group = v2;
  if (v2)
  {
    dispatch_retain(v2);
    dispatch_group_enter(v2);
  }
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPConfig: bootstrap 2...", buf, 2u);
  }
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = sub_100BBB060;
  uint64_t v60 = &unk_101A44370;
  uint64_t v61 = v3;
  uint32_t v5 = notify_register_dispatch("com.apple.system.config.network_change.dns", (int *)(v3 + 384), *(dispatch_queue_t *)(v3 + 24), buf);
  uint64_t v6 = *(NSObject **)(v3 + 40);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      LOWORD(v58[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I dnsNotificationHandler: failed to register", (uint8_t *)v58, 2u);
    }
    uint64_t v8 = 0xFFFFFFFFLL;
    *(_DWORD *)(v3 + 384) = -1;
  }
  else if (v7)
  {
    LOWORD(v58[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I dnsNotificationHandler: registered successfully", (uint8_t *)v58, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v8, *(Registry **)(v3 + 56));
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v11;
  int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (!v15)
  {
    uint64_t v17 = 0;
    goto LABEL_18;
  }
  uint64_t v17 = v15[3];
  unint64_t v16 = (std::__shared_weak_count *)v15[4];
  if (!v16)
  {
LABEL_18:
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_19;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
LABEL_19:
  if (!v17 || !(*(unsigned int (**)(uint64_t))(*(void *)v17 + 32))(v17)) {
    goto LABEL_41;
  }
  int64x2_t v19 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I configuring DNS overrides", buf, 2u);
  }
  sub_100BBB9F0(buf, @"FakePrimaryDns");
  uint64_t v20 = (void **)(v3 + 336);
  if (*(char *)(v3 + 359) < 0) {
    operator delete(*v20);
  }
  *(_OWORD *)uint64_t v20 = *(_OWORD *)buf;
  *(void *)(v3 + 352) = *(void *)&buf[16];
  sub_100BBB9F0(buf, @"FakeSecondaryDns");
  BOOL v21 = (void **)(v3 + 360);
  if (*(char *)(v3 + 383) < 0) {
    operator delete(*v21);
  }
  *(_OWORD *)BOOL v21 = *(_OWORD *)buf;
  *(void *)(v3 + 376) = *(void *)&buf[16];
  char v22 = *(unsigned char *)(v3 + 359);
  if (v22 < 0)
  {
    if (!*(void *)(v3 + 344)) {
      goto LABEL_31;
    }
  }
  else if (!*(unsigned char *)(v3 + 359))
  {
LABEL_31:
    if (*(char *)(v3 + 383) < 0)
    {
      if (!*(void *)(v3 + 368)) {
        goto LABEL_41;
      }
    }
    else if (!*(unsigned char *)(v3 + 383))
    {
      goto LABEL_41;
    }
  }
  uint64_t v23 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (v22 < 0) {
      uint64_t v20 = (void **)*v20;
    }
    if (*(char *)(v3 + 383) < 0) {
      BOOL v21 = (void **)*v21;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v20;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v21;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Fake primary DNS: %s, fake secondary DNS: %s", buf, 0x16u);
  }
LABEL_41:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  Registry::createRestModuleOneTimeUseConnection(&v52, *(Registry **)(v3 + 56));
  ctu::RestModule::connect();
  if (v53) {
    sub_10004D2C8(v53);
  }
  uint64_t v60 = 0;
  v58[3] = 0;
  v57[3] = 0;
  PersonalitiesTracker::bind();
  sub_100100490(v57);
  sub_10010040C(v58);
  int64x2_t v24 = (capabilities::ct *)sub_100100388(buf);
  uint64_t v25 = capabilities::ct::supportedPDPContextCount(v24);
  int v26 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I creating PDP Managers", buf, 2u);
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v27 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  uint64_t v28 = dispatch_queue_create("SCWriteQueuePDP", v27);
  uint64_t v29 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  uint64_t v30 = dispatch_queue_create("IPConfigurationQueuePDP", v29);
  if (v25)
  {
    uint64_t v31 = *(void *)(v3 + 64);
    v57[0] = *(void *)(v3 + 56);
    v57[1] = v31;
    if (v31) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v32 = *(NSObject **)(v3 + 24);
    uint64_t v56 = v32;
    if (v32) {
      dispatch_retain(v32);
    }
    uint64_t v55 = v28;
    if (v28) {
      dispatch_retain(v28);
    }
    uint64_t v54 = v30;
    if (v30) {
      dispatch_retain(v30);
    }
    sub_10027BAE8(v58);
  }
  if (v30) {
    dispatch_release(v30);
  }
  if (v28) {
    dispatch_release(v28);
  }
  uint64_t v33 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v58[0]) = 134218240;
    *(void ***)((char *)v58 + 4) = (void **)((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 4);
    WORD2(v58[1]) = 2048;
    *(void ***)((char *)&v58[1] + 6) = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I created %lu/%lu PDP Managers", (uint8_t *)v58, 0x16u);
  }
  if (*(void *)(v3 + 288))
  {
    sub_10019E028((uint64_t *)(v3 + 288));
    operator delete(*(void **)(v3 + 288));
    *(void *)(v3 + 288) = 0;
    *(void *)(v3 + 296) = 0;
    *(void *)(v3 + 304) = 0;
  }
  *(_OWORD *)(v3 + 288) = *(_OWORD *)buf;
  *(void *)(v3 + 304) = *(void *)&buf[16];
  memset(buf, 0, sizeof(buf));
  v58[0] = (void **)buf;
  sub_10005CBF0(v58);
  BOOL v34 = (uint64_t *)(*(void *)(v3 + 296) - *(void *)(v3 + 288));
  uint64_t v35 = (uint64_t)v34 >> 4;
  if ((uint64_t)v34 >> 4)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "Wrong size of the PDPManagers vector";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CommCenter/Source/CSI/DarwinPDPConfig.cpp";
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v60) = 206;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT fPacketHandlers.size() == contextCount\n %s\n at %s:%d\n**********", buf, 0x1Cu);
      BOOL v34 = (uint64_t *)(*(void *)(v3 + 296) - *(void *)(v3 + 288));
      uint64_t v35 = (uint64_t)v34 >> 4;
    }
    if (v35) {
      __TUAssertTrigger();
    }
  }
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  int v36 = (std::mutex *)Registry::getServiceMap(v34, *(Registry **)(v3 + 56));
  uint64_t v37 = v36;
  if (v38 < 0)
  {
    CFTypeID v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v40 = 5381;
    do
    {
      uint64_t v38 = v40;
      unsigned int v41 = *v39++;
      uint64_t v40 = (33 * v40) ^ v41;
    }
    while (v41);
  }
  std::mutex::lock(v36);
  *(void *)long long buf = v38;
  uint64_t v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)buf);
  if (v42)
  {
    uint64_t v44 = v42[3];
    uint64_t v43 = (std::__shared_weak_count *)v42[4];
    if (v43)
    {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v37);
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v43);
      char v45 = 0;
      if (!v44) {
        goto LABEL_86;
      }
      goto LABEL_81;
    }
  }
  else
  {
    uint64_t v44 = 0;
  }
  std::mutex::unlock(v37);
  uint64_t v43 = 0;
  char v45 = 1;
  if (!v44) {
    goto LABEL_86;
  }
LABEL_81:
  int v46 = v48[1];
  *(void *)long long buf = v46;
  if (v46)
  {
    dispatch_retain(v46);
    dispatch_group_enter(v46);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v44 + 16))(v44, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
LABEL_86:
  if ((v45 & 1) == 0) {
    sub_10004D2C8(v43);
  }
  sub_100088C88((uint64_t *)&v50);
  return sub_100046B58((uint64_t *)&v49);
}

void sub_100BC6FBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, long long a11, uint64_t a12, uint64_t a13, dispatch_group_t group, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a13);
  sub_100046B58(&a12);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BC7124(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v53 = a1;
  uint64_t v54 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPConfig: start 2 ...", buf, 2u);
  }
  uint64_t v60 = 0;
  if (getifaddrs(&v60))
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "getifaddrs failed", buf, 2u);
    }
  }
  else
  {
    int v5 = socket(2, 2, 0);
    if (v5 < 0)
    {
      unsigned int v14 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "socket failed", buf, 2u);
      }
    }
    else
    {
      for (uint64_t i = v60; i; uint64_t i = i->ifa_next)
      {
        if (strnstr(i->ifa_name, "rd", 0x10uLL))
        {
          int v73 = 0;
          long long v71 = 0u;
          long long v72 = 0u;
          long long v69 = 0u;
          long long v70 = 0u;
          long long v67 = 0u;
          long long v68 = 0u;
          *(_OWORD *)__n = 0u;
          long long v66 = 0u;
          *(_OWORD *)long long buf = 0u;
          v58[1] = 0;
          uint64_t v59 = 0;
          v58[0] = 0;
          sub_100058DB0(v58, i->ifa_name);
          if (SHIBYTE(v59) >= 0) {
            BOOL v7 = v58;
          }
          else {
            BOOL v7 = (void **)v58[0];
          }
          strncpy((char *)buf, (const char *)v7, 0x10uLL);
          if (ioctl(v5, 0xC0946990uLL, buf) != -1
            && LODWORD(__n[0])
            && !strncmp((const char *)__n + 4, "CoreTelephonyHOVI", LODWORD(__n[0])))
          {
            uint64_t v8 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
            {
              if (SHIBYTE(v59) >= 0) {
                unsigned int v9 = v58;
              }
              else {
                unsigned int v9 = (void **)v58[0];
              }
              *(_DWORD *)uint64_t v76 = 136315138;
              *(void *)&v76[4] = v9;
              _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I deleting virtual interface %s", v76, 0xCu);
            }
            int v57 = 0;
            if (SHIBYTE(v59) < 0)
            {
              sub_10004FC84(__p, v58[0], (unint64_t)v58[1]);
            }
            else
            {
              *(_OWORD *)std::string __p = *(_OWORD *)v58;
              uint64_t v56 = v59;
            }
            if (SHIBYTE(v56) < 0)
            {
              sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
            }
            else
            {
              *(_OWORD *)long long __dst = *(_OWORD *)__p;
              int v75 = v56;
            }
            uint64_t v61 = 0;
            if (SHIBYTE(v75) < 0)
            {
              sub_10004FC84(v76, *(void **)__dst, *(unint64_t *)&__dst[8]);
            }
            else
            {
              *(_OWORD *)uint64_t v76 = *(_OWORD *)__dst;
              uint64_t v77 = v75;
            }
            uint64_t v62 = 0;
            if (ctu::cf::convert_copy())
            {
              uint64_t v10 = v61;
              uint64_t v61 = v62;
              uint64_t v63 = v10;
              sub_1000558F4(&v63);
            }
            if (SHIBYTE(v77) < 0) {
              operator delete(*(void **)v76);
            }
            int v57 = v61;
            uint64_t v61 = 0;
            sub_1000558F4(&v61);
            if (SHIBYTE(v75) < 0) {
              operator delete(*(void **)__dst);
            }
            if (SHIBYTE(v56) < 0) {
              operator delete(__p[0]);
            }
            RedirectFromName = (const void *)NEVirtualInterfaceCreateRedirectFromName();
            if (RedirectFromName)
            {
              NEVirtualInterfaceInvalidate();
              CFRelease(RedirectFromName);
            }
            else
            {
              uint64_t v12 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
              {
                if (SHIBYTE(v59) >= 0) {
                  uint64_t v13 = v58;
                }
                else {
                  uint64_t v13 = (void **)v58[0];
                }
                *(_DWORD *)uint64_t v76 = 136315138;
                *(void *)&v76[4] = v13;
                _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "failed to create a reference to virtual interface %s", v76, 0xCu);
              }
            }
            sub_1000558F4(&v57);
          }
          if (SHIBYTE(v59) < 0) {
            operator delete(v58[0]);
          }
        }
      }
      close(v5);
    }
    freeifaddrs(v60);
  }
  int v15 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPConfig: start 3 ...", buf, 2u);
  }
  memset(v76, 0, sizeof(v76));
  uint64_t v77 = 0;
  uint64_t v17 = *(uint64_t **)(v2 + 264);
  if (v17 != (uint64_t *)(v2 + 272))
  {
    char v18 = 0;
    do
    {
      if (v18 >= v77)
      {
        int64x2_t v19 = *(char **)v76;
        uint64_t v20 = (uint64_t)&v18[-*(void *)v76] >> 2;
        unint64_t v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v22 = (uint64_t)&v77[-*(void *)v76];
        if ((uint64_t)&v77[-*(void *)v76] >> 1 > v21) {
          unint64_t v21 = v22 >> 1;
        }
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v21;
        }
        if (v23)
        {
          int64x2_t v24 = (char *)sub_10005ECD8((uint64_t)&v77, v23);
          int64x2_t v19 = *(char **)v76;
          char v18 = *(char **)&v76[8];
        }
        else
        {
          int64x2_t v24 = 0;
        }
        uint64_t v25 = &v24[4 * v20];
        *(_DWORD *)uint64_t v25 = *((_DWORD *)v17 + 8);
        char v26 = v25 + 4;
        while (v18 != v19)
        {
          int v27 = *((_DWORD *)v18 - 1);
          v18 -= 4;
          *((_DWORD *)v25 - 1) = v27;
          v25 -= 4;
        }
        *(void *)uint64_t v76 = v25;
        *(void *)&v76[8] = v26;
        uint64_t v77 = &v24[4 * v23];
        if (v19) {
          operator delete(v19);
        }
        char v18 = v26;
      }
      else
      {
        *(_DWORD *)char v18 = *((_DWORD *)v17 + 8);
        v18 += 4;
      }
      *(void *)&v76[8] = v18;
      uint64_t v28 = (uint64_t *)v17[1];
      if (v28)
      {
        do
        {
          unint64_t v16 = v28;
          uint64_t v28 = (uint64_t *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          unint64_t v16 = (uint64_t *)v17[2];
          BOOL v29 = *v16 == (void)v17;
          uint64_t v17 = v16;
        }
        while (!v29);
      }
      uint64_t v17 = v16;
    }
    while (v16 != (uint64_t *)(v2 + 272));
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)(v2 + 56));
  uint64_t v31 = ServiceMap;
  if (v32 < 0)
  {
    uint64_t v33 = (unsigned __int8 *)(v32 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v34 = 5381;
    do
    {
      uint64_t v32 = v34;
      unsigned int v35 = *v33++;
      uint64_t v34 = (33 * v34) ^ v35;
    }
    while (v35);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v32;
  int v36 = sub_10004D37C(&v31[1].__m_.__sig, (unint64_t *)buf);
  if (v36)
  {
    uint64_t v38 = v36[3];
    uint64_t v37 = (std::__shared_weak_count *)v36[4];
    if (v37)
    {
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v31);
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v37);
      char v52 = 0;
      if (!v38) {
        goto LABEL_94;
      }
      goto LABEL_89;
    }
  }
  else
  {
    uint64_t v38 = 0;
  }
  std::mutex::unlock(v31);
  uint64_t v37 = 0;
  char v52 = 1;
  if (!v38) {
    goto LABEL_94;
  }
LABEL_89:
  (*(void (**)(uint64_t))(*(void *)v38 + 24))(v38);
  uint64_t v39 = *(void *)v76;
  uint64_t v40 = *(void *)&v76[8];
  while (v39 != v40)
  {
    sub_1006E3F34(v38, buf);
    (*(void (**)(void))(**(void **)buf + 64))(*(void *)buf);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    v39 += 4;
  }
LABEL_94:
  uint64_t v42 = *(unsigned int **)v76;
  for (uint64_t j = *(unsigned int **)&v76[8]; v42 != j; ++v42)
  {
    if (v38)
    {
      sub_100BBB920(v38, buf);
      int v43 = (*(uint64_t (**)(void))(**(void **)buf + 80))(*(void *)buf);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
    else
    {
      int v43 = 0;
    }
    uint64_t v44 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v42);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      WirelessTechnologyAsString();
      char v45 = (__n[0] & 0x8000000000000000) == 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)long long __dst = 136315138;
      *(void *)&__dst[4] = v45;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Default wireless technology is %s", __dst, 0xCu);
      if (SHIBYTE(__n[0]) < 0) {
        operator delete(*(void **)buf);
      }
    }
    sub_100BBBD10(v2, *v42, v43, 0);
  }
  int v46 = *(uint64_t **)(v2 + 288);
  for (CFIndex k = *(uint64_t **)(v2 + 296); v46 != k; v46 += 2)
  {
    uint64_t v48 = *v46;
    CFNumberRef v49 = (std::__shared_weak_count *)v46[1];
    if (v49) {
      atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    if (v49) {
      sub_10004D2C8(v49);
    }
  }
  sub_100058DB0(buf, "/cc/events/pdpConfig_started");
  *(void *)long long __dst = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(*(xpc_object_t *)__dst);
  *(void *)long long __dst = 0;
  if (SHIBYTE(__n[0]) < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v50 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPConfig: started !", buf, 2u);
  }
  if ((v52 & 1) == 0) {
    sub_10004D2C8(v37);
  }
  if (*(void *)v76)
  {
    *(void *)&v76[8] = *(void *)v76;
    operator delete(*(void **)v76);
  }
  sub_1000E1A60(&v54);
  return sub_100046B58((uint64_t *)&v53);
}

void sub_100BC7A28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,const void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  sub_1000558F4(&a31);
  if (*(char *)(v39 - 137) < 0) {
    operator delete(*(void **)(v39 - 160));
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  sub_1000E1A60(&a15);
  sub_100046B58(&a14);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BC7B74(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  sub_100BBF3A8(*(void *)v1, *(_DWORD *)(v1 + 8), v6);
  uint64_t v2 = *(void *)(v1 + 40);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v2 + 48))(v2, v6);
  BOOL v7 = v6;
  sub_10005CBF0(&v7);
  sub_100BC7C3C(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100BC7C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100BC7C3C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10023197C((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t **sub_100BC7C8C(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v7 = a1 + 1;
LABEL_9:
    unsigned int v9 = operator new(0x30uLL);
    v9[7] = *a3;
    *((void *)v9 + 4) = 0;
    *((void *)v9 + 5) = 0;
    sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t **sub_100BC7D38(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v7 = a1 + 1;
LABEL_9:
    unsigned int v9 = operator new(0x40uLL);
    uint8_t v9[8] = *a3;
    *((void *)v9 + 6) = 0;
    *((void *)v9 + 7) = 0;
    *((void *)v9 + 5) = 0;
    sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t sub_100BC7DE8(uint64_t a1)
{
  sub_100BC61EC(*(char **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_100BC61EC((char *)v2);
  }
  return a1;
}

void getPrivacyProxyFeatureEnabled(void *a1, uint64_t a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B10200, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = a1;
    uint64_t v5 = a2;
    int v6 = __cxa_guard_acquire(&qword_101B10200);
    a2 = v5;
    int v7 = v6;
    a1 = v4;
    if (v7)
    {
      ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B101F8, kCtLoggingSystemName, "npp");
      __cxa_guard_release(&qword_101B10200);
      a2 = v5;
      a1 = v4;
    }
  }
  if (*(void *)(a2 + 24))
  {
    uint64_t v2 = *a1;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3321888768;
    void v9[2] = sub_100BC7FF4;
    void v9[3] = &unk_101A445E0;
    sub_1000DFC90((uint64_t)v10, a2);
    +[PrivacyProxyClient getUserTier:v2 completionHandler:v9];
    sub_100060644(v10);
  }
  else
  {
    uint64_t v3 = qword_101B101F8;
    if (os_log_type_enabled((os_log_t)qword_101B101F8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "No callback provided to get privacy proxy feature enabled", v8, 2u);
    }
  }
}

void sub_100BC7FC4(_Unwind_Exception *a1)
{
}

void sub_100BC7FF4(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    int v6 = qword_101B101F8;
    if (os_log_type_enabled((os_log_t)qword_101B101F8, OS_LOG_TYPE_ERROR))
    {
      int v8 = 138412290;
      id v9 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Getting privacy proxy configuration returned %@", (uint8_t *)&v8, 0xCu);
    }
    char v7 = 0;
  }
  else
  {
    char v7 = a2 == 2;
  }
  sub_1000607A8(a1 + 32, v7);
}

void sub_100BC80CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void notifyPrivacyProxyOfChangeByUser(uint64_t a1, uint64_t *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B10210, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B10210))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B10208, kCtLoggingSystemName, "npp");
    __cxa_guard_release(&qword_101B10210);
  }
  id v4 = objc_alloc((Class)NSString);
  if (*((char *)a2 + 23) < 0) {
    a2 = (uint64_t *)*a2;
  }
  id v5 = [v4 initWithUTF8String:a2];
  +[PrivacyProxyClient reportCellularNetworkStatus:networkName:queue:completionHandler:](PrivacyProxyClient, "reportCellularNetworkStatus:networkName:queue:completionHandler:", a1);
}

void sub_100BC81C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100BC81F0(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  if (v2)
  {
    uint64_t v3 = qword_101B10208;
    if (os_log_type_enabled((os_log_t)qword_101B10208, OS_LOG_TYPE_ERROR))
    {
      int v4 = 138412290;
      id v5 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Reporting privacy proxy returned %@", (uint8_t *)&v4, 0xCu);
    }
  }
}

uint64_t sub_100BC82A4(uint64_t a1, os_log_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 24);
  if (v4)
  {
    *(_OWORD *)uint64_t v11 = 0u;
    long long v12 = 0u;
    *(_OWORD *)long long buf = 0u;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v4 + 48))(buf);
    __dst[0] = 0;
    __dst[1] = 0;
    id v9 = 0;
    if (SHIBYTE(v11[0]) < 0)
    {
      sub_10004FC84(__dst, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)buf;
      id v9 = v11[0];
    }
    int v6 = (void *)HIBYTE(v9);
    if (SHIBYTE(v9) < 0) {
      int v6 = __dst[1];
    }
    if (v6) {
      sub_1013BBA8C();
    }
    if ((HIBYTE(v9) & 0x80) != 0) {
      operator delete(__dst[0]);
    }
    if (SHIBYTE(v12) < 0) {
      operator delete(v11[1]);
    }
    if (SHIBYTE(v11[0]) < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    id v5 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Invalid PRI versions functor", buf, 2u);
    }
  }
  return 0;
}

void sub_100BC8788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  sub_1001085D8((uint64_t)&a27);
  _Unwind_Resume(a1);
}

const char *sub_100BC87FC(int a1)
{
  uint64_t result = "kNone";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = "kEmergency";
      break;
    case 2:
      uint64_t result = "kTryOut";
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_6;
    case 4:
      uint64_t result = "kFindMy";
      break;
    case 8:
      uint64_t result = "kRoadside";
      break;
    default:
      if (a1 == 16)
      {
        uint64_t result = "kIMessageLite";
      }
      else if (a1 == 32)
      {
        uint64_t result = "kSatSms";
      }
      else
      {
LABEL_6:
        uint64_t result = "???";
      }
      break;
  }
  return result;
}

uint64_t sub_100BC88BC(uint64_t result, uint64_t a2)
{
  int v2 = result & 0x3F;
  if ((result & 0x3F) != 0)
  {
    do
    {
      int v4 = v2 & -v2;
      v2 ^= v4;
      uint64_t result = sub_100BC8928(a2, v4);
    }
    while ((_WORD)v2);
  }
  return result;
}

uint64_t sub_100BC8928(uint64_t a1, __int16 a2)
{
  __int16 v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v2 + 48))(v2, &v4);
}

void sub_100BC897C(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  memset(&v13, 0, sizeof(v13));
  std::string __p = 0;
  std::string::size_type v11 = 0;
  uint64_t v12 = 0;
  sub_100058DB0(&__p, ", ");
  v14[0] = off_101A446D8;
  v14[1] = &v13;
  v14[2] = &__p;
  v14[3] = v14;
  sub_100BC88BC(a1, (uint64_t)v14);
  sub_10026ED50(v14);
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = v13.__r_.__value_.__l.__size_;
    if (v13.__r_.__value_.__l.__size_) {
      goto LABEL_5;
    }
LABEL_17:
    sub_100058DB0(a2, "kNone");
    goto LABEL_18;
  }
  if (!*((unsigned char *)&v13.__r_.__value_.__s + 23)) {
    goto LABEL_17;
  }
  std::string::size_type size = HIBYTE(v13.__r_.__value_.__r.__words[2]);
LABEL_5:
  std::string::size_type v5 = HIBYTE(v12);
  if (v12 < 0) {
    std::string::size_type v5 = v11;
  }
  if (size <= v5) {
    __assert_rtn("stewieServiceMaskToString", "StewieDefines_ios.cpp", 105, "result.size() > kSeparator.size()");
  }
  if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v6 = &v13;
  }
  else {
    int v6 = (std::string *)v13.__r_.__value_.__r.__words[0];
  }
  if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v7 = HIBYTE(v13.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v7 = v13.__r_.__value_.__l.__size_;
  }
  int v8 = (char *)v6 + v7;
  id v9 = (char *)&v13 + HIBYTE(v13.__r_.__value_.__r.__words[2]);
  if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    id v9 = (char *)(v13.__r_.__value_.__r.__words[0] + v13.__r_.__value_.__l.__size_);
  }
  std::string::erase(&v13, &v8[-v5] - (char *)v6, v9 - &v8[-v5]);
  *a2 = v13;
  memset(&v13, 0, sizeof(v13));
LABEL_18:
  if (SHIBYTE(v12) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
}

void sub_100BC8B24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100BC8B6C(unsigned int a1)
{
  if (a1 > 0xA) {
    return "???";
  }
  else {
    return off_101A44748[a1];
  }
}

const char *sub_100BC8B90(unsigned int a1)
{
  if (a1 > 0x10) {
    return "???";
  }
  else {
    return off_101A447A0[a1];
  }
}

const char *sub_100BC8BB4(unsigned int a1)
{
  if (a1 > 0xA) {
    return "???";
  }
  else {
    return off_101A44828[(char)a1];
  }
}

uint64_t sub_100BC8BDC(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(unsigned char **)a1;
    uint64_t v2 = (unsigned char *)(*(void *)a1 + *(void *)(a1 + 8));
  }
  else
  {
    uint64_t v2 = (unsigned char *)(a1 + *(unsigned __int8 *)(a1 + 23));
    uint64_t v3 = (unsigned char *)a1;
  }
  while (v3 != v2)
  {
    *uint64_t v3 = __tolower(*v3);
    ++v3;
  }
  sub_100058DB0(v30, "emergency");
  __int16 v31 = 1;
  sub_100058DB0(v32, "findmy");
  __int16 v33 = 4;
  sub_100058DB0(v34, "roadside");
  __int16 v35 = 8;
  sub_100058DB0(v36, "imessagelite");
  __int16 v37 = 16;
  sub_100058DB0(v38, "satsms");
  __int16 v4 = 0;
  uint64_t v5 = 0;
  __int16 v39 = 32;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  int v27 = &v28;
  int v6 = &v28;
  while (1)
  {
    std::string::size_type v7 = (void **)&v30[4 * v5];
    if (v6 == &v28)
    {
      id v9 = &v28;
    }
    else
    {
      int v8 = &v28;
      if (v4)
      {
        do
        {
          id v9 = (uint64_t **)v4;
          __int16 v4 = (uint64_t *)v4[1];
        }
        while (v4);
      }
      else
      {
        do
        {
          id v9 = (uint64_t **)v8[2];
          BOOL v10 = *v9 == (uint64_t *)v8;
          int v8 = v9;
        }
        while (v10);
      }
      char v11 = sub_100046FE8(v9 + 4, (void **)&v30[4 * v5]);
      __int16 v4 = v28;
      if ((v11 & 0x80) == 0)
      {
        uint64_t v12 = &v28;
        std::string v13 = &v28;
        if (v28)
        {
          std::string v13 = &v28;
          do
          {
            while (1)
            {
              uint64_t v12 = (uint64_t **)v4;
              unsigned int v14 = v4 + 4;
              if ((sub_100046FE8(&v30[4 * v5], (void **)v4 + 4) & 0x80) == 0) {
                break;
              }
              __int16 v4 = *v12;
              std::string v13 = v12;
              if (!*v12) {
                goto LABEL_25;
              }
            }
            if ((sub_100046FE8(v14, (void **)&v30[4 * v5]) & 0x80) == 0) {
              goto LABEL_24;
            }
            std::string v13 = v12 + 1;
            __int16 v4 = v12[1];
          }
          while (v4);
        }
LABEL_25:
        int v15 = (char *)operator new(0x40uLL);
        unint64_t v16 = v15 + 32;
        if (*((char *)v7 + 23) < 0)
        {
          sub_10004FC84(v16, *v7, (unint64_t)v7[1]);
        }
        else
        {
          *(_OWORD *)unint64_t v16 = *(_OWORD *)v7;
          *((void *)v15 + 6) = v7[2];
        }
        *((_WORD *)v15 + 28) = v30[4 * v5 + 3];
        *(void *)int v15 = 0;
        *((void *)v15 + 1) = 0;
        *((void *)v15 + 2) = v12;
        char *v13 = (uint64_t *)v15;
        if (*v27)
        {
          int v27 = (uint64_t **)*v27;
          int v15 = (char *)*v13;
        }
        sub_100046C90(v28, (uint64_t *)v15);
        ++v29;
        goto LABEL_31;
      }
    }
    uint64_t v12 = &v28;
    std::string v13 = &v28;
    if (!v4) {
      goto LABEL_25;
    }
    std::string v13 = v9 + 1;
    uint64_t v12 = v9;
LABEL_24:
    if (!*v13) {
      goto LABEL_25;
    }
LABEL_31:
    if (++v5 == 5) {
      break;
    }
    int v6 = v27;
    __int16 v4 = v28;
  }
  for (uint64_t i = 0; i != -20; i -= 4)
  {
    if (SHIBYTE(v38[i + 2]) < 0) {
      operator delete((void *)v38[i]);
    }
  }
  char v18 = v28;
  if (!v28) {
    goto LABEL_48;
  }
  int64x2_t v19 = &v28;
  do
  {
    uint64_t v20 = v19;
    unint64_t v21 = (void **)(v18 + 4);
    int v22 = (char)sub_100046FE8(v18 + 4, (void **)a1);
    unint64_t v23 = v18 + 1;
    if (v22 >= 0)
    {
      unint64_t v23 = v18;
      int64x2_t v19 = (uint64_t **)v18;
    }
    char v18 = (uint64_t *)*v23;
  }
  while (*v23);
  if (v19 == &v28
    || (v22 >= 0 ? (int64x2_t v24 = v21) : (int64x2_t v24 = (void **)(v20 + 4)), (sub_100046FE8((void *)a1, v24) & 0x80) != 0))
  {
LABEL_48:
    uint64_t v25 = 0;
  }
  else
  {
    uint64_t v25 = *((unsigned __int16 *)v19 + 28);
  }
  sub_1000DA2E4((char *)v28);
  return v25;
}

void sub_100BC8F24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  while (1)
  {
    if (*(v12 - 9) < 0) {
      operator delete(*((void **)v12 - 4));
    }
    v12 -= 32;
    if (v12 == &a12) {
      _Unwind_Resume(exception_object);
    }
  }
}

const void **sub_100BC8FAC@<X0>(CFUUIDRef *a1@<X0>, void *a2@<X8>)
{
  if (*a1) {
    uint64_t v3 = sub_100136254;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFStringRef v5 = CFUUIDCreateString(kCFAllocatorDefault, *a1);
    long long v6 = 0uLL;
    uint64_t v7 = 0;
    ctu::cf::assign();
    *(_OWORD *)a2 = 0uLL;
    a2[2] = v7;
    return sub_1000558F4((const void **)&v5);
  }
  else
  {
    return (const void **)sub_100058DB0(a2, "<none>");
  }
}

void sub_100BC905C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)&a9);
  _Unwind_Resume(a1);
}

void sub_100BC9084()
{
}

__n128 sub_100BC9098(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A446D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100BC90E4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A446D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

std::string *sub_100BC9114(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v3 = *(std::string **)(a1 + 8);
  __int16 v4 = sub_100BC87FC(*a2);
  size_t v5 = strlen(v4);
  std::string::append(v3, v4, v5);
  long long v6 = *(std::string **)(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 16);
  int v8 = *(char *)(v7 + 23);
  if (v8 >= 0) {
    id v9 = *(const std::string::value_type **)(a1 + 16);
  }
  else {
    id v9 = *(const std::string::value_type **)v7;
  }
  if (v8 >= 0) {
    std::string::size_type v10 = *(unsigned __int8 *)(v7 + 23);
  }
  else {
    std::string::size_type v10 = *(void *)(v7 + 8);
  }

  return std::string::append(v6, v9, v10);
}

uint64_t sub_100BC918C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100BC91CC()
{
}

void *sub_100BC91D8(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, kCALL_SRV_PROV_LOG_DOMAIN);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, &v6);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 3), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  *a1 = off_101A44890;
  a1[4] = *a2;
  uint64_t v4 = a2[1];
  a1[5] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100BC92AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)v2 + 2);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ServiceProvisioningInterface::~ServiceProvisioningInterface(v2);
  _Unwind_Resume(a1);
}

void sub_100BC92EC(void *a1)
{
  *a1 = off_101A44890;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  ServiceProvisioningInterface::~ServiceProvisioningInterface((ServiceProvisioningInterface *)a1);
}

void sub_100BC9360(void *a1)
{
  sub_100BC92EC(a1);

  operator delete();
}

void sub_100BC9398(uint64_t a1)
{
  xpc_object_t v18 = 0;
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t v18 = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v18 = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  xpc_object_t v18 = v4;
LABEL_9:
  xpc_release(v3);
  v16[0] = 0;
  v16[1] = 0;
  uint64_t v17 = 0;
  ctu::cf::assign();
  otaspStatusAsExternalString();
  if (v13 >= 0) {
    uint64_t v5 = __p;
  }
  else {
    uint64_t v5 = (void **)__p[0];
  }
  xpc_object_t v14 = xpc_string_create((const char *)v5);
  if (!v14) {
    xpc_object_t v14 = xpc_null_create();
  }
  OsLogContext v6 = v16;
  if (v17 < 0) {
    OsLogContext v6 = (void **)v16[0];
  }
  *(void *)long long buf = &v18;
  *(void *)&uint8_t buf[8] = v6;
  sub_100035E70((uint64_t)buf, &v14, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v14);
  xpc_object_t v14 = 0;
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v7 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = sub_100027EA4(109);
    xpc::object::to_string((uint64_t *)__p, (xpc::object *)&v18);
    id v9 = v13 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Sending notification %s with notification dictionary of %s", buf, 0x16u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  xpc_object_t v10 = v18;
  __p[0] = v18;
  if (v18)
  {
    xpc_retain(v18);
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    __p[0] = v10;
  }
  xpc_object_t v11 = xpc_null_create();
  *(void *)long long buf = v11;
  sub_1000452AC(109, __p, (xpc_object_t *)buf);
  xpc_release(v11);
  xpc_release(v10);
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
  xpc_release(v18);
}

void sub_100BC9608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

const void **sub_100BC96A0(uint64_t a1)
{
  int v33 = 0;
  CFDictionaryRef theDict = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 32));
  xpc_object_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    id v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  id v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t))(*(void *)v10 + 24))(&theDict, v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (theDict) {
    uint64_t v12 = sub_100080778;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v12)
  {
    CFNumberRef Value = CFDictionaryGetValue(theDict, @"ServiceProvisionState");
    __int16 v31 = Value;
    if (Value) {
      CFRetain(Value);
    }
    int v15 = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(a1 + 32));
    unint64_t v16 = v15;
    if (v17 < 0)
    {
      xpc_object_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        uint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(v15);
    *(void *)long long buf = v17;
    unint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
    if (v21)
    {
      uint64_t v23 = v21[3];
      int v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v24 = 0;
LABEL_25:
        (*(void (**)(uint64_t, const void *, int *))(*(void *)v23 + 48))(v23, v31, &v33);
        if ((v24 & 1) == 0) {
          sub_10004D2C8(v22);
        }
        sub_100062778(&v31);
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    int v22 = 0;
    char v24 = 1;
    goto LABEL_25;
  }
LABEL_28:
  int v25 = v33;
  if (v33)
  {
    char v26 = *(NSObject **)(a1 + 24);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      int v27 = sub_100027EA4(v25);
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Sending notification %s  with no other additional dictionary", buf, 0xCu);
      int v25 = v33;
    }
    xpc_object_t v28 = xpc_null_create();
    *(void *)long long buf = v28;
    xpc_object_t v29 = xpc_null_create();
    __int16 v31 = v29;
    sub_1000452AC(v25, (xpc_object_t *)buf, (xpc_object_t *)&v31);
    xpc_release(v29);
    xpc_release(v28);
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_100BC9990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100BC9A28(void *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x48uLL);
  sub_100BC9A9C(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;

  sub_1000B3BC8((uint64_t)a2, v4 + 4, (uint64_t)(v4 + 3));
}

void sub_100BC9A88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100BC9A9C(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A44928;
  sub_100BC91D8(a1 + 3, a2);
  return a1;
}

void sub_100BC9AE4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100BC9AF8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A44928;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BC9B18(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A44928;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BC9B6C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100BC9B94(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_10057AA94();
}

void sub_100BC9C04(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BC9C1C(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_100CF15A0();
}

void sub_100BC9C8C(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BC9CA4(ServerUpdaterFactoryInterface *this)
{
  *(void *)this = off_101A44978;
  xpc_object_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServerUpdaterFactoryInterface::~ServerUpdaterFactoryInterface(this);
}

void sub_100BC9D00(ServerUpdaterFactoryInterface *this)
{
  *(void *)this = off_101A44978;
  xpc_object_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServerUpdaterFactoryInterface::~ServerUpdaterFactoryInterface(this);

  operator delete();
}

void sub_100BC9E40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, dispatch_object_t object)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a10);
  if (object) {
    dispatch_release(object);
  }

  _Unwind_Resume(a1);
}

void sub_100BC9EE4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BC9F1C(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

uint64_t sub_100BC9F5C(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    uint64_t v4 = (wis::MetricContainer *)v3;
    uint64_t v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    uint64_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100BCA0B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100BCA13C(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(**(Registry ***)(a1 + 32));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v5;
  id v9 = sub_10004D37C(&v4[1].__m_.__sig, &v14);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (v11)
  {
LABEL_10:
    BOOL v13 = (unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 64))(v11) > 1;
    *(_DWORD *)(a2 + 24) |= 2u;
    *(unsigned char *)(a2 + 16) = v13;
  }
LABEL_11:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100BCA264(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100BCA280(uint64_t a1, int a2, int a3, const std::string *a4)
{
  v13[0] = 0;
  v13[1] = 0;
  sub_100BCA494((uint64_t)v13, 524434);
  uint64_t v7 = v13[0];
  if (v13[0])
  {
    int v8 = *(_DWORD *)(v13[0] + 40);
    *(_DWORD *)(v13[0] + 24) = a3;
    *(_DWORD *)(v7 + 40) = v8 | 6;
    id v9 = *(std::string **)(v7 + 16);
    if (v9 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v9, a4);
    uint64_t v10 = v13[0];
    if (a2)
    {
      *(_DWORD *)(v13[0] + 40) |= 8u;
      *(unsigned char *)(v10 + 28) = 1;
    }
    int v11 = subscriber::simSlotAsInstance();
    *(_DWORD *)(v10 + 40) |= 0x10u;
    *(_DWORD *)(v10 + 32) = v11;
  }
  return sub_100BCA57C(v13);
}

void sub_100BCA36C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100BCA380(Registry **a1)
{
  Registry::getWisServerConnection((uint64_t *)&v3, *a1);
  int DeviceConfigurationId = wis::WISServerConnection::getDeviceConfigurationId(v3);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "wis");
  xpc_object_t v2 = v4;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    LODWORD(v3) = 67109376;
    HIDWORD(v3) = DeviceConfigurationId != -1;
    LOWORD(v4) = 1024;
    *(_DWORD *)((char *)&v4 + 2) = DeviceConfigurationId;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Wireless Insights enabled = %d, device config id = %d", (uint8_t *)&v3, 0xEu);
  }
}

void sub_100BCA474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BCA494(uint64_t a1, int a2)
{
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = a2;
  if (sub_10017B48C()) {
    operator new();
  }
  return a1;
}

void sub_100BCA51C()
{
}

uint64_t *sub_100BCA57C(uint64_t *a1)
{
  sub_100BCA5D8((uint64_t)a1);
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_100BCA5D8(uint64_t result)
{
  if (*(void *)result)
  {
    char v1 = (uint64_t *)result;
    sub_100BCA650((uint64_t *)result, *(_DWORD *)(result + 8));
    __n128 result = *v1;
    *char v1 = 0;
    if (result)
    {
      uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 8);
      return v2();
    }
  }
  return result;
}

void sub_100BCA650(uint64_t *a1, unsigned int a2)
{
  uint64_t v4 = sub_10001C8F4(8);
  uint64_t v6 = (wis::WISServerConnection *)*v4;
  unint64_t v5 = (std::__shared_weak_count *)v4[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v6)
  {
    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v4);
    int v8 = (wis *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
    id v9 = v8;
    if (v8)
    {
      uint64_t v10 = *a1;
      *a1 = 0;
      if (v10)
      {
        if (*(unsigned char *)(v10 + 40))
        {
          unint64_t WISTimestamp = *(void *)(v10 + 8);
        }
        else
        {
          unint64_t WISTimestamp = wis::getWISTimestamp(v8);
          *(_DWORD *)(v10 + 40) |= 1u;
          *(void *)(v10 + 8) = WISTimestamp;
        }
        wis::MetricContainer::storeMetric(v9, WISTimestamp, *(_DWORD *)v9, (const wireless_diagnostics::google::protobuf::MessageLite *)v10);
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      }
      wis::WISServerConnection::SubmitMetric(v6, v9);
    }
  }
  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

void sub_100BCA75C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100BCA7AC(os_log_t *a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!__s) {
    __TUAssertTrigger();
  }
  strlen(__s);
  int Hkdf = CCKDFParametersCreateHkdf();
  if (Hkdf)
  {
    uint64_t v10 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__p) = 67109120;
      HIDWORD(__p) = Hkdf;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "derive2x256bitKeys, CCKDFParametersCreateHkdf failed, %d", (uint8_t *)&__p, 8u);
    }
    return 0;
  }
  else
  {
    std::string __p = 0;
    unsigned int v20 = 0;
    uint64_t v21 = 0;
    sub_10008E4E8(&__p, 0x40uLL);
    int v12 = CCHKDFExpand();
    BOOL v11 = v12 == 0;
    if (v12)
    {
      BOOL v13 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "derive2x256bitKeys, CCHKDFExpand secret derivation failed, %d", buf, 8u);
      }
    }
    else
    {
      uint64_t v18 = 0;
      memset(buf, 0, sizeof(buf));
      sub_10036CCEC(buf, __p, (uint64_t)__p + 32, 0x20uLL);
      unint64_t v14 = *(void **)a4;
      if (*(void *)a4)
      {
        *(void *)(a4 + 8) = v14;
        operator delete(v14);
        *(void *)a4 = 0;
        *(void *)(a4 + 8) = 0;
        *(void *)(a4 + 16) = 0;
      }
      *(_OWORD *)a4 = *(_OWORD *)buf;
      *(void *)(a4 + 16) = v18;
      uint64_t v18 = 0;
      memset(buf, 0, sizeof(buf));
      sub_10036CCEC(buf, (char *)__p + 32, (uint64_t)v20, v20 - ((unsigned char *)__p + 32));
      int v15 = *(void **)a5;
      if (*(void *)a5)
      {
        *(void *)(a5 + 8) = v15;
        operator delete(v15);
        *(void *)a5 = 0;
        *(void *)(a5 + 8) = 0;
        *(void *)(a5 + 16) = 0;
      }
      *(_OWORD *)a5 = *(_OWORD *)buf;
      *(void *)(a5 + 16) = v18;
    }
    CCKDFParametersDestroy();
    if (__p)
    {
      unsigned int v20 = __p;
      operator delete(__p);
    }
  }
  return v11;
}

void sub_100BCA9E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCAA0C(os_log_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const void *a4@<X3>, size_t a5@<X4>, _OWORD *a6@<X8>)
{
  *a6 = 0u;
  a6[1] = 0u;
  __n128 __p = 0uLL;
  uint64_t v8 = 0;
  if (sub_100BCAAB4(a1, 0, a2, a3, a4, a5, __p.n128_u64)) {
    sub_100195D74((uint64_t)a6, &__p);
  }
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_100BCAA80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  if (*(unsigned char *)(v11 + 24))
  {
    BOOL v13 = *(void **)v11;
    if (*(void *)v11)
    {
      *(void *)(v11 + 8) = v13;
      operator delete(v13);
    }
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100BCAAB4(os_log_t *a1, CCOperation a2, uint64_t a3, uint64_t a4, const void *a5, size_t a6, unint64_t *a7)
{
  md = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  sub_10008E4E8(&md, 0x20uLL);
  if (CC_SHA256(*(const void **)a4, *(_DWORD *)(a4 + 8) - *(void *)a4, md))
  {
    __int16 v31 = 0;
    uint64_t v32 = 0;
    iv = 0;
    sub_10036CCEC(&iv, md, (uint64_t)(md + 16), 0x10uLL);
    unint64_t v14 = *(const void **)a3;
    size_t v15 = *(void *)(a3 + 8) - *(void *)a3;
    CCCryptorRef cryptorRef = 0;
    CCCryptorStatus v16 = CCCryptorCreateWithMode(a2, 4u, 0, 0, iv, v14, v15, 0, 0, 0, 2u, &cryptorRef);
    if (v16)
    {
      uint64_t v17 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v16;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "msgProcessing, CCCryptorCreateWithMode failed with error %d", buf, 8u);
      }
      goto LABEL_25;
    }
    OutputCFIndex Length = CCCryptorGetOutputLength(cryptorRef, a6, 1);
    unsigned int v20 = (char *)*a7;
    uint64_t v21 = (char *)a7[1];
    size_t v22 = (size_t)&v21[-*a7];
    if (OutputLength <= v22)
    {
      if (OutputLength < v22)
      {
        uint64_t v21 = &v20[OutputLength];
        a7[1] = (unint64_t)&v20[OutputLength];
      }
    }
    else
    {
      sub_10011FDF0(a7, OutputLength - v22);
      unsigned int v20 = (char *)*a7;
      uint64_t v21 = (char *)a7[1];
    }
    *(void *)long long buf = 0;
    CCCryptorStatus v16 = CCCryptorUpdate(cryptorRef, a5, a6, v20, v21 - v20, (size_t *)buf);
    if (v16)
    {
      uint64_t v23 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v36 = 67109120;
        CCCryptorStatus v37 = v16;
        char v24 = "msgProcessing, CCCryptorUpdate failed with error %d";
LABEL_18:
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v24, v36, 8u);
      }
    }
    else
    {
      uint64_t v25 = *(void *)buf;
      CCCryptorStatus v16 = CCCryptorFinal(cryptorRef, (void *)(*a7 + *(void *)buf), a7[1] - (*a7 + *(void *)buf), (size_t *)buf);
      if (!v16)
      {
        unint64_t v26 = *(void *)buf + v25;
        unint64_t v27 = a7[1] - *a7;
        if (*(void *)buf + v25 <= v27)
        {
          if (v26 < v27)
          {
            CCCryptorStatus v16 = 0;
            a7[1] = *a7 + v26;
            goto LABEL_24;
          }
        }
        else
        {
          sub_10011FDF0(a7, *(void *)buf + v25 - v27);
        }
        CCCryptorStatus v16 = 0;
        goto LABEL_24;
      }
      uint64_t v23 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v36 = 67109120;
        CCCryptorStatus v37 = v16;
        char v24 = "msgProcessing, CCCryptorFinal failed with error %d";
        goto LABEL_18;
      }
    }
LABEL_24:
    CCCryptorRelease(cryptorRef);
LABEL_25:
    if (iv)
    {
      __int16 v31 = iv;
      operator delete(iv);
    }
    goto LABEL_27;
  }
  uint64_t v18 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
  {
    LOWORD(iv) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "msgProcessing, CC_SHA256 failed", (uint8_t *)&iv, 2u);
  }
  CCCryptorStatus v16 = -4300;
LABEL_27:
  if (md)
  {
    uint64_t v34 = md;
    operator delete(md);
  }
  return v16 == 0;
}

void sub_100BCADC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCAE0C(os_log_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, const void *a4@<X3>, size_t a5@<X4>, _OWORD *a6@<X8>)
{
  *a6 = 0u;
  a6[1] = 0u;
  __n128 __p = 0uLL;
  uint64_t v8 = 0;
  if (sub_100BCAAB4(a1, 1u, a2, a3, a4, a5, __p.n128_u64)) {
    sub_100195D74((uint64_t)a6, &__p);
  }
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_100BCAE80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  if (*(unsigned char *)(v11 + 24))
  {
    BOOL v13 = *(void **)v11;
    if (*(void *)v11)
    {
      *(void *)(v11 + 8) = v13;
      operator delete(v13);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCAEB4(NSObject **a1@<X0>, uint64_t a2@<X4>, void ***a3@<X8>)
{
  long long v8 = 0uLL;
  uint64_t v9 = 0;
  ctu::cf::assign();
  long long v6 = 0uLL;
  uint64_t v7 = 0;
  sub_100BCAF78(a1, &v6, a2, a3);
}

void sub_100BCAF48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if ((void)a9) {
    operator delete((void *)a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCAF78(NSObject **a1@<X0>, void *a2@<X1>, uint64_t a3@<X4>, void ***a4@<X8>)
{
  size_t v6 = a3 + a2[1] - *a2 + 12;
  size_t v15 = 0;
  CCCryptorStatus v16 = 0;
  sub_100BCB8C4(&v15, v6, 0);
  uint64_t v7 = v15;
  if (SecRandomCopyBytes(kSecRandomDefault, 0xCuLL, *v15))
  {
    long long v8 = *a1;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_9;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v9 = "unable to generate IV";
    uint64_t v10 = v8;
    uint32_t v11 = 2;
LABEL_7:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
    goto LABEL_9;
  }
  int v12 = CCCryptorGCMOneshotEncrypt();
  if (v12)
  {
    BOOL v13 = *a1;
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_9;
    }
    *(_DWORD *)long long buf = 67109120;
    int v18 = v12;
    uint64_t v9 = "CCCryptorGCMOneshotEncrypt failed with %d";
    uint64_t v10 = v13;
    uint32_t v11 = 8;
    goto LABEL_7;
  }
  unint64_t v14 = v16;
  *a4 = v7;
  a4[1] = (void **)&v14->__vftable;
  a4 = &v15;
LABEL_9:
  *a4 = 0;
  a4[1] = 0;
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_100BCB138(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCB15C(os_log_t *a1@<X0>, void *a2@<X1>, void *a3@<X4>, size_t a4@<X5>, uint64_t a5@<X8>)
{
  unint64_t v7 = a3[1] - *a3;
  if (v7 <= 0xB)
  {
    long long v8 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "IV size must be at least 12 bytes, given %zu", buf, 0xCu);
    }
LABEL_4:
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    return;
  }
  size_t v9 = a2[1] - *a2;
  if (!v9)
  {
    CCCryptorStatus v16 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#E empty src to encrypt - skipping", buf, 2u);
    }
    goto LABEL_4;
  }
  *(_OWORD *)long long buf = 0uLL;
  sub_100BCB954(buf, v9, 0);
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_100BCB8C4(&v18, a4, 0);
  uint64_t v11 = *(void *)buf;
  uint64_t v12 = v18;
  int v13 = CCCryptorGCMOneshotEncrypt();
  if (v13)
  {
    unint64_t v14 = *a1;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int v20 = 67109120;
      int v21 = v13;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "CCCryptorGCMOneshotEncrypt failed with %d", v20, 8u);
    }
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    size_t v15 = v19;
    if (!v19) {
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v17 = *(void *)&buf[8];
    *(void *)a5 = v11;
    *(void *)(a5 + 8) = v17;
    if (v17) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
    }
    size_t v15 = v19;
    *(void *)(a5 + 16) = v12;
    *(void *)(a5 + 24) = v15;
    if (!v15) {
      goto LABEL_18;
    }
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10004D2C8(v15);
LABEL_18:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_100BCB3A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCB3D8(NSObject **a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_100BCB954(&v9, a2[1] - *a2, 0);
  uint64_t v5 = v9;
  int v6 = CCCryptorGCMOneshotDecrypt();
  if (v6)
  {
    unint64_t v7 = *a1;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      int v12 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "CCCryptorGCMOneshotDecrypt failed with %d", buf, 8u);
    }
    *a3 = 0;
    a3[1] = 0;
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
  else
  {
    long long v8 = v10;
    *a3 = v5;
    a3[1] = v8;
  }
}

void sub_100BCB534(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCB554(os_log_t *a1@<X0>, size_t a2@<X3>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  int Hkdf = CCKDFParametersCreateHkdf();
  if (Hkdf)
  {
    unint64_t v7 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = Hkdf;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#E failed to CCKDFParametersCreateHkdf: %d", buf, 8u);
    }
  }
  else
  {
    *(void *)long long buf = 0;
    size_t v15 = 0;
    sub_100BCB8C4(buf, a2, 0);
    uint64_t v8 = *(void *)buf;
    int v9 = CCDeriveKey();
    CCKDFParametersDestroy();
    if (v9)
    {
      uint64_t v10 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int v12 = 67109120;
        int v13 = v9;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E failed to CCDeriveKey: %d", v12, 8u);
      }
    }
    else
    {
      uint64_t v11 = v15;
      if (v15) {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *a3 = v8;
      a3[1] = v11;
    }
    if (v15) {
      sub_10004D2C8(v15);
    }
  }
}

void sub_100BCB6EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCB70C(os_log_t *a1@<X0>, size_t a2@<X3>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  int Hkdf = CCKDFParametersCreateHkdf();
  if (Hkdf)
  {
    unint64_t v7 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = Hkdf;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#E failed to CCKDFParametersCreateHkdf: %d", buf, 8u);
    }
  }
  else
  {
    *(void *)long long buf = 0;
    size_t v15 = 0;
    sub_100BCB8C4(buf, a2, 0);
    uint64_t v8 = *(void *)buf;
    int v9 = CCHKDFExpand();
    CCKDFParametersDestroy();
    if (v9)
    {
      uint64_t v10 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int v12 = 67109120;
        int v13 = v9;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E failed to CCHKDFExpand: %d", v12, 8u);
      }
    }
    else
    {
      uint64_t v11 = v15;
      if (v15) {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *a3 = v8;
      a3[1] = v11;
    }
    if (v15) {
      sub_10004D2C8(v15);
    }
  }
}

void sub_100BCB8A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100BCB8C4(void *a1, size_t a2, char a3)
{
  int v6 = operator new(0x30uLL);
  v6[1] = 0;
  uint64_t v6[2] = 0;
  *int v6 = off_1019B47B8;
  char v8 = a3;
  __n128 result = sub_10063BE34(v6 + 3, a2, &v8);
  *a1 = result;
  a1[1] = v6;
  return result;
}

void sub_100BCB93C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void *sub_100BCB954(void *a1, size_t a2, char a3)
{
  int v6 = operator new(0x30uLL);
  v6[1] = 0;
  uint64_t v6[2] = 0;
  *int v6 = off_1019B47B8;
  char v8 = a3;
  __n128 result = sub_10063BE34(v6 + 3, a2, &v8);
  *a1 = result;
  a1[1] = v6;
  return result;
}

void sub_100BCB9CC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_100BCB9E4()
{
}

void sub_100BCBA58()
{
}

void sub_100BCBAD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCBB10()
{
}

void sub_100BCBB4C(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_100BCB9E4();
}

void sub_100BCBC00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8))(a11);
  }
  if (v11) {
    dispatch_release(v11);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100BCBC4C(capabilities::ct *a1, const void **a2, uint64_t a3, const void **a4, uint64_t a5)
{
  if (capabilities::ct::getBasebandBootStrategy(a1) != 2)
  {
    sub_100058198(&v12, a2);
    sub_100083DA4(&v11, a4);
    sub_100BCB9E4();
  }
  sub_100058198(&v14, a2);
  sub_100083DA4(&v13, a4);
  (*(void (**)(capabilities::ct *, const void **, uint64_t, void, const void **, uint64_t))(*(void *)a1 + 56))(a1, &v14, a3, 0, &v13, a5);
  sub_1000558F4(&v13);
  return sub_100057D78(&v14);
}

void sub_100BCBDA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 8))(a3);
  }
  sub_1000558F4((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100BCBE10()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  sub_100BCB9E4();
}

void sub_100BCBEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 8))(a3);
  }
  sub_1000558F4((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100BCBF14(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, const void **a5)
{
  sub_100058198(&v7, a2);
  sub_100083DA4(&v6, a5);
  sub_100BCB9E4();
}

void sub_100BCBFF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 8))(a3);
  }
  sub_1000558F4((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100BCC04C(uint64_t a1, const void **a2, const void **a3)
{
  sub_100083DA4(&v5, a2);
  sub_100083DA4(&v4, a3);
  sub_100BB8C28(&v6);
}

void sub_100BCC0C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_100BCC0E4()
{
}

void sub_100BCC1AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a15) {
    (*(void (**)(uint64_t))(*(void *)a15 + 8))(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCC1FC()
{
  sub_1007D01C4(&v0);
}

void sub_100BCC234(uint64_t a1@<X0>, void *a2@<X8>)
{
}

void sub_100BCC23C()
{
}

void sub_100BCC278(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = (Registry **)(a1 + 8);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 8));
  uint64_t v5 = ServiceMap;
  uint64_t v7 = v6;
  if (v6 < 0)
  {
    char v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v25 = v7;
  uint64_t v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v25);
  if (v11)
  {
    int v13 = (GestaltUtilityInterface *)v11[3];
    int v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    int v13 = 0;
  }
  std::mutex::unlock(v5);
  int v12 = 0;
  char v14 = 1;
LABEL_9:
  if (GestaltUtilityInterface::isIPad(v13))
  {
    int isIPhone = 1;
    goto LABEL_21;
  }
  uint64_t v17 = (std::mutex *)Registry::getServiceMap(v15, *v3);
  uint64_t v18 = v17;
  if (v6 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v6 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v17);
  *(void *)&long long v25 = v6;
  size_t v22 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&v25);
  if (v22)
  {
    char v24 = (GestaltUtilityInterface *)v22[3];
    uint64_t v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      goto LABEL_19;
    }
  }
  else
  {
    char v24 = 0;
  }
  std::mutex::unlock(v18);
  uint64_t v23 = 0;
LABEL_19:
  int isIPhone = GestaltUtilityInterface::isIPhone(v24);
  if (v23) {
    sub_10004D2C8(v23);
  }
LABEL_21:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (isIPhone) {
    sub_1007113A0(&v25);
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_100BCC444(_Unwind_Exception *exception_object)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCC47C()
{
}

void sub_100BCC4B8(CarrierBundleFactoryInterface *this)
{
  *(void *)this = off_101A44A90;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CarrierBundleFactoryInterface::~CarrierBundleFactoryInterface(this);
}

void sub_100BCC514(CarrierBundleFactoryInterface *this)
{
  *(void *)this = off_101A44A90;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CarrierBundleFactoryInterface::~CarrierBundleFactoryInterface(this);

  operator delete();
}

const void **sub_100BCC584(uint64_t a1)
{
  *(void *)char v8 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    char v3 = *(__CFDictionary **)v8;
    *(void *)char v8 = Mutable;
    uint64_t v9 = v3;
    sub_10005717C((const void **)&v9);
  }
  sub_10010F3F0(*(__CFDictionary **)v8, @"MessageName", @"kCarrierBundleIDSMessageInstallIPCC");
  sub_10004EFE4(&v6, (CFTypeRef *)v8);
  sub_100BCC68C(&v7, v6);
  char v4 = (const void **)(a1 + 56);
  if ((const void **)(a1 + 56) != &v7)
  {
    uint64_t v9 = (void *)*v4;
    const void *v4 = v7;
    uint64_t v7 = 0;
    sub_100030068((const void **)&v9);
  }
  sub_100030068(&v7);
  sub_100057D78((const void **)&v6);
  return sub_10005717C((const void **)v8);
}

void sub_100BCC664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11)
{
}

void sub_100BCC68C(void *a1, void *a2)
{
  id v3 = a2;
  id v12 = 0;
  char v4 = +[NSKeyedArchiver archivedDataWithRootObject:v3 requiringSecureCoding:1 error:&v12];
  id v5 = v12;
  uint64_t v6 = v5;
  if (v4)
  {
    if (!v5)
    {
      *a1 = v4;
      CFRetain(v4);
      goto LABEL_8;
    }
    sub_100BCCEC0();
    uint64_t v7 = qword_101B10218;
    if (os_log_type_enabled((os_log_t)qword_101B10218, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      char v14 = v6;
      char v8 = "Error archiving message dictionary : %{public}@";
      uint64_t v9 = v7;
      uint32_t v10 = 12;
LABEL_10:
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v8, buf, v10);
    }
  }
  else
  {
    sub_100BCCEC0();
    uint64_t v11 = qword_101B10218;
    if (os_log_type_enabled((os_log_t)qword_101B10218, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      char v8 = "nil data";
      uint64_t v9 = v11;
      uint32_t v10 = 2;
      goto LABEL_10;
    }
  }
  *a1 = 0;
LABEL_8:
}

void sub_100BCC7E8(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100BCC828(uint64_t a1)
{
  *(void *)char v8 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    id v3 = *(__CFDictionary **)v8;
    *(void *)char v8 = Mutable;
    uint64_t v9 = v3;
    sub_10005717C((const void **)&v9);
  }
  sub_10010F3F0(*(__CFDictionary **)v8, @"MessageName", @"kCarrierBundleIDSMessageRemoteBundleInfo");
  sub_10004EFE4(&v6, (CFTypeRef *)v8);
  sub_100BCC68C(&v7, v6);
  char v4 = (const void **)(a1 + 56);
  if ((const void **)(a1 + 56) != &v7)
  {
    uint64_t v9 = (void *)*v4;
    void *v4 = v7;
    uint64_t v7 = 0;
    sub_100030068((const void **)&v9);
  }
  sub_100030068(&v7);
  sub_100057D78((const void **)&v6);
  return sub_10005717C((const void **)v8);
}

void sub_100BCC908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11)
{
}

const void **sub_100BCC930(uint64_t a1, uint64_t *a2)
{
  *(void *)uint32_t v10 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    id v5 = *(__CFDictionary **)v10;
    *(void *)uint32_t v10 = Mutable;
    uint64_t v11 = v5;
    sub_10005717C((const void **)&v11);
  }
  sub_10010F3F0(*(__CFDictionary **)v10, @"MessageName", @"kCarrierBundleIDSMessageRemoteBundleInfo");
  sub_1001C6A4C(*(__CFDictionary **)v10, @"MessagePayload", *a2);
  sub_10004EFE4(&v8, (CFTypeRef *)v10);
  sub_100BCC68C(&v9, v8);
  uint64_t v6 = (const void **)(a1 + 56);
  if ((const void **)(a1 + 56) != &v9)
  {
    uint64_t v11 = (void *)*v6;
    *uint64_t v6 = v9;
    uint64_t v9 = 0;
    sub_100030068((const void **)&v11);
  }
  sub_100030068(&v9);
  sub_100057D78((const void **)&v8);
  return sub_10005717C((const void **)v10);
}

void sub_100BCCA34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11)
{
}

const void **sub_100BCCA60@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFDictionaryRef theDict = 0;
  sub_10002FD9C((const void **)&v13, (const void **)(a1 + 56));
  sub_100BCCC28(&theDict, v13);
  sub_100030068((const void **)&v13);
  if (theDict) {
    id v3 = sub_100080778;
  }
  else {
    id v3 = 0;
  }
  if (v3)
  {
    CFNumberRef Value = CFDictionaryGetValue(theDict, @"MessagePayload");
    id v5 = Value;
    if (Value && (CFTypeID v6 = CFGetTypeID(Value), v6 == CFDictionaryGetTypeID()))
    {
      *(void *)long long buf = v5;
      CFRetain(v5);
    }
    else
    {
      id v5 = 0;
      *(void *)long long buf = 0;
    }
    if (v5) {
      uint64_t v7 = sub_100080778;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7)
    {
      *a2 = v5;
      *(void *)long long buf = 0;
    }
    else
    {
      sub_100BCCEC0();
      uint64_t v9 = qword_101B10218;
      if (os_log_type_enabled((os_log_t)qword_101B10218, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v11 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not get the bundle info", v11, 2u);
      }
      *a2 = 0;
    }
    sub_100057D78((const void **)buf);
  }
  else
  {
    sub_100BCCEC0();
    char v8 = qword_101B10218;
    if (os_log_type_enabled((os_log_t)qword_101B10218, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to decode the message", buf, 2u);
    }
    *a2 = 0;
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_100BCCBF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  char v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_100057D78((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100BCCC28(void *a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v13 = 0;
    id v4 = [objc_alloc((Class)NSKeyedUnarchiver) initForReadingFromData:v3 error:&v13];
    id v5 = v13;
    if (v5)
    {
      sub_100BCCEC0();
      uint64_t v6 = qword_101B10218;
      if (os_log_type_enabled((os_log_t)qword_101B10218, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v15 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Error creating the UnArchiver : %{public}@", buf, 0xCu);
      }
      *a1 = 0;
    }
    else
    {
      [v4 setRequiresSecureCoding:1];
      uint64_t v8 = objc_opt_class();
      uint64_t v9 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v8, objc_opt_class(), 0);
      uint32_t v10 = [v4 decodeObjectOfClasses:v9 forKey:NSKeyedArchiveRootObjectKey];
      uint64_t v11 = v10;
      if (v10)
      {
        *a1 = v10;
        CFRetain(v10);
      }
      else
      {
        sub_100BCCEC0();
        id v12 = qword_101B10218;
        if (os_log_type_enabled((os_log_t)qword_101B10218, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "message dictionary is nil", buf, 2u);
        }
        *a1 = 0;
      }
    }
  }
  else
  {
    sub_100BCCEC0();
    uint64_t v7 = qword_101B10218;
    if (os_log_type_enabled((os_log_t)qword_101B10218, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Message data is NULL", buf, 2u);
    }
    *a1 = 0;
  }
}

void sub_100BCCE64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100BCCEC0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B10220, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B10220))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B10218, kCtLoggingSystemName, "cb.ids.msg");
    __cxa_guard_release(&qword_101B10220);
  }
}

void sub_100BCCF40(_Unwind_Exception *a1)
{
}

uint64_t sub_100BCCF58(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_10002FD9C((const void **)&v9, (const void **)(a1 + 56));
  sub_100BCCC28(&theDict, v9);
  sub_100030068((const void **)&v9);
  if (theDict) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (v1)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"MessageName");
    CFStringRef v3 = Value;
    if (Value)
    {
      CFTypeID v4 = CFGetTypeID(Value);
      if (v4 != CFStringGetTypeID()) {
        CFStringRef v3 = 0;
      }
    }
    if (CFStringCompare(v3, @"kCarrierBundleIDSMessageInstallIPCC", 1uLL)) {
      uint64_t v5 = 2
    }
         * (CFStringCompare(v3, @"kCarrierBundleIDSMessageRemoteBundleInfo", 1uLL) == kCFCompareEqualTo);
    else {
      uint64_t v5 = 1;
    }
  }
  else
  {
    sub_100BCCEC0();
    uint64_t v6 = qword_101B10218;
    if (os_log_type_enabled((os_log_t)qword_101B10218, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to decode the message", v8, 2u);
    }
    uint64_t v5 = 0;
  }
  sub_100057D78((const void **)&theDict);
  return v5;
}

void sub_100BCD088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100BCD0B0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 440))
  {
    __n128 __p = (void *)1;
    id v15 = (std::__shared_weak_count *)(a1 + 568);
    if (*(char *)(a1 + 623) < 0)
    {
      **(unsigned char **)(a1 + 600) = 0;
      *(void *)(a1 + 608) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 600) = 0;
      *(unsigned char *)(a1 + 623) = 0;
    }
    if (*(char *)(a1 + 647) < 0)
    {
      **(unsigned char **)(a1 + 624) = 0;
      *(void *)(a1 + 632) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 624) = 0;
      *(unsigned char *)(a1 + 647) = 0;
    }
    sub_100BCD5FC((uint64_t)&__p);
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(a1 + 440), *(Registry **)(a1 + 320));
  CFStringRef v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  __n128 __p = (void *)v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&__p);
  if (!v8)
  {
    uint64_t v10 = 0;
    goto LABEL_11;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9)
  {
LABEL_11:
    std::mutex::unlock(v3);
    uint64_t v9 = 0;
    char v11 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
LABEL_12:
  sub_10003E168(&__p, (void *)(a1 + 8));
  id v13 = __p;
  id v12 = v15;
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
  }
  v17[0] = off_101A44B30;
  v17[1] = v13;
  v17[2] = v12;
  v17[3] = v17;
  sub_100058DB0(&__p, "SystemObserver");
  (*(void (**)(uint64_t, void *, void **))(*(void *)v10 + 56))(v10, v17, &__p);
  if (v16 < 0) {
    operator delete(__p);
  }
  sub_100333DB8(v17);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100BCD2BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100333DB8(&a15);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(a1);
}

void sub_100BCD314(NSObject **a1@<X0>, uint64_t a2@<X8>)
{
  CFStringRef v3 = *a1;
  dispatch_object_t object = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  v4.fObj.fObuint64_t j = (dispatch_object_s *)&object;
  NotifySubscription::NotifySubscription((NotifySubscription *)v7, "com.apple.carplay.connected", v4);
  uint64_t v5 = v7[1];
  *(void *)a2 = v7[0];
  *(void *)(a2 + 8) = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  *(_DWORD *)(a2 + 16) = v8;
  *(unsigned char *)(a2 + 24) = 1;
  NotifySubscription::~NotifySubscription((NotifySubscription *)v7);
  if (object) {
    dispatch_release(object);
  }
}

void sub_100BCD394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BCD3AC@<X0>(capabilities::ct *a1@<X0>, dispatch_object_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = sub_100BCD400(a1);
  if (result)
  {
    uint64_t result = (uint64_t)sub_100BCDBC8(a2, &v6);
    *(_OWORD *)a3 = v6;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
  return result;
}

uint64_t sub_100BCD400(capabilities::ct *a1)
{
  if (capabilities::ct::supportsSubwayDetection(a1)) {
    return 1;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v14);
  if (v10)
  {
    id v12 = (GestaltUtilityInterface *)v10[3];
    char v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      goto LABEL_11;
    }
  }
  else
  {
    id v12 = 0;
  }
  std::mutex::unlock(v5);
  char v11 = 0;
LABEL_11:
  uint64_t isWatch = GestaltUtilityInterface::isWatch(v12);
  if (v11) {
    sub_10004D2C8(v11);
  }
  return isWatch;
}

void sub_100BCD4FC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BCD518(uint64_t a1)
{
  uint64_t result = sub_100BCD400((capabilities::ct *)(a1 + 320));
  if (result)
  {
    uint64_t result = *(void *)(a1 + 896);
    if (result)
    {
      CFStringRef v3 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v3();
    }
  }
  return result;
}

uint64_t sub_100BCD588(uint64_t a1)
{
  if (!sub_100BCD400((capabilities::ct *)(a1 + 320))) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 896);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = *(uint64_t (**)(void))(*(void *)v2 + 64);

  return v3();
}

uint64_t sub_100BCD5FC(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void *sub_100BCD660(void *a1)
{
  *a1 = off_101A44B30;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100BCD6AC(void *a1)
{
  *a1 = off_101A44B30;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100BCD718(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A44B30;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100BCD774(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A44B30;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100BCD7AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100BCD7BC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100BCD7FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    unsigned int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        if (*(char *)(a3 + 23) < 0)
        {
          sub_10004FC84(v9, *(void **)a3, *(void *)(a3 + 8));
        }
        else
        {
          *(_OWORD *)unsigned int v9 = *(_OWORD *)a3;
          void v9[2] = *(void **)(a3 + 16);
        }
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)__n128 __p = *(_OWORD *)a2;
          int64x2_t __p[2] = *(void **)(a2 + 16);
        }
        v11[0] = 0;
        v11[1] = 0;
        sub_10003E168(v11, (void *)(v8 + 8));
        operator new();
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100BCD9FC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (*(char *)(v16 + 39) < 0) {
    operator delete(*v17);
  }
  uint64_t v19 = *(std::__shared_weak_count **)(v16 + 8);
  if (v19) {
    sub_10004D2C8(v19);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100BCDA70(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100BCDAB0()
{
}

uint64_t *sub_100BCDABC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v6 = 1;
  uint64_t v2 = *(std::string **)v1;
  uint64_t v7 = *(void *)v1 + 568;
  std::string::operator=(v2 + 25, (const std::string *)(v1 + 16));
  std::string::operator=((std::string *)(v7 + 56), (const std::string *)(v1 + 40));
  sub_100BCD5FC((uint64_t)&v6);
  sub_100BCDB54(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100BCDB30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t *sub_100BCDB54(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void *sub_100BCDBC8@<X0>(dispatch_object_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x28uLL);
  uint64_t result = sub_100BCDC24(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100BCDC10(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100BCDC24(void *a1, dispatch_object_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019AE500;
  sub_100BCDC80(a1 + 3, a2);
  return a1;
}

void sub_100BCDC6C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_100BCDC80(void *a1, dispatch_object_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    *a1 = &off_1019C13E8;
    a1[1] = v3;
    dispatch_retain(v3);
    dispatch_release(v3);
  }
  else
  {
    *a1 = &off_1019C13E8;
    a1[1] = 0;
  }
  return a1;
}

void sub_100BCDD00(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100BCDD9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  id v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCDDE4(uint64_t a1)
{
  sub_100BCE104(a1);
  sub_10003E168(&v3, (void *)(a1 + 8));
  uint64_t v2 = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100BCDEC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BCDEE8(uint64_t a1, NSObject **a2)
{
  uint64_t v4 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, "xpc.tracker");
  sub_100BCDFA8(v4, a2, &v6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  *(void *)a1 = off_101A44BB0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_WORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 136) = 1065353216;
  return a1;
}

void sub_100BCDF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100BCDFA8(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100BCE010(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100BCE034(uint64_t a1)
{
  *(void *)a1 = off_101A44BB0;
  sub_100BCFBA8(*(void **)(a1 + 120));
  uint64_t v2 = *(void **)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v2) {
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 72);
  if (v3)
  {
    *(void *)(a1 + 80) = v3;
    operator delete(v3);
  }
  uint64_t v5 = (void **)(a1 + 48);
  sub_100B05F98(&v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100BCE0CC(uint64_t a1)
{
  sub_100BCE034(a1);

  operator delete();
}

void sub_100BCE104(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 96);
  *(unsigned char *)(a1 + 97) = v2;
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109376;
    v4[1] = v2;
    __int16 v5 = 1024;
    int v6 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Tracker gathering stats = %d (queriable=%d)", (uint8_t *)v4, 0xEu);
    int v2 = *(unsigned __int8 *)(a1 + 97);
  }
  if (!v2) {
    sub_100BCFC80(a1 + 104);
  }
}

void sub_100BCE1CC(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      __int16 v5 = v4;
      if (a1[5])
      {
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 0x40000000;
        void v11[2] = sub_100BCE30C;
        void v11[3] = &unk_101A44BC0;
        v11[4] = v3;
        int v6 = (std::__shared_weak_count *)v3[2];
        if (!v6 || (uint64_t v7 = v3[1], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
          sub_100088B9C();
        }
        unsigned int v9 = v8;
        uint64_t v10 = v3[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100BCFC44;
        block[3] = &unk_101A44D88;
        block[5] = v7;
        id v13 = v9;
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        block[4] = v11;
        dispatch_async(v10, block);
        if (v13) {
          sub_10004D2C8(v13);
        }
        sub_10004D2C8(v9);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100BCE30C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v8 = 0;
  unsigned int v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100BCEA7C;
  v7[3] = &unk_101A44C18;
  void v7[4] = &v8;
  v7[5] = v1;
  int v2 = sub_10001C714((wis::MetricFactory *)v7);
  uint64_t v3 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "false";
    if (v2) {
      __int16 v5 = "true";
    }
    else {
      __int16 v5 = "false";
    }
    uint64_t v6 = v9[3];
    if (*(unsigned char *)(v1 + 97)) {
      uint64_t v4 = "true";
    }
    *(_DWORD *)long long buf = 136315650;
    id v13 = v5;
    __int16 v14 = 2080;
    id v15 = v4;
    __int16 v16 = 2048;
    uint64_t v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Full report submitted=%s; gathered=%s; sent=%zu",
      buf,
      0x20u);
  }
  sub_100BCFC80(v1 + 104);
  _Block_object_dispose(&v8, 8);
}

void sub_100BCE474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100BCE48C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100BCE4A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100BCE4B8(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[1];
  if (*a2 == v2)
  {
    BOOL v4 = 0;
  }
  else
  {
    uint64_t v3 = *a2 + 4;
    do
    {
      BOOL v4 = *(_DWORD *)(v3 - 4) == 524481;
      BOOL v5 = *(_DWORD *)(v3 - 4) == 524481 || v3 == v2;
      v3 += 4;
    }
    while (!v5);
  }
  *(unsigned char *)(a1 + 96) = v4;
  sub_100BCE104(a1);
}

void sub_100BCE4F8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 56);
  if (v2 != v3)
  {
    BOOL v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BCFCD8(&__s, v2);
      std::string v31 = __s;
      for (uint64_t i = v2 + 32; i != v3; i += 32)
      {
        *((unsigned char *)&__s.__r_.__value_.__s + 23) = 1;
        strcpy((char *)&__s, ",");
        std::string::append(&v31, (const std::string::value_type *)&__s, 1uLL);
        if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__s.__r_.__value_.__l.__data_);
        }
        sub_100BCFCD8(&__s, i);
        if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_s = &__s;
        }
        else {
          p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
        }
        if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__s.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = __s.__r_.__value_.__l.__size_;
        }
        std::string::append(&v31, (const std::string::value_type *)p_s, size);
        if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__s.__r_.__value_.__l.__data_);
        }
      }
      uint64_t v8 = &v31;
      if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v8 = (std::string *)v31.__r_.__value_.__r.__words[0];
      }
      LODWORD(__s.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__s.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Pending requests: %s", (uint8_t *)&__s, 0xCu);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
    }
  }
  unsigned int v9 = *(int **)(a1 + 72);
  uint64_t v10 = *(int **)(a1 + 80);
  if (v9 != v10)
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      memset(&v31, 0, sizeof(v31));
      sub_100BCFDCC(&__s, v9);
      std::string v31 = __s;
      for (uint64_t j = v9 + 2; j != v10; j += 2)
      {
        *((unsigned char *)&__s.__r_.__value_.__s + 23) = 1;
        strcpy((char *)&__s, ",");
        std::string::append(&v31, (const std::string::value_type *)&__s, 1uLL);
        if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__s.__r_.__value_.__l.__data_);
        }
        sub_100BCFDCC(&__s, j);
        if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          id v13 = &__s;
        }
        else {
          id v13 = (std::string *)__s.__r_.__value_.__r.__words[0];
        }
        if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v14 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v14 = __s.__r_.__value_.__l.__size_;
        }
        std::string::append(&v31, (const std::string::value_type *)v13, v14);
        if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__s.__r_.__value_.__l.__data_);
        }
      }
      id v15 = &v31;
      if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        id v15 = (std::string *)v31.__r_.__value_.__r.__words[0];
      }
      LODWORD(__s.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__s.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Pending notifications: %s", (uint8_t *)&__s, 0xCu);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
    }
  }
  uint64_t v16 = *(void *)(a1 + 128);
  uint64_t v17 = *(NSObject **)(a1 + 40);
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (v16)
  {
    if (v18)
    {
      LOWORD(__s.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Stats:", (uint8_t *)&__s, 2u);
    }
    for (CFIndex k = *(uint64_t **)(a1 + 120); k; CFIndex k = (uint64_t *)*k)
    {
      uint64_t v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v21 = k + 2;
        if (*((char *)k + 39) < 0) {
          unsigned int v21 = (void *)*v21;
        }
        sub_100062B40((std::string *)k[5], (std::string *)k[6], ",", 1uLL, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        char v24 = (int *)k[8];
        uint64_t v23 = (int *)k[9];
        memset(&v29, 0, sizeof(v29));
        if (v24 != v23)
        {
          std::to_string(&v31, *v24);
          std::string v29 = v31;
          while (++v24 != v23)
          {
            *((unsigned char *)&v31.__r_.__value_.__s + 23) = 1;
            LOWORD(v31.__r_.__value_.__l.__data_) = 44;
            std::string::append(&v29, (const std::string::value_type *)&v31, 1uLL);
            if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v31.__r_.__value_.__l.__data_);
            }
            std::to_string(&v31, *v24);
            if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v25 = &v31;
            }
            else {
              long long v25 = (std::string *)v31.__r_.__value_.__r.__words[0];
            }
            if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v26 = HIBYTE(v31.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v26 = v31.__r_.__value_.__l.__size_;
            }
            std::string::append(&v29, (const std::string::value_type *)v25, v26);
            if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v31.__r_.__value_.__l.__data_);
            }
          }
        }
        unint64_t v27 = &v29;
        if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unint64_t v27 = (std::string *)v29.__r_.__value_.__r.__words[0];
        }
        LODWORD(__s.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)__s.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
        WORD2(__s.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&__s.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_p;
        HIWORD(__s.__r_.__value_.__r.__words[2]) = 2080;
        int v33 = v27;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I  - %s: requests=[%s], events=[%s]", (uint8_t *)&__s, 0x20u);
        if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v29.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
    }
  }
  else if (v18)
  {
    if (*(unsigned char *)(a1 + 97)) {
      xpc_object_t v28 = "empty";
    }
    else {
      xpc_object_t v28 = "disabled";
    }
    LODWORD(__s.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__s.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Stats: %s", (uint8_t *)&__s, 0xCu);
  }
}

void sub_100BCE9E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_100BCEA7C(std::string *result, int *a2)
{
  uint64_t v2 = *(uint64_t **)(result[1].__r_.__value_.__r.__words[2] + 120);
  if (v2)
  {
    BOOL v4 = result;
    BOOL v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 4);
    do
    {
      uint64_t v6 = (const std::string *)v2[5];
      uint64_t v7 = (const std::string *)v2[6];
      while (v6 != v7)
      {
        ++*(void *)(*(void *)(v4[1].__r_.__value_.__l.__size_ + 8) + 24);
        int v8 = a2[7];
        uint64_t v9 = a2[6];
        if ((int)v9 >= v8)
        {
          if (v8 == a2[8])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v8 + 1);
            int v8 = a2[7];
          }
          a2[7] = v8 + 1;
          sub_10000BFA0();
        }
        uint64_t v10 = *((void *)a2 + 2);
        a2[6] = v9 + 1;
        uint64_t v11 = *(void *)(v10 + 8 * v9);
        *(_DWORD *)(v11 + 44) |= 1u;
        id v12 = *(std::string **)(v11 + 8);
        if (v12 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        std::string::operator=(v12, (const std::string *)(v2 + 2));
        *(_DWORD *)(v11 + 44) |= 4u;
        id v13 = *(std::string **)(v11 + 24);
        if (v13 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = std::string::operator=(v13, v6++);
      }
      std::string::size_type v14 = (int *)v2[8];
      id v15 = (int *)v2[9];
      while (v14 != v15)
      {
        ++*(void *)(*(void *)(v4[1].__r_.__value_.__l.__size_ + 8) + 24);
        int v16 = a2[7];
        uint64_t v17 = a2[6];
        if ((int)v17 >= v16)
        {
          if (v16 == a2[8])
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v16 + 1);
            int v16 = a2[7];
          }
          a2[7] = v16 + 1;
          sub_10000BFA0();
        }
        uint64_t v18 = *((void *)a2 + 2);
        a2[6] = v17 + 1;
        uint64_t v19 = *(void *)(v18 + 8 * v17);
        *(_DWORD *)(v19 + 44) |= 1u;
        uint64_t v20 = *(std::string **)(v19 + 8);
        if (v20 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        std::string::operator=(v20, (const std::string *)(v2 + 2));
        unsigned int v21 = (char *)sub_100027EA4(*v14);
        *(_DWORD *)(v19 + 44) |= 8u;
        size_t v22 = *(std::string **)(v19 + 32);
        if (v22 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
          operator new();
        }
        uint64_t result = sub_10003ED78(v22, v21);
        ++v14;
      }
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  return result;
}

void sub_100BCED18(unint64_t *a1, unsigned __int8 *a2)
{
  unint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  if (v4 != *a1)
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - *a1) >> 3);
    do
    {
      uint64_t v7 = (void *)(v5 + 24 * (v6 >> 1));
      int v8 = (char)sub_100046FE8(v7, (void **)a2);
      if (v8 >= 0) {
        v6 >>= 1;
      }
      else {
        v6 += ~(v6 >> 1);
      }
      if (v8 < 0) {
        unint64_t v5 = (unint64_t)(v7 + 3);
      }
    }
    while (v6);
    uint64_t v4 = v5;
    unint64_t v5 = a1[1];
  }
  if (v5 != v4)
  {
    uint64_t v9 = *(unsigned __int8 *)(v4 + 23);
    if ((v9 & 0x80u) == 0) {
      uint64_t v10 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      uint64_t v10 = *(void *)(v4 + 8);
    }
    uint64_t v11 = a2[23];
    int v12 = (char)v11;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *((void *)a2 + 1);
    }
    if (v10 == v11)
    {
      if (v12 >= 0) {
        id v13 = a2;
      }
      else {
        id v13 = *(unsigned __int8 **)a2;
      }
      if ((v9 & 0x80) != 0)
      {
        if (!memcmp(*(const void **)v4, v13, *(void *)(v4 + 8))) {
          return;
        }
      }
      else
      {
        if (!*(unsigned char *)(v4 + 23)) {
          return;
        }
        for (uint64_t i = (unsigned __int8 *)v4; *i == *v13; ++i)
        {
          ++v13;
          if (!--v9) {
            return;
          }
        }
      }
    }
  }
  unint64_t v15 = a1[2];
  if (v5 >= v15)
  {
    unint64_t v16 = *a1;
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3) + 1;
    if (v17 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D8578();
    }
    int64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v16) >> 3);
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - v16) >> 3);
    if (2 * v19 > v17) {
      unint64_t v17 = 2 * v19;
    }
    if (v19 >= 0x555555555555555) {
      unint64_t v20 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v20 = v17;
    }
    int v46 = a1 + 2;
    if (v20)
    {
      unsigned int v21 = (char *)sub_10004812C((uint64_t)(a1 + 2), v20);
      uint64_t v23 = v22;
    }
    else
    {
      unsigned int v21 = 0;
      uint64_t v23 = 0;
    }
    char v24 = (long long *)&v21[8 * ((uint64_t)(v4 - v16) >> 3)];
    uint64_t v42 = v21;
    int v43 = (char *)v24;
    uint64_t v44 = (uint64_t)v24;
    char v45 = &v21[24 * v23];
    if (v18 == v23)
    {
      if ((uint64_t)(v4 - v16) < 1)
      {
        if (v4 == v16) {
          unint64_t v27 = 1;
        }
        else {
          unint64_t v27 = 0x5555555555555556 * ((uint64_t)(v4 - v16) >> 3);
        }
        uint64_t v50 = a1 + 2;
        xpc_object_t v28 = (char *)sub_10004812C((uint64_t)(a1 + 2), v27);
        uint64_t v30 = v43;
        uint64_t v31 = v44;
        uint64_t v32 = v43;
        uint64_t v33 = (uint64_t)&v28[24 * (v27 >> 2)];
        uint64_t v34 = v44 - (void)v43;
        if ((char *)v44 != v43)
        {
          uint64_t v33 = (uint64_t)&v28[24 * (v27 >> 2) + 24 * (v34 / 24)];
          uint64_t v35 = 24 * (v34 / 24);
          int v36 = &v28[24 * (v27 >> 2)];
          CCCryptorStatus v37 = v43;
          do
          {
            long long v38 = *(_OWORD *)v37;
            *((void *)v36 + 2) = *((void *)v37 + 2);
            *(_OWORD *)int v36 = v38;
            v36 += 24;
            *((void *)v37 + 1) = 0;
            *((void *)v37 + 2) = 0;
            *(void *)CCCryptorStatus v37 = 0;
            v37 += 24;
            v35 -= 24;
          }
          while (v35);
          uint64_t v32 = (char *)v31;
        }
        __int16 v39 = v42;
        uint64_t v40 = v45;
        uint64_t v42 = v28;
        int v43 = &v28[24 * (v27 >> 2)];
        *(void *)&long long __dst = v39;
        *((void *)&__dst + 1) = v30;
        uint64_t v44 = v33;
        char v45 = &v28[24 * v29];
        uint64_t v48 = v32;
        CFNumberRef v49 = v40;
        sub_100048174((uint64_t)&__dst);
        char v24 = (long long *)v44;
      }
      else
      {
        if (v18 >= -1) {
          uint64_t v25 = v18 + 1;
        }
        else {
          uint64_t v25 = v18 + 2;
        }
        sub_1000D935C((uint64_t)&__dst, v24, v24, (uint64_t)v24 - 24 * (v25 >> 1));
        v43 -= 24 * (v25 >> 1);
        uint64_t v44 = (uint64_t)v24;
      }
    }
    if ((char)a2[23] < 0)
    {
      sub_10004FC84(v24, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v41 = *(_OWORD *)a2;
      *((void *)v24 + 2) = *((void *)a2 + 2);
      long long *v24 = v41;
    }
    v44 += 24;
    sub_100861100((uint64_t)a1, &v42, (long long *)v4);
    sub_100048174((uint64_t)&v42);
  }
  else if (v4 == v5)
  {
    sub_10030BFC4(a1, (long long *)a2);
  }
  else
  {
    long long __dst = 0uLL;
    uint64_t v48 = 0;
    CFNumberRef v49 = (char *)(a1 + 2);
    if ((char)a2[23] < 0)
    {
      sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
      unint64_t v5 = a1[1];
    }
    else
    {
      long long __dst = *(_OWORD *)a2;
      uint64_t v48 = (char *)*((void *)a2 + 2);
    }
    sub_100861090((uint64_t)a1, v4, v5, v4 + 24);
    if (*(char *)(v4 + 23) < 0) {
      operator delete(*(void **)v4);
    }
    long long v26 = __dst;
    *(void *)(v4 + 16) = v48;
    *(_OWORD *)uint64_t v4 = v26;
  }
}

void sub_100BCF0E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCF110(char **a1, _DWORD *a2)
{
  unint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = v4 - *a1;
  if (v4 == *a1)
  {
    int v8 = a1[1];
  }
  else
  {
    unint64_t v7 = v6 >> 2;
    int v8 = *a1;
    do
    {
      unint64_t v9 = v7 >> 1;
      uint64_t v10 = &v8[4 * (v7 >> 1)];
      int v12 = *(_DWORD *)v10;
      uint64_t v11 = v10 + 4;
      v7 += ~(v7 >> 1);
      if (v12 < *a2) {
        int v8 = v11;
      }
      else {
        unint64_t v7 = v9;
      }
    }
    while (v7);
  }
  if (v4 == v8 || *(_DWORD *)v8 != *a2)
  {
    uint64_t v13 = v8 - v5;
    std::string::size_type v14 = &v5[(v8 - v5) & 0xFFFFFFFFFFFFFFFCLL];
    unint64_t v15 = (unint64_t)a1[2];
    if ((unint64_t)v4 >= v15)
    {
      unint64_t v21 = (v6 >> 2) + 1;
      if (v21 >> 62) {
        sub_100BCF9C0();
      }
      uint64_t v22 = v13 >> 2;
      unint64_t v23 = v15 - (void)v5;
      unint64_t v24 = (uint64_t)(v15 - (void)v5) >> 1;
      if (v24 > v21) {
        unint64_t v21 = v24;
      }
      if (v23 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v25 = v21;
      }
      if (v25) {
        long long v26 = (char *)sub_10005ECD8((uint64_t)(a1 + 2), v25);
      }
      else {
        long long v26 = 0;
      }
      unint64_t v27 = &v26[4 * v22];
      xpc_object_t v28 = &v26[4 * v25];
      if (v22 == v25)
      {
        if (v13 < 1)
        {
          if (v8 == v5) {
            unint64_t v30 = 1;
          }
          else {
            unint64_t v30 = v13 >> 1;
          }
          uint64_t v31 = (char *)sub_10005ECD8((uint64_t)(a1 + 2), v30);
          unint64_t v27 = &v31[v30 & 0xFFFFFFFFFFFFFFFCLL];
          xpc_object_t v28 = &v31[4 * v32];
          if (v26)
          {
            uint64_t v33 = &v31[4 * v32];
            operator delete(v26);
            xpc_object_t v28 = v33;
          }
        }
        else
        {
          unint64_t v29 = v22 + 2;
          if (v22 >= -1) {
            unint64_t v29 = v22 + 1;
          }
          v27 -= 4 * (v29 >> 1);
        }
      }
      *(_DWORD *)unint64_t v27 = *a2;
      uint64_t v34 = v27 + 4;
      uint64_t v35 = *a1;
      if (*a1 != v14)
      {
        int v36 = v14;
        do
        {
          int v37 = *((_DWORD *)v36 - 1);
          v36 -= 4;
          *((_DWORD *)v27 - 1) = v37;
          v27 -= 4;
        }
        while (v36 != v35);
      }
      long long v38 = a1[1];
      int64_t v39 = v38 - v14;
      if (v38 != v14)
      {
        uint64_t v40 = v14;
        size_t v41 = v38 - v14;
        uint64_t v42 = v28;
        memmove(v34, v40, v41);
        xpc_object_t v28 = v42;
      }
      int v43 = *a1;
      *a1 = v27;
      a1[1] = &v34[v39];
      a1[2] = v28;
      if (v43)
      {
        operator delete(v43);
      }
    }
    else
    {
      int v16 = *a2;
      if (v14 == v4)
      {
        *(_DWORD *)uint64_t v4 = v16;
        a1[1] = v4 + 4;
      }
      else
      {
        unint64_t v17 = v14 + 4;
        int64_t v18 = v4 - 4;
        unint64_t v19 = a1[1];
        while (v18 < v4)
        {
          int v20 = *(_DWORD *)v18;
          v18 += 4;
          *(_DWORD *)unint64_t v19 = v20;
          v19 += 4;
        }
        a1[1] = v19;
        if (v4 != v17) {
          memmove(&v4[-4 * ((v4 - v17) >> 2)], &v5[(v8 - v5) & 0xFFFFFFFFFFFFFFFCLL], v4 - v17);
        }
        *(_DWORD *)std::string::size_type v14 = v16;
      }
    }
  }
}

void sub_100BCF37C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCF394(void *a1, int __val)
{
  if (a1[6] == a1[7] || a1[9] == a1[10])
  {
    std::to_string(&v52, __val);
    uint64_t v4 = std::string::insert(&v52, 0, "pid-", 4uLL);
    long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    std::string::size_type v51 = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v50 = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v52.__r_.__value_.__l.__data_);
    }
    int64x2_t v48 = 0uLL;
    unint64_t v49 = 0;
    uint64_t v7 = a1[6];
    uint64_t v6 = a1[7];
    if (v7 != v6)
    {
LABEL_6:
      while (*(_DWORD *)v7 != __val)
      {
        v7 += 32;
        if (v7 == v6)
        {
          uint64_t v7 = v6;
          goto LABEL_12;
        }
      }
      while (1)
      {
        v6 -= 32;
        if (v6 == v7) {
          break;
        }
        if (*(_DWORD *)v6 != __val)
        {
          *(_DWORD *)uint64_t v7 = *(_DWORD *)v6;
          *(_DWORD *)uint64_t v6 = __val;
          long long v8 = *(_OWORD *)(v7 + 8);
          v52.__r_.__value_.__r.__words[2] = *(void *)(v7 + 24);
          *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v8;
          long long v9 = *(_OWORD *)(v6 + 8);
          *(void *)(v7 + 24) = *(void *)(v6 + 24);
          *(_OWORD *)(v7 + 8) = v9;
          long long v10 = *(_OWORD *)&v52.__r_.__value_.__l.__data_;
          *(void *)(v6 + 24) = *((void *)&v52.__r_.__value_.__l + 2);
          *(_OWORD *)(v6 + 8) = v10;
          v7 += 32;
          if (v6 != v7) {
            goto LABEL_6;
          }
          break;
        }
      }
    }
LABEL_12:
    int64x2_t v48 = 0uLL;
    unint64_t v49 = 0;
    uint64_t v11 = a1[7];
    if (v7 == v11)
    {
      unint64_t v12 = 0;
      uint64_t v28 = v7;
    }
    else
    {
      unint64_t v12 = 0;
      uint64_t v13 = v7;
      do
      {
        if (v12 >= v49)
        {
          uint64_t v15 = (uint64_t)(v12 - v48.i64[0]) >> 5;
          if ((unint64_t)(v15 + 1) >> 59) {
            sub_100BCF9C0();
          }
          unint64_t v16 = (uint64_t)(v49 - v48.i64[0]) >> 4;
          if (v16 <= v15 + 1) {
            unint64_t v16 = v15 + 1;
          }
          if (v49 - v48.i64[0] >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v17 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v17 = v16;
          }
          uint64_t v54 = &v49;
          if (v17) {
            unint64_t v17 = (unint64_t)sub_1000509C0(v17);
          }
          else {
            uint64_t v18 = 0;
          }
          unint64_t v19 = v17 + 32 * v15;
          *(_DWORD *)unint64_t v19 = *(_DWORD *)v13;
          long long v20 = *(_OWORD *)(v13 + 8);
          *(void *)(v19 + 24) = *(void *)(v13 + 24);
          *(_OWORD *)(v19 + 8) = v20;
          *(void *)(v13 + 16) = 0;
          *(void *)(v13 + 24) = 0;
          *(void *)(v13 + 8) = 0;
          uint64_t v21 = v48.i64[1];
          uint64_t v22 = v48.i64[0];
          if (v48.i64[1] == v48.i64[0])
          {
            int64x2_t v26 = vdupq_n_s64(v48.u64[1]);
            unint64_t v23 = v17 + 32 * v15;
          }
          else
          {
            unint64_t v23 = v17 + 32 * v15;
            do
            {
              int v24 = *(_DWORD *)(v21 - 32);
              v21 -= 32;
              *(_DWORD *)(v23 - 32) = v24;
              v23 -= 32;
              long long v25 = *(_OWORD *)(v21 + 8);
              *(void *)(v23 + 24) = *(void *)(v21 + 24);
              *(_OWORD *)(v23 + 8) = v25;
              *(void *)(v21 + 16) = 0;
              *(void *)(v21 + 24) = 0;
              *(void *)(v21 + 8) = 0;
            }
            while (v21 != v22);
            int64x2_t v26 = v48;
          }
          unint64_t v12 = v19 + 32;
          v48.i64[0] = v23;
          v48.i64[1] = v19 + 32;
          *(int64x2_t *)&v52.__r_.__value_.__r.__words[1] = v26;
          unint64_t v27 = v49;
          unint64_t v49 = v17 + 32 * v18;
          unint64_t v53 = v27;
          v52.__r_.__value_.__r.__words[0] = v26.i64[0];
          sub_100255B70((uint64_t)&v52);
        }
        else
        {
          *(_DWORD *)unint64_t v12 = *(_DWORD *)v13;
          long long v14 = *(_OWORD *)(v13 + 8);
          *(void *)(v12 + 24) = *(void *)(v13 + 24);
          *(_OWORD *)(v12 + 8) = v14;
          *(void *)(v13 + 16) = 0;
          *(void *)(v13 + 24) = 0;
          *(void *)(v13 + 8) = 0;
          v12 += 32;
        }
        v48.i64[1] = v12;
        v13 += 32;
      }
      while (v13 != v11);
      uint64_t v28 = a1[7];
    }
    if (v7 != v28)
    {
      while (v28 != v7)
      {
        if (*(char *)(v28 - 1) < 0) {
          operator delete(*(void **)(v28 - 24));
        }
        v28 -= 32;
      }
      a1[7] = v7;
      unint64_t v12 = v48.u64[1];
    }
    for (uint64_t i = v48.i64[0]; i != v12; i += 32)
    {
      if (*(char *)(i + 31) < 0)
      {
        sub_10004FC84(__p, *(void **)(i + 8), *(void *)(i + 16));
      }
      else
      {
        long long v30 = *(_OWORD *)(i + 8);
        uint64_t v47 = *(void *)(i + 24);
        *(_OWORD *)std::string __p = v30;
      }
      sub_100004E20((uint64_t)a1, (unsigned __int8 *)__p, __val, (unsigned __int8 *)v50);
      if (SHIBYTE(v47) < 0) {
        operator delete(__p[0]);
      }
    }
    memset(&v52, 0, sizeof(v52));
    uint64_t v31 = (_DWORD *)a1[9];
    uint64_t v32 = (_DWORD *)a1[10];
    if (v31 != v32)
    {
      uint64_t v33 = (_DWORD *)a1[10];
LABEL_51:
      while (*v31 != __val)
      {
        v31 += 2;
        if (v31 == v33)
        {
          uint64_t v31 = v33;
          goto LABEL_57;
        }
      }
      while (1)
      {
        v33 -= 2;
        if (v33 == v31) {
          break;
        }
        if (*v33 != __val)
        {
          *uint64_t v31 = *v33;
          _DWORD *v33 = __val;
          int v34 = v31[1];
          v31[1] = v33[1];
          v33[1] = v34;
          v31 += 2;
          if (v33 != v31) {
            goto LABEL_51;
          }
          break;
        }
      }
    }
LABEL_57:
    memset(&v52, 0, sizeof(v52));
    if (v31 == v32)
    {
      uint64_t v35 = 0;
    }
    else
    {
      uint64_t v35 = 0;
      int v36 = v31;
      do
      {
        if ((unint64_t)v35 >= v52.__r_.__value_.__r.__words[2])
        {
          uint64_t v37 = (uint64_t)((uint64_t)v35 - v52.__r_.__value_.__r.__words[0]) >> 3;
          if ((unint64_t)(v37 + 1) >> 61) {
            sub_100BCF9C0();
          }
          unint64_t v38 = (uint64_t)(v52.__r_.__value_.__r.__words[2] - v52.__r_.__value_.__r.__words[0]) >> 2;
          if (v38 <= v37 + 1) {
            unint64_t v38 = v37 + 1;
          }
          if (v52.__r_.__value_.__r.__words[2] - v52.__r_.__value_.__r.__words[0] >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v39 = v38;
          }
          if (v39) {
            uint64_t v40 = (char *)sub_10004EF74((uint64_t)&v52.__r_.__value_.__r.__words[2], v39);
          }
          else {
            uint64_t v40 = 0;
          }
          size_t v41 = &v40[8 * v37];
          *(void *)size_t v41 = *v36;
          uint64_t v35 = v41 + 8;
          std::string::size_type size = (char *)v52.__r_.__value_.__l.__size_;
          std::string::size_type v43 = v52.__r_.__value_.__r.__words[0];
          if (v52.__r_.__value_.__l.__size_ != v52.__r_.__value_.__r.__words[0])
          {
            do
            {
              uint64_t v44 = *((void *)size - 1);
              size -= 8;
              *((void *)v41 - 1) = v44;
              v41 -= 8;
            }
            while (size != (char *)v43);
            std::string::size_type size = (char *)v52.__r_.__value_.__r.__words[0];
          }
          v52.__r_.__value_.__r.__words[0] = (std::string::size_type)v41;
          v52.__r_.__value_.__l.__size_ = (std::string::size_type)v35;
          v52.__r_.__value_.__r.__words[2] = (std::string::size_type)&v40[8 * v39];
          if (size) {
            operator delete(size);
          }
        }
        else
        {
          *v35++ = *v36;
        }
        v52.__r_.__value_.__l.__size_ = (std::string::size_type)v35;
        ++v36;
      }
      while (v36 != (void *)v32);
      uint64_t v32 = (_DWORD *)a1[10];
    }
    if (v31 != v32) {
      a1[10] = v31;
    }
    std::string::size_type v45 = v52.__r_.__value_.__r.__words[0];
    if (v52.__r_.__value_.__l.__data_ != (std::string::pointer)v35)
    {
      do
      {
        sub_1000096C8((uint64_t)a1, *(_DWORD *)(v45 + 4), __val, (unsigned __int8 *)v50);
        v45 += 8;
      }
      while ((void *)v45 != v35);
      uint64_t v35 = (void *)v52.__r_.__value_.__r.__words[0];
    }
    if (v35)
    {
      v52.__r_.__value_.__l.__size_ = (std::string::size_type)v35;
      operator delete(v35);
    }
    v52.__r_.__value_.__r.__words[0] = (std::string::size_type)&v48;
    sub_100B05F98((void ***)&v52);
    if (SHIBYTE(v51) < 0) {
      operator delete(v50[0]);
    }
  }
}

void sub_100BCF934(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCF9C0()
{
}

void sub_100BCF9D8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100BCFAA4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100BCFB7C);
  __cxa_rethrow();
}

void sub_100BCFACC(_Unwind_Exception *a1)
{
}

void sub_100BCFAE4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BCFB1C(uint64_t a1)
{
}

uint64_t sub_100BCFB38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BCFB7C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100BCFBA8(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      uint64_t v2 = (void *)*v1;
      sub_100BCFBEC((uint64_t)(v1 + 2));
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

void sub_100BCFBEC(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 24);
  uint64_t v3 = *(void **)(a1 + 48);
  if (v3)
  {
    *(void *)(a1 + 56) = v3;
    operator delete(v3);
  }
  uint64_t v4 = v2;
  sub_100047F64(&v4);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

uint64_t sub_100BCFC44(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100BCFC54(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100BCFC70(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100BCFC80(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_100BCFBA8(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void sub_100BCFCD8(std::string *a1, uint64_t a2)
{
  std::to_string(&v13, *(_DWORD *)a2);
  uint64_t v4 = std::string::append(&v13, ":", 1uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v14.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  long long v8 = *(const std::string::value_type **)(a2 + 8);
  uint64_t v7 = a2 + 8;
  uint64_t v6 = v8;
  int v9 = *(char *)(v7 + 23);
  if (v9 >= 0) {
    long long v10 = (const std::string::value_type *)v7;
  }
  else {
    long long v10 = v6;
  }
  if (v9 >= 0) {
    std::string::size_type v11 = *(unsigned __int8 *)(v7 + 23);
  }
  else {
    std::string::size_type v11 = *(void *)(v7 + 8);
  }
  unint64_t v12 = std::string::append(&v14, v10, v11);
  *a1 = *v12;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
}

void sub_100BCFD98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BCFDCC(std::string *a1, int *a2)
{
  std::to_string(&v9, *a2);
  uint64_t v4 = std::string::append(&v9, ":", 1uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v10.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v10.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  uint64_t v6 = sub_100027EA4(a2[1]);
  size_t v7 = strlen(v6);
  long long v8 = std::string::append(&v10, v6, v7);
  *a1 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

void sub_100BCFE88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100BCFEBC(uint64_t a1, unsigned __int8 *a2, long long **a3)
{
  uint64_t v6 = (void *)(a1 + 24);
  unint64_t v7 = sub_100206390(a1 + 24, (uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v12 = v7;
      if (v7 >= v9) {
        unint64_t v12 = v7 % v9;
      }
    }
    else
    {
      unint64_t v12 = (v9 - 1) & v7;
    }
    std::string v13 = *(void ***)(*(void *)a1 + 8 * v12);
    if (v13)
    {
      std::string v14 = (char *)*v13;
      if (*v13)
      {
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v8)
          {
            if (sub_1000609C0(a1 + 32, (unsigned __int8 *)v14 + 16, a2)) {
              return v14;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v15 >= v9) {
                v15 %= v9;
              }
            }
            else
            {
              v15 &= v9 - 1;
            }
            if (v15 != v12) {
              break;
            }
          }
          std::string v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  unint64_t v16 = (void *)(a1 + 16);
  v29[2] = 1;
  std::string v14 = (char *)operator new(0x58uLL);
  v29[0] = v14;
  v29[1] = a1 + 16;
  *(void *)std::string v14 = 0;
  *((void *)v14 + 1) = v8;
  unint64_t v17 = *a3;
  long long v18 = **a3;
  *((void *)v14 + 4) = *((void *)*a3 + 2);
  *((_OWORD *)v14 + 1) = v18;
  *((void *)v17 + 1) = 0;
  *((void *)v17 + 2) = 0;
  *(void *)unint64_t v17 = 0;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  *(_OWORD *)(v14 + 72) = 0u;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    BOOL v21 = 1;
    if (v9 >= 3) {
      BOOL v21 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v9);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    sub_100BD0148(a1, v24);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v12 = v8 % v9;
      }
      else {
        unint64_t v12 = v8;
      }
    }
    else
    {
      unint64_t v12 = (v9 - 1) & v8;
    }
  }
  uint64_t v25 = *(void *)a1;
  int64x2_t v26 = *(void **)(*(void *)a1 + 8 * v12);
  if (v26)
  {
    *(void *)std::string v14 = *v26;
LABEL_38:
    void *v26 = v14;
    goto LABEL_39;
  }
  *(void *)std::string v14 = *v16;
  void *v16 = v14;
  *(void *)(v25 + 8 * v12) = v16;
  if (*(void *)v14)
  {
    unint64_t v27 = *(void *)(*(void *)v14 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v27 >= v9) {
        v27 %= v9;
      }
    }
    else
    {
      v27 &= v9 - 1;
    }
    int64x2_t v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_38;
  }
LABEL_39:
  v29[0] = 0;
  ++*v6;
  sub_100BD0344((uint64_t)v29);
  return v14;
}

void sub_100BD0134(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100BD0344((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100BD0148(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      unint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    sub_10006A7CC();
  }
  long long v5 = operator new(8 * prime);
  uint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  unint64_t v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    std::string v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *unint64_t v8 = *v14;
          void *v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          std::string v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        unint64_t v8 = v14;
        std::string v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

void sub_100BD0344(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100BCFBEC((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

char *sub_100BD039C(uint64_t a1, unsigned __int8 *a2, long long **a3)
{
  uint64_t v6 = (void *)(a1 + 24);
  unint64_t v7 = sub_100206390(a1 + 24, (uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v12 = v7;
      if (v7 >= v9) {
        unint64_t v12 = v7 % v9;
      }
    }
    else
    {
      unint64_t v12 = (v9 - 1) & v7;
    }
    uint64_t v13 = *(void ***)(*(void *)a1 + 8 * v12);
    if (v13)
    {
      std::string v14 = (char *)*v13;
      if (*v13)
      {
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v8)
          {
            if (sub_1000609C0(a1 + 32, (unsigned __int8 *)v14 + 16, a2)) {
              return v14;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v15 >= v9) {
                v15 %= v9;
              }
            }
            else
            {
              v15 &= v9 - 1;
            }
            if (v15 != v12) {
              break;
            }
          }
          std::string v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  unint64_t v16 = *a3;
  unint64_t v17 = (void *)(a1 + 16);
  uint64_t v31 = 0;
  std::string v14 = (char *)operator new(0x58uLL);
  v30[0] = v14;
  v30[1] = a1 + 16;
  *(void *)std::string v14 = 0;
  *((void *)v14 + 1) = v8;
  long long v18 = v14 + 16;
  if (*((char *)v16 + 23) < 0)
  {
    sub_10004FC84(v18, *(void **)v16, *((void *)v16 + 1));
  }
  else
  {
    long long v19 = *v16;
    *((void *)v14 + 4) = *((void *)v16 + 2);
    *(_OWORD *)long long v18 = v19;
  }
  *(_OWORD *)(v14 + 72) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  LOBYTE(v31) = 1;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v9 || (float)(v21 * (float)v9) < v20)
  {
    BOOL v22 = 1;
    if (v9 >= 3) {
      BOOL v22 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v9);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    sub_100BD0148(a1, v25);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v12 = v8 % v9;
      }
      else {
        unint64_t v12 = v8;
      }
    }
    else
    {
      unint64_t v12 = (v9 - 1) & v8;
    }
  }
  uint64_t v26 = *(void *)a1;
  unint64_t v27 = *(void **)(*(void *)a1 + 8 * v12);
  if (v27)
  {
    *(void *)std::string v14 = *v27;
LABEL_41:
    *unint64_t v27 = v14;
    goto LABEL_42;
  }
  *(void *)std::string v14 = *v17;
  void *v17 = v14;
  *(void *)(v26 + 8 * v12) = v17;
  if (*(void *)v14)
  {
    unint64_t v28 = *(void *)(*(void *)v14 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v28 >= v9) {
        v28 %= v9;
      }
    }
    else
    {
      v28 &= v9 - 1;
    }
    unint64_t v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_41;
  }
LABEL_42:
  v30[0] = 0;
  ++*v6;
  sub_100BD0344((uint64_t)v30);
  return v14;
}

void sub_100BD0628(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100BD0344((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100BD0640(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100BD06C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BD0704(uint64_t a1, void *a2, int a3, void *a4)
{
  unint64_t v8 = (ctu::OsLogLogger *)(a1 + 8);
  unint64_t v9 = "roam.user.?";
  if (a3 == 2) {
    unint64_t v9 = "roam.user.2";
  }
  if (a3 == 1) {
    uint8x8_t v10 = "roam.user.1";
  }
  else {
    uint8x8_t v10 = v9;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v14, kCtLoggingSystemName, v10);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v15, &v14);
  ctu::OsLogLogger::OsLogLogger(v8, (const ctu::OsLogLogger *)v15);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v15);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v14);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_101A44DC8;
  *(void *)(a1 + 32) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 40) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 48) = a3;
  *(_WORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 72) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  Registry::getNotificationSenderFactory((uint64_t *)&v14, *(Registry **)(a1 + 32));
  (*(void (**)(char *))(*(void *)v14.var0 + 64))(v14.var0);
  if (v14.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v14.var1.fRef);
  }
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  return a1;
}

void sub_100BD0888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, char a12)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  unint64_t v15 = (std::__shared_weak_count *)*((void *)v12 + 9);
  if (v15) {
    sub_10004D2C8(v15);
  }
  unint64_t v16 = (std::__shared_weak_count *)*((void *)v12 + 5);
  if (v16) {
    sub_10004D2C8(v16);
  }
  unint64_t v17 = (std::__shared_weak_count *)*((void *)v12 + 3);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  UserRoamingSettingInterface::~UserRoamingSettingInterface(v12);
  _Unwind_Resume(a1);
}

void sub_100BD0904(uint64_t a1)
{
  *(void *)a1 = off_101A44DC8;
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int8x8_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  UserRoamingSettingInterface::~UserRoamingSettingInterface((UserRoamingSettingInterface *)a1);
}

void sub_100BD09A0(uint64_t a1)
{
  sub_100BD0904(a1);

  operator delete();
}

uint64_t sub_100BD09D8(capabilities::ct *a1)
{
  if (capabilities::ct::supportsGemini(a1))
  {
    return sub_100BD1948((uint64_t)a1);
  }
  else
  {
    return sub_100BD1804((uint64_t)a1);
  }
}

void sub_100BD0A34(uint64_t a1)
{
  if (!capabilities::ct::supportsGemini((capabilities::ct *)a1)) {
    return;
  }
  PersonalityIdFromSlotId();
  std::string::operator=((std::string *)(a1 + 96), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  unsigned __int16 v2 = sub_100BD1804(a1);
  if (v2 <= 0xFFu)
  {
    uint64_t v3 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Migration not needed for user's data roaming setting", (uint8_t *)&__p, 2u);
    }
    return;
  }
  memset(&__p, 0, sizeof(__p));
  PersonalityIdFromSlotId();
  int8x8_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = p_p;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Start InternationalRoamingEDGE migration for %s", buf, 0xCu);
  }
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    float v20 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, "PersonalityId is not valid", buf, 2u);
    }
    goto LABEL_41;
  }
  if ((isReal() & 1) == 0)
  {
    float v21 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "PersonalityId is not real", buf, 2u);
    }
    goto LABEL_41;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 32));
  unint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v10;
  OsLogContext v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_28:
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_21;
    }
    goto LABEL_29;
  }
  uint64_t v16 = v14[3];
  unint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_28;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (!v16)
  {
LABEL_21:
    long long v18 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_39;
    }
    *(_WORD *)long long buf = 0;
    long long v19 = "Failed to get Personal Wallet interface";
    goto LABEL_34;
  }
LABEL_29:
  BOOL v22 = &kCFBooleanTrue;
  if (!(_BYTE)v2) {
    BOOL v22 = &kCFBooleanFalse;
  }
  if (!(*(unsigned int (**)(uint64_t, std::string *, const __CFString *, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v16 + 48))(v16, &__p, @"InternationalRoamingEDGE", *v22, 0, 0, 1, 0))
  {
    if (!*(unsigned char *)(a1 + 53) || *(unsigned __int8 *)(a1 + 52) != v2)
    {
      *(_WORD *)(a1 + 52) = v2;
      sub_100BD1BAC(a1);
    }
    sub_100BD1AD0(a1);
    goto LABEL_39;
  }
  long long v18 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    long long v19 = "Could not store InternationalRoamingEDGE";
LABEL_34:
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v19, buf, 2u);
  }
LABEL_39:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
LABEL_41:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100BD0DF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BD0E48(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 52);
}

uint64_t sub_100BD0E50(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t sub_100BD0E58(uint64_t a1, int a2, int a3)
{
  if (*(unsigned char *)(a1 + 53) && *(unsigned __int8 *)(a1 + 52) == a2) {
    return 0;
  }
  *(_WORD *)(a1 + 52) = a2 | 0x100;
  sub_100BD1BAC(a1);
  *(_DWORD *)(a1 + 56) = a3;
  unint64_t v7 = *(NSObject **)(a1 + 8);
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (a2) {
      unint64_t v9 = "true";
    }
    else {
      unint64_t v9 = "false";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Raw roaming setting has changed to %s due to %s; saving it in preferences",
      buf,
      0x16u);
  }
  if ((capabilities::ct::supportsGemini((capabilities::ct *)v8) & 1) == 0)
  {
    uint64_t v27 = *(void *)(a1 + 64);
    uint64_t v26 = (void *)(a1 + 64);
    uint64_t v25 = v27;
    if (*((_DWORD *)v26 - 4) == 2) {
      CFStringRef v28 = @"InternationalRoamingEDGE-2";
    }
    else {
      CFStringRef v28 = @"InternationalRoamingEDGE";
    }
    unint64_t v29 = &kCFBooleanTrue;
    if (!a2) {
      unint64_t v29 = &kCFBooleanFalse;
    }
    (*(void (**)(uint64_t, const __CFString *, const CFBooleanRef, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v25 + 16))(v25, v28, *v29, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    (*(void (**)(void, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)*v26 + 48))(*v26, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    goto LABEL_42;
  }
  memset(buf, 0, sizeof(buf));
  PersonalityIdFromSlotId();
  uint64_t v10 = (uint64_t *)buf[23];
  if ((buf[23] & 0x80u) != 0) {
    uint64_t v10 = *(uint64_t **)&buf[8];
  }
  if (!v10)
  {
    long long v30 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)int v36 = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_FAULT, "PersonalityId is not valid", v36, 2u);
    }
    int v31 = 0;
    goto LABEL_38;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 32));
  uint64_t v12 = ServiceMap;
  if (v13 < 0)
  {
    OsLogContext v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int v36 = v13;
  char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)v36);
  if (v17)
  {
    uint64_t v19 = v17[3];
    long long v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      if (!v19)
      {
LABEL_19:
        float v21 = *(NSObject **)(a1 + 8);
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          goto LABEL_36;
        }
        *(_WORD *)int v36 = 0;
        BOOL v22 = "Failed to get Personal Wallet interface";
        unint64_t v23 = v21;
        uint32_t v24 = 2;
        goto LABEL_49;
      }
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  long long v18 = 0;
  char v20 = 1;
  if (!v19) {
    goto LABEL_19;
  }
LABEL_32:
  uint64_t v32 = &kCFBooleanTrue;
  if (!a2) {
    uint64_t v32 = &kCFBooleanFalse;
  }
  if ((*(unsigned int (**)(uint64_t, uint8_t *, const __CFString *, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v19 + 48))(v19, buf, @"InternationalRoamingEDGE", *v32, 0, 0, 1, 0))
  {
    uint64_t v33 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      goto LABEL_36;
    }
    uint64_t v35 = buf;
    if ((buf[23] & 0x80u) != 0) {
      uint64_t v35 = *(uint8_t **)buf;
    }
    *(_DWORD *)int v36 = 136315138;
    *(void *)&uint8_t v36[4] = v35;
    BOOL v22 = "Could not store InternationalRoamingEDGE state for %s";
    unint64_t v23 = v33;
    uint32_t v24 = 12;
LABEL_49:
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v22, v36, v24);
LABEL_36:
    int v31 = 0;
    if (v20) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }
  int v31 = 1;
  if ((v20 & 1) == 0) {
LABEL_37:
  }
    sub_10004D2C8(v18);
LABEL_38:
  if (((char)buf[23] & 0x80000000) == 0)
  {
    if (!v31) {
      return 1;
    }
    goto LABEL_42;
  }
  operator delete(*(void **)buf);
  if (v31)
  {
LABEL_42:
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotification(DarwinNotifyCenter, @"com.apple.commcenter.InternationalRoamingEDGE.changed", 0, 0, 0);
  }
  return 1;
}

void sub_100BD12AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BD12F4(capabilities::ct *a1)
{
  if (capabilities::ct::supportsGemini(a1))
  {
    PersonalityIdFromSlotId();
    unsigned __int16 v2 = *((void *)a1 + 1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "PersonalityId is not valid", buf, 2u);
    }
  }
  return 0;
}

void sub_100BD14FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BD1528@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 32));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    BOOL v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_7;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_7:
    uint64_t v15 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to get Personal Wallet interface", buf, 2u);
    }
    int v16 = 0;
    BOOL v17 = 0;
    if (v14) {
      return v17 | (v16 << 8);
    }
LABEL_29:
    sub_10004D2C8(v12);
    return v17 | (v16 << 8);
  }
LABEL_13:
  CFBooleanRef v24 = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v13 + 64))(&cf, v13, a2, @"InternationalRoamingEDGE", 0, 0, 1);
  CFTypeRef v26 = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFBooleanRef v25 = 0;
  *(void *)long long buf = 0;
  sub_1000057AC(buf, &v26);
  if (*(void *)buf) {
    long long v18 = sub_100084B4C;
  }
  else {
    long long v18 = 0;
  }
  if (v18) {
    sub_1005AED68((const void **)&v25, (const void **)buf);
  }
  sub_100062778((const void **)buf);
  CFBooleanRef v19 = v25;
  CFBooleanRef v24 = v25;
  CFBooleanRef v25 = 0;
  sub_100062778((const void **)&v25);
  sub_1000577C4(&v26);
  sub_1000577C4(&cf);
  if (v19) {
    char v20 = sub_100084B4C;
  }
  else {
    char v20 = 0;
  }
  if (v20)
  {
    BOOL v17 = CFBooleanGetValue(v19) != 0;
    int v16 = 1;
  }
  else
  {
    float v21 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Failed to get InternationalRoamingEDGE from Personal Wallet", buf, 2u);
    }
    BOOL v17 = 0;
    int v16 = 0;
  }
  sub_100062778((const void **)&v24);
  if ((v14 & 1) == 0) {
    goto LABEL_29;
  }
  return v17 | (v16 << 8);
}

void sub_100BD17AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100BD1804(uint64_t a1)
{
  CFTypeRef cf = 0;
  if (*(_DWORD *)(a1 + 48) == 2) {
    CFStringRef v1 = @"InternationalRoamingEDGE-2";
  }
  else {
    CFStringRef v1 = @"InternationalRoamingEDGE";
  }
  (*(void (**)(CFTypeRef *__return_ptr, void, const __CFString *, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(a1 + 64) + 40))(&cf, *(void *)(a1 + 64), v1, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  unsigned __int16 v2 = (int *)cf;
  if (!cf) {
    goto LABEL_12;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 != CFBooleanGetTypeID())
  {
    unsigned __int16 v2 = (int *)cf;
    if (cf)
    {
      CFTypeID v5 = CFGetTypeID(cf);
      if (v5 == CFNumberGetTypeID())
      {
        int v11 = 0;
        ctu::cf::assign((ctu::cf *)&v11, v2, v6);
        LODWORD(v2) = v11 != 0;
        goto LABEL_10;
      }
      LODWORD(v2) = 0;
    }
LABEL_12:
    int v7 = 0;
    goto LABEL_13;
  }
  unsigned __int8 v10 = 0;
  ctu::cf::assign((ctu::cf *)&v10, (BOOL *)v2, v4);
  LODWORD(v2) = v10;
LABEL_10:
  int v7 = 1;
LABEL_13:
  sub_1000577C4(&cf);
  return v2 | (v7 << 8);
}

void sub_100BD1928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_100BD1948(uint64_t a1)
{
  std::string __p = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  PersonalityIdFromSlotId();
  unsigned __int16 v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFBooleanRef v4 = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "PersonalityId is not valid", v4, 2u);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(__p);
  }
  return 0;
}

void sub_100BD1A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BD1A34(uint64_t a1)
{
  unsigned __int16 v2 = *(NSObject **)(a1 + 8);
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    *(_WORD *)CFTypeID v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Data Roaming preference is being reset as Network Settings have been reset", v5, 2u);
  }
  if (*(unsigned char *)(a1 + 53)) {
    *(unsigned char *)(a1 + 53) = 0;
  }
  if ((capabilities::ct::supportsGemini((capabilities::ct *)v3) & 1) == 0) {
    sub_100BD1AD0(a1);
  }
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterPostNotification(DarwinNotifyCenter, @"com.apple.commcenter.InternationalRoamingEDGE.changed", 0, 0, 0);
}

uint64_t sub_100BD1AD0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (*(_DWORD *)(a1 + 48) == 2) {
    CFStringRef v3 = @"InternationalRoamingEDGE-2";
  }
  else {
    CFStringRef v3 = @"InternationalRoamingEDGE";
  }
  (*(void (**)(uint64_t, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v2 + 16))(v2, v3, 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFBooleanRef v4 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 48);

  return v4();
}

uint64_t sub_100BD1BAC(uint64_t a1)
{
  BOOL v2 = 0;
  if (*(unsigned char *)(a1 + 53)) {
    BOOL v2 = *(unsigned char *)(a1 + 52) != 0;
  }
  return (*(uint64_t (**)(void, void, BOOL *))(**(void **)(a1 + 80) + 128))(*(void *)(a1 + 80), *(unsigned int *)(a1 + 48), &v2);
}

void sub_100BD1C18(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100BD1C98(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BD1CD4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BD1D0C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100BD1D3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100BD1D80(uint64_t a1)
{
  sub_10003E168(&v2, (void *)(a1 + 16));
  uint64_t v1 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v1);
  }
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100BD1E4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BD1E70(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    CFStringRef v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      CFBooleanRef v4 = v3;
      CFTypeID v5 = *(void **)(a1 + 32);
      if (v5)
      {
        uint64_t v6 = v5[1];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v8 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Sending Link Quality Metric", v8, 2u);
        }
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v7 = (*(uint64_t (**)(void *))(*v5 + 72))(v5);
        (*(void (**)(void *, uint64_t))(*v5 + 96))(v5, v7);
        sub_10004D2C8(v4);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100BD1F68(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100BD1F84(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100BD1FA0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100BD1FB0(uint64_t a1, void *a2)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "msg.tr.format");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)__p, (const OsLogContext *)buf);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)__p);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)__p);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  sub_100058DB0((void *)(a1 + 8), "TerminalRegistrationMessageFormat");
  *(_OWORD *)(a1 + 32) = 0u;
  CFBooleanRef v4 = (void *)(a1 + 56);
  *(_OWORD *)(a1 + 80) = 0u;
  CFTypeID v5 = (void **)(a1 + 80);
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  if (*a2) {
    uint64_t v6 = sub_1000810B8;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6)
  {
    ctu::cf::assign();
    uint64_t v7 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = a1 + 32;
      if (*(char *)(a1 + 55) < 0) {
        uint64_t v8 = *(void *)(a1 + 32);
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Terminal Registration Message Format: %s", buf, 0xCu);
    }
  }
  BOOL v22 = 0;
  uint64_t v9 = (const void *)_CFCopySystemVersionDictionary();
  BOOL v22 = v9;
  if (v9) {
    unsigned __int8 v10 = sub_100080778;
  }
  else {
    unsigned __int8 v10 = 0;
  }
  if (v10)
  {
    float v21 = 0;
    *(void *)long long buf = CFDictionaryGetValue((CFDictionaryRef)v9, _kCFSystemVersionProductVersionKey);
    sub_100056248(&v21, (CFTypeRef *)buf);
    if (v21) {
      int v11 = sub_1000810B8;
    }
    else {
      int v11 = 0;
    }
    if (v11) {
      ctu::cf::assign();
    }
    memset(buf, 0, sizeof(buf));
    sub_100BAC7F4(buf);
    uint64_t v12 = *(void **)&buf[8];
    if (*(void *)&buf[8] == *(void *)buf) {
      goto LABEL_29;
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v20 = 0;
    ctu::base64::encode();
    uint64_t v13 = (void *)HIBYTE(v20);
    char v14 = HIBYTE(v20);
    if (v20 < 0) {
      uint64_t v13 = __p[1];
    }
    if (v13)
    {
      if (*(char *)(a1 + 103) < 0) {
        operator delete(*v5);
      }
      *(_OWORD *)CFTypeID v5 = *(_OWORD *)__p;
      *(void *)(a1 + 96) = v20;
      goto LABEL_28;
    }
    uint64_t v15 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v18 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Unable to base64 encode product id data", v18, 2u);
      if ((v20 & 0x8000000000000000) == 0) {
        goto LABEL_28;
      }
    }
    else if ((v14 & 0x80) == 0)
    {
LABEL_28:
      uint64_t v12 = *(void **)buf;
LABEL_29:
      if (v12)
      {
        *(void *)&uint8_t buf[8] = v12;
        operator delete(v12);
      }
      sub_1000558F4(&v21);
      goto LABEL_32;
    }
    operator delete(__p[0]);
    goto LABEL_28;
  }
LABEL_32:
  int v16 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 79) < 0) {
      CFBooleanRef v4 = (void *)*v4;
    }
    if (*(char *)(a1 + 103) < 0) {
      CFTypeID v5 = (void **)*v5;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v5;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I OS Version = %s, Model = %s", buf, 0x16u);
  }
  sub_100057D78(&v22);
  return a1;
}

void sub_100BD22D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, const void *a13, const void *a14, void *__p, uint64_t a16)
{
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1000558F4(&a13);
  sub_100057D78(&a14);
  if (v16[103] < 0) {
    operator delete(*v20);
  }
  if (v16[79] < 0) {
    operator delete(*v17);
  }
  if (v16[55] < 0) {
    operator delete(*v19);
  }
  if (v16[31] < 0) {
    operator delete(*v18);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v16);
  _Unwind_Resume(a1);
}

void *sub_100BD2398(void *a1, long long *a2)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "msg.tr.response");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  sub_100058DB0(a1 + 1, "TerminalRegistrationModel");
  CFBooleanRef v4 = a1 + 4;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(v4, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    a1[6] = *((void *)a2 + 2);
    *(_OWORD *)CFBooleanRef v4 = v5;
  }
  return a1;
}

void sub_100BD2450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  if (v12[31] < 0) {
    operator delete(*v13);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v12);
  _Unwind_Resume(a1);
}

BOOL sub_100BD249C(uint64_t a1)
{
  uint64_t v1 = (unsigned char **)(a1 + 32);
  uint64_t v2 = (const char *)*(unsigned __int8 *)(a1 + 55);
  if ((*(char *)(a1 + 55) & 0x80000000) == 0)
  {
    if (v2 == 2)
    {
      int v3 = *(unsigned __int8 *)v1;
      BOOL v4 = v3 == 3;
      if (v3 == 1) {
        char v5 = 1;
      }
      else {
        char v5 = *(unsigned char *)v1;
      }
      if (v3 == 1) {
        BOOL v4 = 1;
      }
      if (v3 == 2) {
        LOBYTE(v6) = 2;
      }
      else {
        LOBYTE(v6) = v5;
      }
      BOOL v7 = v3 == 2 || v4;
      uint64_t v8 = (unsigned __int8 *)(a1 + 32);
      goto LABEL_17;
    }
    uint64_t v13 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR)) {
      goto LABEL_32;
    }
    return 0;
  }
  uint64_t v9 = *(const char **)(a1 + 40);
  if (v9 != (const char *)2)
  {
    uint64_t v13 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
    {
      uint64_t v2 = v9;
LABEL_32:
      int v15 = 134217984;
      int v16 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid Terminal Registration Response size of %lu", (uint8_t *)&v15, 0xCu);
    }
    return 0;
  }
  uint64_t v6 = (uint64_t)*v1;
  BOOL v7 = **v1 - 1 < 3;
  uint64_t v8 = *v1;
LABEL_17:
  BOOL v10 = v8[1] == 4 && v7;
  int v11 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = "an invalid";
    if (v10) {
      uint64_t v12 = "a valid";
    }
    if ((v2 & 0x80) != 0) {
      LOBYTE(v6) = **v1;
    }
    int v15 = 136315394;
    int v16 = v12;
    __int16 v17 = 1024;
    int v18 = (char)v6;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Received %s Terminal Registration Response of Protocol Version %d", (uint8_t *)&v15, 0x12u);
  }
  return v10;
}

uint64_t sub_100BD2668(uint64_t a1, int a2, void *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "msg.tr");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v10, &v9);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v10);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *(void *)(a1 + 8) = *a3;
  uint64_t v6 = a3[1];
  *(void *)(a1 + 16) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0((void *)(a1 + 24), "TerminalRegistrationModel");
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 48) = a2;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  uint64_t v7 = subscriber::simSlotAsInstance();
  *(void *)(a1 + 152) = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@_%d", @"TerminalRegistration", v7);
  *(void *)(a1 + 160) = 0;
  *(_WORD *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 172) = 11;
  return a1;
}

void sub_100BD277C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, char a14)
{
  int v16 = (std::__shared_weak_count *)*((void *)v14 + 2);
  if (v16) {
    sub_10004D2C8(v16);
  }
  ctu::OsLogLogger::~OsLogLogger(v14);
  _Unwind_Resume(a1);
}

const void **sub_100BD27EC(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  *(void *)long long buf = CFPreferencesCopyValue(*(CFStringRef *)(a1 + 152), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100084068(&theDict, (CFTypeRef *)buf);
  CFDictionaryRef v2 = theDict;
  if (theDict) {
    int v3 = sub_100080778;
  }
  else {
    int v3 = 0;
  }
  BOOL v4 = *(NSObject **)a1;
  BOOL v5 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Restored TerminalRegistrationData", buf, 2u);
      CFDictionaryRef v2 = theDict;
    }
    int v18 = 0;
    *(void *)long long buf = CFDictionaryGetValue(v2, @"Identifier");
    sub_100056248(&v18, (CFTypeRef *)buf);
    __int16 v17 = 0;
    *(void *)long long buf = CFDictionaryGetValue(theDict, @"Device");
    sub_100056248(&v17, (CFTypeRef *)buf);
    if (v18) {
      uint64_t v6 = sub_1000810B8;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6 && (v17 ? (uint64_t v7 = sub_1000810B8) : (uint64_t v7 = 0), v7))
    {
      ctu::cf::assign();
      ctu::cf::assign();
    }
    else
    {
      uint64_t v8 = (void **)(a1 + 56);
      if (*(char *)(a1 + 79) < 0) {
        operator delete(*v8);
      }
      OsLogContext v9 = (void **)(a1 + 80);
      *uint64_t v8 = 0;
      *(void *)(a1 + 64) = 0;
      *(void *)(a1 + 72) = 0;
      if (*(char *)(a1 + 103) < 0) {
        operator delete(*v9);
      }
      BOOL v10 = (void **)(a1 + 104);
      *OsLogContext v9 = 0;
      *(void *)(a1 + 88) = 0;
      *(void *)(a1 + 96) = 0;
      if (*(char *)(a1 + 127) < 0) {
        operator delete(*v10);
      }
      *BOOL v10 = 0;
      *(void *)(a1 + 112) = 0;
      *(void *)(a1 + 120) = 0;
      int v11 = *(NSObject **)a1;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        if (v18) {
          uint64_t v12 = sub_1000810B8;
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v13 = "";
        if (v12) {
          char v14 = "";
        }
        else {
          char v14 = " Identifier Info";
        }
        if (v17) {
          int v15 = sub_1000810B8;
        }
        else {
          int v15 = 0;
        }
        if (!v15) {
          uint64_t v13 = " DeviceInfo";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v14;
        __int16 v21 = 2080;
        BOOL v22 = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Missing%s%s: Ignoring stored Terminal Information", buf, 0x16u);
      }
    }
    sub_1000558F4(&v17);
    sub_1000558F4(&v18);
  }
  else if (v5)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I No persisted TerminalRegistrationData", buf, 2u);
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_100BD2AC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  BOOL v5 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_100057D78((const void **)va2);
  _Unwind_Resume(a1);
}

const void **sub_100BD2B00@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  BOOL v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v6;
  BOOL v10 = sub_10004D37C(&v5[1].__m_.__sig, &v18);
  if (v10)
  {
    uint64_t v12 = v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  int v11 = 0;
  char v13 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v12 + 80))(&v16, v12, *(unsigned int *)(a1 + 48), 1, @"SMSSettings", 0, 0);
  sub_10004EFE4(&cf, &v16);
  sub_1000577C4(&v16);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  int v15 = (const void **)cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_1007CFF58(&v15, a2);
  sub_100057D78((const void **)&v15);
  return sub_100057D78(&cf);
}

void sub_100BD2C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11)
{
}

void sub_100BD2CB8(uint64_t a1)
{
  uint64_t v2 = a1 + 56;
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)v2);
  }
  int v3 = (void **)(a1 + 80);
  *(void *)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  *(void *)(v2 + 16) = 0;
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*v3);
  }
  BOOL v4 = (void **)(a1 + 104);
  *int v3 = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*v4);
  }
  NSObject *v4 = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  CFStringRef v5 = *(const __CFString **)(a1 + 152);

  CFPreferencesSetValue(v5, 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
}

void sub_100BD2D6C(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0)
  {
    if (!*(void *)(a1 + 64)) {
      goto LABEL_18;
    }
  }
  else if (!*(unsigned char *)(a1 + 79))
  {
LABEL_18:
    sub_100BD2CB8(a1);
    CFPreferencesSynchronize(@"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    unsigned int v9 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 79) < 0) {
        uint64_t v10 = *(void *)(a1 + 64);
      }
      else {
        uint64_t v10 = *(unsigned __int8 *)(a1 + 79);
      }
      if (*(char *)(a1 + 103) < 0) {
        uint64_t v12 = *(void *)(a1 + 88);
      }
      else {
        uint64_t v12 = *(unsigned __int8 *)(a1 + 103);
      }
      *(_DWORD *)long long buf = 134218240;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No identifier information to perist, Identifier length = %lu, Device length = %lu", buf, 0x16u);
    }
    return;
  }
  if (*(char *)(a1 + 103) < 0)
  {
    if (!*(void *)(a1 + 88)) {
      goto LABEL_18;
    }
  }
  else if (!*(unsigned char *)(a1 + 103))
  {
    goto LABEL_18;
  }
  uint64_t v2 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Persisting TerminalRegistrationData", buf, 2u);
  }
  int v15 = 0;
  values[0] = 0;
  int v3 = ctu::cf::convert_copy();
  if (v3)
  {
    BOOL v4 = v15;
    int v15 = values[0];
    *(void *)long long buf = v4;
    sub_1000558F4((const void **)buf);
  }
  char v14 = 0;
  values[0] = 0;
  if ((ctu::cf::convert_copy() & 1) != 0
    && (CFStringRef v5 = v14, v14 = values[0], *(void *)buf = v5, sub_1000558F4((const void **)buf), v3))
  {
    CFPropertyListRef value = 0;
    *(_OWORD *)long long buf = *(_OWORD *)off_101A44F18;
    values[0] = v15;
    values[1] = v14;
    CFDictionaryRef v6 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)buf, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v6)
    {
      CFPropertyListRef v7 = value;
      CFPropertyListRef value = v6;
      *(void *)int v16 = v7;
      sub_100057D78((const void **)v16);
      CFPreferencesSetValue(*(CFStringRef *)(a1 + 152), value, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      CFPreferencesSynchronize(@"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    }
    else
    {
      int v11 = *(NSObject **)a1;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v16 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Unable to create Terminal Registration Information", v16, 2u);
      }
    }
    sub_100057D78(&value);
  }
  else
  {
    uint64_t v8 = *(NSObject **)a1;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid Terminal Registration Info", buf, 2u);
    }
  }
  sub_1000558F4((const void **)&v14);
  sub_1000558F4((const void **)&v15);
}

void sub_100BD30B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFStringRef v5 = va_arg(va2, const void *);
  sub_100057D78((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  _Unwind_Resume(a1);
}

void sub_100BD30E4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v11) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Dumping Terminal Registration Data", (uint8_t *)&v11, 2u);
    uint64_t v2 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = (const char *)(a1 + 128);
    if (*(char *)(a1 + 151) < 0) {
      int v3 = *(const char **)v3;
    }
    int v11 = 136315138;
    uint64_t v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Destination Address: %s", (uint8_t *)&v11, 0xCu);
    uint64_t v2 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)(a1 + 160);
    int v11 = 67109120;
    LODWORD(v12) = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Total SMS tries: %u", (uint8_t *)&v11, 8u);
    uint64_t v2 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 164)) {
      CFStringRef v5 = "true";
    }
    else {
      CFStringRef v5 = "false";
    }
    int v11 = 136315138;
    uint64_t v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Ims ready: %s", (uint8_t *)&v11, 0xCu);
    uint64_t v2 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 165)) {
      CFDictionaryRef v6 = "true";
    }
    else {
      CFDictionaryRef v6 = "false";
    }
    int v11 = 136315138;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I SMS online: %s", (uint8_t *)&v11, 0xCu);
    uint64_t v2 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 166)) {
      CFPropertyListRef v7 = "true";
    }
    else {
      CFPropertyListRef v7 = "false";
    }
    int v11 = 136315138;
    uint64_t v12 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I SMSC available: %s", (uint8_t *)&v11, 0xCu);
    uint64_t v2 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 167)) {
      uint64_t v8 = "true";
    }
    else {
      uint64_t v8 = "false";
    }
    int v11 = 136315138;
    uint64_t v12 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Attached: %s", (uint8_t *)&v11, 0xCu);
    uint64_t v2 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 168)) {
      unsigned int v9 = "true";
    }
    else {
      unsigned int v9 = "false";
    }
    int v11 = 136315138;
    uint64_t v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Roaming: %s", (uint8_t *)&v11, 0xCu);
    uint64_t v2 = *(NSObject **)a1;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_DWORD *)(a1 + 172)) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    int v11 = 136315138;
    uint64_t v12 = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Camped RAT: %s", (uint8_t *)&v11, 0xCu);
  }
}

uint64_t sub_100BD3418(uint64_t a1, const void **a2)
{
  int v4 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = (void *)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      CFStringRef v5 = (void *)*v5;
    }
    CFDictionaryRef v6 = (void *)(a1 + 80);
    if (*(char *)(a1 + 103) < 0) {
      CFDictionaryRef v6 = (void *)*v6;
    }
    if (*((char *)a2 + 23) >= 0) {
      CFPropertyListRef v7 = a2;
    }
    else {
      CFPropertyListRef v7 = *a2;
    }
    if (*((char *)a2 + 47) >= 0) {
      uint64_t v8 = a2 + 3;
    }
    else {
      uint64_t v8 = (const void **)a2[3];
    }
    int v32 = 136315906;
    uint64_t v33 = v5;
    __int16 v34 = 2080;
    uint64_t v35 = v6;
    __int16 v36 = 2080;
    uint64_t v37 = v7;
    __int16 v38 = 2080;
    unint64_t v39 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Comparing Identifier (%s,%s) to (%s,%s)", (uint8_t *)&v32, 0x2Au);
  }
  uint64_t v9 = *((unsigned __int8 *)a2 + 23);
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = (const void *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v10 = a2[1];
  }
  int v11 = (const void *)*(unsigned __int8 *)(a1 + 79);
  int v12 = (char)v11;
  if ((char)v11 < 0) {
    int v11 = *(const void **)(a1 + 64);
  }
  if (v10 != v11) {
    return 0;
  }
  if (v12 >= 0) {
    char v13 = (unsigned __int8 *)(a1 + 56);
  }
  else {
    char v13 = *(unsigned __int8 **)(a1 + 56);
  }
  if ((v9 & 0x80) != 0)
  {
    if (memcmp(*a2, v13, (size_t)a2[1])) {
      return 0;
    }
  }
  else if (*((unsigned char *)a2 + 23))
  {
    char v14 = a2;
    while (*(unsigned __int8 *)v14 == *v13)
    {
      char v14 = (const void **)((char *)v14 + 1);
      ++v13;
      if (!--v9) {
        goto LABEL_29;
      }
    }
    return 0;
  }
LABEL_29:
  uint64_t v15 = *((unsigned __int8 *)a2 + 47);
  if ((v15 & 0x80u) == 0) {
    int v16 = (const void *)*((unsigned __int8 *)a2 + 47);
  }
  else {
    int v16 = a2[4];
  }
  __int16 v17 = (const void *)*(unsigned __int8 *)(a1 + 103);
  int v18 = (char)v17;
  if ((char)v17 < 0) {
    __int16 v17 = *(const void **)(a1 + 88);
  }
  if (v16 != v17) {
    return 0;
  }
  CFBooleanRef v19 = a2 + 3;
  BOOL v22 = *(unsigned __int8 **)(a1 + 80);
  __int16 v21 = (unsigned __int8 *)(a1 + 80);
  uint64_t v20 = v22;
  if (v18 >= 0) {
    unint64_t v23 = v21;
  }
  else {
    unint64_t v23 = v20;
  }
  if ((v15 & 0x80) != 0) {
    return memcmp(*v19, v23, (size_t)a2[4]) == 0;
  }
  if (!*((unsigned char *)a2 + 47)) {
    return 1;
  }
  uint64_t v24 = v15 - 1;
  do
  {
    int v26 = *(unsigned __int8 *)v19;
    CFBooleanRef v19 = (const void **)((char *)v19 + 1);
    int v25 = v26;
    int v28 = *v23++;
    int v27 = v28;
    BOOL v30 = v24-- != 0;
    uint64_t result = v25 == v27;
  }
  while (v25 == v27 && v30);
  return result;
}

uint64_t sub_100BD362C(uint64_t a1, std::string *a2)
{
  uint64_t result = sub_100BD3418(a1, (const void **)&a2->__r_.__value_.__l.__data_);
  if ((result & 1) == 0)
  {
    CFStringRef v5 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFDictionaryRef v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Got a new Terminal Identifier", v6, 2u);
    }
    std::string::operator=((std::string *)(a1 + 56), a2);
    std::string::operator=((std::string *)(a1 + 80), a2 + 1);
    return (uint64_t)std::string::operator=((std::string *)(a1 + 104), a2 + 2);
  }
  return result;
}

uint64_t sub_100BD36C8(uint64_t a1)
{
  cf[1] = 0;
  int v11 = 0;
  cf[0] = 0;
  sub_100BD2B00(a1, cf);
  CFDictionaryRef v2 = (const __CFDictionary *)cf[0];
  if (cf[0]) {
    int v3 = sub_100080778;
  }
  else {
    int v3 = 0;
  }
  if (!v3)
  {
    CFStringRef v5 = *(NSObject **)a1;
    if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    *(_WORD *)long long buf = 0;
    CFDictionaryRef v6 = "Invalid Carrier settings";
    goto LABEL_14;
  }
  CFDictionaryRef theDict = (CFDictionaryRef)cf[0];
  if (cf[0])
  {
    CFRetain(cf[0]);
    CFDictionaryRef v2 = theDict;
  }
  *(void *)long long buf = 0;
  std::string __p = (void *)CFDictionaryGetValue(v2, @"DestinationAddress");
  sub_100056248(buf, (CFTypeRef *)&__p);
  if (*(void *)buf) {
    int v4 = sub_1000810B8;
  }
  else {
    int v4 = 0;
  }
  if (v4)
  {
    ctu::cf::assign();
  }
  else
  {
    CFPropertyListRef v7 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Terminal Registration Settings without Destination Address, invalid", (uint8_t *)&__p, 2u);
    }
  }
  sub_1000558F4((const void **)buf);
  sub_100057D78((const void **)&theDict);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 169))
    {
      if (CFDictionaryGetValue((CFDictionaryRef)cf[0], @"RegistrationOverIMS")) {
        operator new();
      }
      CFStringRef v5 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        CFDictionaryRef v6 = "Terminal Registration IMS settings not found.";
LABEL_14:
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, buf, 2u);
      }
    }
    else
    {
      if (CFDictionaryGetValue((CFDictionaryRef)cf[0], @"Registration")) {
        operator new();
      }
      CFStringRef v5 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        CFDictionaryRef v6 = "Terminal Registration settings not found.";
        goto LABEL_14;
      }
    }
  }
LABEL_26:
  sub_100057D78(cf);
  if (v11) {
    sub_10004D2C8(v11);
  }
  return 0;
}

void sub_100BD4350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,const void *a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  sub_1001F78F8((uint64_t)&a9);
  sub_100057D78(&a27);
  if (a29) {
    sub_10004D2C8((std::__shared_weak_count *)a29);
  }
  _Unwind_Resume(a1);
}

void sub_100BD44C4()
{
}

void sub_100BD454C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_100BD47B8(v1);
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100BD4578(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (!*a2) {
    return 0;
  }
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  (*(void (**)(void **__return_ptr))(*(void *)v2 + 192))(__p);
  sub_100BD2398(v7, (long long *)__p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  BOOL v3 = sub_100BD249C((uint64_t)v7);
  sub_100BD469C((void **)v7);
  return v3;
}

void sub_100BD4618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100BD4634(uint64_t a1)
{
  CFStringRef v5 = 0;
  sub_100BD2B00(a1, &v5);
  if (v5) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  BOOL v2 = v1 != 0;
  if (v5) {
    BOOL v3 = v2;
  }
  else {
    BOOL v3 = 0;
  }
  sub_100057D78(&v5);
  return v3;
}

void sub_100BD469C(void **this)
{
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)this);
}

void sub_100BD46F4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void **sub_100BD472C(uint64_t a1)
{
  uint64_t result = *(void ***)(a1 + 24);
  if (result)
  {
    sub_100BD47B8(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100BD4774(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100BD47B8(void **this)
{
  if (*((char *)this + 103) < 0) {
    operator delete(this[10]);
  }
  if (*((char *)this + 79) < 0) {
    operator delete(this[7]);
  }
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)this);
}

void sub_100BD482C(std::__shared_weak_count **a1@<X8>)
{
  BOOL v2 = (std::__shared_weak_count *)operator new(0x38uLL);
  v2->__shared_owners_ = 0;
  v2->__shared_weak_owners_ = 0;
  v2->__vftable = (std::__shared_weak_count_vtbl *)off_101A450B8;
  BOOL v3 = v2 + 1;
  sub_100BD4918(&v2[1].__vftable);
  v2[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A45108;
  int v4 = (std::__shared_weak_count *)v2[2].__vftable;
  if (!v4)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v2[1].__shared_weak_owners_ = (uint64_t)v3;
    v2[2].__vftable = (std::__shared_weak_count_vtbl *)v2;
    goto LABEL_5;
  }
  if (v4->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v2[1].__shared_weak_owners_ = (uint64_t)v3;
    v2[2].__vftable = (std::__shared_weak_count_vtbl *)v2;
    std::__shared_weak_count::__release_weak(v4);
LABEL_5:
    sub_10004D2C8(v2);
  }
  *a1 = v3;
  a1[1] = v2;
}

void sub_100BD4900(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void *sub_100BD4918(void *a1)
{
  *a1 = off_1019E4E90;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "call");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, &v3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 1), (const ctu::OsLogLogger *)v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_101A44FB0;
  return a1;
}

void sub_100BD49C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void sub_100BD49E8(uint64_t a1, int a2, uint64_t a3, int a4)
{
  xpc_object_t v57 = 0;
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v9 = v8;
  if (v8)
  {
    xpc_object_t v57 = v8;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v57 = v9;
    if (!v9)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v9 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v9);
    goto LABEL_9;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_8:
  xpc_object_t v57 = v10;
LABEL_9:
  xpc_release(v9);
  xpc_object_t v56 = 0;
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v12 = v11;
  if (v11)
  {
    xpc_object_t v56 = v11;
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v56 = v12;
    if (!v12)
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v12 = 0;
      goto LABEL_16;
    }
  }
  if (xpc_get_type(v12) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v13 = xpc_null_create();
LABEL_16:
    xpc_object_t v56 = v13;
    goto LABEL_17;
  }
  xpc_retain(v12);
LABEL_17:
  xpc_release(v12);
  switch(a2)
  {
    case 1:
    case 2:
      if (CallInfo::operator BOOL())
      {
        sub_10057DEAC(a3, (char *)&v52);
        *(void *)&long long buf = &v56;
        *((void *)&buf + 1) = "kCTCallProcessing";
        sub_10014E03C((uint64_t)&buf, &v52, &v53);
        xpc_release(v53);
        xpc_object_t v53 = 0;
        xpc_release(v52);
        xpc_object_t v52 = 0;
        uint64_t v14 = *(unsigned __int8 *)(a3 + 151);
        if ((v14 & 0x80u) != 0) {
          uint64_t v14 = *(void *)(a3 + 136);
        }
        if (v14)
        {
          long long buf = 0uLL;
          uint64_t v62 = 0;
          ctu::cf::assign();
          if (*(char *)(a3 + 151) >= 0) {
            uint64_t v15 = (const char *)(a3 + 128);
          }
          else {
            uint64_t v15 = *(const char **)(a3 + 128);
          }
          xpc_object_t v50 = xpc_string_create(v15);
          if (!v50) {
            xpc_object_t v50 = xpc_null_create();
          }
          p_long long buf = &buf;
          if (v62 < 0) {
            p_long long buf = (long long *)buf;
          }
          std::string __p = &v57;
          __int16 v36 = p_buf;
          sub_100035E70((uint64_t)&__p, &v50, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          xpc_release(v50);
          xpc_object_t v50 = 0;
          goto LABEL_60;
        }
      }
      else
      {
        unint64_t v23 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          goto LABEL_63;
        }
      }
      goto LABEL_69;
    case 3:
    case 4:
      if (CallInfo::operator BOOL())
      {
        sub_10057DEAC(a3, (char *)&v54);
        *(void *)&long long buf = &v56;
        *((void *)&buf + 1) = "kCTCallProcessing";
        sub_10014E03C((uint64_t)&buf, &v54, &v55);
        xpc_release(v55);
        xpc_object_t v55 = 0;
        xpc_release(v54);
        xpc_object_t v54 = 0;
      }
      else
      {
        unint64_t v23 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
LABEL_63:
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = sub_100027EA4(a2);
          goto LABEL_68;
        }
      }
      goto LABEL_69;
    case 6:
      if (CallInfo::operator BOOL())
      {
        sub_10057DEAC(a3, (char *)&v44);
        *(void *)&long long buf = &v56;
        *((void *)&buf + 1) = "kCTCallProcessing";
        sub_10014E03C((uint64_t)&buf, &v44, &v45);
        xpc_release(v45);
        xpc_object_t v45 = 0;
        xpc_release(v44);
        xpc_object_t v44 = 0;
      }
      long long buf = 0uLL;
      uint64_t v62 = 0;
      ctu::cf::assign();
      xpc_object_t v42 = xpc_int64_create(a4);
      if (!v42) {
        xpc_object_t v42 = xpc_null_create();
      }
      int v18 = &buf;
      if (v62 < 0) {
        int v18 = (long long *)buf;
      }
      std::string __p = &v57;
      __int16 v36 = v18;
      sub_100035E70((uint64_t)&__p, &v42, &v43);
      xpc_release(v43);
      xpc_object_t v43 = 0;
      xpc_release(v42);
      xpc_object_t v42 = 0;
      goto LABEL_60;
    case 7:
      if (CallInfo::operator BOOL())
      {
        sub_10057DEAC(a3, (char *)&v48);
        *(void *)&long long buf = &v56;
        *((void *)&buf + 1) = "kCTCallProcessing";
        sub_10014E03C((uint64_t)&buf, &v48, &v49);
        xpc_release(v49);
        xpc_object_t v49 = 0;
        xpc_release(v48);
        xpc_object_t v48 = 0;
        long long buf = 0uLL;
        uint64_t v62 = 0;
        ctu::cf::assign();
        xpc_object_t v46 = xpc_int64_create(*(unsigned __int16 *)(a3 + 116));
        if (!v46) {
          xpc_object_t v46 = xpc_null_create();
        }
        CFBooleanRef v19 = &buf;
        if (v62 < 0) {
          CFBooleanRef v19 = (long long *)buf;
        }
        std::string __p = &v57;
        __int16 v36 = v19;
        sub_100035E70((uint64_t)&__p, &v46, &v47);
        xpc_release(v47);
        xpc_object_t v47 = 0;
        xpc_release(v46);
        xpc_object_t v46 = 0;
LABEL_60:
        if (SHIBYTE(v62) < 0) {
          operator delete((void *)buf);
        }
      }
      else
      {
        unint64_t v23 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = sub_100027EA4(7);
LABEL_68:
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Cannot send %s! Call is invalid.", (uint8_t *)&buf, 0xCu);
        }
      }
LABEL_69:
      if (!xpc_dictionary_get_value(v56, "kCTCallProcessing"))
      {
        xpc_object_t v25 = v57;
        *(void *)&long long buf = v57;
        if (v57)
        {
          xpc_retain(v57);
        }
        else
        {
          xpc_object_t v25 = xpc_null_create();
          *(void *)&long long buf = v25;
        }
        xpc_object_t v29 = v56;
        std::string __p = v56;
        if (v56)
        {
          xpc_retain(v56);
        }
        else
        {
          xpc_object_t v29 = xpc_null_create();
          std::string __p = v29;
        }
        sub_1000452AC(a2, (xpc_object_t *)&buf, &__p);
        xpc_release(v29);
        xpc_release(v25);
        goto LABEL_102;
      }
      xpc_object_t v33 = 0;
      xpc_object_t v24 = v56;
      if (v56) {
        xpc_retain(v56);
      }
      else {
        xpc_object_t v24 = xpc_null_create();
      }
      xpc_object_t v33 = 0;
      xpc_object_t v26 = xpc_copy(v24);
      xpc_object_t v27 = v26;
      if (v26)
      {
        xpc_object_t v33 = v26;
      }
      else
      {
        xpc_object_t v27 = xpc_null_create();
        xpc_object_t v33 = v27;
        if (!v27)
        {
          xpc_object_t v28 = xpc_null_create();
          xpc_object_t v27 = 0;
          goto LABEL_87;
        }
      }
      if (xpc_get_type(v27) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v27);
        goto LABEL_88;
      }
      xpc_object_t v28 = xpc_null_create();
LABEL_87:
      xpc_object_t v33 = v28;
LABEL_88:
      xpc_release(v27);
      std::string __p = 0;
      *(void *)&long long buf = &v33;
      *((void *)&buf + 1) = "kCTCallProcessing";
      sub_10000CB28((uint64_t)&buf, &__p);
      xpc_object_t v60 = xpc_string_create("");
      if (!v60) {
        xpc_object_t v60 = xpc_null_create();
      }
      *(void *)&long long buf = &__p;
      *((void *)&buf + 1) = "kCallName";
      sub_100035E70((uint64_t)&buf, &v60, v34);
      xpc_release(v34[0]);
      v34[0] = 0;
      xpc_release(v60);
      xpc_object_t v60 = 0;
      xpc_object_t v58 = xpc_string_create("");
      if (!v58) {
        xpc_object_t v58 = xpc_null_create();
      }
      *(void *)&long long buf = &__p;
      *((void *)&buf + 1) = "kPhoneNumber";
      sub_100035E70((uint64_t)&buf, &v58, &v59);
      xpc_release(v59);
      xpc_object_t v59 = 0;
      xpc_release(v58);
      xpc_object_t v58 = 0;
      xpc_release(__p);
      xpc_release(v24);
      xpc_object_t v32 = v57;
      if (v57) {
        xpc_retain(v57);
      }
      else {
        xpc_object_t v32 = xpc_null_create();
      }
      xpc_object_t v31 = v56;
      if (v56) {
        xpc_retain(v56);
      }
      else {
        xpc_object_t v31 = xpc_null_create();
      }
      xpc_object_t v30 = v33;
      if (v33) {
        xpc_retain(v33);
      }
      else {
        xpc_object_t v30 = xpc_null_create();
      }
      sub_100DD67A4(a2, &v32, &v31, &v30);
      xpc_release(v30);
      xpc_object_t v30 = 0;
      xpc_release(v31);
      xpc_object_t v31 = 0;
      xpc_release(v32);
      xpc_object_t v32 = 0;
      xpc_release(v33);
LABEL_102:
      xpc_release(v56);
      xpc_release(v57);
      return;
    case 14:
      long long buf = 0uLL;
      uint64_t v62 = 0;
      ctu::cf::assign();
      xpc_object_t v40 = xpc_int64_create(a4);
      if (!v40) {
        xpc_object_t v40 = xpc_null_create();
      }
      uint64_t v20 = &buf;
      if (v62 < 0) {
        uint64_t v20 = (long long *)buf;
      }
      std::string __p = &v57;
      __int16 v36 = v20;
      sub_100035E70((uint64_t)&__p, &v40, &v41);
      xpc_release(v41);
      xpc_object_t v41 = 0;
      xpc_release(v40);
      xpc_object_t v40 = 0;
      ctu::cf::assign();
      asExternalCSIErrorString();
      if (v37 >= 0) {
        p_p = (const char *)&__p;
      }
      else {
        p_p = (const char *)__p;
      }
      xpc_object_t v38 = xpc_string_create(p_p);
      if (!v38) {
        xpc_object_t v38 = xpc_null_create();
      }
      BOOL v22 = &buf;
      if (v62 < 0) {
        BOOL v22 = (long long *)buf;
      }
      v34[0] = &v57;
      v34[1] = v22;
      sub_100035E70((uint64_t)v34, &v38, &v39);
      xpc_release(v39);
      xpc_object_t v39 = 0;
      xpc_release(v38);
      xpc_object_t v38 = 0;
      if (v37 < 0) {
        operator delete(__p);
      }
      goto LABEL_60;
    default:
      __int16 v17 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = sub_100027EA4(a2);
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s does not need any extra info. Sending.", (uint8_t *)&buf, 0xCu);
      }
      goto LABEL_69;
  }
}

void sub_100BD5318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10, xpc_object_t a11, xpc_object_t a12)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

const void **sub_100BD554C(uint64_t a1, uint64_t a2)
{
  memset(v5, 0, sizeof(v5));
  sub_100058DB0(v6, kCallerIdDefaultValue);
  int v7 = 9;
  char v8 = 0;
  int v9 = 1;
  char v10 = 1;
  uint64_t v11 = 0x400000001;
  uint64_t v12 = 2;
  char v13 = 0;
  int v14 = CallInfo::kDefaultCallId;
  char v17 = 0;
  char v18 = 0;
  uint64_t v15 = 0;
  v16[0] = 0;
  *(void *)((char *)v16 + 6) = 0;
  sub_100058DB0(v19, "");
  int v20 = 0;
  sub_100058DB0(v21, "");
  int v22 = 0;
  __int16 v23 = 0;
  int v24 = 0;
  __int16 v25 = 0;
  int v26 = 0;
  char v27 = 0;
  char v28 = 0;
  char v29 = 0;
  char v30 = 0;
  __int16 v31 = 0;
  int v32 = 1;
  char v33 = 0;
  int v34 = 0;
  char v35 = 0;
  char v41 = 0;
  char v42 = 0;
  char v43 = 0;
  char v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  (*(void (**)(uint64_t, uint64_t, _OWORD *, void))(*(void *)a1 + 16))(a1, a2, v5, 0);
  return sub_1002243E8((uint64_t)v5);
}

void sub_100BD56AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
}

void sub_100BD5710(uint64_t a1, uint64_t a2, int a3)
{
  xpc_object_t v25 = 0;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v25 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v25 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_9;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_8:
  xpc_object_t v25 = v7;
LABEL_9:
  xpc_release(v6);
  xpc_object_t v24 = 0;
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v9 = v8;
  if (v8)
  {
    xpc_object_t v24 = v8;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v24 = v9;
    if (!v9)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v9 = 0;
      goto LABEL_16;
    }
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v9);
    goto LABEL_17;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_16:
  xpc_object_t v24 = v10;
LABEL_17:
  xpc_release(v9);
  if (CallInfo::operator BOOL())
  {
    sub_10057DEAC(a2, (char *)&object);
    std::string __p = &v24;
    int v20 = "kCTCallProcessing";
    sub_10014E03C((uint64_t)&__p, &object, &v23);
    xpc_release(v23);
    xpc_object_t v23 = 0;
    xpc_release(object);
    xpc_object_t object = 0;
  }
  else
  {
    std::string __p = 0;
    int v20 = 0;
    uint64_t v21 = 0;
    ctu::cf::assign();
    uint64_t v11 = 3;
    if (a3 != 32) {
      uint64_t v11 = 1;
    }
    if (a3 == 31) {
      int64_t v12 = 2;
    }
    else {
      int64_t v12 = v11;
    }
    xpc_object_t v17 = xpc_int64_create(v12);
    if (!v17) {
      xpc_object_t v17 = xpc_null_create();
    }
    p_p = &__p;
    if (v21 < 0) {
      p_p = __p;
    }
    v16[0] = &v25;
    v16[1] = p_p;
    sub_100035E70((uint64_t)v16, &v17, &v18);
    xpc_release(v18);
    xpc_object_t v18 = 0;
    xpc_release(v17);
    xpc_object_t v17 = 0;
    if (SHIBYTE(v21) < 0) {
      operator delete(__p);
    }
  }
  xpc_object_t v14 = v25;
  std::string __p = v25;
  if (v25)
  {
    xpc_retain(v25);
  }
  else
  {
    xpc_object_t v14 = xpc_null_create();
    std::string __p = v14;
  }
  xpc_object_t v15 = v24;
  v16[0] = v24;
  if (v24)
  {
    xpc_retain(v24);
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
    v16[0] = v15;
  }
  sub_1000452AC(6, &__p, v16);
  xpc_release(v15);
  xpc_release(v14);
  xpc_release(v24);
  xpc_release(v25);
}

void sub_100BD59A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v19 - 48));
  xpc_release(*(xpc_object_t *)(v19 - 40));
  _Unwind_Resume(a1);
}

void sub_100BD5A38(uint64_t a1, BOOL a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v15 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v15 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v15 = v5;
LABEL_9:
  xpc_release(v4);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v14 = 0;
  ctu::cf::assign();
  xpc_object_t v11 = xpc_BOOL_create(a2);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  xpc_object_t v6 = __p;
  if (v14 < 0) {
    xpc_object_t v6 = (void **)__p[0];
  }
  v10[0] = &v15;
  v10[1] = v6;
  sub_100035E70((uint64_t)v10, &v11, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v7 = v15;
  v10[0] = v15;
  if (v15)
  {
    xpc_retain(v15);
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    v10[0] = v7;
  }
  xpc_object_t v8 = xpc_null_create();
  xpc_object_t v9 = v8;
  sub_1000452AC(92, v10, &v9);
  xpc_release(v8);
  xpc_release(v7);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v15);
}

void sub_100BD5BC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  xpc_object_t v23 = v21;
  xpc_release(v23);
  xpc_release(v20);
  if (a20 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v22 - 24));
  _Unwind_Resume(a1);
}

void sub_100BD5C30(uint64_t a1, BOOL a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v15 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v15 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v15 = v5;
LABEL_9:
  xpc_release(v4);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v14 = 0;
  ctu::cf::assign();
  xpc_object_t v11 = xpc_BOOL_create(a2);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  xpc_object_t v6 = __p;
  if (v14 < 0) {
    xpc_object_t v6 = (void **)__p[0];
  }
  v10[0] = &v15;
  v10[1] = v6;
  sub_100035E70((uint64_t)v10, &v11, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v7 = v15;
  v10[0] = v15;
  if (v15)
  {
    xpc_retain(v15);
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    v10[0] = v7;
  }
  xpc_object_t v8 = xpc_null_create();
  xpc_object_t v9 = v8;
  sub_1000452AC(108, v10, &v9);
  xpc_release(v8);
  xpc_release(v7);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v15);
}

void sub_100BD5DBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  xpc_object_t v23 = v21;
  xpc_release(v23);
  xpc_release(v20);
  if (a20 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v22 - 24));
  _Unwind_Resume(a1);
}

void sub_100BD5E28(uint64_t a1, void *a2)
{
  xpc_object_t v29 = 0;
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v29 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v29 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v29 = v5;
LABEL_9:
  xpc_release(v4);
  xpc_object_t v8 = (void *)*a2;
  xpc_object_t v6 = a2 + 1;
  xpc_object_t v7 = v8;
  if (v8 != v6)
  {
    do
    {
      uint64_t v33 = 0;
      memset(v32, 0, sizeof(v32));
      *(void *)&v32[0] = v7[4];
      sub_100BD77B8((int *)v32 + 2, (uint64_t)(v7 + 5));
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v28 = 0;
      ctu::cf::assign();
      *(_OWORD *)CFPropertyListRef value = 0u;
      long long v31 = 0u;
      sub_100BD77B8((int *)value, (uint64_t)v32 + 8);
      int v9 = LODWORD(value[0]) ^ (SLODWORD(value[0]) >> 31);
      if (v9)
      {
        if (v9 == 1)
        {
          xpc_object_t v21 = xpc_int64_create(SLODWORD(value[1]));
          if (!v21) {
            xpc_object_t v21 = xpc_null_create();
          }
          if (v28 >= 0) {
            int64_t v12 = __p;
          }
          else {
            int64_t v12 = (void **)__p[0];
          }
          xpc_object_t v23 = &v29;
          xpc_object_t v24 = v12;
          sub_100035E70((uint64_t)&v23, &v21, &v22);
          xpc_release(v22);
          xpc_object_t v22 = 0;
          xpc_release(v21);
          xpc_object_t v21 = 0;
        }
        else
        {
          if (v9 != 2) {
            sub_1000971B8();
          }
          if (v31 >= 0) {
            xpc_object_t v10 = (const char *)&value[1];
          }
          else {
            xpc_object_t v10 = (const char *)value[1];
          }
          xpc_object_t v19 = xpc_string_create(v10);
          if (!v19) {
            xpc_object_t v19 = xpc_null_create();
          }
          if (v28 >= 0) {
            xpc_object_t v11 = __p;
          }
          else {
            xpc_object_t v11 = (void **)__p[0];
          }
          xpc_object_t v23 = &v29;
          xpc_object_t v24 = v11;
          sub_100035E70((uint64_t)&v23, &v19, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          xpc_release(v19);
          xpc_object_t v19 = 0;
        }
      }
      else
      {
        xpc_object_t v25 = xpc_BOOL_create(value[1]);
        if (!v25) {
          xpc_object_t v25 = xpc_null_create();
        }
        if (v28 >= 0) {
          char v13 = __p;
        }
        else {
          char v13 = (void **)__p[0];
        }
        xpc_object_t v23 = &v29;
        xpc_object_t v24 = v13;
        sub_100035E70((uint64_t)&v23, &v25, &v26);
        xpc_release(v26);
        xpc_object_t v26 = 0;
        xpc_release(v25);
        xpc_object_t v25 = 0;
      }
      sub_100BD78B4((uint64_t)value);
      if (SHIBYTE(v28) < 0) {
        operator delete(__p[0]);
      }
      sub_100BD78B4((uint64_t)v32 + 8);
      uint64_t v14 = (void *)v7[1];
      if (v14)
      {
        do
        {
          xpc_object_t v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          xpc_object_t v15 = (void *)v7[2];
          BOOL v16 = *v15 == (void)v7;
          xpc_object_t v7 = v15;
        }
        while (!v16);
      }
      xpc_object_t v7 = v15;
    }
    while (v15 != v6);
  }
  xpc_object_t v17 = v29;
  *(void *)&v32[0] = v29;
  if (v29)
  {
    xpc_retain(v29);
  }
  else
  {
    xpc_object_t v17 = xpc_null_create();
    *(void *)&v32[0] = v17;
  }
  xpc_object_t v18 = xpc_null_create();
  value[0] = (int64_t)v18;
  sub_1000452AC(111, (xpc_object_t *)v32, (xpc_object_t *)value);
  xpc_release(v18);
  xpc_release(v17);
  xpc_release(v29);
}

void sub_100BD6158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100BD6220(uint64_t a1)
{
  pthread_mutex_lock(&stru_101B0AC18);
  int v2 = dword_101B13E54;
  pthread_mutex_unlock(&stru_101B0AC18);
  if (v2)
  {
    pthread_mutex_lock(&stru_101B0AC18);
    dword_101B13E54 &= ~v2;
    pthread_mutex_unlock(&stru_101B0AC18);
    (*(void (**)(uint64_t))(*(void *)a1 + 64))(a1);
  }

  sub_10007FB40();
}

void sub_100BD62C4(uint64_t a1, int a2)
{
}

void sub_100BD62CC(uint64_t a1, BOOL a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v15 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v15 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v15 = v5;
LABEL_9:
  xpc_release(v4);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v14 = 0;
  ctu::cf::assign();
  xpc_object_t v11 = xpc_BOOL_create(a2);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  xpc_object_t v6 = __p;
  if (v14 < 0) {
    xpc_object_t v6 = (void **)__p[0];
  }
  v10[0] = &v15;
  v10[1] = v6;
  sub_100035E70((uint64_t)v10, &v11, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v7 = v15;
  v10[0] = v15;
  if (v15)
  {
    xpc_retain(v15);
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    v10[0] = v7;
  }
  xpc_object_t v8 = xpc_null_create();
  xpc_object_t v9 = v8;
  sub_1000452AC(144, v10, &v9);
  xpc_release(v8);
  xpc_release(v7);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v15);
}

void sub_100BD6458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  xpc_object_t v23 = v21;
  xpc_release(v23);
  xpc_release(v20);
  if (a20 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v22 - 24));
  _Unwind_Resume(a1);
}

void sub_100BD64C4(uint64_t a1, BOOL a2, BOOL a3, uint64_t a4, int a5)
{
}

void sub_100BD64D8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t *a6)
{
  xpc_object_t v36 = 0;
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v12 = v11;
  if (v11)
  {
    xpc_object_t v36 = v11;
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
    xpc_object_t v36 = v12;
    if (!v12)
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v12 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v12);
    goto LABEL_9;
  }
  xpc_object_t v13 = xpc_null_create();
LABEL_8:
  xpc_object_t v36 = v13;
LABEL_9:
  xpc_release(v12);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v14 = (const char *)a2;
  }
  else {
    uint64_t v14 = *(const char **)a2;
  }
  xpc_object_t v34 = xpc_string_create(v14);
  if (!v34) {
    xpc_object_t v34 = xpc_null_create();
  }
  long long v37 = 0uLL;
  uint64_t v38 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0u;
  uint64_t v33 = 0;
  v24[0] = &v36;
  v24[1] = __p;
  sub_100035E70((uint64_t)v24, &v34, &v35);
  xpc_release(v35);
  xpc_object_t v35 = 0;
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v34);
  xpc_object_t v34 = 0;
  if (*(char *)(a3 + 23) >= 0) {
    xpc_object_t v15 = (const char *)a3;
  }
  else {
    xpc_object_t v15 = *(const char **)a3;
  }
  xpc_object_t v30 = xpc_string_create(v15);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  long long v37 = 0uLL;
  uint64_t v38 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v37;
  uint64_t v33 = v38;
  BOOL v16 = (void **)v37;
  if (v38 >= 0) {
    BOOL v16 = __p;
  }
  v24[0] = &v36;
  v24[1] = v16;
  sub_100035E70((uint64_t)v24, &v30, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v30);
  xpc_object_t v30 = 0;
  sub_10015DBCC(a4);
  long long v37 = 0uLL;
  uint64_t v38 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v37;
  uint64_t v33 = v38;
  if (v38 >= 0) {
    xpc_object_t v17 = __p;
  }
  else {
    xpc_object_t v17 = (void **)__p[0];
  }
  xpc_object_t v28 = xpc_string_create((const char *)v17);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  long long v37 = 0uLL;
  uint64_t v38 = 0;
  ctu::cf::assign();
  *(_OWORD *)xpc_object_t v24 = v37;
  uint64_t v25 = v38;
  xpc_object_t v18 = (void **)v37;
  if (v38 >= 0) {
    xpc_object_t v18 = v24;
  }
  xpc_object_t v26 = &v36;
  char v27 = v18;
  sub_100035E70((uint64_t)&v26, &v28, &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
  xpc_release(v28);
  xpc_object_t v28 = 0;
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[0]);
  }
  sub_10015DC24(a5);
  long long v37 = 0uLL;
  uint64_t v38 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v37;
  uint64_t v33 = v38;
  if (v38 >= 0) {
    xpc_object_t v19 = __p;
  }
  else {
    xpc_object_t v19 = (void **)__p[0];
  }
  xpc_object_t v22 = xpc_string_create((const char *)v19);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  long long v37 = 0uLL;
  uint64_t v38 = 0;
  ctu::cf::assign();
  *(_OWORD *)xpc_object_t v24 = v37;
  uint64_t v25 = v38;
  int v20 = v24;
  if (v38 < 0) {
    int v20 = (void **)v24[0];
  }
  xpc_object_t v26 = &v36;
  char v27 = v20;
  sub_100035E70((uint64_t)&v26, &v22, &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
  xpc_release(v22);
  xpc_object_t v22 = 0;
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v21 = *a6;
  *(void *)&long long v37 = v36;
  if (v36) {
    xpc_retain(v36);
  }
  else {
    *(void *)&long long v37 = xpc_null_create();
  }
  (*(void (**)(uint64_t, uint64_t, long long *))(v21 + 16))(v21, 105, &v37);
  xpc_release((xpc_object_t)v37);
  xpc_release(v36);
}

void sub_100BD6914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t object, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  xpc_release(*(xpc_object_t *)(v26 - 72));
  xpc_release(*(xpc_object_t *)(v26 - 80));
  _Unwind_Resume(a1);
}

void sub_100BD69DC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  if (*(char *)(v19 - 49) < 0) {
    operator delete(*(void **)(v19 - 72));
  }
  xpc_release(object);
  JUMPOUT(0x100BD69C4);
}

void sub_100BD6A10()
{
  if (*(char *)(v0 - 49) < 0) {
    operator delete(*(void **)(v0 - 72));
  }
  xpc_release(*(xpc_object_t *)(v0 - 96));
  *(void *)(v0 - 96) = 0;
  JUMPOUT(0x100BD69C4);
}

void sub_100BD6A4C(uint64_t a1, int a2, uint64_t a3, ctu *a4)
{
  if (!CallInfo::operator BOOL()) {
    return;
  }
  xpc_object_t v30 = 0;
  xpc_object_t v7 = (xpc_object_t *)xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t v30 = v7;
  }
  else
  {
    xpc_object_t v8 = (xpc_object_t *)xpc_null_create();
    xpc_object_t v30 = v8;
    if (!v8)
    {
      xpc_object_t v9 = (xpc_object_t *)xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_9;
    }
  }
  if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v8);
    goto LABEL_10;
  }
  xpc_object_t v9 = (xpc_object_t *)xpc_null_create();
LABEL_9:
  xpc_object_t v30 = v9;
LABEL_10:
  xpc_release(v8);
  xpc_object_t v29 = 0;
  xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v11 = v10;
  if (v10)
  {
    xpc_object_t v29 = v10;
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
    xpc_object_t v29 = v11;
    if (!v11)
    {
      xpc_object_t v12 = xpc_null_create();
      xpc_object_t v11 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v11) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v12 = xpc_null_create();
LABEL_17:
    xpc_object_t v29 = v12;
    goto LABEL_18;
  }
  xpc_retain(v11);
LABEL_18:
  xpc_release(v11);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v28 = 0;
  ctu::cf::assign();
  uint64_t v26 = a4;
  if (a4)
  {
    CFRetain(a4);
    uint64_t v14 = v26;
  }
  else
  {
    uint64_t v14 = 0;
  }
  ctu::cf_to_xpc((uint64_t *)&v24, v14, v13);
  xpc_object_t v15 = __p;
  if (v28 < 0) {
    xpc_object_t v15 = (void **)__p[0];
  }
  xpc_object_t v22 = (xpc_object_t *)&v30;
  xpc_object_t v23 = (const char *)v15;
  sub_100035E70((uint64_t)&v22, &v24, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
  sub_10057DEAC(a3, (char *)&v20);
  xpc_object_t v22 = &v29;
  xpc_object_t v23 = "kCTCallProcessing";
  sub_10014E03C((uint64_t)&v22, &v20, &v21);
  xpc_release(v21);
  xpc_object_t v21 = 0;
  xpc_release(v20);
  xpc_object_t v20 = 0;
  if (a2) {
    int v16 = 146;
  }
  else {
    int v16 = 147;
  }
  xpc_object_t v17 = v30;
  xpc_object_t v22 = v30;
  if (v30)
  {
    xpc_retain(v30);
  }
  else
  {
    xpc_object_t v17 = (xpc_object_t *)xpc_null_create();
    xpc_object_t v22 = v17;
  }
  xpc_object_t v18 = v29;
  xpc_object_t v19 = v29;
  if (v29)
  {
    xpc_retain(v29);
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
    xpc_object_t v19 = v18;
  }
  sub_1000452AC(v16, (xpc_object_t *)&v22, &v19);
  xpc_release(v18);
  xpc_release(v17);
  sub_100030068((const void **)&v26);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v29);
  xpc_release(v30);
}

void sub_100BD6CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, const void *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  xpc_release(v24);
  xpc_release(v23);
  sub_100030068(&a17);
  if (a23 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v25 - 64));
  xpc_release(*(xpc_object_t *)(v25 - 56));
  _Unwind_Resume(a1);
}

void sub_100BD6D8C(uint64_t a1, BOOL a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v15 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v15 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v15 = v5;
LABEL_9:
  xpc_release(v4);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v14 = 0;
  ctu::cf::assign();
  xpc_object_t v11 = xpc_BOOL_create(a2);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  xpc_object_t v6 = __p;
  if (v14 < 0) {
    xpc_object_t v6 = (void **)__p[0];
  }
  v10[0] = &v15;
  v10[1] = v6;
  sub_100035E70((uint64_t)v10, &v11, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v7 = v15;
  v10[0] = v15;
  if (v15)
  {
    xpc_retain(v15);
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    v10[0] = v7;
  }
  xpc_object_t v8 = xpc_null_create();
  xpc_object_t v9 = v8;
  sub_1000452AC(148, v10, &v9);
  xpc_release(v8);
  xpc_release(v7);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v15);
}

void sub_100BD6F18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  xpc_object_t v23 = v21;
  xpc_release(v23);
  xpc_release(v20);
  if (a20 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v22 - 24));
  _Unwind_Resume(a1);
}

void sub_100BD6F84(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (CallInfo::operator BOOL())
  {
    xpc_object_t v23 = 0;
    xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v7 = v6;
    if (v6)
    {
      xpc_object_t v23 = v6;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v23 = v7;
      if (!v7)
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_11;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
      goto LABEL_12;
    }
    xpc_object_t v9 = xpc_null_create();
LABEL_11:
    xpc_object_t v23 = v9;
LABEL_12:
    xpc_release(v7);
    xpc_object_t v22 = 0;
    xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v11 = v10;
    if (v10)
    {
      xpc_object_t v22 = v10;
    }
    else
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v22 = v11;
      if (!v11)
      {
        xpc_object_t v12 = xpc_null_create();
        xpc_object_t v11 = 0;
        goto LABEL_19;
      }
    }
    if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v11);
LABEL_20:
      xpc_release(v11);
      xpc_object_t v20 = xpc_int64_create(a3);
      if (!v20) {
        xpc_object_t v20 = xpc_null_create();
      }
      memset(buf, 0, sizeof(buf));
      uint64_t v25 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v18 = 0;
      v19[0] = &v23;
      v19[1] = __p;
      sub_100035E70((uint64_t)v19, &v20, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      if (SHIBYTE(v18) < 0) {
        operator delete(__p[0]);
      }
      xpc_release(v20);
      xpc_object_t v20 = 0;
      sub_10057DEAC(a2, (char *)&v15);
      *(void *)long long buf = &v22;
      *(void *)&uint8_t buf[8] = "kCTCallProcessing";
      sub_10014E03C((uint64_t)buf, &v15, &v16);
      xpc_release(v16);
      xpc_object_t v16 = 0;
      xpc_release(v15);
      xpc_object_t v15 = 0;
      xpc_object_t v13 = v23;
      *(void *)long long buf = v23;
      if (v23)
      {
        xpc_retain(v23);
      }
      else
      {
        xpc_object_t v13 = xpc_null_create();
        *(void *)long long buf = v13;
      }
      xpc_object_t v14 = v22;
      __p[0] = v22;
      if (v22)
      {
        xpc_retain(v22);
      }
      else
      {
        xpc_object_t v14 = xpc_null_create();
        __p[0] = v14;
      }
      sub_1000452AC(8, (xpc_object_t *)buf, __p);
      xpc_release(v14);
      xpc_release(v13);
      xpc_release(v22);
      xpc_release(v23);
      return;
    }
    xpc_object_t v12 = xpc_null_create();
LABEL_19:
    xpc_object_t v22 = v12;
    goto LABEL_20;
  }
  xpc_object_t v8 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot send kCTEventCallAudioToneRelay! Call is invalid.", buf, 2u);
  }
}

void sub_100BD7258(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(v20);
  xpc_release(v19);
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v21 - 72));
  _Unwind_Resume(a1);
}

void sub_100BD72F8(uint64_t a1, BOOL a2, uint64_t a3)
{
  xpc_object_t v24 = 0;
  xpc_object_t v5 = (xpc_object_t *)xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v24 = v5;
  }
  else
  {
    xpc_object_t v6 = (xpc_object_t *)xpc_null_create();
    xpc_object_t v24 = v6;
    if (!v6)
    {
      xpc_object_t v7 = (xpc_object_t *)xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_9;
  }
  xpc_object_t v7 = (xpc_object_t *)xpc_null_create();
LABEL_8:
  xpc_object_t v24 = v7;
LABEL_9:
  xpc_release(v6);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v23 = 0;
  ctu::cf::assign();
  xpc_object_t v20 = xpc_BOOL_create(a2);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  xpc_object_t v8 = __p;
  if (v23 < 0) {
    xpc_object_t v8 = (void **)__p[0];
  }
  uint64_t v18 = (xpc_object_t *)&v24;
  xpc_object_t v19 = (const char *)v8;
  sub_100035E70((uint64_t)&v18, &v20, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_object_t v17 = 0;
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v10 = v9;
  if (v9)
  {
    xpc_object_t v17 = v9;
  }
  else
  {
    xpc_object_t v10 = xpc_null_create();
    xpc_object_t v17 = v10;
    if (!v10)
    {
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v10 = 0;
      goto LABEL_20;
    }
  }
  if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v10);
    goto LABEL_21;
  }
  xpc_object_t v11 = xpc_null_create();
LABEL_20:
  xpc_object_t v17 = v11;
LABEL_21:
  xpc_release(v10);
  sub_10057DEAC(a3, (char *)&v15);
  uint64_t v18 = &v17;
  xpc_object_t v19 = "kCTCallProcessing";
  sub_10014E03C((uint64_t)&v18, &v15, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_object_t v12 = v24;
  uint64_t v18 = v24;
  if (v24)
  {
    xpc_retain(v24);
  }
  else
  {
    xpc_object_t v12 = (xpc_object_t *)xpc_null_create();
    uint64_t v18 = v12;
  }
  xpc_object_t v13 = v17;
  xpc_object_t v14 = v17;
  if (v17)
  {
    xpc_retain(v17);
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v14 = v13;
  }
  sub_1000452AC(153, (xpc_object_t *)&v18, &v14);
  xpc_release(v13);
  xpc_release(v12);
  xpc_release(v17);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v24);
}

void sub_100BD756C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  xpc_release(v23);
  xpc_release(v22);
  xpc_release(object);
  if (a22 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v24 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_100BD75FC(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_100BD7634(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  operator delete();
}

void sub_100BD768C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A450B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BD76AC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A450B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BD7700(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_100BD7728(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_100BD7760(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  operator delete();
}

int *sub_100BD77B8(int *a1, uint64_t a2)
{
  int v2 = (unsigned char *)(a2 + 8);
  xpc_object_t v5 = a1 + 2;
  switch(*(_DWORD *)a2 ^ (*(int *)a2 >> 31))
  {
    case 0:
      *(unsigned char *)xpc_object_t v5 = *v2;
      break;
    case 1:
      *xpc_object_t v5 = *(_DWORD *)v2;
      break;
    case 2:
      if (*(char *)(a2 + 31) < 0)
      {
        sub_10004FC84(v5, *(void **)(a2 + 8), *(void *)(a2 + 16));
      }
      else
      {
        long long v6 = *(_OWORD *)v2;
        *((void *)v5 + 2) = *(void *)(a2 + 24);
        *(_OWORD *)xpc_object_t v5 = v6;
      }
      break;
    default:
      sub_1000971B8();
  }
  *a1 = *(_DWORD *)a2 ^ (*(int *)a2 >> 31);
  return a1;
}

void sub_100BD78B4(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)a1 ^ (*(int *)a1 >> 31);
  if (v1 >= 2)
  {
    if (v1 != 2) {
      sub_1000971B8();
    }
    if (*(char *)(a1 + 31) < 0)
    {
      int v2 = *(void **)(a1 + 8);
      operator delete(v2);
    }
  }
}

void sub_100BD790C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100BD7C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100BD7E04(uint64_t a1)
{
  *(void *)a1 = off_101A451C0;
  sub_10030AB98((void *)(a1 + 168));
  sub_1000440D4((const void **)(a1 + 152));
  sub_100044D00((const void **)(a1 + 144));
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_object_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    sub_10004D2C8(v3);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    sub_10004D2C8(v4);
  }
  xpc_object_t v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100BD7EB0(uint64_t a1)
{
  sub_100BD7E04(a1);

  operator delete();
}

void sub_100BD7EE8(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_100BD7FE8(uint64_t a1)
{
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 80) + 24))(&cf);
  CFDictionaryRef v2 = (const __CFDictionary *)cf;
  if (cf) {
    xpc_object_t v3 = sub_100080778;
  }
  else {
    xpc_object_t v3 = 0;
  }
  xpc_object_t v4 = (os_log_t *)(a1 + 40);
  xpc_object_t v5 = *(NSObject **)(a1 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v6)
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Received message from lockdown: %@", (uint8_t *)&buf, 0xCu);
      CFDictionaryRef v2 = (const __CFDictionary *)cf;
    }
    CFStringRef theString1 = 0;
    *(void *)&long long buf = CFDictionaryGetValue(v2, @"messageName");
    sub_100056248(&theString1, (CFTypeRef *)&buf);
    if (CFStringCompare(theString1, @"GetURLList", 1uLL))
    {
      xpc_object_t v7 = *v4;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = theString1;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Received Unknown command: %@. Disconnect", (uint8_t *)&buf, 0xCu);
      }
      sub_100BD9AC4(a1);
      goto LABEL_242;
    }
    CFDictionaryRef v8 = (const __CFDictionary *)cf;
    CFDictionaryRef theDict = (CFDictionaryRef)cf;
    if (cf)
    {
      CFRetain(cf);
      CFDictionaryRef v8 = theDict;
    }
    CFStringRef Value = (BOOL *)CFDictionaryGetValue(v8, @"storeActivationMode");
    xpc_object_t v10 = Value;
    LOBYTE(buf) = 0;
    if (Value && (CFTypeID v11 = CFGetTypeID(Value), v11 == CFBooleanGetTypeID()))
    {
      ctu::cf::assign((ctu::cf *)&buf, v10, v12);
      char v13 = buf;
    }
    else
    {
      char v13 = 0;
    }
    *(unsigned char *)(a1 + 112) = v13;
    xpc_object_t v14 = (BOOL *)CFDictionaryGetValue(theDict, @"isManualCheck");
    xpc_object_t v15 = v14;
    LOBYTE(buf) = 0;
    if (v14)
    {
      CFTypeID v16 = CFGetTypeID(v14);
      if (v16 == CFBooleanGetTypeID()) {
        ctu::cf::assign((ctu::cf *)&buf, v15, v17);
      }
    }
    *(unsigned char *)(a1 + 113) = buf;
    *(void *)int v150 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      xpc_object_t v19 = *(__CFDictionary **)v150;
      *(void *)int v150 = Mutable;
      *(void *)&long long buf = v19;
      sub_10005717C((const void **)&buf);
    }
    if (*(unsigned char *)(a1 + 113))
    {
LABEL_26:
      if (!*(unsigned char *)(a1 + 200))
      {
        *(unsigned char *)(a1 + 200) = 1;
        uint64_t v20 = *(void *)(a1 + 192);
        if (v20) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 48))(v20, a1 + 200);
        }
      }
      __int16 v149 = 0;
      sub_1006CEDDC((Registry **)(a1 + 48), (uint64_t *)&v149);
      uint64_t v21 = v149;
      if (v149) {
        xpc_object_t v22 = sub_1000810B8;
      }
      else {
        xpc_object_t v22 = 0;
      }
      if (v22)
      {
        uint64_t v23 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v21;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Received URL: %{public}@", (uint8_t *)&buf, 0xCu);
          uint64_t v21 = v149;
        }
        CFTypeRef v148 = v21;
        if (v21) {
          CFRetain(v21);
        }
        theDate[0] = 0;
        CFDateRef v24 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (v24)
        {
          CFDateRef v25 = theDate[0];
          theDate[0] = v24;
          *(void *)&long long buf = v25;
          sub_1000440D4((const void **)&buf);
        }
        if (v148) {
          uint64_t v26 = sub_1000810B8;
        }
        else {
          uint64_t v26 = 0;
        }
        if (v26)
        {
          __p[0] = 0;
          CFMutableDictionaryRef v27 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v27)
          {
            uint64_t v28 = __p[0];
            __p[0] = v27;
            *(void *)&long long buf = v28;
            sub_10005717C((const void **)&buf);
          }
          sub_10010F3F0((__CFDictionary *)__p[0], @"URL", (uint64_t)v148);
          sub_10012C97C((__CFDictionary *)__p[0], @"StripLegacyVersionXML", (uint64_t)kCFBooleanTrue);
          sub_100699750(theDate[0], __p[0]);
          sub_100044D6C(&v167, (CFTypeRef *)theDate);
          sub_10005717C((const void **)__p);
        }
        else
        {
          sub_100044D6C(&v167, (CFTypeRef *)theDate);
        }
        sub_1000440D4((const void **)theDate);
        sub_10015C624(*(__CFDictionary **)v150, @"URLList", (uint64_t)v167);
        sub_100044D00((const void **)&v167);
        sub_1000558F4(&v148);
        sub_100BD9FB4((CFNumberRef *)&buf, 0);
        sub_10069637C(*(__CFDictionary **)v150, @"status", buf);
        sub_1000570E8((const void **)&buf);
        uint64_t v42 = *(void *)(a1 + 80);
        sub_10004EFE4(&v147, (CFTypeRef *)v150);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v42 + 32))(v42, &v147);
        sub_100057D78(&v147);
        if (v42)
        {
          CFTypeRef v161 = 0;
          (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 80) + 24))(&v161);
          if (v161) {
            char v43 = sub_100080778;
          }
          else {
            char v43 = 0;
          }
          if (!v43)
          {
            long long v68 = *v4;
            if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I Invalid request. Disconnect.", (uint8_t *)&buf, 2u);
            }
            sub_100BD9AC4(a1);
            goto LABEL_239;
          }
          *(void *)uint64_t v160 = 0;
          CFMutableDictionaryRef v44 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v44)
          {
            xpc_object_t v45 = *(__CFDictionary **)v160;
            *(void *)uint64_t v160 = v44;
            *(void *)&long long buf = v45;
            sub_10005717C((const void **)&buf);
          }
          CFTypeRef v159 = v161;
          if (v161) {
            CFRetain(v161);
          }
          char v46 = sub_100BDA03C((std::string *)a1, (CFDictionaryRef *)&v159);
          sub_100057D78(&v159);
          if ((v46 & 1) == 0)
          {
            long long v72 = *v4;
            if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf) = 138543362;
              *(void *)((char *)&buf + 4) = v161;
              _os_log_error_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "Failed to receive bytes for %{public}@", (uint8_t *)&buf, 0xCu);
            }
            sub_100BD9FB4((CFNumberRef *)&buf, 2u);
            sub_10069637C(*(__CFDictionary **)v160, @"status", buf);
            sub_1000570E8((const void **)&buf);
            int v73 = *v4;
            if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 138543362;
              *(void *)((char *)&buf + 4) = *(void *)v160;
              _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#I Sending reply for transfer failure: %{public}@", (uint8_t *)&buf, 0xCu);
            }
            uint64_t v74 = *(void *)(a1 + 80);
            sub_10004EFE4(&buf, (CFTypeRef *)v160);
            (*(void (**)(uint64_t, long long *))(*(void *)v74 + 32))(v74, &buf);
            sub_100057D78((const void **)&buf);
            sub_100BD9AC4(a1);
LABEL_238:
            sub_10005717C((const void **)v160);
LABEL_239:
            sub_100057D78(&v161);
            goto LABEL_240;
          }
          sub_100BD9FB4((CFNumberRef *)&buf, 0);
          sub_10069637C(*(__CFDictionary **)v160, @"status", buf);
          sub_1000570E8((const void **)&buf);
          xpc_object_t v47 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138543362;
            *(void *)((char *)&buf + 4) = *(void *)v160;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Sending Success after version.xml transfer: %{public}@", (uint8_t *)&buf, 0xCu);
          }
          uint64_t v48 = *(void *)(a1 + 80);
          sub_10004EFE4(&v158, (CFTypeRef *)v160);
          (*(void (**)(uint64_t, const void **))(*(void *)v48 + 32))(v48, &v158);
          sub_100057D78(&v158);
          ServiceMap = (std::mutex *)Registry::getServiceMap(v49, *(Registry **)(a1 + 48));
          std::string::size_type v51 = ServiceMap;
          if (v52 < 0)
          {
            xpc_object_t v53 = (unsigned __int8 *)(v52 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v54 = 5381;
            do
            {
              uint64_t v52 = v54;
              unsigned int v55 = *v53++;
              uint64_t v54 = (33 * v54) ^ v55;
            }
            while (v55);
          }
          std::mutex::lock(ServiceMap);
          *(void *)&long long buf = v52;
          xpc_object_t v56 = sub_10004D37C(&v51[1].__m_.__sig, (unint64_t *)&buf);
          if (v56)
          {
            uint64_t v57 = v56[3];
            xpc_object_t v58 = (std::__shared_weak_count *)v56[4];
            if (v58)
            {
              atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v51);
              atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v58);
              char v59 = 0;
LABEL_110:
              if (v57)
              {
                CFTypeID v142 = v58;
                (*(void (**)(CFDateRef *__return_ptr, uint64_t, uint64_t))(*(void *)v57 + 288))(theDate, v57, a1 + 120);
                int v75 = (CFArrayRef *)(a1 + 144);
                if ((CFDateRef *)(a1 + 144) != theDate)
                {
                  *(void *)&long long buf = *v75;
                  CFArrayRef *v75 = theDate[0];
                  theDate[0] = 0;
                  sub_100044D00((const void **)&buf);
                }
                char v143 = v59;
                sub_100044D00((const void **)theDate);
                CFDictionaryRef v157 = 0;
                (*(void (**)(CFDictionaryRef *__return_ptr))(**(void **)(a1 + 80) + 24))(&v157);
                CFDictionaryRef v76 = v157;
                if (v157) {
                  uint64_t v77 = sub_100080778;
                }
                else {
                  uint64_t v77 = 0;
                }
                unsigned int v78 = *v4;
                BOOL v79 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
                if (v77)
                {
                  if (v79)
                  {
                    LODWORD(buf) = 138543362;
                    *(void *)((char *)&buf + 4) = v76;
                    _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I Received message from lockdown: %{public}@", (uint8_t *)&buf, 0xCu);
                    CFDictionaryRef v76 = v157;
                  }
                  theDate[0] = 0;
                  theDate[1] = 0;
                  uint64_t v156 = 0;
                  CFDictionaryGetValue(v76, @"messageName");
                  long long buf = 0uLL;
                  uint64_t v169 = 0;
                  ctu::cf::assign();
                  *(_OWORD *)theDate = buf;
                  uint64_t v156 = v169;
                  long long buf = 0uLL;
                  uint64_t v169 = 0;
                  ctu::cf::assign();
                  uint64_t v154 = v169;
                  *(_OWORD *)std::string __p = buf;
                  if (v156 >= 0) {
                    CFDateRef v80 = (CFDateRef)HIBYTE(v156);
                  }
                  else {
                    CFDateRef v80 = theDate[1];
                  }
                  CFDateRef v81 = (CFDateRef)HIBYTE(v154);
                  int v82 = SHIBYTE(v154);
                  if (v154 < 0) {
                    CFDateRef v81 = (CFDateRef)__p[1];
                  }
                  if (v80 == v81)
                  {
                    if (v154 >= 0) {
                      uint64_t v83 = __p;
                    }
                    else {
                      uint64_t v83 = (void **)__p[0];
                    }
                    if (v156 < 0)
                    {
                      BOOL v92 = memcmp(theDate[0], v83, (size_t)theDate[1]) == 0;
                    }
                    else if (HIBYTE(v156))
                    {
                      uint64_t v84 = HIBYTE(v156) - 1;
                      uint64_t v85 = theDate;
                      do
                      {
                        int v87 = *(unsigned __int8 *)v85;
                        uint64_t v85 = (CFDateRef *)((char *)v85 + 1);
                        int v86 = v87;
                        int v89 = *(unsigned __int8 *)v83;
                        uint64_t v83 = (void **)((char *)v83 + 1);
                        int v88 = v89;
                        BOOL v91 = v84-- != 0;
                        BOOL v92 = v86 == v88;
                      }
                      while (v86 == v88 && v91);
                    }
                    else
                    {
                      BOOL v92 = 1;
                    }
                  }
                  else
                  {
                    BOOL v92 = 0;
                  }
                  if (v82 < 0) {
                    operator delete(__p[0]);
                  }
                  if (!v92)
                  {
                    uint64_t v93 = *v4;
                    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v94 = theDate;
                      if (v156 < 0) {
                        uint64_t v94 = (CFDateRef *)theDate[0];
                      }
                      LODWORD(buf) = 136315138;
                      *(void *)((char *)&buf + 4) = v94;
                      _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#I Received Unknown command: %s. Disconnect", (uint8_t *)&buf, 0xCu);
                    }
                    sub_100BD9AC4(a1);
                  }
                  if (*v75) {
                    uint64_t v95 = sub_100083F10;
                  }
                  else {
                    uint64_t v95 = 0;
                  }
                  if (v95 && CFArrayGetCount(*v75))
                  {
                    sub_100062740((const void **)&theArray, (const void **)(a1 + 144));
                    __p[0] = 0;
                    CFMutableArrayRef v96 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                    if (v96)
                    {
                      uint64_t v97 = __p[0];
                      __p[0] = v96;
                      *(void *)&long long buf = v97;
                      sub_1000440D4((const void **)&buf);
                    }
                    if (theArray) {
                      uint64_t v98 = sub_100083F10;
                    }
                    else {
                      uint64_t v98 = 0;
                    }
                    if (v98)
                    {
                      CFIndex Count = CFArrayGetCount(theArray);
                      if (Count >= 1)
                      {
                        for (CFIndex i = 0; i != Count; ++i)
                        {
                          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
                          CFDictionaryRef v102 = ValueAtIndex;
                          if (ValueAtIndex)
                          {
                            CFTypeID v103 = CFGetTypeID(ValueAtIndex);
                            if (v103 == CFDictionaryGetTypeID()) {
                              CFDictionaryRef v104 = v102;
                            }
                            else {
                              CFDictionaryRef v104 = 0;
                            }
                          }
                          else
                          {
                            CFDictionaryRef v104 = 0;
                          }
                          int v105 = CFDictionaryGetValue(v104, @"BundleURL");
                          uint64_t v106 = (uint64_t)v105;
                          if (v105)
                          {
                            CFTypeID v107 = CFGetTypeID(v105);
                            if (v107 == CFStringGetTypeID())
                            {
                              unint64_t v167 = 0;
                              CFMutableDictionaryRef v108 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                              if (v108)
                              {
                                long long v109 = v167;
                                unint64_t v167 = v108;
                                *(void *)&long long buf = v109;
                                sub_10005717C((const void **)&buf);
                              }
                              sub_10010F3F0(v167, @"URL", v106);
                              sub_100699750((__CFArray *)__p[0], v167);
                              sub_10005717C((const void **)&v167);
                            }
                          }
                        }
                      }
                    }
                    sub_100044D6C(&v166, (CFTypeRef *)__p);
                    uint64_t v110 = (CFArrayRef *)(a1 + 144);
                    sub_1000440D4((const void **)__p);
                    sub_10015C624(*(__CFDictionary **)v160, @"URLList", (uint64_t)v166);
                    sub_100044D00((const void **)&v166);
                    sub_100044D00((const void **)&theArray);
                    sub_100BD9FB4((CFNumberRef *)&buf, 0);
                    sub_100BDC408(*(__CFDictionary **)v160, (const void *)buf);
                    sub_1000570E8((const void **)&buf);
                    uint64_t v111 = *(void *)(a1 + 80);
                    sub_10004EFE4(&v151, (CFTypeRef *)v160);
                    LOBYTE(v111) = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v111 + 32))(v111, &v151);
                    sub_100057D78(&v151);
                    if (v111)
                    {
                      CFIndex v112 = CFArrayGetCount(*(CFArrayRef *)(a1 + 144));
                      CFMutableArrayRef v113 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                      uint64_t v114 = (CFMutableArrayRef *)(a1 + 152);
                      if (v113)
                      {
                        CFMutableArrayRef v115 = *v114;
                        *uint64_t v114 = v113;
                        *(void *)&long long buf = v115;
                        sub_1000440D4((const void **)&buf);
                      }
                      char v141 = 1;
                      do
                      {
                        if (v112 < 1) {
                          break;
                        }
                        unint64_t v167 = 0;
                        (*(void (**)(__CFDictionary **__return_ptr))(**(void **)(a1 + 80) + 24))(&v167);
                        uint64_t v116 = v167;
                        if (v167) {
                          uint64_t v117 = sub_100080778;
                        }
                        else {
                          uint64_t v117 = 0;
                        }
                        uint64_t v118 = *v4;
                        BOOL v119 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
                        if (!v117)
                        {
                          if (v119)
                          {
                            LOWORD(buf) = 0;
                            _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "#I Invalid request. Disconnect.", (uint8_t *)&buf, 2u);
                          }
                          sub_100057D78((const void **)&v167);
                          goto LABEL_231;
                        }
                        if (v119)
                        {
                          LODWORD(buf) = 138412290;
                          *(void *)((char *)&buf + 4) = v116;
                          _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "#I Received message is %@", (uint8_t *)&buf, 0xCu);
                        }
                        long long v166 = 0;
                        CFMutableDictionaryRef v120 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                        if (v120)
                        {
                          uint64_t v121 = v166;
                          long long v166 = v120;
                          *(void *)&long long buf = v121;
                          sub_10005717C((const void **)&buf);
                        }
                        sub_100BD9FB4((CFNumberRef *)&buf, 0);
                        sub_10069637C(v166, @"status", buf);
                        sub_1000570E8((const void **)&buf);
                        uint64_t v165 = v167;
                        if (v167) {
                          CFRetain(v167);
                        }
                        char v122 = sub_100BDA03C((std::string *)a1, &v165);
                        sub_100057D78((const void **)&v165);
                        if ((v122 & 1) == 0)
                        {
                          sub_100BD9FB4((CFNumberRef *)&buf, 2u);
                          sub_100BDC408(v166, (const void *)buf);
                          sub_1000570E8((const void **)&buf);
                          CFDictionaryRef v123 = v167;
                          v163 = v167;
                          if (v167)
                          {
                            CFRetain(v167);
                            CFDictionaryRef v123 = v163;
                          }
                          *(void *)&long long buf = 0;
                          __p[0] = (void *)CFDictionaryGetValue(v123, @"originalURL");
                          sub_100056248(&buf, (CFTypeRef *)__p);
                          if ((void)buf) {
                            unsigned int v124 = sub_1000810B8;
                          }
                          else {
                            unsigned int v124 = 0;
                          }
                          if (v124 && (CFIndex v125 = CFArrayGetCount(*v110), v125 >= 1))
                          {
                            CFIndex v126 = 0;
                            while (1)
                            {
                              CFDictionaryRef v164 = 0;
                              __p[0] = (void *)CFArrayGetValueAtIndex(*v110, v126);
                              sub_10004EFE4(&v164, (CFTypeRef *)__p);
                              unint64_t v127 = CFDictionaryGetValue(v164, @"BundleURL");
                              v128 = v127;
                              if (v127)
                              {
                                CFTypeID v129 = CFGetTypeID(v127);
                                unint64_t v130 = v129 == CFStringGetTypeID() ? v128 : 0;
                              }
                              else
                              {
                                unint64_t v130 = 0;
                              }
                              uint64_t v110 = (CFArrayRef *)(a1 + 144);
                              if (CFEqual(v130, (CFTypeRef)buf)) {
                                break;
                              }
                              sub_100057D78((const void **)&v164);
                              if (v125 == ++v126) {
                                goto LABEL_209;
                              }
                            }
                          }
                          else
                          {
LABEL_209:
                            CFDictionaryRef v164 = 0;
                          }
                          sub_1000558F4((const void **)&buf);
                          sub_100527E94(a1, (const void **)&v164);
                          sub_100057D78((const void **)&v164);
                          sub_100057D78((const void **)&v163);
                        }
                        int v131 = *v4;
                        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
                        {
                          LODWORD(buf) = 138412290;
                          *(void *)((char *)&buf + 4) = v166;
                          _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "#I Sending reply for transfer: %@", (uint8_t *)&buf, 0xCu);
                        }
                        uint64_t v132 = *(void *)(a1 + 80);
                        sub_10004EFE4(&v162, (CFTypeRef *)&v166);
                        char v133 = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v132 + 32))(v132, &v162);
                        sub_100057D78(&v162);
                        if (v133)
                        {
                          --v112;
                        }
                        else
                        {
                          CFTypeID v134 = *v4;
                          if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
                          {
                            LOWORD(buf) = 0;
                            _os_log_error_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_ERROR, "Failed sending reply for transfer failure.Disconnect.", (uint8_t *)&buf, 2u);
                          }
                          char v141 = 0;
                        }
                        sub_10005717C((const void **)&v166);
                        sub_100057D78((const void **)&v167);
                      }
                      while ((v133 & 1) != 0);
                      if ((v141 & 1) == 0) {
                        goto LABEL_231;
                      }
                      sub_100044D6C(__p, (CFTypeRef *)(a1 + 152));
                      uint64_t v139 = *(unsigned __int8 *)(a1 + 112);
                      *(void *)&long long buf = off_101A45458;
                      *((void *)&buf + 1) = a1;
                      p_long long buf = &buf;
                      (*(void (**)(uint64_t, void **, uint64_t, long long *))(*(void *)v57 + 296))(v57, __p, v139, &buf);
                      sub_100060644(&buf);
                      sub_100044D00((const void **)__p);
                    }
                    else
                    {
                      CFTypeID v138 = *v4;
                      if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
                      {
                        LOWORD(buf) = 0;
                        _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, "#I Failed to send urllist to lockdown.Disconnect.", (uint8_t *)&buf, 2u);
                      }
LABEL_231:
                      sub_100BD9AC4(a1);
                    }
                  }
                  else
                  {
                    CFNumberRef v135 = *v4;
                    if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
                    {
                      LOWORD(buf) = 0;
                      _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "#I No updates available", (uint8_t *)&buf, 2u);
                    }
                    sub_100BD9FB4((CFNumberRef *)&buf, 1u);
                    sub_100BDC408(*(__CFDictionary **)v160, (const void *)buf);
                    id v136 = sub_1000570E8((const void **)&buf);
                    uint64_t v137 = *(void *)(a1 + 80);
                    sub_10004EFE4(v136, (CFTypeRef *)v160);
                    (*(void (**)(uint64_t, long long *))(*(void *)v137 + 32))(v137, &buf);
                    sub_100057D78((const void **)&buf);
                    sub_100BD9AC4(a1);
                    sub_100BDAD80(a1, 3);
                  }
                  if (SHIBYTE(v156) < 0) {
                    operator delete(theDate[0]);
                  }
                  xpc_object_t v58 = v142;
                  char v59 = v143;
                }
                else
                {
                  if (v79)
                  {
                    LOWORD(buf) = 0;
                    _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I Invalid request. Disconnect.", (uint8_t *)&buf, 2u);
                  }
                  xpc_object_t v58 = v142;
                  char v59 = v143;
                  sub_100BD9AC4(a1);
                }
                sub_100057D78((const void **)&v157);
              }
              else
              {
                sub_100BD9AC4(a1);
              }
              if ((v59 & 1) == 0) {
                sub_10004D2C8(v58);
              }
              goto LABEL_238;
            }
          }
          else
          {
            uint64_t v57 = 0;
          }
          std::mutex::unlock(v51);
          xpc_object_t v58 = 0;
          char v59 = 1;
          goto LABEL_110;
        }
        xpc_object_t v60 = *v4;
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "Error sending message. Disconnect.", (uint8_t *)&buf, 2u);
        }
      }
      else
      {
        sub_100BD9FB4((CFNumberRef *)&buf, 1u);
        sub_10069637C(*(__CFDictionary **)v150, @"status", buf);
        char v40 = sub_1000570E8((const void **)&buf);
        uint64_t v41 = *(void *)(a1 + 80);
        sub_10004EFE4(v40, (CFTypeRef *)v150);
        (*(void (**)(uint64_t, long long *))(*(void *)v41 + 32))(v41, &buf);
        sub_100057D78((const void **)&buf);
      }
      sub_100BD9AC4(a1);
LABEL_240:
      sub_1000558F4(&v149);
LABEL_241:
      sub_10005717C((const void **)v150);
      sub_100057D78((const void **)&theDict);
LABEL_242:
      sub_1000558F4((const void **)&theString1);
      return sub_100057D78(&cf);
    }
    xpc_object_t v29 = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(a1 + 113), *(Registry **)(a1 + 48));
    xpc_object_t v30 = v29;
    if (v31 < 0)
    {
      int v32 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v33 = 5381;
      do
      {
        uint64_t v31 = v33;
        unsigned int v34 = *v32++;
        uint64_t v33 = (33 * v33) ^ v34;
      }
      while (v34);
    }
    std::mutex::lock(v29);
    *(void *)&long long buf = v31;
    xpc_object_t v35 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)&buf);
    if (v35)
    {
      uint64_t v37 = v35[3];
      xpc_object_t v36 = (std::__shared_weak_count *)v35[4];
      if (v36)
      {
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v30);
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v36);
        char v38 = 0;
        if (!v37)
        {
LABEL_52:
          long long v39 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Cannot create preferences", (uint8_t *)&buf, 2u);
            if (v38) {
              goto LABEL_100;
            }
            goto LABEL_54;
          }
          if ((v38 & 1) == 0) {
LABEL_54:
          }
            sub_10004D2C8(v36);
LABEL_100:
          long long v69 = *v4;
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#I Not proceeding with update check now.", (uint8_t *)&buf, 2u);
          }
          sub_100BD9FB4((CFNumberRef *)&buf, 1u);
          sub_10069637C(*(__CFDictionary **)v150, @"status", buf);
          long long v70 = sub_1000570E8((const void **)&buf);
          uint64_t v71 = *(void *)(a1 + 80);
          sub_10004EFE4(v70, (CFTypeRef *)v150);
          (*(void (**)(uint64_t, long long *))(*(void *)v71 + 32))(v71, &buf);
          sub_100057D78((const void **)&buf);
          sub_100BD9AC4(a1);
          goto LABEL_241;
        }
LABEL_80:
        theDate[0] = 0;
        (*(void (**)(long long *__return_ptr, uint64_t, const __CFString *, void, const CFStringRef, const CFStringRef))(*(void *)v37 + 40))(&buf, v37, @"kNextDesktopHostCarrierBundleUpdateCheck", kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        sub_100201EE4(theDate, (CFTypeRef *)&buf);
        sub_1000577C4((const void **)&buf);
        if (theDate[0]) {
          uint64_t v61 = sub_1001908E4;
        }
        else {
          uint64_t v61 = 0;
        }
        if (v61)
        {
          double Current = CFAbsoluteTimeGetCurrent();
          double AbsoluteTime = CFDateGetAbsoluteTime(theDate[0]);
          uint64_t v64 = *v4;
          BOOL v65 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
          if (Current < AbsoluteTime)
          {
            if (v65)
            {
              LODWORD(buf) = 138543362;
              *(CFDateRef *)((char *)&buf + 4) = theDate[0];
              _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I Next update check is: %{public}@. Will check update then.", (uint8_t *)&buf, 0xCu);
            }
            char v66 = 0;
LABEL_97:
            sub_10007CA64((const void **)theDate);
            if ((v38 & 1) == 0) {
              sub_10004D2C8(v36);
            }
            if (v66) {
              goto LABEL_26;
            }
            goto LABEL_100;
          }
          if (v65)
          {
            LOWORD(buf) = 0;
            long long v67 = "#I Past the update check date in preferences. Proceeding to continue with the update.";
            goto LABEL_95;
          }
        }
        else
        {
          uint64_t v64 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            long long v67 = "#I Update check date not available in preferences. Proceeding to continue with the update.";
LABEL_95:
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, v67, (uint8_t *)&buf, 2u);
          }
        }
        char v66 = 1;
        goto LABEL_97;
      }
    }
    else
    {
      uint64_t v37 = 0;
    }
    std::mutex::unlock(v30);
    xpc_object_t v36 = 0;
    char v38 = 1;
    if (!v37) {
      goto LABEL_52;
    }
    goto LABEL_80;
  }
  if (v6)
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I No message dict. Disconnect", (uint8_t *)&buf, 2u);
  }
  sub_100BD9AC4(a1);
  return sub_100057D78(&cf);
}

void sub_100BD9744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, int a14, char a15, uint64_t a16, const void *a17, const void *a18, const void *a19, uint64_t a20,uint64_t a21,const void *a22,const void *a23,uint64_t a24,uint64_t a25,const void *a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,const void *a36,uint64_t a37,uint64_t a38,const void *a39,const void *a40)
{
  sub_100060644((void *)(v40 - 160));
  sub_100044D00(&a26);
  if (a35 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a36);
  if ((a15 & 1) == 0) {
    sub_10004D2C8(a13);
  }
  sub_10005717C(&a39);
  sub_100057D78(&a40);
  sub_1000558F4(&a22);
  sub_10005717C(&a23);
  sub_100057D78(&a17);
  sub_1000558F4(&a18);
  sub_100057D78(&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100BD9AC4(uint64_t a1)
{
  uint64_t v2 = a1 + 200;
  if (*(unsigned char *)(a1 + 200))
  {
    *(unsigned char *)(a1 + 200) = 0;
    uint64_t v3 = *(void *)(a1 + 192);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2);
    }
  }
  uint64_t v4 = *(unsigned __int8 *)(a1 + 143);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a1 + 128);
  }
  if (v4)
  {
    uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 112))(*(void *)(a1 + 64), a1 + 120);
    if (v5)
    {
      uint64_t v6 = v5;
      xpc_object_t v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a1 + 143) >= 0) {
          uint64_t v31 = a1 + 120;
        }
        else {
          uint64_t v31 = *(void *)(a1 + 120);
        }
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = v31;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v6;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to remove: %{public}s, error: %ld", buf, 0x16u);
      }
    }
  }
  if (*(void *)(a1 + 152)) {
    CFDictionaryRef v8 = sub_100289354;
  }
  else {
    CFDictionaryRef v8 = 0;
  }
  if (v8)
  {
    CFArrayRef v35 = 0;
    sub_100044D6C(&theArray, (CFTypeRef *)(a1 + 152));
    __p[0] = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      xpc_object_t v10 = __p[0];
      __p[0] = Mutable;
      *(void *)long long buf = v10;
      sub_1000440D4((const void **)buf);
    }
    if (theArray) {
      CFTypeID v11 = sub_100083F10;
    }
    else {
      CFTypeID v11 = 0;
    }
    if (v11)
    {
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
          CFDictionaryRef v15 = ValueAtIndex;
          if (ValueAtIndex)
          {
            CFTypeID v16 = CFGetTypeID(ValueAtIndex);
            if (v16 == CFDictionaryGetTypeID()) {
              CFDictionaryRef v17 = v15;
            }
            else {
              CFDictionaryRef v17 = 0;
            }
          }
          else
          {
            CFDictionaryRef v17 = 0;
          }
          CFStringRef Value = CFDictionaryGetValue(v17, @"LocalFilePath");
          xpc_object_t v19 = Value;
          if (Value)
          {
            CFTypeID v20 = CFGetTypeID(Value);
            if (v20 == CFStringGetTypeID()) {
              sub_1001C6B94((__CFArray *)__p[0], v19);
            }
          }
        }
      }
    }
    sub_100044D6C(&v35, (CFTypeRef *)__p);
    sub_1000440D4((const void **)__p);
    sub_100044D00((const void **)&theArray);
    if (v35) {
      uint64_t v21 = sub_100083F10;
    }
    else {
      uint64_t v21 = 0;
    }
    if (v21)
    {
      CFIndex v22 = CFArrayGetCount(v35);
      if (v22 >= 1)
      {
        for (CFIndex j = 0; j != v22; ++j)
        {
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v33 = 0;
          CFArrayGetValueAtIndex(v35, j);
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          *(_OWORD *)std::string __p = *(_OWORD *)buf;
          uint64_t v33 = *(void *)&buf[16];
          uint64_t v24 = *(void *)&buf[8];
          if ((buf[23] & 0x80u) == 0) {
            uint64_t v24 = buf[23];
          }
          if (v24)
          {
            uint64_t v25 = (*(uint64_t (**)(void, void **))(**(void **)(a1 + 64) + 112))(*(void *)(a1 + 64), __p);
            if (v25)
            {
              uint64_t v26 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                if (v33 >= 0) {
                  CFMutableDictionaryRef v27 = __p;
                }
                else {
                  CFMutableDictionaryRef v27 = (void **)__p[0];
                }
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v25;
                _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to remove: %{public}s, error: %ld", buf, 0x16u);
              }
            }
          }
          if (SHIBYTE(v33) < 0) {
            operator delete(__p[0]);
          }
        }
      }
    }
    sub_100044D00((const void **)&v35);
  }
  uint64_t v28 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  *(void *)long long buf = v28;
  sub_100044D00((const void **)buf);
  uint64_t v29 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = 0;
  *(void *)long long buf = v29;
  sub_1000440D4((const void **)buf);
  if (*(char *)(a1 + 143) < 0)
  {
    **(unsigned char **)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 120) = 0;
    *(unsigned char *)(a1 + 143) = 0;
  }
  *(_WORD *)(a1 + 112) = 0;
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 48))(*(void *)(a1 + 80));
}

void sub_100BD9F48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, const void *a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

const void **sub_100BD9FB4(CFNumberRef *a1, unsigned __int8 a2)
{
  CFNumberRef v6 = 0;
  unint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v3)
  {
    unint64_t v4 = (unint64_t)v6;
    CFNumberRef v6 = v3;
    unint64_t valuePtr = v4;
    sub_1000570E8((const void **)&valuePtr);
  }
  *a1 = v6;
  CFNumberRef v6 = 0;
  return sub_1000570E8((const void **)&v6);
}

void sub_100BDA028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_100BDA03C(std::string *a1, CFDictionaryRef *a2)
{
  CFDictionaryRef v4 = *a2;
  if (*a2) {
    uint64_t v5 = sub_100080778;
  }
  else {
    uint64_t v5 = 0;
  }
  CFNumberRef v6 = a1[1].__r_.__value_.__r.__words[2];
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received message from lockdown: %@", (uint8_t *)&buf, 0xCu);
      CFDictionaryRef v4 = *a2;
    }
    CFDictionaryGetValue(v4, @"messageName");
    long long buf = 0uLL;
    *(void *)&long long v104 = 0;
    ctu::cf::assign();
    long long __s1 = buf;
    uint64_t v101 = v104;
    CFStringRef Value = (int *)CFDictionaryGetValue(*a2, @"status");
    xpc_object_t v9 = Value;
    LODWORD(buf) = 0;
    if (Value)
    {
      CFTypeID v10 = CFGetTypeID(Value);
      if (v10 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)&buf, v9, v11);
      }
      int v12 = buf;
      if (buf)
      {
        char v13 = a1[1].__r_.__value_.__r.__words[2];
        uint64_t v14 = 0;
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_69;
        }
        LODWORD(buf) = 67109120;
        DWORD1(buf) = v12;
        CFDictionaryRef v15 = "#I Received an error status: %d. Disconnect.";
        CFTypeID v16 = v13;
        uint32_t v17 = 8;
        goto LABEL_65;
      }
    }
    long long buf = 0uLL;
    *(void *)&long long v104 = 0;
    ctu::cf::assign();
    uint64_t v99 = v104;
    *(_OWORD *)std::string __p = buf;
    if (v101 >= 0) {
      uint64_t v18 = (void *)HIBYTE(v101);
    }
    else {
      uint64_t v18 = (void *)*((void *)&__s1 + 1);
    }
    xpc_object_t v19 = (void *)HIBYTE(v99);
    int v20 = SHIBYTE(v99);
    if (v99 < 0) {
      xpc_object_t v19 = __p[1];
    }
    if (v18 != v19)
    {
      BOOL v30 = 0;
      if ((SHIBYTE(v99) & 0x80000000) == 0) {
        goto LABEL_38;
      }
      goto LABEL_35;
    }
    if (v99 >= 0) {
      uint64_t v21 = __p;
    }
    else {
      uint64_t v21 = (void **)__p[0];
    }
    if (v101 < 0)
    {
      BOOL v30 = memcmp((const void *)__s1, v21, *((size_t *)&__s1 + 1)) == 0;
    }
    else
    {
      if (!HIBYTE(v101))
      {
        BOOL v30 = 1;
        if ((SHIBYTE(v99) & 0x80000000) == 0)
        {
LABEL_38:
          uint64_t v31 = a1[1].__r_.__value_.__r.__words[2];
          BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
          if (!v30)
          {
            if (!v32)
            {
LABEL_68:
              uint64_t v14 = 0;
              goto LABEL_69;
            }
            p_s1 = &__s1;
            if (v101 < 0) {
              p_s1 = (long long *)__s1;
            }
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = p_s1;
            CFDictionaryRef v15 = "#I Unknown message %s";
            CFTypeID v16 = v31;
            uint32_t v17 = 12;
LABEL_65:
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)&buf, v17);
            goto LABEL_68;
          }
          if (v32)
          {
            uint64_t v33 = &__s1;
            if (v101 < 0) {
              uint64_t v33 = (long long *)__s1;
            }
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v33;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Received %s request", (uint8_t *)&buf, 0xCu);
          }
          CFNumberRef v34 = (const __CFNumber *)CFDictionaryGetValue(*a2, @"fileSize");
          CFNumberRef v35 = v34;
          if (!v34 || (CFTypeID v36 = CFGetTypeID(v34), v36 != CFNumberGetTypeID()))
          {
            uint64_t v48 = a1[1].__r_.__value_.__r.__words[2];
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Invalid file Size", (uint8_t *)&buf, 2u);
            }
            goto LABEL_68;
          }
          CFTypeRef cf = 0;
          *(void *)&long long buf = CFDictionaryGetValue(*a2, @"originalURL");
          sub_100056248(&cf, (CFTypeRef *)&buf);
          if (cf) {
            uint64_t v37 = sub_1000810B8;
          }
          else {
            uint64_t v37 = 0;
          }
          if (!v37)
          {
            BOOL v79 = a1[1].__r_.__value_.__r.__words[2];
            if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "Invalid original url", (uint8_t *)&buf, 2u);
            }
            uint64_t v14 = 0;
            goto LABEL_158;
          }
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v99 = 0;
          sub_100058DB0(__p, "");
          memset(&__str, 0, sizeof(__str));
          std::string::size_type v38 = a1[2].__r_.__value_.__r.__words[2];
          long long buf = 0uLL;
          *(void *)&long long v104 = 0;
          ctu::cf::assign();
          *(_OWORD *)&v95.__r_.__value_.__l.__data_ = buf;
          v95.__r_.__value_.__r.__words[2] = v104;
          (*(void (**)(std::string *__return_ptr, std::string::size_type, std::string *))(*(void *)v38 + 120))(&__str, v38, &v95);
          if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v95.__r_.__value_.__l.__data_);
          }
          std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          p_str = &__str;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          {
            std::string::size_type size = __str.__r_.__value_.__l.__size_;
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          if (size)
          {
            uint64_t v41 = (unsigned __int8 *)p_str + size;
            uint64_t v42 = p_str;
            char v43 = (std::string *)v41;
            do
            {
              CFMutableDictionaryRef v44 = v42;
              xpc_object_t v45 = (unsigned __int8 *)v42;
              while (1)
              {
                int v46 = *v45++;
                if (v46 == 46) {
                  break;
                }
                CFMutableDictionaryRef v44 = (std::string *)v45;
                if (v45 == v41)
                {
                  CFMutableDictionaryRef v44 = v43;
                  goto LABEL_74;
                }
              }
              uint64_t v42 = (std::string *)((char *)&v44->__r_.__value_.__l.__data_ + 1);
              char v43 = v44;
            }
            while (v45 != v41);
LABEL_74:
            if (v44 != (std::string *)v41 && (char *)v44 - (char *)p_str != -1)
            {
              std::string::basic_string((std::string *)&buf, &__str, (char *)v44 - (char *)p_str, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v95);
              if (SHIBYTE(v99) < 0) {
                operator delete(__p[0]);
              }
              uint64_t v99 = v104;
              *(_OWORD *)std::string __p = buf;
              if ((SBYTE7(v104) & 0x80u) == 0) {
                xpc_object_t v50 = (void **)((char *)__p + BYTE7(v104));
              }
              else {
                xpc_object_t v50 = (void **)((char *)__p[0] + (unint64_t)__p[1]);
              }
              if ((SBYTE7(v104) & 0x80u) == 0) {
                std::string::size_type v51 = __p;
              }
              else {
                std::string::size_type v51 = (void **)__p[0];
              }
              while (v51 != v50)
              {
                *(unsigned char *)std::string::size_type v51 = __tolower(*(char *)v51);
                std::string::size_type v51 = (void **)((char *)v51 + 1);
              }
            }
          }
          uint64_t v52 = (void *)HIBYTE(v99);
          if (v99 < 0) {
            uint64_t v52 = __p[1];
          }
          if (v52 == (void *)5)
          {
            xpc_object_t v53 = __p;
            if (v99 < 0) {
              xpc_object_t v53 = (void **)__p[0];
            }
            int v54 = *(_DWORD *)v53;
            int v55 = *((unsigned __int8 *)v53 + 4);
            if (v54 == 1668311342 && v55 == 99)
            {
              CFTypeRef v94 = cf;
              if (cf) {
                CFRetain(cf);
              }
              BOOL v57 = sub_100BDB01C((uint64_t)a1, &v94);
              sub_1000558F4(&v94);
              if (!v57)
              {
                uint64_t v84 = a1[1].__r_.__value_.__r.__words[2];
                if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(buf) = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "Filename not part of the expected urls.", (uint8_t *)&buf, 2u);
                }
                uint64_t v14 = 0;
                goto LABEL_154;
              }
            }
          }
          memset(&v95, 0, sizeof(v95));
          WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
          char v59 = (std::string *)sub_100058DB0(v106, WirelessUserDirectory);
          xpc_object_t v60 = std::string::append(v59, "/Library/", 9uLL);
          long long v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
          v93.__r_.__value_.__r.__words[2] = v60->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v93.__r_.__value_.__l.__data_ = v61;
          v60->__r_.__value_.__l.__size_ = 0;
          v60->__r_.__value_.__r.__words[2] = 0;
          v60->__r_.__value_.__r.__words[0] = 0;
          generateUUIDForIPCC(valuePtr);
          if ((v92 & 0x80u) == 0) {
            uint64_t v62 = valuePtr;
          }
          else {
            uint64_t v62 = (void **)valuePtr[0];
          }
          if ((v92 & 0x80u) == 0) {
            std::string::size_type v63 = v92;
          }
          else {
            std::string::size_type v63 = (std::string::size_type)valuePtr[1];
          }
          uint64_t v64 = std::string::append(&v93, (const std::string::value_type *)v62, v63);
          long long v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
          *(void *)&long long v104 = *((void *)&v64->__r_.__value_.__l + 2);
          long long buf = v65;
          v64->__r_.__value_.__l.__size_ = 0;
          v64->__r_.__value_.__r.__words[2] = 0;
          v64->__r_.__value_.__r.__words[0] = 0;
          if (v99 >= 0) {
            char v66 = __p;
          }
          else {
            char v66 = (void **)__p[0];
          }
          if (v99 >= 0) {
            std::string::size_type v67 = HIBYTE(v99);
          }
          else {
            std::string::size_type v67 = (std::string::size_type)__p[1];
          }
          long long v68 = std::string::append((std::string *)&buf, (const std::string::value_type *)v66, v67);
          long long v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
          v95.__r_.__value_.__r.__words[2] = v68->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v69;
          v68->__r_.__value_.__l.__size_ = 0;
          v68->__r_.__value_.__r.__words[2] = 0;
          v68->__r_.__value_.__r.__words[0] = 0;
          if (SBYTE7(v104) < 0) {
            operator delete((void *)buf);
          }
          if ((char)v92 < 0) {
            operator delete(valuePtr[0]);
          }
          if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v93.__r_.__value_.__l.__data_);
          }
          if (v107 < 0) {
            operator delete(*(void **)v106);
          }
          std::string::size_type v70 = a1[3].__r_.__value_.__l.__size_;
          v93.__r_.__value_.__r.__words[0] = 0;
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (Mutable)
          {
            std::string::size_type v72 = v93.__r_.__value_.__r.__words[0];
            v93.__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
            *(void *)&long long buf = v72;
            sub_10005717C((const void **)&buf);
          }
          sub_100BD9FB4((CFNumberRef *)&buf, 0);
          sub_10069637C((__CFDictionary *)v93.__r_.__value_.__l.__data_, @"status", buf);
          sub_1000570E8((const void **)&buf);
          sub_10004EFE4(&v90, (CFTypeRef *)&v93.__r_.__value_.__l.__data_);
          sub_10005717C((const void **)&v93.__r_.__value_.__l.__data_);
          char v73 = (*(uint64_t (**)(std::string::size_type, const void **))(*(void *)v70 + 32))(v70, &v90);
          sub_100057D78(&v90);
          if ((v73 & 1) == 0)
          {
            CFDateRef v80 = a1[1].__r_.__value_.__r.__words[2];
            if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "Couldn't send file transfer ack. Disconnect.", (uint8_t *)&buf, 2u);
            }
            uint64_t v14 = 0;
            goto LABEL_152;
          }
          long long v104 = 0u;
          long long v105 = 0u;
          long long buf = 0u;
          uint64_t v74 = (void *)a1[1].__r_.__value_.__r.__words[2];
          v93.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
          v93.__r_.__value_.__l.__size_ = (std::string::size_type)&v95;
          os_signpost_id_t v75 = sub_100BDB694(&v93);
          sub_100BDB5E4(&buf, v74, v75);
          *(_OWORD *)&v93.__r_.__value_.__l.__data_ = 0uLL;
          sub_100058DB0(&v88, "Receive data from desktop host");
          sub_100BDB770(v102, &buf);
          Registry::createXpcJetsamAssertion();
          sub_1000339DC(v102);
          if (v89 < 0) {
            operator delete(v88);
          }
          valuePtr[0] = 0;
          CFNumberGetValue(v35, kCFNumberCFIndexType, valuePtr);
          int v87 = 0;
          (*(void (**)(const void **__return_ptr))(*(void *)a1[3].__r_.__value_.__l.__size_ + 40))(&v87);
          if (v87) {
            CFDictionaryRef v76 = sub_10008324C;
          }
          else {
            CFDictionaryRef v76 = 0;
          }
          if (v76)
          {
            if (((*(uint64_t (**)(std::string::size_type, std::string *))(*(void *)a1[2].__r_.__value_.__r.__words[2]
                                                                                   + 200))(a1[2].__r_.__value_.__r.__words[2], &v95) & 1) != 0)
            {
              uint64_t v77 = v87;
              int v87 = 0;
              *(void *)uint64_t v106 = v77;
              sub_100030068((const void **)v106);
              unsigned int v78 = (std::__shared_weak_count *)v93.__r_.__value_.__l.__size_;
              *(_OWORD *)&v93.__r_.__value_.__l.__data_ = 0uLL;
              if (v78) {
                sub_10004D2C8(v78);
              }
              if (sub_1002E6B08((const void **)__p, ".ipcc"))
              {
                sub_100083DA4(&v86, &cf);
                sub_100BDB7C4((uint64_t)a1, &v86, (uint64_t)&v95);
                sub_1000558F4(&v86);
              }
              else
              {
                std::string::operator=(a1 + 5, &v95);
              }
              uint64_t v14 = 1;
              goto LABEL_149;
            }
            int v82 = a1[1].__r_.__value_.__r.__words[2];
            if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
            {
              uint64_t v85 = &v95;
              if ((v95.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                uint64_t v85 = (std::string *)v95.__r_.__value_.__r.__words[0];
              }
              *(_DWORD *)uint64_t v106 = 136446210;
              *(void *)&void v106[4] = v85;
              _os_log_error_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_ERROR, "Failed to write file: %{public}s", v106, 0xCu);
            }
            uint64_t v83 = v87;
            int v87 = 0;
            *(void *)uint64_t v106 = v83;
            sub_100030068((const void **)v106);
          }
          else
          {
            CFDateRef v81 = a1[1].__r_.__value_.__r.__words[2];
            if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t v106 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "Invalid data ref", v106, 2u);
            }
          }
          uint64_t v14 = 0;
LABEL_149:
          sub_100030068(&v87);
          if (v93.__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)v93.__r_.__value_.__l.__size_);
          }
          sub_1000339DC((uint64_t *)&buf);
LABEL_152:
          if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v95.__r_.__value_.__l.__data_);
          }
LABEL_154:
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v99) < 0) {
            operator delete(__p[0]);
          }
LABEL_158:
          sub_1000558F4(&cf);
LABEL_69:
          if (SHIBYTE(v101) < 0) {
            operator delete((void *)__s1);
          }
          return v14;
        }
LABEL_35:
        operator delete(__p[0]);
        goto LABEL_38;
      }
      uint64_t v22 = HIBYTE(v101) - 1;
      uint64_t v23 = &__s1;
      do
      {
        int v25 = *(unsigned __int8 *)v23;
        uint64_t v23 = (long long *)((char *)v23 + 1);
        int v24 = v25;
        int v27 = *(unsigned __int8 *)v21;
        uint64_t v21 = (void **)((char *)v21 + 1);
        int v26 = v27;
        BOOL v29 = v22-- != 0;
        BOOL v30 = v24 == v26;
      }
      while (v24 == v26 && v29);
    }
    if ((v20 & 0x80000000) == 0) {
      goto LABEL_38;
    }
    goto LABEL_35;
  }
  if (v7)
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Invalid request. Disconnect.", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_100BDAB8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,std::__shared_weak_count *a26,int a27,__int16 a28,char a29,char a30,char a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,const void *a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,uint64_t a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  sub_1000558F4(&a10);
  sub_100030068(&a11);
  if (a26) {
    sub_10004D2C8(a26);
  }
  sub_1000339DC((uint64_t *)(v58 - 128));
  if (a37 < 0) {
    operator delete(__p);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  sub_1000558F4(&a45);
  if (a58 < 0) {
    operator delete(a53);
  }
  _Unwind_Resume(a1);
}

const void **sub_100BDAD80(uint64_t a1, int a2)
{
  int v4 = rand();
  if (a2 == 3) {
    double v5 = CFAbsoluteTimeGetCurrent() + (double)(v4 % 24 + 1) * 3600.0;
  }
  else {
    double v5 = CFAbsoluteTimeGetCurrent() + (double)(v4 % 7 + 8) * 86400.0;
  }
  CFDateRef v6 = CFDateCreate(kCFAllocatorDefault, v5);
  CFDateRef v20 = v6;
  BOOL v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138543362;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Saving the next update check at %{public}@", buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(a1 + 48));
  CFTypeID v10 = ServiceMap;
  if (v11 < 0)
  {
    int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v11;
  CFDictionaryRef v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_14:
    std::mutex::unlock(v10);
    CFTypeID v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v17 = v15[3];
  CFTypeID v16 = (std::__shared_weak_count *)v15[4];
  if (!v16) {
    goto LABEL_14;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
  if (v17) {
LABEL_15:
  }
    (*(void (**)(uint64_t, const __CFString *, CFDateRef, void, const CFStringRef, const CFStringRef))(*(void *)v17 + 16))(v17, @"kNextDesktopHostCarrierBundleUpdateCheck", v20, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
LABEL_16:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  return sub_10007CA64((const void **)&v20);
}

void sub_100BDAFE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  char v4 = v2;
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  sub_10007CA64((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100BDB01C(uint64_t a1, CFTypeRef *a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 144));
  if (Count < 1) {
    return 0;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  BOOL v7 = 1;
  while (1)
  {
    CFDictionaryRef theDict = 0;
    *(void *)long long buf = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), v6);
    sub_10004EFE4(&theDict, (CFTypeRef *)buf);
    CFStringRef Value = CFDictionaryGetValue(theDict, @"BundleURL");
    xpc_object_t v9 = Value;
    if (Value)
    {
      CFTypeID v10 = CFGetTypeID(Value);
      uint64_t v11 = v10 == CFStringGetTypeID() ? v9 : 0;
    }
    else
    {
      uint64_t v11 = 0;
    }
    if (CFEqual(v11, *a2)) {
      break;
    }
    sub_100057D78((const void **)&theDict);
    BOOL v7 = ++v6 < v5;
    if (v5 == v6) {
      return v7;
    }
  }
  CFDictionaryRef v30 = theDict;
  if (theDict) {
    CFRetain(theDict);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)(a1 + 48));
  unsigned int v14 = ServiceMap;
  if (v15 < 0)
  {
    CFTypeID v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v15;
  xpc_object_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
  if (v19)
  {
    uint64_t v21 = v19[3];
    CFDateRef v20 = (std::__shared_weak_count *)v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v22 = 0;
      if (!v21) {
        goto LABEL_55;
      }
LABEL_23:
      uint64_t v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Submitting metric on desktop update check", buf, 2u);
      }
      xpc_object_t v44 = 0;
      xpc_object_t v24 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v25 = v24;
      if (v24)
      {
        xpc_object_t v44 = v24;
      }
      else
      {
        xpc_object_t v25 = xpc_null_create();
        xpc_object_t v44 = v25;
        if (!v25)
        {
          xpc_object_t v26 = xpc_null_create();
          xpc_object_t v25 = 0;
          goto LABEL_32;
        }
      }
      if (xpc_get_type(v25) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v25);
LABEL_33:
        xpc_release(v25);
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v43 = 0;
        CFDictionaryGetValue(v30, @"BundleID");
        memset(buf, 0, sizeof(buf));
        uint64_t v46 = 0;
        ctu::cf::assign();
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v43 = v46;
        if (v46 >= 0) {
          int v27 = __p;
        }
        else {
          int v27 = (void **)__p[0];
        }
        xpc_object_t v40 = xpc_string_create((const char *)v27);
        if (!v40) {
          xpc_object_t v40 = xpc_null_create();
        }
        *(void *)long long buf = &v44;
        *(void *)&uint8_t buf[8] = "bundle_update_check_info_bundle_name_to_check";
        sub_100035E70((uint64_t)buf, &v40, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v40);
        xpc_object_t v40 = 0;
        xpc_object_t v38 = xpc_BOOL_create(1);
        if (!v38) {
          xpc_object_t v38 = xpc_null_create();
        }
        *(void *)long long buf = &v44;
        *(void *)&uint8_t buf[8] = "is_desktop_host";
        sub_100035E70((uint64_t)buf, &v38, &v39);
        xpc_release(v39);
        xpc_object_t v39 = 0;
        xpc_release(v38);
        xpc_object_t v38 = 0;
        if (*(unsigned char *)(a1 + 113)) {
          int64_t v28 = 9;
        }
        else {
          int64_t v28 = 10;
        }
        xpc_object_t v36 = xpc_int64_create(v28);
        if (!v36) {
          xpc_object_t v36 = xpc_null_create();
        }
        *(void *)long long buf = &v44;
        *(void *)&uint8_t buf[8] = "update_check_trigger";
        sub_100035E70((uint64_t)buf, &v36, &v37);
        xpc_release(v37);
        xpc_object_t v37 = 0;
        xpc_release(v36);
        xpc_object_t v36 = 0;
        xpc_object_t v34 = xpc_BOOL_create(*(unsigned char *)(a1 + 112));
        if (!v34) {
          xpc_object_t v34 = xpc_null_create();
        }
        *(void *)long long buf = &v44;
        *(void *)&uint8_t buf[8] = "is_store_activation_mode_enabled_on_desktop";
        sub_100035E70((uint64_t)buf, &v34, &v35);
        xpc_release(v35);
        xpc_object_t v35 = 0;
        xpc_release(v34);
        xpc_object_t v34 = 0;
        xpc_object_t v32 = xpc_BOOL_create(*(_DWORD *)(a1 + 160) == 1);
        if (!v32) {
          xpc_object_t v32 = xpc_null_create();
        }
        *(void *)long long buf = &v44;
        *(void *)&uint8_t buf[8] = "bundle_update_check_info_is_buddy_active";
        sub_100035E70((uint64_t)buf, &v32, &v33);
        xpc_release(v33);
        xpc_object_t v33 = 0;
        xpc_release(v32);
        xpc_object_t v32 = 0;
        *(void *)long long buf = v44;
        if (v44) {
          xpc_retain(v44);
        }
        else {
          *(void *)long long buf = xpc_null_create();
        }
        (*(void (**)(uint64_t, const char *, uint8_t *))(*(void *)v21 + 16))(v21, "commCenterBundleUpdateCheck", buf);
        xpc_release(*(xpc_object_t *)buf);
        *(void *)long long buf = 0;
        if (SHIBYTE(v43) < 0) {
          operator delete(__p[0]);
        }
        xpc_release(v44);
        goto LABEL_55;
      }
      xpc_object_t v26 = xpc_null_create();
LABEL_32:
      xpc_object_t v44 = v26;
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v14);
  CFDateRef v20 = 0;
  char v22 = 1;
  if (v21) {
    goto LABEL_23;
  }
LABEL_55:
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  sub_100057D78((const void **)&v30);
  sub_100057D78((const void **)&theDict);
  return v7;
}

void sub_100BDB510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  xpc_release(*(xpc_object_t *)(v28 - 96));
  *(void *)(v28 - 96) = 0;
  if (a26 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v28 - 104));
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  sub_100057D78((const void **)&a9);
  sub_100057D78(&a10);
  _Unwind_Resume(a1);
}

void *sub_100BDB5E4(void *a1, void *object, uint64_t a3)
{
  v5[0] = off_101A454D8;
  v5[3] = v5;
  *a1 = a3;
  a1[1] = os_retain(object);
  sub_1000336E8((uint64_t)(a1 + 2), (uint64_t)v5);
  return sub_100033A10(v5);
}

void sub_100BDB680(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100033A10((uint64_t *)va);
  _Unwind_Resume(a1);
}

os_signpost_id_t sub_100BDB694(void *a1)
{
  uint64_t v2 = *a1;
  os_signpost_id_t v3 = os_signpost_id_generate(*(os_log_t *)(*a1 + 40));
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v4 = *(NSObject **)(v2 + 40);
    if (os_signpost_enabled(v4))
    {
      CFIndex v5 = (uint64_t *)a1[1];
      if (*((char *)v5 + 23) < 0) {
        CFIndex v5 = (uint64_t *)*v5;
      }
      int v7 = 136315138;
      CFDictionaryRef v8 = v5;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "Receive data from desktop host", "path=%{signpost.description:attribute}s", (uint8_t *)&v7, 0xCu);
    }
  }
  return v3;
}

void *sub_100BDB770(void *a1, void *a2)
{
  uint64_t v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  CFIndex v5 = a2 + 2;
  sub_1000336E8((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  *a2 = 0;
  a2[1] = 0;
  sub_100033AF4(v5);
  return a1;
}

uint64_t sub_100BDB7C4(uint64_t result, CFTypeRef *a2, uint64_t a3)
{
  if (*a2) {
    os_signpost_id_t v3 = sub_1000810B8;
  }
  else {
    os_signpost_id_t v3 = 0;
  }
  if (v3)
  {
    uint64_t v5 = *(unsigned __int8 *)(a3 + 23);
    if ((v5 & 0x80u) != 0) {
      uint64_t v5 = *(void *)(a3 + 8);
    }
    if (v5)
    {
      uint64_t v7 = result;
      uint64_t result = CFArrayGetCount(*(CFArrayRef *)(result + 144));
      if (result >= 1)
      {
        uint64_t v8 = result;
        for (CFIndex i = 0; i != v8; ++i)
        {
          CFDictionaryRef theDict = 0;
          __p[0] = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 144), i);
          sub_10004EFE4(&theDict, (CFTypeRef *)__p);
          CFTypeID v10 = CFDictionaryGetValue(theDict, @"BundleURL");
          uint64_t v11 = v10;
          if (v10)
          {
            CFTypeID v12 = CFGetTypeID(v10);
            if (v12 == CFStringGetTypeID()) {
              uint64_t v13 = v11;
            }
            else {
              uint64_t v13 = 0;
            }
          }
          else
          {
            uint64_t v13 = 0;
          }
          if (CFEqual(v13, *a2))
          {
            CFTypeRef cf = 0;
            CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
            CFTypeRef cf = MutableCopy;
            if (*(char *)(a3 + 23) < 0)
            {
              sub_10004FC84(v16, *(void **)a3, *(void *)(a3 + 8));
            }
            else
            {
              *(_OWORD *)CFTypeID v16 = *(_OWORD *)a3;
              uint64_t v17 = *(void *)(a3 + 16);
            }
            if (SHIBYTE(v17) < 0)
            {
              sub_10004FC84(__dst, v16[0], (unint64_t)v16[1]);
            }
            else
            {
              *(_OWORD *)long long __dst = *(_OWORD *)v16;
              uint64_t v23 = v17;
            }
            uint64_t v21 = 0;
            if (SHIBYTE(v23) < 0)
            {
              sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
            }
            else
            {
              *(_OWORD *)std::string __p = *(_OWORD *)__dst;
              uint64_t v25 = v23;
            }
            xpc_object_t v26 = 0;
            if (ctu::cf::convert_copy())
            {
              uint64_t v15 = v21;
              uint64_t v21 = v26;
              char v27 = v15;
              sub_1000558F4(&v27);
            }
            if (SHIBYTE(v25) < 0) {
              operator delete(__p[0]);
            }
            CFPropertyListRef value = v21;
            uint64_t v21 = 0;
            sub_1000558F4((const void **)&v21);
            if (SHIBYTE(v23) < 0) {
              operator delete(__dst[0]);
            }
            CFDictionarySetValue(MutableCopy, @"LocalFilePath", value);
            sub_1000558F4((const void **)&value);
            if (SHIBYTE(v17) < 0) {
              operator delete(v16[0]);
            }
            sub_100699750(*(__CFArray **)(v7 + 152), cf);
            sub_10005717C(&cf);
          }
          uint64_t result = (uint64_t)sub_100057D78((const void **)&theDict);
        }
      }
    }
  }
  return result;
}

void sub_100BDBA38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, const void *a19, const void *a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10005717C(&a18);
  sub_100057D78(&a19);
  _Unwind_Resume(a1);
}

void sub_100BDBAC8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BDBB00(uint64_t a1)
{
}

uint64_t sub_100BDBB1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BDBB60(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100BDBB8C(ServiceManager::Service *this)
{
  *(void *)this = off_101A452D8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100BDBBE8(ServiceManager::Service *this)
{
  *(void *)this = off_101A452D8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100BDBC58@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CarrierBundleDesktopHostUpdateServiceHandler");
}

unsigned char *sub_100BDBC68@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100BDBCA8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  os_signpost_id_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100BD7EE8(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100BD7EE8(v4, 0);
}

uint64_t sub_100BDBD2C()
{
  return 0;
}

uint64_t sub_100BDBD34()
{
  return 1;
}

uint64_t sub_100BDBD3C()
{
  return 0;
}

void sub_100BDBD48(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100BDBE28(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)(a1 + 8) + 96));
}

uint64_t *sub_100BDBE34(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(*(void *)v1 + 48));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100664E98(v2 + 160);
  v9[0] = off_101A45358;
  v9[1] = v2 + 96;
  void v9[3] = v9;
  sub_100318874(v9, (void *)(v2 + 168));
  sub_10030AB98(v9);
  uint64_t v3 = *(void *)(v2 + 192);
  if (v3) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 200);
  }
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100BDBF3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100BDBF70()
{
}

void *sub_100BDBF84(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A45358;
  result[1] = v3;
  return result;
}

uint64_t sub_100BDBFCC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A45358;
  a2[1] = v2;
  return result;
}

void sub_100BDBFF8(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/desktop_update_status");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100BDC0A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100BDC0F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BDC130()
{
}

void sub_100BDC13C(void **a1)
{
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[10];
  if (v2)
  {
    uint64_t v3 = v1[3];
    dispatch_object_t object = v3;
    if (v3) {
      dispatch_retain(v3);
    }
    *(void *)long long buf = off_101A453D8;
    uint64_t v7 = v1;
    uint64_t v8 = buf;
    (*(void (**)(uint64_t, dispatch_object_t *, uint8_t *))(*(void *)v2 + 16))(v2, &object, buf);
    sub_10003B34C(buf);
    if (object) {
      dispatch_release(object);
    }
  }
  else
  {
    uint64_t v4 = v1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Invalid lockdown helper.", buf, 2u);
    }
  }
  operator delete();
}

void sub_100BDC284(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11)
{
  if (object) {
    dispatch_release(object);
  }
  operator delete();
}

void sub_100BDC2C8()
{
}

void *sub_100BDC2DC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A453D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100BDC324(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A453D8;
  a2[1] = v2;
  return result;
}

const void **sub_100BDC350(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received connection from lockdown.", v4, 2u);
  }
  return sub_100BD7FE8(v1);
}

uint64_t sub_100BDC3BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BDC3FC()
{
}

const void **sub_100BDC408(__CFDictionary *a1, const void *a2)
{
  key = @"status";
  CFRetain(@"status");
  char v5 = a2;
  if (a2)
  {
    CFRetain(a2);
    if (key) {
      CFDictionarySetValue(a1, key, a2);
    }
  }
  sub_10010F494(&v5);
  return sub_10010F494((const void **)&key);
}

void sub_100BDC478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_100BDC4A0()
{
}

void *sub_100BDC4B4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A45458;
  result[1] = v3;
  return result;
}

uint64_t sub_100BDC4FC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A45458;
  a2[1] = v2;
  return result;
}

const void **sub_100BDC528(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v11 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(v3 + 80) + 24))(&v11);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received message from lockdown: %@", buf, 0xCu);
    uint64_t v4 = *(NSObject **)(v3 + 40);
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Bundle updates complete. End.", buf, 2u);
  }
  *(void *)CFTypeID v10 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v6 = *(__CFDictionary **)v10;
    *(void *)CFTypeID v10 = Mutable;
    *(void *)long long buf = v6;
    sub_10005717C((const void **)buf);
  }
  sub_100BD9FB4((CFNumberRef *)buf, 1u);
  sub_10069637C(*(__CFDictionary **)v10, @"status", *(uint64_t *)buf);
  sub_1000570E8((const void **)buf);
  uint64_t v7 = *(void *)(v3 + 80);
  sub_10004EFE4(buf, (CFTypeRef *)v10);
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v7 + 32))(v7, buf);
  sub_100057D78((const void **)buf);
  sub_100BD9AC4(v3);
  if (v2) {
    int v8 = 2;
  }
  else {
    int v8 = 3;
  }
  sub_100BDAD80(v3, v8);
  sub_10005717C((const void **)v10);
  return sub_100057D78(&v11);
}

void sub_100BDC720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, const void *a11)
{
}

uint64_t sub_100BDC768(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BDC7A8()
{
}

void sub_100BDC7B8()
{
}

void *sub_100BDC7CC()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A454D8;
  return result;
}

void sub_100BDC804(uint64_t a1, void *a2)
{
  *a2 = off_101A454D8;
}

void sub_100BDC82C(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)char v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "Receive data from desktop host", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_100BDC8A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BDC8E4()
{
}

void sub_100BDC8F0(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100BDC9CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v13) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BDCA0C(uint64_t a1, NSObject **a2, void *a3)
{
  uint64_t v6 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "pp.push.observer");
  sub_100BDCAD4(v6, a2, &v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *(void *)a1 = &off_101A45558;
  *(void *)(a1 + 48) = *a3;
  uint64_t v7 = a3[1];
  *(void *)(a1 + 56) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 64) = 0;
  return a1;
}

void sub_100BDCAC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100BDCAD4(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  char v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100BDCB3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

push::PushMessageListenerInterface *sub_100BDCB60(push::PushMessageListenerInterface *this)
{
  *(void *)this = &off_101A45558;
  int v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  push::PushMessageListenerInterface::~PushMessageListenerInterface(this);
  ctu::OsLogLogger::~OsLogLogger((push::PushMessageListenerInterface *)((char *)this + 40));
  sub_100087E88((void *)this + 1);
  return this;
}

void sub_100BDCBCC(push::PushMessageListenerInterface *a1)
{
  sub_100BDCB60(a1);

  operator delete();
}

void sub_100BDCC04(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BDCCF4(uint64_t a1, const void **a2)
{
  sub_100083DA4((const void **)&v4 + 1, a2);
  os_signpost_id_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BDCE00(uint64_t a1, const void **a2, const void **a3)
{
  sub_10002FD9C((const void **)&v6 + 1, a2);
  sub_100083DA4(&v7, a3);
  char v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BDCF30(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BDD010(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100BDD0DC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100BDD1B4);
  __cxa_rethrow();
}

void sub_100BDD104(_Unwind_Exception *a1)
{
}

void sub_100BDD11C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BDD154(uint64_t a1)
{
}

uint64_t sub_100BDD170(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BDD1B4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100BDD1E0(uint64_t **a1)
{
  CFTypeID v16 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  pthread_mutex_lock(&stru_101B09E48);
  os_signpost_id_t v3 = (void *)off_101B09E88;
  if (!off_101B09E88) {
    sub_1012D6D0C(buf);
  }
  long long v4 = (std::__shared_weak_count *)*(&off_101B09E88 + 1);
  if (*(&off_101B09E88 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_101B09E88 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_101B09E48);
  CFStringRef v5 = @"com.apple.OutOfBandCellularActivation";
  CFStringRef v20 = @"com.apple.OutOfBandCellularActivation";
  CFRetain(@"com.apple.OutOfBandCellularActivation");
  long long v6 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "development";
    if (!*(unsigned char *)(v2 + 64)) {
      uint64_t v7 = "production";
    }
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = @"com.apple.OutOfBandCellularActivation";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I register for topic %@ with %s environment", buf, 0x16u);
  }
  sub_1012D75D8(v3, *(unsigned char *)(v2 + 64));
  if (*((unsigned char *)v1 + 8))
  {
    CFStringRef v18 = @"com.apple.OutOfBandCellularActivation";
  }
  else
  {
    CFStringRef v19 = @"com.apple.OutOfBandCellularActivation";
    CFRetain(@"com.apple.OutOfBandCellularActivation");
    int v8 = *(std::__shared_weak_count **)(v2 + 16);
    if (!v8 || (uint64_t v9 = *(void *)(v2 + 8), (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v11 = v10;
    *(void *)long long buf = v9;
    *(void *)&uint8_t buf[8] = v10;
    sub_1012D8040(v3, (const void **)&v19, (uint64_t)buf);
    sub_10004D2C8(v11);
    sub_1000558F4((const void **)&v19);
    CFStringRef v5 = v20;
    CFStringRef v18 = v20;
    if (!v20)
    {
LABEL_15:
      CFTypeID v12 = *(std::__shared_weak_count **)(v2 + 16);
      if (v12)
      {
        uint64_t v13 = *(void *)(v2 + 8);
        unsigned int v14 = std::__shared_weak_count::lock(v12);
        if (v14)
        {
          uint64_t v15 = v14;
          v17[0] = v13;
          v17[1] = v14;
          sub_1012D7700(v3, (const void **)&v18, (uint64_t)v17);
          sub_10004D2C8(v15);
          sub_1000558F4((const void **)&v18);
          sub_1000558F4((const void **)&v20);
          if (v4) {
            sub_10004D2C8(v4);
          }
          operator delete();
        }
      }
      sub_100088B9C();
    }
  }
  CFRetain(v5);
  goto LABEL_15;
}

void sub_100BDD43C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100BDD4CC(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v11 = a1;
  CFTypeID v12 = v1;
  os_signpost_id_t v3 = (void *)*v1;
  uint64_t v2 = (const void *)v1[1];
  if (v2) {
    long long v4 = sub_1000810B8;
  }
  else {
    long long v4 = 0;
  }
  if (v4)
  {
    if (CFEqual(v2, @"com.apple.OutOfBandCellularActivation"))
    {
      CFStringRef v5 = (std::__shared_weak_count *)v3[7];
      if (v5)
      {
        long long v6 = std::__shared_weak_count::lock(v5);
        if (v6)
        {
          uint64_t v7 = v6;
          uint64_t v8 = v3[6];
          if (v8) {
            (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
          }
          sub_10004D2C8(v7);
        }
      }
    }
  }
  else
  {
    uint64_t v9 = v3[5];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No topic in the push message", buf, 2u);
    }
  }
  sub_100BDD5F0((uint64_t *)&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100BDD5C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100BDD5F0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BDD5F0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1000558F4((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_100BDD640(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFStringRef v19 = a1;
  uint64_t v20 = v1;
  uint64_t v2 = *(void **)v1;
  if (*(void *)(v1 + 16)) {
    os_signpost_id_t v3 = sub_1000810B8;
  }
  else {
    os_signpost_id_t v3 = 0;
  }
  if (v3 && (*(void *)(v1 + 8) ? (long long v4 = sub_10008324C) : (long long v4 = 0), v4))
  {
    memset(buf, 0, sizeof(buf));
    uint64_t v28 = 0;
    ctu::cf::assign();
    *(_OWORD *)uint64_t v23 = 0u;
    uint64_t v24 = 0;
    CFStringRef v5 = v2[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      long long v6 = v23;
      if (v24 < 0) {
        long long v6 = (void **)v23[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I push token for topic: %s", buf, 0xCu);
    }
    if (CFEqual(*(CFTypeRef *)(v1 + 16), @"com.apple.OutOfBandCellularActivation"))
    {
      uint64_t v7 = (std::__shared_weak_count *)v2[7];
      if (v7)
      {
        uint64_t v8 = std::__shared_weak_count::lock(v7);
        if (v8)
        {
          uint64_t v9 = v8;
          uint64_t v10 = v2[6];
          if (v10)
          {
            uint64_t v28 = 0;
            memset(buf, 0, sizeof(buf));
            BytePtr = (char *)CFDataGetBytePtr(*(CFDataRef *)(v1 + 8));
            CFIndex Length = CFDataGetLength(*(CFDataRef *)(v1 + 8));
            sub_10006E4A8(buf, BytePtr, &BytePtr[Length], Length);
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v22 = 0;
            ctu::hex();
            uint64_t v13 = v2[5];
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v14 = __p;
              if (v22 < 0) {
                unsigned int v14 = (void **)__p[0];
              }
              *(_DWORD *)long long __dst = 136315138;
              *(void *)&__dst[4] = v14;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I activation push token received: %s", __dst, 0xCu);
            }
            if (SHIBYTE(v22) < 0)
            {
              sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
            }
            else
            {
              *(_OWORD *)long long __dst = *(_OWORD *)__p;
              uint64_t v26 = v22;
            }
            (*(void (**)(uint64_t, uint8_t *))(*(void *)v10 + 16))(v10, __dst);
            if (SHIBYTE(v26) < 0) {
              operator delete(*(void **)__dst);
            }
            if (SHIBYTE(v22) < 0) {
              operator delete(__p[0]);
            }
            if (*(void *)buf)
            {
              *(void *)&uint8_t buf[8] = *(void *)buf;
              operator delete(*(void **)buf);
            }
          }
          sub_10004D2C8(v9);
        }
      }
    }
    else
    {
      CFTypeID v16 = v2[5];
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        uint64_t v17 = v23;
        if (v24 < 0) {
          uint64_t v17 = (void **)v23[0];
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v17;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Topic mismatch for activation push token [%s]", buf, 0xCu);
      }
    }
    if (SHIBYTE(v24) < 0) {
      operator delete(v23[0]);
    }
  }
  else
  {
    uint64_t v15 = v2[5];
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No token in activation push token handler", buf, 2u);
    }
  }
  sub_100BDDA20(&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_100BDD98C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  xpc_object_t v33 = *(void **)(v31 - 80);
  if (v33)
  {
    *(void *)(v31 - 72) = v33;
    operator delete(v33);
  }
  sub_10004D2C8(v30);
  if (a23 < 0) {
    operator delete(a18);
  }
  sub_100BDDA20(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BDDA20(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1000558F4((const void **)(v1 + 16));
    sub_100030068((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_100BDDA78(uint64_t **a1)
{
  os_signpost_id_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I public token updated", buf, 2u);
  }
  sub_100BDCC04(v1);
}

uint64_t sub_100BDDB18()
{
  if ((byte_101B09E98 & 1) == 0)
  {
    byte_101B09E98 = 1;
    return __cxa_atexit((void (*)(void *))sub_10021691C, &stru_101B09E48, (void *)&_mh_execute_header);
  }
  return result;
}

void IPsecInterfaceSettingsResource::IPsecInterfaceSettingsResource(IPsecInterfaceSettingsResource *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = off_101A456A8;
  sub_1001EC034(&v3);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  *(_OWORD *)((char *)this + 8) = v3;
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100BDDBBC(_Unwind_Exception *exception_object)
{
  long long v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100BDDBD4(void *a1)
{
  *a1 = off_101A456A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100BDDC20(void *a1)
{
  *a1 = off_101A456A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

uint64_t sub_100BDDC8C()
{
  return kIPsecInterfaceSettingsResource;
}

void sub_100BDDC9C(uint64_t **a1, int a2, void *a3)
{
  int v5 = a2;
  long long v6 = &v5;
  long long v4 = sub_100200564(a1, &v5, (uint64_t)&unk_10144E20E, &v6);
  sub_10041F480((uint64_t)(v4 + 5), a3);
}

void sub_100BDDCF4(void *a1@<X0>, uint64_t *a2@<X8>)
{
  a2[2] = 0;
  a2[1] = 0;
  *a2 = (uint64_t)(a2 + 1);
  long long v3 = a1 + 1;
  long long v4 = (void *)*a1;
  if ((void *)*a1 != a1 + 1)
  {
    do
    {
      long long v8 = 0u;
      long long v9 = 0u;
      sub_10024EEAC((uint64_t *)&v8 + 1, (uint64_t)(v4 + 5));
      sub_100BDE2CC(a2, (uint64_t **)&v8 + 1);
      sub_1000346F8((uint64_t)&v8 + 8, (void *)v9);
      int v5 = (void *)v4[1];
      if (v5)
      {
        do
        {
          long long v6 = v5;
          int v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          long long v6 = (void *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          long long v4 = v6;
        }
        while (!v7);
      }
      long long v4 = v6;
    }
    while (v6 != v3);
  }
}

void sub_100BDDDB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  sub_1000346F8(v12, a11);
  sub_1000346F8(v11, *(void **)(v11 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100BDDDE0(uint64_t a1, int a2, unint64_t a3, unsigned int a4)
{
  int v25 = a2;
  int64_t v24 = a3;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v5 = a1 + 32;
  uint64_t v6 = v7;
  if (v7)
  {
    uint64_t v8 = v5;
    do
    {
      int v9 = *(_DWORD *)(v6 + 32);
      BOOL v10 = v9 < a2;
      if (v9 >= a2) {
        uint64_t v11 = (uint64_t *)v6;
      }
      else {
        uint64_t v11 = (uint64_t *)(v6 + 8);
      }
      if (!v10) {
        uint64_t v8 = v6;
      }
      uint64_t v6 = *v11;
    }
    while (*v11);
    if (v8 != v5 && *(_DWORD *)(v8 + 32) <= a2)
    {
      unsigned int v14 = *(void **)(v8 + 48);
      uint64_t v12 = (void *)(v8 + 48);
      uint64_t v13 = v14;
      if (v14)
      {
        uint64_t v15 = v12;
        do
        {
          unint64_t v16 = v13[4];
          BOOL v17 = v16 >= a3;
          if (v16 >= a3) {
            CFStringRef v18 = v13;
          }
          else {
            CFStringRef v18 = v13 + 1;
          }
          if (v17) {
            uint64_t v15 = v13;
          }
          uint64_t v13 = (void *)*v18;
        }
        while (*v18);
        if (v15 != v12 && v15[4] <= a3 && *((_DWORD *)v15 + 10) == a4) {
          return 0;
        }
      }
    }
  }
  uint64_t v20 = (uint64_t **)(v5 - 8);
  uint64_t v26 = &v25;
  uint64_t v21 = sub_100200564((uint64_t **)(v5 - 8), &v25, (uint64_t)&unk_10144E20E, &v26);
  uint64_t v22 = v21 + 6;
  sub_1000346F8((uint64_t)(v21 + 5), v21[6]);
  *(v22 - 1) = v22;
  void *v22 = 0;
  v22[1] = 0;
  uint64_t v26 = &v25;
  uint64_t v23 = sub_100200564(v20, &v25, (uint64_t)&unk_10144E20E, &v26);
  uint64_t v26 = (int *)&v24;
  *((_DWORD *)sub_1003B2574(v23 + 5, (unint64_t *)&v24, (uint64_t)&unk_10144E20E, (void **)&v26) + 10) = a4;
  sub_100BDDF40(v24, a4);
  return 1;
}

void sub_100BDDF40(int64_t a1, unsigned int a2)
{
  xpc_object_t v18 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v18 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v18 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v16 = xpc_int64_create(a1);
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  long long v19 = 0uLL;
  uint64_t v20 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v13 = 0;
  unsigned int v14 = &v18;
  uint64_t v15 = __p;
  sub_100035E70((uint64_t)&v14, &v16, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_object_t v10 = xpc_int64_create(a2);
  if (!v10) {
    xpc_object_t v10 = xpc_null_create();
  }
  long long v19 = 0uLL;
  uint64_t v20 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = v19;
  uint64_t v13 = v20;
  uint64_t v7 = __p;
  if (v20 < 0) {
    uint64_t v7 = (void **)__p[0];
  }
  unsigned int v14 = &v18;
  uint64_t v15 = v7;
  sub_100035E70((uint64_t)&v14, &v10, &v11);
  xpc_release(v11);
  xpc_object_t v11 = 0;
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_object_t v8 = v18;
  *(void *)&long long v19 = v18;
  if (v18)
  {
    xpc_retain(v18);
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    *(void *)&long long v19 = v8;
  }
  xpc_object_t v9 = xpc_null_create();
  __p[0] = v9;
  sub_1000452AC(172, (xpc_object_t *)&v19, __p);
  xpc_release(v9);
  xpc_release(v8);
  xpc_release(v18);
}

void sub_100BDE188(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t object)
{
  xpc_release(v18);
  xpc_release(v17);
  xpc_release(*(xpc_object_t *)(v19 - 64));
  _Unwind_Resume(a1);
}

void sub_100BDE234(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v2 = a1 + 32;
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v5 = v2;
    do
    {
      int v6 = *(_DWORD *)(v3 + 32);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        xpc_object_t v8 = (uint64_t *)v3;
      }
      else {
        xpc_object_t v8 = (uint64_t *)(v3 + 8);
      }
      if (!v7) {
        uint64_t v5 = v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 != v2 && *(_DWORD *)(v5 + 32) <= a2 && *(void *)(v5 + 56))
    {
      xpc_object_t v10 = *(void **)(v5 + 48);
      xpc_object_t v9 = (void *)(v5 + 48);
      sub_1000346F8((uint64_t)(v9 - 1), v10);
      *(v9 - 1) = v9;
      *xpc_object_t v9 = 0;
      v9[1] = 0;
      sub_100BDDF40(0, 0);
    }
  }
}

uint64_t *sub_100BDE2CC(uint64_t *result, uint64_t **a2)
{
  uint64_t v3 = a2 + 1;
  uint64_t v2 = *a2;
  if (*a2 != (uint64_t *)(a2 + 1))
  {
    uint64_t v5 = (uint64_t **)result;
    int v6 = (uint64_t **)(result + 1);
    do
    {
      BOOL v7 = *v6;
      if (*v6)
      {
        unint64_t v8 = v2[4];
        xpc_object_t v9 = v6;
        while (1)
        {
          while (1)
          {
            xpc_object_t v10 = (uint64_t **)v7;
            unint64_t v11 = v7[4];
            if (v8 >= v11) {
              break;
            }
            BOOL v7 = *v10;
            xpc_object_t v9 = v10;
            if (!*v10)
            {
              uint64_t v12 = 0;
              xpc_object_t v9 = v10;
              goto LABEL_13;
            }
          }
          if (v11 >= v8) {
            break;
          }
          xpc_object_t v9 = v10 + 1;
          BOOL v7 = v10[1];
          if (!v7)
          {
            uint64_t v12 = 0;
            goto LABEL_13;
          }
        }
        uint64_t v12 = v10;
      }
      else
      {
        uint64_t v12 = 0;
        xpc_object_t v10 = v6;
        xpc_object_t v9 = v6;
      }
LABEL_13:
      uint64_t v13 = (uint64_t *)v2[1];
      unsigned int v14 = v2;
      if (v13)
      {
        do
        {
          uint64_t v15 = v13;
          uint64_t v13 = (uint64_t *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v15 = (uint64_t *)v14[2];
          BOOL v16 = *v15 == (void)v14;
          unsigned int v14 = v15;
        }
        while (!v16);
      }
      if (!v12)
      {
        sub_10006C514(a2, v2);
        uint64_t result = sub_100046C38(v5, (uint64_t)v10, v9, v2);
      }
      uint64_t v2 = v15;
    }
    while (v15 != (uint64_t *)v3);
  }
  return result;
}

void sub_100BDE3E8(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 88);
  if (v2 != a2 && v2 != 0)
  {
    id v5 = [(objc_class *)off_101B0B1C8() sharedInstance];
    *(unsigned char *)(a1 + 64) = [v5 isDeviceEnrolledWithDeKOTA:0];
  }
}

void sub_100BDE468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

Class sub_100BDE47C()
{
  if (qword_101B10238 != -1) {
    dispatch_once(&qword_101B10238, &stru_101A456D8);
  }
  Class result = objc_getClass("MSDKDemoState");
  qword_101B10230 = (uint64_t)result;
  off_101B0B1C8 = (uint64_t (*)())sub_100BDE4E0;
  return result;
}

id sub_100BDE4E0()
{
  return (id)qword_101B10230;
}

void sub_100BDE4EC(id a1)
{
  qword_101B10228 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/MobileStoreDemoKit.framework/MobileStoreDemoKit", 2);
}

void sub_100BDE518(void *a1, void *a2)
{
  *(void *)operator new(8uLL) = @"Stewie";
  sub_1011241AC(a1, a2, "stw.em.env");
}

void sub_100BDE6D8()
{
}

void sub_100BDE780(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  JUMPOUT(0x100BDE778);
}

uint64_t sub_100BDE798(uint64_t a1)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  *int v2 = 0;
  if (v4) {
    sub_10026CD9C((uint64_t)v2, v3);
  }
  return a1;
}

uint64_t sub_100BDE7CC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting up environment", v6, 2u);
  }

  uint64_t result = sub_1011244F4(a1, (uint64_t)(a2 + 8), *a2);
  if (!*(unsigned char *)(a1 + 272))
  {
    uint64_t result = sub_100BDE8A4(a1 + 296, 0);
    if (result != 2)
    {
      *(unsigned char *)(a1 + 314) = 0;
      return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 304) + 8) + 16))(*(void *)(*(void *)(a1 + 304) + 8));
    }
  }
  return result;
}

uint64_t sub_100BDE8A4(uint64_t a1, char a2)
{
  if (!*(unsigned char *)(a1 + 18) || (a2 & 1) != 0)
  {
    *(unsigned char *)(a1 + 18) = 1;
    unint64_t v8 = 0;
    (*(void (**)(const void **__return_ptr))(**(void **)(*(void *)(a1 + 8) + 8) + 8))(&v7);
    sub_1000842D0(&v8, &v7);
    sub_1000577C4(&v7);
    if (v8) {
      id v5 = sub_100081E58;
    }
    else {
      id v5 = 0;
    }
    if (v5)
    {
      LODWORD(v7) = 0;
      ctu::cf::assign((ctu::cf *)&v7, v8, v4);
      unsigned __int8 v3 = v7;
    }
    else
    {
      unsigned __int8 v3 = *(unsigned char *)(a1 + 16);
    }
    *(unsigned char *)(a1 + 17) = v3;
    sub_1000570E8((const void **)&v8);
  }
  else
  {
    return *(unsigned __int8 *)(a1 + 17);
  }
  return v3;
}

void sub_100BDE978(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100BDE99C(uint64_t a1)
{
  *(unsigned char *)(a1 + 18) = 0;
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 8) + 16))();
}

void sub_100BDE9CC(uint64_t a1)
{
  uint64_t v1 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Teardown requested", v2, 2u);
  }
}

void sub_100BDEA38(uint64_t a1, __int16 a2)
{
  *(_WORD *)(a1 + 320) = a2 | 0x100;
  if (!sub_100BDEA90(a1))
  {
    unsigned __int8 v3 = *(std::__shared_weak_count **)(a1 + 336);
    *(void *)(a1 + 328) = 0;
    *(void *)(a1 + 336) = 0;
    if (v3)
    {
      sub_10004D2C8(v3);
    }
  }
}

BOOL sub_100BDEA90(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 321)) {
    return 0;
  }
  int v2 = sub_100BDE8A4(a1 + 296, 0);
  if (v2 == 2) {
    int v3 = 0;
  }
  else {
    int v3 = v2;
  }
  if (*(unsigned char *)(a1 + 321)) {
    BOOL v4 = *(unsigned __int8 *)(a1 + 320) == v3;
  }
  else {
    BOOL v4 = 0;
  }
  return !v4;
}

uint64_t sub_100BDEAE8(uint64_t a1, unsigned int a2)
{
  *(unsigned char *)(a1 + 18) = 1;
  *(unsigned char *)(a1 + 17) = a2;
  uint64_t v2 = *(void *)(a1 + 8);
  CFNumberRef v9 = 0;
  unint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v3)
  {
    unint64_t v4 = (unint64_t)v9;
    CFNumberRef v9 = v3;
    unint64_t valuePtr = v4;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v5 = v9;
  CFNumberRef v8 = v9;
  CFNumberRef v9 = 0;
  sub_1000570E8((const void **)&v9);
  uint64_t v6 = (***(uint64_t (****)(void, const void *))(v2 + 8))(*(void *)(v2 + 8), v5);
  sub_1000570E8((const void **)&v8);
  return v6;
}

void sub_100BDEBA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

const char *sub_100BDEBC0()
{
  return "com.apple.stewie.quagmire";
}

uint64_t sub_100BDEBCC()
{
  return 7200;
}

uint64_t sub_100BDEBD4(uint64_t a1, void *a2)
{
  unsigned __int16 v3 = sub_100BDECB8(a1);
  if (v3 >= 0x100u)
  {
    char v5 = v3;
    uint64_t v6 = (char *)operator new(0x70uLL);
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = 0;
    *(void *)uint64_t v6 = off_101A459C8;
    *(_OWORD *)(v6 + 24) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 88) = 0u;
    *((void *)v6 + 13) = 0;
    switch(v5)
    {
      case 3:
        unint64_t v7 = 0xC056800000000000;
        break;
      case 2:
        unint64_t v7 = 0x4056800000000000;
        break;
      case 1:
        *((void *)v6 + 4) = 0;
        *((void *)v6 + 5) = 0;
LABEL_10:
        CFNumberRef v8 = (char *)a2[1];
        *a2 = v6 + 24;
        a2[1] = v6;
        uint64_t v4 = 1;
        uint64_t v6 = v8;
        if (!v8) {
          return v4;
        }
        goto LABEL_13;
      default:
        uint64_t v4 = 0;
LABEL_13:
        sub_10004D2C8((std::__shared_weak_count *)v6);
        return v4;
    }
    *((void *)v6 + 5) = v7;
    goto LABEL_10;
  }
  return 0;
}

uint64_t sub_100BDECB8(uint64_t a1)
{
  int v2 = sub_1002B45F4(a1);
  if (v2)
  {
    int v2 = sub_100BDECFC(a1 + 352, 0);
    int v3 = 1;
  }
  else
  {
    int v3 = 0;
  }
  return v2 | (v3 << 8);
}

uint64_t sub_100BDECFC(uint64_t a1, char a2)
{
  if (!*(unsigned char *)(a1 + 18) || (a2 & 1) != 0)
  {
    *(unsigned char *)(a1 + 18) = 1;
    CFNumberRef v8 = 0;
    (*(void (**)(const void **__return_ptr))(**(void **)(*(void *)(a1 + 8) + 8) + 8))(&v7);
    sub_1000842D0(&v8, &v7);
    sub_1000577C4(&v7);
    if (v8) {
      char v5 = sub_100081E58;
    }
    else {
      char v5 = 0;
    }
    if (v5)
    {
      LODWORD(v7) = 0;
      ctu::cf::assign((ctu::cf *)&v7, v8, v4);
      unsigned __int8 v3 = v7;
    }
    else
    {
      unsigned __int8 v3 = *(unsigned char *)(a1 + 16);
    }
    *(unsigned char *)(a1 + 17) = v3;
    sub_1000570E8((const void **)&v8);
  }
  else
  {
    return *(unsigned __int8 *)(a1 + 17);
  }
  return v3;
}

void sub_100BDEDD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100BDEDF4(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 280);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 288);
    *a2 = v4;
    a2[1] = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v6 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Trying to get EED key", buf, 2u);
    }

    unsigned __int8 v7 = atomic_load(byte_101B10240);
    if ((v7 & 1) == 0)
    {
      atomic_store(1u, byte_101B10240);
      uint64_t v8 = *(void *)(a1 + 24);
      uint64_t v12 = *(void *)(a1 + 16);
      uint64_t v13 = v8;
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      CFNumberRef v9 = sub_100200FB4((id *)(a1 + 8));
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I EED key fetch is now in progress", buf, 2u);
      }

      xpc_object_t v10 = operator new(0x20uLL);
      v10[1] = 0;
      int v10[2] = 0;
      *xpc_object_t v10 = off_101A45860;
      operator new();
    }
    unint64_t v11 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Previous EED key fetch is still in progress and seems to be stuck. Skip fetching EED key.", buf, 2u);
    }

    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_100BDF5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, std::exception_ptr a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,std::mutex *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(a1);
}

void sub_100BDF768(uint64_t a1)
{
  sub_1011263E8(a1);
  int v2 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 273) && *(void *)(a1 + 88))
    {
      unsigned __int8 v3 = "false";
      if (*(void *)(a1 + 152) && *(void *)(a1 + 168)) {
        unsigned __int8 v3 = "true";
      }
    }
    else
    {
      unsigned __int8 v3 = "false";
    }
    int v21 = 136315138;
    uint64_t v22 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Ready: %s", (uint8_t *)&v21, 0xCu);
  }

  uint64_t v4 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = sub_100BDE8A4(a1 + 296, 0);
    if (v5 == 2) {
      unsigned int v6 = 0;
    }
    else {
      unsigned int v6 = v5;
    }
    if (v6 > 2) {
      unsigned __int8 v7 = "???";
    }
    else {
      unsigned __int8 v7 = off_101A45A08[(char)v6];
    }
    int v21 = 136315138;
    uint64_t v22 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [d] Notify options: %s", (uint8_t *)&v21, 0xCu);
  }

  uint64_t v8 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v9 = sub_100BDEA90(a1);
    xpc_object_t v10 = "false";
    if (v9) {
      xpc_object_t v10 = "true";
    }
    int v21 = 136315138;
    uint64_t v22 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [d] Need to sync notify option: %s", (uint8_t *)&v21, 0xCu);
  }

  if (*(void *)(a1 + 328))
  {
    unint64_t v11 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int isExpired = AutoStartTimer::isExpired(*(AutoStartTimer **)(a1 + 328));
      uint64_t v13 = "false";
      if (isExpired) {
        uint64_t v13 = "true";
      }
      int v21 = 136315138;
      uint64_t v22 = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [d] Notify option timer exists. isExpired: %s", (uint8_t *)&v21, 0xCu);
    }
  }
  unsigned __int16 v14 = sub_100BDECB8(a1);
  unsigned __int8 v15 = v14;
  if (v14 >= 0x100u)
  {
    BOOL v16 = sub_100200FB4((id *)(a1 + 8));
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      if (v15 > 4u) {
        BOOL v17 = "???";
      }
      else {
        BOOL v17 = off_101A45A20[(char)v15];
      }
      int v21 = 136315138;
      uint64_t v22 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [d] Mock Mode Type: %s", (uint8_t *)&v21, 0xCu);
    }
  }
  xpc_object_t v18 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v19 = *(char *)(a1 + 344);
    if (v19 > 3) {
      uint64_t v20 = "???";
    }
    else {
      uint64_t v20 = off_101A45A48[v19];
    }
    int v21 = 136315138;
    uint64_t v22 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [d] (Em Env) User incapacitated: %s", (uint8_t *)&v21, 0xCu);
  }
}

void sub_100BDFAE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100BDFB08(void *a1)
{
  *a1 = off_101A45708;
  uint64_t v2 = a1[45];
  a1[45] = 0;
  if (v2) {
    sub_10026CD9C((uint64_t)(a1 + 45), v2);
  }
  unsigned __int8 v3 = (std::__shared_weak_count *)a1[42];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = a1[38];
  a1[38] = 0;
  if (v4) {
    sub_10026CD9C((uint64_t)(a1 + 38), v4);
  }
  unsigned int v5 = (std::__shared_weak_count *)a1[36];
  if (v5) {
    sub_10004D2C8(v5);
  }

  return sub_101126828(a1);
}

uint64_t sub_100BDFB98(uint64_t a1)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  *uint64_t v2 = 0;
  if (v4) {
    sub_10026CD9C((uint64_t)v2, v3);
  }
  return a1;
}

void sub_100BDFBD0(void *a1)
{
  sub_100BDFB08(a1);

  operator delete();
}

void sub_100BDFC08(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A45860;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BDFC28(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A45860;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BDFC7C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    if ((*(unsigned char *)(v1 + 136) & 1) == 0)
    {
      v4.__vftable = 0;
      uint64_t v3 = *(void *)(v1 + 16);
      std::exception_ptr::~exception_ptr((std::exception_ptr *)&v4);
      uint64_t v1 = *(void *)(a1 + 24);
      if (!v3 && *(uint64_t *)(v1 + 8) >= 1)
      {
        v5.__cat_ = std::future_category();
        *(void *)&v5.__val_ = 4;
        std::future_error::future_error(&v4, v5);
        sub_1007074E4(&v4);
      }
    }
    if (!atomic_fetch_add((atomic_ullong *volatile)(v1 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
      (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
    }
  }
}

void sub_100BDFD60(uint64_t a1)
{
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

void sub_100BDFDCC(uint64_t a1)
{
  uint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  operator delete();
}

uint64_t sub_100BDFE4C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136)) {

  }
  uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 8);

  return v2(a1);
}

uint64_t *sub_100BDFEB0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 16));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100BDFF0C(uint64_t a1)
{
  v11[0] = a1;
  v11[1] = 0;
  uint64_t v2 = CLGetEEDCloakingKey();
  id v3 = 0;
  std::future_error v4 = v3;
  uint64_t v5 = **(void **)a1;
  if (!v2 || v3)
  {
    if (!v5) {
      sub_1007078E4(3u);
    }
    unsigned int v6 = (std::mutex *)(v5 + 24);
    std::mutex::lock((std::mutex *)(v5 + 24));
    if ((*(unsigned char *)(v5 + 136) & 1) != 0
      || (v12.__ptr_ = 0, uint64_t v8 = *(void *)(v5 + 16), std::exception_ptr::~exception_ptr(&v12), v8))
    {
      sub_1007078E4(2u);
    }
    *(void *)(v5 + 144) = 0;
  }
  else
  {
    if (!v5) {
      sub_1007078E4(3u);
    }
    unsigned int v6 = (std::mutex *)(v5 + 24);
    std::mutex::lock((std::mutex *)(v5 + 24));
    if ((*(unsigned char *)(v5 + 136) & 1) != 0
      || (v12.__ptr_ = 0, uint64_t v7 = *(void *)(v5 + 16), std::exception_ptr::~exception_ptr(&v12), v7))
    {
      sub_1007078E4(2u);
    }
    *(void *)(v5 + 144) = v2;
  }
  *(_DWORD *)(v5 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(v5 + 88));
  std::mutex::unlock(v6);
  atomic_store(0, byte_101B10240);
  BOOL v9 = sub_100200FB4((id *)(a1 + 16));
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12.__ptr_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I EED key fetch is now complete", (uint8_t *)&v12, 2u);
  }

  return sub_100BDFEB0(v11);
}

void sub_100BE0090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100BDFEB0(&a9);
  _Unwind_Resume(a1);
}

void sub_100BE00C8()
{
}

uint64_t sub_100BE00D0(uint64_t a1)
{
  return sub_100BDE8A4(a1, 1);
}

void sub_100BE00D8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = v3;
  *uint64_t v1 = 0;
  if (v3) {
    sub_10026CD9C((uint64_t)v1, v2);
  }

  operator delete();
}

uint64_t sub_100BE012C(uint64_t a1, unsigned int a2)
{
  *(unsigned char *)(a1 + 18) = 1;
  *(unsigned char *)(a1 + 17) = a2;
  uint64_t v2 = *(void *)(a1 + 8);
  CFNumberRef v9 = 0;
  unint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v3)
  {
    unint64_t v4 = (unint64_t)v9;
    CFNumberRef v9 = v3;
    unint64_t valuePtr = v4;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v5 = v9;
  CFNumberRef v8 = v9;
  CFNumberRef v9 = 0;
  sub_1000570E8((const void **)&v9);
  uint64_t v6 = (***(uint64_t (****)(void, const void *))(v2 + 8))(*(void *)(v2 + 8), v5);
  sub_1000570E8((const void **)&v8);
  return v6;
}

void sub_100BE01E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100BE0204(uint64_t a1)
{
  *(unsigned char *)(a1 + 18) = 0;
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 8) + 16))();
}

uint64_t sub_100BE0234(uint64_t a1)
{
  return sub_100BDECFC(a1, 1);
}

void sub_100BE023C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = v3;
  *uint64_t v1 = 0;
  if (v3) {
    sub_10026CD9C((uint64_t)v1, v2);
  }

  operator delete();
}

void sub_100BE0290(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A459C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BE02B0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A459C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100BE030C@<X0>(const void **a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x30uLL);
  uint64_t result = sub_100BE0370(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_100BE035C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100BE0370(void *a1, const void **a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019B47B8;
  unint64_t v4 = *a2;
  uint64_t v5 = *a3;
  a1[4] = 0;
  a1[5] = 0;
  a1[3] = 0;
  sub_1001E7940(a1 + 3, v4, v5, v5 - (void)v4);
  return a1;
}

void sub_100BE03CC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100BE03E0(uint64_t a1)
{
  *(void *)a1 = off_101A45A78;
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_100110A40((void ***)(a1 + 8), 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_100BE0470(uint64_t a1)
{
  sub_100BE03E0(a1);

  operator delete();
}

uint64_t sub_100BE04A8(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, this, "details");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100BE053C(int a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v18 = v10 & 7;
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v10 >> 3;
      if ((v10 >> 3) == 4) {
        operator new();
      }
      if (v19 == 1) {
        operator new();
      }
LABEL_24:
      uint64_t result = PB::Reader::skip(this, v19, v18, 0);
      if (!result) {
        return result;
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)this + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_20;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13)
      {
LABEL_19:
        unsigned __int8 v18 = 0;
        LODWORD(v19) = 0;
        goto LABEL_24;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100BE07D4(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  uint64_t v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
  {
    return PB::Writer::writeSubmessage(this, v5, 4u);
  }
  return result;
}

uint64_t sub_100BE0838(uint64_t result)
{
  if (!*(void *)(result + 16)) {
    operator new();
  }
  return result;
}

const void **sub_100BE0904@<X0>(const void **result@<X0>, uint64_t a2@<X8>)
{
  int v21 = result;
  BOOL v2 = *result == 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v3 = (uint64_t **)(a2 + 8);
  if (v2) {
    int v4 = 0;
  }
  else {
    int v4 = sub_100080778;
  }
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = v3;
  if (v4)
  {
    unsigned int v26 = begin();
    int v22 = end();
    while (1)
    {
      uint64_t result = (const void **)v26;
      if (v26 == v22) {
        break;
      }
      int v5 = operator*();
      CFDictionaryRef v25 = 0;
      sub_100058198((const void **)&theDict, v21);
      uint64_t v6 = "gsm";
      switch(v5)
      {
        case 1:
          uint64_t v6 = "umts";
          break;
        case 2:
          uint64_t v6 = "cdma";
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_12;
        case 4:
          uint64_t v6 = "lte";
          break;
        case 8:
          break;
        default:
          if (v5 == 16)
          {
            uint64_t v6 = "scdma";
          }
          else if (v5 == 32)
          {
            uint64_t v6 = "nr";
          }
          else
          {
LABEL_12:
            uint64_t v6 = "unknown";
          }
          break;
      }
      CFStringRef v27 = CFStringCreateWithCString(kCFAllocatorDefault, v6, 0x8000100u);
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, v27);
      CFDictionaryRef v8 = Value;
      if (Value && (CFTypeID v9 = CFGetTypeID(Value), v9 == CFDictionaryGetTypeID()))
      {
        CFDictionaryRef v25 = v8;
        CFRetain(v8);
      }
      else
      {
        CFDictionaryRef v25 = 0;
      }
      sub_1000558F4((const void **)&v27);
      sub_100057D78((const void **)&theDict);
      if (v25) {
        unint64_t v10 = sub_100080778;
      }
      else {
        unint64_t v10 = 0;
      }
      if (v10)
      {
        CFDictionaryGetValue(v25, @"Version");
        CFStringRef v27 = 0;
        uint64_t v28 = 0;
        uint64_t v29 = 0;
        ctu::cf::assign();
        unint64_t v11 = (__CFString *)v27;
        unint64_t v12 = (unint64_t)v28;
        *(_DWORD *)uint64_t v23 = v29;
        *(_DWORD *)&v23[3] = *(_DWORD *)((char *)&v29 + 3);
        int v13 = SHIBYTE(v29);
        char v14 = *v3;
        unsigned int v15 = v3;
        unint64_t v16 = v3;
        if (*v3)
        {
          while (1)
          {
            while (1)
            {
              unint64_t v16 = (uint64_t **)v14;
              int v17 = *((_DWORD *)v14 + 8);
              if (v17 <= v5) {
                break;
              }
              char v14 = *v16;
              unsigned int v15 = v16;
              if (!*v16) {
                goto LABEL_31;
              }
            }
            if (v17 >= v5) {
              break;
            }
            char v14 = v16[1];
            if (!v14)
            {
              unsigned int v15 = v16 + 1;
              goto LABEL_31;
            }
          }
        }
        else
        {
LABEL_31:
          uint64_t v29 = 0;
          unsigned __int8 v18 = (char *)operator new(0x40uLL);
          unint64_t v19 = (uint64_t *)v18;
          uint64_t v28 = v3;
          LOBYTE(v29) = 0;
          *((_DWORD *)v18 + 8) = v5;
          if (v13 < 0)
          {
            sub_10004FC84(v18 + 40, v11, v12);
          }
          else
          {
            *((void *)v18 + 5) = v11;
            *((void *)v18 + 6) = v12;
            *((_DWORD *)v18 + 14) = *(_DWORD *)v23;
            *(_DWORD *)(v18 + 59) = *(_DWORD *)&v23[3];
            v18[63] = v13;
          }
          sub_100046C38((uint64_t **)a2, (uint64_t)v16, v15, v19);
        }
        if (v13 < 0) {
          operator delete(v11);
        }
      }
      sub_100057D78((const void **)&v25);
      operator++();
    }
  }
  return result;
}

void sub_100BE0BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t sub_100BE0C90(capabilities::ct *a1)
{
  uint64_t v1 = (capabilities::ct *)capabilities::ct::supportsLASDGSMDatabase(a1);
  if (v1) {
    int v2 = 9;
  }
  else {
    int v2 = 1;
  }
  uint64_t v3 = (capabilities::ct *)capabilities::ct::supportsCapabilityC2KDevice(v1);
  if (v3) {
    v2 |= 2u;
  }
  int v4 = (capabilities::ct *)capabilities::ct::supportsCapabilityTDSCDMADevice(v3);
  if (v4) {
    int v5 = 20;
  }
  else {
    int v5 = 4;
  }
  unsigned int v6 = v2 | v5;
  if (capabilities::ct::supports5G(v4)) {
    return v6 | 0x20;
  }
  else {
    return v6;
  }
}

const void **sub_100BE0CF4@<X0>(const void **result@<X0>, void *a2@<X8>)
{
  if (result[2])
  {
    uint64_t v3 = result;
    int v17 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      int v5 = v17;
      int v17 = Mutable;
      unsigned __int8 v18 = v5;
      sub_10005717C((const void **)&v18);
    }
    CFDictionaryRef v8 = *v3;
    unsigned int v6 = v3 + 1;
    uint64_t v7 = v8;
    if (v8 != v6)
    {
      do
      {
        int v9 = *((_DWORD *)v7 + 8);
        unint64_t v10 = "gsm";
        switch(v9)
        {
          case 1:
            unint64_t v10 = "umts";
            break;
          case 2:
            unint64_t v10 = "cdma";
            break;
          case 3:
          case 5:
          case 6:
          case 7:
            goto LABEL_10;
          case 4:
            unint64_t v10 = "lte";
            break;
          case 8:
            break;
          default:
            if (v9 == 16)
            {
              unint64_t v10 = "scdma";
            }
            else if (v9 == 32)
            {
              unint64_t v10 = "nr";
            }
            else
            {
LABEL_10:
              unint64_t v10 = "unknown";
            }
            break;
        }
        CFStringRef v11 = CFStringCreateWithCString(kCFAllocatorDefault, v10, 0x8000100u);
        unint64_t v12 = (const char *)(v7 + 5);
        unsigned __int8 v18 = (void *)v11;
        if (*((char *)v7 + 63) < 0) {
          unint64_t v12 = *(const char **)v12;
        }
        CFStringRef v16 = CFStringCreateWithCString(kCFAllocatorDefault, v12, 0x8000100u);
        sub_10010F3F0(v17, v18, (uint64_t)v16);
        sub_1000558F4((const void **)&v16);
        sub_1000558F4((const void **)&v18);
        int v13 = (void *)v7[1];
        if (v13)
        {
          do
          {
            char v14 = v13;
            int v13 = (void *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            char v14 = (void *)v7[2];
            BOOL v15 = *v14 == (void)v7;
            uint64_t v7 = v14;
          }
          while (!v15);
        }
        uint64_t v7 = v14;
      }
      while (v14 != v6);
    }
    sub_10004EFE4(a2, (CFTypeRef *)&v17);
    return sub_10005717C((const void **)&v17);
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_100BE0EE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

CFDictionaryRef *sub_100BE0F3C@<X0>(CFDictionaryRef *result@<X0>, uint64_t a2@<X8>)
{
  BOOL v2 = *result == 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v3 = (uint64_t **)(a2 + 8);
  if (v2) {
    int v4 = 0;
  }
  else {
    int v4 = sub_100080778;
  }
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = v3;
  if (v4)
  {
    int v5 = result;
    unsigned int v20 = begin();
    int v6 = end();
    while (1)
    {
      uint64_t result = (CFDictionaryRef *)v20;
      if (v20 == v6) {
        break;
      }
      int v7 = operator*();
      int v8 = v7;
      int v9 = "gsm";
      switch(v7)
      {
        case 1:
          int v9 = "umts";
          break;
        case 2:
          int v9 = "cdma";
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_12;
        case 4:
          int v9 = "lte";
          break;
        case 8:
          break;
        default:
          if (v7 == 16)
          {
            int v9 = "scdma";
          }
          else if (v7 == 32)
          {
            int v9 = "nr";
          }
          else
          {
LABEL_12:
            int v9 = "unknown";
          }
          break;
      }
      CFStringRef v19 = CFStringCreateWithCString(kCFAllocatorDefault, v9, 0x8000100u);
      if (CFDictionaryGetValue(*v5, v19))
      {
        std::string __p = 0;
        long long v22 = 0uLL;
        ctu::cf::assign();
        unint64_t v10 = __p;
        v23[0] = v22;
        *(void *)((char *)v23 + 7) = *(void *)((char *)&v22 + 7);
        char v11 = HIBYTE(v22);
        unint64_t v12 = *v3;
        int v13 = v3;
        char v14 = v3;
        if (*v3)
        {
          while (1)
          {
            while (1)
            {
              char v14 = (uint64_t **)v12;
              int v15 = *((_DWORD *)v12 + 8);
              if (v15 <= v8) {
                break;
              }
              unint64_t v12 = *v14;
              int v13 = v14;
              if (!*v14) {
                goto LABEL_24;
              }
            }
            if (v15 >= v8) {
              break;
            }
            unint64_t v12 = v14[1];
            if (!v12)
            {
              int v13 = v14 + 1;
              goto LABEL_24;
            }
          }
          if (SHIBYTE(v22) < 0) {
            operator delete(__p);
          }
        }
        else
        {
LABEL_24:
          CFStringRef v16 = (char *)operator new(0x40uLL);
          *((_DWORD *)v16 + 8) = v8;
          uint64_t v17 = v23[0];
          *((void *)v16 + 5) = v10;
          *((void *)v16 + 6) = v17;
          *(void *)(v16 + 55) = *(void *)((char *)v23 + 7);
          v16[63] = v11;
          v23[0] = 0;
          *(void *)((char *)v23 + 7) = 0;
          sub_100046C38((uint64_t **)a2, (uint64_t)v14, v13, (uint64_t *)v16);
        }
      }
      sub_1000558F4((const void **)&v19);
      operator++();
    }
  }
  return result;
}

void sub_100BE119C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void CellularPlanAttachProvisioningMonitorMode::create()
{
}

void sub_100BE16C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t a12, dispatch_object_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,dispatch_object_t object,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  uint64_t v41 = (std::__shared_weak_count *)*((void *)v38 + 20);
  if (v41) {
    std::__shared_weak_count::__release_weak(v41);
  }
  sub_10045E9DC(v38);
  if (a38 < 0)
  {
    operator delete(__p);
    if (!v40)
    {
LABEL_5:
      if (!v39) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
  }
  else if (!v40)
  {
    goto LABEL_5;
  }
  sub_10004D2C8(v40);
  if (!v39) {
LABEL_10:
  }
    operator delete();
LABEL_9:
  dispatch_release(v39);
  goto LABEL_10;
}

CellularPlanProvisioningMonitorModeInterface *sub_100BE1858(uint64_t a1)
{
  *(void *)a1 = off_101A45AC8;
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 296));
  if (*(unsigned char *)(a1 + 1200))
  {
    BOOL v2 = *(void **)(a1 + 1176);
    if (v2)
    {
      *(void *)(a1 + 1184) = v2;
      operator delete(v2);
    }
  }
  sub_1000346F8(a1 + 1144, *(void **)(a1 + 1152));
  sub_10030AAD0(a1 + 1120, *(void **)(a1 + 1128));
  sub_10030A970(a1 + 312);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 304);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v6 = (void **)(a1 + 272);
  sub_10008A88C(&v6);
  int v6 = (void **)(a1 + 248);
  sub_1000C56F4(&v6);
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*(void **)(a1 + 208));
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 160);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return sub_10045E9DC((CellularPlanProvisioningMonitorModeInterface *)a1);
}

void sub_100BE1934(uint64_t a1)
{
  sub_100BE1858(a1);

  operator delete();
}

void sub_100BE196C(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 240);
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (v1 == 3)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315138;
      uint64_t v6 = asString();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received registration status %s", (uint8_t *)&v5, 0xCu);
    }
    sub_100BE2880(a1);
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
  {
    if (v1 > 2) {
      int v4 = "???";
    }
    else {
      int v4 = off_101A45DB0[v1];
    }
    int v5 = 136315138;
    uint64_t v6 = (uint64_t)v4;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Recieved registration event when not monitoring, %s", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100BE1A98(uint64_t a1)
{
  uint64_t v2 = *(int *)(a1 + 240);
  if (v2 == 3)
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v12 = 0;
    if (*(char *)(a1 + 231) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 208), *(void *)(a1 + 216));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 208);
      uint64_t v12 = *(void *)(a1 + 224);
    }
    int v5 = sub_100046F68(a1 + 1120, __p);
    if ((void **)(a1 + 1128) != v5)
    {
      int v6 = *((unsigned __int8 *)v5 + 144);
      *(unsigned char *)(a1 + 1170) = v6;
      int v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = "blocked";
        if (!v6) {
          int v8 = "unblocked";
        }
        int v9 = 136315138;
        unint64_t v10 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Received entitlement block status %s", (uint8_t *)&v9, 0xCu);
      }
      sub_100BE2880(a1);
    }
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      if (v2 > 2) {
        int v4 = "???";
      }
      else {
        int v4 = off_101A45DB0[v2];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v4;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Recieved entitlement event when not monitoring, %s", (uint8_t *)__p, 0xCu);
    }
  }
}

void sub_100BE1C38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_100BE1C5C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1152);
  if (v1)
  {
    int v3 = *(_DWORD *)(a1 + 168);
    uint64_t v4 = a1 + 1152;
    do
    {
      int v5 = *(_DWORD *)(v1 + 28);
      BOOL v6 = v5 < v3;
      if (v5 >= v3) {
        int v7 = (uint64_t *)v1;
      }
      else {
        int v7 = (uint64_t *)(v1 + 8);
      }
      if (!v6) {
        uint64_t v4 = v1;
      }
      uint64_t v1 = *v7;
    }
    while (*v7);
    if (v4 != a1 + 1152 && v3 >= *(_DWORD *)(v4 + 28))
    {
      int v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = *(unsigned __int8 *)(v4 + 32);
        int v10 = *(unsigned __int8 *)(v4 + 33);
        v15[0] = 67109634;
        v15[1] = v9;
        __int16 v16 = 1024;
        int v17 = v10;
        __int16 v18 = 2080;
        uint64_t v19 = asString();
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Received Reject cause code: PS: %d, CS: %d, Rat: %s", (uint8_t *)v15, 0x18u);
      }
      unsigned int v11 = *(_DWORD *)(v4 + 36);
      BOOL v6 = v11 > 0xB;
      int v12 = (1 << v11) & 0x838;
      if (v6 || v12 == 0)
      {
        if (*(unsigned char *)(a1 + 1169)) {
          char v14 = 1;
        }
        else {
          char v14 = sub_100BE2B2C(a1);
        }
        *(unsigned char *)(a1 + 1169) = v14;
      }
    }
  }
}

void sub_100BE1DB4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 244)) {
    goto LABEL_10;
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 160);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 152);
      if (v5)
      {
        BOOL v6 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)xpc_object_t v37 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Notify backoff timer expiry.", v37, 2u);
        }
        (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
  if (*(unsigned char *)(a1 + 244) || !*(unsigned char *)(a1 + 1169) || *(unsigned char *)(a1 + 1168))
  {
LABEL_10:
    int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = printers::asString((printers *)(a1 + 1169), v8);
      uint64_t v11 = printers::asString((printers *)(a1 + 1168), v10);
      *(_DWORD *)xpc_object_t v37 = 136315394;
      *(void *)&uint8_t v37[4] = v9;
      *(_WORD *)&v37[12] = 2080;
      *(void *)&v37[14] = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Reject cause code: %s - ecall in progress %s", v37, 0x16u);
    }
    *(unsigned char *)(a1 + 244) = 0;
    sub_100BE221C(a1, 3);
    sub_10045EEC8(a1, 0x100u);
    return;
  }
  if (*(unsigned char *)(a1 + 1172))
  {
    uint64_t v12 = *(void *)(a1 + 272);
    uint64_t v13 = *(void *)(a1 + 280);
    if (v12 != v13)
    {
      while (1)
      {
        uint64_t v14 = *(unsigned __int8 *)(v12 + 95);
        if ((v14 & 0x80u) == 0) {
          uint64_t v15 = *(unsigned __int8 *)(v12 + 95);
        }
        else {
          uint64_t v15 = *(void *)(v12 + 80);
        }
        uint64_t v16 = *(unsigned __int8 *)(a1 + 231);
        int v17 = (char)v16;
        if ((v16 & 0x80u) != 0) {
          uint64_t v16 = *(void *)(a1 + 216);
        }
        if (v15 == v16)
        {
          if (v17 >= 0) {
            __int16 v18 = (unsigned __int8 *)(a1 + 208);
          }
          else {
            __int16 v18 = *(unsigned __int8 **)(a1 + 208);
          }
          if ((v14 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)(v12 + 72), v18, *(void *)(v12 + 80)))
            {
LABEL_34:
              if (subscriber::isPhySimDisabled()) {
                goto LABEL_68;
              }
            }
          }
          else
          {
            if (!*(unsigned char *)(v12 + 95)) {
              goto LABEL_34;
            }
            uint64_t v19 = 0;
            while (*(unsigned __int8 *)(v12 + v19 + 72) == v18[v19])
            {
              if (v14 == ++v19) {
                goto LABEL_34;
              }
            }
          }
        }
        v12 += 168;
        if (v12 == v13) {
          goto LABEL_63;
        }
      }
    }
    goto LABEL_63;
  }
  uint64_t v20 = *(void *)(a1 + 248);
  uint64_t v21 = *(void *)(a1 + 256);
  if (v20 != v21)
  {
    char v22 = 0;
    do
    {
      if (*(unsigned char *)(v20 + 80))
      {
        uint64_t v23 = *(void *)(v20 + 56);
        uint64_t v24 = *(void *)(v20 + 64);
        if (v23 != v24)
        {
          int v25 = *(char *)(a1 + 231);
          if (v25 >= 0) {
            uint64_t v26 = *(unsigned __int8 *)(a1 + 231);
          }
          else {
            uint64_t v26 = *(void *)(a1 + 216);
          }
          do
          {
            uint64_t v27 = *(unsigned __int8 *)(v23 + 39);
            if ((v27 & 0x80u) == 0) {
              uint64_t v28 = *(unsigned __int8 *)(v23 + 39);
            }
            else {
              uint64_t v28 = *(void *)(v23 + 24);
            }
            if (v28 == v26)
            {
              if (v25 >= 0) {
                uint64_t v29 = (unsigned __int8 *)(a1 + 208);
              }
              else {
                uint64_t v29 = *(unsigned __int8 **)(a1 + 208);
              }
              if ((v27 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v23 + 16), v29, *(void *)(v23 + 24)))
                {
LABEL_60:
                  v22 |= *(unsigned char *)(v23 + 89) != 0;
                  break;
                }
              }
              else
              {
                if (!*(unsigned char *)(v23 + 39)) {
                  goto LABEL_60;
                }
                uint64_t v30 = 0;
                while (*(unsigned __int8 *)(v23 + v30 + 16) == v29[v30])
                {
                  if (v27 == ++v30) {
                    goto LABEL_60;
                  }
                }
              }
            }
            v23 += 216;
          }
          while (v23 != v24);
        }
      }
      v20 += 88;
    }
    while (v20 != v21);
    if (v22)
    {
LABEL_63:
      uint64_t v31 = *(std::__shared_weak_count **)(a1 + 160);
      if (v31)
      {
        xpc_object_t v32 = std::__shared_weak_count::lock(v31);
        if (v32)
        {
          xpc_object_t v33 = v32;
          uint64_t v34 = *(void *)(a1 + 152);
          if (v34)
          {
            sub_100BE221C(a1, 2);
            uint64_t v35 = *(void *)(a1 + 172);
            uint64_t v36 = *(void *)(a1 + 180);
            *(_OWORD *)xpc_object_t v37 = *(_OWORD *)(a1 + 192);
            if (*(char *)(a1 + 231) < 0)
            {
              sub_10004FC84(&v37[16], *(void **)(a1 + 208), *(void *)(a1 + 216));
            }
            else
            {
              *(_OWORD *)&v37[16] = *(_OWORD *)(a1 + 208);
              uint64_t v38 = *(void *)(a1 + 224);
            }
            char v39 = *(unsigned char *)(a1 + 232);
            (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *))(*(void *)v34 + 32))(v34, v35, v36, v37);
            if (SHIBYTE(v38) < 0) {
              operator delete(*(void **)&v37[16]);
            }
          }
          sub_10004D2C8(v33);
        }
      }
      return;
    }
  }
LABEL_68:

  sub_100BE231C(a1);
}

void sub_100BE21E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_100BE221C(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(int *)(a1 + 240);
    if (v5 > 3) {
      BOOL v6 = "???";
    }
    else {
      BOOL v6 = off_101A45DC8[v5];
    }
    if ((a2 - 1) > 2) {
      int v7 = "???";
    }
    else {
      int v7 = off_101A45DE8[a2 - 1];
    }
    int v8 = 136315394;
    uint64_t v9 = v6;
    __int16 v10 = 2080;
    uint64_t v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Attach MonitorMode state:[%s] -> [%s]", (uint8_t *)&v8, 0x16u);
  }
  *(_DWORD *)(a1 + 240) = a2;
}

void sub_100BE231C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 160);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 152);
      if (v5)
      {
        sub_100BE221C(a1, 1);
        uint64_t v6 = *(void *)(a1 + 172);
        uint64_t v7 = *(void *)(a1 + 180);
        long long v8 = *(_OWORD *)(a1 + 192);
        if (*(char *)(a1 + 231) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 208), *(void *)(a1 + 216));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 208);
          uint64_t v10 = *(void *)(a1 + 224);
        }
        char v11 = *(unsigned char *)(a1 + 232);
        (*(void (**)(uint64_t, uint64_t, uint64_t, long long *))(*(void *)v5 + 24))(v5, v6, v7, &v8);
        if (SHIBYTE(v10) < 0) {
          operator delete((void *)__p);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100BE243C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_100BE2468(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 248;
  if ((uint64_t *)v4 != a2) {
    sub_1003DB294(v4, *a2, a2[1], 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 3));
  }
  if (*(unsigned char *)(a1 + 1172))
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Skip handling vinyl info for physical SIM monitor mode", buf, 2u);
    }
    return;
  }
  uint64_t v6 = *(void *)(a1 + 248);
  uint64_t v7 = *(void *)(a1 + 256);
  if (v6 == v7) {
    return;
  }
  do
  {
    if (!*(unsigned char *)(v6 + 80)) {
      goto LABEL_38;
    }
    uint64_t v9 = *(void *)(v6 + 56);
    uint64_t v8 = *(void *)(v6 + 64);
    if (v9 == v8) {
      goto LABEL_38;
    }
    int v10 = *(char *)(a1 + 231);
    if (v10 >= 0) {
      uint64_t v11 = *(unsigned __int8 *)(a1 + 231);
    }
    else {
      uint64_t v11 = *(void *)(a1 + 216);
    }
    while (1)
    {
      uint64_t v12 = *(unsigned __int8 *)(v9 + 39);
      if ((v12 & 0x80u) == 0) {
        uint64_t v13 = *(unsigned __int8 *)(v9 + 39);
      }
      else {
        uint64_t v13 = *(void *)(v9 + 24);
      }
      if (v13 != v11) {
        goto LABEL_26;
      }
      uint64_t v14 = v10 >= 0 ? (unsigned __int8 *)(a1 + 208) : *(unsigned __int8 **)(a1 + 208);
      if ((v12 & 0x80) != 0) {
        break;
      }
      if (!*(unsigned char *)(v9 + 39)) {
        goto LABEL_28;
      }
      uint64_t v15 = 0;
      while (*(unsigned __int8 *)(v9 + v15 + 16) == v14[v15])
      {
        if (v12 == ++v15) {
          goto LABEL_28;
        }
      }
LABEL_26:
      v9 += 216;
      if (v9 == v8) {
        goto LABEL_38;
      }
    }
    if (memcmp(*(const void **)(v9 + 16), v14, *(void *)(v9 + 24))) {
      goto LABEL_26;
    }
LABEL_28:
    uint64_t v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = "Active";
      if (!*(unsigned char *)(v9 + 89)) {
        int v17 = "Disabled";
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v20 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Received Vinyl Info profile status: %s", buf, 0xCu);
    }
    int v18 = *(_DWORD *)(a1 + 240);
    if (v18 == 1 && *(unsigned char *)(v9 + 89))
    {
      *(unsigned char *)(a1 + 1169) = 0;
      sub_100BE221C(a1, 3);
      unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | 0x100;
      sub_10045EEC8(a1, v2);
    }
    else if (v18 == 2 && !*(unsigned char *)(v9 + 89))
    {
      sub_100BE231C(a1);
    }
LABEL_38:
    v6 += 88;
  }
  while (v6 != v7);
}

void sub_100BE26D0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = a1 + 272;
  if ((uint64_t *)v3 != a2) {
    sub_1003DB990(v3, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
  }
  if (!*(unsigned char *)(a1 + 1172)) {
    return;
  }
  uint64_t v5 = *(void *)(a1 + 272);
  uint64_t v4 = *(void *)(a1 + 280);
  if (v5 == v4) {
    return;
  }
  int v6 = *(char *)(a1 + 231);
  if (v6 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 231);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 216);
  }
  while (1)
  {
    uint64_t v8 = *(unsigned __int8 *)(v5 + 95);
    if ((v8 & 0x80u) == 0) {
      uint64_t v9 = *(unsigned __int8 *)(v5 + 95);
    }
    else {
      uint64_t v9 = *(void *)(v5 + 80);
    }
    if (v9 != v7) {
      goto LABEL_22;
    }
    int v10 = v6 >= 0 ? (unsigned __int8 *)(a1 + 208) : *(unsigned __int8 **)(a1 + 208);
    if ((v8 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v5 + 95)) {
      goto LABEL_24;
    }
    uint64_t v11 = 0;
    while (*(unsigned __int8 *)(v5 + v11 + 72) == v10[v11])
    {
      if (v8 == ++v11) {
        goto LABEL_24;
      }
    }
LABEL_22:
    v5 += 168;
    if (v5 == v4) {
      return;
    }
  }
  if (memcmp(*(const void **)(v5 + 72), v10, *(void *)(v5 + 80))) {
    goto LABEL_22;
  }
LABEL_24:
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Received sim info update", v14, 2u);
  }
  int v13 = *(_DWORD *)(a1 + 240);
  if (v13 == 1)
  {
    if (subscriber::isSimReady())
    {
      *(unsigned char *)(a1 + 1169) = 0;
      sub_100BE221C(a1, 3);
      sub_10045EEC8(a1, 0x100u);
      return;
    }
    int v13 = *(_DWORD *)(a1 + 240);
  }
  if (v13 == 2)
  {
    if (subscriber::isPhySimDisabled()) {
      sub_100BE231C(a1);
    }
  }
}

void sub_100BE2880(uint64_t a1)
{
  void (***v15)(uint64_t *__return_ptr, void, uint8_t *);
  char v16;
  char v17;
  NSObject *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint8_t buf[16];
  uint64_t v22;
  unint64_t v23;

  unsigned int v2 = *(_DWORD *)(a1 + 320);
  BOOL v3 = v2 > 0xB;
  int v4 = (1 << v2) & 0x838;
  if (!v3 && v4 != 0)
  {
    int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Ignore registration status on CDMA/Unknown RAT", buf, 2u);
    }
    return;
  }
  if ((*(_DWORD *)(a1 + 328) & 0xFFFFFFFE) == 4 && !*(unsigned char *)(a1 + 1170))
  {
    memset(buf, 0, sizeof(buf));
    char v22 = 0;
    if (*(char *)(a1 + 231) < 0)
    {
      sub_10004FC84(buf, *(void **)(a1 + 208), *(void *)(a1 + 216));
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)(a1 + 208);
      char v22 = *(void *)(a1 + 224);
    }
    if (!*(unsigned char *)(a1 + 1171)) {
      goto LABEL_27;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    uint64_t v8 = ServiceMap;
    if ((v9 & 0x8000000000000000) != 0)
    {
      int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        unint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v23 = v9;
    int v13 = sub_10004D37C(&v8[1].__m_.__sig, &v23);
    if (v13)
    {
      uint64_t v15 = (void (***)(uint64_t *__return_ptr, void, uint8_t *))v13[3];
      uint64_t v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        uint64_t v16 = 0;
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    uint64_t v16 = 1;
LABEL_22:
    (**v15)(&v19, v15, buf);
    int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 544))(v19);
    if (v20) {
      sub_10004D2C8(v20);
    }
    if ((v16 & 1) == 0) {
      sub_10004D2C8(v14);
    }
    if ((v17 & 1) == 0)
    {
      int v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v19) = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I SIM is not authenticated", (uint8_t *)&v19, 2u);
      }
      goto LABEL_28;
    }
LABEL_27:
    sub_10045EEC8(a1, 0x101u);
LABEL_28:
    if (SHIBYTE(v22) < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_100BE2AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BE2B2C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 1144);
  unsigned int v2 = (void *)(a1 + 1152);
  if (v1 == (void *)(a1 + 1152)) {
    return 0;
  }
  while (1)
  {
    if (*((_DWORD *)v1 + 7) != *(_DWORD *)(a1 + 168)) {
      goto LABEL_26;
    }
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *((unsigned __int8 *)v1 + 32);
      int v6 = *((unsigned __int8 *)v1 + 33);
      uint64_t v7 = asString();
      *(_DWORD *)long long buf = 67109634;
      *(_DWORD *)&uint8_t buf[4] = v5;
      LOWORD(v26) = 1024;
      *(_DWORD *)((char *)&v26 + 2) = v6;
      HIWORD(v26) = 2080;
      uint64_t v27 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I NetworkRejectCauseCodePS: %d, NetworkRejectCauseCodeCS: %d, Rat: %s", buf, 0x18u);
    }
    __int32 v8 = *((unsigned __int8 *)v1 + 33);
    if (v8 - 2) < 7 && ((0x73u >> (v8 - 2))) {
      return 1;
    }
    __int32 v9 = *((unsigned __int8 *)v1 + 32);
    if (v9 - 2) < 7 && ((0x73u >> (v9 - 2))) {
      return 1;
    }
    if (!*(unsigned char *)(a1 + 1200)) {
      goto LABEL_26;
    }
    *(void *)long long buf = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    sub_100448664(buf, *(const void **)(a1 + 1176), *(void *)(a1 + 1184), (uint64_t)(*(void *)(a1 + 1184) - *(void *)(a1 + 1176)) >> 2);
    int v10 = v26;
    uint64_t v11 = wmemchr(*(__int32 **)buf, v8, ((uint64_t)v26 - *(void *)buf) >> 2);
    if (v11) {
      int v10 = v11;
    }
    if (v10 != v26)
    {
      unsigned int v12 = *(NSObject **)(a1 + 40);
      int v13 = 0;
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_23;
      }
      *(_DWORD *)uint64_t v23 = 67109120;
      __int32 v24 = v8;
      uint64_t v14 = v12;
      uint64_t v15 = "#I CS reject cause code [%d] is a cb configured code";
LABEL_21:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v15, v23, 8u);
      int v13 = 0;
      goto LABEL_23;
    }
    uint64_t v16 = wmemchr(*(__int32 **)buf, v9, ((uint64_t)v10 - *(void *)buf) >> 2);
    if (v16) {
      char v17 = v16;
    }
    else {
      char v17 = v10;
    }
    if (v17 != v26)
    {
      int v18 = *(NSObject **)(a1 + 40);
      int v13 = 0;
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_23;
      }
      *(_DWORD *)uint64_t v23 = 67109120;
      __int32 v24 = v9;
      uint64_t v14 = v18;
      uint64_t v15 = "#I PS reject cause code [%d] is a cb configured code";
      goto LABEL_21;
    }
    int v13 = 1;
LABEL_23:
    if (*(void *)buf)
    {
      uint64_t v26 = *(__int32 **)buf;
      operator delete(*(void **)buf);
    }
    if (!v13) {
      return 1;
    }
LABEL_26:
    uint64_t v19 = (void *)v1[1];
    if (v19)
    {
      do
      {
        uint64_t v20 = v19;
        uint64_t v19 = (void *)*v19;
      }
      while (v19);
    }
    else
    {
      do
      {
        uint64_t v20 = (void *)v1[2];
        BOOL v21 = *v20 == (void)v1;
        uint64_t v1 = v20;
      }
      while (!v21);
    }
    uint64_t v1 = v20;
    if (v20 == v2) {
      return 0;
    }
  }
}

void sub_100BE2DE8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BE2E20(uint64_t a1)
{
}

uint64_t sub_100BE2E3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BE2E80(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_100BE2EAC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v40 = a1;
  uint64_t v41 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection(&v42, *(Registry **)(v1 + 16));
  ctu::RestModule::connect();
  if (v43) {
    sub_10004D2C8(v43);
  }
  if (*(_DWORD *)(v2 + 168) == 1) {
    BOOL v3 = "/cc/props/reg_net_info1";
  }
  else {
    BOOL v3 = "/cc/props/reg_net_info2";
  }
  *(void *)(v2 + 312) = v3;
  sub_100058DB0(&__p, v3);
  int v4 = (void **)operator new(0x28uLL);
  NSObject *v4 = off_101A45BC0;
  v4[1] = (void *)(v2 + 312);
  _DWORD v4[2] = (void *)v2;
  uint64_t v4[3] = sub_100BE196C;
  void v4[4] = 0;
  xpc_object_t v50 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v47);
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)__p.n128_u64[0]);
  }
  if (*(unsigned char *)(v2 + 1171))
  {
    sub_100058DB0(&__p, "/cc/props/carrier_entitlements_info");
    int v5 = (void **)operator new(0x28uLL);
    *int v5 = off_101A45C40;
    v5[1] = (void *)(v2 + 1120);
    _OWORD v5[2] = (void *)v2;
    v5[3] = sub_100BE1A98;
    void v5[4] = 0;
    xpc_object_t v50 = v5;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v47);
    if (SHIBYTE(v45) < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
  }
  else
  {
    *(unsigned char *)(v2 + 1170) = 0;
  }
  sub_100058DB0(&__p, "/cc/props/network_rejects");
  int v6 = (void **)operator new(0x28uLL);
  *int v6 = off_101A45CC0;
  v6[1] = (void *)(v2 + 1144);
  uint64_t v6[2] = (void *)v2;
  void v6[3] = sub_100BE1C5C;
  void v6[4] = 0;
  xpc_object_t v50 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v47);
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)__p.n128_u64[0]);
  }
  sub_100058DB0(&__p, "/cc/props/emergency_call_in_progress");
  xpc_object_t v47 = off_101A45D40;
  uint64_t v48 = (void *)(v2 + 1168);
  xpc_object_t v50 = &v47;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v47);
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)__p.n128_u64[0]);
  }
  uint64_t v7 = *(unsigned int *)(v2 + 168);
  unint64_t v45 = 0;
  __n128 __p = 0uLL;
  __int32 v8 = operator new(0x10uLL);
  uint64_t v48 = v8 + 2;
  xpc_object_t v49 = v8 + 2;
  *__int32 v8 = @"CellularPlanProvisioningSettings";
  v8[1] = @"AdditionalRejectCauseCodesForAttachMonitorMode";
  xpc_object_t v47 = v8;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 48));
  int v10 = ServiceMap;
  if (v11 < 0)
  {
    unsigned int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CFArrayRef theArray = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)theArray);
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_24:
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_55;
    }
    goto LABEL_25;
  }
  uint64_t v17 = v15[3];
  uint64_t v16 = (std::__shared_weak_count *)v15[4];
  if (!v16) {
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
  if (!v17) {
    goto LABEL_55;
  }
LABEL_25:
  *(void *)CFArrayRef theArray = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v17 + 104))(&v46, v17, v7, 1, &v47, 0, 0);
  sub_100044D6C(theArray, &v46);
  sub_1000577C4(&v46);
  if (*(void *)theArray) {
    uint64_t v19 = sub_100083F10;
  }
  else {
    uint64_t v19 = 0;
  }
  if (v19 && CFArrayGetCount(*(CFArrayRef *)theArray))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)theArray);
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFDictionaryRef ValueAtIndex = (int *)CFArrayGetValueAtIndex(*(CFArrayRef *)theArray, i);
        __int32 v24 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v25 = CFGetTypeID(ValueAtIndex);
          if (v25 == CFNumberGetTypeID()) {
            uint64_t v26 = v24;
          }
          else {
            uint64_t v26 = 0;
          }
        }
        else
        {
          uint64_t v26 = 0;
        }
        LODWORD(v46) = 0;
        ctu::cf::assign((ctu::cf *)&v46, v26, v23);
        int v27 = (int)v46;
        unint64_t v28 = __p.n128_u64[1];
        if (__p.n128_u64[1] >= v45)
        {
          uint64_t v30 = (void *)__p.n128_u64[0];
          uint64_t v31 = (uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) >> 2;
          unint64_t v32 = v31 + 1;
          if ((unint64_t)(v31 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v33 = v45 - __p.n128_u64[0];
          if ((uint64_t)(v45 - __p.n128_u64[0]) >> 1 > v32) {
            unint64_t v32 = v33 >> 1;
          }
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v34 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v34 = v32;
          }
          if (v34)
          {
            uint64_t v35 = (char *)sub_10005ECD8((uint64_t)&v45, v34);
            unint64_t v28 = __p.n128_u64[1];
            uint64_t v30 = (void *)__p.n128_u64[0];
          }
          else
          {
            uint64_t v35 = 0;
          }
          uint64_t v36 = &v35[4 * v31];
          *(_DWORD *)uint64_t v36 = v27;
          unint64_t v29 = (unint64_t)(v36 + 4);
          while ((void *)v28 != v30)
          {
            int v37 = *(_DWORD *)(v28 - 4);
            v28 -= 4;
            *((_DWORD *)v36 - 1) = v37;
            v36 -= 4;
          }
          __p.n128_u64[0] = (unint64_t)v36;
          __p.n128_u64[1] = v29;
          unint64_t v45 = (unint64_t)&v35[4 * v34];
          if (v30) {
            operator delete(v30);
          }
        }
        else
        {
          *(_DWORD *)__p.n128_u64[1] = v46;
          unint64_t v29 = v28 + 4;
        }
        __p.n128_u64[1] = v29;
      }
    }
    sub_100044D00((const void **)theArray);
LABEL_55:
    uint64_t v38 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CFArrayRef theArray = 134217984;
      *(void *)&theArray[4] = (uint64_t)(__p.n128_u64[1] - __p.n128_u64[0]) >> 2;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I [%lu] additional fatal reject cause codes are defined in CB", theArray, 0xCu);
    }
    if ((v18 & 1) == 0) {
      goto LABEL_58;
    }
    goto LABEL_59;
  }
  sub_100044D00((const void **)theArray);
  if ((v18 & 1) == 0) {
LABEL_58:
  }
    sub_10004D2C8(v16);
LABEL_59:
  if (v47)
  {
    uint64_t v48 = v47;
    operator delete(v47);
  }
  sub_100195D74(v2 + 1176, &__p);
  if (__p.n128_u64[0])
  {
    __p.n128_u64[1] = __p.n128_u64[0];
    operator delete((void *)__p.n128_u64[0]);
  }
  sub_100BE3560(&v41);
  return sub_100046B58((uint64_t *)&v40);
}

void sub_100BE3474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,const void *a24)
{
  sub_100044D00(&a24);
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  if (__p)
  {
    a21 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  sub_100BE3560(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BE3560(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    BOOL v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      sub_10004D2C8(v3);
    }
    operator delete();
  }
  return result;
}

void sub_100BE35C4()
{
}

__n128 sub_100BE35D8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A45BC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BE362C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A45BC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BE3664(void *a1, const xpc::object *a2)
{
  read_rest_value((RegisteredNetworkInfo *)(a1[1] + 8), a2);
  BOOL v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    BOOL v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100BE36E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BE3724()
{
}

void sub_100BE3734()
{
}

__n128 sub_100BE3748(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A45C40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BE379C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A45C40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BE37D4(uint64_t *a1, xpc_object_t *a2)
{
  sub_10031A644(a1[1], a2);
  BOOL v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    BOOL v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100BE3850(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BE3890()
{
}

void sub_100BE38A0()
{
}

__n128 sub_100BE38B4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A45CC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100BE3908(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A45CC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BE3940(uint64_t *a1, xpc_object_t *a2)
{
  sub_1004CF7D4(a1[1], a2);
  BOOL v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    BOOL v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100BE39BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BE39FC()
{
}

void sub_100BE3A0C()
{
}

void *sub_100BE3A20(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A45D40;
  result[1] = v3;
  return result;
}

uint64_t sub_100BE3A68(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A45D40;
  a2[1] = v2;
  return result;
}

uint64_t sub_100BE3A94(uint64_t a1, xpc *this, BOOL a3)
{
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_100BE3AC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BE3B04()
{
}

void *DataConnectionAgentCarrierSpace::DataConnectionAgentCarrierSpace(void *a1, uint64_t *a2, int a3, uint64_t a4, id *a5, void *a6)
{
  uint64_t v7 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  int v10 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  DataConnectionAgent::DataConnectionAgent((uint64_t)a1, (uint64_t *)off_101A46030, &v9, a3, (uint64_t)"DATA.agent.carrierspace", a4, a5, a6);
  if (v10) {
    sub_10004D2C8(v10);
  }
  *a1 = off_101A45E38;
  a1[3] = off_101A45F48;
  a1[13] = off_101A46010;
  a1[41] = 0;
  a1[42] = 0;
  a1[40] = 0;
  return a1;
}

void sub_100BE3C0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  PersonalitySpecific::~PersonalitySpecific(v10);
  _Unwind_Resume(a1);
}

void sub_100BE3C2C(uint64_t a1)
{
  *(void *)a1 = off_101A45E38;
  *(void *)(a1 + 24) = off_101A45F48;
  *(void *)(a1 + 104) = off_101A46010;
  uint64_t v2 = *(void **)(a1 + 320);
  if (v2)
  {
    *(void *)(a1 + 320) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 328);
  if (v3)
  {
    *(void *)(a1 + 328) = 0;
  }
  uint64_t v4 = *(void **)(a1 + 336);
  if (v4)
  {
    *(void *)(a1 + 336) = 0;

    uint64_t v4 = *(void **)(a1 + 336);
  }

  DataConnectionAgent::~DataConnectionAgent((DataConnectionAgent *)a1, (uint64_t *)off_101A46030);
}

void sub_100BE3D0C(uint64_t a1)
{
  sub_100BE3C2C(a1);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100BE3D34(uint64_t a1)
{
  sub_100BE3C2C(a1 - 24);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100BE3D60(uint64_t a1)
{
  sub_100BE3C2C(a1 - 104);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100BE3D8C(uint64_t a1)
{
  sub_100BE3C2C(a1);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_100BE3DC8(uint64_t a1)
{
}

void sub_100BE3DD0(uint64_t a1)
{
}

void sub_100BE3DD8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1 + 144;
    if (*(char *)(a1 + 167) < 0) {
      uint64_t v3 = *(void *)(a1 + 144);
    }
    int v8 = 136446210;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I NWAgent %{public}s: unsetPolicyOverride", (uint8_t *)&v8, 0xCu);
  }
  uint64_t v4 = *(void **)(a1 + 320);
  if (v4)
  {
    *(void *)(a1 + 320) = 0;
  }
  int v5 = *(void **)(a1 + 328);
  if (v5)
  {
    *(void *)(a1 + 328) = 0;
  }
  int v6 = *(void **)(a1 + 336);
  if (v6)
  {
    *(void *)(a1 + 336) = 0;

    uint64_t v7 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I unregistered fallback policy", (uint8_t *)&v8, 2u);
    }
  }
}

void sub_100BE3EF4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B10250, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B10250))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B10248, kCtLoggingSystemName, "nr.obs");
    __cxa_guard_release(&qword_101B10250);
  }
}

void sub_100BE3F74(_Unwind_Exception *a1)
{
}

void sub_100BE40B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100BE4118(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  int v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)NanoRegistryObserver;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_100BE4280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100BE42A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_100BE4340;
  _OWORD v7[3] = &unk_101A04440;
  void v7[4] = v4;
  id v8 = v3;
  int v5 = *(NSObject **)(v4 + 8);
  id v6 = v3;
  dispatch_async(v5, v7);
}

id sub_100BE4340(uint64_t a1)
{
  return [*(id *)(a1 + 32) sendInitialUpdate:*(void *)(a1 + 40)];
}

void sub_100BE43A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100BE4450(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  id v2 = [*(id *)(a1 + 40) userInfo];
  objc_msgSend(v1, "didEnterCompatibilityState_sync:");
}

void sub_100BE44A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100BE4610(_Unwind_Exception *a1)
{
  sub_10004D2C8(v3);

  _Unwind_Resume(a1);
}

void sub_100BE46F4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  id v2 = [*(id *)(a1 + 40) userInfo];
  objc_msgSend(v1, "didDeviceUnpair_sync:");
}

void sub_100BE4748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100BE48B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_100BE49C0(uint64_t a1)
{
  sub_100BE3EF4();
  id v2 = qword_101B10248;
  if (os_log_type_enabled((os_log_t)qword_101B10248, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I propertyDidChange for device: %@", buf, 0xCu);
  }
  uint64_t v4 = *(void **)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 32);
  int v5 = +[NSArray arrayWithObjects:&v6 count:1];
  [v4 notifyDevicesUpdated:v5];
}

void sub_100BE4A9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100BE4BBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100BE5308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,xpc_object_t object,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,char a39)
{
  sub_10004D2C8(v39);
  *(void *)(v40 - 256) = &a36;
  sub_100150960((void ***)(v40 - 256));

  _Unwind_Resume(a1);
}

uint64_t sub_100BE5478(uint64_t a1, NSObject **a2, void *a3, void *a4)
{
  *(void *)a1 = off_101A464E8;
  uint64_t v8 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, "cp.consent");
  sub_100BE55B0(v8, a2, &v13);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  *(void *)a1 = off_101A46470;
  *(void *)(a1 + 48) = *a3;
  uint64_t v9 = a3[1];
  *(void *)(a1 + 56) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = *a4;
  uint64_t v10 = a4[1];
  *(void *)(a1 + 72) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  *(void *)(a1 + 80) = dispatch_queue_create("cp.consent", v11);
  *(unsigned char *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 384) = 0;
  return a1;
}

void sub_100BE559C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100BE55B0(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  int v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100BE5618(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100BE563C(uint64_t a1)
{
  *(void *)a1 = off_101A46470;
  if (*(unsigned char *)(a1 + 384)) {
    sub_100BE74FC(a1 + 88);
  }
  id v2 = *(NSObject **)(a1 + 80);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100BE56C8(uint64_t a1)
{
  sub_100BE563C(a1);

  operator delete();
}

uint64_t sub_100BE5700(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, long long *a5, uint64_t *a6, long long *a7, long long *a8, long long *a9, char a10, uint64_t a11)
{
  if (*(unsigned char *)(a1 + 384))
  {
    if (sub_1003D5918(a1 + 112, a4)
      && (*(void *)(a1 + 200) == *a6 ? (BOOL v17 = *(void *)(a1 + 208) == a6[1]) : (BOOL v17 = 0), v17))
    {
      uint64_t v40 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = *(void *)(a4 + 16);
        uint64_t v42 = a4 + 16;
        uint64_t v41 = v43;
        if (*(char *)(v42 + 23) >= 0) {
          uint64_t v41 = v42;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v41;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I ignore duplicate consent request:%s", buf, 0xCu);
      }
    }
    else
    {
      char v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = (void *)(a1 + 128);
        if (*(char *)(a1 + 151) < 0) {
          uint64_t v19 = (void *)*v19;
        }
        uint64_t v20 = a4 + 16;
        if (*(char *)(a4 + 39) < 0) {
          uint64_t v20 = *(void *)(a4 + 16);
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v19;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v20;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#E consent ongoing. consent iccid:%s, iccid: %s", buf, 0x16u);
      }
      BOOL v21 = *(std::__shared_weak_count **)(a1 + 72);
      if (v21)
      {
        char v22 = std::__shared_weak_count::lock(v21);
        if (v22)
        {
          CFNumberRef v23 = v22;
          uint64_t v24 = *(void *)(a1 + 64);
          if (v24)
          {
            if (*(char *)(a2 + 23) < 0)
            {
              sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
            }
            else
            {
              *(_OWORD *)long long __dst = *(_OWORD *)a2;
              uint64_t v119 = *(void *)(a2 + 16);
            }
            if (*(char *)(a4 + 39) < 0)
            {
              sub_10004FC84(v116, *(void **)(a4 + 16), *(void *)(a4 + 24));
            }
            else
            {
              *(_OWORD *)uint64_t v116 = *(_OWORD *)(a4 + 16);
              uint64_t v117 = *(void *)(a4 + 32);
            }
            uint64_t v45 = *a3;
            uint64_t v44 = a3[1];
            uint64_t v47 = *a6;
            uint64_t v46 = a6[1];
            if (*((char *)a7 + 23) < 0)
            {
              sub_10004FC84(__p, *(void **)a7, *((void *)a7 + 1));
            }
            else
            {
              *(_OWORD *)__n128 __p = *a7;
              uint64_t v115 = *((void *)a7 + 2);
            }
            (*(void (**)(uint64_t, void **, void **, uint64_t, uint64_t, uint64_t, uint64_t, void **, __int16))(*(void *)v24 + 16))(v24, __dst, v116, v45, v44, v47, v46, __p, 3332);
            if (SHIBYTE(v115) < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v117) < 0) {
              operator delete(v116[0]);
            }
            if (SHIBYTE(v119) < 0) {
              operator delete(__dst[0]);
            }
          }
          sub_10004D2C8(v23);
        }
      }
    }
    return 1;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(buf, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long buf = *(_OWORD *)a2;
    *(void *)&uint8_t buf[16] = *(void *)(a2 + 16);
  }
  long long v144 = *(_OWORD *)a4;
  if (*(char *)(a4 + 39) < 0)
  {
    sub_10004FC84(&v145, *(void **)(a4 + 16), *(void *)(a4 + 24));
  }
  else
  {
    long long v145 = *(_OWORD *)(a4 + 16);
    uint64_t v146 = *(void *)(a4 + 32);
  }
  char v147 = *(unsigned char *)(a4 + 40);
  long long v148 = *(_OWORD *)a3;
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(&v149, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v149 = *a5;
    uint64_t v150 = *((void *)a5 + 2);
  }
  long long v151 = *(_OWORD *)a6;
  if (*((char *)a7 + 23) < 0)
  {
    sub_10004FC84(&v152, *(void **)a7, *((void *)a7 + 1));
  }
  else
  {
    long long v152 = *a7;
    uint64_t v153 = *((void *)a7 + 2);
  }
  if (*((char *)a8 + 23) < 0)
  {
    sub_10004FC84(&v154, *(void **)a8, *((void *)a8 + 1));
  }
  else
  {
    long long v154 = *a8;
    uint64_t v155 = *((void *)a8 + 2);
  }
  if (*((char *)a9 + 23) < 0)
  {
    sub_10004FC84(&v156, *(void **)a9, *((void *)a9 + 1));
  }
  else
  {
    long long v156 = *a9;
    uint64_t v157 = *((void *)a9 + 2);
  }
  int v27 = (void **)(a1 + 88);
  LOBYTE(v158[0]) = 0;
  unsigned __int8 v159 = 0;
  LOBYTE(v160) = 4;
  HIBYTE(v160) = a10;
  if (*(unsigned char *)(a1 + 384))
  {
    if (*(char *)(a1 + 111) < 0) {
      operator delete(*v27);
    }
    *(_OWORD *)int v27 = *(_OWORD *)buf;
    *(void *)(a1 + 104) = *(void *)&buf[16];
    uint8_t buf[23] = 0;
    buf[0] = 0;
    *(_OWORD *)(a1 + 112) = v144;
    unint64_t v28 = (void **)(a1 + 128);
    if (*(char *)(a1 + 151) < 0) {
      operator delete(*v28);
    }
    *(_OWORD *)unint64_t v28 = v145;
    *(void *)(a1 + 144) = v146;
    HIBYTE(v146) = 0;
    LOBYTE(v145) = 0;
    *(unsigned char *)(a1 + 152) = v147;
    *(_OWORD *)(a1 + 160) = v148;
    unint64_t v29 = (void **)(a1 + 176);
    if (*(char *)(a1 + 199) < 0) {
      operator delete(*v29);
    }
    *(_OWORD *)unint64_t v29 = v149;
    *(void *)(a1 + 192) = v150;
    HIBYTE(v150) = 0;
    LOBYTE(v149) = 0;
    *(_OWORD *)(a1 + 200) = v151;
    uint64_t v30 = (void **)(a1 + 216);
    if (*(char *)(a1 + 239) < 0) {
      operator delete(*v30);
    }
    *(_OWORD *)uint64_t v30 = v152;
    *(void *)(a1 + 232) = v153;
    HIBYTE(v153) = 0;
    LOBYTE(v152) = 0;
    uint64_t v31 = (void **)(a1 + 240);
    if (*(char *)(a1 + 263) < 0) {
      operator delete(*v31);
    }
    *(_OWORD *)uint64_t v31 = v154;
    *(void *)(a1 + 256) = v155;
    HIBYTE(v155) = 0;
    LOBYTE(v154) = 0;
    unint64_t v32 = (void **)(a1 + 264);
    if (*(char *)(a1 + 287) < 0) {
      operator delete(*v32);
    }
    *(_OWORD *)unint64_t v32 = v156;
    *(void *)(a1 + 280) = v157;
    HIBYTE(v157) = 0;
    LOBYTE(v156) = 0;
    uint64_t v33 = (const void **)(a1 + 288);
    if (*(unsigned __int8 *)(a1 + 368) == v159)
    {
      if (*(unsigned char *)(a1 + 368)) {
        sub_100BE7298(v33, v158);
      }
    }
    else if (*(unsigned char *)(a1 + 368))
    {
      sub_100BE7408(v33);
    }
    else
    {
      sub_100BE746C(v33, v158);
      *(unsigned char *)(a1 + 368) = 1;
    }
    *(_WORD *)(a1 + 376) = v160;
  }
  else
  {
    *(_OWORD *)int v27 = *(_OWORD *)buf;
    *(void *)(a1 + 104) = *(void *)&buf[16];
    memset(buf, 0, sizeof(buf));
    long long v34 = v145;
    *(_OWORD *)(a1 + 112) = v144;
    *(_OWORD *)(a1 + 128) = v34;
    *(void *)(a1 + 144) = v146;
    long long v145 = 0uLL;
    uint64_t v146 = 0;
    *(unsigned char *)(a1 + 152) = v147;
    long long v35 = v148;
    long long v36 = v149;
    *(void *)(a1 + 192) = v150;
    *(_OWORD *)(a1 + 160) = v35;
    *(_OWORD *)(a1 + 176) = v36;
    long long v149 = 0uLL;
    uint64_t v150 = 0;
    *(_OWORD *)(a1 + 200) = v151;
    long long v37 = v152;
    *(void *)(a1 + 232) = v153;
    *(_OWORD *)(a1 + 216) = v37;
    long long v152 = 0uLL;
    uint64_t v153 = 0;
    long long v38 = v154;
    *(void *)(a1 + 256) = v155;
    *(_OWORD *)(a1 + 240) = v38;
    long long v154 = 0uLL;
    uint64_t v155 = 0;
    long long v39 = v156;
    *(void *)(a1 + 280) = v157;
    *(_OWORD *)(a1 + 264) = v39;
    long long v156 = 0uLL;
    uint64_t v157 = 0;
    *(unsigned char *)(a1 + 288) = 0;
    *(unsigned char *)(a1 + 368) = 0;
    *(_WORD *)(a1 + 376) = v160;
    *(unsigned char *)(a1 + 384) = 1;
  }
  sub_100BE74FC((uint64_t)buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v48, *(Registry **)(a1 + 48));
  xpc_object_t v50 = ServiceMap;
  if (v51 < 0)
  {
    uint64_t v52 = (unsigned __int8 *)(v51 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v53 = 5381;
    do
    {
      uint64_t v51 = v53;
      unsigned int v54 = *v52++;
      uint64_t v53 = (33 * v53) ^ v54;
    }
    while (v54);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v51;
  int v55 = sub_10004D37C(&v50[1].__m_.__sig, (unint64_t *)buf);
  if (v55)
  {
    uint64_t v57 = v55[3];
    xpc_object_t v56 = (std::__shared_weak_count *)v55[4];
    if (v56)
    {
      atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v50);
      atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v56);
      char v59 = 0;
      if (!v57) {
        goto LABEL_81;
      }
LABEL_86:
      long long v61 = (std::mutex *)Registry::getServiceMap(v58, *(Registry **)(a1 + 48));
      uint64_t v62 = v61;
      if (v63 < 0)
      {
        uint64_t v64 = (unsigned __int8 *)(v63 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v65 = 5381;
        do
        {
          uint64_t v63 = v65;
          unsigned int v66 = *v64++;
          uint64_t v65 = (33 * v65) ^ v66;
        }
        while (v66);
      }
      std::mutex::lock(v61);
      *(void *)long long buf = v63;
      std::string::size_type v67 = sub_10004D37C(&v62[1].__m_.__sig, (unint64_t *)buf);
      if (v67)
      {
        long long v69 = (GestaltUtilityInterface *)v67[3];
        long long v68 = (std::__shared_weak_count *)v67[4];
        if (v68)
        {
          atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v62);
          atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v68);
          char v71 = 0;
          if (!v69)
          {
LABEL_92:
            std::string::size_type v72 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_104;
            }
            *(_WORD *)long long buf = 0;
            char v73 = "#E invalid gestaltUtility";
            goto LABEL_103;
          }
LABEL_96:
          if (!*(unsigned char *)(a1 + 384))
          {
            std::string::size_type v72 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_104;
            }
            *(_WORD *)long long buf = 0;
            char v73 = "#E inconsistent state, transfer context is invalid";
LABEL_103:
            _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, v73, buf, 2u);
LABEL_104:
            LOBYTE(v57) = 0;
            if (v71) {
              goto LABEL_106;
            }
            goto LABEL_105;
          }
          CFTypeRef cf = 0;
          CFStringRef format = 0;
          CFStringRef v134 = 0;
          CFTypeRef v135 = 0;
          CFTypeRef v132 = 0;
          CFStringRef v133 = 0;
          CFTypeRef v131 = 0;
          int v74 = *(unsigned __int8 *)(a1 + 377);
          if (v74 != 2)
          {
            if (v74 != 1) {
              goto LABEL_185;
            }
            int isIPad = GestaltUtilityInterface::isIPad(v69);
            uint64_t v76 = kCBMessageLocalizationTable;
            if (isIPad) {
              (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v57 + 40))(v139, v57, kCBMessageLocalizationTable, @"TRANSFER_SOURCE_TITLE_PAD", 0);
            }
            else {
              (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v57 + 40))(v139, v57, kCBMessageLocalizationTable, @"TRANSFER_SOURCE_TITLE", 0);
            }
            *(void *)long long buf = format;
            CFStringRef format = (CFStringRef)v139[0];
            v139[0] = 0;
            sub_1000558F4((const void **)buf);
            sub_1000558F4((const void **)v139);
            if (GestaltUtilityInterface::isIPad(v69)) {
              (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v57 + 40))(v139, v57, v76, @"TRANSFER_REQUEST_PROMPT_PAD", 0);
            }
            else {
              (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v57 + 40))(v139, v57, v76, @"TRANSFER_REQUEST_PROMPT", 0);
            }
            *(void *)long long buf = v135;
            CFTypeRef v135 = v139[0];
            v139[0] = 0;
            sub_1000558F4((const void **)buf);
            sub_1000558F4((const void **)v139);
            if (!GestaltUtilityInterface::isIPad(v69))
            {
              uint64_t v84 = (void **)(a1 + 176);
              if (*(char *)(a1 + 199) < 0)
              {
                unint64_t v95 = *(void *)(a1 + 184);
                if (v95)
                {
                  sub_10004FC84(v128, *v84, v95);
                  goto LABEL_156;
                }
              }
              else if (*(unsigned char *)(a1 + 199))
              {
                *(_OWORD *)v128 = *(_OWORD *)v84;
                uint64_t v129 = *(void *)(a1 + 192);
LABEL_156:
                if (SHIBYTE(v129) < 0)
                {
                  sub_10004FC84(v139, v128[0], (unint64_t)v128[1]);
                }
                else
                {
                  *(_OWORD *)uint64_t v139 = *(_OWORD *)v128;
                  uint64_t v140 = v129;
                }
                CFStringRef v138 = 0;
                if (SHIBYTE(v140) < 0)
                {
                  sub_10004FC84(buf, v139[0], (unint64_t)v139[1]);
                }
                else
                {
                  *(_OWORD *)long long buf = *(_OWORD *)v139;
                  *(void *)&uint8_t buf[16] = v140;
                }
                CFStringRef v141 = 0;
                if (ctu::cf::convert_copy())
                {
                  CFStringRef v96 = v138;
                  CFStringRef v138 = v141;
                  CFStringRef v142 = v96;
                  sub_1000558F4((const void **)&v142);
                }
                if ((char)buf[23] < 0) {
                  operator delete(*(void **)buf);
                }
                CFStringRef v130 = v138;
                CFStringRef v138 = 0;
                sub_1000558F4((const void **)&v138);
                if (SHIBYTE(v140) < 0) {
                  operator delete(v139[0]);
                }
                *(void *)long long buf = v134;
                CFStringRef v134 = v130;
                CFStringRef v130 = 0;
                sub_1000558F4((const void **)buf);
                sub_1000558F4((const void **)&v130);
                if (SHIBYTE(v129) < 0) {
                  operator delete(v128[0]);
                }
LABEL_171:
                if (!format)
                {
LABEL_183:
                  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v57 + 40))(v139, v57, v76, @"TRANSFER_ESIM", 0);
                  *(void *)long long buf = v132;
                  CFTypeRef v132 = v139[0];
                  v139[0] = 0;
                  sub_1000558F4((const void **)buf);
                  sub_1000558F4((const void **)v139);
                  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v57 + 40))(v139, v57, v76, @"CANCEL", 0);
                  *(void *)long long buf = v131;
                  CFTypeRef v131 = v139[0];
                  v139[0] = 0;
                  sub_1000558F4((const void **)buf);
                  CFTypeRef v94 = v139;
LABEL_184:
                  sub_1000558F4((const void **)v94);
LABEL_185:
                  if (!cf || !v135 || !v132 || !v131)
                  {
                    CFTypeID v103 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "#E localization string does not exist", buf, 2u);
                    }
                  }
                  long long v104 = *(std::__shared_weak_count **)(a1 + 72);
                  if (v104)
                  {
                    long long v105 = std::__shared_weak_count::lock(v104);
                    if (v105)
                    {
                      uint64_t v106 = v105;
                      uint64_t v107 = *(void *)(a1 + 64);
                      if (v107) {
                        (*(void (**)(uint64_t))(*(void *)v107 + 24))(v107);
                      }
                      sub_10004D2C8(v106);
                    }
                  }
                  CFTypeRef v125 = cf;
                  if (cf) {
                    CFRetain(cf);
                  }
                  CFTypeRef v124 = v135;
                  if (v135) {
                    CFRetain(v135);
                  }
                  CFTypeRef v123 = v132;
                  if (v132) {
                    CFRetain(v132);
                  }
                  CFTypeRef v122 = v131;
                  if (v131) {
                    CFRetain(v131);
                  }
                  uint64_t v121 = 0;
                  CFMutableDictionaryRef v108 = *(std::__shared_weak_count **)(a1 + 16);
                  if (!v108 || (uint64_t v109 = *(void *)(a1 + 8), (v110 = std::__shared_weak_count::lock(v108)) == 0)) {
                    sub_100088B9C();
                  }
                  uint64_t v111 = v110;
                  atomic_fetch_add_explicit(&v110->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v110);
                  long long v162 = 0;
                  CFIndex v112 = operator new(0x20uLL);
                  *CFIndex v112 = off_101A465D0;
                  v112[1] = a1;
                  v112[2] = v109;
                  v112[3] = v111;
                  long long v162 = v112;
                  sub_1001D8368((uint64_t)buf, &v125, &v124, &v123, &v122, &v121, (uint64_t)v161);
                  if (*(unsigned char *)(a1 + 368))
                  {
                    sub_100BE7298((void *)(a1 + 288), buf);
                  }
                  else
                  {
                    sub_100BE746C((void *)(a1 + 288), buf);
                    *(unsigned char *)(a1 + 368) = 1;
                  }
                  sub_1001D8A28((void *)&v145 + 1);
                  sub_1000558F4((const void **)&v145);
                  sub_1000558F4((const void **)&v144 + 1);
                  sub_1000558F4((const void **)&v144);
                  sub_1000558F4((const void **)&buf[16]);
                  sub_1000558F4((const void **)&buf[8]);
                  sub_1001D88DC((const void **)buf);
                  sub_1001D8A28(v161);
                  sub_1000558F4(&v121);
                  sub_1000558F4(&v122);
                  sub_1000558F4(&v123);
                  sub_1000558F4(&v124);
                  sub_1000558F4(&v125);
                  if (*(unsigned char *)(a1 + 368))
                  {
                    CFMutableArrayRef v113 = *(NSObject **)(a1 + 80);
                    dispatch_object_t object = v113;
                    if (v113) {
                      dispatch_retain(v113);
                    }
                    sub_1001D845C(a1 + 288, &object);
                    if (object) {
                      dispatch_release(object);
                    }
                  }
                  LOBYTE(v57) = *(unsigned char *)(a1 + 368) != 0;
                  sub_1000558F4(&v131);
                  sub_1000558F4(&v132);
                  sub_1000558F4((const void **)&v133);
                  sub_1000558F4((const void **)&v134);
                  sub_1000558F4(&v135);
                  sub_1000558F4(&cf);
                  sub_1000558F4((const void **)&format);
                  if (v71) {
                    goto LABEL_106;
                  }
LABEL_105:
                  sub_10004D2C8(v68);
                  goto LABEL_106;
                }
                if (!GestaltUtilityInterface::isIPad(v69))
                {
                  CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, v134);
                  CFTypeRef v99 = cf;
                  CFTypeRef cf = StringWithValidatedFormat;
                  *(void *)long long buf = v99;
                  uint64_t v100 = (const void **)buf;
LABEL_182:
                  sub_1000558F4(v100);
                  goto LABEL_183;
                }
                uint64_t v97 = (const char *)a11;
                if (*(char *)(a11 + 23) < 0)
                {
                  if (*(void *)(a11 + 8))
                  {
                    v139[0] = 0;
                    uint64_t v97 = *(const char **)a11;
                    goto LABEL_179;
                  }
                }
                else if (*(unsigned char *)(a11 + 23))
                {
                  v139[0] = 0;
LABEL_179:
                  v139[0] = (void *)CFStringCreateWithCString(kCFAllocatorDefault, v97, 0x8000100u);
                  CFStringRef v101 = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, v139[0]);
                  CFTypeRef v102 = cf;
                  CFTypeRef cf = v101;
                  *(void *)long long buf = v102;
LABEL_181:
                  sub_1000558F4((const void **)buf);
                  uint64_t v100 = (const void **)v139;
                  goto LABEL_182;
                }
                (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v57 + 40))(v139, v57, v76, @"TRANSFER_SOURCE_TITLE_PAD_NO_CARRIERNAME", 0);
                *(void *)long long buf = cf;
                CFTypeRef cf = v139[0];
                v139[0] = 0;
                goto LABEL_181;
              }
            }
            (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v57 + 40))(v139, v57, v76, @"TRANSFER_CELLULAR_PLAN", 0);
            *(void *)long long buf = v134;
            CFStringRef v134 = (const __CFString *)v139[0];
            v139[0] = 0;
            sub_1000558F4((const void **)buf);
            sub_1000558F4((const void **)v139);
            goto LABEL_171;
          }
          CFStringRef v142 = 0;
          v139[0] = 0;
          if (ctu::cf::convert_copy((ctu::cf *)v139, (const __CFString **)"A data plan purchase was requested by %@.", (const char *)0x8000100, kCFAllocatorDefault, v70))
          {
            CFStringRef v79 = v142;
            CFStringRef v142 = (const __CFString *)v139[0];
            *(void *)long long buf = v79;
            sub_1000558F4((const void **)buf);
          }
          CFStringRef v141 = v142;
          CFStringRef v142 = 0;
          sub_1000558F4((const void **)&v142);
          *(void *)long long buf = format;
          CFStringRef format = v141;
          CFStringRef v141 = 0;
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v141);
          CFStringRef v142 = 0;
          v139[0] = 0;
          if (ctu::cf::convert_copy((ctu::cf *)v139, (const __CFString **)"Another Apple device wants to use this iPhone to make a purchase. If you did not request this, don't allow the purchase.", (const char *)0x8000100, kCFAllocatorDefault, v80))
          {
            CFStringRef v81 = v142;
            CFStringRef v142 = (const __CFString *)v139[0];
            *(void *)long long buf = v81;
            sub_1000558F4((const void **)buf);
          }
          CFStringRef v141 = v142;
          CFStringRef v142 = 0;
          sub_1000558F4((const void **)&v142);
          *(void *)long long buf = v135;
          CFTypeRef v135 = v141;
          CFStringRef v141 = 0;
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v141);
          uint64_t v83 = (void **)(a1 + 264);
          if (*(char *)(a1 + 287) < 0)
          {
            unint64_t v85 = *(void *)(a1 + 272);
            if (v85)
            {
              sub_10004FC84(v126, *v83, v85);
              goto LABEL_130;
            }
          }
          else if (*(unsigned char *)(a1 + 287))
          {
            *(_OWORD *)CFIndex v126 = *(_OWORD *)v83;
            uint64_t v127 = *(void *)(a1 + 280);
LABEL_130:
            if (SHIBYTE(v127) < 0)
            {
              sub_10004FC84(v139, v126[0], (unint64_t)v126[1]);
            }
            else
            {
              *(_OWORD *)uint64_t v139 = *(_OWORD *)v126;
              uint64_t v140 = v127;
            }
            CFStringRef v138 = 0;
            if (SHIBYTE(v140) < 0)
            {
              sub_10004FC84(buf, v139[0], (unint64_t)v139[1]);
            }
            else
            {
              *(_OWORD *)long long buf = *(_OWORD *)v139;
              *(void *)&uint8_t buf[16] = v140;
            }
            CFStringRef v141 = 0;
            if (ctu::cf::convert_copy())
            {
              CFStringRef v88 = v138;
              CFStringRef v138 = v141;
              CFStringRef v142 = v88;
              sub_1000558F4((const void **)&v142);
            }
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            CFStringRef v130 = v138;
            CFStringRef v138 = 0;
            sub_1000558F4((const void **)&v138);
            if (SHIBYTE(v140) < 0) {
              operator delete(v139[0]);
            }
            *(void *)long long buf = v133;
            CFStringRef v133 = v130;
            CFStringRef v130 = 0;
            sub_1000558F4((const void **)buf);
            sub_1000558F4((const void **)&v130);
            if (SHIBYTE(v127) < 0) {
              operator delete(v126[0]);
            }
LABEL_147:
            if (format)
            {
              CFStringRef v89 = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", format, 0, v133);
              CFTypeRef v90 = cf;
              CFTypeRef cf = v89;
              *(void *)long long buf = v90;
              sub_1000558F4((const void **)buf);
            }
            CFStringRef v142 = 0;
            v139[0] = 0;
            if (ctu::cf::convert_copy((ctu::cf *)v139, (const __CFString **)"Purchase", (const char *)0x8000100, kCFAllocatorDefault, v87))
            {
              CFStringRef v91 = v142;
              CFStringRef v142 = (const __CFString *)v139[0];
              *(void *)long long buf = v91;
              sub_1000558F4((const void **)buf);
            }
            CFStringRef v141 = v142;
            CFStringRef v142 = 0;
            sub_1000558F4((const void **)&v142);
            *(void *)long long buf = v132;
            CFTypeRef v132 = v141;
            CFStringRef v141 = 0;
            sub_1000558F4((const void **)buf);
            sub_1000558F4((const void **)&v141);
            CFStringRef v142 = 0;
            v139[0] = 0;
            if (ctu::cf::convert_copy((ctu::cf *)v139, (const __CFString **)"Don't Allow", (const char *)0x8000100, kCFAllocatorDefault, v92))
            {
              CFStringRef v93 = v142;
              CFStringRef v142 = (const __CFString *)v139[0];
              *(void *)long long buf = v93;
              sub_1000558F4((const void **)buf);
            }
            CFStringRef v141 = v142;
            CFStringRef v142 = 0;
            sub_1000558F4((const void **)&v142);
            *(void *)long long buf = v131;
            CFTypeRef v131 = v141;
            CFStringRef v141 = 0;
            sub_1000558F4((const void **)buf);
            CFTypeRef v94 = (void **)&v141;
            goto LABEL_184;
          }
          CFStringRef v142 = 0;
          v139[0] = 0;
          if (ctu::cf::convert_copy((ctu::cf *)v139, (const __CFString **)"your iPad", (const char *)0x8000100, kCFAllocatorDefault, v82))
          {
            CFStringRef v86 = v142;
            CFStringRef v142 = (const __CFString *)v139[0];
            *(void *)long long buf = v86;
            sub_1000558F4((const void **)buf);
          }
          CFStringRef v141 = v142;
          CFStringRef v142 = 0;
          sub_1000558F4((const void **)&v142);
          *(void *)long long buf = v133;
          CFStringRef v133 = v141;
          CFStringRef v141 = 0;
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v141);
          goto LABEL_147;
        }
      }
      else
      {
        long long v69 = 0;
      }
      std::mutex::unlock(v62);
      long long v68 = 0;
      char v71 = 1;
      if (!v69) {
        goto LABEL_92;
      }
      goto LABEL_96;
    }
  }
  else
  {
    uint64_t v57 = 0;
  }
  std::mutex::unlock(v50);
  xpc_object_t v56 = 0;
  char v59 = 1;
  if (v57) {
    goto LABEL_86;
  }
LABEL_81:
  xpc_object_t v60 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#E invalid localization", buf, 2u);
    if ((v59 & 1) == 0) {
      sub_10004D2C8(v56);
    }
LABEL_109:
    uint64_t v77 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#E display user consent failure", buf, 2u);
    }
    sub_100BE6E24(a1, 4, 5);
    return 1;
  }
LABEL_106:
  if ((v59 & 1) == 0) {
    sub_10004D2C8(v56);
  }
  if ((v57 & 1) == 0) {
    goto LABEL_109;
  }
  return 1;
}

void sub_100BE6B58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,dispatch_object_t object,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,const void *a37,const void *a38,const void *a39,const void *a40,const void *a41,const void *a42,const void *a43)
{
  sub_1000558F4(&a37);
  sub_1000558F4(&a38);
  sub_1000558F4(&a39);
  sub_1000558F4(&a40);
  sub_1000558F4(&a41);
  sub_1000558F4(&a42);
  sub_1000558F4(&a43);
  if ((v46 & 1) == 0) {
    sub_10004D2C8(v44);
  }
  if ((v45 & 1) == 0) {
    sub_10004D2C8(v43);
  }
  _Unwind_Resume(a1);
}

void sub_100BE6E24(uint64_t a1, char a2, char a3)
{
  if (*(unsigned char *)(a1 + 384))
  {
    *(unsigned char *)(a1 + 376) = a2;
    int v5 = *(std::__shared_weak_count **)(a1 + 72);
    if (v5)
    {
      uint64_t v7 = std::__shared_weak_count::lock(v5);
      if (v7)
      {
        uint64_t v8 = v7;
        uint64_t v9 = *(void *)(a1 + 64);
        if (v9 && *(unsigned char *)(a1 + 377) == 1)
        {
          if (*(char *)(a1 + 111) < 0)
          {
            sub_10004FC84(__dst, *(void **)(a1 + 88), *(void *)(a1 + 96));
          }
          else
          {
            *(_OWORD *)long long __dst = *(_OWORD *)(a1 + 88);
            uint64_t v20 = *(void *)(a1 + 104);
          }
          if (*(char *)(a1 + 151) < 0)
          {
            sub_10004FC84(v17, *(void **)(a1 + 128), *(void *)(a1 + 136));
          }
          else
          {
            *(_OWORD *)BOOL v17 = *(_OWORD *)(a1 + 128);
            uint64_t v18 = *(void *)(a1 + 144);
          }
          uint64_t v10 = *(void *)(a1 + 160);
          uint64_t v11 = *(void *)(a1 + 168);
          uint64_t v12 = *(void *)(a1 + 200);
          uint64_t v13 = *(void *)(a1 + 208);
          if (*(char *)(a1 + 239) < 0)
          {
            sub_10004FC84(__p, *(void **)(a1 + 216), *(void *)(a1 + 224));
          }
          else
          {
            *(_OWORD *)__n128 __p = *(_OWORD *)(a1 + 216);
            uint64_t v16 = *(void *)(a1 + 232);
          }
          HIBYTE(v14) = a3;
          LOBYTE(v14) = a2;
          (*(void (**)(uint64_t, void **, void **, uint64_t, uint64_t, uint64_t, uint64_t, void **, __int16))(*(void *)v9 + 16))(v9, __dst, v17, v10, v11, v12, v13, __p, v14);
          if (SHIBYTE(v16) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v18) < 0) {
            operator delete(v17[0]);
          }
          if (SHIBYTE(v20) < 0) {
            operator delete(__dst[0]);
          }
        }
        sub_10004D2C8(v8);
      }
    }
  }
}

void sub_100BE6FB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  sub_10004D2C8(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_100BE7014(uint64_t a1, unsigned __int8 *a2, void *a3)
{
  if (!*(unsigned char *)(a1 + 384))
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v14) {
      return result;
    }
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E inconsistent state. no transfer context", buf, 2u);
    return 0;
  }
  int v5 = a2;
  uint64_t v6 = (const void **)(a1 + 128);
  char v7 = *(unsigned char *)(a1 + 151);
  if (v7 >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(a1 + 151);
  }
  else {
    uint64_t v8 = *(void *)(a1 + 136);
  }
  uint64_t v9 = a2[23];
  int v10 = (char)v9;
  if ((v9 & 0x80u) != 0) {
    uint64_t v9 = *((void *)a2 + 1);
  }
  if (v8 != v9) {
    goto LABEL_23;
  }
  if (v10 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((*(unsigned char *)(a1 + 151) & 0x80) != 0)
  {
    if (!memcmp(*v6, a2, *(void *)(a1 + 136))) {
      goto LABEL_19;
    }
LABEL_23:
    BOOL v17 = *(NSObject **)(a1 + 40);
    BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v18) {
      return result;
    }
    if (v10 < 0) {
      int v5 = (void *)*v5;
    }
    if (v7 < 0) {
      uint64_t v6 = (const void **)*v6;
    }
    sCardSerialNumberAsString();
    sCardSerialNumberAsString();
    uint64_t v19 = &v24;
    if (v25 < 0) {
      uint64_t v19 = v24;
    }
    if (v23 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)long long buf = 136315906;
    int v27 = v5;
    __int16 v28 = 2080;
    unint64_t v29 = v6;
    __int16 v30 = 2080;
    uint64_t v31 = v19;
    __int16 v32 = 2080;
    uint64_t v33 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#E transfer info not matched. iccid - %s vs %s(ctx). eid - %s vs %s(ctx)", buf, 0x2Au);
    if (v23 < 0) {
      operator delete(__p);
    }
    if (v25 < 0) {
      operator delete(v24);
    }
    return 0;
  }
  if (*(unsigned char *)(a1 + 151))
  {
    uint64_t v11 = (unsigned __int8 *)(a1 + 128);
    uint64_t v12 = *(unsigned __int8 *)(a1 + 151);
    while (*v11 == *a2)
    {
      ++v11;
      ++a2;
      if (!--v12) {
        goto LABEL_19;
      }
    }
    goto LABEL_23;
  }
LABEL_19:
  if (*(void *)(a1 + 200) != *a3 || *(void *)(a1 + 208) != a3[1]) {
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 368))
  {
    BOOL v21 = (const void ***)(a1 + 288);
    sub_1001D887C(v21);
    sub_100BE7408((const void **)v21);
  }
  return 1;
}

void sub_100BE7274(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100BE7298(void *a1, void *a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = (const void *)*a1;
    *a1 = 0;
    uint64_t v13 = v4;
    *a1 = *a2;
    *a2 = 0;
    sub_1001D88DC(&v13);
    int v5 = (const void *)a1[1];
    a1[1] = 0;
    uint64_t v13 = v5;
    a1[1] = a2[1];
    a2[1] = 0;
    sub_1000558F4(&v13);
    uint64_t v6 = (const void *)a1[2];
    a1[2] = 0;
    uint64_t v13 = v6;
    a1[2] = a2[2];
    a2[2] = 0;
    sub_1000558F4(&v13);
    char v7 = (const void *)a1[3];
    a1[3] = 0;
    uint64_t v13 = v7;
    a1[3] = a2[3];
    a2[3] = 0;
    sub_1000558F4(&v13);
    uint64_t v8 = (const void *)a1[4];
    a1[4] = 0;
    uint64_t v13 = v8;
    a1[4] = a2[4];
    a2[4] = 0;
    sub_1000558F4(&v13);
    uint64_t v9 = (const void *)a1[5];
    a1[5] = 0;
    uint64_t v13 = v9;
    a1[5] = a2[5];
    a2[5] = 0;
    sub_1000558F4(&v13);
  }
  sub_1001D8968(a1 + 6);
  int v10 = a2 + 9;
  uint64_t v11 = (void *)a2[9];
  if (v11)
  {
    if (v11 == a2 + 6)
    {
      a1[9] = a1 + 6;
      (*(void (**)(void, void *))(*(void *)*v10 + 24))(*v10, a1 + 6);
      return a1;
    }
    a1[9] = v11;
  }
  else
  {
    int v10 = a1 + 9;
  }
  *int v10 = 0;
  return a1;
}

const void **sub_100BE7408(const void **result)
{
  if (*((unsigned char *)result + 80))
  {
    uint64_t v1 = result;
    sub_1001D8A28(result + 6);
    sub_1000558F4(v1 + 5);
    sub_1000558F4(v1 + 4);
    sub_1000558F4(v1 + 3);
    sub_1000558F4(v1 + 2);
    sub_1000558F4(v1 + 1);
    uint64_t result = sub_1001D88DC(v1);
    *((unsigned char *)v1 + 80) = 0;
  }
  return result;
}

void *sub_100BE746C(void *a1, void *a2)
{
  *a1 = 0;
  *a1 = *a2;
  *a2 = 0;
  a1[1] = 0;
  a1[1] = a2[1];
  a2[1] = 0;
  a1[2] = 0;
  a1[2] = a2[2];
  a2[2] = 0;
  a1[3] = 0;
  a1[3] = a2[3];
  a2[3] = 0;
  a1[4] = 0;
  a1[4] = a2[4];
  a2[4] = 0;
  a1[5] = 0;
  a1[5] = a2[5];
  a2[5] = 0;
  sub_1001D8D30((uint64_t)(a1 + 6), (uint64_t)(a2 + 6));
  return a1;
}

uint64_t sub_100BE74FC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 280))
  {
    sub_1001D8A28((void *)(a1 + 248));
    sub_1000558F4((const void **)(a1 + 240));
    sub_1000558F4((const void **)(a1 + 232));
    sub_1000558F4((const void **)(a1 + 224));
    sub_1000558F4((const void **)(a1 + 216));
    sub_1000558F4((const void **)(a1 + 208));
    sub_1001D88DC((const void **)(a1 + 200));
  }
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_100BE75C4(void *a1)
{
  *a1 = off_101A465D0;
  id v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100BE7610(void *a1)
{
  *a1 = off_101A465D0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100BE767C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A465D0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100BE76E0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A465D0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100BE7720(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100BE7730(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100BE7770(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        int v5 = *(std::__shared_weak_count **)(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100BE7898(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BE78D8()
{
}

void sub_100BE78E4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 72);
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      int v5 = v4;
      uint64_t v6 = *(void *)(v2 + 64);
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 32))(v6);
      }
      sub_10004D2C8(v5);
    }
  }
  int v7 = *((_DWORD *)v1 + 2);
  if (v7)
  {
    uint64_t v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v17) = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Transfer consent response error: %d", buf, 8u);
    }
    unsigned int v9 = 4;
  }
  else
  {
    uint64_t v10 = v1[2];
    if (v10) {
      int v11 = 4;
    }
    else {
      int v11 = 1;
    }
    if (v10 == 1) {
      int v11 = 2;
    }
    if (v10 == 3) {
      unsigned int v9 = 3;
    }
    else {
      unsigned int v9 = v11;
    }
  }
  uint64_t v12 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = v9 - 2;
    if (v13 > 2) {
      BOOL v14 = "kAccepted";
    }
    else {
      BOOL v14 = off_101A46640[v13];
    }
    *(_DWORD *)long long buf = 136315138;
    BOOL v17 = v14;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Transfer consent state: %s", buf, 0xCu);
  }
  if (*(unsigned char *)(v2 + 384)) {
    sub_100BE7408((const void **)(v2 + 288));
  }
  if (v9 == 4) {
    char v15 = 5;
  }
  else {
    char v15 = 0;
  }
  sub_100BE6E24(v2, v9, v15);
  operator delete();
}

void sub_100BE7ACC()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_100BE7B08(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v3 = (const char *)a2;
  }
  else {
    uint64_t v3 = *(const char **)a2;
  }
  xpc_object_t v7 = xpc_string_create(v3);
  if (!v7) {
    xpc_object_t v7 = xpc_null_create();
  }
  long long v9 = 0uLL;
  uint64_t v10 = 0;
  ctu::cf::assign();
  *(_OWORD *)__n128 __p = 0uLL;
  uint64_t v5 = 0;
  v6[0] = a1;
  v6[1] = __p;
  sub_100035E70((uint64_t)v6, &v7, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v7);
}

void sub_100BE7BE0(_Unwind_Exception *a1)
{
  if (*(char *)(v2 - 17) < 0) {
    operator delete(*(void **)(v2 - 40));
  }
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100BE7C0C(Registry **a1, uint64_t a2, xpc_object_t *a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned __int8 *)(a4 + 95);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a4 + 80);
  }
  if (!v4 || xpc_get_type(*a3) != (xpc_type_t)&_xpc_type_dictionary) {
    return 0;
  }
  uint64_t v27 = 0;
  __int16 v28 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)&_xpc_type_dictionary, *a1);
  uint64_t v12 = ServiceMap;
  if (v13 < 0)
  {
    BOOL v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v29 = v13;
  BOOL v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&v29);
  if (v17)
  {
    uint64_t v19 = v17[3];
    BOOL v18 = (std::__shared_weak_count *)v17[4];
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v19 = 0;
    BOOL v18 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v27 = v19;
  __int16 v28 = v18;
  if (v18)
  {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v18);
  }
  if (v19 && (sub_100527BA0(a2, (uint64_t)&v27, carrier_space::kCBAuthorizationRequestRequiresICCIDKey, 0) & 1) != 0)
  {
    if (*(char *)(a4 + 95) >= 0) {
      uint64_t v20 = (const char *)(a4 + 72);
    }
    else {
      uint64_t v20 = *(const char **)(a4 + 72);
    }
    xpc_object_t v25 = xpc_string_create(v20);
    if (!v25) {
      xpc_object_t v25 = xpc_null_create();
    }
    long long v29 = 0uLL;
    uint64_t v30 = 0;
    ctu::cf::assign();
    *(_OWORD *)__n128 __p = v29;
    uint64_t v23 = v30;
    v24[0] = a3;
    BOOL v21 = __p;
    if (v30 < 0) {
      BOOL v21 = (void **)v29;
    }
    v24[1] = v21;
    sub_100035E70((uint64_t)v24, &v25, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v25);
    xpc_object_t v25 = 0;
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (v28) {
    sub_10004D2C8(v28);
  }
  return v9;
}

void sub_100BE7E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  xpc_release(v23);
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(a1);
}

void sub_100BE7E60(Registry **a1@<X0>, uint64_t a2@<X1>, xpc_object_t *a3@<X8>)
{
  uint64_t v5 = *a1;
  if (!v5)
  {
    *a3 = xpc_null_create();
    return;
  }
  uint64_t v68 = 0;
  long long v69 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v70 = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v70);
  if (v13)
  {
    uint64_t v15 = v13[3];
    BOOL v14 = (std::__shared_weak_count *)v13[4];
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v15 = 0;
    BOOL v14 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v68 = v15;
  long long v69 = v14;
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v14);
    uint64_t v15 = v68;
  }
  if (v15)
  {
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    uint64_t v67 = 0;
    v63[1] = 0;
    uint64_t v64 = 0;
    v63[0] = 0;
    sub_100BE87C8((uint64_t)v63, (uint64_t)&v65);
    if (SHIBYTE(v64) < 0) {
      operator delete(v63[0]);
    }
    uint64_t v16 = HIBYTE(v67);
    if (v67 < 0) {
      uint64_t v16 = v66;
    }
    if (!v16)
    {
      *a3 = xpc_null_create();
LABEL_96:
      if (SHIBYTE(v67) < 0) {
        operator delete(v65);
      }
      goto LABEL_98;
    }
    xpc_object_t v60 = 0;
    uint64_t v61 = 0;
    uint64_t v62 = 0;
    v58[1] = 0;
    uint64_t v59 = 0;
    v58[0] = 0;
    sub_100BE87C8((uint64_t)v58, (uint64_t)&v60);
    if (SHIBYTE(v59) < 0) {
      operator delete(v58[0]);
    }
    uint64_t v17 = HIBYTE(v62);
    if (v62 < 0) {
      uint64_t v17 = v61;
    }
    if (!v17)
    {
      *a3 = xpc_null_create();
LABEL_94:
      if (SHIBYTE(v62) < 0) {
        operator delete(v60);
      }
      goto LABEL_96;
    }
    int v55 = 0;
    uint64_t v56 = 0;
    uint64_t v57 = 0;
    __p[1] = 0;
    uint64_t v54 = 0;
    __p[0] = 0;
    sub_100BE87C8((uint64_t)__p, (uint64_t)&v55);
    if (SHIBYTE(v54) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v18 = HIBYTE(v57);
    if (v57 < 0) {
      uint64_t v18 = v56;
    }
    if (!v18)
    {
      *a3 = xpc_null_create();
      goto LABEL_92;
    }
    *a3 = 0;
    xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v20 = v19;
    if (v19)
    {
      *a3 = v19;
    }
    else
    {
      xpc_object_t v20 = xpc_null_create();
      *a3 = v20;
      if (!v20)
      {
        xpc_object_t v21 = xpc_null_create();
        xpc_object_t v20 = 0;
        goto LABEL_39;
      }
    }
    if (xpc_get_type(v20) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v20);
      goto LABEL_40;
    }
    xpc_object_t v21 = xpc_null_create();
LABEL_39:
    *a3 = v21;
LABEL_40:
    xpc_release(v20);
    if (v67 >= 0) {
      char v22 = (const char *)&v65;
    }
    else {
      char v22 = (const char *)v65;
    }
    xpc_object_t v51 = xpc_string_create(v22);
    if (!v51) {
      xpc_object_t v51 = xpc_null_create();
    }
    long long v70 = 0uLL;
    uint64_t v71 = 0;
    ctu::cf::assign();
    *(_OWORD *)string = v70;
    uint64_t v50 = v71;
    uint64_t v23 = string;
    if (v71 < 0) {
      uint64_t v23 = (char **)string[0];
    }
    v34[0] = a3;
    v34[1] = v23;
    sub_100035E70((uint64_t)v34, &v51, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    if (SHIBYTE(v50) < 0) {
      operator delete(string[0]);
    }
    xpc_release(v51);
    xpc_object_t v51 = 0;
    if (v62 >= 0) {
      uint64_t v24 = (const char *)&v60;
    }
    else {
      uint64_t v24 = (const char *)v60;
    }
    xpc_object_t v47 = xpc_string_create(v24);
    if (!v47) {
      xpc_object_t v47 = xpc_null_create();
    }
    long long v70 = 0uLL;
    uint64_t v71 = 0;
    ctu::cf::assign();
    *(_OWORD *)string = v70;
    uint64_t v50 = v71;
    xpc_object_t v25 = string;
    if (v71 < 0) {
      xpc_object_t v25 = (char **)string[0];
    }
    v34[0] = a3;
    v34[1] = v25;
    sub_100035E70((uint64_t)v34, &v47, &v48);
    xpc_release(v48);
    xpc_object_t v48 = 0;
    if (SHIBYTE(v50) < 0) {
      operator delete(string[0]);
    }
    xpc_release(v47);
    xpc_object_t v47 = 0;
    if (v57 >= 0) {
      uint64_t v26 = (const char *)&v55;
    }
    else {
      uint64_t v26 = (const char *)v55;
    }
    xpc_object_t v45 = xpc_string_create(v26);
    if (!v45) {
      xpc_object_t v45 = xpc_null_create();
    }
    long long v70 = 0uLL;
    uint64_t v71 = 0;
    ctu::cf::assign();
    *(_OWORD *)string = v70;
    uint64_t v50 = v71;
    uint64_t v27 = string;
    if (v71 < 0) {
      uint64_t v27 = (char **)string[0];
    }
    v34[0] = a3;
    v34[1] = v27;
    sub_100035E70((uint64_t)v34, &v45, &v46);
    xpc_release(v46);
    xpc_object_t v46 = 0;
    if (SHIBYTE(v50) < 0) {
      operator delete(string[0]);
    }
    xpc_release(v45);
    xpc_object_t v45 = 0;
    sub_100BE88AC(a1, a2, (const void **)v36);
    ctu::cf_to_xpc((uint64_t *)&v43, v36[0], v28);
    long long v70 = 0uLL;
    uint64_t v71 = 0;
    ctu::cf::assign();
    *(_OWORD *)string = v70;
    uint64_t v50 = v71;
    long long v29 = string;
    if (v71 < 0) {
      long long v29 = (char **)string[0];
    }
    v34[0] = a3;
    v34[1] = v29;
    sub_100035E70((uint64_t)v34, &v43, &v44);
    xpc_release(v44);
    xpc_object_t v44 = 0;
    if (SHIBYTE(v50) < 0) {
      operator delete(string[0]);
    }
    xpc_release(v43);
    xpc_object_t v43 = 0;
    sub_1000558F4((const void **)v36);
    char v30 = sub_100527BA0(a2, (uint64_t)&v68, carrier_space::kCBSupportsStateParameterKey, 0);
    xpc_object_t v41 = xpc_BOOL_create(v30);
    if (!v41) {
      xpc_object_t v41 = xpc_null_create();
    }
    long long v70 = 0uLL;
    uint64_t v71 = 0;
    ctu::cf::assign();
    *(_OWORD *)string = v70;
    uint64_t v50 = v71;
    uint64_t v31 = string;
    if (v71 < 0) {
      uint64_t v31 = (char **)string[0];
    }
    v34[0] = a3;
    v34[1] = v31;
    sub_100035E70((uint64_t)v34, &v41, &v42);
    xpc_release(v42);
    xpc_object_t v42 = 0;
    if (SHIBYTE(v50) < 0) {
      operator delete(string[0]);
    }
    xpc_release(v41);
    xpc_object_t v41 = 0;
    string[0] = 0;
    string[1] = 0;
    uint64_t v50 = 0;
    v39[1] = 0;
    uint64_t v40 = 0;
    v39[0] = 0;
    sub_100BE87C8((uint64_t)v39, (uint64_t)string);
    if (SHIBYTE(v40) < 0) {
      operator delete(v39[0]);
    }
    if (SHIBYTE(v50) < 0)
    {
      if (!string[1])
      {
LABEL_91:
        operator delete(string[0]);
LABEL_92:
        if (SHIBYTE(v57) < 0) {
          operator delete(v55);
        }
        goto LABEL_94;
      }
      __int16 v32 = string[0];
    }
    else
    {
      if (!HIBYTE(v50)) {
        goto LABEL_92;
      }
      __int16 v32 = (const char *)string;
    }
    xpc_object_t v37 = xpc_string_create(v32);
    if (!v37) {
      xpc_object_t v37 = xpc_null_create();
    }
    long long v70 = 0uLL;
    uint64_t v71 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long v34 = v70;
    uint64_t v35 = v71;
    v36[0] = (ctu *)a3;
    uint64_t v33 = v34;
    if (v71 < 0) {
      uint64_t v33 = (void **)v34[0];
    }
    v36[1] = (ctu *)v33;
    sub_100035E70((uint64_t)v36, &v37, &v38);
    xpc_release(v38);
    xpc_object_t v38 = 0;
    if (SHIBYTE(v35) < 0) {
      operator delete(v34[0]);
    }
    xpc_release(v37);
    xpc_object_t v37 = 0;
    if ((SHIBYTE(v50) & 0x80000000) == 0) {
      goto LABEL_92;
    }
    goto LABEL_91;
  }
  *a3 = xpc_null_create();
LABEL_98:
  if (v69) {
    sub_10004D2C8(v69);
  }
}

void sub_100BE85AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,xpc_object_t object,uint64_t a23,xpc_object_t a24,uint64_t a25,xpc_object_t a26,uint64_t a27,xpc_object_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,xpc_object_t a36,uint64_t a37,char a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (*(char *)(v51 - 65) < 0) {
    operator delete(*(void **)(v51 - 88));
  }
  xpc_release(v50);
  if (a35 < 0) {
    operator delete(a30);
  }
  sub_10017143C(v49);
  if (a49 < 0) {
    operator delete(a44);
  }
  if (*(char *)(v51 - 153) < 0) {
    operator delete(*(void **)(v51 - 176));
  }
  if (*(char *)(v51 - 105) < 0) {
    operator delete(*(void **)(v51 - 128));
  }
  uint64_t v53 = *(std::__shared_weak_count **)(v51 - 96);
  if (v53) {
    sub_10004D2C8(v53);
  }
  _Unwind_Resume(a1);
}

const void **sub_100BE87C8@<X0>(uint64_t a1@<X3>, uint64_t a2@<X8>)
{
  uint64_t v5 = 0;
  carrier_space::getCarrierSpaceValueForKey();
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  return sub_1000577C4(&v5);
}

void sub_100BE8880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15)
{
}

const void **sub_100BE88AC@<X0>(Registry **a1@<X0>, uint64_t a2@<X1>, const void **a3@<X8>)
{
  CFStringRef v17 = @"Carrier";
  CFRetain(@"Carrier");
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v18 = v8;
  unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v18);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_7:
    sub_100083DA4(a3, (const void **)&v17);
    if (v15) {
      return sub_1000558F4((const void **)&v17);
    }
    goto LABEL_12;
  }
LABEL_11:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const __CFString *, void))(*(void *)v14 + 96))(&v18, v14, a2, 1, @"CarrierName", v17, 0);
  sub_100056248(a3, (CFTypeRef *)&v18);
  sub_1000577C4((const void **)&v18);
  if ((v15 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v13);
  return sub_1000558F4((const void **)&v17);
}

void sub_100BE8A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_1000577C4(&a10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  sub_1000558F4(&a9);
  _Unwind_Resume(a1);
}

const void **sub_100BE8A60@<X0>(Registry **a1@<X0>, uint64_t a2@<X1>, CFStringRef *a3@<X8>)
{
  char v22 = 0;
  sub_100BE88AC(a1, a2, &v22);
  CFStringRef v21 = CFStringCreateWithFormat(0, 0, @"Touch ID to Change this \"%@\" Plan", v22);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *a1);
  xpc_object_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  CFTypeRef cf = (CFTypeRef)v8;
  unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&cf);
  if (!v12)
  {
    std::mutex::unlock(v7);
    goto LABEL_9;
  }
  uint64_t v14 = v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v7);
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v13);
    if (!v14)
    {
      *a3 = v21;
      CFStringRef v21 = 0;
LABEL_20:
      sub_10004D2C8(v13);
      goto LABEL_21;
    }
    goto LABEL_11;
  }
  std::mutex::unlock(v7);
  if (!v14)
  {
LABEL_9:
    *a3 = v21;
    CFStringRef v21 = 0;
    goto LABEL_21;
  }
LABEL_11:
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, const __CFString *, CFStringRef))(*(void *)v14 + 40))(&cf, v14, kCBMessageLocalizationTable, @"TOUCH_ID_AUTH_TITLE", v21);
  CFStringRef v15 = (const __CFString *)cf;
  if (cf) {
    uint64_t v16 = sub_1000810B8;
  }
  else {
    uint64_t v16 = 0;
  }
  if (v16)
  {
    CFTypeRef v20 = cf;
    if (cf) {
      CFRetain(cf);
    }
    CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v15);
    sub_1000558F4(&v20);
    *a3 = CFStringCreateWithFormat(0, 0, Copy, v22, Copy, v20);
    sub_1000558F4(&v19);
  }
  else
  {
    *a3 = v21;
    CFStringRef v21 = 0;
  }
  sub_1000558F4(&cf);
  if (v13) {
    goto LABEL_20;
  }
LABEL_21:
  sub_1000558F4((const void **)&v21);
  return sub_1000558F4(&v22);
}

void sub_100BE8C70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  va_copy(va2, va1);
  xpc_object_t v7 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v9 = va_arg(va3, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va3);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  _Unwind_Resume(a1);
}

BOOL sub_100BE8CD4(int a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = "33TelephonyHiSpeedFilerWriteSession";
  while (byte_1015565E3[v1] != a1)
  {
    if (++v1 == 4) {
      return v2 - byte_1015565E3 != 4;
    }
  }
  uint64_t v2 = &byte_1015565E3[v1];
  return v2 - byte_1015565E3 != 4;
}

BOOL sub_100BE8D18(int a1)
{
  return a1 == 8;
}

const void **sub_100BE8D24@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFPropertyListRef propertyList = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFDataRef v5 = (const __CFData *)propertyList;
    CFPropertyListRef propertyList = Mutable;
    CFDataRef Data = v5;
    sub_10005717C((const void **)&Data);
  }
  uint64_t v6 = *(const void **)a1;
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(void *)a1 != v7)
  {
    char v22 = 0;
    uint64_t v23 = 0;
    CFStringRef v21 = 0;
    sub_10005C928(&v21, v6, v7, v7 - (void)v6);
    __int16 v28 = 0;
    uint64_t v29 = 0;
    __n128 __p = 0;
    sub_10005C928(&__p, v21, (uint64_t)v22, v22 - (unsigned char *)v21);
    uint64_t v26 = 0;
    CFDataRef Data = 0;
    CFDataRef v31 = 0;
    uint64_t v32 = 0;
    sub_10005C928(&Data, __p, (uint64_t)v28, v28 - (unsigned char *)__p);
    uint64_t v33 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v8 = v26;
      uint64_t v26 = v33;
      long long v34 = v8;
      sub_100030068(&v34);
    }
    if (Data)
    {
      CFDataRef v31 = Data;
      operator delete(Data);
    }
    uint64_t v24 = (uint64_t)v26;
    uint64_t v26 = 0;
    sub_100030068(&v26);
    if (__p)
    {
      __int16 v28 = __p;
      operator delete(__p);
    }
    sub_10012C54C((__CFDictionary *)propertyList, @"kAccessTokenKey", v24);
    sub_100030068((const void **)&v24);
    if (v21)
    {
      char v22 = v21;
      operator delete(v21);
    }
  }
  uint64_t v9 = *(const void **)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 32);
  if (v9 != (const void *)v10)
  {
    xpc_object_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v18 = 0;
    sub_10005C928(&v18, v9, v10, v10 - (void)v9);
    __int16 v28 = 0;
    uint64_t v29 = 0;
    __n128 __p = 0;
    sub_10005C928(&__p, v18, (uint64_t)v19, v19 - (unsigned char *)v18);
    uint64_t v26 = 0;
    CFDataRef Data = 0;
    CFDataRef v31 = 0;
    uint64_t v32 = 0;
    sub_10005C928(&Data, __p, (uint64_t)v28, v28 - (unsigned char *)__p);
    uint64_t v33 = 0;
    if (ctu::cf::convert_copy())
    {
      unsigned int v11 = v26;
      uint64_t v26 = v33;
      long long v34 = v11;
      sub_100030068(&v34);
    }
    if (Data)
    {
      CFDataRef v31 = Data;
      operator delete(Data);
    }
    uint64_t v12 = (uint64_t)v26;
    uint64_t v24 = (uint64_t)v26;
    uint64_t v26 = 0;
    sub_100030068(&v26);
    if (__p)
    {
      __int16 v28 = __p;
      operator delete(__p);
    }
    sub_10012C54C((__CFDictionary *)propertyList, @"kRefreshTokenKey", v12);
    sub_100030068((const void **)&v24);
    if (v18)
    {
      xpc_object_t v19 = v18;
      operator delete(v18);
    }
  }
  uint64_t v13 = *(void *)(a1 + 48);
  if (v13) {
    uint64_t v14 = sub_1001908E4;
  }
  else {
    uint64_t v14 = 0;
  }
  if (v14) {
    sub_1001C6AF0((__CFDictionary *)propertyList, @"kExpiresAtKey", v13);
  }
  CFDataRef Data = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  BytePtr = CFDataGetBytePtr(Data);
  size_t Length = CFDataGetLength(Data);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_1001E7940(a2, BytePtr, (uint64_t)&BytePtr[Length], Length);
  sub_100030068((const void **)&Data);
  return sub_10005717C(&propertyList);
}

void sub_100BE8FEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, int a17, const void *a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23)
{
}

const void **sub_100BE90E0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v18 = 0;
  CFDataRef data = 0;
  uint64_t v16 = 0;
  CFStringRef v17 = 0;
  sub_10005C928(&v16, *(const void **)a1, *(void *)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
  CFDictionaryRef v22 = 0;
  uint64_t v23 = 0;
  CFDictionaryRef theDict = 0;
  sub_10005C928(&theDict, v16, (uint64_t)v17, v17 - (unsigned char *)v16);
  CFDataRef v20 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v25 = 0;
  sub_10005C928(__p, theDict, (uint64_t)v22, v22 - theDict);
  CFDataRef v26 = 0;
  if (ctu::cf::convert_copy())
  {
    CFDataRef v3 = v20;
    CFDataRef v20 = v26;
    CFDataRef v27 = v3;
    sub_100030068((const void **)&v27);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  CFDataRef data = v20;
  CFDataRef v20 = 0;
  sub_100030068((const void **)&v20);
  if (theDict)
  {
    CFDictionaryRef v22 = theDict;
    operator delete(theDict);
  }
  if (v16)
  {
    CFStringRef v17 = v16;
    operator delete(v16);
  }
  CFDictionaryRef theDict = 0;
  __p[0] = (void *)CFPropertyListCreateWithData(0, data, 0, 0, 0);
  sub_100084068(&theDict, (CFTypeRef *)__p);
  CFDictionaryRef v4 = theDict;
  if (theDict) {
    CFDataRef v5 = sub_100080778;
  }
  else {
    CFDataRef v5 = 0;
  }
  if (v5)
  {
    *(_OWORD *)(a2 + 32) = 0uLL;
    *(_OWORD *)(a2 + 48) = 0uLL;
    *(_OWORD *)a2 = 0uLL;
    *(_OWORD *)(a2 + 16) = 0uLL;
    if (CFDictionaryGetValue(v4, @"kAccessTokenKey"))
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v25 = 0;
      ctu::cf::assign();
      long long v6 = *(_OWORD *)__p;
      uint64_t v7 = v25;
      uint64_t v8 = *(void **)a2;
      if (*(void *)a2)
      {
        *(void *)(a2 + 8) = v8;
        long long v14 = v6;
        operator delete(v8);
        long long v6 = v14;
        *(void *)a2 = 0;
        *(void *)(a2 + 8) = 0;
        *(void *)(a2 + 16) = 0;
      }
      *(_OWORD *)a2 = v6;
      *(void *)(a2 + 16) = v7;
    }
    if (CFDictionaryGetValue(theDict, @"kRefreshTokenKey"))
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v25 = 0;
      ctu::cf::assign();
      long long v9 = *(_OWORD *)__p;
      uint64_t v10 = v25;
      unsigned int v11 = *(void **)(a2 + 24);
      if (v11)
      {
        *(void *)(a2 + 32) = v11;
        long long v15 = v9;
        operator delete(v11);
        long long v9 = v15;
        *(void *)(a2 + 24) = 0;
        *(void *)(a2 + 32) = 0;
        *(void *)(a2 + 40) = 0;
      }
      *(_OWORD *)(a2 + 24) = v9;
      *(void *)(a2 + 40) = v10;
    }
    CFDictionaryRef Value = (void *)CFDictionaryGetValue(theDict, @"kExpiresAtKey");
    if (Value)
    {
      __p[0] = Value;
      sub_10007CA10((const void **)(a2 + 48), (CFTypeRef *)__p);
    }
  }
  else
  {
    *(_OWORD *)(a2 + 42) = 0uLL;
    *(_OWORD *)(a2 + 16) = 0uLL;
    *(_OWORD *)(a2 + 32) = 0uLL;
    *(_OWORD *)a2 = 0uLL;
  }
  sub_100057D78((const void **)&theDict);
  return sub_100030068((const void **)&data);
}

void sub_100BE9318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, const void *a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  sub_100079C54(v22);
  sub_100057D78((const void **)&a18);
  sub_100030068(&a14);
  _Unwind_Resume(a1);
}

void sub_100BE93BC(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v14 = 0;
  long long v15 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *a1);
  CFDictionaryRef v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    long long v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v5;
  long long v9 = sub_10004D37C(&v4[1].__m_.__sig, &v16);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v14 = v11;
  long long v15 = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
  if (v11)
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v13 = 0;
    sub_100BE87C8((uint64_t)__p, (uint64_t)a2);
    if (SHIBYTE(v13) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_100BE94E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BE9514(Registry **a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v21 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v21);
  id v6 = +[NSMutableArray array];
  [v6 addObject:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@=%@", @"grant_type", @"refresh_token"];
  [v6 addObject:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@=%@", @"refresh_token", objc_msgSend(objc_alloc((Class)NSString), "initWithBytes:length:encoding:", *(void *)(a2 + 24), *(void *)(a2 + 32) - *(void *)(a2 + 24), 4))];
  uint64_t v19 = 0;
  CFDataRef v20 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *a1);
  long long v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v22 = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v22);
  if (v14)
  {
    uint64_t v16 = v14[3];
    long long v15 = (std::__shared_weak_count *)v14[4];
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v16 = 0;
    long long v15 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v19 = v16;
  CFDataRef v20 = v15;
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
  }
  *(void *)&long long v22 = 0;
  carrier_space::getCarrierSpaceValueForKey();
  sub_100056248(&v22, &v18);
  sub_1000577C4(&v18);
  if ((void)v22) {
    CFStringRef v17 = sub_1000810B8;
  }
  else {
    CFStringRef v17 = 0;
  }
  if (v17) {
    [v6 addObject:+[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@=%@", @"scope", (void)v22)];
  }
  sub_1000558F4((const void **)&v22);
  objc_msgSend(objc_msgSend(objc_msgSend(v6, "componentsJoinedByString:", @"&"), "stringByAddingPercentEncodingWithAllowedCharacters:", +[NSCharacterSet URLQueryAllowedCharacterSet](NSCharacterSet, "URLQueryAllowedCharacterSet")), "dataUsingEncoding:", 4);
  long long v22 = 0uLL;
  uint64_t v23 = 0;
  ctu::cf::assign();
  *(_OWORD *)a3 = v22;
  *(void *)(a3 + 16) = v23;
  if (v20) {
    sub_10004D2C8(v20);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v21);
}

void sub_100BE977C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, std::__shared_weak_count *a13, char a14, void *__p, uint64_t a16)
{
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&a14);
  _Unwind_Resume(a1);
}

void sub_100BE97F0(uint64_t a1@<X8>)
{
  sub_100BE9F30(v2, off_101A46658, &off_101A46660);
  sub_1002369E0(a1, (long long *)v2, 1);
  if (v5 < 0) {
    operator delete(__p);
  }
  if (v3 < 0) {
    operator delete(v2[0]);
  }
}

void sub_100BE9890(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001085D8((uint64_t)va);
  _Unwind_Resume(a1);
}

const void **sub_100BE98AC@<X0>(const void **result@<X0>, Registry **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  id v6 = *(const void **)a3;
  uint64_t v7 = *(void *)(a3 + 8);
  if (v6 == (const void *)v7)
  {
    *(_OWORD *)(a4 + 42) = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)a4 = 0u;
    return result;
  }
  unsigned int v8 = (os_log_t *)result;
  uint64_t v37 = 0;
  xpc_object_t v38 = 0;
  uint64_t v35 = 0;
  long long v36 = 0;
  sub_10005C928(&v35, v6, v7, v7 - (void)v6);
  xpc_object_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v40 = 0;
  sub_10005C928(&v40, v35, (uint64_t)v36, v36 - (unsigned char *)v35);
  long long v39 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v46 = 0;
  sub_10005C928(__p, v40, (uint64_t)v41, v41 - (unsigned char *)v40);
  xpc_object_t v43 = 0;
  if (ctu::cf::convert_copy())
  {
    long long v9 = v39;
    long long v39 = v43;
    xpc_object_t v44 = v9;
    sub_100030068(&v44);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  xpc_object_t v38 = v39;
  long long v39 = 0;
  sub_100030068(&v39);
  if (v40)
  {
    xpc_object_t v41 = v40;
    operator delete(v40);
  }
  if (v35)
  {
    long long v36 = v35;
    operator delete(v35);
  }
  if (v38) {
    uint64_t v10 = sub_10008324C;
  }
  else {
    uint64_t v10 = 0;
  }
  if (!v10)
  {
    uint64_t v14 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not convert refresh token response to data blob", (uint8_t *)__p, 2u);
    }
    *(_OWORD *)(a4 + 42) = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)a4 = 0u;
    return sub_100030068(&v38);
  }
  uint64_t v40 = 0;
  ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v40);
  xpc_object_t v44 = 0;
  id v11 = +[NSJSONSerialization JSONObjectWithData:v38 options:0 error:&v44];
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_18;
  }
  id v12 = [v11 objectForKeyedSubscript:@"error"];
  if (!v12)
  {
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    id v15 = [v11 objectForKeyedSubscript:@"access_token"];
    if (v15)
    {
      [v15 dataUsingEncoding:4];
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v46 = 0;
      ctu::cf::assign();
      uint64_t v16 = v46;
      *(_OWORD *)a4 = *(_OWORD *)__p;
      *(void *)(a4 + 16) = v16;
    }
    id v17 = [v11 objectForKeyedSubscript:@"refresh_token"];
    if (v17)
    {
      [v17 dataUsingEncoding:4];
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v46 = 0;
      ctu::cf::assign();
      uint64_t v18 = v46;
      *(_OWORD *)(a4 + 24) = *(_OWORD *)__p;
      *(void *)(a4 + 40) = v18;
    }
    id v20 = [v11 objectForKeyedSubscript:@"expires_in"];
    if (!v20) {
      goto LABEL_19;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v19, *a2);
    long long v22 = ServiceMap;
    if (v23 < 0)
    {
      uint64_t v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        uint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v23;
    CFDataRef v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)__p);
    if (v27)
    {
      uint64_t v29 = v27[3];
      __int16 v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    __int16 v28 = 0;
    char v30 = 1;
LABEL_38:
    double v31 = (*(double (**)(uint64_t))(*(void *)v29 + 96))(v29);
    CFDateRef v32 = CFDateCreate(0, v31 + (double)(uint64_t)[v20 integerValue]);
    uint64_t v33 = *(void **)(a4 + 48);
    *(void *)(a4 + 48) = v32;
    __p[0] = v33;
    sub_10007CA64((const void **)__p);
    if ((v30 & 1) == 0) {
      sub_10004D2C8(v28);
    }
    goto LABEL_19;
  }
  unsigned int v13 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
  {
    id v34 = [v12 UTF8String];
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = v34;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Refresh token response contains error: %s", (uint8_t *)__p, 0xCu);
  }
LABEL_18:
  *(_OWORD *)(a4 + 42) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
LABEL_19:
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v40);
  return sub_100030068(&v38);
}

void sub_100BE9CE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100BE9E5C@<X0>(CFDateRef *a1@<X0>, uint64_t a2@<X8>)
{
  id v6 = CFDateFormatterCreate(kCFAllocatorDefault, 0, kCFDateFormatterShortStyle, kCFDateFormatterFullStyle);
  CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(kCFAllocatorDefault, v6, *a1);
  long long v7 = 0uLL;
  uint64_t v8 = 0;
  ctu::cf::assign();
  *(_OWORD *)a2 = 0uLL;
  *(void *)(a2 + 16) = v8;
  sub_1000558F4((const void **)&StringWithDate);
  return sub_100201E7C((const void **)&v6);
}

void sub_100BE9EFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a10);
  sub_100201E7C(&a11);
  _Unwind_Resume(a1);
}

void *sub_100BE9F30(void *a1, char **a2, char **a3)
{
  char v5 = sub_100058DB0(a1, *a2);
  sub_100058DB0(v5 + 3, *a3);
  return a1;
}

void sub_100BE9F6C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BE9F88(unsigned char *a1, os_log_t *a2)
{
  char v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    CFDictionaryRef v4 = "true";
    if (*a1) {
      char v5 = "true";
    }
    else {
      char v5 = "false";
    }
    int v6 = a1[2];
    if (a1[1]) {
      long long v7 = "true";
    }
    else {
      long long v7 = "false";
    }
    int v8 = 136315650;
    if (!v6) {
      CFDictionaryRef v4 = "false";
    }
    long long v9 = v5;
    __int16 v10 = 2080;
    id v11 = v7;
    __int16 v12 = 2080;
    unsigned int v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I fResetInProgress = %s, fServiceProvisioningInProgress = %s, fPendingToProcessSiuint64_t m = %s", (uint8_t *)&v8, 0x20u);
  }
}

void sub_100BEA06C(uint64_t a1, int a2, os_log_t *a3)
{
  char v3 = a2;
  int v5 = *(unsigned __int8 *)(a1 + 2);
  *(_WORD *)a1 = 0;
  *(unsigned char *)(a1 + 2) = 0;
  if (v5) {
    BOOL v6 = a2 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    long long v7 = *a3;
    if (os_log_type_enabled(*a3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Retaining pending SIM info event to process", v8, 2u);
    }
    *(unsigned char *)(a1 + 2) = 1;
  }
  if ((v3 & 1) == 0) {
    *(unsigned char *)a1 = 1;
  }
}

uint64_t sub_100BEA108(void *a1, uint64_t a2, int a3, uint64_t *a4, uint64_t a5)
{
  int v5 = (os_log_t *)a1[3];
  if (a1[4])
  {
    memset(buf, 0, sizeof(buf));
    uint64_t v24 = 0;
    if (a3 == 6)
    {
      sub_100058DB0(buf, "gri");
    }
    else if (a3)
    {
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(buf, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)a2;
        uint64_t v24 = *(void *)(a2 + 16);
      }
    }
    else
    {
      sub_100058DB0(buf, "pri");
    }
    id v11 = (std::__shared_weak_count *)a1[2];
    if (!v11 || (uint64_t v12 = a1[1], (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v14 = v13;
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v13);
    id v15 = (uint64_t (***)(void, uint8_t *, void **, uint64_t))a1[4];
    if (SHIBYTE(v24) < 0)
    {
      sub_10004FC84(&__dst, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      long long __dst = *(_OWORD *)buf;
      uint64_t v35 = v24;
    }
    *(void *)id v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    v25[0] = (void **)v20;
    v25[1] = 0;
    *(void *)id v20 = operator new(0x18uLL);
    uint64_t v21 = *(char **)v20;
    uint64_t v22 = *(void *)v20 + 24;
    uint64_t v21 = sub_1000D8A18((uint64_t)&v22, &__dst, &v36, *(char **)v20);
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    aBlock[2] = sub_100BEA564;
    aBlock[3] = &unk_101A466C0;
    aBlock[4] = a1;
    void aBlock[5] = v12;
    CFDataRef v27 = v14;
    atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    __int16 v28 = v5;
    sub_100BEB2BC((uint64_t)v29, a5);
    if (SHIBYTE(v24) < 0)
    {
      sub_10004FC84(&__p, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      long long __p = *(_OWORD *)buf;
      uint64_t v31 = v24;
    }
    uint64_t v16 = (std::__shared_weak_count *)a4[1];
    uint64_t v32 = *a4;
    uint64_t v33 = v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v19 = _Block_copy(aBlock);
    uint64_t v10 = (**v15)(v15, v20, &v19, 5);
    if (v19) {
      _Block_release(v19);
    }
    v25[0] = (void **)v20;
    sub_100047F64(v25);
    if (SHIBYTE(v35) < 0)
    {
      operator delete((void *)__dst);
      if (v10)
      {
LABEL_30:
        if (v33) {
          sub_10004D2C8(v33);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete((void *)__p);
        }
        sub_100BEB238(v29);
        if (v27) {
          std::__shared_weak_count::__release_weak(v27);
        }
        std::__shared_weak_count::__release_weak(v14);
        if (SHIBYTE(v24) < 0) {
          operator delete(*(void **)buf);
        }
        return v10;
      }
    }
    else if (v10)
    {
      goto LABEL_30;
    }
    id v17 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v20 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Queuing file failed", v20, 2u);
    }
    goto LABEL_30;
  }
  long long v9 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to create write session", buf, 2u);
  }
  return 0;
}

void sub_100BEA490(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42)
{
  sub_100BEB238(v43);
  if (a29) {
    std::__shared_weak_count::__release_weak(a29);
  }
  a21 = &a11;
  sub_100047F64((void ***)&a21);
  if (*(char *)(v44 - 89) < 0) {
    operator delete(*(void **)(v44 - 112));
  }
  std::__shared_weak_count::__release_weak(v42);
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100BEA564(uint64_t a1, uint64_t a2, int a3)
{
  CFDictionaryRef v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    BOOL v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      long long v7 = v6;
      uint64_t v8 = *(void *)(a1 + 40);
      if (v8)
      {
        if (a3)
        {
          long long v9 = **(NSObject ***)(a1 + 56);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136315138;
            uint64_t v21 = hsfiler::support::to_string();
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Queuing file status: %s", buf, 0xCu);
          }
          if (a3 != 1) {
            sub_100BEA81C(*(void *)(a1 + 88), 1);
          }
        }
        else
        {
          uint64_t v10 = *(std::__shared_weak_count **)(a1 + 128);
          id v15 = v10;
          if (v10)
          {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v8 = *(void *)(a1 + 40);
          }
          aBlock[0] = _NSConcreteStackBlock;
          aBlock[1] = 1174405120;
          aBlock[2] = sub_100BEA86C;
          aBlock[3] = &unk_101A46690;
          id v11 = *(std::__shared_weak_count **)(a1 + 48);
          aBlock[4] = v8;
          id v17 = v11;
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v18 = *(void *)(a1 + 56);
          sub_100BEB2BC((uint64_t)v19, a1 + 64);
          uint64_t v14 = _Block_copy(aBlock);
          char v12 = HSFilerWriteSession::writeWithStream();
          if (v14) {
            _Block_release(v14);
          }
          if (v15) {
            sub_10004D2C8(v15);
          }
          if ((v12 & 1) == 0)
          {
            unsigned int v13 = **(NSObject ***)(a1 + 56);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Writing file failed", buf, 2u);
            }
            sub_100BEA81C(*(void *)(a1 + 88), 1);
          }
          sub_100BEB238(v19);
          if (v17) {
            std::__shared_weak_count::__release_weak(v17);
          }
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100BEA794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  sub_100BEB238(v18);
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100BEA81C(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

void sub_100BEA86C(uint64_t a1, uint64_t a2, int a3)
{
  CFDictionaryRef v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4)
  {
    BOOL v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      long long v7 = v6;
      if (*(void *)(a1 + 32) && a3 != 1)
      {
        if (a3)
        {
          char v10 = 1;
        }
        else
        {
          uint64_t v8 = **(NSObject ***)(a1 + 48);
          BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
          char v10 = 0;
          if (v9)
          {
            *(_WORD *)id v11 = 0;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Writing file was successful", v11, 2u);
            char v10 = 0;
          }
        }
        sub_100BEA81C(*(void *)(a1 + 80), v10);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100BEA928(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100BEA93C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_100BEB2BC(a1 + 56, a2 + 56);
}

void sub_100BEA980(_Unwind_Exception *exception_object)
{
  char v3 = *(std::__shared_weak_count **)(v1 + 40);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BEA998(uint64_t a1)
{
  sub_100BEB238((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

unsigned char *sub_100BEA9E4(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_100BEB2BC((uint64_t)(a1 + 8), a2 + 64);
  uint64_t result = a1 + 12;
  if (*(char *)(a2 + 119) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)(a2 + 96), *(void *)(a2 + 104));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 96);
    a1[14] = *(void *)(a2 + 112);
    *(_OWORD *)uint64_t result = v6;
  }
  uint64_t v7 = *(void *)(a2 + 128);
  a1[15] = *(void *)(a2 + 120);
  a1[16] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100BEAA7C(_Unwind_Exception *a1)
{
  sub_100BEB238(v2);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 48);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100BEAAA4(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 64);
  char v3 = *(std::__shared_weak_count **)(a1 + 128);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  sub_100BEB238(v2);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t sub_100BEAB10@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = capabilities::ct::supportsHiSpeedFiler(a1);
  if (result) {
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void sub_100BEAB94()
{
}

void *sub_100BEABB8(void *a1)
{
  uint64_t v2 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "hs.filer");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v5, &v7);
  ctu::OsLogLogger::OsLogLogger(v2, (const ctu::OsLogLogger *)&v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  v6[0] = off_101999E18;
  v6[1] = sub_100BEAE70;
  void v6[3] = v6;
  a1[2] = 0;
  if ((capabilities::ct::supportsGemini(v3) & 1) == 0) {
    operator new();
  }
  if (!a1[2]) {
    operator new();
  }
  sub_10008863C(v6);
  *a1 = off_101A46700;
  return a1;
}

void sub_100BEADC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

const char *sub_100BEAE70(int a1)
{
  uint64_t v1 = "hs.filer.?";
  if (a1 == 2) {
    uint64_t v1 = "hs.filer.2";
  }
  if (a1 == 1) {
    return "hs.filer.1";
  }
  else {
    return v1;
  }
}

void sub_100BEAE9C(void *a1)
{
  uint64_t v2 = a1[2];
  a1[2] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  HiSpeedFilerFactoryInterface::~HiSpeedFilerFactoryInterface((HiSpeedFilerFactoryInterface *)a1);
}

void sub_100BEAF0C(void *a1)
{
  sub_100BEAE9C(a1);

  operator delete();
}

void sub_100BEAF44()
{
}

void sub_100BEB0CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  _Unwind_Resume(a1);
}

void sub_100BEB154(HiSpeedFilerWriteSessionInterface *this)
{
  *(void *)this = off_101A46678;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  HiSpeedFilerWriteSessionInterface::~HiSpeedFilerWriteSessionInterface(this);
}

void sub_100BEB1BC(HiSpeedFilerWriteSessionInterface *this)
{
  *(void *)this = off_101A46678;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  HiSpeedFilerWriteSessionInterface::~HiSpeedFilerWriteSessionInterface(this);

  operator delete();
}

void *sub_100BEB238(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100BEB2BC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_100BEB354(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100BEB3BC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BEB3F8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BEB430(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100BEB460(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100BEB4A8()
{
}

uint64_t sub_100BEB4BC(uint64_t a1)
{
  return *(void *)(a1 + 8) + 8;
}

void sub_100BEB4CC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BEB504(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100BEB534(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100BEB578()
{
}

void sub_100BEB764()
{
}

void sub_100BEB794(_Unwind_Exception *a1)
{
}

void sub_100BEB7E4(ctu::DispatchTimerService *a1)
{
  ctu::DispatchTimerService::~DispatchTimerService(a1);

  operator delete();
}

void sub_100BEB820(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BEB858(uint64_t a1)
{
}

uint64_t sub_100BEB874(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BEB8B8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

uint64_t *sub_100BEB8E4(void **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v2;
  (*(void (**)(void, uint64_t))(*(void *)*v2 + 56))(*v2, a2);
  sub_1000E3958((uint64_t *)&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100BEB948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100BEB964(uint64_t a1, int a2, long long *a3)
{
  *(void *)a1 = off_101A469F0;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    *(void *)(a1 + 24) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 8) = v5;
  }
  sub_100561B00(a1 + 32);
  *(_DWORD *)(a1 + 56) = a2;
  return a1;
}

void sub_100BEB9E8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BEBA04(uint64_t a1)
{
  *(void *)a1 = off_101A469F0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_100BEBA6C@<X0>(char *a1@<X0>, void *a2@<X8>)
{
  uint64_t v38 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v27 = 0u;
  memset(v25, 0, sizeof(v25));
  long long v24 = 0u;
  sub_10004BD84((uint64_t)&v24);
  uint64_t v4 = sub_10004B96C(v25, (uint64_t)"[", 1);
  unsigned int v5 = (*(uint64_t (**)(char *))(*(void *)a1 + 16))(a1) - 1;
  if (v5 > 4) {
    long long v6 = "kInvalid";
  }
  else {
    long long v6 = off_101A46BD8[v5];
  }
  size_t v7 = strlen(v6);
  uint64_t v8 = sub_10004B96C(v4, (uint64_t)v6, v7);
  BOOL v9 = sub_10004B96C(v8, (uint64_t)"]", 1);
  char v10 = sub_10004B96C(v9, (uint64_t)" [Type: ", 8);
  id v11 = (const char *)Lazuli::asString();
  size_t v12 = strlen(v11);
  unsigned int v13 = sub_10004B96C(v10, (uint64_t)v11, v12);
  uint64_t v14 = sub_10004B96C(v13, (uint64_t)", UUID: ", 8);
  id v15 = a1 + 8;
  if (a1[31] < 0) {
    id v15 = *(const char **)v15;
  }
  size_t v16 = strlen(v15);
  id v17 = sub_10004B96C(v14, (uint64_t)v15, v16);
  uint64_t v18 = sub_10004B96C(v17, (uint64_t)", TID: ", 7);
  uint64_t v19 = a1 + 32;
  if (a1[55] < 0) {
    uint64_t v19 = *(const char **)v19;
  }
  size_t v20 = strlen(v19);
  uint64_t v21 = sub_10004B96C(v18, (uint64_t)v19, v20);
  sub_10004B96C(v21, (uint64_t)"]", 1);
  sub_10004BC98((uint64_t)v25 + 8, a2);
  *(void *)((char *)&v25[-1]
  *(void *)&v25[0] = v22;
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100BEBD4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100BEBD60(void *a1, int a2, uint64_t a3, long long *a4)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v11 = *(void *)(a3 + 16);
  }
  sub_100BEB964((uint64_t)a1, a2, (long long *)__p);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A46A18;
  size_t v7 = a1 + 8;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v8 = *a4;
    a1[10] = *((void *)a4 + 2);
    *(_OWORD *)size_t v7 = v8;
  }
  return a1;
}

void sub_100BEBE28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_100BEBA04(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_100BEBE54(uint64_t a1)
{
  *(void *)a1 = off_101A46A18;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }

  return sub_100BEBA04(a1);
}

void sub_100BEBEBC(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  long long __dst = 0uLL;
  uint64_t v18 = 0;
  if (*(char *)(a1 + 31) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a1 + 8), *(void *)(a1 + 16));
  }
  else
  {
    long long __dst = *(_OWORD *)(a1 + 8);
    uint64_t v18 = *(void *)(a1 + 24);
  }
  sub_100058DB0(&v15, "__");
  if (v18 >= 0) {
    p_dst = (const std::string::value_type *)&__dst;
  }
  else {
    p_dst = (const std::string::value_type *)__dst;
  }
  if (v18 >= 0) {
    std::string::size_type v5 = HIBYTE(v18);
  }
  else {
    std::string::size_type v5 = *((void *)&__dst + 1);
  }
  long long v6 = std::string::insert(&v15, 0, p_dst, v5);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  char v10 = *(const std::string::value_type **)(a1 + 64);
  uint64_t v9 = a1 + 64;
  long long v8 = v10;
  int v11 = *(char *)(v9 + 23);
  if (v11 >= 0) {
    size_t v12 = (const std::string::value_type *)v9;
  }
  else {
    size_t v12 = v8;
  }
  if (v11 >= 0) {
    std::string::size_type v13 = *(unsigned __int8 *)(v9 + 23);
  }
  else {
    std::string::size_type v13 = *(void *)(v9 + 8);
  }
  uint64_t v14 = std::string::append(&v16, v12, v13);
  *a2 = *v14;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__dst);
  }
}

void sub_100BEBFD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (*(char *)(v21 - 25) < 0) {
    operator delete(*(void **)(v21 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_100BEC024(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  memset(&__str, 0, sizeof(__str));
  if (*(char *)(a1 + 23) < 0) {
    sub_10004FC84(&__str, *(void **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string __str = *(std::string *)a1;
  }
  int64_t size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_str = &__str;
  }
  else
  {
    int64_t size = __str.__r_.__value_.__l.__size_;
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if (size >= 2)
  {
    long long v6 = (char *)p_str + size;
    long long v7 = p_str;
    do
    {
      long long v8 = (char *)memchr(v7, 95, size - 1);
      if (!v8) {
        break;
      }
      if (*(_WORD *)v8 == 24415)
      {
        if (v8 != v6)
        {
          std::string::size_type v9 = v8 - (char *)p_str;
          if (v9 != -1)
          {
            std::string::basic_string(&v11, &__str, 0, v9, (std::allocator<char> *)&v10);
            std::string::basic_string(&v10, &__str, v9 + 2, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v13);
            *a2 = v11;
            a2[1] = v10;
            goto LABEL_18;
          }
        }
        break;
      }
      long long v7 = (std::string *)(v8 + 1);
      int64_t size = v6 - (char *)v7;
    }
    while (v6 - (char *)v7 >= 2);
  }
  memset(&v11, 0, sizeof(v11));
  sub_100720B70((char *)a2, (long long *)a1, (long long *)&v11);
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
LABEL_18:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_100BEC190(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100BEC1C8(void *a1, int a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v7 = *(void *)(a3 + 16);
  }
  sub_100BEB964((uint64_t)a1, a2, (long long *)__p);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A46A40;
  return a1;
}

void sub_100BEC25C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100BEC280(void *a1, int a2, uint64_t a3, long long *a4, long long *a5)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v13 = *(void *)(a3 + 16);
  }
  sub_100BEBD60(a1, a2, (uint64_t)__p, a5);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A46A68;
  std::string::size_type v9 = a1 + 11;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(v9, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v10 = *a4;
    a1[13] = *((void *)a4 + 2);
    *(_OWORD *)std::string::size_type v9 = v10;
  }
  return a1;
}

void sub_100BEC350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_100BEBE54(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_100BEC37C(uint64_t a1)
{
  *(void *)a1 = off_101A46A68;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }

  return sub_100BEBE54(a1);
}

void sub_100BEC3E0(uint64_t a1)
{
  sub_100BEC37C(a1);

  operator delete();
}

uint64_t sub_100BEC418()
{
  return 3;
}

void *sub_100BEC420(void *a1, int a2, uint64_t a3, long long *a4)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v11 = *(void *)(a3 + 16);
  }
  sub_100BEC1C8(a1, a2, (uint64_t)__p);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A46A90;
  uint64_t v7 = a1 + 8;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v8 = *a4;
    a1[10] = *((void *)a4 + 2);
    *(_OWORD *)uint64_t v7 = v8;
  }
  return a1;
}

void sub_100BEC4E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_100BEBA04(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_100BEC514(uint64_t a1)
{
  *(void *)a1 = off_101A46A90;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }

  return sub_100BEBA04(a1);
}

void sub_100BEC578(uint64_t a1)
{
  sub_100BEC514(a1);

  operator delete();
}

uint64_t sub_100BEC5B0()
{
  return 1;
}

uint64_t sub_100BEC5B8(uint64_t a1, int a2, uint64_t a3, long long **a4, long long *a5)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v13 = *(void *)(a3 + 16);
  }
  sub_100BEC1C8((void *)a1, a2, (uint64_t)__p);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  *(void *)a1 = off_101A46AB8;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  sub_100938284((char *)(a1 + 64), *a4, a4[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a4[1] - (char *)*a4) >> 3));
  std::string::size_type v9 = (unsigned char *)(a1 + 88);
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(v9, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v10 = *a5;
    *(void *)(a1 + 104) = *((void *)a5 + 2);
    *(_OWORD *)std::string::size_type v9 = v10;
  }
  return a1;
}

void sub_100BEC6B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  sub_100047F64((void ***)&a15);
  sub_100BEBA04(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100BEC6F0(uint64_t a1)
{
  *(void *)a1 = off_101A46AB8;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  uint64_t v3 = (void **)(a1 + 64);
  sub_100047F64(&v3);
  return sub_100BEBA04(a1);
}

void sub_100BEC760(uint64_t a1)
{
  sub_100BEC6F0(a1);

  operator delete();
}

uint64_t sub_100BEC798()
{
  return 5;
}

uint64_t sub_100BEC7A0(uint64_t a1, int a2, uint64_t a3, long long *a4, long long *a5, long long *a6, long long *a7)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v19 = *(void *)(a3 + 16);
  }
  sub_100BEBD60((void *)a1, a2, (uint64_t)__p, a6);
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  *(void *)a1 = off_101A46AE0;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 88), *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v13 = *a4;
    *(void *)(a1 + 104) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 88) = v13;
  }
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 112), *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v14 = *a5;
    *(void *)(a1 + 128) = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 112) = v14;
  }
  uint64_t v15 = (unsigned char *)(a1 + 136);
  if (*((char *)a7 + 23) < 0)
  {
    sub_10004FC84(v15, *(void **)a7, *((void *)a7 + 1));
  }
  else
  {
    long long v16 = *a7;
    *(void *)(a1 + 152) = *((void *)a7 + 2);
    *(_OWORD *)uint64_t v15 = v16;
  }
  return a1;
}

void sub_100BEC8D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (*(char *)(v14 + 135) < 0) {
    operator delete(*v16);
  }
  if (*(char *)(v14 + 111) < 0) {
    operator delete(*v15);
  }
  sub_100BEBE54(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_100BEC934()
{
  return 4;
}

uint64_t sub_100BEC93C(uint64_t a1)
{
  *(void *)a1 = off_101A46AE0;
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }

  return sub_100BEBE54(a1);
}

void sub_100BEC9C0(uint64_t a1)
{
  sub_100BEC93C(a1);

  operator delete();
}

void *sub_100BEC9F8(void *a1, int a2, uint64_t a3, long long *a4)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v11 = *(void *)(a3 + 16);
  }
  sub_100BEC1C8(a1, a2, (uint64_t)__p);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A46B08;
  uint64_t v7 = a1 + 8;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v8 = *a4;
    a1[10] = *((void *)a4 + 2);
    *(_OWORD *)uint64_t v7 = v8;
  }
  return a1;
}

void sub_100BECAC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_100BEBA04(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_100BECAEC()
{
  return 2;
}

uint64_t sub_100BECAF4(uint64_t a1)
{
  *(void *)a1 = off_101A46B08;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }

  return sub_100BEBA04(a1);
}

void sub_100BECB58(uint64_t a1)
{
  sub_100BECAF4(a1);

  operator delete();
}

void sub_100BECB94()
{
}

const void **sub_100BECBA8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v13) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v17 = v13;
  }
  uint64_t v15 = 0;
  if (SHIBYTE(v17) < 0)
  {
    sub_10004FC84(&v18, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long v18 = *(_OWORD *)__p;
    uint64_t v19 = v17;
  }
  size_t v20 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v4 = v15;
    uint64_t v15 = v20;
    uint64_t v21 = v4;
    sub_1000558F4(&v21);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete((void *)v18);
  }
  CFTypeRef cf = v15;
  uint64_t v15 = 0;
  sub_1000558F4(&v15);
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(__dst[0]);
  }
  pthread_mutex_lock(&stru_101B09E48);
  std::string::size_type v5 = (void *)off_101B09E88;
  if (!off_101B09E88) {
    sub_1012D6D0C(&v18);
  }
  long long v6 = (std::__shared_weak_count *)*(&off_101B09E88 + 1);
  if (*(&off_101B09E88 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_101B09E88 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_101B09E48);
  CFTypeRef v11 = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v7 = *a3;
  long long v8 = (std::__shared_weak_count *)a3[1];
  v10[0] = v7;
  v10[1] = v8;
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_1012D7700(v5, &v11, (uint64_t)v10);
    sub_10004D2C8(v8);
  }
  else
  {
    sub_1012D7700(v5, &v11, (uint64_t)v10);
  }
  sub_1000558F4(&v11);
  if (v6) {
    sub_10004D2C8(v6);
  }
  return sub_1000558F4(&cf);
}

void sub_100BECDBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, const void *a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
}

const void **sub_100BECE40(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v13) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v17 = v13;
  }
  uint64_t v15 = 0;
  if (SHIBYTE(v17) < 0)
  {
    sub_10004FC84(&v18, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long v18 = *(_OWORD *)__p;
    uint64_t v19 = v17;
  }
  size_t v20 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v4 = v15;
    uint64_t v15 = v20;
    uint64_t v21 = v4;
    sub_1000558F4(&v21);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete((void *)v18);
  }
  CFTypeRef cf = v15;
  uint64_t v15 = 0;
  sub_1000558F4(&v15);
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(__dst[0]);
  }
  pthread_mutex_lock(&stru_101B09E48);
  std::string::size_type v5 = (void *)off_101B09E88;
  if (!off_101B09E88) {
    sub_1012D6D0C(&v18);
  }
  long long v6 = (std::__shared_weak_count *)*(&off_101B09E88 + 1);
  if (*(&off_101B09E88 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(&off_101B09E88 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&stru_101B09E48);
  CFTypeRef v11 = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v7 = *a3;
  long long v8 = (std::__shared_weak_count *)a3[1];
  v10[0] = v7;
  v10[1] = v8;
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_1012D8040(v5, &v11, (uint64_t)v10);
    sub_10004D2C8(v8);
  }
  else
  {
    sub_1012D8040(v5, &v11, (uint64_t)v10);
  }
  sub_1000558F4(&v11);
  if (v6) {
    sub_10004D2C8(v6);
  }
  return sub_1000558F4(&cf);
}

void sub_100BED054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, const void *a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
}

uint64_t sub_100BED0D8()
{
  if ((byte_101B09E98 & 1) == 0)
  {
    byte_101B09E98 = 1;
    return __cxa_atexit((void (*)(void *))sub_10021691C, &stru_101B09E48, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_100BED114@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = capabilities::ct::supportsPhoneNumberRegistration(a1);
  *a2 = 0;
  a2[1] = 0;
  if (result) {
    operator new();
  }
  return result;
}

void sub_100BED64C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void sub_100BED8A4(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  JUMPOUT(0x100BED870);
}

void sub_100BED8CC()
{
}

const char *sub_100BED8D4(int a1)
{
  uint64_t v1 = "msg.pnr.ctr?";
  if (a1 == 2) {
    uint64_t v1 = "msg.pnr.ctr.2";
  }
  if (a1 == 1) {
    return "msg.pnr.ctr.1";
  }
  else {
    return v1;
  }
}

void sub_100BED900(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BEDA00(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100BEDB04(uint64_t a1, uint64_t a2, int a3)
{
  int v7 = a3;
  v6[0] = a1;
  v6[1] = a2;
  void v6[2] = &v7;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  int v8[2] = sub_100BEF7E4;
  v8[3] = &unk_101A46FB0;
  v8[4] = a1 + 8;
  void v8[5] = v6;
  std::string::size_type v9 = v8;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v16 = 0;
    blocCFIndex k = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    size_t v12 = sub_10005B158;
    uint64_t v13 = &unk_101A46FF0;
    uint64_t v14 = &v16;
    uint64_t v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v16 = 0;
    blocCFIndex k = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    size_t v12 = sub_10005A3F4;
    uint64_t v13 = &unk_101A46FD0;
    uint64_t v14 = &v16;
    uint64_t v15 = &v9;
    dispatch_sync(v3, &block);
  }
  return v16 != 0;
}

const void **sub_100BEDC44(uint64_t a1, CFTypeRef cf)
{
  CFStringRef v4 = CFCopyDescription(cf);
  long long v5 = 0uLL;
  uint64_t v6 = 0;
  ctu::cf::assign();
  *(_OWORD *)a1 = 0uLL;
  *(void *)(a1 + 16) = v6;
  return sub_1000558F4((const void **)&v4);
}

void sub_100BEDCA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)&a9);
  _Unwind_Resume(a1);
}

BOOL sub_100BEDCC4(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100BF0744;
  _OWORD v7[3] = &unk_101A47010;
  void v7[4] = a1 + 8;
  void v7[5] = v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    blocCFIndex k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005B158;
    size_t v12 = &unk_101A46FF0;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    blocCFIndex k = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005A3F4;
    size_t v12 = &unk_101A46FD0;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

BOOL sub_100BEDE00@<W0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v28 = 0;
  long long v29 = 0;
  long long v5 = (Registry **)(a1 + 56);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 56));
  int v7 = ServiceMap;
  if (v8 < 0)
  {
    std::string::size_type v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  size_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v14 + 8))(&v28, v14, a2);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (v28) {
    int v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v28 + 72))(v28, 1);
  }
  else {
    int v16 = 0;
  }
  if (v29) {
    sub_10004D2C8(v29);
  }
  uint64_t v17 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  long long v18 = (os_log_t *)v17;
  if (!v16)
  {
    if ((capabilities::ct::supportsPhoneNumberRegistration(v17) & 1) == 0)
    {
      uint64_t v23 = *v18;
      BOOL v24 = os_log_type_enabled(*v18, OS_LOG_TYPE_DEFAULT);
      BOOL result = 0;
      if (!v24) {
        return result;
      }
      LOWORD(v28) = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Device does not support PNR", (uint8_t *)&v28, 2u);
      return 0;
    }
    CFStringRef v20 = (const __CFString *)sub_100794BC4((NSObject **)(a1 + 40), v5, a2);
    uint64_t v28 = (uint64_t)v20;
    if (v20) {
      uint64_t v21 = sub_1000810B8;
    }
    else {
      uint64_t v21 = 0;
    }
    if (v21)
    {
      if (CFStringGetLength(v20) > 0)
      {
        sub_1000558F4((const void **)&v28);
        goto LABEL_26;
      }
      unsigned int v26 = *v18;
      if (!os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR))
      {
LABEL_35:
        sub_1000558F4((const void **)&v28);
        return 0;
      }
      *(_WORD *)long long buf = 0;
      long long v27 = "Gateway address is not valid?";
    }
    else
    {
      unsigned int v26 = *v18;
      if (!os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_35;
      }
      *(_WORD *)long long buf = 0;
      long long v27 = "Failed to find gateway address";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, v27, buf, 2u);
    goto LABEL_35;
  }
  uint64_t v19 = *(NSObject **)v17;
  if (os_log_type_enabled(*(os_log_t *)v17, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v28) = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Carrier Supports PNR over entitlements", (uint8_t *)&v28, 2u);
  }
LABEL_26:
  uint64_t v28 = 2048;
  if (IsTelephonyRunningExtended(&v28)) {
    return 1;
  }
  uint64_t v25 = *v18;
  BOOL result = os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR);
  if (result)
  {
    LOWORD(v28) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Radio Module is not present, Phone number registration is not supported", (uint8_t *)&v28, 2u);
    return 0;
  }
  return result;
}

void sub_100BEE144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_100BEE180(uint64_t a1, int a2, uint64_t a3)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  void v6[2] = a3;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  int v8[2] = sub_100BF0754;
  v8[3] = &unk_101A47030;
  v8[4] = a1 + 8;
  void v8[5] = v6;
  std::string::size_type v9 = v8;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    unsigned __int16 v16 = 0;
    blocCFIndex k = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    size_t v12 = sub_100BEF000;
    uint64_t v13 = &unk_101A46F90;
    uint64_t v14 = &v16;
    char v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    unsigned __int16 v16 = 0;
    blocCFIndex k = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    size_t v12 = sub_100BEEFC4;
    uint64_t v13 = &unk_101A46F70;
    uint64_t v14 = &v16;
    char v15 = &v9;
    dispatch_sync(v3, &block);
  }
  return v16;
}

void sub_100BEE2B8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100BEE3B8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I =====DumpState for PhoneNumberRegistrationController======", buf, 2u);
  }
  uint64_t result = subscriber::makeSimSlotRange();
  uint64_t v4 = v12;
  if (v12 != v13)
  {
    while (1)
    {
      uint64_t result = v14(*v4);
      if (result) {
        break;
      }
      if (++v4 == v13)
      {
        uint64_t v4 = v13;
        break;
      }
    }
    while (v4 != v13)
    {
      uint64_t v5 = *v4;
      int v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Slot: %s PNR request cookies:", buf, 0xCu);
      }
      long long v20 = 0u;
      long long v21 = 0u;
      *(_OWORD *)long long buf = 0u;
      sub_10119E480(*(void *)(a1 + 72), v5, buf);
      if (*((void *)&v21 + 1))
      {
        unint64_t v8 = 0;
        do
        {
          std::string::size_type v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v5);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v10 = *(void *)(*(void *)&buf[8] + 8 * ((v8 + (unint64_t)v21) / 0xAA))
                + 24 * ((v8 + (unint64_t)v21) % 0xAA);
            if (*(char *)(v10 + 23) < 0) {
              unint64_t v10 = *(void *)v10;
            }
            *(_DWORD *)char v15 = 134218242;
            unint64_t v16 = v8;
            __int16 v17 = 2080;
            unint64_t v18 = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Cookie %zu = %s", v15, 0x16u);
          }
          ++v8;
        }
        while (v8 < *((void *)&v21 + 1));
      }
      uint64_t result = sub_100BEF03C(buf);
      uint64_t v11 = v4 + 1;
      uint64_t v4 = v13;
      if (v11 != v13)
      {
        uint64_t v4 = v11;
        while (1)
        {
          uint64_t result = v14(*v4);
          if (result) {
            break;
          }
          if (++v4 == v13)
          {
            uint64_t v4 = v13;
            break;
          }
        }
      }
    }
  }
  return result;
}

void sub_100BEE680(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
}

void sub_100BEE6A0(PhoneNumberRegistrationControllerInterface *a1)
{
  sub_100BEE6D8(a1);

  operator delete();
}

PhoneNumberRegistrationControllerInterface *sub_100BEE6D8(PhoneNumberRegistrationControllerInterface *this)
{
  *(void *)this = &off_101A46C58;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  PhoneNumberRegistrationControllerInterface::~PhoneNumberRegistrationControllerInterface(this);
  ctu::OsLogLogger::~OsLogLogger((PhoneNumberRegistrationControllerInterface *)((char *)this + 40));
  sub_100087E88((void *)this + 1);
  return this;
}

void sub_100BEE7A4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BEE7DC(uint64_t a1)
{
}

uint64_t sub_100BEE7F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BEE83C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100BEE868(ServiceManager::Service *this)
{
  *(void *)this = off_101A46DC8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100BEE8C4(ServiceManager::Service *this)
{
  *(void *)this = off_101A46DC8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100BEE934@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "PhonenumberRegistrationController");
}

unsigned char *sub_100BEE944@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100BEE984(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100BED900(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100BED900(v4, 0);
}

uint64_t sub_100BEEA08()
{
  return 0;
}

uint64_t sub_100BEEA10()
{
  return 1;
}

uint64_t sub_100BEEA18()
{
  return 0;
}

uint64_t sub_100BEEA28(uint64_t result, int a2, ServiceStage *this)
{
  if (a2 == 2)
  {
    uint64_t v3 = *(void *)(result + 8);
    ServiceStage::holdOffStage((uint64_t *)&group[1], this);
    uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
    if (v4)
    {
      if (std::__shared_weak_count::lock(v4)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_100BEEB48()
{
}

uint64_t sub_100BEEB5C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100BEEB6C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BEEBA4(uint64_t a1)
{
  return sub_100BEEBF0(*(void *)(a1 + 24));
}

uint64_t sub_100BEEBAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100BEEBF0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    sub_1000346F8(result + 64, *(void **)(result + 72));
    sub_100BEEC6C(v1 + 40, *(void **)(v1 + 48));
    sub_1000886C0(v1 + 16, *(char **)(v1 + 24));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100BEEC6C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100BEEC6C(a1, *a2);
    sub_100BEEC6C(a1, a2[1]);
    sub_100BEF03C(a2 + 5);
    operator delete(a2);
  }
}

uint64_t *sub_100BEECC8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 120));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100BEED10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100BEED2C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(*(void *)v1 + 56));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100058DB0(&__p, "/cc/events/dump_state");
  uint64_t v3 = operator new(0x20uLL);
  *uint64_t v3 = off_101A46F00;
  v3[1] = v2;
  v3[2] = sub_100BEE3B8;
  v3[3] = 0;
  void v11[3] = v3;
  ctu::RestModule::observeEvent();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100BEEE34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100BEEE90()
{
}

__n128 sub_100BEEEA4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A46F00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100BEEEF8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A46F00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100BEEF30(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100BEEF78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100BEEFB8()
{
}

uint64_t sub_100BEEFC4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100BEF000(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100BEF03C(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    uint64_t v4 = a1 + 5;
    uint64_t v3 = (void **)a1[1];
  }
  else
  {
    uint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 / 0xAA];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 24 * (v5 % 0xAA);
    unint64_t v9 = (unint64_t)v2[(a1[5] + v5) / 0xAA] + 24 * ((a1[5] + v5) % 0xAA);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 23) < 0)
        {
          operator delete(*(void **)v8);
          unint64_t v7 = (unint64_t)*v6;
        }
        v8 += 24;
        if (v8 - v7 == 4080)
        {
          unint64_t v10 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v10;
          unint64_t v8 = v10;
        }
      }
      while (v8 != v9);
      uint64_t v2 = (void **)a1[1];
      uint64_t v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 85;
  }
  else
  {
    if (v12 != 2) {
      goto LABEL_18;
    }
    uint64_t v13 = 170;
  }
  a1[4] = v13;
LABEL_18:
  while (v2 != v3)
  {
    uint64_t v14 = *v2++;
    operator delete(v14);
  }

  return sub_10005EE1C((uint64_t)a1);
}

uint64_t sub_100BEF194(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0xAA) {
    a2 = 1;
  }
  if (v2 < 0x154) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 170;
  }
  return v4 ^ 1u;
}

uint64_t sub_100BEF1F4(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 170 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0xAA) {
    a2 = 1;
  }
  if (v5 < 0x154) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

void sub_100BEF26C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)*a1 + 2));
  uint64_t v4 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *((_DWORD *)v1 + 3);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Handling phone number registration send %x", buf, 8u);
  }
  uint64_t v6 = *(void *)(v2 + 72);
  if (!v6) {
LABEL_44:
  }
    operator delete();
  v28[1] = 0;
  uint64_t v29 = 0;
  v28[0] = 0;
  sub_10119D2C8(v6, *((_DWORD *)v1 + 3), (uint64_t)v28);
  int v7 = (void *)HIBYTE(v29);
  if (v29 < 0) {
    int v7 = v28[1];
  }
  if (!v7)
  {
    unint64_t v10 = *v3;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *((_DWORD *)v1 + 3);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E Token for message id %x not found", buf, 8u);
    }
    goto LABEL_42;
  }
  memset(buf, 0, 24);
  ctu::cf::assign();
  *(_OWORD *)unsigned int v26 = *(_OWORD *)buf;
  uint64_t v27 = *(void *)&buf[16];
  memset(buf, 0, 24);
  ctu::cf::assign();
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  uint64_t v25 = *(void *)&buf[16];
  xpc_object_t v23 = 0;
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v9 = v8;
  if (v8)
  {
    xpc_object_t v23 = v8;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v23 = v9;
    if (!v9)
    {
      xpc_object_t v12 = xpc_null_create();
      xpc_object_t v9 = 0;
      goto LABEL_16;
    }
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v9);
LABEL_17:
    xpc_release(v9);
    xpc_object_t v21 = xpc_BOOL_create(*((unsigned char *)v1 + 16));
    if (!v21) {
      xpc_object_t v21 = xpc_null_create();
    }
    uint64_t v13 = v26;
    if (v27 < 0) {
      uint64_t v13 = (void **)v26[0];
    }
    *(void *)long long buf = &v23;
    *(void *)&uint8_t buf[8] = v13;
    sub_100035E70((uint64_t)buf, &v21, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v21);
    xpc_object_t v21 = 0;
    if (v29 >= 0) {
      uint64_t v14 = v28;
    }
    else {
      uint64_t v14 = (void **)v28[0];
    }
    xpc_object_t v19 = xpc_string_create((const char *)v14);
    if (!v19) {
      xpc_object_t v19 = xpc_null_create();
    }
    char v15 = __p;
    if (v25 < 0) {
      char v15 = (void **)__p[0];
    }
    *(void *)long long buf = &v23;
    *(void *)&uint8_t buf[8] = v15;
    sub_100035E70((uint64_t)buf, &v19, &v20);
    xpc_release(v20);
    xpc_object_t v20 = 0;
    xpc_release(v19);
    xpc_object_t v19 = 0;
    if (*((_DWORD *)v1 + 2) == 1)
    {
      xpc_object_t v16 = v23;
      *(void *)long long buf = v23;
      if (v23)
      {
        xpc_retain(v23);
      }
      else
      {
        xpc_object_t v16 = xpc_null_create();
        *(void *)long long buf = v16;
      }
      xpc_object_t v17 = xpc_null_create();
      xpc_object_t v18 = v17;
      sub_1000452AC(103, (xpc_object_t *)buf, &v18);
      xpc_release(v17);
      xpc_release(v16);
    }
    uint64_t v31 = 0;
    memset(buf, 0, sizeof(buf));
    buf[0] = *((unsigned char *)v1 + 16);
    if (SHIBYTE(v29) < 0)
    {
      sub_10004FC84(&buf[8], v28[0], (unint64_t)v28[1]);
    }
    else
    {
      *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v28;
      *(void *)&uint8_t buf[24] = v29;
    }
    LODWORD(v31) = 0;
    (***(void (****)(void, void, uint8_t *))(v2 + 104))(*(void *)(v2 + 104), *((unsigned int *)v1 + 2), buf);
    if ((char)buf[31] < 0) {
      operator delete(*(void **)&buf[8]);
    }
    xpc_release(v23);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete(v26[0]);
    }
LABEL_42:
    if (SHIBYTE(v29) < 0) {
      operator delete(v28[0]);
    }
    goto LABEL_44;
  }
  xpc_object_t v12 = xpc_null_create();
LABEL_16:
  xpc_object_t v23 = v12;
  goto LABEL_17;
}

void sub_100BEF6B8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a35 < 0) {
    operator delete(__p);
  }
  operator delete();
}

BOOL sub_100BEF7E4(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  sub_100058198((const void **)&theDict, (const void **)v1[1]);
  uint64_t v3 = *(unsigned int *)v1[2];
  ct_green_tea_logger_create_static();
  CTGreenTeaOsLogHandle = getCTGreenTeaOsLogHandle();
  int v5 = CTGreenTeaOsLogHandle;
  if (CTGreenTeaOsLogHandle && os_log_type_enabled(CTGreenTeaOsLogHandle, OS_LOG_TYPE_INFO))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Got PNR response SMS", (uint8_t *)&buf, 2u);
  }
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  int v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BEDC44((uint64_t)&buf, theDict);
    xpc_object_t v8 = (SBYTE7(v80) & 0x80u) == 0 ? &buf : (long long *)buf;
    *(_DWORD *)CFStringRef v86 = 136315138;
    *(void *)&v86[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Incoming response description: (#pnr) %s ", v86, 0xCu);
    if (SBYTE7(v80) < 0) {
      operator delete((void *)buf);
    }
  }
  CFDictionaryGetValue(theDict, kCTPhoneNumberRegistrationVersionKey);
  long long buf = 0uLL;
  *(void *)&long long v80 = 0;
  ctu::cf::assign();
  long long v72 = buf;
  uint64_t v73 = v80;
  if (sub_10119E52C(*(void *)(v2 + 72), (unsigned __int8 *)&v72))
  {
    long long v70 = 0uLL;
    uint64_t v71 = 0;
    CFDictionaryGetValue(theDict, kCTPhoneNumberRegistrationCookieKey);
    long long buf = 0uLL;
    *(void *)&long long v80 = 0;
    ctu::cf::assign();
    long long v70 = buf;
    uint64_t v71 = v80;
    uint64_t v9 = *((void *)&buf + 1);
    if ((SBYTE7(v80) & 0x80u) == 0) {
      uint64_t v9 = BYTE7(v80);
    }
    if (!v9 || (sub_10119D398(*(void *)(v2 + 72), (unsigned __int8 **)&v70, v3) & 1) == 0)
    {
      uint64_t v27 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = &v70;
        if (v71 < 0) {
          uint64_t v28 = (long long *)v70;
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v28;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#E Response cookie %s doesn't match any stored cookies:", (uint8_t *)&buf, 0xCu);
      }
      long long v80 = 0u;
      long long v81 = 0u;
      long long buf = 0u;
      int v58 = v3;
      sub_10119E480(*(void *)(v2 + 72), v3, &buf);
      unint64_t v29 = *((void *)&v81 + 1);
      if (*((void *)&v81 + 1))
      {
        unint64_t v30 = 0;
        do
        {
          uint64_t v31 = *v6;
          if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v32 = *(void *)(*((void *)&buf + 1) + 8 * ((v30 + (unint64_t)v81) / 0xAA))
                + 24 * ((v30 + (unint64_t)v81) % 0xAA);
            if (*(char *)(v32 + 23) < 0) {
              unint64_t v32 = *(void *)v32;
            }
            *(_DWORD *)CFStringRef v86 = 134218242;
            *(void *)&v86[4] = v30;
            *(_WORD *)&v86[12] = 2082;
            *(void *)&v86[14] = v32;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#E Cookie %zu = %{public}s", v86, 0x16u);
            unint64_t v29 = *((void *)&v81 + 1);
          }
          ++v30;
        }
        while (v30 < v29);
      }
      sub_100BEF03C(&buf);
      BOOL v25 = 0;
      char v26 = 2;
      LODWORD(v3) = v58;
      goto LABEL_147;
    }
    v68[0] = 0;
    v68[1] = 0;
    uint64_t v69 = 0;
    unint64_t v10 = (const void *)kCTPhoneNumberRegistrationSignatureKey;
    CFDictionaryGetValue(theDict, kCTPhoneNumberRegistrationSignatureKey);
    long long buf = 0uLL;
    *(void *)&long long v80 = 0;
    ctu::cf::assign();
    *(_OWORD *)uint64_t v68 = buf;
    uint64_t v69 = v80;
    uint64_t v11 = *((void *)&buf + 1);
    if ((SBYTE7(v80) & 0x80u) == 0) {
      uint64_t v11 = BYTE7(v80);
    }
    if (!v11)
    {
      long long v33 = *v6;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#E Signature is empty", (uint8_t *)&buf, 2u);
      }
      BOOL v25 = 0;
      char v26 = 4;
      goto LABEL_145;
    }
    v66[0] = 0;
    v66[1] = 0;
    uint64_t v67 = 0;
    CFDictionaryGetValue(theDict, kCTPhoneNumberRegistrationNumberKey);
    long long buf = 0uLL;
    *(void *)&long long v80 = 0;
    ctu::cf::assign();
    *(_OWORD *)uint64_t v66 = buf;
    uint64_t v67 = v80;
    xpc_object_t v12 = (uint64_t *)*((void *)&buf + 1);
    if ((SBYTE7(v80) & 0x80u) == 0) {
      xpc_object_t v12 = (uint64_t *)BYTE7(v80);
    }
    if (!v12)
    {
      long long v34 = *v6;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#E Incoming response has empty phone number", (uint8_t *)&buf, 2u);
      }
      BOOL v25 = 0;
      char v26 = 5;
      goto LABEL_143;
    }
    uint64_t v64 = 0;
    uint64_t v65 = 0;
    uint64_t v63 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)(v2 + 56));
    uint64_t v14 = ServiceMap;
    if (v15 < 0)
    {
      xpc_object_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v15;
    xpc_object_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)&buf);
    if (v19)
    {
      uint64_t v21 = v19[3];
      xpc_object_t v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
LABEL_52:
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v21 + 8))(&v63, v21, v3);
        if ((v22 & 1) == 0) {
          sub_10004D2C8(v20);
        }
        if (v63 && isReal())
        {
          *(void *)CFStringRef v86 = 0;
          *(void *)&v86[8] = 0;
          sub_100659D2C(*(Registry **)(v2 + 56), v86);
          uint64_t v35 = *(void *)v86;
          if (*(void *)v86)
          {
            CSIPhoneNumber::CSIPhoneNumber();
            (*(void (**)(uint64_t, uint64_t *, long long *))(*(void *)v35 + 312))(v35, &v63, &buf);
            sub_100087E24((uint64_t)&buf);
          }
          if (*(void *)&v86[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v86[8]);
          }
          uint64_t v85 = 0;
          long long v83 = 0u;
          long long v84 = 0u;
          long long v81 = 0u;
          long long __src = 0u;
          long long buf = 0u;
          long long v80 = 0u;
          sub_1003D59E4(*(Registry **)(v2 + 56), v86);
          (*(void (**)(long long *__return_ptr))(**(void **)v86 + 176))(&buf);
          if (*(void *)&v86[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v86[8]);
          }
          uint64_t v36 = BYTE7(v83);
          if (SBYTE7(v83) < 0) {
            uint64_t v36 = *((void *)&__src + 1);
          }
          if (v36)
          {
            if (SBYTE7(v83) < 0)
            {
              sub_10004FC84(__dst, (void *)__src, *((unint64_t *)&__src + 1));
            }
            else
            {
              *(_OWORD *)long long __dst = __src;
              uint64_t v61 = v83;
            }
            if (SHIBYTE(v61) < 0)
            {
              sub_10004FC84(&__p, __dst[0], (unint64_t)__dst[1]);
            }
            else
            {
              long long __p = *(_OWORD *)__dst;
              uint64_t v76 = v61;
            }
            CFMutableDictionaryRef v74 = 0;
            if (SHIBYTE(v76) < 0)
            {
              sub_10004FC84(v86, (void *)__p, *((unint64_t *)&__p + 1));
            }
            else
            {
              *(_OWORD *)CFStringRef v86 = __p;
              *(void *)&v86[16] = v76;
            }
            CFPropertyListRef value = 0;
            if (ctu::cf::convert_copy())
            {
              CFMutableDictionaryRef v37 = v74;
              CFMutableDictionaryRef v74 = (CFMutableDictionaryRef)value;
              *(void *)unsigned int v78 = v37;
              sub_1000558F4((const void **)v78);
            }
            if ((v86[23] & 0x80000000) != 0) {
              operator delete(*(void **)v86);
            }
            xpc_object_t object = v74;
            CFMutableDictionaryRef v74 = 0;
            sub_1000558F4((const void **)&v74);
            if (SHIBYTE(v76) < 0) {
              operator delete((void *)__p);
            }
            *(void *)CFStringRef v86 = v65;
            uint64_t v65 = object;
            xpc_object_t object = 0;
            sub_1000558F4((const void **)v86);
            sub_1000558F4((const void **)&object);
            if (SHIBYTE(v61) < 0) {
              operator delete(__dst[0]);
            }
          }
          sub_1001A7138((uint64_t)&buf);
        }
        long long __p = 0uLL;
        ctu::TextConverter::TextConverter((ctu::TextConverter *)&__p);
        if (v69 >= 0) {
          uint64_t v38 = v68;
        }
        else {
          uint64_t v38 = (void **)v68[0];
        }
        if (v69 >= 0) {
          unint64_t v39 = HIBYTE(v69);
        }
        else {
          unint64_t v39 = (unint64_t)v68[1];
        }
        ctu::TextConverter::setSource((ctu::TextConverter *)&__p, (const char *)v38, v39);
        ctu::TextConverter::pushConversion();
        long long buf = 0uLL;
        *(void *)&long long v80 = 0;
        ctu::TextConverter::readChars((uint64_t *)&buf, (ctu::TextConverter *)&__p, 0x7FFFFFFFuLL);
        CFPropertyListRef value = 0;
        if ((SBYTE7(v80) & 0x80u) == 0) {
          p_long long buf = (const UInt8 *)&buf;
        }
        else {
          p_long long buf = (const UInt8 *)buf;
        }
        if ((SBYTE7(v80) & 0x80u) == 0) {
          CFIndex v41 = BYTE7(v80);
        }
        else {
          CFIndex v41 = *((void *)&buf + 1);
        }
        CFPropertyListRef value = CFDataCreate(kCFAllocatorDefault, p_buf, v41);
        if (value) {
          uint64_t v42 = sub_10008324C;
        }
        else {
          uint64_t v42 = 0;
        }
        if (v42)
        {
          CFMutableDictionaryRef v74 = 0;
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
          CFMutableDictionaryRef v74 = MutableCopy;
          if (MutableCopy) {
            uint64_t v44 = sub_1000C06D0;
          }
          else {
            uint64_t v44 = 0;
          }
          BOOL v25 = v44 != 0;
          if (v44)
          {
            CFDictionarySetValue(MutableCopy, v10, value);
            CFDictionarySetValue(v74, kCTPhoneNumberRegistrationResponseStatusKey, kCTPhoneNumberRegistrationResponseStatusSuccess);
            if (v65) {
              xpc_object_t v45 = sub_1000810B8;
            }
            else {
              xpc_object_t v45 = 0;
            }
            if (v45) {
              CFDictionarySetValue(v74, kCTPhoneNumberRegistrationResponseLabelID, v65);
            }
            uint64_t v46 = *v6;
            if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
            {
              sub_100BEDC44((uint64_t)v86, v74);
              xpc_object_t v48 = v86[23] >= 0 ? v86 : *(unsigned char **)v86;
              *(_DWORD *)unsigned int v78 = 136315138;
              *(void *)&v78[4] = v48;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Modified response description: %s", v78, 0xCu);
              if ((v86[23] & 0x80000000) != 0) {
                operator delete(*(void **)v86);
              }
            }
            xpc_object_t object = 0;
            ctu::cf_to_xpc((uint64_t *)v86, v74, v47);
            xpc_object_t v49 = *(void **)v86;
            xpc_object_t object = *(xpc_object_t *)v86;
            if (*(void *)v86 && xpc_get_type(*(xpc_object_t *)v86) == (xpc_type_t)&_xpc_type_dictionary) {
              xpc_retain(v49);
            }
            else {
              xpc_object_t object = xpc_null_create();
            }
            xpc_release(*(xpc_object_t *)v86);
            if (v3 == 1)
            {
              uint64_t v52 = *v6;
              if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
              {
                sub_100BEDC44((uint64_t)v86, v74);
                uint64_t v53 = v86[23] >= 0 ? v86 : *(unsigned char **)v86;
                *(_DWORD *)unsigned int v78 = 136315138;
                *(void *)&v78[4] = v53;
                _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I Modified response description: %s", v78, 0xCu);
                if ((v86[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v86);
                }
              }
              xpc_object_t v54 = object;
              *(void *)CFStringRef v86 = object;
              if (object)
              {
                xpc_retain(object);
              }
              else
              {
                xpc_object_t v54 = xpc_null_create();
                *(void *)CFStringRef v86 = v54;
              }
              xpc_object_t v55 = xpc_null_create();
              *(void *)unsigned int v78 = v55;
              sub_1000452AC(96, (xpc_object_t *)v86, (xpc_object_t *)v78);
              xpc_release(v55);
              xpc_release(v54);
            }
            uint64_t v56 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)CFStringRef v86 = 0;
              _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Issuing PNR Response received", v86, 2u);
            }
            (*(void (**)(void, uint64_t, xpc_object_t *))(**(void **)(v2 + 104) + 8))(*(void *)(v2 + 104), v3, &object);
            xpc_release(object);
          }
          else
          {
            uint64_t v51 = *v6;
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)CFStringRef v86 = 0;
              _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#E Failed to convert response from immutable -> mutable", v86, 2u);
            }
          }
          sub_10005717C((const void **)&v74);
        }
        else
        {
          uint64_t v50 = *v6;
          BOOL v25 = 0;
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)CFStringRef v86 = 0;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#E Failed to convert signature byte blob to CFData", v86, 2u);
            BOOL v25 = 0;
          }
        }
        sub_100030068((const void **)&value);
        if (SBYTE7(v80) < 0) {
          operator delete((void *)buf);
        }
        ctu::TextConverter::~TextConverter((ctu::TextConverter *)&__p);
        if (v64) {
          sub_10004D2C8(v64);
        }
        sub_1000558F4((const void **)&v65);
        char v26 = 0;
LABEL_143:
        if (SHIBYTE(v67) < 0) {
          operator delete(v66[0]);
        }
LABEL_145:
        if (SHIBYTE(v69) < 0) {
          operator delete(v68[0]);
        }
LABEL_147:
        if (SHIBYTE(v71) < 0) {
          operator delete((void *)v70);
        }
        goto LABEL_149;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    xpc_object_t v20 = 0;
    char v22 = 1;
    goto LABEL_52;
  }
  xpc_object_t v23 = *v6;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v24 = &v72;
    if (v73 < 0) {
      BOOL v24 = (long long *)v72;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#E Response version %s doesn't match", (uint8_t *)&buf, 0xCu);
  }
  BOOL v25 = 0;
  char v26 = 3;
LABEL_149:
  if (SHIBYTE(v73) < 0) {
    operator delete((void *)v72);
  }
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000;
  *(void *)&long long v80 = sub_1008C3858;
  *((void *)&v80 + 1) = &unk_101A16688;
  LODWORD(v81) = v3;
  BYTE4(v81) = v26;
  sub_1008C3678((wis::MetricFactory *)0x800E1);
  sub_100057D78((const void **)&theDict);
  return v25;
}

void sub_100BF04FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,xpc_object_t object,uint64_t a23,uint64_t a24,const void *a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,const void *a53,void *__p,uint64_t a55,int a56,__int16 a57,char a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,void *a63)
{
  if (a59 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  sub_1001A7138((uint64_t)&a63);
  if (a24) {
    sub_10004D2C8((std::__shared_weak_count *)a24);
  }
  sub_1000558F4(&a25);
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  sub_100057D78(&a14);
  _Unwind_Resume(a1);
}

BOOL sub_100BF0744(uint64_t a1)
{
  return sub_100BEDE00(**(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8), *(uint64_t **)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_100BF0754(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = *(unsigned int *)v1[1];
  uint64_t v4 = *(void **)v1[2];
  xpc_object_t v102 = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    xpc_object_t v102 = xpc_null_create();
  }
  int v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  uint64_t v6 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Issuing phone number registration request", buf, 2u);
  }
  v108[0] = 0;
  v108[1] = 0;
  uint64_t v109 = 0;
  *(void *)&long long v132 = &v102;
  *((void *)&v132 + 1) = "kSmsToken";
  sub_100048BAC((uint64_t)&v132, &object);
  memset(buf, 0, 24);
  xpc::dyn_cast_or_default();
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release((xpc_object_t)object);
  int v7 = (void *)HIBYTE(v109);
  if (v109 < 0) {
    int v7 = v108[1];
  }
  if (v7)
  {
    xpc_object_t xarray = 0;
    *(void *)long long buf = &v102;
    *(void *)&uint8_t buf[8] = "kPhoneNumberRegistrationMechanisms";
    sub_10005107C((uint64_t)buf, &xarray);
    xpc_object_t v8 = *(Registry **)(v2 + 56);
    uint64_t v100 = (uint64_t *)(v2 + 56);
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)(v2 + 56), v8);
    unint64_t v10 = ServiceMap;
    uint64_t v12 = v11;
    if (v11 < 0)
    {
      uint64_t v13 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long v132 = v12;
    xpc_object_t v16 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v132);
    if (v16)
    {
      uint64_t v18 = v16[3];
      uint64_t v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v17 = 0;
    char v19 = 1;
LABEL_21:
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 8))(buf, v18, v3);
    if ((v19 & 1) == 0) {
      sub_10004D2C8(v17);
    }
    if (*(void *)buf) {
      int v21 = (*(uint64_t (**)(void, uint64_t))(**(void **)buf + 72))(*(void *)buf, 1);
    }
    else {
      int v21 = 0;
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    char v22 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v23 = "false";
      if (v21) {
        xpc_object_t v23 = "true";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Can use entitlement for phone number registration: %s", buf, 0xCu);
    }
    *(void *)long long buf = &v102;
    *(void *)&uint8_t buf[8] = "kSmsPhoneNumberRegistrationAttemptCount";
    sub_100048BAC((uint64_t)buf, &v132);
    uint64_t v101 = v2;
    int v25 = xpc::dyn_cast_or_default((xpc *)&v132, 0, v24);
    xpc_release((xpc_object_t)v132);
    if (v25 < 3) {
      int v26 = v21;
    }
    else {
      int v26 = 0;
    }
    BOOL v27 = v25 < 5;
    v105[0] = 0;
    v105[1] = 0;
    uint64_t v106 = 0;
    __p[0] = 0;
    __p[1] = 0;
    long long v104 = 0;
    if (xpc_get_type(xarray) == (xpc_type_t)&_xpc_type_array)
    {
      if (v26)
      {
        if (xpc_get_type(xarray) == (xpc_type_t)&_xpc_type_array && (size_t count = xpc_array_get_count(xarray)) != 0)
        {
          uint64_t v29 = 0;
          LOBYTE(v26) = 1;
          do
          {
            *(void *)&long long v132 = 0;
            *(void *)long long buf = &xarray;
            *(void *)&uint8_t buf[8] = v29;
            sub_10003FBDC((uint64_t)buf, &v132);
            if (xpc_get_type((xpc_object_t)v132) == (xpc_type_t)&_xpc_type_dictionary)
            {
              *(void *)long long buf = &v132;
              *(void *)&uint8_t buf[8] = "kPhoneNumberRegistrationMechanismType";
              sub_100048BAC((uint64_t)buf, &object);
              char v32 = xpc::dyn_cast_or_default((xpc *)&object, 0, v31);
              xpc_release((xpc_object_t)object);
              if (v32 == 2)
              {
                long long v33 = *(NSObject **)(v101 + 40);
                if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Can use sms less PNR mechanism", buf, 2u);
                }
                int v30 = 1;
              }
              else
              {
                int v30 = 0;
              }
            }
            else
            {
              int v30 = 4;
            }
            xpc_release((xpc_object_t)v132);
            if ((v30 | 4) != 4) {
              break;
            }
            LOBYTE(v26) = ++v29 < count;
          }
          while (count != v29);
        }
        else
        {
          LOBYTE(v26) = 0;
        }
      }
      else
      {
        BOOL v27 = 0;
        if (v25 > 4) {
          goto LABEL_54;
        }
      }
      if (xpc_get_type(xarray) == (xpc_type_t)&_xpc_type_array && (size_t v54 = xpc_array_get_count(xarray)) != 0)
      {
        uint64_t v55 = 0;
        BOOL v27 = 1;
        do
        {
          __dst[0] = 0;
          *(void *)long long buf = &xarray;
          *(void *)&uint8_t buf[8] = v55;
          sub_10003FBDC((uint64_t)buf, __dst);
          if (xpc_get_type(__dst[0]) == (xpc_type_t)&_xpc_type_dictionary)
          {
            *(void *)long long buf = __dst;
            *(void *)&uint8_t buf[8] = "kPhoneNumberRegistrationMechanismType";
            sub_100048BAC((uint64_t)buf, &v132);
            char v58 = xpc::dyn_cast_or_default((xpc *)&v132, 0, v57);
            xpc_release((xpc_object_t)v132);
            if (v58 == 1)
            {
              *(void *)&long long object = __dst;
              *((void *)&object + 1) = "kPhoneNumberRegistrationDestinationAddress";
              sub_100048BAC((uint64_t)&object, v116);
              memset(buf, 0, 24);
              xpc::dyn_cast_or_default();
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
              if (SHIBYTE(v104) < 0) {
                operator delete(__p[0]);
              }
              *(_OWORD *)long long __p = v132;
              long long v104 = (void *)v133;
              BYTE7(v133) = 0;
              LOBYTE(v132) = 0;
              xpc_release(v116[0]);
              *(void *)&long long object = __dst;
              *((void *)&object + 1) = "kPhoneNumberRegistrationServiceCenterAddress";
              sub_100048BAC((uint64_t)&object, v116);
              memset(buf, 0, 24);
              xpc::dyn_cast_or_default();
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
              if (SHIBYTE(v106) < 0) {
                operator delete(v105[0]);
              }
              *(_OWORD *)long long v105 = v132;
              uint64_t v106 = (void *)v133;
              BYTE7(v133) = 0;
              LOBYTE(v132) = 0;
              xpc_release(v116[0]);
              uint64_t v59 = *(NSObject **)(v101 + 40);
              if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
              {
                xpc_object_t v60 = __p;
                if (SHIBYTE(v104) < 0) {
                  xpc_object_t v60 = (void **)__p[0];
                }
                uint64_t v61 = v105;
                if (SHIBYTE(v106) < 0) {
                  uint64_t v61 = (void **)v105[0];
                }
                *(_DWORD *)long long buf = 136315394;
                *(void *)&uint8_t buf[4] = v60;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v61;
                _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I Can use sms PNR mechanism. Destination address: %s service center address: %s", buf, 0x16u);
              }
              int v56 = 1;
            }
            else
            {
              int v56 = 0;
            }
          }
          else
          {
            int v56 = 4;
          }
          xpc_release(__dst[0]);
          if ((v56 | 4) != 4) {
            break;
          }
          BOOL v27 = ++v55 < v54;
        }
        while (v54 != v55);
      }
      else
      {
        BOOL v27 = 0;
      }
    }
LABEL_54:
    long long v34 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = v25;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = 3;
      *(_WORD *)&buf[14] = 1024;
      *(_DWORD *)&uint8_t buf[16] = 5;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Attempt: %d, max http attempts allowed: %d, max attempts allowed: %d", buf, 0x14u);
    }
    sub_1008C3AD8(v3, v25);
    if (v26)
    {
      uint64_t v35 = *v5;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Issuing phone number registration request over HTTP", buf, 2u);
      }
      long long v132 = 0uLL;
      *(void *)&long long v133 = 0;
      uint64_t v36 = (std::mutex *)Registry::getServiceMap(v100, (Registry *)*v100);
      CFMutableDictionaryRef v37 = v36;
      if (v11 < 0)
      {
        uint64_t v38 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v39 = 5381;
        do
        {
          uint64_t v11 = v39;
          unsigned int v40 = *v38++;
          uint64_t v39 = (33 * v39) ^ v40;
        }
        while (v40);
      }
      std::mutex::lock(v36);
      *(void *)&long long object = v11;
      CFIndex v41 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)&object);
      if (v41)
      {
        uint64_t v43 = v41[3];
        uint64_t v42 = (std::__shared_weak_count *)v41[4];
        if (v42)
        {
          atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v37);
          atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v42);
          char v44 = 0;
          uint64_t v45 = v101;
          goto LABEL_80;
        }
      }
      else
      {
        uint64_t v43 = 0;
      }
      uint64_t v45 = v101;
      std::mutex::unlock(v37);
      uint64_t v42 = 0;
      char v44 = 1;
LABEL_80:
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v43 + 8))(buf, v43, v3);
      (*(void (**)(long long *__return_ptr))(**(void **)buf + 392))(&v132);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if ((v44 & 1) == 0) {
        sub_10004D2C8(v42);
      }
      v118[0] = 0;
      xpc_object_t v51 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v52 = v51;
      if (v51)
      {
        v118[0] = v51;
      }
      else
      {
        xpc_object_t v52 = xpc_null_create();
        v118[0] = v52;
        if (!v52)
        {
          xpc_object_t v53 = xpc_null_create();
          xpc_object_t v52 = 0;
          goto LABEL_128;
        }
      }
      if (xpc_get_type(v52) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v52);
LABEL_129:
        xpc_release(v52);
        long long object = 0uLL;
        CFMutableDictionaryRef v120 = 0;
        memset(buf, 0, 24);
        ctu::cf::assign();
        long long object = *(_OWORD *)buf;
        CFMutableDictionaryRef v120 = *(void **)&buf[16];
        memset(__dst, 0, 24);
        memset(buf, 0, 24);
        ctu::cf::assign();
        *(_OWORD *)long long __dst = *(_OWORD *)buf;
        __dst[2] = *(xpc_object_t *)&buf[16];
        memset(v116, 0, 24);
        memset(buf, 0, 24);
        ctu::cf::assign();
        *(_OWORD *)uint64_t v116 = *(_OWORD *)buf;
        v116[2] = *(xpc_object_t *)&buf[16];
        xpc_object_t v115 = xpc_BOOL_create(1);
        if (!v115) {
          xpc_object_t v115 = xpc_null_create();
        }
        p_long long object = &object;
        if (SHIBYTE(v120) < 0) {
          p_long long object = (long long *)object;
        }
        *(void *)long long buf = v118;
        *(void *)&uint8_t buf[8] = p_object;
        sub_100035E70((uint64_t)buf, &v115, &v121);
        xpc_release(v121);
        xpc_object_t v121 = 0;
        xpc_release(v115);
        xpc_object_t v115 = 0;
        if ((SBYTE7(v133) & 0x80u) == 0) {
          os_signpost_id_t v75 = (const char *)&v132;
        }
        else {
          os_signpost_id_t v75 = (const char *)v132;
        }
        xpc_object_t v113 = xpc_string_create(v75);
        if (!v113) {
          xpc_object_t v113 = xpc_null_create();
        }
        uint64_t v76 = __dst;
        if (SHIBYTE(__dst[2]) < 0) {
          uint64_t v76 = (xpc_object_t *)__dst[0];
        }
        *(void *)long long buf = v118;
        *(void *)&uint8_t buf[8] = v76;
        sub_100035E70((uint64_t)buf, &v113, &v114);
        xpc_release(v114);
        xpc_object_t v114 = 0;
        xpc_release(v113);
        xpc_object_t v113 = 0;
        xpc_object_t v111 = xpc_int64_create(360);
        if (!v111) {
          xpc_object_t v111 = xpc_null_create();
        }
        uint64_t v77 = v116;
        if (SHIBYTE(v116[2]) < 0) {
          uint64_t v77 = (xpc_object_t *)v116[0];
        }
        *(void *)long long buf = v118;
        *(void *)&uint8_t buf[8] = v77;
        sub_100035E70((uint64_t)buf, &v111, &v112);
        xpc_release(v112);
        xpc_object_t v112 = 0;
        xpc_release(v111);
        xpc_object_t v111 = 0;
        if (v3 == 1)
        {
          xpc_object_t v78 = v118[0];
          *(xpc_object_t *)long long buf = v118[0];
          if (v118[0])
          {
            xpc_retain(v118[0]);
          }
          else
          {
            xpc_object_t v78 = xpc_null_create();
            *(void *)long long buf = v78;
          }
          xpc_object_t v79 = xpc_null_create();
          xpc_object_t v110 = v79;
          sub_1000452AC(103, (xpc_object_t *)buf, &v110);
          xpc_release(v79);
          xpc_release(v78);
        }
        v123[0] = 0;
        memset(buf, 0, sizeof(buf));
        buf[0] = 1;
        if (SHIBYTE(v109) < 0)
        {
          sub_10004FC84(&buf[8], v108[0], (unint64_t)v108[1]);
        }
        else
        {
          *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v108;
          *(void *)&uint8_t buf[24] = v109;
        }
        LODWORD(v123[0]) = 0;
        (***(void (****)(void, void, uint8_t *))(v45 + 104))(*(void *)(v45 + 104), v3, buf);
        if ((char)buf[31] < 0) {
          operator delete(*(void **)&buf[8]);
        }
        if (SHIBYTE(v116[2]) < 0) {
          operator delete(v116[0]);
        }
        if (SHIBYTE(__dst[2]) < 0) {
          operator delete(__dst[0]);
        }
        if (SHIBYTE(v120) < 0) {
          operator delete((void *)object);
        }
        xpc_release(v118[0]);
        if (SBYTE7(v133) < 0) {
          operator delete((void *)v132);
        }
        uint64_t v20 = 257;
        goto LABEL_215;
      }
      xpc_object_t v53 = xpc_null_create();
LABEL_128:
      v118[0] = v53;
      goto LABEL_129;
    }
    unsigned int v46 = sub_1000BE198(@"kCTAutomaticSMS");
    xpc_object_t v47 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v48 = "false";
      if (v27) {
        xpc_object_t v49 = "true";
      }
      else {
        xpc_object_t v49 = "false";
      }
      if (v46) {
        xpc_object_t v48 = "true";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v49;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v48;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Sms ok :- %s Automatic sms disallowed :- %s", buf, 0x16u);
    }
    if (v46 & 1 | !v27)
    {
      uint64_t v20 = 0;
      goto LABEL_215;
    }
    uint64_t v50 = *v5;
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Issuing phone number registration request over SMS", buf, 2u);
    }
    if (SHIBYTE(v106) < 0)
    {
      sub_10004FC84(__dst, v105[0], (unint64_t)v105[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v105;
      __dst[2] = v106;
    }
    if (SHIBYTE(v104) < 0)
    {
      sub_10004FC84(v116, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)uint64_t v116 = *(_OWORD *)__p;
      v116[2] = v104;
    }
    uint64_t v62 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v101 + 48) + 16))(*(void *)(v101 + 48), v3);
    xpc_object_t v63 = (xpc_object_t)HIBYTE(__dst[2]);
    if (SHIBYTE(__dst[2]) < 0) {
      xpc_object_t v63 = __dst[1];
    }
    if (v63)
    {
LABEL_173:
      unint64_t v84 = HIBYTE(v116[2]);
      char v85 = HIBYTE(v116[2]);
      xpc_object_t v86 = v116[1];
      if (SHIBYTE(v116[2]) >= 0) {
        xpc_object_t v87 = (xpc_object_t)HIBYTE(v116[2]);
      }
      else {
        xpc_object_t v87 = v116[1];
      }
      if (!v87)
      {
        *(void *)&long long object = 0;
        *(void *)&long long object = sub_100794BC4((NSObject **)(v101 + 40), (Registry **)v100, v3);
        memset(buf, 0, 24);
        ctu::cf::assign();
        CFStringRef v88 = *(void **)buf;
        *(void *)&long long v132 = *(void *)&buf[8];
        *(void *)((char *)&v132 + 7) = *(void *)&buf[15];
        int v89 = (char)buf[23];
        if (SHIBYTE(v116[2]) < 0) {
          operator delete(v116[0]);
        }
        v116[0] = v88;
        v116[1] = (xpc_object_t)v132;
        *(xpc_object_t *)((char *)&v116[1] + 7) = *(xpc_object_t *)((char *)&v132 + 7);
        HIBYTE(v116[2]) = v89;
        CFTypeRef v90 = *v62;
        if (os_log_type_enabled(*v62, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v91 = v116;
          if (v89 < 0) {
            CFStringRef v91 = (xpc_object_t *)v88;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v91;
          _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#I Found destination address %s in carrier bundle", buf, 0xCu);
        }
        sub_1000558F4((const void **)&object);
        unint64_t v84 = HIBYTE(v116[2]);
        xpc_object_t v86 = v116[1];
        char v85 = HIBYTE(v116[2]);
      }
      if (v85 < 0) {
        unint64_t v84 = (unint64_t)v86;
      }
      if (v84)
      {
        long long v133 = 0u;
        long long v134 = 0u;
        long long v132 = 0u;
        sub_10119E480(*(void *)(v101 + 72), v3, &v132);
        if (*((void *)&v134 + 1))
        {
          sub_10119D1A8(*(void *)(v101 + 72), v3);
          unsigned int v92 = sub_10119D1F4(*(void *)(v101 + 72), v3);
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 0x40000000;
          *(void *)&uint8_t buf[16] = sub_1008C3A90;
          *(void *)&uint8_t buf[24] = &unk_101A166A8;
          v123[0] = (void *)__PAIR64__(v3, v92);
          sub_1008C38B0((wis::MetricFactory *)0x800EA);
        }
        CFStringRef v93 = *v62;
        if (os_log_type_enabled(*v62, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#I PNR request cookies:", buf, 2u);
        }
        unint64_t v94 = *((void *)&v134 + 1);
        if (*((void *)&v134 + 1))
        {
          unint64_t v95 = 0;
          do
          {
            CFStringRef v96 = *v62;
            if (os_log_type_enabled(*v62, OS_LOG_TYPE_DEFAULT))
            {
              unint64_t v97 = *(void *)(*((void *)&v132 + 1) + 8 * ((v95 + (unint64_t)v134) / 0xAA))
                  + 24 * ((v95 + (unint64_t)v134) % 0xAA);
              if (*(char *)(v97 + 23) < 0) {
                unint64_t v97 = *(void *)v97;
              }
              *(_DWORD *)long long buf = 134218242;
              *(void *)&uint8_t buf[4] = v95;
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v97;
              _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "#I Cookie %zu = %{public}s", buf, 0x16u);
              unint64_t v94 = *((void *)&v134 + 1);
            }
            ++v95;
          }
          while (v95 < v94);
        }
        long long object = 0uLL;
        CFMutableDictionaryRef v120 = 0;
        sub_10119D940(*(void *)(v101 + 72), (Registry **)v100, (uint64_t)v108, v3, (uint64_t)&object);
        v118[0] = 0;
        v118[1] = 0;
        if (SHIBYTE(v116[2]) < 0)
        {
          sub_10004FC84(buf, v116[0], (unint64_t)v116[1]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)v116;
          *(xpc_object_t *)&uint8_t buf[16] = v116[2];
        }
        *(_DWORD *)&uint8_t buf[24] = v3;
        if (SHIBYTE(v120) < 0)
        {
          sub_10004FC84(v123, (void *)object, *((unint64_t *)&object + 1));
        }
        else
        {
          *(_OWORD *)CFTypeRef v123 = object;
          v123[2] = v120;
        }
        int v124 = 3;
        if (SHIBYTE(__dst[2]) < 0)
        {
          sub_10004FC84(v125, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)CFTypeRef v125 = *(_OWORD *)__dst;
          v125[2] = __dst[2];
        }
        v125[3] = 0;
        char v126 = 0;
        char v127 = 0;
        char v128 = 0;
        int v129 = 9;
        char v130 = 0;
        char v131 = 0;
        sub_100643AD0();
      }
      uint64_t v98 = *v62;
      if (os_log_type_enabled(*v62, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_ERROR, "Destination address for PNR SMS is empty", buf, 2u);
      }
      uint64_t v20 = 1;
      if (SHIBYTE(v116[2]) < 0) {
        operator delete(v116[0]);
      }
      if (SHIBYTE(__dst[2]) < 0) {
        operator delete(__dst[0]);
      }
LABEL_215:
      if (SHIBYTE(v104) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v106) < 0) {
        operator delete(v105[0]);
      }
      xpc_release(xarray);
      if (v109 < 0) {
        goto LABEL_220;
      }
      goto LABEL_221;
    }
    uint64_t v64 = (std::mutex *)Registry::getServiceMap(v100, (Registry *)*v100);
    uint64_t v65 = v64;
    if (v66 < 0)
    {
      uint64_t v67 = (unsigned __int8 *)(v66 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v68 = 5381;
      do
      {
        uint64_t v66 = v68;
        unsigned int v69 = *v67++;
        uint64_t v68 = (33 * v68) ^ v69;
      }
      while (v69);
    }
    std::mutex::lock(v64);
    *(void *)long long buf = v66;
    long long v70 = sub_10004D37C(&v65[1].__m_.__sig, (unint64_t *)buf);
    if (v70)
    {
      uint64_t v72 = v70[3];
      uint64_t v71 = (std::__shared_weak_count *)v70[4];
      if (v71)
      {
        atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v65);
        atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v71);
        char v73 = 0;
LABEL_165:
        (*(void (**)(long long *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v72 + 96))(&object, v72, v3, 1, @"PhoneNumberRegistrationServiceCenter", 0, 0);
        memset(buf, 0, 24);
        ctu::cf::assign();
        long long v80 = *(void **)buf;
        *(void *)&long long v132 = *(void *)&buf[8];
        *(void *)((char *)&v132 + 7) = *(void *)&buf[15];
        uint8_t v81 = buf[23];
        if (SHIBYTE(__dst[2]) < 0) {
          operator delete(__dst[0]);
        }
        __dst[0] = v80;
        __dst[1] = (xpc_object_t)v132;
        *(xpc_object_t *)((char *)&__dst[1] + 7) = *(xpc_object_t *)((char *)&v132 + 7);
        HIBYTE(__dst[2]) = v81;
        sub_1000577C4((const void **)&object);
        if ((v73 & 1) == 0) {
          sub_10004D2C8(v71);
        }
        CFAllocatorRef v82 = *v62;
        if (os_log_type_enabled(*v62, OS_LOG_TYPE_DEFAULT))
        {
          long long v83 = __dst;
          if (SHIBYTE(__dst[2]) < 0) {
            long long v83 = (xpc_object_t *)__dst[0];
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v83;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I Found service center address %s in carrier bundle", buf, 0xCu);
        }
        goto LABEL_173;
      }
    }
    else
    {
      uint64_t v72 = 0;
    }
    std::mutex::unlock(v65);
    uint64_t v71 = 0;
    char v73 = 1;
    goto LABEL_165;
  }
  uint64_t v20 = 0;
  if (v109 < 0) {
LABEL_220:
  }
    operator delete(v108[0]);
LABEL_221:
  xpc_release(v102);
  return v20;
}

void sub_100BF1CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,xpc_object_t object,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,xpc_object_t a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,xpc_object_t a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,xpc_object_t a56,uint64_t a57,xpc_object_t a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a74 < 0) {
    operator delete(__p);
  }
  if (a72 < 0) {
    operator delete(a67);
  }
  if (a63 < 0) {
    operator delete(a58);
  }
  sub_100BEF03C((void *)(v74 - 160));
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  xpc_release(object);
  if (a35 < 0) {
    operator delete(a30);
  }
  xpc_release(a14);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BF20E0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  BOOL v3 = sub_100BEDE00(*(void *)v1, *(unsigned int *)(*(void *)(v1 + 8) + 52), *(uint64_t **)(v1 + 8));
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(*(void *)(v1 + 8) + 52));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(v1 + 8);
    uint64_t v6 = *(unsigned __int8 *)(v5 + 47);
    BOOL v7 = (v6 & 0x80u) != 0;
    xpc_object_t v8 = (const char *)(v5 + 24);
    if ((v6 & 0x80u) != 0) {
      uint64_t v6 = *(void *)(v5 + 32);
    }
    if (v7) {
      xpc_object_t v8 = *(const char **)(v5 + 24);
    }
    if (v6) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = "<invalid>";
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v9;
    __int16 v15 = 2080;
    uint64_t v16 = PersonalityInfo::logPrefix((PersonalityInfo *)v5);
    __int16 v17 = 2080;
    uint64_t v18 = asStringBool(v3);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I updatePNRSupport for %s [%s] to %s", buf, 0x20u);
  }
  uint64_t v10 = *(void *)(v2 + 104);
  PersonalityInfo::uuid((uint64_t *)buf, *(PersonalityInfo **)(v1 + 8));
  (*(void (**)(uint64_t, void, BOOL))(*(void *)v10 + 24))(v10, *(void *)buf, v3);
  sub_10012577C((const void **)buf);
  sub_100046B58(&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100BF2284(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11)
{
}

void MMSFactory::create(void *a1@<X8>)
{
  *a1 = 0;
  operator new();
}

void sub_100BF2328(char *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x110uLL);
  v4[1] = 0;
  _DWORD v4[2] = 0;
  void *v4 = off_101A470C8;
  MMSCServer::MMSCServer((MMSCServer *)(v4 + 3), a1);
  *a2 = v5;
  a2[1] = v4;
}

void sub_100BF238C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_100BF23A4(uint64_t a1, dispatch_object_t *a2, uint64_t a3, uint64_t a4)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  uint64_t v5 = *(void *)(a4 + 8);
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  MMSDataContextController::create();
}

void sub_100BF2450(_Unwind_Exception *exception_object)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

double MMSFactory::createMMSSendOperation@<D0>(int a1@<W1>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, void *a4@<X4>, _OWORD *a5@<X8>)
{
  int v8 = a1;
  sub_100BF2A94(&v8, a2, a3, a4, v7);
  double result = v7[0];
  *a5 = *(_OWORD *)v7;
  return result;
}

void sub_100BF24B8(uint64_t a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, uint64_t *a4@<X4>, uint64_t a5@<X5>, void *a6@<X8>)
{
  uint64_t v12 = *a2;
  uint64_t v11 = (std::__shared_weak_count *)a2[1];
  uint64_t v13 = (std::__shared_weak_count *)operator new(0x148uLL);
  uint64_t v14 = v13;
  v13->__shared_owners_ = 0;
  v13->__shared_weak_owners_ = 0;
  v13->__vftable = (std::__shared_weak_count_vtbl *)off_101A47168;
  uint64_t v23 = v12;
  int v24 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __int16 v15 = &v13[1].__vftable;
  uint64_t v16 = *a3;
  __int16 v17 = (std::__shared_weak_count *)a3[1];
  v22[0] = v16;
  v22[1] = (uint64_t)v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = *a4;
  char v19 = (std::__shared_weak_count *)a4[1];
  v21[0] = v18;
  v21[1] = (uint64_t)v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10050E5F8((uint64_t)&v13[1], a1, (uint64_t)&v23, v22, v21, a5);
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (v24) {
    sub_10004D2C8(v24);
  }
  uint64_t v20 = (std::__shared_weak_count *)v14[2].__vftable;
  if (!v20)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v14[1].__shared_weak_owners_ = (uint64_t)v15;
    v14[2].__vftable = (std::__shared_weak_count_vtbl *)v14;
    goto LABEL_17;
  }
  if (v20->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v14[1].__shared_weak_owners_ = (uint64_t)v15;
    v14[2].__vftable = (std::__shared_weak_count_vtbl *)v14;
    std::__shared_weak_count::__release_weak(v20);
LABEL_17:
    sub_10004D2C8(v14);
  }
  *a6 = v15;
  a6[1] = v14;
}

void sub_100BF2618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  std::__shared_weak_count::~__shared_weak_count(v14);
  operator delete(v18);
  _Unwind_Resume(a1);
}

void sub_100BF2654(uint64_t a1, int a2, uint64_t *a3, char *a4, uint64_t *a5)
{
  uint64_t v9 = *a3;
  uint64_t v8 = a3[1];
  uint64_t v10 = (std::string *)operator new(0x108uLL);
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A471B8;
  v14[0] = v9;
  v14[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *a5;
  uint64_t v12 = a5[1];
  v13[0] = v11;
  v13[1] = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1005802BC(v10 + 1, a2, v14, a4, v13);
}

void sub_100BF2788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  std::__shared_weak_count::~__shared_weak_count(v12);
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_100BF27B8(uint64_t a1, int a2, uint64_t *a3, char *a4, char *a5, uint64_t *a6)
{
  uint64_t v11 = *a3;
  uint64_t v10 = a3[1];
  uint64_t v12 = operator new(0x120uLL);
  v12[1] = 0;
  void v12[2] = 0;
  void *v12 = off_101A47208;
  v16[0] = v11;
  v16[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *a6;
  uint64_t v14 = a6[1];
  v15[0] = v13;
  v15[1] = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1005951DC((uint64_t)(v12 + 3), a2, v16, a4, a5, v15);
}

void sub_100BF28FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  std::__shared_weak_count::~__shared_weak_count(v12);
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_100BF292C(MMSFactoryInterface *this)
{
  *(void *)this = off_101A47060;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  MMSFactoryInterface::~MMSFactoryInterface(this);
}

void sub_100BF2988(MMSFactoryInterface *this)
{
  *(void *)this = off_101A47060;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  MMSFactoryInterface::~MMSFactoryInterface(this);

  operator delete();
}

void sub_100BF29F8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A470C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BF2A18(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A470C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BF2A6C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100BF2A94(int *a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, void *a4@<X4>, void *a5@<X8>)
{
  uint64_t v10 = operator new(0x120uLL);
  sub_100BF2B28(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;

  sub_1000B3BC8((uint64_t)a5, v10 + 5, (uint64_t)(v10 + 3));
}

void sub_100BF2B14(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100BF2B28(void *a1, int *a2, uint64_t *a3, uint64_t *a4, void *a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A47118;
  sub_100BF2C20((uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_100BF2B70(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100BF2B84(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A47118;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BF2BA4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A47118;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BF2BF8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_100BF2C20(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4, void *a5)
{
  int v6 = *a2;
  BOOL v7 = (std::__shared_weak_count *)a3[1];
  uint64_t v13 = *a3;
  uint64_t v14 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = (std::__shared_weak_count *)a4[1];
  v12[0] = *a4;
  v12[1] = (uint64_t)v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (std::__shared_weak_count *)a5[1];
  v11[0] = *a5;
  v11[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1005025F4(a1, v6, &v13, v12, v11);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  return a1;
}

void sub_100BF2CD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BF2D08(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A47168;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BF2D28(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A47168;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BF2D7C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100BF2DA4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A471B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BF2DC4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A471B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BF2E18(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100BF2E40(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A47208;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BF2E60(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A47208;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BF2EB4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void stewie::StewieConnectionAssistant::create(void *a1@<X1>, void *a2@<X2>, void *a3@<X3>, void *a4@<X5>, void *a5@<X8>)
{
  if (!*a1)
  {
    sub_100BF360C();
    uint64_t v14 = qword_101B10258;
    if (!os_log_type_enabled((os_log_t)qword_101B10258, OS_LOG_TYPE_ERROR))
    {
LABEL_11:
      *a5 = 0;
      a5[1] = 0;
      return;
    }
    *(_WORD *)long long buf = 0;
    __int16 v15 = "timerService must be provided";
LABEL_18:
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v15, buf, 2u);
    goto LABEL_11;
  }
  if (!*a2)
  {
    sub_100BF360C();
    uint64_t v14 = qword_101B10258;
    if (!os_log_type_enabled((os_log_t)qword_101B10258, OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
    *(_WORD *)long long buf = 0;
    __int16 v15 = "sbServices must be provided";
    goto LABEL_18;
  }
  uint64_t v8 = (char *)operator new(0x30uLL);
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *(void *)uint64_t v8 = off_101A47438;
  *(_OWORD *)(v8 + 24) = xmmword_101557450;
  *((_DWORD *)v8 + 10) = 1;
  sub_100BF360C();
  uint64_t v9 = qword_101B10258;
  if (os_log_type_enabled((os_log_t)qword_101B10258, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *((_DWORD *)v8 + 6);
    int v11 = *((_DWORD *)v8 + 7);
    int v12 = *((_DWORD *)v8 + 8);
    int v13 = *((_DWORD *)v8 + 9);
    *(_DWORD *)long long buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = v10;
    __int16 v19 = 1024;
    int v20 = v11;
    __int16 v21 = 1024;
    int v22 = v12;
    __int16 v23 = 1024;
    int v24 = v13;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Using model vector: [x: %d|%d, y: %d|%d]", buf, 0x1Au);
  }
  if (*a3)
  {
    if (*a4) {
      operator new();
    }
    sub_100BF360C();
    uint64_t v16 = qword_101B10258;
    if (!os_log_type_enabled((os_log_t)qword_101B10258, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_WORD *)long long buf = 0;
    __int16 v17 = "delegateQueue must be provided";
    goto LABEL_20;
  }
  sub_100BF360C();
  uint64_t v16 = qword_101B10258;
  if (os_log_type_enabled((os_log_t)qword_101B10258, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    __int16 v17 = "notificationSender must be provided";
LABEL_20:
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v17, buf, 2u);
  }
LABEL_15:
  *a5 = 0;
  a5[1] = 0;
  sub_10004D2C8((std::__shared_weak_count *)v8);
}

void sub_100BF34D0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100BF360C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_101B10260, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_101B10260))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B10258, kCtLoggingSystemName, "stw.ca");
    __cxa_guard_release(qword_101B10260);
  }
}

void sub_100BF368C(_Unwind_Exception *a1)
{
}

uint64_t sub_100BF36A4(uint64_t a1)
{
  *(void *)a1 = off_101A47258;
  *(void *)(a1 + 48) = off_101A47358;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 824);
  if (v2) {
    sub_10004D2C8(v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 768);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 752);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(unsigned char *)(a1 + 736)) {
    sub_100BF5240((void *)(a1 + 696));
  }
  if (*(unsigned char *)(a1 + 600))
  {
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 592);
    if (v5) {
      sub_10004D2C8(v5);
    }
    if (*(unsigned char *)(a1 + 496)) {
      sub_10012577C((const void **)(a1 + 440));
    }
    uint64_t v6 = *(void *)(a1 + 368);
    *(void *)(a1 + 368) = 0;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
  }
  sub_100BFE02C((ctu::OsLogLogger **)(a1 + 328), 0);
  BOOL v7 = *(std::__shared_weak_count **)(a1 + 320);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 304);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 288);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (*(char *)(a1 + 279) < 0) {
    operator delete(*(void **)(a1 + 256));
  }
  int v10 = *(std::__shared_weak_count **)(a1 + 232);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100BFDFDC((stewie::ConnectionAssistantTargetDataSource **)(a1 + 216), 0);
  int v11 = *(std::__shared_weak_count **)(a1 + 208);
  if (v11) {
    sub_10004D2C8(v11);
  }
  int v12 = *(std::__shared_weak_count **)(a1 + 192);
  if (v12) {
    sub_10004D2C8(v12);
  }
  int v13 = *(std::__shared_weak_count **)(a1 + 168);
  if (v13) {
    sub_10004D2C8(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 152);
  if (v14) {
    sub_10004D2C8(v14);
  }
  __int16 v15 = *(std::__shared_weak_count **)(a1 + 136);
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  uint64_t v16 = *(NSObject **)(a1 + 120);
  if (v16) {
    dispatch_release(v16);
  }
  __int16 v17 = *(std::__shared_weak_count **)(a1 + 112);
  if (v17) {
    sub_10004D2C8(v17);
  }
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 96);
  if (v18) {
    sub_10004D2C8(v18);
  }
  __int16 v19 = *(std::__shared_weak_count **)(a1 + 80);
  if (v19) {
    sub_10004D2C8(v19);
  }
  int v20 = *(std::__shared_weak_count **)(a1 + 64);
  if (v20) {
    sub_10004D2C8(v20);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100BF3874(uint64_t a1)
{
  return sub_100BF36A4(a1 - 48);
}

void sub_100BF387C(uint64_t a1)
{
  sub_100BF36A4(a1);

  operator delete();
}

void sub_100BF38B4(uint64_t a1)
{
  sub_100BF36A4(a1 - 48);

  operator delete();
}

void sub_100BF38F0(uint64_t a1, int *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *a2;
    if (v5 > 0xA) {
      uint64_t v6 = "???";
    }
    else {
      uint64_t v6 = off_101A47988[v5];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)int v26 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I requestStewie: reason = %s", buf, 0xCu);
  }
  if (*((unsigned char *)a2 + 48))
  {
    BOOL v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *((unsigned __int8 *)a2 + 42);
      if (*((unsigned char *)a2 + 43)) {
        uint64_t v9 = "true";
      }
      else {
        uint64_t v9 = "false";
      }
      if (*((unsigned char *)a2 + 46)) {
        unsigned __int16 v10 = *((_WORD *)a2 + 22);
      }
      else {
        unsigned __int16 v10 = 0;
      }
      int v11 = sub_100BC87FC(v10);
      *(_DWORD *)long long buf = 67109634;
      *(_DWORD *)int v26 = v8;
      *(_WORD *)&v26[4] = 2080;
      *(void *)&void v26[6] = v9;
      *(_WORD *)&v26[14] = 2080;
      *(void *)&uint8_t v26[16] = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I conversationID = %hhu, committed = %s, fromService = %s", buf, 0x1Cu);
    }
  }
  if (*((unsigned char *)a2 + 88))
  {
    int v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *((unsigned __int8 *)a2 + 56);
      sub_10026B270((uint64_t)(a2 + 16), &__p);
      if (*((unsigned char *)a2 + 82)) {
        unsigned __int16 v14 = *((_WORD *)a2 + 40);
      }
      else {
        unsigned __int16 v14 = 0;
      }
      __int16 v15 = sub_100BC87FC(v14);
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      *(_DWORD *)long long buf = 67109634;
      *(_DWORD *)int v26 = v13;
      *(_WORD *)&v26[4] = 2082;
      *(void *)&void v26[6] = p_p;
      *(_WORD *)&v26[14] = 2080;
      *(void *)&uint8_t v26[16] = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I conversationID = %hhu, providerId = %{public}s, fromService = %s", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  if (*((unsigned char *)a2 + 4))
  {
    __int16 v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = (const char *)(a2 + 2);
      if (*((char *)a2 + 31) < 0) {
        uint64_t v18 = (const char *)*((void *)a2 + 1);
      }
      if (!*((unsigned char *)a2 + 32)) {
        uint64_t v18 = "<none>";
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)int v26 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Request for offer, reason: %{public}s", buf, 0xCu);
    }
    if (*((unsigned char *)a2 + 32))
    {
      __p.__r_.__value_.__r.__words[0] = *((void *)a2 + 2);
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 7) = *(void *)((char *)a2 + 23);
      *((void *)a2 + 2) = 0;
      *((void *)a2 + 3) = 0;
      *((void *)a2 + 1) = 0;
    }
    *(_OWORD *)&v26[3] = *(_OWORD *)(a2 + 10);
    *(_OWORD *)&v26[19] = *(_OWORD *)(a2 + 14);
    long long v27 = *(_OWORD *)(a2 + 18);
    char v28 = *((unsigned char *)a2 + 88);
    int v20 = *(std::__shared_weak_count **)(a1 + 16);
    if (v20)
    {
      if (std::__shared_weak_count::lock(v20)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  __int16 v19 = a2 + 10;
  if (*((unsigned char *)a2 + 40))
  {
    if (*((unsigned char *)a2 + 32))
    {
      __p.__r_.__value_.__r.__words[0] = *((void *)a2 + 2);
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 7) = *(void *)((char *)a2 + 23);
      *((void *)a2 + 2) = 0;
      *((void *)a2 + 3) = 0;
      *((void *)a2 + 1) = 0;
    }
    long long v21 = *(_OWORD *)(a2 + 14);
    *(_OWORD *)&v26[3] = *v19;
    *(_OWORD *)&v26[19] = v21;
    long long v27 = *(_OWORD *)(a2 + 18);
    char v28 = *((unsigned char *)a2 + 88);
    int v22 = *(std::__shared_weak_count **)(a1 + 16);
    if (v22 && std::__shared_weak_count::lock(v22)) {
      operator new();
    }
    sub_100088B9C();
  }
  if (*((unsigned char *)a2 + 32))
  {
    __p.__r_.__value_.__r.__words[0] = *((void *)a2 + 2);
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 7) = *(void *)((char *)a2 + 23);
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    *((void *)a2 + 1) = 0;
  }
  long long v23 = *(_OWORD *)(a2 + 14);
  *(_OWORD *)&v26[3] = *v19;
  *(_OWORD *)&v26[19] = v23;
  long long v27 = *(_OWORD *)(a2 + 18);
  char v28 = *((unsigned char *)a2 + 88);
  int v24 = *(std::__shared_weak_count **)(a1 + 16);
  if (v24 && std::__shared_weak_count::lock(v24)) {
    operator new();
  }
  sub_100088B9C();
}

void sub_100BF3FE4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BF4018(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = sub_100BC8B90(a3);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I exitStewie: reason = %s", buf, 0xCu);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF4184(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BF4194(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100BFEE6C((uint64_t)&v5, a2);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF42C8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BF42D8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100BFF000((uint64_t)&v5, a2);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF440C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BF441C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100BFF194((uint64_t)&v5, a2);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF4550(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BF4560(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF4650(void *a1, uint64_t *a2, void *a3)
{
  uint64_t v4 = *a2;
  if (*a2)
  {
    uint64_t v6 = (void *)*a3;
    if (*a3)
    {
      int v8 = a1[5];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(v4 + 32);
        int v10 = *(_DWORD *)(v4 + 72);
        double v11 = *(double *)(v4 + 8);
        uint64_t v12 = v6[2];
        uint64_t v19 = v6[1];
        uint64_t v13 = v6[4];
        uint64_t v14 = (*(uint64_t (**)(void *))(*a1 + 232))(a1);
        buf[0] = 134219777;
        *(void *)&buf[1] = v9;
        __int16 v21 = 1024;
        int v22 = v10;
        __int16 v23 = 2048;
        double v24 = v11;
        __int16 v25 = 2048;
        unint64_t v26 = (unint64_t)(v11 * 1000000000.0);
        __int16 v27 = 2049;
        uint64_t v28 = v12;
        __int16 v29 = 2049;
        uint64_t v30 = v19;
        __int16 v31 = 2049;
        uint64_t v32 = v13;
        __int16 v33 = 2048;
        uint64_t v34 = v14;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I updateTimeAndLocation - [time: %llu, leap second: %d, timestamp: %f (%llu ns)] and [lat: %{private}f, lng: %{private}f, alt: %{private}f] received at: %llu ns (continuous time)", (uint8_t *)buf, 0x4Eu);
      }
      uint64_t v15 = a2[1];
      if (v15) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v16 = a3[1];
      if (v16) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
      }
      __int16 v17 = (std::__shared_weak_count *)a1[2];
      if (v17)
      {
        if (std::__shared_weak_count::lock(v17)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  uint64_t v18 = a1[5];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "updateTimeAndLocation - null timeFreqData or locationData received", (uint8_t *)buf, 2u);
  }
}

void sub_100BF4918(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BF4928(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *a2;
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I handleStewieTxDeferTime - stewieTxDeferTime: %llu", buf, 0xCu);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF4A88(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BF4A98(uint64_t a1, int isExpired)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 600)) {
    return;
  }
  int v4 = *(unsigned __int8 *)(a1 + 360);
  if (*(unsigned char *)(a1 + 360)) {
    BOOL v5 = (*(_DWORD *)(a1 + 336) & 0xFFFFFFFE) == 2;
  }
  else {
    BOOL v5 = 0;
  }
  uint64_t v6 = *(AutoStartTimer **)(a1 + 816);
  if (v6)
  {
    if (*(unsigned char *)(a1 + 552)) {
      *(unsigned char *)(a1 + 552) = 0;
    }
    int isExpired = AutoStartTimer::isExpired(v6);
    int v4 = *(unsigned __int8 *)(a1 + 360);
    if (!*(unsigned char *)(a1 + 360)) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  if (*(unsigned char *)(a1 + 853) != 1 || (uint64_t v7 = *(void *)(a1 + 216)) == 0 || !*(unsigned char *)(v7 + 184))
  {
    if (*(unsigned char *)(a1 + 552)) {
      goto LABEL_19;
    }
LABEL_25:
    int isExpired = 0;
LABEL_26:
    if (!v4) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  if (!v5)
  {
    if (!isExpired) {
      goto LABEL_26;
    }
    if (*(unsigned char *)(a1 + 520) && *(unsigned char *)(a1 + 512) && *(unsigned char *)(a1 + 851) != 4)
    {
      if (*(unsigned char *)(a1 + 552))
      {
        uint64_t v12 = *(void *)(a1 + 544) + 1;
      }
      else
      {
        uint64_t v12 = 1;
        *(unsigned char *)(a1 + 552) = 1;
      }
      int isExpired = 0;
      *(void *)(a1 + 544) = v12;
      *(void *)(a1 + 536) = 0;
      if (!v4) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }
    goto LABEL_25;
  }
  if (!isExpired) {
    goto LABEL_26;
  }
  if (!*(unsigned char *)(a1 + 552)) {
    goto LABEL_25;
  }
  unint64_t v8 = *(void *)(a1 + 536) + 1;
  *(void *)(a1 + 536) = v8;
  if (v8 < 8) {
    goto LABEL_25;
  }
LABEL_19:
  int isExpired = 0;
  *(unsigned char *)(a1 + 552) = 0;
  if (v4) {
LABEL_27:
  }
    int v4 = *(_DWORD *)(a1 + 336) == 3;
LABEL_28:
  if (*(unsigned char *)(a1 + 552))
  {
    int v9 = v4 ? isExpired : 1;
    if (*(void *)(a1 + 544) > 0x14uLL) {
      int isExpired = v9;
    }
  }
  if (isExpired != *(_DWORD *)(a1 + 528))
  {
    *(_DWORD *)(a1 + 528) = isExpired;
    int v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      if (isExpired) {
        double v11 = "kLow";
      }
      else {
        double v11 = "kUnknown";
      }
      int v13 = 136315138;
      uint64_t v14 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Visibility level changed to: %s", (uint8_t *)&v13, 0xCu);
    }
  }
}

void sub_100BF4CA0(uint64_t a1)
{
  uint64_t v2 = a1 + 696;
  if ((*(_WORD *)(a1 + 833) & 0x30) == 0)
  {
    if (!*(void *)(a1 + 760))
    {
      BOOL v4 = 1;
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  int v3 = *(_WORD *)(a1 + 835) & 0x30;
  BOOL v4 = (*(_WORD *)(a1 + 835) & 0x30) != 0;
  uint64_t v5 = *(void *)(a1 + 760);
  if (!v5) {
    goto LABEL_16;
  }
  if (v3)
  {
LABEL_10:
    int v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Instant offer is presented when messaging services are either not allowed or already active, dismissing it", buf, 2u);
    }
    BOOL v4 = 1;
    goto LABEL_13;
  }
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  if (*(unsigned char *)(a1 + 810) && *(unsigned char *)(a1 + 809) && v6 == 1)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    BOOL v4 = 0;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    *(_WORD *)long long buf = 0;
    unint64_t v8 = "#I OTG offer is presented when OTG mode is on, dismissing it";
    goto LABEL_54;
  }
  if (*(unsigned char *)(a1 + 811) && !*(unsigned char *)(a1 + 812))
  {
    BOOL v4 = 0;
    goto LABEL_16;
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  BOOL v4 = 0;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    unint64_t v8 = "#I Instant offer pending while display is not active or coversheet is active, dismissing it";
LABEL_54:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, buf, 2u);
    BOOL v4 = 0;
  }
LABEL_13:
  (*(void (**)(void))(**(void **)(a1 + 760) + 24))(*(void *)(a1 + 760));
  *(void *)(a1 + 760) = 0;
  int v10 = *(std::__shared_weak_count **)(a1 + 768);
  *(void *)(a1 + 768) = 0;
  if (v10) {
    sub_10004D2C8(v10);
  }
LABEL_16:
  if ((*(_WORD *)(v2 + 137) & 0x30) != 0)
  {
    if ((*(_WORD *)(v2 + 139) & 0x30) != 0 && !*(unsigned char *)(a1 + 808))
    {
      double v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Remember that messaging services were active at least once", buf, 2u);
      }
      *(unsigned char *)(a1 + 808) = 1;
    }
  }
  else if (*(unsigned char *)(a1 + 808))
  {
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Messaging services are not allowed, reset the fact that they were active at least once", buf, 2u);
    }
    *(unsigned char *)(a1 + 808) = 0;
  }
  if (v4
    || *(unsigned char *)(a1 + 810) && *(unsigned char *)(a1 + 809)
    || *(unsigned char *)(a1 + 808)
    || (int v13 = *(AutoStartTimer **)(a1 + 744)) != 0 && (AutoStartTimer::isExpired(v13) & 1) == 0)
  {
    buf[0] = 0;
    char v32 = 0;
    sub_100BFD114(a1 + 696, (uint64_t *)buf);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 736))
    {
      uint64_t v31 = 0;
      *(_OWORD *)long long buf = 0u;
      long long v30 = 0u;
      *(void *)uint64_t v2 = 0;
      *(void *)(v2 + 8) = 0;
      *(unsigned char *)(v2 + 16) = 0;
      *(void *)(a1 + 728) = 0;
      *(void *)(a1 + 720) = 0;
      *(unsigned char *)(a1 + 736) = 1;
      sub_100BF5240(buf);
    }
    if (*(void *)v2)
    {
      if (AutoStartTimer::isExpired(*(AutoStartTimer **)v2)
        && !*(unsigned char *)(a1 + 811)
        && *(unsigned char *)(a1 + 854)
        && *(unsigned char *)(a1 + 814)
        && *(unsigned char *)(a1 + 813)
        && !*(void *)(a1 + 720))
      {
        *(unsigned char *)(a1 + 712) = 1;
        ++*(void *)(a1 + 776);
        uint64_t v14 = *(void *)(a1 + 144);
        uint64_t v15 = *(NSObject **)(a1 + 24);
        object[0] = v15;
        if (v15) {
          dispatch_retain(v15);
        }
        sub_100BF51F4(&v21, (void *)(a1 + 8));
        unint64_t v26 = off_101A47680;
        long long v27 = v21;
        uint64_t v28 = &v26;
        (*(void (**)(uint8_t *__return_ptr, uint64_t, void, dispatch_object_t *, uint64_t (***)()))(*(void *)v14 + 16))(buf, v14, 0, object, &v26);
        long long v16 = *(_OWORD *)buf;
        memset(buf, 0, sizeof(buf));
        __int16 v17 = *(std::__shared_weak_count **)(a1 + 728);
        *(_OWORD *)(a1 + 720) = v16;
        if (v17)
        {
          sub_10004D2C8(v17);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
        }
        sub_100C0015C(&v26);
        if (object[0]) {
          dispatch_release(object[0]);
        }
      }
    }
    else
    {
      uint64_t v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = 7200;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Starting a timer for OTG offer. Duration: %lld seconds", buf, 0xCu);
      }
      sub_100058DB0(&__p, "OfferTracker");
      object[1] = (dispatch_object_t)7200000;
      *(void *)long long buf = off_101A47600;
      *(void *)&uint8_t buf[8] = a1;
      *((void *)&v30 + 1) = buf;
      AutoStartTimer::create();
      long long v19 = v25;
      long long v25 = 0uLL;
      int v20 = *(std::__shared_weak_count **)(a1 + 704);
      *(_OWORD *)uint64_t v2 = v19;
      if (v20)
      {
        sub_10004D2C8(v20);
        if (*((void *)&v25 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v25 + 1));
        }
      }
      sub_10003B34C(buf);
      if (v24 < 0) {
        operator delete(__p);
      }
    }
  }
}

void sub_100BF51A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(a1);
}

void sub_100BF51F4(void *a1, void *a2)
{
  sub_10003E168(v4, a2);
  int v3 = (std::__shared_weak_count *)v4[1];
  *a1 = v4[0];
  a1[1] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
  }
}

void *sub_100BF5240(void *a1)
{
  uint64_t v2 = a1[3];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    sub_10004D2C8(v3);
  }
  BOOL v4 = (std::__shared_weak_count *)a1[1];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_100BF52AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF53A4(uint64_t a1, uint64_t a2)
{
  BOOL v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I handleStewieStateChanged", v6, 2u);
  }
  *(_OWORD *)int v6 = *(_OWORD *)a2;
  *(void *)&v6[14] = *(void *)(a2 + 14);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF54F4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF55E4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF56D4(uint64_t a1, void *a2)
{
  if (*a2)
  {
    uint64_t v2 = a2[1];
    if (v2) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
    }
    int v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (v3)
    {
      if (std::__shared_weak_count::lock(v3)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  BOOL v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I updateProvisioningData - not provisioned", buf, 2u);
  }
}

void sub_100BF5838(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF5938(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I stopTargetDataTracking", buf, 2u);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF5A54(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF5B70(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF5C70(uint64_t a1, void *a2)
{
  a2[2] = 0;
  a2[3] = 0;
  a2[1] = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF5D80(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF5E70(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF5F68(uint64_t a1, uint64_t a2)
{
  sub_10012A394(&v5, (const void **)a2);
  long long v6 = *(_OWORD *)(a2 + 8);
  uint64_t v7 = *(void *)(a2 + 24);
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF609C(uint64_t a1, int a2)
{
  BOOL v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "false";
    if (a2) {
      uint64_t v5 = "true";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I handleOffTheGridModeUpdated: on = %s", buf, 0xCu);
  }
  long long v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF6210(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BF6220(uint64_t a1, int a2, int a3)
{
  long long v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "false";
    if (a2) {
      unint64_t v8 = "true";
    }
    else {
      unint64_t v8 = "false";
    }
    if (a3) {
      uint64_t v7 = "true";
    }
    buf[0] = 136315394;
    *(void *)&buf[1] = v8;
    __int16 v11 = 2080;
    uint64_t v12 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I handleDisplayStatusChanged: isDisplayActive = %s, isCoverSheetActive = %s", (uint8_t *)buf, 0x16u);
  }
  int v9 = *(std::__shared_weak_count **)(a1 + 16);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF63B0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BF63C0(uint64_t a1, unsigned char *a2)
{
  BOOL v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*a2) {
      uint64_t v5 = "true";
    }
    else {
      uint64_t v5 = "false";
    }
    if (a2[1]) {
      long long v6 = v5;
    }
    else {
      long long v6 = "<none>";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I handleAreGPSSatsVisibleChanged: areGpsSatsVisible = %s", buf, 0xCu);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BF6550(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100BF6560(uint64_t a1, int *a2, int a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  long long v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *a2;
    if (v7 > 0xA) {
      unint64_t v8 = "???";
    }
    else {
      unint64_t v8 = off_101A47988[v7];
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I requestAssistantApp_sync: reason = %s", (uint8_t *)&buf, 0xCu);
  }
  if (*((unsigned char *)a2 + 4))
  {
    int v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "SOSBuddy is not interested in learning about offer requests", (uint8_t *)&buf, 2u);
    }
    return 0;
  }
  else
  {
    uint64_t v189 = 0;
    v190 = 0;
    unint64_t v191 = 0;
    uint64_t v186 = 0;
    size_t v187 = 0;
    uint64_t v188 = 0;
    sub_100058DB0(&v186, "reason=");
    int v183 = 0;
    std::string::size_type v184 = 0;
    uint64_t v185 = 0;
    sub_100058DB0(&v183, "conversationId=");
    int v180 = 0;
    std::string::size_type v181 = 0;
    uint64_t v182 = 0;
    sub_100058DB0(&v180, "action=");
    uint64_t v177 = 0;
    std::string::size_type v178 = 0;
    uint64_t v179 = 0;
    sub_100058DB0(&v177, "providerId=");
    uint64_t v174 = 0;
    size_t v175 = 0;
    uint64_t v176 = 0;
    sub_100058DB0(&v174, "fromService=");
    v172[0] = 0;
    v172[1] = 0;
    uint64_t v173 = 0;
    sub_100058DB0(v172, "offerKind=");
    BOOL v10 = 0;
    switch(*a2)
    {
      case 0:
        goto LABEL_388;
      case 1:
        if (v188 >= 0) {
          size_t v11 = HIBYTE(v188);
        }
        else {
          size_t v11 = v187;
        }
        memset(&__p, 0, sizeof(__p));
        p_p = &__p;
        sub_1000C140C((uint64_t)&__p, v11 + 13);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v11)
        {
          if (v188 >= 0) {
            int v13 = &v186;
          }
          else {
            int v13 = v186;
          }
          memmove(p_p, v13, v11);
        }
        strcpy((char *)p_p + v11, "EmergencyCall");
        uint64_t v14 = v190;
        if ((unint64_t)v190 < v191) {
          goto LABEL_177;
        }
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
        unint64_t v16 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v16) {
          unint64_t v16 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v16;
        }
        char v196 = &v191;
        if (v17) {
          goto LABEL_185;
        }
        xpc_object_t v52 = 0;
        goto LABEL_195;
      case 2:
        if (v188 >= 0) {
          size_t v26 = HIBYTE(v188);
        }
        else {
          size_t v26 = v187;
        }
        memset(&__p, 0, sizeof(__p));
        long long v27 = &__p;
        sub_1000C140C((uint64_t)&__p, v26 + 13);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          long long v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v26)
        {
          if (v188 >= 0) {
            uint64_t v28 = &v186;
          }
          else {
            uint64_t v28 = v186;
          }
          memmove(v27, v28, v26);
        }
        strcpy((char *)v27 + v26, "EmergencyText");
        uint64_t v14 = v190;
        if ((unint64_t)v190 < v191) {
          goto LABEL_177;
        }
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
        unint64_t v29 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v29) {
          unint64_t v29 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v29;
        }
        char v196 = &v191;
        if (v17) {
          goto LABEL_185;
        }
        xpc_object_t v52 = 0;
        goto LABEL_195;
      case 3:
        if (v188 >= 0) {
          size_t v30 = HIBYTE(v188);
        }
        else {
          size_t v30 = v187;
        }
        memset(&__p, 0, sizeof(__p));
        uint64_t v31 = &__p;
        sub_1000C140C((uint64_t)&__p, v30 + 22);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v31 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v30)
        {
          if (v188 >= 0) {
            char v32 = &v186;
          }
          else {
            char v32 = v186;
          }
          memmove(v31, v32, v30);
        }
        strcpy((char *)v31 + v30, "EmergencyFallDetection");
        uint64_t v14 = v190;
        if ((unint64_t)v190 < v191) {
          goto LABEL_177;
        }
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
        unint64_t v33 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v33) {
          unint64_t v33 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v33;
        }
        char v196 = &v191;
        if (v17) {
          goto LABEL_185;
        }
        xpc_object_t v52 = 0;
        goto LABEL_195;
      case 4:
        if (v188 >= 0) {
          size_t v18 = HIBYTE(v188);
        }
        else {
          size_t v18 = v187;
        }
        memset(&__p, 0, sizeof(__p));
        long long v19 = &__p;
        sub_1000C140C((uint64_t)&__p, v18 + 14);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          long long v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v18)
        {
          if (v188 >= 0) {
            int v20 = &v186;
          }
          else {
            int v20 = v186;
          }
          memmove(v19, v20, v18);
        }
        strcpy((char *)v19 + v18, "EmergencyKappa");
        uint64_t v14 = v190;
        if ((unint64_t)v190 < v191) {
          goto LABEL_177;
        }
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
        unint64_t v21 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v21) {
          unint64_t v21 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v21;
        }
        char v196 = &v191;
        if (v17) {
          goto LABEL_185;
        }
        xpc_object_t v52 = 0;
        goto LABEL_195;
      case 5:
        uint64_t v38 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "SOSBuddy is not interested in learning about kTryOut", (uint8_t *)&buf, 2u);
        }
        BOOL v10 = 0;
        goto LABEL_388;
      case 6:
        if (v188 >= 0) {
          size_t v39 = HIBYTE(v188);
        }
        else {
          size_t v39 = v187;
        }
        memset(&__p, 0, sizeof(__p));
        unsigned int v40 = &__p;
        sub_1000C140C((uint64_t)&__p, v39 + 6);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unsigned int v40 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v39)
        {
          if (v188 >= 0) {
            CFIndex v41 = &v186;
          }
          else {
            CFIndex v41 = v186;
          }
          memmove(v40, v41, v39);
        }
        strcpy((char *)v40 + v39, "FindMy");
        uint64_t v14 = v190;
        if ((unint64_t)v190 < v191) {
          goto LABEL_177;
        }
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
        unint64_t v42 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v42) {
          unint64_t v42 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v42;
        }
        char v196 = &v191;
        if (v17) {
          goto LABEL_185;
        }
        xpc_object_t v52 = 0;
        goto LABEL_195;
      case 7:
        if (v188 >= 0) {
          size_t v34 = HIBYTE(v188);
        }
        else {
          size_t v34 = v187;
        }
        memset(&__p, 0, sizeof(__p));
        uint64_t v35 = &__p;
        sub_1000C140C((uint64_t)&__p, v34 + 8);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v34)
        {
          if (v188 >= 0) {
            uint64_t v36 = &v186;
          }
          else {
            uint64_t v36 = v186;
          }
          memmove(v35, v36, v34);
        }
        strcpy((char *)v35 + v34, "Roadside");
        uint64_t v14 = v190;
        if ((unint64_t)v190 < v191) {
          goto LABEL_177;
        }
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
        unint64_t v37 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v37) {
          unint64_t v37 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v37;
        }
        char v196 = &v191;
        if (v17) {
          goto LABEL_185;
        }
        xpc_object_t v52 = 0;
        goto LABEL_195;
      case 8:
        if (v188 >= 0) {
          size_t v47 = HIBYTE(v188);
        }
        else {
          size_t v47 = v187;
        }
        memset(&__p, 0, sizeof(__p));
        xpc_object_t v48 = &__p;
        sub_1000C140C((uint64_t)&__p, v47 + 9);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          xpc_object_t v48 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v47)
        {
          if (v188 >= 0) {
            xpc_object_t v49 = &v186;
          }
          else {
            xpc_object_t v49 = v186;
          }
          memmove(v48, v49, v47);
        }
        strcpy((char *)v48 + v47, "Messaging");
        uint64_t v14 = v190;
        if ((unint64_t)v190 < v191) {
          goto LABEL_177;
        }
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
        unint64_t v51 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v51) {
          unint64_t v51 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v51;
        }
        char v196 = &v191;
        if (v17) {
          goto LABEL_185;
        }
        xpc_object_t v52 = 0;
        goto LABEL_195;
      case 9:
        if (v188 >= 0) {
          size_t v22 = HIBYTE(v188);
        }
        else {
          size_t v22 = v187;
        }
        memset(&__p, 0, sizeof(__p));
        __int16 v23 = &__p;
        sub_1000C140C((uint64_t)&__p, v22 + 12);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          __int16 v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v22)
        {
          if (v188 >= 0) {
            char v24 = &v186;
          }
          else {
            char v24 = v186;
          }
          memmove(v23, v24, v22);
        }
        strcpy((char *)v23 + v22, "IMessageLite");
        uint64_t v14 = v190;
        if ((unint64_t)v190 < v191) {
          goto LABEL_177;
        }
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
        unint64_t v25 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v25) {
          unint64_t v25 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v25;
        }
        char v196 = &v191;
        if (v17) {
          goto LABEL_185;
        }
        xpc_object_t v52 = 0;
        goto LABEL_195;
      case 10:
        if (v188 >= 0) {
          size_t v43 = HIBYTE(v188);
        }
        else {
          size_t v43 = v187;
        }
        memset(&__p, 0, sizeof(__p));
        char v44 = &__p;
        sub_1000C140C((uint64_t)&__p, v43 + 6);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          char v44 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v43)
        {
          if (v188 >= 0) {
            uint64_t v45 = &v186;
          }
          else {
            uint64_t v45 = v186;
          }
          memmove(v44, v45, v43);
        }
        strcpy((char *)v44 + v43, "SatSms");
        uint64_t v14 = v190;
        if ((unint64_t)v190 < v191)
        {
LABEL_177:
          long long v50 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((void *)v14 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)uint64_t v14 = v50;
          v190 = v14 + 24;
        }
        else
        {
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
          unint64_t v46 = v15 + 1;
          if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_1000D8578();
          }
          if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v46) {
            unint64_t v46 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
            unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v17 = v46;
          }
          char v196 = &v191;
          if (v17) {
LABEL_185:
          }
            xpc_object_t v52 = (char *)sub_10004812C((uint64_t)&v191, v17);
          else {
            xpc_object_t v52 = 0;
          }
LABEL_195:
          xpc_object_t v53 = &v52[24 * v15];
          *(void *)&long long buf = v52;
          *((void *)&buf + 1) = v53;
          uint64_t v195 = &v52[24 * v17];
          long long v54 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((void *)v53 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)xpc_object_t v53 = v54;
          memset(&__p, 0, sizeof(__p));
          v194 = v53 + 24;
          sub_100048204((uint64_t *)&v189, &buf);
          uint64_t v55 = v190;
          sub_100048174((uint64_t)&buf);
          v190 = v55;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
LABEL_197:
        if (*((unsigned char *)a2 + 48))
        {
          std::to_string(&__p, *((unsigned __int8 *)a2 + 42));
          if (v185 >= 0) {
            int v56 = (const std::string::value_type *)&v183;
          }
          else {
            int v56 = (const std::string::value_type *)v183;
          }
          if (v185 >= 0) {
            std::string::size_type v57 = HIBYTE(v185);
          }
          else {
            std::string::size_type v57 = v184;
          }
          char v58 = std::string::insert(&__p, 0, v56, v57);
          std::string::size_type v59 = v58->__r_.__value_.__r.__words[0];
          v192[0] = v58->__r_.__value_.__l.__size_;
          *(void *)((char *)v192 + 7) = *(std::string::size_type *)((char *)&v58->__r_.__value_.__r.__words[1] + 7);
          char v60 = HIBYTE(v58->__r_.__value_.__r.__words[2]);
          v58->__r_.__value_.__l.__size_ = 0;
          v58->__r_.__value_.__r.__words[2] = 0;
          v58->__r_.__value_.__r.__words[0] = 0;
          uint64_t v61 = v190;
          if ((unint64_t)v190 >= v191)
          {
            unint64_t v64 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
            unint64_t v65 = v64 + 1;
            if (v64 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_1000D8578();
            }
            if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v65) {
              unint64_t v65 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
              unint64_t v66 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v66 = v65;
            }
            char v196 = &v191;
            if (v66) {
              uint64_t v67 = (char *)sub_10004812C((uint64_t)&v191, v66);
            }
            else {
              uint64_t v67 = 0;
            }
            uint64_t v68 = &v67[24 * v64];
            *(void *)&long long buf = v67;
            *((void *)&buf + 1) = v68;
            uint64_t v195 = &v67[24 * v66];
            uint64_t v69 = v192[0];
            *(void *)uint64_t v68 = v59;
            *((void *)v68 + 1) = v69;
            *(void *)(v68 + 15) = *(void *)((char *)v192 + 7);
            v68[23] = v60;
            v194 = v68 + 24;
            sub_100048204((uint64_t *)&v189, &buf);
            xpc_object_t v63 = v190;
            sub_100048174((uint64_t)&buf);
          }
          else
          {
            uint64_t v62 = v192[0];
            *(void *)v190 = v59;
            *((void *)v61 + 1) = v62;
            *(void *)(v61 + 15) = *(void *)((char *)v192 + 7);
            v61[23] = v60;
            xpc_object_t v63 = v61 + 24;
          }
          v190 = v63;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (*((unsigned char *)a2 + 43)) {
            long long v70 = "resumeConversation";
          }
          else {
            long long v70 = "startConversation";
          }
          sub_100058DB0(&__p, v70);
          if (v182 >= 0) {
            uint64_t v71 = (const std::string::value_type *)&v180;
          }
          else {
            uint64_t v71 = (const std::string::value_type *)v180;
          }
          if (v182 >= 0) {
            std::string::size_type v72 = HIBYTE(v182);
          }
          else {
            std::string::size_type v72 = v181;
          }
          char v73 = std::string::insert(&__p, 0, v71, v72);
          std::string::size_type v74 = v73->__r_.__value_.__r.__words[0];
          v192[0] = v73->__r_.__value_.__l.__size_;
          *(void *)((char *)v192 + 7) = *(std::string::size_type *)((char *)&v73->__r_.__value_.__r.__words[1] + 7);
          char v75 = HIBYTE(v73->__r_.__value_.__r.__words[2]);
          v73->__r_.__value_.__l.__size_ = 0;
          v73->__r_.__value_.__r.__words[2] = 0;
          v73->__r_.__value_.__r.__words[0] = 0;
          uint64_t v76 = v190;
          if ((unint64_t)v190 >= v191)
          {
            unint64_t v79 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
            unint64_t v80 = v79 + 1;
            if (v79 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_1000D8578();
            }
            if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v80) {
              unint64_t v80 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
              unint64_t v81 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v81 = v80;
            }
            char v196 = &v191;
            if (v81) {
              CFAllocatorRef v82 = (char *)sub_10004812C((uint64_t)&v191, v81);
            }
            else {
              CFAllocatorRef v82 = 0;
            }
            long long v83 = &v82[24 * v79];
            *(void *)&long long buf = v82;
            *((void *)&buf + 1) = v83;
            uint64_t v195 = &v82[24 * v81];
            uint64_t v84 = v192[0];
            *(void *)long long v83 = v74;
            *((void *)v83 + 1) = v84;
            *(void *)(v83 + 15) = *(void *)((char *)v192 + 7);
            v83[23] = v75;
            v194 = v83 + 24;
            sub_100048204((uint64_t *)&v189, &buf);
            xpc_object_t v78 = v190;
            sub_100048174((uint64_t)&buf);
          }
          else
          {
            uint64_t v77 = v192[0];
            *(void *)v190 = v74;
            *((void *)v76 + 1) = v77;
            *(void *)(v76 + 15) = *(void *)((char *)v192 + 7);
            v76[23] = v75;
            xpc_object_t v78 = v76 + 24;
          }
          v190 = v78;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (*((unsigned char *)a2 + 46) && *((_WORD *)a2 + 22) == 8)
          {
            if (v176 >= 0) {
              size_t v85 = HIBYTE(v176);
            }
            else {
              size_t v85 = v175;
            }
            memset(&__p, 0, sizeof(__p));
            xpc_object_t v86 = &__p;
            sub_1000C140C((uint64_t)&__p, v85 + 8);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              xpc_object_t v86 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            if (v85)
            {
              if (v176 >= 0) {
                xpc_object_t v87 = &v174;
              }
              else {
                xpc_object_t v87 = v174;
              }
              memmove(v86, v87, v85);
            }
            strcpy((char *)v86 + v85, "Roadside");
            CFStringRef v88 = v190;
            if ((unint64_t)v190 >= v191)
            {
              unint64_t v90 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
              unint64_t v91 = v90 + 1;
              if (v90 + 1 > 0xAAAAAAAAAAAAAAALL) {
                sub_1000D8578();
              }
              if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v91) {
                unint64_t v91 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
                unint64_t v92 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v92 = v91;
              }
              char v196 = &v191;
              if (v92) {
                CFStringRef v93 = (char *)sub_10004812C((uint64_t)&v191, v92);
              }
              else {
                CFStringRef v93 = 0;
              }
              unint64_t v94 = &v93[24 * v90];
              *(void *)&long long buf = v93;
              *((void *)&buf + 1) = v94;
              uint64_t v195 = &v93[24 * v92];
              long long v95 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
              *((void *)v94 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
              *(_OWORD *)unint64_t v94 = v95;
              memset(&__p, 0, sizeof(__p));
              v194 = v94 + 24;
              sub_100048204((uint64_t *)&v189, &buf);
              CFStringRef v96 = v190;
              sub_100048174((uint64_t)&buf);
              v190 = v96;
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
            }
            else
            {
              long long v89 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
              *((void *)v190 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
              *CFStringRef v88 = v89;
              v190 = (char *)v88 + 24;
            }
          }
        }
        if (*((unsigned char *)a2 + 88))
        {
          std::to_string(&__p, *((unsigned __int8 *)a2 + 56));
          if (v185 >= 0) {
            unint64_t v97 = (const std::string::value_type *)&v183;
          }
          else {
            unint64_t v97 = (const std::string::value_type *)v183;
          }
          if (v185 >= 0) {
            std::string::size_type v98 = HIBYTE(v185);
          }
          else {
            std::string::size_type v98 = v184;
          }
          CFTypeRef v99 = std::string::insert(&__p, 0, v97, v98);
          std::string::size_type v100 = v99->__r_.__value_.__r.__words[0];
          v192[0] = v99->__r_.__value_.__l.__size_;
          *(void *)((char *)v192 + 7) = *(std::string::size_type *)((char *)&v99->__r_.__value_.__r.__words[1] + 7);
          char v101 = HIBYTE(v99->__r_.__value_.__r.__words[2]);
          v99->__r_.__value_.__l.__size_ = 0;
          v99->__r_.__value_.__r.__words[2] = 0;
          v99->__r_.__value_.__r.__words[0] = 0;
          xpc_object_t v102 = v190;
          if ((unint64_t)v190 >= v191)
          {
            unint64_t v105 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
            unint64_t v106 = v105 + 1;
            if (v105 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_1000D8578();
            }
            if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v106) {
              unint64_t v106 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
              unint64_t v107 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v107 = v106;
            }
            char v196 = &v191;
            if (v107) {
              CFMutableDictionaryRef v108 = (char *)sub_10004812C((uint64_t)&v191, v107);
            }
            else {
              CFMutableDictionaryRef v108 = 0;
            }
            uint64_t v109 = &v108[24 * v105];
            *(void *)&long long buf = v108;
            *((void *)&buf + 1) = v109;
            uint64_t v195 = &v108[24 * v107];
            uint64_t v110 = v192[0];
            *(void *)uint64_t v109 = v100;
            *((void *)v109 + 1) = v110;
            *(void *)(v109 + 15) = *(void *)((char *)v192 + 7);
            v109[23] = v101;
            v194 = v109 + 24;
            sub_100048204((uint64_t *)&v189, &buf);
            long long v104 = v190;
            sub_100048174((uint64_t)&buf);
          }
          else
          {
            uint64_t v103 = v192[0];
            *(void *)v190 = v100;
            *((void *)v102 + 1) = v103;
            *(void *)(v102 + 15) = *(void *)((char *)v192 + 7);
            v102[23] = v101;
            long long v104 = v102 + 24;
          }
          v190 = v104;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (*((unsigned char *)a2 + 57)) {
            xpc_object_t v111 = "resumeConversation";
          }
          else {
            xpc_object_t v111 = "startConversation";
          }
          sub_100058DB0(&__p, v111);
          if (v182 >= 0) {
            xpc_object_t v112 = (const std::string::value_type *)&v180;
          }
          else {
            xpc_object_t v112 = (const std::string::value_type *)v180;
          }
          if (v182 >= 0) {
            std::string::size_type v113 = HIBYTE(v182);
          }
          else {
            std::string::size_type v113 = v181;
          }
          xpc_object_t v114 = std::string::insert(&__p, 0, v112, v113);
          std::string::size_type v115 = v114->__r_.__value_.__r.__words[0];
          v192[0] = v114->__r_.__value_.__l.__size_;
          *(void *)((char *)v192 + 7) = *(std::string::size_type *)((char *)&v114->__r_.__value_.__r.__words[1] + 7);
          char v116 = HIBYTE(v114->__r_.__value_.__r.__words[2]);
          v114->__r_.__value_.__l.__size_ = 0;
          v114->__r_.__value_.__r.__words[2] = 0;
          v114->__r_.__value_.__r.__words[0] = 0;
          uint64_t v117 = v190;
          if ((unint64_t)v190 >= v191)
          {
            unint64_t v120 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
            unint64_t v121 = v120 + 1;
            if (v120 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_1000D8578();
            }
            if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v121) {
              unint64_t v121 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
              unint64_t v122 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v122 = v121;
            }
            char v196 = &v191;
            if (v122) {
              CFTypeRef v123 = (char *)sub_10004812C((uint64_t)&v191, v122);
            }
            else {
              CFTypeRef v123 = 0;
            }
            int v124 = &v123[24 * v120];
            *(void *)&long long buf = v123;
            *((void *)&buf + 1) = v124;
            uint64_t v195 = &v123[24 * v122];
            uint64_t v125 = v192[0];
            *(void *)int v124 = v115;
            *((void *)v124 + 1) = v125;
            *(void *)(v124 + 15) = *(void *)((char *)v192 + 7);
            v124[23] = v116;
            v194 = v124 + 24;
            sub_100048204((uint64_t *)&v189, &buf);
            uint64_t v119 = v190;
            sub_100048174((uint64_t)&buf);
          }
          else
          {
            uint64_t v118 = v192[0];
            *(void *)v190 = v115;
            *((void *)v117 + 1) = v118;
            *(void *)(v117 + 15) = *(void *)((char *)v192 + 7);
            v117[23] = v116;
            uint64_t v119 = v117 + 24;
          }
          v190 = v119;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (*((unsigned char *)a2 + 72))
          {
            std::to_string(&__p, *((void *)a2 + 8));
            if (v179 >= 0) {
              char v126 = (const std::string::value_type *)&v177;
            }
            else {
              char v126 = (const std::string::value_type *)v177;
            }
            if (v179 >= 0) {
              std::string::size_type v127 = HIBYTE(v179);
            }
            else {
              std::string::size_type v127 = v178;
            }
            char v128 = std::string::insert(&__p, 0, v126, v127);
            std::string::size_type v129 = v128->__r_.__value_.__r.__words[0];
            v192[0] = v128->__r_.__value_.__l.__size_;
            *(void *)((char *)v192 + 7) = *(std::string::size_type *)((char *)&v128->__r_.__value_.__r.__words[1] + 7);
            char v130 = HIBYTE(v128->__r_.__value_.__r.__words[2]);
            v128->__r_.__value_.__l.__size_ = 0;
            v128->__r_.__value_.__r.__words[2] = 0;
            v128->__r_.__value_.__r.__words[0] = 0;
            char v131 = v190;
            if ((unint64_t)v190 >= v191)
            {
              unint64_t v134 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
              unint64_t v135 = v134 + 1;
              if (v134 + 1 > 0xAAAAAAAAAAAAAAALL) {
                sub_1000D8578();
              }
              if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v135) {
                unint64_t v135 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
                unint64_t v136 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v136 = v135;
              }
              char v196 = &v191;
              if (v136) {
                uint64_t v137 = (char *)sub_10004812C((uint64_t)&v191, v136);
              }
              else {
                uint64_t v137 = 0;
              }
              CFStringRef v138 = &v137[24 * v134];
              *(void *)&long long buf = v137;
              *((void *)&buf + 1) = v138;
              uint64_t v195 = &v137[24 * v136];
              uint64_t v139 = v192[0];
              *(void *)CFStringRef v138 = v129;
              *((void *)v138 + 1) = v139;
              *(void *)(v138 + 15) = *(void *)((char *)v192 + 7);
              v138[23] = v130;
              v194 = v138 + 24;
              sub_100048204((uint64_t *)&v189, &buf);
              long long v133 = v190;
              sub_100048174((uint64_t)&buf);
            }
            else
            {
              uint64_t v132 = v192[0];
              *(void *)v190 = v129;
              *((void *)v131 + 1) = v132;
              *(void *)(v131 + 15) = *(void *)((char *)v192 + 7);
              v131[23] = v130;
              long long v133 = v131 + 24;
            }
            v190 = v133;
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }
          if (*((unsigned char *)a2 + 82) && *((_WORD *)a2 + 40) == 1)
          {
            if (v176 >= 0) {
              size_t v140 = HIBYTE(v176);
            }
            else {
              size_t v140 = v175;
            }
            memset(&__p, 0, sizeof(__p));
            CFStringRef v141 = &__p;
            sub_1000C140C((uint64_t)&__p, v140 + 9);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              CFStringRef v141 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            if (v140)
            {
              if (v176 >= 0) {
                CFStringRef v142 = &v174;
              }
              else {
                CFStringRef v142 = v174;
              }
              memmove(v141, v142, v140);
            }
            strcpy((char *)v141 + v140, "Emergency");
            char v143 = v190;
            if ((unint64_t)v190 >= v191)
            {
              unint64_t v145 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
              unint64_t v146 = v145 + 1;
              if (v145 + 1 > 0xAAAAAAAAAAAAAAALL) {
                sub_1000D8578();
              }
              if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v146) {
                unint64_t v146 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
                unint64_t v147 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v147 = v146;
              }
              char v196 = &v191;
              if (v147) {
                long long v148 = (char *)sub_10004812C((uint64_t)&v191, v147);
              }
              else {
                long long v148 = 0;
              }
              long long v149 = &v148[24 * v145];
              *(void *)&long long buf = v148;
              *((void *)&buf + 1) = v149;
              uint64_t v195 = &v148[24 * v147];
              long long v150 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
              *((void *)v149 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
              *(_OWORD *)long long v149 = v150;
              memset(&__p, 0, sizeof(__p));
              v194 = v149 + 24;
              sub_100048204((uint64_t *)&v189, &buf);
              long long v151 = v190;
              sub_100048174((uint64_t)&buf);
              v190 = v151;
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
            }
            else
            {
              long long v144 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
              *((void *)v190 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
              *char v143 = v144;
              v190 = (char *)v143 + 24;
            }
          }
        }
        if (!*((unsigned char *)a2 + 40)) {
          goto LABEL_370;
        }
        sub_100058DB0(&__p, "launchDemo");
        long long v152 = v190;
        if ((unint64_t)v190 >= v191)
        {
          unint64_t v154 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
          unint64_t v155 = v154 + 1;
          if (v154 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_1000D8578();
          }
          if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v155) {
            unint64_t v155 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
            unint64_t v156 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v156 = v155;
          }
          char v196 = &v191;
          if (v156) {
            uint64_t v157 = (char *)sub_10004812C((uint64_t)&v191, v156);
          }
          else {
            uint64_t v157 = 0;
          }
          long long v158 = &v157[24 * v154];
          *(void *)&long long buf = v157;
          *((void *)&buf + 1) = v158;
          uint64_t v195 = &v157[24 * v156];
          long long v159 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((void *)v158 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)long long v158 = v159;
          memset(&__p, 0, sizeof(__p));
          v194 = v158 + 24;
          sub_100048204((uint64_t *)&v189, &buf);
          __int16 v160 = v190;
          sub_100048174((uint64_t)&buf);
          v190 = v160;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
            if (!a3) {
              goto LABEL_386;
            }
          }
          else
          {
LABEL_370:
            if (!a3) {
              goto LABEL_386;
            }
          }
        }
        else
        {
          long long v153 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((void *)v190 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
          _OWORD *v152 = v153;
          v190 = (char *)v152 + 24;
          if (!a3) {
            goto LABEL_386;
          }
        }
        sub_100058DB0(&__p, "relaunch");
        CFTypeRef v161 = v190;
        if ((unint64_t)v190 >= v191)
        {
          unint64_t v163 = 0xAAAAAAAAAAAAAAABLL * ((v190 - (char *)v189) >> 3);
          unint64_t v164 = v163 + 1;
          if (v163 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_1000D8578();
          }
          if (0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3) > v164) {
            unint64_t v164 = 0x5555555555555556 * ((uint64_t)(v191 - (void)v189) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v191 - (void)v189) >> 3) >= 0x555555555555555) {
            unint64_t v165 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v165 = v164;
          }
          char v196 = &v191;
          if (v165) {
            long long v166 = (char *)sub_10004812C((uint64_t)&v191, v165);
          }
          else {
            long long v166 = 0;
          }
          unint64_t v167 = &v166[24 * v163];
          *(void *)&long long buf = v166;
          *((void *)&buf + 1) = v167;
          uint64_t v195 = &v166[24 * v165];
          long long v168 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((void *)v167 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)unint64_t v167 = v168;
          memset(&__p, 0, sizeof(__p));
          v194 = v167 + 24;
          sub_100048204((uint64_t *)&v189, &buf);
          uint64_t v169 = v190;
          sub_100048174((uint64_t)&buf);
          v190 = v169;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          long long v162 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((void *)v190 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
          *CFTypeRef v161 = v162;
          v190 = (char *)v161 + 24;
        }
LABEL_386:
        sub_100058DB0(&buf, "request");
        BOOL v10 = sub_100BF823C((uint64_t *)(a1 + 72), (uint64_t *)&buf, &v189);
        if (SHIBYTE(v194) < 0) {
          operator delete((void *)buf);
        }
LABEL_388:
        if (SHIBYTE(v173) < 0) {
          operator delete(v172[0]);
        }
        if (SHIBYTE(v176) < 0) {
          operator delete(v174);
        }
        if (SHIBYTE(v179) < 0) {
          operator delete(v177);
        }
        if (SHIBYTE(v182) < 0) {
          operator delete(v180);
        }
        if (SHIBYTE(v185) < 0) {
          operator delete(v183);
        }
        if (SHIBYTE(v188) < 0) {
          operator delete(v186);
        }
        *(void *)&long long buf = &v189;
        sub_100047F64((void ***)&buf);
        break;
      default:
        goto LABEL_197;
    }
  }
  return v10;
}

void sub_100BF8034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,char *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,char a51)
{
  sub_100048174(v51 - 144);
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a50 < 0) {
    operator delete(a45);
  }
  a45 = &a51;
  sub_100047F64((void ***)&a45);
  _Unwind_Resume(a1);
}

void sub_100BF81E0()
{
}

void sub_100BF81E8()
{
}

void sub_100BF81F0()
{
}

void sub_100BF81F8()
{
}

void sub_100BF8200()
{
}

BOOL sub_100BF823C(uint64_t *a1, uint64_t *a2, std::string **a3)
{
  sub_100BF360C();
  long long v6 = qword_101B10258;
  if (os_log_type_enabled((os_log_t)qword_101B10258, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = (uint64_t *)*a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I launchAssistantApp(%s)", buf, 0xCu);
  }
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v8 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v8 = a2[1];
  }
  if (v8)
  {
    memset(&v21, 0, sizeof(v21));
    std::operator+<char>();
    int v9 = a3[1];
    if (*a3 != v9)
    {
      sub_100062B40(*a3, v9, "&", 1uLL, &v20);
      BOOL v10 = std::string::insert(&v20, 0, "?", 1uLL);
      long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      int64_t v23 = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)long long buf = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      if (v23 >= 0) {
        uint64_t v12 = buf;
      }
      else {
        uint64_t v12 = *(uint8_t **)buf;
      }
      if (v23 >= 0) {
        std::string::size_type v13 = HIBYTE(v23);
      }
      else {
        std::string::size_type v13 = *(void *)&buf[8];
      }
      std::string::append(&v21, (const std::string::value_type *)v12, v13);
      if (SHIBYTE(v23) < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v20.__r_.__value_.__l.__data_);
      }
    }
    v20.__r_.__value_.__s.__data_[0] = 1;
    uint64_t v14 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    unint64_t v15 = dispatch_queue_create("stw.ca.ui", v14);
    uint64_t v16 = *a1;
    dispatch_object_t object = v15;
    *(void *)long long buf = off_101A47810;
    char v24 = buf;
    (*(void (**)(uint64_t, std::string *, std::string *, dispatch_object_t *, uint8_t *))(*(void *)v16 + 24))(v16, &v21, &v20, &object, buf);
    sub_100060644(buf);
    if (object) {
      dispatch_release(object);
    }
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v21.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    sub_100BF360C();
    unint64_t v17 = qword_101B10258;
    if (os_log_type_enabled((os_log_t)qword_101B10258, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "assistant app command must be specified", buf, 2u);
    }
  }
  return v8 != 0;
}

void sub_100BF84D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

BOOL stewie::StewieConnectionAssistant::presentAlertInAssistantApp(uint64_t *a1, int *a2)
{
  sub_100BF360C();
  BOOL v4 = qword_101B10258;
  if (os_log_type_enabled((os_log_t)qword_101B10258, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *a2;
    if (v5 > 2) {
      long long v6 = "???";
    }
    else {
      long long v6 = off_101A47970[v5];
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I presentAlertInAssistantApp: %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v55 = 0;
  int v56 = 0;
  unint64_t v57 = 0;
  xpc_object_t v52 = 0;
  size_t v53 = 0;
  uint64_t v54 = 0;
  sub_100058DB0(&v52, "alertKind=");
  xpc_object_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  sub_100058DB0(&v49, "requestedProviderId=");
  int v7 = *a2;
  if (!*a2)
  {
    BOOL v18 = 0;
    goto LABEL_79;
  }
  if (v7 == 1)
  {
    if (v54 >= 0) {
      size_t v13 = HIBYTE(v54);
    }
    else {
      size_t v13 = v53;
    }
    memset(&__p, 0, sizeof(__p));
    p_p = &__p;
    sub_1000C140C((uint64_t)&__p, v13 + 19);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (v13)
    {
      if (v54 >= 0) {
        unint64_t v15 = &v52;
      }
      else {
        unint64_t v15 = v52;
      }
      memmove(p_p, v15, v13);
    }
    strcpy((char *)p_p + v13, "EmergencyToRoadside");
    uint64_t v16 = v56;
    if ((unint64_t)v56 >= v57)
    {
      unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (((char *)v56 - (char *)v55) >> 3);
      unint64_t v20 = v19 + 1;
      if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_1000D8578();
      }
      if (0x5555555555555556 * ((uint64_t)(v57 - (void)v55) >> 3) > v20) {
        unint64_t v20 = 0x5555555555555556 * ((uint64_t)(v57 - (void)v55) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v55) >> 3) >= 0x555555555555555) {
        unint64_t v21 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v21 = v20;
      }
      uint64_t v62 = &v57;
      if (v21) {
        size_t v22 = (char *)sub_10004812C((uint64_t)&v57, v21);
      }
      else {
        size_t v22 = 0;
      }
      long long v27 = &v22[24 * v19];
      *(void *)&long long buf = v22;
      *((void *)&buf + 1) = v27;
      uint64_t v61 = &v22[24 * v21];
      long long v28 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((void *)v27 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)long long v27 = v28;
      memset(&__p, 0, sizeof(__p));
      char v60 = v27 + 24;
      sub_100048204((uint64_t *)&v55, &buf);
      unint64_t v29 = v56;
      sub_100048174((uint64_t)&buf);
      int v56 = v29;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      long long v17 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      v56[2] = __p.__r_.__value_.__r.__words[2];
      _OWORD *v16 = v17;
      int v56 = (std::string::size_type *)v16 + 3;
    }
    if (!*((unsigned char *)a2 + 16)) {
      goto LABEL_77;
    }
    std::to_string(&__p, *((void *)a2 + 1));
    size_t v30 = v51 >= 0 ? (const std::string::value_type *)&v49 : (const std::string::value_type *)v49;
    std::string::size_type v31 = v51 >= 0 ? HIBYTE(v51) : v50;
    char v32 = std::string::insert(&__p, 0, v30, v31);
    std::string::size_type v33 = v32->__r_.__value_.__r.__words[0];
    v58[0] = v32->__r_.__value_.__l.__size_;
    *(void *)((char *)v58 + 7) = *(std::string::size_type *)((char *)&v32->__r_.__value_.__r.__words[1] + 7);
    char v34 = HIBYTE(v32->__r_.__value_.__r.__words[2]);
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    uint64_t v35 = v56;
    if ((unint64_t)v56 >= v57)
    {
      unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * (((char *)v56 - (char *)v55) >> 3);
      unint64_t v39 = v38 + 1;
      if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_1000D8578();
      }
      if (0x5555555555555556 * ((uint64_t)(v57 - (void)v55) >> 3) > v39) {
        unint64_t v39 = 0x5555555555555556 * ((uint64_t)(v57 - (void)v55) >> 3);
      }
      unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v55) >> 3) >= 0x555555555555555
          ? 0xAAAAAAAAAAAAAAALL
          : v39;
      uint64_t v62 = &v57;
      CFIndex v41 = v40 ? (char *)sub_10004812C((uint64_t)&v57, v40) : 0;
      uint64_t v45 = &v41[24 * v38];
      *(void *)&long long buf = v41;
      *((void *)&buf + 1) = v45;
      uint64_t v61 = &v41[24 * v40];
      uint64_t v46 = v58[0];
      *(void *)uint64_t v45 = v33;
      *((void *)v45 + 1) = v46;
      *(void *)(v45 + 15) = *(void *)((char *)v58 + 7);
      v45[23] = v34;
      char v60 = v45 + 24;
      sub_100048204((uint64_t *)&v55, &buf);
      unint64_t v37 = v56;
      sub_100048174((uint64_t)&buf);
    }
    else
    {
      std::string::size_type v36 = v58[0];
      std::string::size_type *v56 = v33;
      v35[1] = v36;
      *(std::string::size_type *)((char *)v35 + 15) = *(void *)((char *)v58 + 7);
      *((unsigned char *)v35 + 23) = v34;
      unint64_t v37 = v35 + 3;
    }
    int v56 = v37;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_77;
    }
  }
  else
  {
    if (v7 != 2) {
      goto LABEL_77;
    }
    if (v54 >= 0) {
      size_t v8 = HIBYTE(v54);
    }
    else {
      size_t v8 = v53;
    }
    memset(&__p, 0, sizeof(__p));
    int v9 = &__p;
    sub_1000C140C((uint64_t)&__p, v8 + 19);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (v8)
    {
      if (v54 >= 0) {
        BOOL v10 = &v52;
      }
      else {
        BOOL v10 = v52;
      }
      memmove(v9, v10, v8);
    }
    strcpy((char *)v9 + v8, "RoadsideToEmergency");
    long long v11 = v56;
    if ((unint64_t)v56 < v57)
    {
      long long v12 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      v56[2] = __p.__r_.__value_.__r.__words[2];
      _OWORD *v11 = v12;
      int v56 = (std::string::size_type *)v11 + 3;
      goto LABEL_77;
    }
    unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((char *)v56 - (char *)v55) >> 3);
    unint64_t v24 = v23 + 1;
    if (v23 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D8578();
    }
    if (0x5555555555555556 * ((uint64_t)(v57 - (void)v55) >> 3) > v24) {
      unint64_t v24 = 0x5555555555555556 * ((uint64_t)(v57 - (void)v55) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v57 - (void)v55) >> 3) >= 0x555555555555555) {
      unint64_t v25 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v25 = v24;
    }
    uint64_t v62 = &v57;
    if (v25) {
      size_t v26 = (char *)sub_10004812C((uint64_t)&v57, v25);
    }
    else {
      size_t v26 = 0;
    }
    unint64_t v42 = &v26[24 * v23];
    *(void *)&long long buf = v26;
    *((void *)&buf + 1) = v42;
    uint64_t v61 = &v26[24 * v25];
    long long v43 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *((void *)v42 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
    *(_OWORD *)unint64_t v42 = v43;
    memset(&__p, 0, sizeof(__p));
    char v60 = v42 + 24;
    sub_100048204((uint64_t *)&v55, &buf);
    char v44 = v56;
    sub_100048174((uint64_t)&buf);
    int v56 = v44;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_77;
    }
  }
  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_77:
  sub_100058DB0(&buf, "alert");
  BOOL v18 = sub_100BF823C(a1, (uint64_t *)&buf, &v55);
  if (SHIBYTE(v60) < 0) {
    operator delete((void *)buf);
  }
LABEL_79:
  if (SHIBYTE(v51) < 0) {
    operator delete(v49);
  }
  if (SHIBYTE(v54) < 0) {
    operator delete(v52);
  }
  *(void *)&long long buf = &v55;
  sub_100047F64((void ***)&buf);
  return v18;
}

void sub_100BF8B48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  sub_100048174(v27 - 96);
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  a21 = &a27;
  sub_100047F64((void ***)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_100BF8C00(uint64_t a1, int *a2)
{
  int v4 = *a2;
  *(unsigned char *)(a1 + 4) = *((unsigned char *)a2 + 4);
  *(_DWORD *)a1 = v4;
  sub_100179CB0(a1 + 8, (__n128 *)(a2 + 2));
  long long v5 = *(_OWORD *)(a2 + 10);
  long long v6 = *(_OWORD *)(a2 + 14);
  long long v7 = *(_OWORD *)(a2 + 18);
  *(unsigned char *)(a1 + 88) = *((unsigned char *)a2 + 88);
  *(_OWORD *)(a1 + 72) = v7;
  *(_OWORD *)(a1 + 56) = v6;
  *(_OWORD *)(a1 + 40) = v5;
  return a1;
}

unint64_t sub_100BF8C64()
{
  mach_continuous_time();
  TMConvertTicksToSeconds();
  return (unint64_t)(v0 * 1000000000.0);
}

unint64_t sub_100BF8C90()
{
  mach_continuous_time();
  TMConvertTicksToSeconds();
  return (unint64_t)(v0 * 1000000000.0);
}

void sub_100BF8CBC(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v2 = *(stewie::ConnectionAssistantGPSDataSource **)(a1 + 328);
  if (v2)
  {
    *(void *)unint64_t v94 = 0;
    stewie::ConnectionAssistantGPSDataSource::currentGPSTime(v2, (unint64_t *)v94);
    if (*(void *)v94)
    {
      uint64_t v3 = *(void *)(a1 + 216);
      if (v3)
      {
        *(void *)unint64_t v81 = stewie::ConnectionAssistantGPSDataSource::location(*(stewie::ConnectionAssistantGPSDataSource **)(a1 + 328));
        *(void *)&v81[8] = v4;
        *(void *)&v81[16] = v5;
        uint64_t v6 = *(void *)(a1 + 328);
        if (*(unsigned char *)(v6 + 40)) {
          int v7 = *(_DWORD *)(v6 + 24);
        }
        else {
          int v7 = 0;
        }
        stewie::ConnectionAssistantTargetDataSource::updateGPSData(v3, (long long *)v81, v7, (unint64_t *)v94);
      }
      sub_100BF9A00(a1);
      if (*(unsigned char *)(a1 + 600) && *(unsigned char *)(a1 + 576) && *(void *)(a1 + 568) < *(void *)v94) {
        *(unsigned char *)(a1 + 576) = 0;
      }
    }
  }
  uint64_t v8 = *(void *)(a1 + 176);
  if (!v8)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 232))(a1);
    *(void *)(a1 + 176) = v8;
  }
  *(void *)(a1 + 176) = v8 + 1;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  long long v91 = 0u;
  memset(v90, 0, sizeof(v90));
  uint64_t v92 = 0;
  long long v89 = 0u;
  long long v88 = 0u;
  long long v87 = 0u;
  long long v86 = 0u;
  memset(v85, 0, sizeof(v85));
  long long v84 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v83 = 0u;
  *(void *)unint64_t v81 = *(void *)(a1 + 176);
  *(_OWORD *)&v81[8] = *(_OWORD *)(a1 + 833);
  memset(&v81[24], 0, 80);
  *(void *)&v81[22] = *(void *)(a1 + 847);
  BYTE8(v91) = 0;
  memset((char *)&v90[3] + 8, 0, 25);
  BYTE2(v92) = *(unsigned char *)(a1 + 855);
  HIDWORD(v92) = *(_DWORD *)(a1 + 856);
  uint64_t v9 = *(void *)(a1 + 216);
  if (!v9) {
    goto LABEL_66;
  }
  if (*(unsigned char *)(v9 + 184))
  {
    *(_DWORD *)&v81[32] = *(_DWORD *)(v9 + 152);
    *(float64x2_t *)&v81[40] = vdivq_f64(vmulq_f64(*(float64x2_t *)(v9 + 160), (float64x2_t)vdupq_n_s64(0x4066800000000000uLL)), (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL));
    v81[56] = 1;
  }
  if (!*(unsigned char *)(v9 + 240) || !*(void *)(v9 + 200) || !*(void *)(v9 + 208))
  {
LABEL_66:
    if (*(unsigned char *)(a1 + 600))
    {
      if (*(_DWORD *)(a1 + 528))
      {
        *(_DWORD *)&v81[64] = *(_DWORD *)(a1 + 528);
        v81[68] = 1;
      }
      uint64_t v38 = *(void *)(a1 + 816);
      if (v38) {
        LOBYTE(v38) = *(unsigned char *)(a1 + 832) != 0;
      }
      v81[72] = v38;
      if (*(unsigned char *)(a1 + 576))
      {
        uint64_t v39 = *(void *)(a1 + 328);
        if (v39)
        {
          uint64_t v40 = 315964800;
          if (*(unsigned char *)(v39 + 40))
          {
            uint64_t v41 = *(int *)(v39 + 24);
            unint64_t v42 = *(void *)(a1 + 560) / 0x3B9ACA00uLL - v41;
            uint64_t v40 = 315964800 - v41;
          }
          else
          {
            unint64_t v42 = *(void *)(a1 + 560) / 0x3B9ACA00uLL;
          }
          uint64_t v39 = 1000000 * v42 + 315964800000000;
          unint64_t v43 = 1000000 * (*(void *)(a1 + 568) / 0x3B9ACA00uLL + v40);
        }
        else
        {
          unint64_t v43 = 0;
        }
        *(void *)&long long v84 = v39;
        *((void *)&v84 + 1) = v43;
        LOBYTE(v85[0]) = 1;
      }
      if (!*(unsigned char *)(a1 + 360)) {
        goto LABEL_129;
      }
      memset(__src, 0, 48);
      if (*(unsigned char *)(a1 + 496))
      {
        char v44 = *(stewie::ConnectionAssistantGPSDataSource **)(a1 + 328);
        if (v44)
        {
          unint64_t v93 = 0;
          stewie::ConnectionAssistantGPSDataSource::currentGPSTime(v44, &v93);
          uint64_t v45 = *(void *)(a1 + 488);
          if (v45)
          {
            if (v45 + 2000000000 < v93) {
              goto LABEL_109;
            }
            __int16 v46 = 1;
            __int16 v47 = 100;
          }
          else
          {
            unint64_t v48 = *(void *)(a1 + 472);
            if (v48 && (unsigned int v49 = *(_DWORD *)(a1 + 480)) != 0)
            {
              unint64_t v50 = v93 / 0x3B9ACA00 - v48 / 0x3B9ACA00;
              if (v93 / 0x3B9ACA00 < *(void *)(a1 + 472) / 0x3B9ACA00uLL) {
                unint64_t v50 = 0;
              }
              double v51 = (double)v50 / (double)v49;
              double v52 = v51 * 100.0;
              BOOL v53 = v51 < 0.85;
              double v54 = 85.0;
              if (v53) {
                double v54 = v52;
              }
              __int16 v47 = llround(v54);
              __int16 v46 = 1;
            }
            else
            {
              __int16 v47 = 0;
              __int16 v46 = 0;
            }
          }
          sub_10012A394((const void **)v94, (const void **)(a1 + 440));
          uint64_t v55 = *(void *)(a1 + 328);
          if (v55)
          {
            uint64_t v56 = 315964800;
            if (*(unsigned char *)(v55 + 40)) {
              uint64_t v56 = 315964800 - *(int *)(v55 + 24);
            }
            unint64_t v57 = 1000000 * (v56 + *(void *)(a1 + 472) / 0x3B9ACA00uLL);
          }
          else
          {
            unint64_t v57 = 0;
          }
          *(void *)&v94[8] = v57;
          v94[16] = 1;
          int v58 = *(_DWORD *)(a1 + 480);
          if (v58)
          {
            *(_DWORD *)&v94[24] = *(_DWORD *)(a1 + 480);
            LOBYTE(v58) = 1;
          }
          else
          {
            v94[24] = 0;
          }
          v94[28] = v58;
          *(_WORD *)&v94[32] = v47 | (v46 << 8);
          int v59 = *(_DWORD *)(a1 + 448) - 1;
          if (v59 > 8) {
            int v60 = 0;
          }
          else {
            int v60 = dword_101557F80[v59];
          }
          *(_DWORD *)&v94[36] = v60;
          if (LOBYTE(__src[5])) {
            sub_10012577C(__src);
          }
          __src[0] = *(const void **)v94;
          *(void *)unint64_t v94 = 0;
          *(_OWORD *)&__src[1] = *(_OWORD *)&v94[8];
          *(_OWORD *)&__src[3] = *(_OWORD *)&v94[24];
          LOBYTE(__src[5]) = 1;
          sub_10012577C((const void **)v94);
        }
      }
    }
    else
    {
      if (!*(unsigned char *)(a1 + 360)) {
        goto LABEL_133;
      }
      memset(__src, 0, 48);
    }
LABEL_109:
    int v61 = *(_DWORD *)(a1 + 336);
    switch(v61)
    {
      case 3:
        *(_DWORD *)unint64_t v94 = 3;
        int v61 = 2;
        break;
      case 2:
        *(_DWORD *)unint64_t v94 = 2;
        break;
      case 1:
        *(_DWORD *)unint64_t v94 = 2;
        int v61 = 1;
        break;
      default:
        int v61 = 0;
        *(_DWORD *)unint64_t v94 = 1;
        break;
    }
    int v62 = *(_DWORD *)(a1 + 340);
    *(_DWORD *)&void v94[4] = v61;
    *(_DWORD *)&v94[8] = v62;
    *(_DWORD *)&v94[12] = *(_DWORD *)(a1 + 344);
    v94[16] = *(unsigned char *)(a1 + 348);
    *(_DWORD *)&v94[20] = *(_DWORD *)(a1 + 352);
    v94[24] = *(unsigned char *)(a1 + 356);
    v94[32] = 0;
    char v97 = 0;
    int v63 = LOBYTE(__src[5]);
    if (LOBYTE(__src[5]))
    {
      *(const void **)&v94[32] = __src[0];
      if (__src[0]) {
        CFRetain(__src[0]);
      }
      long long v95 = *(_OWORD *)&__src[1];
      long long v96 = *(_OWORD *)&__src[3];
      char v97 = 1;
    }
    if (BYTE8(v88) && (_BYTE)v88) {
      sub_10012577C((const void **)&v85[5]);
    }
    *(_OWORD *)&v85[1] = *(_OWORD *)v94;
    *(_OWORD *)((char *)&v85[2] + 1) = *(_OWORD *)&v94[9];
    LOBYTE(v85[5]) = 0;
    LOBYTE(v88) = 0;
    if (v63)
    {
      v85[5] = *(void *)&v94[32];
      *(void *)&v94[32] = 0;
      long long v86 = v95;
      long long v87 = v96;
      LOBYTE(v88) = 1;
      BYTE8(v88) = 1;
      sub_10012577C((const void **)&v94[32]);
    }
    else
    {
      BYTE8(v88) = 1;
    }
    if (LOBYTE(__src[5])) {
      sub_10012577C(__src);
    }
    if (!*(unsigned char *)(a1 + 600))
    {
LABEL_133:
      std::string::operator=((std::string *)((char *)&v90[2] + 8), (const std::string *)(a1 + 256));
      uint64_t v67 = *(void *)(a1 + 312);
      uint64_t v66 = *(void *)(a1 + 320);
      if (v66) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v66 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v68 = (std::__shared_weak_count *)*((void *)&v90[4] + 1);
      *(void *)&v90[4] = v67;
      *((void *)&v90[4] + 1) = v66;
      if (v68) {
        sub_10004D2C8(v68);
      }
      if (!*(unsigned char *)(a1 + 600))
      {
        if (*(unsigned char *)(a1 + 632))
        {
          uint64_t v69 = *(void *)(a1 + 616);
          __int16 v70 = *(_WORD *)(a1 + 624);
          LODWORD(v90[5]) = *(_DWORD *)(a1 + 608);
          *((void *)&v90[5] + 1) = v69;
          LOWORD(v91) = v70;
          BYTE8(v91) = 1;
        }
        if (*(unsigned char *)(a1 + 640)) {
          LOWORD(v92) = 257;
        }
      }
      uint64_t v71 = (char *)operator new(0x198uLL);
      long long v72 = *(_OWORD *)v81;
      *(_OWORD *)(v71 + 40) = *(_OWORD *)&v81[16];
      long long v73 = *(_OWORD *)&v81[48];
      *(_OWORD *)(v71 + 56) = *(_OWORD *)&v81[32];
      *(_OWORD *)(v71 + 72) = v73;
      *(_OWORD *)(v71 + 81) = *(_OWORD *)&v81[57];
      *((void *)v71 + 1) = 0;
      *((void *)v71 + 2) = 0;
      *(void *)uint64_t v71 = off_101A47890;
      *(_OWORD *)(v71 + 24) = v72;
      v71[104] = 0;
      v71[152] = 0;
      if (BYTE8(v83))
      {
        *(_OWORD *)(v71 + 104) = *(_OWORD *)&v81[80];
        v71[120] = v81[96];
        *((_OWORD *)v71 + 8) = *(_OWORD *)__p;
        *((void *)v71 + 18) = v83;
        __p[0] = 0;
        __p[1] = 0;
        *(void *)&long long v83 = 0;
        v71[152] = 1;
      }
      v71[184] = 0;
      *((_OWORD *)v71 + 10) = v84;
      *((void *)v71 + 22) = v85[0];
      v71[264] = 0;
      if (BYTE8(v88))
      {
        *(_OWORD *)(v71 + 184) = *(_OWORD *)&v85[1];
        *(_OWORD *)(v71 + 193) = *(_OWORD *)((char *)&v85[2] + 1);
        v71[216] = 0;
        v71[256] = 0;
        if ((_BYTE)v88)
        {
          *((void *)v71 + 27) = v85[5];
          v85[5] = 0;
          long long v74 = v87;
          *((_OWORD *)v71 + 14) = v86;
          *((_OWORD *)v71 + 15) = v74;
          v71[256] = 1;
        }
        v71[264] = 1;
      }
      long long v75 = v90[0];
      *((_OWORD *)v71 + 17) = v89;
      *((_OWORD *)v71 + 18) = v75;
      *((_OWORD *)v71 + 19) = v90[1];
      v71[320] = v90[2];
      *(_OWORD *)(v71 + 328) = *(_OWORD *)((char *)&v90[2] + 8);
      *((void *)v71 + 43) = *((void *)&v90[3] + 1);
      memset((char *)&v90[2] + 8, 0, 24);
      long long v76 = v91;
      *((_OWORD *)v71 + 23) = v90[5];
      *((_OWORD *)v71 + 24) = v76;
      long long v77 = v90[4];
      v90[4] = 0uLL;
      *((void *)v71 + 50) = v92;
      *((_OWORD *)v71 + 22) = v77;
      xpc_object_t v78 = *(std::__shared_weak_count **)(a1 + 192);
      *(void *)(a1 + 184) = v71 + 24;
      *(void *)(a1 + 192) = v71;
      if (v78)
      {
        sub_10004D2C8(v78);
        if (*((void *)&v90[4] + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v90[4] + 1));
        }
      }
      if (SHIBYTE(v90[3]) < 0) {
        operator delete(*((void **)&v90[2] + 1));
      }
      if (BYTE8(v88) && (_BYTE)v88) {
        sub_10012577C((const void **)&v85[5]);
      }
      if (BYTE8(v83) && __p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      sub_10003E168(v81, (void *)(a1 + 8));
      unint64_t v79 = *(std::__shared_weak_count **)&v81[8];
      if (*(void *)&v81[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v81[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v79);
      }
      uint64_t v80 = *(void *)(a1 + 192);
      if (v80) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v80 + 8), 1uLL, memory_order_relaxed);
      }
      operator new();
    }
LABEL_129:
    if (*(unsigned char *)(a1 + 392))
    {
      int v64 = *(_DWORD *)(a1 + 384);
      LODWORD(v89) = *(_DWORD *)(a1 + 380);
      DWORD1(v89) = v64;
      BYTE8(v89) = *(unsigned char *)(a1 + 388);
      BYTE12(v89) = 1;
    }
    if (*(unsigned char *)(a1 + 432))
    {
      __int16 v65 = *(_WORD *)(a1 + 400);
      *(void *)&v94[6] = *(void *)(a1 + 408);
      v94[14] = *(unsigned char *)(a1 + 416);
      *(_WORD *)((char *)__src + 7) = *(_WORD *)(a1 + 424);
      BYTE1(__src[1]) = *(unsigned char *)(a1 + 426);
      LOWORD(v90[0]) = v65;
      *(void *)((char *)v90 + 2) = *(void *)v94;
      *(void *)((char *)v90 + 9) = *(void *)&v94[7];
      *(_WORD *)((char *)&v90[1] + 9) = __src[1];
      *(const void **)((char *)&v90[1] + 1) = __src[0];
      LOBYTE(v90[2]) = 1;
    }
    goto LABEL_133;
  }
  memset(v94, 0, 24);
  unint64_t v10 = *(void *)(v9 + 224);
  if (*(unsigned char *)(v9 + 216))
  {
    if (v10)
    {
      unint64_t v11 = *(void *)(v9 + 232);
      if (v10 < v11)
      {
        uint64_t v12 = *(void *)(a1 + 328);
        if (v12)
        {
          uint64_t v13 = 315964800;
          unint64_t v14 = v10 / 0x3B9ACA00;
          if (*(unsigned char *)(v12 + 40))
          {
            uint64_t v15 = *(int *)(v12 + 24);
            v14 -= v15;
            uint64_t v13 = 315964800 - v15;
          }
          __src[0] = (const void *)(1000000 * v14 + 315964800000000);
          unint64_t v16 = 1000000 * (v13 + v11 / 0x3B9ACA00);
        }
        else
        {
          unint64_t v16 = 0;
          __src[0] = 0;
        }
LABEL_50:
        __src[1] = (const void *)v16;
        sub_100BFD208(v94, (char *)__src, (uint64_t)&__src[2], 2uLL);
        goto LABEL_51;
      }
      if (!v11)
      {
        uint64_t v22 = *(void *)(a1 + 328);
        if (v22)
        {
          uint64_t v23 = 315964800;
          if (*(unsigned char *)(v22 + 40)) {
            uint64_t v23 = 315964800 - *(int *)(v22 + 24);
          }
          unint64_t v24 = 1000000 * (v23 + v10 / 0x3B9ACA00);
        }
        else
        {
          unint64_t v24 = 0;
        }
LABEL_46:
        __src[0] = (const void *)v24;
        sub_100BFD208(v94, (char *)__src, (uint64_t)&__src[1], 1uLL);
      }
    }
  }
  else
  {
    unint64_t v17 = *(void *)(v9 + 232);
    if (v10)
    {
      if (!v17 || v17 >= v10) {
        goto LABEL_51;
      }
      uint64_t v18 = *(void *)(a1 + 328);
      if (v18)
      {
        uint64_t v19 = 315964800;
        if (*(unsigned char *)(v18 + 40))
        {
          uint64_t v20 = *(int *)(v18 + 24);
          unint64_t v21 = v17 / 0x3B9ACA00 - v20;
          uint64_t v19 = 315964800 - v20;
        }
        else
        {
          unint64_t v21 = v17 / 0x3B9ACA00;
        }
        __src[0] = (const void *)(1000000 * v21 + 315964800000000);
        unint64_t v16 = 1000000 * (v19 + v10 / 0x3B9ACA00);
      }
      else
      {
        unint64_t v16 = 0;
        __src[0] = 0;
      }
      goto LABEL_50;
    }
    if (v17)
    {
      uint64_t v25 = *(void *)(a1 + 328);
      if (v25)
      {
        uint64_t v26 = 315964800;
        if (*(unsigned char *)(v25 + 40)) {
          uint64_t v26 = 315964800 - *(int *)(v25 + 24);
        }
        unint64_t v24 = 1000000 * (v26 + *(void *)(v9 + 232) / 0x3B9ACA00uLL);
      }
      else
      {
        unint64_t v24 = 0;
      }
      goto LABEL_46;
    }
  }
LABEL_51:
  uint64_t v27 = *(void *)(a1 + 328);
  if (v27)
  {
    uint64_t v28 = 315964800;
    if (*(unsigned char *)(v27 + 40))
    {
      uint64_t v29 = *(int *)(v27 + 24);
      unint64_t v30 = *(void *)(v9 + 200) / 0x3B9ACA00uLL - v29;
      uint64_t v28 = 315964800 - v29;
    }
    else
    {
      unint64_t v30 = *(void *)(v9 + 200) / 0x3B9ACA00uLL;
    }
    uint64_t v31 = 1000000 * v30 + 315964800000000;
    unint64_t v32 = 1000000 * (*(void *)(v9 + 208) / 0x3B9ACA00uLL + v28);
  }
  else
  {
    uint64_t v31 = 0;
    unint64_t v32 = 0;
  }
  char v33 = *(unsigned char *)(v9 + 216);
  char v34 = *(void **)v94;
  int64_t v35 = *(void *)&v94[8] - *(void *)v94;
  if (*(void *)&v94[8] == *(void *)v94)
  {
    unint64_t v37 = 0;
    std::string::size_type v36 = 0;
  }
  else
  {
    if (v35 < 0) {
      sub_10006A748();
    }
    std::string::size_type v36 = (char *)operator new(*(void *)&v94[8] - *(void *)v94);
    unint64_t v37 = &v36[8 * (v35 >> 3)];
    memmove(v36, v34, v35);
  }
  if (BYTE8(v83) && __p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(void *)&v81[80] = v31;
  *(void *)&v81[88] = v32;
  v81[96] = v33;
  __p[0] = v36;
  __p[1] = v37;
  *(void *)&long long v83 = v37;
  BYTE8(v83) = 1;
  if (v34) {
    operator delete(v34);
  }
  goto LABEL_66;
}

void sub_100BF9990(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v4 = *(void **)(v2 - 240);
  if (v4) {
    operator delete(v4);
  }
  sub_100BF9EDC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100BF9A00(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v2 = *(void *)(a1 + 216);
  if (v2)
  {
    if (*(unsigned char *)(v2 + 304) && (uint64_t v3 = *(void *)(v2 + 256)) != 0 && *(void *)(v2 + 264) && *(void *)(v2 + 272))
    {
      uint64_t v4 = *(void **)(a1 + 200);
      if (!v4 || *v4 != v3)
      {
        uint64_t v5 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 134217984;
          uint64_t v45 = v3;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Service plot was changed, caching version %llu in CA", buf, 0xCu);
          uint64_t v2 = *(void *)(a1 + 216);
        }
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
        if (!*(void *)(v2 + 256) || !*(void *)(v2 + 264) || !*(void *)(v2 + 272))
        {
          uint64_t v6 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Invalid service plot was supplied to buildServicePlot_sync, proceeding anyway", buf, 2u);
          }
        }
        uint64_t v7 = *(void *)(v2 + 288) - *(void *)(v2 + 280);
        if (v7)
        {
          unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * (v7 >> 3);
          if (v8 >> 59) {
            sub_10006A748();
          }
          uint64_t v9 = (char *)sub_1000509C0(v8);
          unint64_t v10 = (unint64_t *)v9;
          uint64_t v12 = &v9[32 * v11];
          uint64_t v13 = *(void *)(v2 + 280);
          uint64_t v14 = *(void *)(v2 + 288);
          if (v13 == v14)
          {
            uint64_t v15 = (unint64_t *)v9;
          }
          else
          {
            float64x2_t v42 = (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL);
            float64x2_t v43 = (float64x2_t)vdupq_n_s64(0x4066800000000000uLL);
            uint64_t v15 = (unint64_t *)v9;
            do
            {
              uint64_t v16 = *(void *)(a1 + 328);
              if (v16)
              {
                uint64_t v17 = 315964800;
                if (*(unsigned char *)(v16 + 40)) {
                  uint64_t v17 = 315964800 - *(int *)(v16 + 24);
                }
                unint64_t v18 = 1000000 * (*(void *)v13 / 0x3B9ACA00uLL + v17);
              }
              else
              {
                unint64_t v18 = 0;
              }
              int v19 = *(_DWORD *)(v13 + 8);
              float64x2_t v20 = vdivq_f64(vmulq_f64(*(float64x2_t *)(v13 + 16), v43), v42);
              if (v15 >= (unint64_t *)v12)
              {
                float64x2_t v41 = v20;
                uint64_t v21 = ((char *)v15 - (char *)v10) >> 5;
                unint64_t v22 = v21 + 1;
                if ((unint64_t)(v21 + 1) >> 59) {
                  sub_10006A748();
                }
                if ((v12 - (char *)v10) >> 4 > v22) {
                  unint64_t v22 = (v12 - (char *)v10) >> 4;
                }
                if ((unint64_t)(v12 - (char *)v10) >= 0x7FFFFFFFFFFFFFE0) {
                  unint64_t v23 = 0x7FFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v23 = v22;
                }
                if (v23) {
                  unint64_t v23 = (unint64_t)sub_1000509C0(v23);
                }
                else {
                  uint64_t v24 = 0;
                }
                unint64_t v25 = v23 + 32 * v21;
                *(void *)unint64_t v25 = v18;
                *(_DWORD *)(v25 + 8) = v19;
                *(float64x2_t *)(v25 + 16) = v41;
                if (v15 == v10)
                {
                  uint64_t v28 = (unint64_t *)(v23 + 32 * v21);
                }
                else
                {
                  unint64_t v26 = v23 + 32 * v21;
                  do
                  {
                    long long v27 = *((_OWORD *)v15 - 1);
                    uint64_t v28 = (unint64_t *)(v26 - 32);
                    *(_OWORD *)(v26 - 32) = *((_OWORD *)v15 - 2);
                    *(_OWORD *)(v26 - 16) = v27;
                    v15 -= 4;
                    v26 -= 32;
                  }
                  while (v15 != v10);
                }
                uint64_t v12 = (char *)(v23 + 32 * v24);
                uint64_t v15 = (unint64_t *)(v25 + 32);
                if (v10) {
                  operator delete(v10);
                }
                unint64_t v10 = v28;
              }
              else
              {
                unint64_t *v15 = v18;
                *((_DWORD *)v15 + 2) = v19;
                *((float64x2_t *)v15 + 1) = v20;
                v15 += 4;
              }
              v13 += 40;
            }
            while (v13 != v14);
          }
        }
        else
        {
          unint64_t v10 = 0;
          uint64_t v15 = 0;
          uint64_t v12 = 0;
        }
        uint64_t v32 = *(void *)(a1 + 328);
        if (v32)
        {
          if (*(unsigned char *)(v32 + 40))
          {
            uint64_t v33 = *(int *)(v32 + 24);
            unint64_t v34 = *(void *)(v2 + 264) / 0x3B9ACA00uLL - v33;
            uint64_t v35 = 315964800 - v33;
          }
          else
          {
            unint64_t v34 = *(void *)(v2 + 264) / 0x3B9ACA00uLL;
            uint64_t v35 = 315964800;
          }
          uint64_t v36 = 1000000 * v34 + 315964800000000;
          unint64_t v37 = 1000000 * (*(void *)(v2 + 272) / 0x3B9ACA00uLL + v35);
        }
        else
        {
          uint64_t v36 = 0;
          unint64_t v37 = 0;
        }
        uint64_t v38 = *(void *)(v2 + 256);
        uint64_t v39 = operator new(0x48uLL);
        v39[1] = 0;
        v39[2] = 0;
        *uint64_t v39 = off_101A478E0;
        v39[3] = v38;
        v39[4] = v36;
        v39[5] = v37;
        v39[6] = v10;
        v39[7] = v15;
        v39[8] = v12;
        uint64_t v40 = *(std::__shared_weak_count **)(a1 + 208);
        *(void *)(a1 + 200) = v39 + 3;
        *(void *)(a1 + 208) = v39;
        if (v40) {
          sub_10004D2C8(v40);
        }
      }
    }
    else if (*(void *)(a1 + 200))
    {
      uint64_t v29 = *(std::__shared_weak_count **)(a1 + 208);
      *(void *)(a1 + 200) = 0;
      *(void *)(a1 + 208) = 0;
      if (v29) {
        sub_10004D2C8(v29);
      }
      unint64_t v30 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Service plot was reset, resetting CA cached service plot too", buf, 2u);
      }
    }
  }
  else
  {
    uint64_t v31 = *(std::__shared_weak_count **)(a1 + 208);
    *(void *)(a1 + 200) = 0;
    *(void *)(a1 + 208) = 0;
    if (v31)
    {
      sub_10004D2C8(v31);
    }
  }
}

void sub_100BF9EB4(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BF9EDC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 336);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 327) < 0) {
    operator delete(*(void **)(a1 + 304));
  }
  if (*(unsigned char *)(a1 + 240) && *(unsigned char *)(a1 + 232)) {
    sub_10012577C((const void **)(a1 + 192));
  }
  if (*(unsigned char *)(a1 + 128))
  {
    uint64_t v3 = *(void **)(a1 + 104);
    if (v3)
    {
      *(void *)(a1 + 112) = v3;
      operator delete(v3);
    }
  }
  return a1;
}

__n128 sub_100BF9F4C(const void **a1, uint64_t a2)
{
  if (*((unsigned char *)a1 + 56))
  {
    a1 = sub_10012577C(a1);
    *((unsigned char *)a1 + 56) = 0;
  }
  uint64_t v3 = sub_10012A394(a1, (const void **)a2);
  __n128 result = *(__n128 *)(a2 + 8);
  v3[3] = *(const void **)(a2 + 24);
  *(__n128 *)(v3 + 1) = result;
  v3[4] = *(const void **)(a2 + 32);
  *((_DWORD *)v3 + 10) = *(_DWORD *)(a2 + 40);
  v3[6] = *(const void **)(a2 + 48);
  *((unsigned char *)v3 + 56) = 1;
  return result;
}

void sub_100BF9FB4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BFA094(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v3 = (os_log_t *)(a1 + 40);
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ***********************************", buf, 2u);
    uint64_t v2 = *v3;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * StewieConnectionAssistant state *", buf, 2u);
    uint64_t v2 = *v3;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ***********************************", buf, 2u);
  }
  uint64_t v4 = *(int **)(v1 + 104);
  if (v4)
  {
    int v5 = *((unsigned __int8 *)v4 + 16);
    uint64_t v6 = *v3;
    BOOL v7 = os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (!v7) {
        goto LABEL_14;
      }
      int v8 = *v4;
      int v9 = v4[1];
      int v10 = v4[2];
      int v11 = v4[3];
      *(_DWORD *)long long buf = 67109888;
      *(_DWORD *)&uint8_t buf[4] = v8;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v9;
      LOWORD(v284) = 1024;
      *(_DWORD *)((char *)&v284 + 2) = v10;
      HIWORD(v284) = 1024;
      *(_DWORD *)v285 = v11;
      uint64_t v12 = "#I [d] (CAConfig) Model vector: [x: %d|%d, y: %d|%d]";
      uint64_t v13 = v6;
      uint32_t v14 = 26;
    }
    else
    {
      if (!v7) {
        goto LABEL_14;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v12 = "#I [d] (CAConfig) Model vector is not defined";
      uint64_t v13 = v6;
      uint32_t v14 = 2;
    }
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
  }
LABEL_14:
  uint64_t v15 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    double v16 = *(double *)(v1 + 240) * 180.0 / 3.14159265;
    *(_DWORD *)long long buf = 134217984;
    *(double *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] Service threshold: %.2f", buf, 0xCu);
    uint64_t v15 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    double v17 = *(double *)(v1 + 248) * 180.0 / 3.14159265;
    *(_DWORD *)long long buf = 134217984;
    *(double *)&uint8_t buf[4] = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] Anchor service threshold: %.2f", buf, 0xCu);
    uint64_t v15 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v18 = (void *)(v1 + 256);
    if (*(char *)(v1 + 279) < 0) {
      unint64_t v18 = (void *)*v18;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v18;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] iso3166Alpha3CountryCode: %{public}s", buf, 0xCu);
    uint64_t v15 = *v3;
  }
  int v19 = *(void **)(v1 + 280);
  BOOL v20 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
  if (!v19)
  {
    if (!v20) {
      goto LABEL_39;
    }
    *(_WORD *)long long buf = 0;
    unint64_t v30 = "#I [d] TargetGen2ToGen1Mapping not set";
    goto LABEL_38;
  }
  if (v20)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] TargetGen2ToGen1Mapping: [", buf, 2u);
    int v19 = *(void **)(v1 + 280);
  }
  unint64_t v23 = (void *)*v19;
  uint64_t v21 = v19 + 1;
  unint64_t v22 = v23;
  if (v23 != v21)
  {
    do
    {
      uint64_t v24 = *v3;
      if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = *((_DWORD *)v22 + 7);
        int v26 = *((_DWORD *)v22 + 8);
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v25;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v26;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I [d] TargetGen2ToGen1Mapping     %d -> %d", buf, 0xEu);
      }
      long long v27 = (void *)v22[1];
      if (v27)
      {
        do
        {
          uint64_t v28 = v27;
          long long v27 = (void *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          uint64_t v28 = (void *)v22[2];
          BOOL v29 = *v28 == (void)v22;
          unint64_t v22 = v28;
        }
        while (!v29);
      }
      unint64_t v22 = v28;
    }
    while (v28 != v21);
  }
  uint64_t v15 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    unint64_t v30 = "#I [d] TargetGen2ToGen1Mapping ]";
LABEL_38:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v30, buf, 2u);
  }
LABEL_39:
  uint64_t v31 = *(void *)(v1 + 296);
  if (v31)
  {
    (*(void (**)(uint64_t))(*(void *)v31 + 24))(v31);
  }
  else
  {
    uint64_t v32 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I [d] AnchorStorage not set", buf, 2u);
    }
  }
  int v33 = *(unsigned __int8 *)(v1 + 600);
  unint64_t v34 = *(NSObject **)(v1 + 40);
  BOOL v35 = os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT);
  uint64_t v36 = &byte_10144BF80[128];
  if (!v33)
  {
    if (!v35) {
      goto LABEL_174;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v39 = "#I [d] State: On is not set";
    goto LABEL_173;
  }
  if (v35)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I [d] State: On", buf, 2u);
    unint64_t v34 = *v3;
  }
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = *(int *)(v1 + 376);
    if (v37 > 0xA) {
      uint64_t v38 = "???";
    }
    else {
      uint64_t v38 = off_101A47988[v37];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v38;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I [d] lastRequestReason: %s", buf, 0xCu);
    unint64_t v34 = *v3;
  }
  int v40 = *(unsigned __int8 *)(v1 + 392);
  BOOL v41 = os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT);
  if (!v40)
  {
    if (!v41) {
      goto LABEL_73;
    }
    *(_WORD *)long long buf = 0;
    char v44 = "#I [d] (Conversation) Conversation not set";
    uint64_t v45 = v34;
    uint32_t v46 = 2;
    goto LABEL_72;
  }
  if (v41)
  {
    uint64_t v42 = *(int *)(v1 + 380);
    if (v42 > 4) {
      float64x2_t v43 = "???";
    }
    else {
      float64x2_t v43 = off_101A47AB0[v42];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v43;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I [d] (Conversation) requestReason: %s", buf, 0xCu);
    unint64_t v34 = *v3;
  }
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    int v47 = *(unsigned __int8 *)(v1 + 384);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v47;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I [d] (Conversation) conversationID: %hhu", buf, 8u);
    unint64_t v34 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v48 = "true";
    if (!*(unsigned char *)(v1 + 385)) {
      unint64_t v48 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v48;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I [d] (Conversation) committed: %s", buf, 0xCu);
    unint64_t v34 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 388)) {
      unsigned int v49 = sub_100BC87FC(*(unsigned __int16 *)(v1 + 386));
    }
    else {
      unsigned int v49 = "<none>";
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v49;
    char v44 = "#I [d] (Conversation) fromService: %{public}s";
    uint64_t v45 = v34;
    uint32_t v46 = 12;
LABEL_72:
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, v44, buf, v46);
  }
LABEL_73:
  int v50 = *(unsigned __int8 *)(v1 + 432);
  double v51 = *(NSObject **)(v1 + 40);
  BOOL v52 = os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT);
  if (!v50)
  {
    if (!v52) {
      goto LABEL_93;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v55 = "#I [d] (RoadsideConversation) roadsideConversationState not set";
    uint64_t v56 = v51;
    uint32_t v57 = 2;
    goto LABEL_92;
  }
  if (v52)
  {
    int v53 = *(unsigned __int8 *)(v1 + 400);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v53;
    _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I [d] (RoadsideConversation) conversationID: %hhu", buf, 8u);
    double v51 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 416))
    {
      std::to_string((std::string *)buf, *(void *)(v1 + 408));
      if (v285[1] >= 0) {
        double v54 = buf;
      }
      else {
        double v54 = *(unsigned char **)buf;
      }
      LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v54;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I [d] (RoadsideConversation) providerId: %{public}s", (uint8_t *)&v282, 0xCu);
      if ((v285[1] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)"<none>";
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I [d] (RoadsideConversation) providerId: %{public}s", (uint8_t *)&v282, 0xCu);
    }
    double v51 = *v3;
  }
  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 426)) {
      int v58 = sub_100BC87FC(*(unsigned __int16 *)(v1 + 424));
    }
    else {
      int v58 = "<none>";
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v58;
    uint64_t v55 = "#I [d] (RoadsideConversation) fromService: %{public}s";
    uint64_t v56 = v51;
    uint32_t v57 = 12;
LABEL_92:
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, v55, buf, v57);
  }
LABEL_93:
  int v59 = *(unsigned __int8 *)(v1 + 496);
  int v60 = *(NSObject **)(v1 + 40);
  BOOL v61 = os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT);
  if (!v59)
  {
    if (!v61) {
      goto LABEL_129;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v66 = "#I [d] (Transmission) Progress not set";
    uint64_t v67 = v60;
    uint32_t v68 = 2;
    goto LABEL_128;
  }
  if (v61)
  {
    stewie::dumpToString((CFUUIDRef *)(v1 + 440), (uint64_t)buf);
    if (v285[1] >= 0) {
      int v62 = buf;
    }
    else {
      int v62 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136380675;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v62;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I [d] (Transmission) (Message) MessageID: %{private}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    int v60 = *v3;
  }
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    std::to_string((std::string *)buf, *(_DWORD *)(v1 + 448));
    if (v285[1] >= 0) {
      int v63 = buf;
    }
    else {
      int v63 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v63;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I [d] (Transmission) (Message) MessageType: %{public}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    int v60 = *v3;
  }
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v64 = *(char *)(v1 + 452);
    if (v64 > 2) {
      __int16 v65 = "???";
    }
    else {
      __int16 v65 = off_101A479E0[v64];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v65;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I [d] (Transmission) (Message) TransportType: %s", buf, 0xCu);
    int v60 = *v3;
  }
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v69 = *(int *)(v1 + 456);
    if (v69 > 3) {
      __int16 v70 = "???";
    }
    else {
      __int16 v70 = off_101A479F8[v69];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v70;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I [d] (Transmission) (Message) StatusType: %s", buf, 0xCu);
    int v60 = *v3;
  }
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v71 = *(void *)(v1 + 464);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v71;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I [d] (Transmission) (Message) MessageSizeInBytes: %zu", buf, 0xCu);
    int v60 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v72 = *(void *)(v1 + 472) / 0x3B9ACA00uLL;
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v72;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I [d] (Transmission) sentAt (GPS time, seconds): %llu", buf, 0xCu);
    int v60 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    int v73 = *(_DWORD *)(v1 + 480);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v73;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I [d] (Transmission) estimatedTimeToSendSeconds: %u", buf, 8u);
    int v60 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v74 = *(void *)(v1 + 488) / 0x3B9ACA00uLL;
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v74;
    uint64_t v66 = "#I [d] (Transmission) deliveredAt (GPS time, seconds): %llu";
    uint64_t v67 = v60;
    uint32_t v68 = 12;
LABEL_128:
    _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, v66, buf, v68);
  }
LABEL_129:
  int v75 = *(unsigned __int8 *)(v1 + 520);
  long long v76 = *(NSObject **)(v1 + 40);
  BOOL v77 = os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT);
  if (!v75)
  {
    if (!v77) {
      goto LABEL_145;
    }
    *(_WORD *)long long buf = 0;
    CFAllocatorRef v82 = "#I [d] (DeviceOrientationData) deviceOrientationData not set";
    long long v83 = v76;
    uint32_t v84 = 2;
    goto LABEL_144;
  }
  if (v77)
  {
    uint64_t v78 = *(void *)(v1 + 504);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v78;
    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I [d] (DeviceOrientationData) fTimeStamp: %llu", buf, 0xCu);
    long long v76 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v79 = "true";
    if (!*(unsigned char *)(v1 + 512)) {
      unint64_t v79 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v79;
    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I [d] (DeviceOrientationData) fTargetLocked: %s", buf, 0xCu);
    long long v76 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v80 = "true";
    if (!*(unsigned char *)(v1 + 513)) {
      uint64_t v80 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v80;
    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I [d] (DeviceOrientationData) fIsDeviceStationary: %s", buf, 0xCu);
    long long v76 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
  {
    int v81 = *(_DWORD *)(v1 + 516);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v81;
    CFAllocatorRef v82 = "#I [d] (DeviceOrientationData) fX: %d";
    long long v83 = v76;
    uint32_t v84 = 8;
LABEL_144:
    _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, v82, buf, v84);
  }
LABEL_145:
  size_t v85 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v86 = *(int *)(v1 + 528);
    if (v86 > 3) {
      long long v87 = "???";
    }
    else {
      long long v87 = off_101A47A18[v86];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v87;
    _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I [d] visibilityLevel: %s", buf, 0xCu);
    size_t v85 = *v3;
  }
  int v88 = *(unsigned __int8 *)(v1 + 552);
  BOOL v89 = os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT);
  if (!v88)
  {
    if (!v89) {
      goto LABEL_158;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v92 = "#I [d] (VisibilityTicks) visibilityTicks not set";
    unint64_t v93 = v85;
    uint32_t v94 = 2;
    goto LABEL_157;
  }
  if (v89)
  {
    uint64_t v90 = *(void *)(v1 + 544);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v90;
    _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I [d] (VisibilityTicks) numTicksElapsedWaitingForSync: %llu", buf, 0xCu);
    size_t v85 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v91 = *(void *)(v1 + 536);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v91;
    uint64_t v92 = "#I [d] (VisibilityTicks) numTicksElapsedWaitingToResetVisibility: %llu";
    unint64_t v93 = v85;
    uint32_t v94 = 12;
LABEL_157:
    _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, v92, buf, v94);
  }
LABEL_158:
  int v95 = *(unsigned __int8 *)(v1 + 576);
  long long v96 = *(NSObject **)(v1 + 40);
  BOOL v97 = os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT);
  if (!v95)
  {
    if (!v97) {
      goto LABEL_166;
    }
    *(_WORD *)long long buf = 0;
    std::string::size_type v100 = "#I [d] (TxDeferInterval) txDeferInterval not set";
    char v101 = v96;
    uint32_t v102 = 2;
    goto LABEL_165;
  }
  if (v97)
  {
    unint64_t v98 = *(void *)(v1 + 560) / 0x3B9ACA00uLL;
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v98;
    _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "#I [d] (TxDeferInterval) startsAt (GPS time, seconds): %llu", buf, 0xCu);
    long long v96 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v99 = *(void *)(v1 + 568) / 0x3B9ACA00uLL;
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v99;
    std::string::size_type v100 = "#I [d] (TxDeferInterval) endsAt (GPS time, seconds): %llu";
    char v101 = v96;
    uint32_t v102 = 12;
LABEL_165:
    _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, v100, buf, v102);
  }
LABEL_166:
  uint64_t v103 = *(void *)(v1 + 584);
  unint64_t v34 = *(NSObject **)(v1 + 40);
  BOOL v104 = os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT);
  if (!v103)
  {
    if (!v104) {
      goto LABEL_174;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v39 = "#I [d] (TargetServiceSchedule) targetServiceSchedule not set";
    goto LABEL_173;
  }
  if (v104)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I [d] (TargetServiceSchedule) targetServiceSchedule {", buf, 2u);
  }
  (*(void (**)(uint64_t, os_log_t *))(*(void *)v103 + 24))(v103, v3);
  unint64_t v34 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v39 = "#I [d] (TargetServiceSchedule) }";
LABEL_173:
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v39, buf, 2u);
  }
LABEL_174:
  int v105 = *(unsigned __int8 *)(v1 + 632);
  unint64_t v106 = *(NSObject **)(v1 + 40);
  BOOL v107 = os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT);
  if (v105)
  {
    if (v107)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "#I [d] State: Off", buf, 2u);
      unint64_t v106 = *v3;
    }
    if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
    {
      CFMutableDictionaryRef v108 = sub_100BC8B90(*(_DWORD *)(v1 + 608));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v108;
      _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "#I [d] (Off) exitReason: %s", buf, 0xCu);
      unint64_t v106 = *(NSObject **)(v1 + 40);
    }
    if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
    {
      int v109 = *(unsigned __int16 *)(v1 + 624);
      sub_100BC897C(*(unsigned __int16 *)(v1 + 624), (std::string *)buf);
      uint64_t v110 = v285[1] >= 0 ? buf : *(unsigned char **)buf;
      LODWORD(v282.__r_.__value_.__l.__data_) = 67109378;
      HIDWORD(v282.__r_.__value_.__r.__words[0]) = v109;
      LOWORD(v282.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v282.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v110;
      _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "#I [d] (Off) wasActiveservices: { [Mask: %u] %s }", (uint8_t *)&v282, 0x12u);
      if ((v285[1] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  else if (v107)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "#I [d] State: Off is not set", buf, 2u);
  }
  xpc_object_t v111 = *(NSObject **)(v1 + 40);
  if (*(unsigned char *)(v1 + 640) && os_log_type_enabled(*(os_log_t *)(v1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I [d] State: TryOut mode offer pending", buf, 2u);
    xpc_object_t v111 = *v3;
  }
  if (*(unsigned char *)(v1 + 656) && os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I [d] State: Assistant app is on", buf, 2u);
    xpc_object_t v111 = *v3;
  }
  if (*(unsigned char *)(v1 + 688))
  {
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I [d] State: Assistant app is off", buf, 2u);
      xpc_object_t v111 = *v3;
    }
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      int v112 = *(_DWORD *)(v1 + 680);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v112;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I [d] (Assistant App Off) fReopenRequestsSent: %u", buf, 8u);
      xpc_object_t v111 = *(NSObject **)(v1 + 40);
    }
  }
  int v113 = *(unsigned __int8 *)(v1 + 360);
  BOOL v114 = os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT);
  if (v113)
  {
    if (v114)
    {
      uint64_t v115 = *(int *)(v1 + 336);
      if (v115 > 3) {
        char v116 = "???";
      }
      else {
        char v116 = off_101A47B30[v115];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v116;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I [d] (Connection) connectionStatus: %s", buf, 0xCu);
      xpc_object_t v111 = *v3;
    }
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v117 = *(int *)(v1 + 340);
      if (v117 > 2) {
        uint64_t v118 = "???";
      }
      else {
        uint64_t v118 = off_101A47B50[v117];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v118;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I [d] (Connection) registrationStatus: %s", buf, 0xCu);
      xpc_object_t v111 = *v3;
    }
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(v1 + 348))
      {
        uint64_t v119 = *(int *)(v1 + 344);
        if (v119 > 5) {
          unint64_t v120 = "???";
        }
        else {
          unint64_t v120 = off_101A47B68[v119];
        }
      }
      else
      {
        unint64_t v120 = "<none>";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v120;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I [d] (Connection) congestionStatus: %s", buf, 0xCu);
      xpc_object_t v111 = *v3;
    }
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(v1 + 356)) {
        std::to_string((std::string *)buf, *(_DWORD *)(v1 + 352));
      }
      else {
        sub_100058DB0(buf, "<none>");
      }
      unint64_t v121 = buf;
      if (v285[1] < 0) {
        unint64_t v121 = *(unsigned char **)buf;
      }
      LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v121;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I [d] (Connection) rssi: %{public}s", (uint8_t *)&v282, 0xCu);
      if ((v285[1] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  else if (v114)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I [d] (Connection) Connection not set", buf, 2u);
  }
  unint64_t v122 = *(uint64_t **)(v1 + 184);
  CFTypeRef v123 = *(NSObject **)(v1 + 40);
  BOOL v124 = os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT);
  if (!v122)
  {
    if (!v124) {
      goto LABEL_420;
    }
    *(_WORD *)long long buf = 0;
    unint64_t v134 = "#I [d] (CAState) CAState not set";
    goto LABEL_418;
  }
  if (v124)
  {
    uint64_t v125 = *v122;
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v125;
    _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) Version: %llu", buf, 0xCu);
    unint64_t v122 = *(uint64_t **)(v1 + 184);
    CFTypeRef v123 = *(NSObject **)(v1 + 40);
  }
  int v126 = *((unsigned __int8 *)v122 + 56);
  BOOL v127 = os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT);
  if (!v126)
  {
    if (!v127) {
      goto LABEL_241;
    }
    *(_WORD *)long long buf = 0;
    char v131 = "#I [d] (CAState) (Target) Target not set";
    uint64_t v132 = v123;
    uint32_t v133 = 2;
    goto LABEL_240;
  }
  if (v127)
  {
    int v128 = *((_DWORD *)v122 + 8);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v128;
    _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Target) ID: %u", buf, 8u);
    CFTypeRef v123 = *v3;
  }
  if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v129 = v122[5];
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v129;
    _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Target) X: %.1f", buf, 0xCu);
    CFTypeRef v123 = *v3;
  }
  if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v130 = v122[6];
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v130;
    char v131 = "#I [d] (CAState) (Target) Y: %.1f";
    uint64_t v132 = v123;
    uint32_t v133 = 12;
LABEL_240:
    _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, v131, buf, v133);
  }
LABEL_241:
  uint64_t v135 = *(void *)(v1 + 184);
  int v136 = *(unsigned __int8 *)(v135 + 68);
  uint64_t v137 = *(NSObject **)(v1 + 40);
  BOOL v138 = os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT);
  if (v136)
  {
    if (!v138) {
      goto LABEL_250;
    }
    uint64_t v139 = *(int *)(v135 + 64);
    if (v139 > 3) {
      size_t v140 = "???";
    }
    else {
      size_t v140 = off_101A47A18[v139];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v140;
    CFStringRef v141 = "#I [d] (CAState) (Visibility) aggregateVisibility: %s";
    CFStringRef v142 = v137;
    uint32_t v143 = 12;
  }
  else
  {
    if (!v138) {
      goto LABEL_250;
    }
    *(_WORD *)long long buf = 0;
    CFStringRef v141 = "#I [d] (CAState) (Visibility) Visibility not set";
    CFStringRef v142 = v137;
    uint32_t v143 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_DEFAULT, v141, buf, v143);
LABEL_250:
  uint64_t v144 = *(void *)(v1 + 184);
  int v145 = *(unsigned __int8 *)(v144 + 128);
  unint64_t v146 = *(NSObject **)(v1 + 40);
  BOOL v147 = os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT);
  if (!v145)
  {
    if (!v147) {
      goto LABEL_286;
    }
    *(_WORD *)long long buf = 0;
    unint64_t v156 = "#I [d] (CAState) (ServiceIntervals) ServiceIntervals not set";
    goto LABEL_285;
  }
  if (v147)
  {
    std::to_string((std::string *)buf, *(void *)(v144 + 80));
    if (v285[1] >= 0) {
      long long v148 = buf;
    }
    else {
      long long v148 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v148;
    _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (ServiceIntervals) startsAt: %{public}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    unint64_t v146 = *v3;
  }
  if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
  {
    std::to_string((std::string *)buf, *(void *)(v144 + 88));
    if (v285[1] >= 0) {
      long long v149 = buf;
    }
    else {
      long long v149 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v149;
    _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (ServiceIntervals) endsAt: %{public}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    unint64_t v146 = *v3;
  }
  if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v144 + 96)) {
      long long v150 = "true";
    }
    else {
      long long v150 = "false";
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v150;
    _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (ServiceIntervals) atStart: %{public}s", buf, 0xCu);
  }
  long long v151 = *(uint64_t **)(v144 + 104);
  long long v152 = *(uint64_t **)(v144 + 112);
  if (v151 != v152)
  {
    long long v153 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (ServiceIntervals) changesAt: [", buf, 2u);
      long long v151 = *(uint64_t **)(v144 + 104);
      long long v152 = *(uint64_t **)(v144 + 112);
    }
    for (; v151 != v152; ++v151)
    {
      unint64_t v154 = *v3;
      if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
      {
        std::to_string((std::string *)buf, *v151);
        unint64_t v155 = v285[1] >= 0 ? buf : *(unsigned char **)buf;
        LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v155;
        _os_log_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (ServiceIntervals)     %{public}s", (uint8_t *)&v282, 0xCu);
        if ((v285[1] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
    }
    unint64_t v146 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      unint64_t v156 = "#I [d] (CAState) (ServiceIntervals) ]";
LABEL_285:
      _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, v156, buf, 2u);
    }
  }
LABEL_286:
  uint64_t v157 = *(void *)(v1 + 184);
  int v158 = *(unsigned __int8 *)(v157 + 240);
  long long v159 = *(NSObject **)(v1 + 40);
  BOOL v160 = os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT);
  if (!v158)
  {
    if (!v160) {
      goto LABEL_360;
    }
    *(_WORD *)long long buf = 0;
    unint64_t v163 = "#I [d] (CAState) (Connection) connectionState not set";
LABEL_333:
    uint64_t v174 = v159;
    uint32_t v175 = 2;
LABEL_359:
    _os_log_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_DEFAULT, v163, buf, v175);
    goto LABEL_360;
  }
  if (v160)
  {
    uint64_t v161 = *(int *)(v157 + 160);
    if (v161 > 3) {
      long long v162 = "???";
    }
    else {
      long long v162 = off_101A47A38[v161];
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v162;
    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Connection) connectionStatus: %{public}s", buf, 0xCu);
    long long v159 = *v3;
  }
  if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v164 = *(int *)(v157 + 164);
    if (v164 > 2) {
      unint64_t v165 = "???";
    }
    else {
      unint64_t v165 = off_101A47A58[v164];
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v165;
    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Connection) syncStatus: %{public}s", buf, 0xCu);
    long long v159 = *v3;
  }
  if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v166 = *(int *)(v157 + 168);
    if (v166 > 2) {
      unint64_t v167 = "???";
    }
    else {
      unint64_t v167 = off_101A47B50[v166];
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v167;
    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Connection) registrationStatus: %{public}s", buf, 0xCu);
    long long v159 = *v3;
  }
  if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v157 + 176))
    {
      uint64_t v168 = *(int *)(v157 + 172);
      if (v168 > 5) {
        uint64_t v169 = "???";
      }
      else {
        uint64_t v169 = off_101A47B68[v168];
      }
    }
    else
    {
      uint64_t v169 = "<none>";
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v169;
    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Connection) congestionStatus: %{public}s", buf, 0xCu);
    long long v159 = *v3;
  }
  if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v157 + 184)) {
      std::to_string((std::string *)buf, *(_DWORD *)(v157 + 180));
    }
    else {
      sub_100058DB0(buf, "<none>");
    }
    uint64_t v170 = buf;
    if (v285[1] < 0) {
      uint64_t v170 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v170;
    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Connection) rssi: %{public}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    long long v159 = *v3;
  }
  int v171 = *(unsigned __int8 *)(v157 + 232);
  BOOL v172 = os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT);
  if (!v171)
  {
    if (!v172) {
      goto LABEL_360;
    }
    *(_WORD *)long long buf = 0;
    unint64_t v163 = "#I [d] (CAState) (Connection) (TransmissionProgress) TransmissionProgress not set";
    goto LABEL_333;
  }
  if (v172)
  {
    stewie::dumpToString((CFUUIDRef *)(v157 + 192), (uint64_t)buf);
    if (v285[1] >= 0) {
      uint64_t v173 = buf;
    }
    else {
      uint64_t v173 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v173;
    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Connection) (TransmissionProgress) messageId: %{public}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    long long v159 = *v3;
  }
  if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v157 + 208)) {
      std::to_string((std::string *)buf, *(void *)(v157 + 200));
    }
    else {
      sub_100058DB0(buf, "<none>");
    }
    uint64_t v176 = buf;
    if (v285[1] < 0) {
      uint64_t v176 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v176;
    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Connection) (TransmissionProgress) startedAt: %{public}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    long long v159 = *v3;
  }
  if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BFCEE8(v157 + 216, (std::string *)buf);
    if (v285[1] >= 0) {
      uint64_t v177 = buf;
    }
    else {
      uint64_t v177 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v177;
    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Connection) (TransmissionProgress) estimatedDurationSeconds: %{public}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    long long v159 = *v3;
  }
  if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
  {
    sub_10026CCB8((unsigned __int8 *)(v157 + 224), (std::string *)buf);
    if (v285[1] >= 0) {
      std::string::size_type v178 = buf;
    }
    else {
      std::string::size_type v178 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v178;
    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Connection) (TransmissionProgress) progressPercents: %{public}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    long long v159 = *v3;
  }
  if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v179 = *(int *)(v157 + 228);
    if (v179 > 7) {
      int v180 = "???";
    }
    else {
      int v180 = off_101A47A70[v179];
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v180;
    unint64_t v163 = "#I [d] (CAState) (Connection) (TransmissionProgress) payloadType: %{public}s";
    uint64_t v174 = v159;
    uint32_t v175 = 12;
    goto LABEL_359;
  }
LABEL_360:
  uint64_t v181 = *(void *)(v1 + 184);
  int v182 = *(unsigned __int8 *)(v181 + 260);
  int v183 = *(NSObject **)(v1 + 40);
  BOOL v184 = os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT);
  if (!v182)
  {
    if (!v184) {
      goto LABEL_381;
    }
    *(_WORD *)long long buf = 0;
    size_t v187 = "#I [d] (CAState) (Conversation) conversationState not set";
    uint64_t v188 = v183;
    uint32_t v189 = 2;
    goto LABEL_380;
  }
  if (v184)
  {
    uint64_t v185 = *(int *)(v181 + 248);
    if (v185 > 4) {
      uint64_t v186 = "???";
    }
    else {
      uint64_t v186 = off_101A47AB0[v185];
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v186;
    _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Conversation) requestReason: %{public}s", buf, 0xCu);
    int v183 = *v3;
  }
  if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
  {
    int v190 = *(unsigned __int8 *)(v181 + 252);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v190;
    _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Conversation) conversationId: %hhu", buf, 8u);
    int v183 = *v3;
  }
  if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v181 + 253)) {
      unint64_t v191 = "true";
    }
    else {
      unint64_t v191 = "false";
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v191;
    _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (Conversation) committed: %{public}s", buf, 0xCu);
    int v183 = *v3;
  }
  if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v181 + 256)) {
      uint64_t v192 = sub_100BC87FC(*(unsigned __int16 *)(v181 + 254));
    }
    else {
      uint64_t v192 = "<none>";
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v192;
    size_t v187 = "#I [d] (CAState) (Conversation) fromService: %{public}s";
    uint64_t v188 = v183;
    uint32_t v189 = 12;
LABEL_380:
    _os_log_impl((void *)&_mh_execute_header, v188, OS_LOG_TYPE_DEFAULT, v187, buf, v189);
  }
LABEL_381:
  uint64_t v193 = *(void *)(v1 + 184);
  int v194 = *(unsigned __int8 *)(v193 + 296);
  uint64_t v195 = *(NSObject **)(v1 + 40);
  BOOL v196 = os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT);
  if (v194)
  {
    if (v196)
    {
      int v197 = *(unsigned __int8 *)(v193 + 264);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v197;
      _os_log_impl((void *)&_mh_execute_header, v195, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (RoadsideConversation) conversationId: %hhu", buf, 8u);
      uint64_t v195 = *v3;
    }
    if (os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT))
    {
      sub_10026B270(v193 + 272, (std::string *)buf);
      if (v285[1] >= 0) {
        uint64_t v198 = buf;
      }
      else {
        uint64_t v198 = *(unsigned char **)buf;
      }
      LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v198;
      _os_log_impl((void *)&_mh_execute_header, v195, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (RoadsideConversation) providerId: %{public}s", (uint8_t *)&v282, 0xCu);
      if ((v285[1] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v195 = *v3;
    }
    if (!os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_399;
    }
    if (*(unsigned char *)(v193 + 290)) {
      uint64_t v199 = sub_100BC87FC(*(unsigned __int16 *)(v193 + 288));
    }
    else {
      uint64_t v199 = "<none>";
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v199;
    uint64_t v200 = "#I [d] (CAState) (RoadsideConversation) fromService: %{public}s";
    v201 = v195;
    uint32_t v202 = 12;
    goto LABEL_398;
  }
  if (v196)
  {
    *(_WORD *)long long buf = 0;
    uint64_t v200 = "#I [d] (CAState) (RoadsideConversation) roadsideConversationState not set";
    v201 = v195;
    uint32_t v202 = 2;
LABEL_398:
    _os_log_impl((void *)&_mh_execute_header, v201, OS_LOG_TYPE_DEFAULT, v200, buf, v202);
  }
LABEL_399:
  uint64_t v203 = *(void *)(v1 + 184);
  int v204 = *(unsigned __int8 *)(v203 + 368);
  int v205 = *(NSObject **)(v1 + 40);
  BOOL v206 = os_log_type_enabled(v205, OS_LOG_TYPE_DEFAULT);
  if (v204)
  {
    if (v206)
    {
      int v207 = sub_100BC8B90(*(_DWORD *)(v203 + 344));
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v207;
      _os_log_impl((void *)&_mh_execute_header, v205, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (ConnectionClosed) exitReason: %{public}s", buf, 0xCu);
      int v205 = *v3;
    }
    if (os_log_type_enabled(v205, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v208 = *(unsigned __int16 *)(v203 + 360);
      sub_100BC897C(v208, (std::string *)buf);
      uint64_t v209 = v285[1] >= 0 ? buf : *(unsigned char **)buf;
      LODWORD(v282.__r_.__value_.__l.__data_) = 67109378;
      HIDWORD(v282.__r_.__value_.__r.__words[0]) = v208;
      LOWORD(v282.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v282.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v209;
      _os_log_impl((void *)&_mh_execute_header, v205, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (ConnectionClosed) wasActiveservices: { [Mask: %u] %s }", (uint8_t *)&v282, 0x12u);
      if ((v285[1] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  else if (v206)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v205, OS_LOG_TYPE_DEFAULT, "#I [d] (CAState) (ConnectionClosed) connectionClosedState not set", buf, 2u);
  }
  uint64_t v210 = *(void *)(v1 + 184);
  int v211 = *(unsigned __int8 *)(v210 + 377);
  CFTypeRef v123 = *(NSObject **)(v1 + 40);
  BOOL v212 = os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT);
  uint64_t v36 = &byte_10144BF80[128];
  if (v211)
  {
    if (!v212) {
      goto LABEL_420;
    }
    if (*(unsigned char *)(v210 + 376)) {
      int32x2_t v213 = "true";
    }
    else {
      int32x2_t v213 = "false";
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v213;
    unint64_t v134 = "#I [d] (CAState) (TryOut) tryOutOfferPending: %{public}s";
    uint64_t v214 = v123;
    uint32_t v215 = 12;
    goto LABEL_419;
  }
  if (!v212) {
    goto LABEL_420;
  }
  *(_WORD *)long long buf = 0;
  unint64_t v134 = "#I [d] (CAState) (TryOut) tryOutState not set";
LABEL_418:
  uint64_t v214 = v123;
  uint32_t v215 = 2;
LABEL_419:
  _os_log_impl((void *)&_mh_execute_header, v214, OS_LOG_TYPE_DEFAULT, v134, buf, v215);
LABEL_420:
  v216 = *(void **)(v1 + 200);
  uint64_t v217 = *(NSObject **)(v1 + 40);
  BOOL v218 = os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT);
  if (!v216)
  {
    if (!v218) {
      goto LABEL_457;
    }
    *(_WORD *)long long buf = 0;
    __int16 v235 = "#I [d] (CAServicePlot) ServicePlot not set";
    uint64_t v236 = v217;
    uint32_t v237 = 2;
    goto LABEL_456;
  }
  if (v218)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_DEFAULT, "#I [d] (CAServicePlot) ServicePlot is valid, all times are GPS times", buf, 2u);
    uint64_t v217 = *v3;
  }
  if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v219 = *v216;
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v219;
    _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_DEFAULT, "#I [d] (CAServicePlot) version: %llu", buf, 0xCu);
    uint64_t v217 = *v3;
  }
  v280 = v216;
  if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
  {
    std::to_string((std::string *)buf, v216[1]);
    if (v285[1] >= 0) {
      uint64_t v220 = buf;
    }
    else {
      uint64_t v220 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v220;
    _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_DEFAULT, "#I [d] (CAServicePlot) startsAt: %{public}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v217 = *v3;
  }
  if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
  {
    std::to_string((std::string *)buf, v216[2]);
    if (v285[1] >= 0) {
      char v221 = buf;
    }
    else {
      char v221 = *(unsigned char **)buf;
    }
    LODWORD(v282.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v282.__r_.__value_.__r.__words + 4) = (std::string::size_type)v221;
    _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_DEFAULT, "#I [d] (CAServicePlot) endsAt: %{public}s", (uint8_t *)&v282, 0xCu);
    if ((v285[1] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v217 = *v3;
  }
  if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_DEFAULT, "#I [d] (CAServicePlot) readings [", buf, 2u);
  }
  uint64_t v222 = v216[3];
  for (uint64_t i = v216[4]; v222 != i; v222 += 32)
  {
    uint64_t v224 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      std::to_string(&v282, *(void *)v222);
      uint64_t v225 = v1;
      uint64_t v226 = v3;
      int v227 = SHIBYTE(v282.__r_.__value_.__r.__words[2]);
      std::string::size_type v228 = v282.__r_.__value_.__r.__words[0];
      std::to_string(&v281, *(_DWORD *)(v222 + 8));
      uint64_t v229 = &v282;
      if (v227 < 0) {
        uint64_t v229 = (std::string *)v228;
      }
      uint64_t v230 = &v281;
      if ((v281.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v230 = (std::string *)v281.__r_.__value_.__r.__words[0];
      }
      double v231 = *(double *)(v222 + 16) * 180.0 / 3.14159265;
      double v232 = *(double *)(v222 + 24) * 180.0;
      *(_DWORD *)long long buf = 136446979;
      *(void *)&uint8_t buf[4] = v229;
      *(_WORD *)&unsigned char buf[12] = 2082;
      v284 = v230;
      *(_WORD *)v285 = 2049;
      *(double *)&v285[2] = v231;
      __int16 v286 = 2049;
      double v287 = v232 / 3.14159265;
      _os_log_impl((void *)&_mh_execute_header, v224, OS_LOG_TYPE_DEFAULT, "#I [d] (CAServicePlot) readings - at: %{public}s, targetID: %{public}s, heading: %{private}.2f, service: %{private}.2f", buf, 0x2Au);
      if (SHIBYTE(v281.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v281.__r_.__value_.__l.__data_);
      }
      uint64_t v3 = v226;
      uint64_t v1 = v225;
      if (SHIBYTE(v282.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v282.__r_.__value_.__l.__data_);
      }
    }
  }
  os_log_t v233 = *v3;
  uint64_t v36 = byte_10144BF80 + 128;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v234 = (uint64_t)(v280[4] - v280[3]) >> 5;
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v234;
    __int16 v235 = "#I [d] (CAServicePlot) readings ] %zu readings";
    uint64_t v236 = v233;
    uint32_t v237 = 12;
LABEL_456:
    _os_log_impl((void *)&_mh_execute_header, v236, OS_LOG_TYPE_DEFAULT, v235, buf, v237);
  }
LABEL_457:
  int v238 = *(unsigned __int8 *)(v1 + 736);
  __int16 v239 = *(NSObject **)(v1 + 40);
  BOOL v240 = os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT);
  if (!v238)
  {
    if (!v240) {
      goto LABEL_476;
    }
    *(_WORD *)long long buf = 0;
    CFDictionaryRef v245 = "#I [d] Offer not set";
    v246 = v239;
    uint32_t v247 = 2;
    goto LABEL_475;
  }
  if (v240)
  {
    __int16 v241 = "true";
    if (!*(unsigned char *)(v1 + 712)) {
      __int16 v241 = "false";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v241;
    _os_log_impl((void *)&_mh_execute_header, v239, OS_LOG_TYPE_DEFAULT, "#I [d] Offer requested: %s", buf, 0xCu);
    __int16 v239 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v242 = *(AutoStartTimer **)(v1 + 696);
    if (v242)
    {
      int isExpired = AutoStartTimer::isExpired(v242);
      uint64_t v244 = "running";
      if (isExpired) {
        uint64_t v244 = "expired";
      }
    }
    else
    {
      uint64_t v244 = "off";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v244;
    _os_log_impl((void *)&_mh_execute_header, v239, OS_LOG_TYPE_DEFAULT, "#I [d] Offer tracker: %s", buf, 0xCu);
    __int16 v239 = *v3;
  }
  if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
  {
    v248 = "true";
    if (!*(void *)(v1 + 720)) {
      v248 = "false";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v248;
    CFDictionaryRef v245 = "#I [d] Offer is presented: %s";
    v246 = v239;
    uint32_t v247 = 12;
LABEL_475:
    _os_log_impl((void *)&_mh_execute_header, v246, OS_LOG_TYPE_DEFAULT, v245, buf, v247);
  }
LABEL_476:
  CFDictionaryRef v249 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    int64x2_t v250 = *(AutoStartTimer **)(v1 + 744);
    if (v250)
    {
      int v251 = AutoStartTimer::isExpired(v250);
      int v252 = "running";
      if (v251) {
        int v252 = "expired";
      }
    }
    else
    {
      int v252 = "off";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v252;
    _os_log_impl((void *)&_mh_execute_header, v249, OS_LOG_TYPE_DEFAULT, "#I [d] Declined offer tracker: %s", buf, 0xCu);
    CFDictionaryRef v249 = *v3;
  }
  if (os_log_type_enabled(v249, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v253 = *(void *)(v1 + 776);
    CFDictionaryRef v254 = *(std::string **)(v1 + 784);
    *(_DWORD *)long long buf = 134218240;
    *(void *)&uint8_t buf[4] = v253;
    *(_WORD *)&unsigned char buf[12] = 2048;
    v284 = v254;
    _os_log_impl((void *)&_mh_execute_header, v249, OS_LOG_TYPE_DEFAULT, "#I [d] Offer since last metric report: presented - %llu, accepted - %llu", buf, 0x16u);
    CFDictionaryRef v249 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v249, OS_LOG_TYPE_DEFAULT))
  {
    v255 = "true";
    if (!*(void *)(v1 + 760)) {
      v255 = "false";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v255;
    _os_log_impl((void *)&_mh_execute_header, v249, OS_LOG_TYPE_DEFAULT, "#I [d] Instant offer is presented: %s", buf, 0xCu);
    CFDictionaryRef v249 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v249, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v256 = *(void *)(v1 + 792);
    CFArrayRef v257 = *(std::string **)(v1 + 800);
    *(_DWORD *)long long buf = 134218240;
    *(void *)&uint8_t buf[4] = v256;
    *(_WORD *)&unsigned char buf[12] = 2048;
    v284 = v257;
    _os_log_impl((void *)&_mh_execute_header, v249, OS_LOG_TYPE_DEFAULT, "#I [d] Instant offer since last metric report: presented - %llu, accepted - %llu", buf, 0x16u);
    CFDictionaryRef v249 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v249, OS_LOG_TYPE_DEFAULT))
  {
    v258 = "true";
    if (!*(unsigned char *)(v1 + 808)) {
      v258 = "false";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v258;
    _os_log_impl((void *)&_mh_execute_header, v249, OS_LOG_TYPE_DEFAULT, "#I [d] Messaging was used at least once this time off grid: %s", buf, 0xCu);
    CFDictionaryRef v249 = *(NSObject **)(v1 + 40);
  }
  int v259 = *(unsigned __int8 *)(v1 + 810);
  BOOL v260 = os_log_type_enabled(v249, OS_LOG_TYPE_DEFAULT);
  if (v259)
  {
    if (!v260) {
      goto LABEL_503;
    }
    v261 = "on";
    if (!*(unsigned char *)(v1 + 809)) {
      v261 = "off";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v261;
    v262 = "#I [d] OffTheGrid mode: %s";
    v263 = v249;
    uint32_t v264 = 12;
  }
  else
  {
    if (!v260) {
      goto LABEL_503;
    }
    *(_WORD *)long long buf = 0;
    v262 = "#I [d] OffTheGrid mode: not fetched yet";
    v263 = v249;
    uint32_t v264 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v263, OS_LOG_TYPE_DEFAULT, v262, buf, v264);
LABEL_503:
  v265 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 811)) {
      v266 = "yes";
    }
    else {
      v266 = "no";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v266;
    _os_log_impl((void *)&_mh_execute_header, v265, OS_LOG_TYPE_DEFAULT, "#I [d] Display is active: %s", buf, 0xCu);
    v265 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 812)) {
      v267 = "yes";
    }
    else {
      v267 = "no";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v267;
    _os_log_impl((void *)&_mh_execute_header, v265, OS_LOG_TYPE_DEFAULT, "#I [d] Coversheet is active: %s", buf, 0xCu);
    v265 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 814))
    {
      if (*(unsigned char *)(v1 + 813)) {
        v268 = "true";
      }
      else {
        v268 = "false";
      }
    }
    else
    {
      v268 = "<none>";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v268;
    _os_log_impl((void *)&_mh_execute_header, v265, OS_LOG_TYPE_DEFAULT, "#I [d] GPS Satellites are visible: %s", buf, 0xCu);
    v265 = *v3;
  }
  if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
  {
    v269 = *(AutoStartTimer **)(v1 + 816);
    if (v269)
    {
      int v270 = AutoStartTimer::isExpired(v269);
      v271 = "running";
      if (v270) {
        v271 = "expired";
      }
    }
    else
    {
      v271 = "off";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v271;
    _os_log_impl((void *)&_mh_execute_header, v265, OS_LOG_TYPE_DEFAULT, "#I [d] GPS acquisition tracker: %s", buf, 0xCu);
    v265 = *v3;
  }
  if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
  {
    v272 = "true";
    if (!*(unsigned char *)(v1 + 832)) {
      v272 = "false";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v272;
    _os_log_impl((void *)&_mh_execute_header, v265, OS_LOG_TYPE_DEFAULT, "#I [d] Surface GPS acquisition status to user: %s", buf, 0xCu);
    v265 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
  {
    v273 = "true";
    if (!*(unsigned char *)(v1 + 855)) {
      v273 = "false";
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v273;
    _os_log_impl((void *)&_mh_execute_header, v265, OS_LOG_TYPE_DEFAULT, "#I [d] Is emergency voice call capable: %s", buf, 0xCu);
    v265 = *(NSObject **)(v1 + 40);
  }
  if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v274 = *(int *)(v1 + 856);
    if (v274 > 2) {
      v275 = "???";
    }
    else {
      v275 = off_101A47AD8[v274];
    }
    *(_DWORD *)long long buf = *((void *)v36 + 232);
    *(void *)&uint8_t buf[4] = v275;
    _os_log_impl((void *)&_mh_execute_header, v265, OS_LOG_TYPE_DEFAULT, "#I [d] Stewie internet interface: %s", buf, 0xCu);
  }
  v276 = *(stewie::ConnectionAssistantTargetDataSource **)(v1 + 216);
  if (v276)
  {
    stewie::ConnectionAssistantTargetDataSource::handleDumpState(v276);
  }
  else
  {
    v277 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v277, OS_LOG_TYPE_DEFAULT, "#I [d] TargetDataSource not set", buf, 2u);
    }
  }
  v278 = *(stewie::ConnectionAssistantGPSDataSource **)(v1 + 328);
  if (v278)
  {
    stewie::ConnectionAssistantGPSDataSource::handleDumpState(v278);
  }
  else
  {
    v279 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v279, OS_LOG_TYPE_DEFAULT, "#I [d] GPSDataSource not set", buf, 2u);
    }
  }
}

void sub_100BFCEC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_100BFCEE8@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 4)) {
    return std::to_string(a2, *(_DWORD *)a1);
  }
  else {
    return (std::string *)sub_100058DB0(a2, "<none>");
  }
}

void sub_100BFCF08(void *a1, void **a2, uint64_t a3)
{
  int v5 = *a2;
  object[0] = a1;
  object[1] = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    object[1] = xpc_null_create();
  }
  sub_100C03EB8((uint64_t)&v8, a3);
  uint64_t v6 = (std::__shared_weak_count *)a1[2];
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100BFD070(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100BFD098(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A47438;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BFD0B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A47438;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100BFD114(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned __int8 *)(a1 + 40) == *((unsigned __int8 *)a2 + 40))
  {
    if (*(unsigned char *)(a1 + 40))
    {
      uint64_t v5 = *a2;
      uint64_t v4 = a2[1];
      if (v4) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v6 = *(std::__shared_weak_count **)(a1 + 8);
      *(void *)a1 = v5;
      *(void *)(a1 + 8) = v4;
      if (v6) {
        sub_10004D2C8(v6);
      }
      *(unsigned char *)(a1 + 16) = *((unsigned char *)a2 + 16);
      uint64_t v8 = a2[3];
      uint64_t v7 = a2[4];
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      int v9 = *(std::__shared_weak_count **)(a1 + 32);
      *(void *)(a1 + 24) = v8;
      *(void *)(a1 + 32) = v7;
      if (v9)
      {
        sub_10004D2C8(v9);
      }
    }
  }
  else if (*(unsigned char *)(a1 + 40))
  {
    sub_100BF5240((void *)a1);
    *(unsigned char *)(a1 + 40) = 0;
  }
  else
  {
    uint64_t v10 = a2[1];
    *(void *)a1 = *a2;
    *(void *)(a1 + 8) = v10;
    if (v10) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    }
    *(unsigned char *)(a1 + 16) = *((unsigned char *)a2 + 16);
    uint64_t v11 = a2[4];
    *(void *)(a1 + 24) = a2[3];
    *(void *)(a1 + 32) = v11;
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
    *(unsigned char *)(a1 + 40) = 1;
  }
}

char *sub_100BFD208(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  int v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = sub_100BFD304(v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    int v9 = v13;
LABEL_15:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      int v19 = __src;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  uint64_t v12 = (void **)(result + 8);
  uint32_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_15;
  }
  double v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    int v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    int v19 = v16;
LABEL_17:
    __n128 result = (char *)memmove(v18, v19, v17);
  }
LABEL_18:
  const char *v12 = &v9[v17];
  return result;
}

char *sub_100BFD304(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_10006A748();
  }
  __n128 result = (char *)operator new(8 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * a2];
  return result;
}

void *sub_100BFD348(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = result;
    if (a4 >> 60) {
      sub_10006A748();
    }
    __n128 result = sub_10006A794((uint64_t)(result + 2), a4);
    uint64_t v7 = result;
    void *v4 = result;
    v4[1] = result;
    void v4[2] = &result[2 * v8];
    size_t v9 = a3 - (void)a2;
    if (v9) {
      __n128 result = memmove(result, a2, v9);
    }
    v4[1] = (char *)v7 + v9;
  }
  return result;
}

void sub_100BFD3CC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t *sub_100BFD3E8(unint64_t *result, unint64_t *a2, uint64_t a3, char a4)
{
  size_t v9 = result;
LABEL_2:
  uint64_t v10 = v9;
  unint64_t v11 = v9 + 2;
  uint64_t v12 = v9 + 4;
  while (1)
  {
    uint64_t v13 = (char *)a2 - (char *)v10;
    unint64_t v14 = ((char *)a2 - (char *)v10) >> 4;
    if (v5 || !v4)
    {
      switch(v14)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v41 = *(a2 - 2);
          unint64_t v42 = *v10;
          if (v41 < *v10)
          {
            unint64_t v43 = v10[1];
            *uint64_t v10 = v41;
            v10[1] = *(a2 - 1);
            *(a2 - 2) = v42;
            *(a2 - 1) = v43;
          }
          break;
        case 3uLL:
          __n128 result = sub_100BFDADC(v10, v10 + 2, a2 - 2);
          break;
        case 4uLL:
          __n128 result = sub_100BFDD18(v10, v10 + 2, v10 + 4, a2 - 2);
          break;
        case 5uLL:
          __n128 result = sub_100BFDDBC(v10, v10 + 2, v10 + 4, v10 + 6, a2 - 2);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v13 <= 383) {
      break;
    }
    if (!a3)
    {
      if (v10 != a2)
      {
        int64_t v57 = (v14 - 2) >> 1;
        int64_t v58 = v57;
        do
        {
          int64_t v59 = v58;
          if (v57 >= v58)
          {
            uint64_t v60 = (2 * v58) | 1;
            BOOL v61 = &v10[2 * v60];
            if (2 * v59 + 2 < (uint64_t)v14)
            {
              unint64_t v64 = *v61;
              unint64_t v62 = v61[2];
              BOOL v63 = *v61 >= v62;
              if (*v61 <= v62) {
                unint64_t v64 = v61[2];
              }
              if (*v61 < v62) {
                v61 += 2;
              }
              if (!v63) {
                uint64_t v60 = 2 * v59 + 2;
              }
            }
            else
            {
              unint64_t v64 = *v61;
            }
            __n128 result = &v10[2 * v59];
            unint64_t v65 = *result;
            if (v64 >= *result)
            {
              unint64_t v66 = v10[2 * v59 + 1];
              do
              {
                uint64_t v67 = v61;
                *__n128 result = v64;
                result[1] = v61[1];
                if (v57 < v60) {
                  break;
                }
                uint64_t v68 = (2 * v60) | 1;
                BOOL v61 = &v10[2 * v68];
                uint64_t v60 = 2 * v60 + 2;
                if (v60 < (uint64_t)v14)
                {
                  unint64_t v64 = *v61;
                  unint64_t v69 = v61[2];
                  BOOL v70 = *v61 >= v69;
                  if (*v61 <= v69) {
                    unint64_t v64 = v61[2];
                  }
                  if (*v61 < v69) {
                    v61 += 2;
                  }
                  if (v70) {
                    uint64_t v60 = v68;
                  }
                }
                else
                {
                  unint64_t v64 = *v61;
                  uint64_t v60 = v68;
                }
                __n128 result = v67;
              }
              while (v64 >= v65);
              *uint64_t v67 = v65;
              v67[1] = v66;
            }
          }
          int64_t v58 = v59 - 1;
        }
        while (v59);
        uint64_t v71 = (unint64_t)v13 >> 4;
        do
        {
          if (v71 >= 2)
          {
            uint64_t v72 = 0;
            unint64_t v73 = *v10;
            unint64_t v74 = v10[1];
            int v75 = v10;
            do
            {
              long long v76 = &v75[2 * v72 + 2];
              uint64_t v77 = (2 * v72) | 1;
              uint64_t v72 = 2 * v72 + 2;
              if (v72 >= v71)
              {
                unint64_t v78 = *v76;
                uint64_t v72 = v77;
              }
              else
              {
                unint64_t v78 = *v76;
                __n128 result = (unint64_t *)v76[2];
                if (*v76 <= (unint64_t)result) {
                  unint64_t v78 = v76[2];
                }
                if (*v76 >= (unint64_t)result) {
                  uint64_t v72 = v77;
                }
                else {
                  v76 += 2;
                }
              }
              unint64_t *v75 = v78;
              v75[1] = v76[1];
              int v75 = v76;
            }
            while (v72 <= (uint64_t)((unint64_t)(v71 - 2) >> 1));
            if (v76 == a2 - 2)
            {
              *long long v76 = v73;
              v76[1] = v74;
            }
            else
            {
              *long long v76 = *(a2 - 2);
              v76[1] = *(a2 - 1);
              *(a2 - 2) = v73;
              *(a2 - 1) = v74;
              uint64_t v79 = (char *)v76 - (char *)v10 + 16;
              if (v79 >= 17)
              {
                unint64_t v80 = (((unint64_t)v79 >> 4) - 2) >> 1;
                int v81 = &v10[2 * v80];
                unint64_t v82 = *v81;
                unint64_t v83 = *v76;
                if (*v81 < *v76)
                {
                  unint64_t v84 = v76[1];
                  do
                  {
                    size_t v85 = v81;
                    *long long v76 = v82;
                    v76[1] = v81[1];
                    if (!v80) {
                      break;
                    }
                    unint64_t v80 = (v80 - 1) >> 1;
                    int v81 = &v10[2 * v80];
                    unint64_t v82 = *v81;
                    long long v76 = v85;
                  }
                  while (*v81 < v83);
                  *size_t v85 = v83;
                  v85[1] = v84;
                }
              }
            }
          }
          a2 -= 2;
        }
        while ((unint64_t)v71-- > 2);
      }
      return result;
    }
    unint64_t v15 = &v10[2 * (v14 >> 1)];
    if ((unint64_t)v13 >= 0x801)
    {
      sub_100BFDADC(v10, &v10[2 * (v14 >> 1)], a2 - 2);
      sub_100BFDADC(v11, v15 - 2, a2 - 4);
      sub_100BFDADC(v12, v15 + 2, a2 - 6);
      __n128 result = sub_100BFDADC(v15 - 2, v15, v15 + 2);
      long long v16 = *(_OWORD *)v10;
      *(_OWORD *)uint64_t v10 = *(_OWORD *)v15;
      *(_OWORD *)unint64_t v15 = v16;
    }
    else
    {
      __n128 result = sub_100BFDADC(&v10[2 * (v14 >> 1)], v10, a2 - 2);
    }
    --a3;
    unint64_t v17 = *v10;
    if ((a4 & 1) == 0 && *(v10 - 2) >= v17)
    {
      if (v17 >= *(a2 - 2))
      {
        uint64_t v32 = v10 + 2;
        do
        {
          size_t v9 = v32;
          if (v32 >= a2) {
            break;
          }
          v32 += 2;
        }
        while (v17 >= *v9);
      }
      else
      {
        size_t v9 = v10;
        do
        {
          unint64_t v31 = v9[2];
          v9 += 2;
        }
        while (v17 >= v31);
      }
      int v33 = a2;
      if (v9 < a2)
      {
        int v33 = a2;
        do
        {
          unint64_t v34 = *(v33 - 2);
          v33 -= 2;
        }
        while (v17 < v34);
      }
      unint64_t v35 = v10[1];
      if (v9 < v33)
      {
        unint64_t v36 = *v9;
        unint64_t v37 = *v33;
        do
        {
          unint64_t v38 = v9[1];
          *size_t v9 = v37;
          v9[1] = v33[1];
          unint64_t *v33 = v36;
          v33[1] = v38;
          do
          {
            unint64_t v39 = v9[2];
            v9 += 2;
            unint64_t v36 = v39;
          }
          while (v17 >= v39);
          do
          {
            unint64_t v40 = *(v33 - 2);
            v33 -= 2;
            unint64_t v37 = v40;
          }
          while (v17 < v40);
        }
        while (v9 < v33);
      }
      BOOL v4 = v9 - 2 >= v10;
      BOOL v5 = v9 - 2 == v10;
      if (v9 - 2 != v10)
      {
        *uint64_t v10 = *(v9 - 2);
        v10[1] = *(v9 - 1);
      }
      a4 = 0;
      *(v9 - 2) = v17;
      *(v9 - 1) = v35;
      goto LABEL_2;
    }
    uint64_t v18 = 0;
    unint64_t v19 = v10[1];
    do
    {
      unint64_t v20 = v10[v18 + 2];
      v18 += 2;
    }
    while (v20 < v17);
    uint64_t v21 = &v10[v18];
    unint64_t v22 = a2;
    if (v18 == 2)
    {
      unint64_t v22 = a2;
      do
      {
        if (v21 >= v22) {
          break;
        }
        unint64_t v24 = *(v22 - 2);
        v22 -= 2;
      }
      while (v24 >= v17);
    }
    else
    {
      do
      {
        unint64_t v23 = *(v22 - 2);
        v22 -= 2;
      }
      while (v23 >= v17);
    }
    if (v21 >= v22)
    {
      size_t v9 = &v10[v18];
    }
    else
    {
      unint64_t v25 = *v22;
      size_t v9 = &v10[v18];
      int v26 = v22;
      do
      {
        unint64_t v27 = v9[1];
        *size_t v9 = v25;
        v9[1] = v26[1];
        unint64_t *v26 = v20;
        v26[1] = v27;
        do
        {
          unint64_t v28 = v9[2];
          v9 += 2;
          unint64_t v20 = v28;
        }
        while (v28 < v17);
        do
        {
          unint64_t v29 = *(v26 - 2);
          v26 -= 2;
          unint64_t v25 = v29;
        }
        while (v29 >= v17);
      }
      while (v9 < v26);
    }
    if (v9 - 2 != v10)
    {
      *uint64_t v10 = *(v9 - 2);
      v10[1] = *(v9 - 1);
    }
    *(v9 - 2) = v17;
    *(v9 - 1) = v19;
    if (v21 < v22) {
      goto LABEL_35;
    }
    BOOL v30 = sub_100BFDB80(v10, v9 - 2);
    __n128 result = (unint64_t *)sub_100BFDB80(v9, a2);
    if (!result)
    {
      if (v30) {
        goto LABEL_2;
      }
LABEL_35:
      __n128 result = (unint64_t *)sub_100BFD3E8(v10, v9 - 2, a3, a4 & 1);
      a4 = 0;
      goto LABEL_2;
    }
    a2 = v9 - 2;
    if (v30) {
      return result;
    }
  }
  char v44 = v10 + 2;
  BOOL v46 = v10 == a2 || v44 == a2;
  if (a4)
  {
    if (!v46)
    {
      uint64_t v47 = 0;
      unint64_t v48 = v10;
      do
      {
        unsigned int v49 = v44;
        unint64_t v50 = v48[2];
        unint64_t v51 = *v48;
        if (v50 < *v48)
        {
          unint64_t v52 = v48[3];
          uint64_t v53 = v47;
          while (1)
          {
            double v54 = (char *)v10 + v53;
            uint64_t v55 = *(unint64_t *)((char *)v10 + v53 + 8);
            *((void *)v54 + 2) = v51;
            *((void *)v54 + 3) = v55;
            if (!v53) {
              break;
            }
            unint64_t v51 = *((void *)v54 - 2);
            v53 -= 16;
            if (v50 >= v51)
            {
              uint64_t v56 = (unint64_t *)((char *)v10 + v53 + 16);
              goto LABEL_82;
            }
          }
          uint64_t v56 = v10;
LABEL_82:
          unint64_t *v56 = v50;
          v56[1] = v52;
        }
        char v44 = v49 + 2;
        v47 += 16;
        unint64_t v48 = v49;
      }
      while (v49 + 2 != a2);
    }
  }
  else if (!v46)
  {
    long long v87 = v10 + 3;
    do
    {
      int v88 = v44;
      unint64_t v89 = v10[2];
      unint64_t v90 = *v10;
      if (v89 < *v10)
      {
        unint64_t v91 = v10[3];
        uint64_t v92 = v87;
        do
        {
          unint64_t v93 = v92;
          *(v92 - 1) = v90;
          unint64_t v94 = *(v92 - 2);
          v92 -= 2;
          *unint64_t v93 = v94;
          unint64_t v90 = *(v93 - 5);
        }
        while (v89 < v90);
        *(v92 - 1) = v89;
        *uint64_t v92 = v91;
      }
      char v44 = v88 + 2;
      v87 += 2;
      uint64_t v10 = v88;
    }
    while (v88 + 2 != a2);
  }
  return result;
}

unint64_t *sub_100BFDADC(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *result;
  unint64_t v5 = *a3;
  if (*a2 >= *result)
  {
    if (v5 < v3)
    {
      unint64_t v7 = a2[1];
      *a2 = v5;
      a2[1] = a3[1];
      *a3 = v3;
      a3[1] = v7;
      unint64_t v8 = *result;
      if (*a2 < *result)
      {
        unint64_t v9 = result[1];
        *__n128 result = *a2;
        result[1] = a2[1];
        *a2 = v8;
        a2[1] = v9;
      }
    }
  }
  else
  {
    unint64_t v6 = result[1];
    if (v5 >= v3)
    {
      *__n128 result = v3;
      result[1] = a2[1];
      *a2 = v4;
      a2[1] = v6;
      if (*a3 >= v4) {
        return result;
      }
      *a2 = *a3;
      a2[1] = a3[1];
    }
    else
    {
      *__n128 result = v5;
      result[1] = a3[1];
    }
    *a3 = v4;
    a3[1] = v6;
  }
  return result;
}

BOOL sub_100BFDB80(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *(a2 - 2);
      unint64_t v7 = *a1;
      if (v6 < *a1)
      {
        unint64_t v8 = a1[1];
        *a1 = v6;
        a1[1] = *(a2 - 1);
        *(a2 - 2) = v7;
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      sub_100BFDADC(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      sub_100BFDD18(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      sub_100BFDDBC(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      unint64_t v9 = a1 + 4;
      sub_100BFDADC(a1, a1 + 2, a1 + 4);
      uint64_t v10 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    unint64_t v13 = *v10;
    unint64_t v14 = *v9;
    if (*v10 < *v9)
    {
      unint64_t v15 = v10[1];
      uint64_t v16 = v11;
      while (1)
      {
        unint64_t v17 = (unint64_t *)((char *)a1 + v16);
        uint64_t v18 = *(unint64_t *)((char *)a1 + v16 + 40);
        v17[6] = v14;
        v17[7] = v18;
        if (v16 == -32) {
          break;
        }
        unint64_t v14 = v17[2];
        v16 -= 16;
        if (v13 >= v14)
        {
          unint64_t v19 = (unint64_t *)((char *)a1 + v16 + 48);
          goto LABEL_12;
        }
      }
      unint64_t v19 = a1;
LABEL_12:
      unint64_t *v19 = v13;
      v19[1] = v15;
      if (++v12 == 8) {
        return v10 + 2 == a2;
      }
    }
    unint64_t v9 = v10;
    v11 += 16;
    v10 += 2;
    if (v10 == a2) {
      return 1;
    }
  }
}

unint64_t *sub_100BFDD18(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  BOOL result = sub_100BFDADC(a1, a2, a3);
  unint64_t v9 = *a3;
  if (*a4 < *a3)
  {
    unint64_t v10 = a3[1];
    *a3 = *a4;
    a3[1] = a4[1];
    *a4 = v9;
    a4[1] = v10;
    unint64_t v11 = *a2;
    if (*a3 < *a2)
    {
      unint64_t v12 = a2[1];
      *a2 = *a3;
      a2[1] = a3[1];
      *a3 = v11;
      a3[1] = v12;
      unint64_t v13 = *a1;
      if (*a2 < *a1)
      {
        unint64_t v14 = a1[1];
        *a1 = *a2;
        a1[1] = a2[1];
        *a2 = v13;
        a2[1] = v14;
      }
    }
  }
  return result;
}

unint64_t *sub_100BFDDBC(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  BOOL result = sub_100BFDD18(a1, a2, a3, a4);
  unint64_t v11 = *a4;
  if (*a5 < *a4)
  {
    unint64_t v12 = a4[1];
    *a4 = *a5;
    a4[1] = a5[1];
    *a5 = v11;
    a5[1] = v12;
    unint64_t v13 = *a3;
    if (*a4 < *a3)
    {
      unint64_t v14 = a3[1];
      *a3 = *a4;
      a3[1] = a4[1];
      *a4 = v13;
      a4[1] = v14;
      unint64_t v15 = *a2;
      if (*a3 < *a2)
      {
        unint64_t v16 = a2[1];
        *a2 = *a3;
        a2[1] = a3[1];
        *a3 = v15;
        a3[1] = v16;
        unint64_t v17 = *a1;
        if (*a2 < *a1)
        {
          unint64_t v18 = a1[1];
          *a1 = *a2;
          a1[1] = a2[1];
          *a2 = v17;
          a2[1] = v18;
        }
      }
    }
  }
  return result;
}

void sub_100BFDE90(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A47488;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100BFDEB0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A47488;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BFDF04(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100BFDF30(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100BFDF68(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100BFDF98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

stewie::ConnectionAssistantTargetDataSource *sub_100BFDFDC(stewie::ConnectionAssistantTargetDataSource **a1, stewie::ConnectionAssistantTargetDataSource *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    stewie::ConnectionAssistantTargetDataSource::~ConnectionAssistantTargetDataSource(result);
    operator delete();
  }
  return result;
}

ctu::OsLogLogger *sub_100BFE02C(ctu::OsLogLogger **a1, ctu::OsLogLogger *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    ctu::OsLogLogger::~OsLogLogger(result);
    operator delete();
  }
  return result;
}

uint64_t *sub_100BFE07C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(_DWORD *)(v1 + 8) == 8 && (*(_WORD *)(v2 + 833) & 0x30) != 0 && (*(_WORD *)(v2 + 835) & 0x30) == 0)
  {
    if (!*(unsigned char *)(v2 + 811) || *(unsigned char *)(v2 + 812))
    {
      unint64_t v3 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_7;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v4 = "#I Instant offer requested while display is not active or coversheet is active, ignoring this request";
      goto LABEL_6;
    }
    if (*(unsigned char *)(v2 + 809)) {
      BOOL v6 = *(unsigned char *)(v2 + 810) == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = 2;
    }
    if (*(void *)(v2 + 760))
    {
      unint64_t v8 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "kMessaging";
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Instant offer already pending, replacing it with new one for: %s", buf, 0xCu);
      }
    }
    else
    {
      ++*(void *)(v2 + 792);
      unint64_t v9 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "kMessaging";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Presenting instant offer for: %s", buf, 0xCu);
      }
      uint64_t v10 = *(void *)(v2 + 144);
      unint64_t v11 = *(NSObject **)(v2 + 24);
      dispatch_object_t object = v11;
      if (v11) {
        dispatch_retain(v11);
      }
      sub_10003E168(buf, (void *)(v2 + 8));
      long long v12 = *(_OWORD *)buf;
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
      }
      *(void *)long long buf = off_101A47710;
      *(_OWORD *)&uint8_t buf[8] = v12;
      unint64_t v20 = buf;
      (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, dispatch_object_t *, unsigned char *))(*(void *)v10 + 16))(&v18, v10, v7, &object, buf);
      long long v13 = v18;
      long long v18 = 0uLL;
      unint64_t v14 = *(std::__shared_weak_count **)(v2 + 768);
      *(_OWORD *)(v2 + 760) = v13;
      if (v14)
      {
        sub_10004D2C8(v14);
        if (*((void *)&v18 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v18 + 1));
        }
      }
      sub_100C0015C(buf);
      if (object) {
        dispatch_release(object);
      }
    }
  }
  else
  {
    unint64_t v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v4 = "#I Instant offer is not relevant at the moment (due to service state), ignoring this request";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, buf, 2u);
    }
  }
LABEL_7:
  sub_100BFE380(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100BFE344(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (object) {
    dispatch_release(object);
  }
  sub_100BFE380(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BFE380(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 40))
    {
      if (*(char *)(v1 + 39) < 0) {
        operator delete(*(void **)(v1 + 16));
      }
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100BFE3E0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  if (!sub_100BF6560(*(void *)v1, (int *)(v1 + 8), 0))
  {
    unint64_t v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to start assistant app", buf, 2u);
    }
  }
  sub_100BFE380(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100BFE470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100BFE48C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  *(unsigned char *)(v2 + 640) = 0;
  unint64_t v3 = (_OWORD *)(v2 + 368);
  int v4 = *(unsigned __int8 *)(v2 + 600);
  if (!*(unsigned char *)(v2 + 600))
  {
    sub_100BFED04(v2 + 368);
    *(void *)(v2 + 592) = 0;
    *(_OWORD *)(v2 + 560) = 0u;
    *(_OWORD *)(v2 + 576) = 0u;
    *(_OWORD *)(v2 + 528) = 0u;
    *(_OWORD *)(v2 + 544) = 0u;
    *(_OWORD *)(v2 + 496) = 0u;
    *(_OWORD *)(v2 + 512) = 0u;
    *(_OWORD *)(v2 + 464) = 0u;
    *(_OWORD *)(v2 + 480) = 0u;
    *(_OWORD *)(v2 + 432) = 0u;
    *(_OWORD *)(v2 + 448) = 0u;
    *(_OWORD *)(v2 + 400) = 0u;
    *(_OWORD *)(v2 + 416) = 0u;
    *unint64_t v3 = 0u;
    *(_OWORD *)(v2 + 384) = 0u;
    *(unsigned char *)(v2 + 600) = 1;
  }
  int v5 = *((_DWORD *)v1 + 2);
  *(_DWORD *)(v2 + 376) = v5;
  if (*((unsigned char *)v1 + 56))
  {
    if ((v5 - 1) >= 4) {
      int v5 = 0;
    }
    char v6 = *((unsigned char *)v1 + 50);
    char v7 = *((unsigned char *)v1 + 51);
    LOWORD(aBlock) = *((_WORD *)v1 + 26);
    BYTE2(aBlock) = *((unsigned char *)v1 + 54);
    if (*(unsigned char *)(v2 + 392)) {
      *(unsigned char *)(v2 + 392) = 0;
    }
    *(_DWORD *)(v2 + 380) = v5;
    *(unsigned char *)(v2 + 384) = v6;
    *(unsigned char *)(v2 + 385) = v7;
    *(_WORD *)(v2 + 386) = aBlock;
    *(unsigned char *)(v2 + 388) = BYTE2(aBlock);
    *(unsigned char *)(v2 + 392) = 1;
  }
  if (*((unsigned char *)v1 + 96))
  {
    char v8 = *((unsigned char *)v1 + 64);
    char v9 = *((unsigned char *)v1 + 65);
    *(void *)((char *)&aBlock + 6) = v1[9];
    BYTE14(aBlock) = *((unsigned char *)v1 + 80);
    *(_WORD *)&unsigned char v23[7] = *((_WORD *)v1 + 44);
    v23[9] = *((unsigned char *)v1 + 90);
    if (*(unsigned char *)(v2 + 432)) {
      *(unsigned char *)(v2 + 432) = 0;
    }
    *(unsigned char *)(v2 + 400) = v8;
    *(unsigned char *)(v2 + 401) = v9;
    *(void *)(v2 + 402) = aBlock;
    *(void *)(v2 + 409) = *(void *)((char *)&aBlock + 7);
    *(void *)(v2 + 417) = *(void *)v23;
    *(_WORD *)(v2 + 425) = *(_WORD *)&v23[8];
    *(unsigned char *)(v2 + 432) = 1;
  }
  if (*(unsigned char *)(v2 + 632)) {
    *(unsigned char *)(v2 + 632) = 0;
  }
  if (!v4)
  {
    sub_10003E168(&aBlock, (void *)(v2 + 8));
    long long v10 = aBlock;
    if (*((void *)&aBlock + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&aBlock + 1) + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
    }
    uint64_t v11 = *(void *)(v2 + 56);
    sub_100058DB0(v23, "stw.catick");
    long long v12 = *(NSObject **)(v2 + 24);
    dispatch_object_t object = v12;
    if (v12) {
      dispatch_retain(v12);
    }
    *(void *)&aBlocCFIndex k = _NSConcreteStackBlock;
    *((void *)&aBlock + 1) = 1174405120;
    unint64_t v20 = sub_100BFE8F8;
    uint64_t v21 = &unk_101A47540;
    long long v22 = v10;
    if (*((void *)&v10 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v10 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    uint64_t v16 = _Block_copy(&aBlock);
    sub_10038ECF0(v11, (uint64_t)v23, 2, 1000000, &object, &v16);
    if (!*(unsigned char *)(v2 + 600)) {
      sub_10016C840();
    }
    uint64_t v13 = *(void *)buf;
    *(void *)long long buf = 0;
    uint64_t v14 = *(void *)v3;
    *(void *)unint64_t v3 = v13;
    if (v14)
    {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      uint64_t v15 = *(void *)buf;
      *(void *)long long buf = 0;
      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
      }
    }
    if (v16) {
      _Block_release(v16);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v24 < 0) {
      operator delete(*(void **)v23);
    }
    sub_100BF4A98(v2, 0);
    if (*((void *)&v22 + 1)) {
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v22 + 1));
    }
    if (*((void *)&v10 + 1)) {
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v10 + 1));
    }
  }
  sub_100BF8CBC(v2);
}

void sub_100BFE828(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *aBlock, dispatch_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100BFE8F8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    unint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 32);
      if (v4)
      {
        if (!*(unsigned char *)(v4 + 600) || *(unsigned char *)(v4 + 656))
        {
          if (*(unsigned char *)(v4 + 688)) {
            *(unsigned char *)(v4 + 688) = 0;
          }
          goto LABEL_8;
        }
        v5.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = v5.__d_.__rep_;
        if (!*(unsigned char *)(v4 + 688))
        {
          char v9 = *(NSObject **)(v4 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Looks like Assistant app is not running, starting countdown", buf, 2u);
            if (*(unsigned char *)(v4 + 688)) {
              *(unsigned char *)(v4 + 688) = 0;
            }
          }
          *(void *)(v4 + 664) = rep;
          *(void *)(v4 + 672) = rep;
          *(_DWORD *)(v4 + 680) = 0;
          *(unsigned char *)(v4 + 684) = 0;
          *(unsigned char *)(v4 + 687) = buf[2];
          *(_WORD *)(v4 + 685) = *(_WORD *)buf;
          *(unsigned char *)(v4 + 688) = 1;
LABEL_8:
          sub_100BF4A98(v4, 1);
          sub_100BF8CBC(v4);
        }
        if (v5.__d_.__rep_ - *(void *)(v4 + 672) < 3000000000) {
          goto LABEL_8;
        }
        unsigned int v7 = *(_DWORD *)(v4 + 680);
        if (v7 >= 6)
        {
          if (!*(unsigned char *)(v4 + 684))
          {
            *(unsigned char *)(v4 + 684) = 1;
            char v8 = *(NSObject **)(v4 + 40);
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v7;
              _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Too many Assistant app reopen requests sent (%u), failed to reopen the app", buf, 8u);
            }
          }
          goto LABEL_8;
        }
        memset(v26, 0, sizeof(v26));
        *(_OWORD *)long long buf = 0u;
        long long v25 = 0u;
        *(_DWORD *)long long buf = *(_DWORD *)(v4 + 376);
        BYTE8(v26[0]) = 0;
        BYTE8(v26[3]) = 0;
        if (*(unsigned char *)(v4 + 392))
        {
          int v10 = *(_DWORD *)(v4 + 380);
          __int16 v11 = *(_WORD *)(v4 + 384);
          if ((v10 - 1) >= 4) {
            int v10 = 0;
          }
          int v12 = *(_DWORD *)(v4 + 386);
          int v16 = v10;
          char v17 = 0;
          __p.n128_u8[0] = 0;
          char v20 = 0;
          LOBYTE(v21) = 0;
          WORD1(v21) = v11;
          DWORD1(v21) = v12;
          BYTE8(v21) = 1;
          v22[0] = 0;
          char v23 = 0;
          uint8_t buf[4] = 0;
          *(_DWORD *)long long buf = v10;
          sub_100179CB0((uint64_t)&buf[8], &__p);
          *(_OWORD *)((char *)v26 + 8) = v21;
          *(_OWORD *)((char *)&v26[1] + 8) = *(_OWORD *)v22;
          *(_OWORD *)((char *)&v26[2] + 8) = *(_OWORD *)&v22[16];
          BYTE8(v26[3]) = v23;
        }
        else
        {
          if (!*(unsigned char *)(v4 + 432))
          {
LABEL_32:
            ++*(_DWORD *)(v4 + 680);
            *(void *)(v4 + 672) = rep;
            if (sub_100BF6560(v4, (int *)buf, 1))
            {
              uint64_t v15 = *(NSObject **)(v4 + 40);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v16) = 0;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Assistant app reopen request sent, waiting for the app to start", (uint8_t *)&v16, 2u);
              }
            }
            if (LOBYTE(v26[0]) && SHIBYTE(v25) < 0) {
              operator delete(*(void **)&buf[8]);
            }
            goto LABEL_8;
          }
          *(_WORD *)&v22[6] = 0;
          *(_DWORD *)&uint64_t v22[2] = 0;
          __int16 v13 = *(_WORD *)(v4 + 400);
          int v14 = *(_DWORD *)(v4 + 424);
          int v16 = 7;
          char v17 = 0;
          __p.n128_u8[0] = 0;
          char v20 = 0;
          LOBYTE(v21) = 0;
          BYTE2(v21) = 0;
          BYTE8(v21) = 0;
          *(_WORD *)long long v22 = v13;
          *(_OWORD *)&v22[8] = *(_OWORD *)(v4 + 408);
          *(_DWORD *)&v22[24] = v14;
          *(_DWORD *)&v22[28] = 0;
          char v23 = 1;
          sub_100BF8C00((uint64_t)buf, &v16);
        }
        if (v20 && v19 < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
        goto LABEL_32;
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_100BFEC94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100BFECD8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100BFECF4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100BFED04(uint64_t result)
{
  if (*(unsigned char *)(result + 232))
  {
    uint64_t v1 = result;
    uint64_t v2 = *(std::__shared_weak_count **)(result + 224);
    if (v2) {
      sub_10004D2C8(v2);
    }
    if (*(unsigned char *)(v1 + 128)) {
      sub_10012577C((const void **)(v1 + 72));
    }
    uint64_t result = *(void *)v1;
    *(void *)uint64_t v1 = 0;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
    *(unsigned char *)(v1 + 232) = 0;
  }
  return result;
}

void sub_100BFED7C(uint64_t **a1)
{
  unint64_t v3 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  *(unsigned char *)(v2 + 640) = 0;
  if (!*(unsigned char *)(v2 + 632))
  {
    *(void *)(v2 + 608) = 0;
    *(void *)(v2 + 616) = 0;
    *(void *)(v2 + 624) = 0;
    *(unsigned char *)(v2 + 632) = 1;
  }
  *(_DWORD *)(v2 + 608) = *((_DWORD *)v1 + 3);
  *(std::chrono::system_clock::time_point *)(v2 + 616) = std::chrono::system_clock::now();
  *(_WORD *)(v2 + 624) = *((_WORD *)v1 + 4);
  if (*(unsigned char *)(v2 + 600))
  {
    sub_100BFED04(v2 + 368);
    sub_100BFDFDC((stewie::ConnectionAssistantTargetDataSource **)(v2 + 216), 0);
    sub_100BFE02C((ctu::OsLogLogger **)(v2 + 328), 0);
    if (*(unsigned char *)(v2 + 360)) {
      *(unsigned char *)(v2 + 360) = 0;
    }
  }
  sub_100BF8CBC(v2);
}

void sub_100BFEE40()
{
}

uint64_t sub_100BFEE6C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    unint64_t v3 = (void *)(a1 + 24);
  }
  *unint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100BFEEEC(void **a1)
{
  uint64_t v1 = *a1;
  std::chrono::steady_clock::time_point v5 = a1;
  char v6 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(*v1 + 112);
  uint64_t v7 = *(void *)(*v1 + 104);
  char v8 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = v1[4];
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, &v7);
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100BFEFB0((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100BFEF88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100BFEFB0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BFEFB0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1001E8174((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100BFF000(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100BFF080(void **a1)
{
  uint64_t v1 = *a1;
  std::chrono::steady_clock::time_point v5 = a1;
  char v6 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(*v1 + 192);
  uint64_t v7 = *(void *)(*v1 + 184);
  char v8 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = v1[4];
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, &v7);
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100BFF144((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100BFF11C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100BFF144(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BFF144(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1001E8464((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100BFF194(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_100BFF214(uint64_t **a1)
{
  uint64_t v1 = *a1;
  __int16 v13 = a1;
  int v14 = v1;
  uint64_t v2 = *v1;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(*v1 + 24));
  if (*(void *)(v2 + 216)
    && (uint64_t v3 = *(stewie::ConnectionAssistantGPSDataSource **)(v2 + 328)) != 0
    && (unint64_t v17 = 0, stewie::ConnectionAssistantGPSDataSource::currentGPSTime(v3, &v17), v17))
  {
    uint64_t v4 = *(void *)(v2 + 216);
    *(void *)&long long v15 = stewie::ConnectionAssistantGPSDataSource::location(*(stewie::ConnectionAssistantGPSDataSource **)(v2 + 328));
    *((void *)&v15 + 1) = v5;
    uint64_t v16 = v6;
    uint64_t v7 = *(void *)(v2 + 328);
    if (*(unsigned char *)(v7 + 40)) {
      int v8 = *(_DWORD *)(v7 + 24);
    }
    else {
      int v8 = 0;
    }
    stewie::ConnectionAssistantTargetDataSource::updateCachedServicePlot(v4, &v15, v8, &v17);
    sub_100BF9A00(v2);
  }
  else
  {
    char v9 = *(std::__shared_weak_count **)(v2 + 208);
    *(void *)(v2 + 200) = 0;
    *(void *)(v2 + 208) = 0;
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  uint64_t v10 = *(void *)(v2 + 208);
  *(void *)&long long v15 = *(void *)(v2 + 200);
  *((void *)&v15 + 1) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = v1[4];
  if (!v11) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v11 + 48))(v11, &v15);
  if (*((void *)&v15 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v15 + 1));
  }
  sub_100BFF36C((uint64_t *)&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_100BFF33C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100BFF36C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100BFF36C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1001E8754((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_100BFF3BC(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *((int *)v1 + 2);
    if (v4 > 7) {
      uint64_t v5 = "???";
    }
    else {
      uint64_t v5 = off_101A47AF0[v4];
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I handleEvent: eventType = %s", (uint8_t *)&buf, 0xCu);
  }
  switch(*((_DWORD *)v1 + 2))
  {
    case 1:
    case 2:
      goto LABEL_25;
    case 3:
      if (*(unsigned char *)(v2 + 640))
      {
        *(unsigned char *)(v2 + 640) = 0;
        sub_100BF8CBC(v2);
      }
      goto LABEL_25;
    case 4:
      if (*(unsigned char *)(v2 + 656)) {
        *(unsigned char *)(v2 + 656) = 0;
      }
      break;
    case 5:
      if (*(unsigned char *)(v2 + 632))
      {
        *(unsigned char *)(v2 + 632) = 0;
        sub_100BF8CBC(v2);
      }
LABEL_25:
      if (*(unsigned char *)(v2 + 688)) {
        *(unsigned char *)(v2 + 688) = 0;
      }
      if (!*(unsigned char *)(v2 + 656))
      {
        *(void *)(v2 + 648) = 0;
        *(unsigned char *)(v2 + 656) = 1;
      }
      *(std::chrono::steady_clock::time_point *)(v2 + 648) = std::chrono::steady_clock::now();
      break;
    case 6:
      if (*(unsigned char *)(v2 + 688)) {
        *(unsigned char *)(v2 + 688) = 0;
      }
      if (!*(unsigned char *)(v2 + 656))
      {
        *(void *)(v2 + 648) = 0;
        *(unsigned char *)(v2 + 656) = 1;
      }
      *(std::chrono::steady_clock::time_point *)(v2 + 648) = std::chrono::steady_clock::now();
      uint64_t v6 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = 79200;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Starting a timer for OTG offer declined backoff. Duration: %lld seconds", (uint8_t *)&buf, 0xCu);
      }
      sub_100058DB0(&__p, "OfferDeclinedBackoffTracker");
      *(void *)&long long buf = off_101A47580;
      *((void *)&buf + 1) = v2;
      p_long long buf = &buf;
      AutoStartTimer::create();
      long long v7 = v12;
      long long v12 = 0uLL;
      int v8 = *(std::__shared_weak_count **)(v2 + 752);
      *(_OWORD *)(v2 + 744) = v7;
      if (v8)
      {
        sub_10004D2C8(v8);
        if (*((void *)&v12 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
        }
      }
      sub_10003B34C(&buf);
      if (v11 < 0) {
        operator delete(__p);
      }
      sub_100BF4CA0(v2);
      break;
    case 7:
      if (*(unsigned char *)(v2 + 688)) {
        *(unsigned char *)(v2 + 688) = 0;
      }
      if (!*(unsigned char *)(v2 + 656))
      {
        *(void *)(v2 + 648) = 0;
        *(unsigned char *)(v2 + 656) = 1;
      }
      *(std::chrono::steady_clock::time_point *)(v2 + 648) = std::chrono::steady_clock::now();
      char v9 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I OTG mode offer was accepted", (uint8_t *)&buf, 2u);
      }
      ++*(void *)(v2 + 784);
      break;
    default:
      break;
  }
  operator delete();
}

void sub_100BFF6D4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_100BFF73C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v16 = a1;
  unint64_t v17 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *v1 + 328;
  uint64_t v4 = *(stewie::ConnectionAssistantGPSDataSource **)v3;
  if (!*(void *)v3) {
    stewie::ConnectionAssistantGPSDataSource::create();
  }
  unint64_t v19 = 0;
  stewie::ConnectionAssistantGPSDataSource::currentGPSTime(v4, &v19);
  uint64_t v5 = *(stewie::ConnectionAssistantGPSDataSource **)v3;
  uint64_t v6 = v1[1];
  uint64_t v7 = *(void *)(v6 + 32);
  double v8 = *(double *)(v6 + 8) * 1000000000.0;
  LODWORD(v6) = *(_DWORD *)(v6 + 72);
  *((void *)v5 + 2) = v7;
  *((_DWORD *)v5 + 6) = v6;
  *((void *)v5 + 4) = (unint64_t)v8;
  *((unsigned char *)v5 + 40) = 1;
  unint64_t v18 = 0;
  stewie::ConnectionAssistantGPSDataSource::currentGPSTime(v5, &v18);
  unint64_t v9 = v18;
  unint64_t v10 = v19;
  if (v19 > v18 + 100000000)
  {
    char v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v10 - v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Tracked time went back %llu ns, if it happens too often, optimize how TargetDataSource handles this case.", buf, 0xCu);
    }
  }
  uint64_t v12 = v1[3];
  uint64_t v13 = *(void *)(v12 + 32);
  int v14 = *(int8x16_t **)v3;
  int8x16_t v15 = (int8x16_t)vdivq_f64(vmulq_f64(*(float64x2_t *)(v12 + 8), (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL)), (float64x2_t)vdupq_n_s64(0x4066800000000000uLL));
  if (*(unsigned char *)(*(void *)v3 + 72)) {
    v14[4].i8[8] = 0;
  }
  v14[3] = vextq_s8(v15, v15, 8uLL);
  v14[4].i64[0] = v13;
  v14[4].i8[8] = 1;
  sub_100BF8CBC(v2);
}

void sub_100BFF904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100BFF920(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 32);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
    if (v3) {
      sub_10004D2C8(v3);
    }
    operator delete();
  }
  return result;
}

void sub_100BFF980(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (*(unsigned char *)(v2 + 600))
  {
    uint64_t v3 = *(stewie::ConnectionAssistantGPSDataSource **)(v2 + 328);
    if (v3)
    {
      *(void *)long long buf = 0;
      stewie::ConnectionAssistantGPSDataSource::currentGPSTime(v3, (unint64_t *)buf);
      if (*(void *)buf)
      {
        uint64_t v4 = *(void *)buf + 1000000 * v1[1];
        *(void *)(v2 + 560) = *(void *)buf;
        *(void *)(v2 + 568) = v4;
        *(unsigned char *)(v2 + 576) = 1;
        sub_100BF8CBC(v2);
      }
      uint64_t v5 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
LABEL_12:
      }
        operator delete();
      __int16 v8 = 0;
      uint64_t v6 = "handleStewieTxDeferTime - currentGPSTime is 0";
      uint64_t v7 = (uint8_t *)&v8;
LABEL_10:
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, v7, 2u);
      goto LABEL_12;
    }
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v6 = "handleStewieTxDeferTime - fGPSDataSource == nil";
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v6 = "handleStewieTxDeferTime - stewieTxDeferTime reported when Stewie is not on";
  }
  uint64_t v7 = buf;
  goto LABEL_10;
}

void sub_100BFFABC()
{
}

void sub_100BFFAEC()
{
}

void *sub_100BFFB00(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A47580;
  result[1] = v3;
  return result;
}

uint64_t sub_100BFFB48(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A47580;
  a2[1] = v2;
  return result;
}

void sub_100BFFB74(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I OTG offer declined backoff timer expired", v4, 2u);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 752);
  *(_OWORD *)(v1 + 744) = 0u;
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100BF4CA0(v1);
}

uint64_t sub_100BFFBF8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100BFFC38()
{
}

void sub_100BFFC48()
{
}

void *sub_100BFFC5C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A47600;
  result[1] = v3;
  return result;
}

uint64_t sub_100BFFCA4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A47600;
  a2[1] = v2;
  return result;
}

void sub_100BFFCD0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I OTG offer timer expired", v3, 2u);
  }
  sub_100BF4CA0(v1);
}

uint64_t sub_100BFFD3C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100BFFD7C()
{
}

void *sub_100BFFD88(void *a1)
{
  *a1 = off_101A47680;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100BFFDD4(void *a1)
{
  *a1 = off_101A47680;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100BFFE40(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A47680;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100BFFE9C(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A47680;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100BFFED4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100BFFEE4(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100BFFF24(uint64_t a1, uint64_t *a2, unsigned __int8 *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4) {
    return;
  }
  uint64_t v5 = *a2;
  int v6 = *a3;
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return;
  }
  __int16 v8 = v7;
  uint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    if (*(unsigned char *)(v9 + 736) && (uint64_t v10 = *(void *)(v9 + 720)) != 0)
    {
      if (v10 == v5)
      {
        int8x16_t v15 = *(std::__shared_weak_count **)(v9 + 728);
        *(_OWORD *)(v9 + 720) = 0u;
        if (v15) {
          sub_10004D2C8(v15);
        }
        char v11 = *(NSObject **)(v9 + 40);
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_17;
        }
        uint64_t v16 = "accepted";
        if (!v6) {
          uint64_t v16 = "ignored";
        }
        int v17 = 136315138;
        unint64_t v18 = v16;
        uint64_t v13 = "#I Offer response received: %s";
        goto LABEL_16;
      }
      char v11 = *(NSObject **)(v9 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = "accepted";
        if (!v6) {
          uint64_t v12 = "ignored";
        }
        int v17 = 136315138;
        unint64_t v18 = v12;
        uint64_t v13 = "#I Offer response received for expired offer: %s";
LABEL_16:
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v17, 0xCu);
      }
    }
    else
    {
      char v11 = *(NSObject **)(v9 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = "accepted";
        if (!v6) {
          int v14 = "ignored";
        }
        int v17 = 136315138;
        unint64_t v18 = v14;
        uint64_t v13 = "#I No offer is pending, but response received: %s";
        goto LABEL_16;
      }
    }
  }
LABEL_17:

  sub_10004D2C8(v8);
}

uint64_t sub_100C00110(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100C00150()
{
}

void *sub_100C0015C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100C001E0(void *a1)
{
  *a1 = off_101A47710;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100C0022C(void *a1)
{
  *a1 = off_101A47710;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100C00298(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A47710;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100C002F4(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A47710;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100C0032C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100C0033C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100C0037C(uint64_t a1, uint64_t *a2, unsigned __int8 *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4) {
    return;
  }
  uint64_t v5 = *a2;
  int v6 = *a3;
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return;
  }
  __int16 v8 = v7;
  uint64_t v9 = *(void **)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = v9[95];
    if (v10)
    {
      if (v10 == v5)
      {
        int v15 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
        uint64_t v16 = (std::__shared_weak_count *)v9[96];
        v9[95] = 0;
        v9[96] = 0;
        if (v16) {
          sub_10004D2C8(v16);
        }
        int v17 = v9[5];
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v18 = "accepted";
          if (!v6) {
            unint64_t v18 = "ignored";
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v18;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Instant offer response received: %s", (uint8_t *)&buf, 0xCu);
        }
        if (v6)
        {
          ++v9[100];
          if ((v15 - 1) <= 1)
          {
            sub_100058DB0(&buf, "MessagesOfferAccept");
            stewie::StewieConnectionAssistant::submitEntryPointMetric((uint64_t)v9, (const char *)&buf);
            if (v21 < 0) {
              operator delete((void *)buf);
            }
          }
          sub_10003E168(&buf, v9 + 1);
          unint64_t v19 = (std::__shared_weak_count *)*((void *)&buf + 1);
          if (*((void *)&buf + 1))
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&buf + 1) + 16), 1uLL, memory_order_relaxed);
            sub_10004D2C8(v19);
          }
          operator new();
        }
        goto LABEL_29;
      }
      char v11 = v9[5];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = "accepted";
        if (!v6) {
          uint64_t v12 = "ignored";
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v12;
        uint64_t v13 = "#I Instant offer response received for expired alert: %s";
LABEL_15:
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      char v11 = v9[5];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = "accepted";
        if (!v6) {
          int v14 = "ignored";
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v14;
        uint64_t v13 = "#I No instant offer is pending, but response received: %s";
        goto LABEL_15;
      }
    }
  }
LABEL_29:

  sub_10004D2C8(v8);
}

void sub_100C00670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_100C006AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C006EC()
{
}

uint64_t *sub_100C006F8(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100C0074C(uint64_t a1)
{
  uint64_t v11 = a1;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)a1;
      if (*(void *)a1)
      {
        int v6 = *(std::__shared_weak_count **)(v5 + 136);
        if (v6)
        {
          uint64_t v7 = std::__shared_weak_count::lock(v6);
          if (v7)
          {
            __int16 v8 = v7;
            uint64_t v9 = *(void *)(v5 + 128);
            if (v9)
            {
              if ((*(_DWORD *)(a1 + 16) - 1) <= 1)
              {
                sub_100058DB0(__p, "Messages");
                (*(void (**)(uint64_t, void **))(*(void *)v9 + 24))(v9, __p);
                if (v13 < 0) {
                  operator delete(__p[0]);
                }
              }
            }
            sub_10004D2C8(v8);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
  return sub_100C006F8(&v11);
}