uint64_t sub_100C85E44(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    sub_1000C6BDC((uint64_t *)a1, a2);
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_100C85E88(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24)) {
    sub_10005CD2C(v1, *(char **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void sub_100C85EA8(uint64_t a1)
{
  *(void *)a1 = off_101A4C5A0;
  *(void *)(a1 + 48) = off_101A4C740;
  v2 = (CoreUtilsMessageSessionDelegateInterface *)(a1 + 56);
  *(void *)(a1 + 56) = off_101A4C768;
  v3 = (CellularPlanProvisioningMonitorModeDelegate *)(a1 + 64);
  *(void *)(a1 + 64) = off_101A4C790;
  v4 = (CellularPlanProvisioningMonitorModeDelegate *)(a1 + 72);
  *(void *)(a1 + 72) = off_101A4C7C8;
  sub_1003135E4((void *)(a1 + 384));
  if (*(unsigned char *)(a1 + 376)) {
    sub_10005CD2C(a1 + 352, *(char **)(a1 + 360));
  }
  sub_10005CD2C(a1 + 328, *(char **)(a1 + 336));
  v5 = *(std::__shared_weak_count **)(a1 + 320);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 296);
  *(void *)(a1 + 296) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 288);
  *(void *)(a1 + 288) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  v14 = (void **)(a1 + 264);
  sub_10030AFC8(&v14);
  v8 = *(std::__shared_weak_count **)(a1 + 256);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  sub_10010C0E0(a1 + 216, *(void **)(a1 + 224));
  v14 = (void **)(a1 + 184);
  sub_10008A88C(&v14);
  v14 = (void **)(a1 + 160);
  sub_1000C56F4(&v14);
  v9 = *(std::__shared_weak_count **)(a1 + 152);
  if (v9) {
    sub_10004D2C8(v9);
  }
  v10 = *(std::__shared_weak_count **)(a1 + 136);
  if (v10) {
    sub_10004D2C8(v10);
  }
  v11 = *(std::__shared_weak_count **)(a1 + 120);
  if (v11) {
    sub_10004D2C8(v11);
  }
  v12 = *(std::__shared_weak_count **)(a1 + 104);
  if (v12) {
    sub_10004D2C8(v12);
  }
  v13 = *(std::__shared_weak_count **)(a1 + 88);
  if (v13) {
    sub_10004D2C8(v13);
  }
  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate(v4);
  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate(v3);
  CoreUtilsMessageSessionDelegateInterface::~CoreUtilsMessageSessionDelegateInterface(v2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  CellularPlanPendingTransferHandlerInterface::~CellularPlanPendingTransferHandlerInterface((CellularPlanPendingTransferHandlerInterface *)a1);
}

void sub_100C860C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A4C9A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100C860E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A4C9A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100C86134(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100C86160(uint64_t a1)
{
  sub_100C85EA8(a1);

  operator delete();
}

void sub_100C86198(uint64_t a1)
{
}

void sub_100C861A0(uint64_t a1)
{
  sub_100C85EA8(a1 - 48);

  operator delete();
}

void sub_100C861DC(uint64_t a1)
{
}

void sub_100C861E4(uint64_t a1)
{
  sub_100C85EA8(a1 - 56);

  operator delete();
}

void sub_100C86220(uint64_t a1)
{
}

void sub_100C86228(uint64_t a1)
{
  sub_100C85EA8(a1 - 64);

  operator delete();
}

void sub_100C86264(uint64_t a1)
{
}

void sub_100C8626C(uint64_t a1)
{
  sub_100C85EA8(a1 - 72);

  operator delete();
}

uint64_t *sub_100C862A8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  v21 = a1;
  uint64_t v22 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&v23, *(Registry **)(*(void *)v1 + 80));
  ctu::RestModule::connect();
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_100058DB0(&buf, "/cc/props/vinyl_info");
  v3 = operator new(0x28uLL);
  void *v3 = off_101A4CCC0;
  v3[1] = v2 + 160;
  v3[2] = v2;
  v3[3] = sub_100C7845C;
  v3[4] = 0;
  v28 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(&__p);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  sub_100058DB0(&buf, "/cc/props/sims_on_device");
  v4 = operator new(0x28uLL);
  void *v4 = off_101A4CD40;
  v4[1] = v2 + 184;
  v4[2] = v2;
  v4[3] = sub_100C78744;
  v4[4] = 0;
  v28 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(&__p);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  sub_100058DB0(&buf, "/cc/events/dump_state");
  v5 = operator new(0x20uLL);
  void *v5 = off_101A4CDC0;
  v5[1] = v2;
  v5[2] = sub_100C78980;
  v5[3] = 0;
  v28 = v5;
  ctu::RestModule::observeEvent();
  sub_10003F600(&__p);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  sub_100664E98(v2 + 208);
  sub_100AA61BC(v2 + 216);
  uint64_t v6 = *(void *)(v2 + 112);
  uint64_t v7 = *(void *)(v6 + 8);
  if (v7)
  {
    (*(void (**)(uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v7 + 48))(v7, @"com.apple.commcenter.cellular_plan", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    CFArrayRef theArray = 0;
    (*(void (**)(std::string *__return_ptr))(**(void **)(v6 + 8) + 40))(&__p);
    sub_100044D6C(&theArray, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
    sub_1000577C4((const void **)&__p.__r_.__value_.__l.__data_);
    if (theArray) {
      v8 = sub_100083F10;
    }
    else {
      v8 = 0;
    }
    v24 = 0;
    uint64_t v25 = 0;
    v23 = &v24;
    if (v8)
    {
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          memset(&buf, 0, sizeof(buf));
          CFArrayGetValueAtIndex(theArray, i);
          memset(&__p, 0, sizeof(__p));
          ctu::cf::assign();
          std::string buf = __p;
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
          char v12 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }
          if (size)
          {
            sub_1000EA6A0((uint64_t **)&v23, (void **)&buf.__r_.__value_.__l.__data_, (uint64_t)&buf);
            char v12 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
          }
          if (v12 < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
      }
    }
    sub_100044D00((const void **)&theArray);
  }
  else
  {
    v13 = *(NSObject **)v6;
    if (os_log_type_enabled(*(os_log_t *)v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "invalid preferences", (uint8_t *)&__p, 2u);
    }
    v24 = 0;
    uint64_t v25 = 0;
    v23 = &v24;
  }
  v14 = (std::string **)(v2 + 328);
  v15 = (std::string *)(v2 + 336);
  sub_10005CD2C(v2 + 328, *(char **)(v2 + 336));
  v16 = v24;
  *(void *)(v2 + 328) = v23;
  *(void *)(v2 + 336) = v16;
  uint64_t v17 = v25;
  *(void *)(v2 + 344) = v25;
  if (v17)
  {
    v16->__shared_weak_owners_ = (uint64_t)v15;
    v23 = &v24;
    v24 = 0;
    uint64_t v25 = 0;
    v16 = 0;
  }
  else
  {
    *v14 = v15;
  }
  sub_10005CD2C((uint64_t)&v23, (char *)v16);
  v18 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000E8F34(*v14, v15, ",", 1uLL, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I load expired plans : [%s]", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  sub_1000E3958(&v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_100C86770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, char *a12, uint64_t a13, const void *a14)
{
}

void sub_100C86834(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A4CC70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100C86854(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A4CC70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100C868A8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
}

void sub_100C868F0()
{
}

__n128 sub_100C86904(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4CCC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100C86958(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4CCC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100C86990(uint64_t a1, xpc_object_t *a2)
{
  sub_10010C4E0(*(uint64_t **)(a1 + 8), a2);
  v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100C86A0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C86A4C()
{
}

void sub_100C86A5C()
{
}

__n128 sub_100C86A70(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4CD40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100C86AC4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4CD40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100C86AFC(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100C86B78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C86BB8()
{
}

void sub_100C86BC8()
{
}

__n128 sub_100C86BDC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A4CDC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100C86C30(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4CDC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100C86C68(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100C86CB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C86CF0()
{
}

void sub_100C86CFC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(***(void ***)a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100C86DE4(void ***a1)
{
  uint64_t v1 = a1;
  sub_100C81600(**a1);
  operator delete();
}

void sub_100C86E38()
{
}

uint64_t sub_100C86E64(uint64_t a1)
{
  *(void *)a1 = off_101A4CE40;
  sub_1003135E4((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100C86EB8(uint64_t a1)
{
  *(void *)a1 = off_101A4CE40;
  sub_1003135E4((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100C86F2C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  void *v2 = off_101A4CE40;
  sub_100C871AC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100C86F80(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100C86F94(uint64_t a1, void *a2)
{
  *a2 = off_101A4CE40;
  return sub_100C871AC((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100C86FC0(uint64_t a1)
{
}

void sub_100C86FC8(void *a1)
{
  sub_10033D8DC((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_100C87004(uint64_t a1, unsigned __int8 *a2, const void **a3, const void **a4, unsigned __int8 *a5)
{
  int v6 = *a2;
  uint64_t v7 = *a3;
  *a3 = 0;
  v8 = *a4;
  char v12 = *a4;
  v13 = v7;
  *a4 = 0;
  int v9 = *a5;
  uint64_t v10 = *(void *)(a1 + 8);
  v15 = v7;
  if (v7) {
    CFRetain(v7);
  }
  v14 = v8;
  if (v8) {
    CFRetain(v8);
  }
  sub_1002E1174(a1 + 40, v6 != 0, (uint64_t)&v15, (uint64_t)&v14, v9);
  sub_100057D78(&v14);
  sub_1000558F4(&v15);
  if (v9)
  {
    LOBYTE(__p) = 0;
    char v18 = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void **))(*(void *)v10 + 112))(v10, a1 + 16, 11, &__p);
    if (v18)
    {
      if (v17 < 0) {
        operator delete(__p);
      }
    }
  }
  sub_100057D78(&v12);
  return sub_1000558F4(&v13);
}

void sub_100C8710C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, __int16 a11, char a12, char a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a24)
  {
    if (a23 < 0) {
      operator delete(__p);
    }
  }
  sub_100057D78((const void **)&a9);
  sub_1000558F4(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100C87160(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C871A0()
{
}

uint64_t sub_100C871AC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  sub_1003240C8(a1 + 32, a2 + 32);
  return a1;
}

void sub_100C87220(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t (**sub_100C8723C(uint64_t (**result)(uint64_t, void, void, _UNKNOWN **, void *)))(uint64_t, void, void, _UNKNOWN **, void *)
{
  if (result)
  {
    if (*result) {
    else
    }
      return 0;
  }
  return result;
}

uint64_t (**sub_100C87288(uint64_t (**result)(uint64_t, void, void, void *, void *)))(uint64_t, void, void, void *, void *)
{
  if (result)
  {
    if (*result) {
    else
    }
      return 0;
  }
  return result;
}

uint64_t sub_100C872D4(uint64_t a1)
{
  *(void *)a1 = off_101A4CEC0;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100C87324(uint64_t a1)
{
  *(void *)a1 = off_101A4CEC0;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100C87394(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_101A4CEC0;
  v2[1] = v3;
  long long v4 = v2 + 2;
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)long long v4 = *(_OWORD *)(a1 + 16);
    v2[4] = *(void *)(a1 + 32);
  }
  return v2;
}

void sub_100C8740C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_100C87420(char *result, void *a2)
{
  uint64_t v2 = *((void *)result + 1);
  *a2 = off_101A4CEC0;
  a2[1] = v2;
  uint64_t v3 = a2 + 2;
  if (result[39] < 0) {
    return (char *)sub_10004FC84(v3, *((void **)result + 2), *((void *)result + 3));
  }
  long long v4 = *((_OWORD *)result + 1);
  a2[4] = *((void *)result + 4);
  *(_OWORD *)uint64_t v3 = v4;
  return result;
}

void sub_100C87470(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
}

void sub_100C87484(void **__p)
{
  if (*((char *)__p + 39) < 0) {
    operator delete(__p[2]);
  }

  operator delete(__p);
}

const void **sub_100C874C8(uint64_t a1, unsigned __int8 *a2, const void **a3)
{
  int v4 = *a2;
  int v9 = *a3;
  *a3 = 0;
  v5 = *(void **)(a1 + 8);
  if (v4)
  {
    int v6 = v5[5];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = a1 + 16;
      if (*(char *)(a1 + 39) < 0) {
        uint64_t v8 = *(void *)(a1 + 16);
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v11 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "send transfer confirmation timeout for %s", buf, 0xCu);
    }
  }
  sub_100C7D8F0(v5, a1 + 16);
  return sub_100057D78(&v9);
}

void sub_100C875B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100C875C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C87604()
{
}

void sub_100C87610(void **a1)
{
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = (std::__shared_weak_count *)v1[32];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v1[31];
      if (v4)
      {
        v5 = v1[5];
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I notifying pending transfer plans update", buf, 2u);
        }
        (*(void (**)(uint64_t, void *))(*(void *)v4 + 56))(v4, v1 + 33);
        goto LABEL_11;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  int v6 = v1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "delegate not available", v8, 2u);
  }
  if (!v3) {
LABEL_12:
  }
    operator delete();
LABEL_11:
  sub_10004D2C8(v3);
  goto LABEL_12;
}

void sub_100C87748()
{
  sub_10004D2C8(v0);
  operator delete();
}

uint64_t *sub_100C8777C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v22 = a1;
  uint64_t v23 = v1;
  uint64_t v2 = *(void **)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 264);
  uint64_t v4 = *(void *)(*(void *)v1 + 272);
  v5 = (long long *)(v1 + 8);
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v6 = *v5;
    uint64_t v25 = *(void *)(v1 + 24);
    *(_OWORD *)std::string __p = v6;
  }
  uint64_t v7 = HIBYTE(v25);
  if (v3 != v4)
  {
    int v9 = __p[0];
    uint64_t v8 = __p[1];
    if (v25 >= 0) {
      uint64_t v10 = (void *)HIBYTE(v25);
    }
    else {
      uint64_t v10 = __p[1];
    }
    do
    {
      uint64_t v11 = (void *)*(unsigned __int8 *)(v3 + 455);
      int v12 = (char)v11;
      if ((char)v11 < 0) {
        uint64_t v11 = *(void **)(v3 + 440);
      }
      if (v10 == v11)
      {
        if (v12 >= 0) {
          v13 = (unsigned __int8 *)(v3 + 432);
        }
        else {
          v13 = *(unsigned __int8 **)(v3 + 432);
        }
        if ((v7 & 0x80) != 0)
        {
          if (!memcmp(v9, v13, (size_t)v8)) {
            goto LABEL_24;
          }
        }
        else
        {
          if (!v7) {
            goto LABEL_25;
          }
          v14 = __p;
          uint64_t v15 = v7;
          while (*(unsigned __int8 *)v14 == *v13)
          {
            v14 = (void **)((char *)v14 + 1);
            ++v13;
            if (!--v15) {
              goto LABEL_23;
            }
          }
        }
      }
      v3 += 1248;
    }
    while (v3 != v4);
    uint64_t v3 = v4;
  }
LABEL_23:
  if ((v7 & 0x80) != 0) {
LABEL_24:
  }
    operator delete(__p[0]);
LABEL_25:
  if (v3 != v2[34])
  {
    v16 = (std::__shared_weak_count *)v2[32];
    if (v16)
    {
      char v17 = std::__shared_weak_count::lock(v16);
      if (v17)
      {
        uint64_t v18 = v2[31];
        if (v18)
        {
          *(_OWORD *)std::string buf = 0u;
          long long v27 = 0u;
          if (*(char *)(v3 + 479) < 0)
          {
            if (!*(void *)(v3 + 464))
            {
LABEL_42:
              (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)v18 + 40))(v18, v3, 1, 0, 0);
              if (BYTE8(v27) && SBYTE7(v27) < 0) {
                operator delete(*(void **)buf);
              }
LABEL_45:
              sub_10004D2C8(v17);
              goto LABEL_46;
            }
          }
          else if (!*(unsigned char *)(v3 + 479))
          {
            goto LABEL_42;
          }
          sub_100093B44((std::string *)buf, (const std::string *)(v3 + 456));
          goto LABEL_42;
        }
      }
    }
    else
    {
      char v17 = 0;
    }
    v20 = v2[5];
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "delegate not available", buf, 2u);
      if (!v17) {
        goto LABEL_46;
      }
    }
    else if (!v17)
    {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  v19 = v2[5];
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(v1 + 31) < 0) {
      v5 = *(long long **)v5;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I plan : %s is done. ignore transfer push notification", buf, 0xCu);
  }
LABEL_46:
  sub_1001102C4(&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_100C87A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a21)
  {
    if (a20 < 0) {
      operator delete(__p);
    }
  }
  sub_10004D2C8(v21);
  sub_1001102C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100C87A7C(void **a1)
{
  uint64_t v1 = (void *)**a1;
  if (v1[16])
  {
    uint64_t v2 = v1[5];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I session invalidate", buf, 2u);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[32];
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        v5 = v4;
        uint64_t v6 = v1[31];
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 88))(v6);
        }
        sub_10004D2C8(v5);
      }
    }
    uint64_t v7 = (std::__shared_weak_count *)v1[17];
    v1[16] = 0;
    v1[17] = 0;
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
  operator delete();
}

void sub_100C87B70()
{
  sub_10004D2C8(v0);
  operator delete();
}

uint64_t sub_100C87BA4(uint64_t a1)
{
  *(void *)a1 = off_101A4CF40;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100C87C00(uint64_t a1)
{
  *(void *)a1 = off_101A4CF40;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100C87C7C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_101A4CF40;
  sub_100C8806C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100C87CD0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100C87CE4(uint64_t a1, void *a2)
{
  *a2 = off_101A4CF40;
  return sub_100C8806C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100C87D10(uint64_t a1)
{
}

void sub_100C87D18(void *a1)
{
  sub_10010FC80((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100C87D54(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 8);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      v5 = v4;
      if (*(void *)(a1 + 16))
      {
        uint64_t v6 = v3[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = a1 + 32;
          if (*(unsigned char *)(a1 + 56)) {
            uint64_t v8 = "True";
          }
          else {
            uint64_t v8 = "False";
          }
          if (*(char *)(a1 + 55) < 0) {
            uint64_t v7 = *(void *)(a1 + 32);
          }
          *(_DWORD *)std::string __p = 136315394;
          *(void *)&__p[4] = v8;
          *(_WORD *)&__p[12] = 2080;
          *(void *)&__p[14] = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I retry transfer monitor mode completed with status: %s for sourceIccid: %s", __p, 0x16u);
        }
        uint64_t v10 = v3[33];
        uint64_t v9 = v3[34];
        if (*(char *)(a1 + 55) < 0)
        {
          sub_10004FC84(__p, *(void **)(a1 + 32), *(void *)(a1 + 40));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 32);
          *(void *)&__p[16] = *(void *)(a1 + 48);
        }
        char v11 = __p[23];
        if (v10 != v9)
        {
          if (__p[23] >= 0) {
            uint64_t v12 = __p[23];
          }
          else {
            uint64_t v12 = *(void *)&__p[8];
          }
          if (__p[23] >= 0) {
            v13 = __p;
          }
          else {
            v13 = *(unsigned char **)__p;
          }
          do
          {
            uint64_t v14 = *(unsigned __int8 *)(v10 + 455);
            if ((v14 & 0x80u) == 0) {
              uint64_t v15 = *(unsigned __int8 *)(v10 + 455);
            }
            else {
              uint64_t v15 = *(void *)(v10 + 440);
            }
            if (v15 == v12)
            {
              if ((v14 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v10 + 432), v13, *(void *)(v10 + 440))) {
                  goto LABEL_34;
                }
              }
              else
              {
                if (!*(unsigned char *)(v10 + 455)) {
                  goto LABEL_34;
                }
                uint64_t v16 = 0;
                while (*(unsigned __int8 *)(v10 + v16 + 432) == v13[v16])
                {
                  if (v14 == ++v16) {
                    goto LABEL_34;
                  }
                }
              }
            }
            v10 += 1248;
          }
          while (v10 != v9);
          uint64_t v10 = v9;
        }
LABEL_34:
        if (v11 < 0) {
          operator delete(*(void **)__p);
        }
        if (v10 != v3[34])
        {
          char v17 = *(std::__shared_weak_count **)(v10 + 1216);
          *(_OWORD *)(v10 + 1208) = 0u;
          if (v17) {
            sub_10004D2C8(v17);
          }
          *(unsigned char *)(v10 + 1226) = 1;
          *(unsigned char *)(v10 + 18) = 0;
          if (*(unsigned char *)(v10 + 1152) && *(double *)(v10 + 1136) > 0.0)
          {
            uint64_t v18 = (std::__shared_weak_count *)v3[32];
            if (v18)
            {
              v19 = std::__shared_weak_count::lock(v18);
              if (v19)
              {
                v20 = v19;
                uint64_t v21 = v3[31];
                if (v21)
                {
                  int v22 = *(unsigned __int8 *)(a1 + 56);
                  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
                  (*(void (**)(uint64_t, uint64_t, uint64_t, BOOL, unint64_t, uint64_t))(*(void *)v21 + 136))(v21, 4, v10 + 240, v22 != 0, (unint64_t)(Current - *(double *)(v10 + 1136)), v10 + 456);
                }
                sub_10004D2C8(v20);
              }
            }
            *(void *)(v10 + 1136) = 0;
          }
          sub_100C7AAE8((uint64_t)v3);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100C87FFC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100C88020(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C88060()
{
}

uint64_t sub_100C8806C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  v5 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)v5 = v6;
  }
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  return a1;
}

void sub_100C880E8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C88100()
{
  qword_101B12A70 = 0;
  qword_101B12A78 = 0;
  qword_101B12A80 = 0;
  v0 = operator new(0x28uLL);
  qword_101B12A78 = (uint64_t)(v0 + 5);
  qword_101B12A80 = (uint64_t)(v0 + 5);
  v0[4] = 120;
  *(_OWORD *)v0 = xmmword_10155FFC8;
  *((_OWORD *)v0 + 1) = unk_10155FFD8;
  qword_101B12A70 = (uint64_t)v0;
  __cxa_atexit((void (*)(void *))sub_10015B924, &qword_101B12A70, (void *)&_mh_execute_header);
  qword_101B12A88 = 0;
  qword_101B12A90 = 0;
  unk_101B12A98 = 0;
  uint64_t v1 = operator new(0x38uLL);
  v1[6] = 300;
  qword_101B12A90 = (uint64_t)(v1 + 7);
  unk_101B12A98 = v1 + 7;
  *(_OWORD *)uint64_t v1 = xmmword_10155FFF0;
  *((_OWORD *)v1 + 1) = unk_101560000;
  *((_OWORD *)v1 + 2) = xmmword_101560010;
  qword_101B12A88 = (uint64_t)v1;

  return __cxa_atexit((void (*)(void *))sub_10015B924, &qword_101B12A88, (void *)&_mh_execute_header);
}

uint64_t sub_100C881E0@<X0>(dispatch_object_t *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, const void **a5@<X4>, _OWORD *a6@<X8>)
{
  sub_100C889E4(a1, a2, a3, a4, a5, &v8);
  uint64_t result = v8;
  if ((void)v8) {
    sub_100C88244(v8);
  }
  *a6 = v8;
  return result;
}

void sub_100C88244(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

CellularPlanProvisioningMonitorModeInterface *sub_100C88320(uint64_t a1)
{
  *(void *)a1 = off_101A4CFC0;
  uint64_t v2 = (ctu::RestModule *)(a1 + 152);
  uint64_t v3 = a1 + 168;
  sub_1006D495C();
  sub_100058DB0(&__p, "/cc/props/internet_status");
  ctu::RestModule::unobserveProperty();
  if (v7 < 0) {
    operator delete(__p);
  }
  ctu::RestModule::disconnect(v2);
  sub_10030AAD0(v3, *(void **)(a1 + 176));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 160);
  if (v4) {
    sub_10004D2C8(v4);
  }

  return sub_10045E9DC((CellularPlanProvisioningMonitorModeInterface *)a1);
}

void sub_100C883E0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10006A6AC(a1);
}

void sub_100C88408(uint64_t a1)
{
  sub_100C88320(a1);

  operator delete();
}

void sub_100C88440(uint64_t a1)
{
  void (***v13)(uint64_t *__return_ptr, void, void **);
  char v14;
  std::__shared_weak_count *v15;
  void *v16;
  uint64_t v17;
  void v18[6];
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  void *__p[2];
  uint64_t v23;

  v20 = 0;
  uint64_t v21 = 0;
  if (*(unsigned char *)(a1 + 192) != 1) {
    goto LABEL_34;
  }
  uint64_t v2 = a1 + 168;
  uint64_t v3 = a1 + 64;
  if (*(char *)(a1 + 87) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 64), *(void *)(a1 + 72));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v3;
    uint64_t v23 = *(void *)(a1 + 80);
  }
  uint64_t v4 = sub_100046F68(v2, __p);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  if ((void **)(a1 + 176) == v4)
  {
    v20 = 0;
    uint64_t v21 = 0;
    goto LABEL_34;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  long long v6 = ServiceMap;
  if (v7 < 0)
  {
    long long v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v7;
  char v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)__p);
  if (!v11)
  {
    v13 = 0;
LABEL_17:
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    uint64_t v14 = 1;
    if (!v13) {
      goto LABEL_14;
    }
LABEL_18:
    if (*(char *)(a1 + 87) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 64), *(void *)(a1 + 72));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v3;
      uint64_t v23 = *(void *)(v3 + 16);
    }
    (**v13)(&v20, v13, __p);
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_23;
  }
  v13 = (void (***)(uint64_t *__return_ptr, void, void **))v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_17;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  uint64_t v14 = 0;
  if (v13) {
    goto LABEL_18;
  }
LABEL_14:
  v20 = 0;
  uint64_t v21 = 0;
LABEL_23:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (v20)
  {
    sub_10003E168(__p, (void *)(a1 + 8));
    uint64_t v16 = __p[0];
    uint64_t v15 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)__p[1] + 2, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
    }
    char v17 = v20;
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 1174405120;
    v18[2] = sub_100C8877C;
    v18[3] = &unk_101A4D018;
    v18[4] = a1;
    v18[5] = v16;
    v19 = v15;
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    __p[0] = v18;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void **))(*(void *)v17 + 256))(v17, 1, a1 + 24, 1, __p);
    if (v19) {
      std::__shared_weak_count::__release_weak(v19);
    }
    if (v15) {
      std::__shared_weak_count::__release_weak(v15);
    }
  }
LABEL_34:
  if (v21) {
    sub_10004D2C8(v21);
  }
}

void sub_100C88700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C8877C(void *a1, unsigned char *a2, char a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v7 = a1[4];
    long long v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (!a1[5])
      {
LABEL_13:
        sub_10004D2C8(v9);
        return;
      }
      if (a3)
      {
        if (a2[144] | a2[64])
        {
          unsigned __int8 v10 = a2[33] - 1;
          if (v10 <= 7u)
          {
            uint64_t v11 = (char)v10;
            uint64_t v12 = qword_101561750[(char)v10];
            uint64_t v13 = qword_101561790[v11];
LABEL_12:
            sub_10045EEC8(v7, v13 | v12);
            goto LABEL_13;
          }
LABEL_11:
          LOWORD(v12) = 0;
          LOWORD(v13) = 0;
          goto LABEL_12;
        }
        uint64_t v14 = *(NSObject **)(v7 + 40);
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          goto LABEL_11;
        }
        __int16 v17 = 0;
        uint64_t v15 = "AccountInfo not valid";
        uint64_t v16 = (uint8_t *)&v17;
      }
      else
      {
        uint64_t v14 = *(NSObject **)(v7 + 40);
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
          goto LABEL_11;
        }
        __int16 v18 = 0;
        uint64_t v15 = "Error while querying entitlements";
        uint64_t v16 = (uint8_t *)&v18;
      }
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v15, v16, 2u);
      goto LABEL_11;
    }
  }
}

void sub_100C888B0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100C888CC(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 184))
  {
    uint64_t v3 = (unsigned __int8 *)(a2 + 1);
    uint64_t v4 = (unsigned __int8 *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    v5 = *(unsigned __int8 **)(a1 + 168);
    while (sub_10001D294(v4 + 32, v5 + 32) && sub_1003B27B4((uint64_t)(v4 + 56), (uint64_t)(v5 + 56)))
    {
      long long v6 = (unsigned __int8 *)*((void *)v4 + 1);
      uint64_t v7 = v4;
      if (v6)
      {
        do
        {
          uint64_t v4 = v6;
          long long v6 = *(unsigned __int8 **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v4 = (unsigned __int8 *)*((void *)v7 + 2);
          BOOL v8 = *(void *)v4 == (void)v7;
          uint64_t v7 = v4;
        }
        while (!v8);
      }
      uint64_t v9 = (unsigned __int8 *)*((void *)v5 + 1);
      if (v9)
      {
        do
        {
          unsigned __int8 v10 = v9;
          uint64_t v9 = *(unsigned __int8 **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          unsigned __int8 v10 = (unsigned __int8 *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v10 == (void)v5;
          v5 = v10;
        }
        while (!v8);
      }
      v5 = v10;
      if (v4 == v3) {
        return;
      }
    }
  }

  sub_100C88440(a1);
}

void sub_100C889C4(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 192);
  int v3 = *a2;
  if (v2 != v3 && v2 == 1 && v3 != 1) {
    sub_100C88440(a1);
  }
}

void sub_100C889E4(dispatch_object_t *a1@<X1>, void *a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, const void **a5@<X5>, void *a6@<X8>)
{
  uint64_t v12 = operator new(0xE0uLL);
  sub_100C88A88(v12, a1, a2, a3, a4, a5);
  *a6 = v12 + 3;
  a6[1] = v12;

  sub_1000B3BC8((uint64_t)a6, v12 + 4, (uint64_t)(v12 + 3));
}

void sub_100C88A74(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100C88A88(void *a1, dispatch_object_t *a2, void *a3, uint64_t *a4, uint64_t a5, const void **a6)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A4D0A0;
  sub_100C88B80((uint64_t)(a1 + 3), a2, a3, a4, a5, a6);
  return a1;
}

void sub_100C88AD0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100C88AE4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A4D0A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100C88B04(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A4D0A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100C88B58(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_100C88B80(uint64_t a1, dispatch_object_t *a2, void *a3, uint64_t *a4, uint64_t a5, const void **a6)
{
  uint64_t v11 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  uint64_t v13 = *a4;
  uint64_t v12 = (std::__shared_weak_count *)a4[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v15, a6);
  uint64_t v23 = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  v22[0] = v13;
  v22[1] = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a5;
    uint64_t v21 = *(void *)(a5 + 16);
  }
  sub_10045E7FC(a1, &v23, a3, v22, "mm.ent", (long long *)__p);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (v23) {
    dispatch_release(v23);
  }
  *(void *)a1 = off_101A4CFC0;
  sub_100058DB0(&v18, "mm.ent");
  dispatch_object_t v17 = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  dispatch_object_t object = 0;
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v17) {
    dispatch_release(v17);
  }
  if (v19 < 0) {
    operator delete(v18);
  }
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 168) = a1 + 176;
  *(unsigned char *)(a1 + 192) = 0;
  sub_100057D78(&v15);
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (v11) {
    dispatch_release(v11);
  }
  *(void *)a1 = off_101A4D0F0;
  return a1;
}

void sub_100C88D64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (v24) {
    sub_10004D2C8(v24);
  }
  long long v27 = *(NSObject **)(v25 - 72);
  if (v27) {
    dispatch_release(v27);
  }
  sub_100057D78((const void **)&a9);
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (v23) {
    dispatch_release(v23);
  }
  _Unwind_Resume(a1);
}

void sub_100C88E04(uint64_t a1)
{
  sub_100C88320(a1);

  operator delete();
}

void sub_100C88E3C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  Registry::createRestModuleOneTimeUseConnection(&v5, *(Registry **)(v1 + 48));
  ctu::RestModule::connect();
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100058DB0(__p, "/cc/props/carrier_entitlements_info");
  int v2 = operator new(0x28uLL);
  void *v2 = off_101A4D170;
  v2[1] = v1 + 168;
  v2[2] = v1;
  v2[3] = sub_100C888CC;
  v2[4] = 0;
  unsigned __int8 v10 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v9);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/internet_status");
  int v3 = operator new(0x28uLL);
  void *v3 = off_101A4D1F0;
  v3[1] = v1 + 192;
  v3[2] = v1;
  v3[3] = sub_100C889C4;
  v3[4] = 0;
  unsigned __int8 v10 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v9);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = off_101A4D270;
  v4[1] = v1;
  v4[2] = sub_1004CEC08;
  v4[3] = 0;
  unsigned __int8 v10 = v4;
  ctu::RestModule::observeEvent();
  sub_10003F600(v9);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  operator delete();
}

void sub_100C89054(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void sub_100C890D0()
{
}

__n128 sub_100C890E4(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  *(void *)int v2 = off_101A4D170;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100C89138(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4D170;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100C89170(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  unsigned __int8 v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10031A644((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  char v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10030AAD0((uint64_t)&v9, v10);
}

void sub_100C89230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100C89248(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C89288()
{
}

void sub_100C89298()
{
}

__n128 sub_100C892AC(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  *(void *)int v2 = off_101A4D1F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100C89300(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4D1F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100C89338(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (char *)a1[1];
  char v13 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    char v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v6);
    char *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    char *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *, char *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, char *))(*v11 + v9);
  }
  return v9(v11, &v13);
}

uint64_t sub_100C89434(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C89474()
{
}

void sub_100C89484()
{
}

__n128 sub_100C89498(uint64_t a1)
{
  int v2 = (char *)operator new(0x20uLL);
  *(void *)int v2 = off_101A4D270;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100C894EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4D270;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100C89524(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  int v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100C8956C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C895AC()
{
}

uint64_t sub_100C895B8(unsigned int a1)
{
  if (a1 > 0xC) {
    uint64_t v1 = &kCTSIMSupportSIMStatusReady;
  }
  else {
    uint64_t v1 = *(&off_101A4D2F0 + (int)a1);
  }
  return *(void *)v1;
}

const char *sub_100C895E0(int a1)
{
  if ((a1 - 1) > 0x1D) {
    return "getEntitlement";
  }
  else {
    return off_101A4D670[a1 - 1];
  }
}

const char *sub_100C89608(int a1)
{
  if ((a1 - 1) > 0xC) {
    return "GenericTask";
  }
  else {
    return off_101A4D760[a1 - 1];
  }
}

void sub_100C89630(uint64_t a1, char a2)
{
  int v3 = (int **)(a1 + 8);
  if (a2)
  {
    sub_100C896DC(v3, (uint64_t **)(a1 + 80));
    sub_100C898C0((int **)(a1 + 32), (uint64_t **)(a1 + 80));
    sub_100C89AA4((int **)(a1 + 56), (uint64_t **)(a1 + 80));
  }
  else
  {
    sub_1000346F8((uint64_t)v3, *(void **)(a1 + 16));
    *(void *)(a1 + 8) = a1 + 16;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 16) = 0;
    sub_1000346F8(a1 + 32, *(void **)(a1 + 40));
    *(void *)(a1 + 32) = a1 + 40;
    *(void *)(a1 + 40) = 0;
    uint64_t v5 = *(void **)(a1 + 64);
    uint64_t v4 = (void *)(a1 + 64);
    *(v4 - 2) = 0;
    sub_10005D0E4((uint64_t)(v4 - 1), v5);
    *(v4 - 1) = v4;
    void *v4 = 0;
    v4[1] = 0;
  }
}

void sub_100C896DC(int **a1, uint64_t **a2)
{
  int v22 = 0;
  uint64_t v23 = 0;
  unint64_t v24 = 0;
  sub_100C92A48((void **)&v22, (unint64_t)a1[2]);
  uint64_t v4 = *a1;
  if (*a1 != (int *)(a1 + 1))
  {
    do
    {
      uint64_t v5 = v4 + 7;
      uint64_t v25 = (unsigned int *)(v4 + 7);
      if (!*((_DWORD *)sub_10030B04C(a2, v4 + 7, (uint64_t)&unk_10144E20E, &v25) + 8))
      {
        long long v6 = v23;
        if ((unint64_t)v23 >= v24)
        {
          char v8 = v22;
          uint64_t v9 = (v23 - v22) >> 2;
          unint64_t v10 = v9 + 1;
          if ((unint64_t)(v9 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v11 = v24 - (void)v22;
          if ((uint64_t)(v24 - (void)v22) >> 1 > v10) {
            unint64_t v10 = v11 >> 1;
          }
          if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v12 = v10;
          }
          if (v12) {
            unint64_t v12 = (unint64_t)sub_1000492A8(v12);
          }
          else {
            uint64_t v13 = 0;
          }
          char v14 = (char *)(v12 + 4 * v9);
          *(_DWORD *)char v14 = *v5;
          uint64_t v7 = v14 + 4;
          while (v6 != v8)
          {
            int v15 = *((_DWORD *)v6 - 1);
            v6 -= 4;
            *((_DWORD *)v14 - 1) = v15;
            v14 -= 4;
          }
          int v22 = v14;
          unint64_t v24 = v12 + 4 * v13;
          if (v8) {
            operator delete(v8);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v23 = *v5;
          uint64_t v7 = v6 + 4;
        }
        uint64_t v23 = v7;
      }
      uint64_t v16 = (int *)*((void *)v4 + 1);
      if (v16)
      {
        do
        {
          dispatch_object_t v17 = (int **)v16;
          uint64_t v16 = *(int **)v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          dispatch_object_t v17 = (int **)*((void *)v4 + 2);
          BOOL v18 = *v17 == v4;
          uint64_t v4 = (int *)v17;
        }
        while (!v18);
      }
      uint64_t v4 = (int *)v17;
    }
    while (v17 != a1 + 1);
  }
  char v19 = v22;
  v20 = v23;
  if (v22 != v23)
  {
    uint64_t v21 = v22;
    do
    {
      LODWORD(v25) = *(_DWORD *)v21;
      sub_100AE8A00((uint64_t)a1, (int *)&v25);
      v21 += 4;
    }
    while (v21 != v20);
  }
  if (v19) {
    operator delete(v19);
  }
}

void sub_100C8989C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C898C0(int **a1, uint64_t **a2)
{
  int v22 = 0;
  uint64_t v23 = 0;
  unint64_t v24 = 0;
  sub_100C92A48((void **)&v22, (unint64_t)a1[2]);
  uint64_t v4 = *a1;
  if (*a1 != (int *)(a1 + 1))
  {
    do
    {
      uint64_t v5 = v4 + 7;
      uint64_t v25 = (unsigned int *)(v4 + 7);
      if (!*((_DWORD *)sub_10030B04C(a2, v4 + 7, (uint64_t)&unk_10144E20E, &v25) + 8))
      {
        long long v6 = v23;
        if ((unint64_t)v23 >= v24)
        {
          char v8 = v22;
          uint64_t v9 = (v23 - v22) >> 2;
          unint64_t v10 = v9 + 1;
          if ((unint64_t)(v9 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v11 = v24 - (void)v22;
          if ((uint64_t)(v24 - (void)v22) >> 1 > v10) {
            unint64_t v10 = v11 >> 1;
          }
          if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v12 = v10;
          }
          if (v12) {
            unint64_t v12 = (unint64_t)sub_1000492A8(v12);
          }
          else {
            uint64_t v13 = 0;
          }
          char v14 = (char *)(v12 + 4 * v9);
          *(_DWORD *)char v14 = *v5;
          uint64_t v7 = v14 + 4;
          while (v6 != v8)
          {
            int v15 = *((_DWORD *)v6 - 1);
            v6 -= 4;
            *((_DWORD *)v14 - 1) = v15;
            v14 -= 4;
          }
          int v22 = v14;
          unint64_t v24 = v12 + 4 * v13;
          if (v8) {
            operator delete(v8);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v23 = *v5;
          uint64_t v7 = v6 + 4;
        }
        uint64_t v23 = v7;
      }
      uint64_t v16 = (int *)*((void *)v4 + 1);
      if (v16)
      {
        do
        {
          dispatch_object_t v17 = (int **)v16;
          uint64_t v16 = *(int **)v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          dispatch_object_t v17 = (int **)*((void *)v4 + 2);
          BOOL v18 = *v17 == v4;
          uint64_t v4 = (int *)v17;
        }
        while (!v18);
      }
      uint64_t v4 = (int *)v17;
    }
    while (v17 != a1 + 1);
  }
  char v19 = v22;
  v20 = v23;
  if (v22 != v23)
  {
    uint64_t v21 = v22;
    do
    {
      LODWORD(v25) = *(_DWORD *)v21;
      sub_100AE8A00((uint64_t)a1, (int *)&v25);
      v21 += 4;
    }
    while (v21 != v20);
  }
  if (v19) {
    operator delete(v19);
  }
}

void sub_100C89A80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C89AA4(int **a1, uint64_t **a2)
{
  int v22 = 0;
  uint64_t v23 = 0;
  unint64_t v24 = 0;
  sub_100C92A48((void **)&v22, (unint64_t)a1[2]);
  uint64_t v4 = *a1;
  if (*a1 != (int *)(a1 + 1))
  {
    do
    {
      uint64_t v5 = v4 + 8;
      uint64_t v25 = (unsigned int *)(v4 + 8);
      if (!*((_DWORD *)sub_10030B04C(a2, v4 + 8, (uint64_t)&unk_10144E20E, &v25) + 8))
      {
        long long v6 = v23;
        if ((unint64_t)v23 >= v24)
        {
          char v8 = v22;
          uint64_t v9 = (v23 - v22) >> 2;
          unint64_t v10 = v9 + 1;
          if ((unint64_t)(v9 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v11 = v24 - (void)v22;
          if ((uint64_t)(v24 - (void)v22) >> 1 > v10) {
            unint64_t v10 = v11 >> 1;
          }
          if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v12 = v10;
          }
          if (v12) {
            unint64_t v12 = (unint64_t)sub_1000492A8(v12);
          }
          else {
            uint64_t v13 = 0;
          }
          char v14 = (char *)(v12 + 4 * v9);
          *(_DWORD *)char v14 = *v5;
          uint64_t v7 = v14 + 4;
          while (v6 != v8)
          {
            int v15 = *((_DWORD *)v6 - 1);
            v6 -= 4;
            *((_DWORD *)v14 - 1) = v15;
            v14 -= 4;
          }
          int v22 = v14;
          unint64_t v24 = v12 + 4 * v13;
          if (v8) {
            operator delete(v8);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v23 = *v5;
          uint64_t v7 = v6 + 4;
        }
        uint64_t v23 = v7;
      }
      uint64_t v16 = (int *)*((void *)v4 + 1);
      if (v16)
      {
        do
        {
          dispatch_object_t v17 = (int **)v16;
          uint64_t v16 = *(int **)v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          dispatch_object_t v17 = (int **)*((void *)v4 + 2);
          BOOL v18 = *v17 == v4;
          uint64_t v4 = (int *)v17;
        }
        while (!v18);
      }
      uint64_t v4 = (int *)v17;
    }
    while (v17 != a1 + 1);
  }
  char v19 = v22;
  v20 = v23;
  if (v22 != v23)
  {
    uint64_t v21 = v22;
    do
    {
      LODWORD(v25) = *(_DWORD *)v21;
      sub_100C92AF0((uint64_t)a1, (int *)&v25);
      v21 += 4;
    }
    while (v21 != v20);
  }
  if (v19) {
    operator delete(v19);
  }
}

void sub_100C89C64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_100C89C88(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = a1 + 40;
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v5 = v2;
    do
    {
      int v6 = *(_DWORD *)(v3 + 28);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        char v8 = (uint64_t *)v3;
      }
      else {
        char v8 = (uint64_t *)(v3 + 8);
      }
      if (!v7) {
        uint64_t v5 = v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 != v2 && *(_DWORD *)(v5 + 28) <= a2)
    {
      int v11 = *(_DWORD *)(v5 + 32);
      unsigned int v10 = v11 & 0xFFFFFF00;
      LODWORD(v3) = v11;
      uint64_t v9 = &_mh_execute_header;
      return (unint64_t)v9 | v10 | v3;
    }
    uint64_t v9 = 0;
    LODWORD(v3) = 0;
  }
  else
  {
    uint64_t v9 = 0;
  }
  unsigned int v10 = 0;
  return (unint64_t)v9 | v10 | v3;
}

uint64_t sub_100C89CF8@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t result = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = result;
  do
  {
    int v7 = *(_DWORD *)(v4 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v4;
    }
    else {
      uint64_t v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != result && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v12 = *(void *)(v6 + 40);
    uint64_t v11 = *(void *)(v6 + 48);
    *(void *)a3 = v12;
    *(void *)(a3 + 8) = v11;
    if (v11)
    {
      uint64_t v13 = (atomic_ullong *)(v11 + 8);
      char v10 = 1;
      atomic_fetch_add_explicit(v13, 1uLL, memory_order_relaxed);
    }
    else
    {
      char v10 = 1;
    }
  }
  else
  {
LABEL_11:
    char v10 = 0;
    *(unsigned char *)a3 = 0;
  }
  *(unsigned char *)(a3 + 16) = v10;
  return result;
}

void sub_100C89D68(uint64_t a1, int a2, int a3, uint64_t **a4)
{
  int v10 = a2;
  uint64_t v11 = &v10;
  *((_DWORD *)sub_10030B04C((uint64_t **)(a1 + 8), &v10, (uint64_t)&unk_10144E20E, (unsigned int **)&v11) + 8) = a3;
  uint64_t v11 = &v10;
  uint64_t v6 = sub_1001B0B78((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_10144E20E, &v11);
  BOOL v8 = *a4;
  int v7 = a4[1];
  if (v7) {
    atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (std::__shared_weak_count *)v6[6];
  v6[5] = v8;
  v6[6] = v7;
  if (v9) {
    sub_10004D2C8(v9);
  }
}

uint64_t sub_100C89E1C(uint64_t a1, int a2)
{
  int v4 = a2;
  sub_100AE8A00(a1 + 8, &v4);
  sub_100AE8A00(a1 + 32, &v4);
  return sub_100C92AF0(a1 + 56, &v4);
}

uint64_t sub_100C89E6C(uint64_t a1, int a2, int a3, int a4, int a5)
{
  int v14 = a2;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7)
  {
    uint64_t v8 = a1 + 16;
    do
    {
      int v9 = *(_DWORD *)(v7 + 28);
      BOOL v10 = v9 < a2;
      if (v9 >= a2) {
        uint64_t v11 = (uint64_t *)v7;
      }
      else {
        uint64_t v11 = (uint64_t *)(v7 + 8);
      }
      if (!v10) {
        uint64_t v8 = v7;
      }
      uint64_t v7 = *v11;
    }
    while (*v11);
    if (v8 != a1 + 16 && *(_DWORD *)(v8 + 28) <= a2 && a5 == 0) {
      return 0;
    }
  }
  int v15 = a2;
  uint64_t v16 = (unsigned int *)&v15;
  *((_DWORD *)sub_10030B04C((uint64_t **)(a1 + 8), &v15, (uint64_t)&unk_10144E20E, &v16) + 8) = a3;
  uint64_t v16 = (unsigned int *)&v14;
  *((_DWORD *)sub_10030B04C((uint64_t **)(a1 + 32), &v14, (uint64_t)&unk_10144E20E, &v16) + 8) = a4;
  return 1;
}

void sub_100C89F4C(uint64_t a1, int a2, int a3, int a4, uint64_t **a5)
{
  int v12 = a2;
  if (sub_100C89E6C(a1, a2, a3, a4, 0))
  {
    uint64_t v7 = *a5;
    if (*a5 && (*((unsigned char *)v7 + 24) || *((unsigned char *)v7 + 64) || *((unsigned char *)v7 + 73)))
    {
      uint64_t v13 = &v12;
      uint64_t v8 = sub_1001B0B78((uint64_t **)(a1 + 56), &v12, (uint64_t)&unk_10144E20E, &v13);
      BOOL v10 = *a5;
      int v9 = a5[1];
      if (v9) {
        atomic_fetch_add_explicit(v9 + 1, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = (std::__shared_weak_count *)v8[6];
      v8[5] = v10;
      v8[6] = v9;
      if (v11) {
        sub_10004D2C8(v11);
      }
    }
    else
    {
      sub_100C92AF0(a1 + 56, &v12);
    }
  }
}

uint64_t sub_100C8A004(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v6 = 0;
  int v4 = operator new(0x20uLL);
  void *v4 = off_101A4D408;
  v4[1] = a2;
  v4[2] = &v6;
  v4[3] = a1;
  v7[3] = v4;
  sub_100022878((uint64_t)v7);
  sub_1000227F0(v7);
  return v6;
}

void sub_100C8A0A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000227F0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100C8A0B8(void *a1, uint64_t a2)
{
  sub_10004B96C(a1, (uint64_t)"EntitlementsSnapshot(", 21);
  char v7 = 1;
  int v4 = operator new(0x20uLL);
  void *v4 = off_101A4D488;
  v4[1] = a2;
  v4[2] = a1;
  v4[3] = &v7;
  void v9[3] = v4;
  sub_100022878((uint64_t)v9);
  sub_1000227F0(v9);
  char v7 = 1;
  uint64_t v5 = operator new(0x20uLL);
  void *v5 = off_101A4D508;
  v5[1] = a2;
  v5[2] = a1;
  v5[3] = &v7;
  v8[3] = v5;
  sub_100022878((uint64_t)v8);
  sub_1000227F0(v8);
  return sub_10004B96C(a1, (uint64_t)")", 1);
}

void sub_100C8A1CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000227F0(va);
  _Unwind_Resume(a1);
}

uint64_t sub_100C8A1F4(uint64_t *a1, uint64_t a2)
{
  if (*((unsigned char *)a1 + 24)) {
    BOOL v2 = *(unsigned char *)(a2 + 24) == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return (*((unsigned char *)a1 + 24) != 0) == (*(unsigned char *)(a2 + 24) != 0);
  }
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  unsigned __int8 v6 = *(int **)a2;
  if (v4 - *a1 != *(void *)(a2 + 8) - *(void *)a2) {
    return 0;
  }
  if (v5 == v4) {
    return 1;
  }
  uint64_t v7 = v5 + 4;
  do
  {
    int v8 = *v6++;
    uint64_t result = *(_DWORD *)(v7 - 4) == v8;
    BOOL v9 = *(_DWORD *)(v7 - 4) != v8 || v7 == v4;
    v7 += 4;
  }
  while (!v9);
  return result;
}

BOOL sub_100C8A278(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  unsigned __int8 v6 = a2;
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0)
  {
    if (!memcmp(*(const void **)a1, a2, *((void *)a1 + 1))) {
      return a1[24] == v6[24];
    }
    return 0;
  }
  if (a1[23])
  {
    for (CFIndex i = a1; *i == *a2; ++i)
    {
      ++a2;
      if (!--v2) {
        return a1[24] == v6[24];
      }
    }
    return 0;
  }
  return a1[24] == v6[24];
}

uint64_t sub_100C8A32C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v14 = 0u;
  memset(v12, 0, sizeof(v12));
  long long v11 = 0u;
  sub_10004BD84((uint64_t)&v11);
  uint64_t v4 = sub_10004B96C(v12, (uint64_t)"url:'", 5);
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *(void *)a1;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  int v8 = sub_10004B96C(v4, v6, v7);
  sub_10004B96C(v8, (uint64_t)"', use_3gpp_rat:", 16);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v12 + 8, a2);
  *(void *)((char *)&v12[-1]
  *(void *)&v12[0] = v9;
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100C8A50C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100C8A520(uint64_t *a1, unsigned __int8 *a2)
{
  int v4 = a2[24];
  if (*((unsigned char *)a1 + 24)) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    if ((*((unsigned char *)a1 + 24) != 0) != (v4 != 0)) {
      return 0;
    }
    goto LABEL_39;
  }
  uint64_t v7 = *a1;
  uint64_t v6 = a1[1];
  uint64_t v8 = *(void *)a2;
  if (v6 - *a1 != *((void *)a2 + 1) - *(void *)a2) {
    return 0;
  }
  if (v7 == v6)
  {
LABEL_39:
    int v18 = a2[64];
    if (*((unsigned char *)a1 + 64)) {
      BOOL v19 = v18 == 0;
    }
    else {
      BOOL v19 = 1;
    }
    if (!v19)
    {
      if (!sub_100C8A278((unsigned __int8 *)a1 + 32, a2 + 32)) {
        return 0;
      }
LABEL_45:
      int v20 = (*((unsigned char *)a1 + 73) != 0) ^ (a2[73] != 0);
      if (*((unsigned char *)a1 + 73))
      {
        if (a2[73]) {
          int v20 = *((unsigned __int8 *)a1 + 72) != a2[72];
        }
      }
      return v20 ^ 1u;
    }
    if ((*((unsigned char *)a1 + 64) != 0) == (v18 != 0)) {
      goto LABEL_45;
    }
    return 0;
  }
  uint64_t v9 = 0;
  while (1)
  {
    int v10 = *(unsigned __int8 *)(v8 + v9 + 4);
    if (!*(unsigned char *)(v7 + v9 + 4) || v10 == 0)
    {
      if ((*(unsigned char *)(v7 + v9 + 4) != 0) != (v10 != 0)) {
        return 0;
      }
    }
    else if (*(_DWORD *)(v7 + v9) != *(_DWORD *)(v8 + v9))
    {
      return 0;
    }
    int v12 = *(unsigned __int8 *)(v8 + v9 + 9);
    if (!*(unsigned char *)(v7 + v9 + 9) || v12 == 0)
    {
      if ((*(unsigned char *)(v7 + v9 + 9) != 0) != (v12 != 0)) {
        return 0;
      }
    }
    else if (*(unsigned __int8 *)(v7 + v9 + 8) != *(unsigned __int8 *)(v8 + v9 + 8))
    {
      return 0;
    }
    if (*(unsigned char *)(v7 + v9 + 16) && *(unsigned char *)(v8 + v9 + 16))
    {
      if (*(_DWORD *)(v7 + v9 + 12) != *(_DWORD *)(v8 + v9 + 12)) {
        return 0;
      }
    }
    else if ((*(unsigned char *)(v7 + v9 + 16) != 0) != (*(unsigned char *)(v8 + v9 + 16) != 0))
    {
      return 0;
    }
    uint64_t v14 = v7 + v9;
    uint64_t v15 = v8 + v9;
    uint64_t result = sub_100C8A1F4((uint64_t *)(v7 + v9 + 24), v8 + v9 + 24);
    if (!result) {
      return result;
    }
    BOOL v17 = (*(unsigned char *)(v14 + 57) != 0) == (*(unsigned char *)(v15 + 57) != 0);
    if (*(unsigned char *)(v14 + 57) && *(unsigned char *)(v15 + 57)) {
      BOOL v17 = *(unsigned __int8 *)(v7 + v9 + 56) == *(unsigned __int8 *)(v8 + v9 + 56);
    }
    if (v17)
    {
      v9 += 64;
      if (v9 + v7 != v6) {
        continue;
      }
    }
    if (!v17) {
      return 0;
    }
    goto LABEL_39;
  }
}

uint64_t sub_100C8A778@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v54 = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  *(_OWORD *)v42 = 0u;
  long long v43 = 0u;
  memset(v41, 0, sizeof(v41));
  long long v40 = 0u;
  sub_10004BD84((uint64_t)&v40);
  if (*((unsigned char *)a1 + 24))
  {
    sub_10004B96C(v41, (uint64_t)" 5g-service: {", 14);
    uint64_t v4 = *a1;
    uint64_t v37 = a1[1];
    if (v37 != *a1)
    {
      char v5 = 1;
      do
      {
        if ((v5 & 1) == 0) {
          sub_10004B96C(v41, (uint64_t)", ", 2);
        }
        uint64_t v69 = 0;
        long long v67 = 0u;
        long long v68 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v63 = 0u;
        long long v64 = 0u;
        long long v61 = 0u;
        long long v62 = 0u;
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        memset(v56, 0, sizeof(v56));
        *(_OWORD *)v55 = 0u;
        sub_10004BD84((uint64_t)v55);
        sub_10004B96C(v56, (uint64_t)"(", 1);
        int v6 = *(unsigned __int8 *)(v4 + 4);
        BOOL v7 = *(unsigned char *)(v4 + 4) == 0;
        if (*(unsigned char *)(v4 + 4))
        {
          uint64_t v8 = sub_10004B96C(v56, (uint64_t)"type: ", 6);
          if (*(_DWORD *)v4) {
            uint64_t v9 = "unmetered";
          }
          else {
            uint64_t v9 = "metered";
          }
          if (*(_DWORD *)v4) {
            uint64_t v10 = 9;
          }
          else {
            uint64_t v10 = 7;
          }
          sub_10004B96C(v8, (uint64_t)v9, v10);
        }
        if (*(unsigned char *)(v4 + 9))
        {
          if (v6) {
            long long v11 = ", ";
          }
          else {
            long long v11 = "";
          }
          int v12 = sub_10004B96C(v56, (uint64_t)v11, 2 * (v6 != 0));
          sub_10004B96C(v12, (uint64_t)"experience: ", 12);
          std::ostream::operator<<();
          BOOL v7 = 0;
        }
        if (*(unsigned char *)(v4 + 16))
        {
          if (v7) {
            uint64_t v13 = "";
          }
          else {
            uint64_t v13 = ", ";
          }
          if (v7) {
            uint64_t v14 = 0;
          }
          else {
            uint64_t v14 = 2;
          }
          uint64_t v15 = sub_10004B96C(v56, (uint64_t)v13, v14);
          sub_10004B96C(v15, (uint64_t)"volume cap: ", 12);
          std::ostream::operator<<();
          BOOL v7 = 0;
        }
        if (*(unsigned char *)(v4 + 48))
        {
          if (v7) {
            long long v16 = "";
          }
          else {
            long long v16 = ", ";
          }
          if (v7) {
            uint64_t v17 = 0;
          }
          else {
            uint64_t v17 = 2;
          }
          int v18 = sub_10004B96C(v56, (uint64_t)v16, v17);
          sub_10004B96C(v18, (uint64_t)"RAT:", 4);
          BOOL v19 = *(_DWORD **)(v4 + 24);
          int v20 = *(_DWORD **)(v4 + 32);
          while (v19 != v20)
          {
            long long v21 = sub_10004B96C(v56, (uint64_t)" ", 1);
            if (*v19) {
              long long v22 = "sub6";
            }
            else {
              long long v22 = "mmw";
            }
            if (*v19) {
              uint64_t v23 = 4;
            }
            else {
              uint64_t v23 = 3;
            }
            sub_10004B96C(v21, (uint64_t)v22, v23);
            ++v19;
          }
          BOOL v7 = 0;
        }
        if (*(unsigned char *)(v4 + 57))
        {
          if (v7) {
            long long v24 = "";
          }
          else {
            long long v24 = ", ";
          }
          if (v7) {
            uint64_t v25 = 0;
          }
          else {
            uint64_t v25 = 2;
          }
          v26 = sub_10004B96C(v56, (uint64_t)v24, v25);
          sub_10004B96C(v26, (uint64_t)"SA provisioned: ", 16);
          std::ostream::operator<<();
        }
        sub_10004B96C(v56, (uint64_t)")", 1);
        sub_10004BC98((uint64_t)&v56[1], v38);
        v55[0] = v36;
        *(void **)((char *)v55 + *((void *)v36 - 3)) = v35;
        v56[0] = v34;
        if (SHIBYTE(v58) < 0) {
          operator delete(*((void **)&v57 + 1));
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        std::ios::~ios();
        if ((v39 & 0x80u) == 0) {
          long long v27 = v38;
        }
        else {
          long long v27 = (void **)v38[0];
        }
        if ((v39 & 0x80u) == 0) {
          uint64_t v28 = v39;
        }
        else {
          uint64_t v28 = (uint64_t)v38[1];
        }
        sub_10004B96C(v41, (uint64_t)v27, v28);
        if ((char)v39 < 0) {
          operator delete(v38[0]);
        }
        char v5 = 0;
        v4 += 64;
      }
      while (v4 != v37);
    }
    sub_10004B96C(v41, (uint64_t)"}", 1);
  }
  if (*((unsigned char *)a1 + 64))
  {
    v29 = sub_10004B96C(v41, (uint64_t)" alt server: ", 13);
    sub_100C8A32C((uint64_t)(a1 + 4), v55);
    v30 = v56[0] >= 0 ? v55 : (void **)v55[0];
    v31 = v56[0] >= 0 ? (void *)HIBYTE(v56[0]) : v55[1];
    sub_10004B96C(v29, (uint64_t)v30, (uint64_t)v31);
    if (SHIBYTE(v56[0]) < 0) {
      operator delete(v55[0]);
    }
  }
  if (*((unsigned char *)a1 + 73))
  {
    sub_10004B96C(v41, (uint64_t)" primary account holder: ", 25);
    std::ostream::operator<<();
  }
  sub_10004BC98((uint64_t)v41 + 8, a2);
  *(void *)((char *)&v41[-1]
  *(void *)&v41[0] = v32;
  if (SHIBYTE(v43) < 0) {
    operator delete(v42[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100C8ADD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *__p,uint64_t a60,int a61,__int16 a62,char a63)
{
  if (a64 < 0) {
    operator delete(__p);
  }
  sub_10008248C((uint64_t)&a23);
  _Unwind_Resume(a1);
}

void sub_100C8AE3C(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  if (*((unsigned char *)a1 + 24))
  {
    sub_100C8AF98((uint64_t *)a2, (a1[1] - *a1) >> 6);
    uint64_t v4 = *a1;
    if (a1[1] != *a1)
    {
      uint64_t v5 = 0;
      unint64_t v6 = 0;
      do
      {
        uint64_t v7 = v4 + v5;
        uint64_t v8 = *(void *)a2 + v5;
        int v9 = *(_DWORD *)(v4 + v5);
        *(unsigned char *)(v8 + 4) = *(unsigned char *)(v7 + 4);
        *(_DWORD *)uint64_t v8 = v9;
        *(_WORD *)(v8 + 8) = *(_WORD *)(v7 + 8);
        int v10 = *(_DWORD *)(v7 + 12);
        *(unsigned char *)(v8 + 16) = *(unsigned char *)(v7 + 16);
        *(_DWORD *)(v8 + 12) = v10;
        sub_1001A13AC(v8 + 24, v7 + 24);
        *(_WORD *)(v8 + 56) = *(_WORD *)(v7 + 56);
        ++v6;
        uint64_t v4 = *a1;
        v5 += 64;
      }
      while (v6 < (a1[1] - *a1) >> 6);
    }
  }
  if (*((unsigned char *)a1 + 64))
  {
    long long v11 = (char *)operator new(0x38uLL);
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = 0;
    *(void *)long long v11 = off_1019C45A8;
    *(_OWORD *)(v11 + 24) = 0u;
    int v12 = (std::string *)(v11 + 24);
    *(_OWORD *)(v11 + 40) = 0u;
    uint64_t v13 = *(std::__shared_weak_count **)(a2 + 32);
    *(void *)(a2 + 24) = v11 + 24;
    *(void *)(a2 + 32) = v11;
    if (v13)
    {
      sub_10004D2C8(v13);
      int v12 = *(std::string **)(a2 + 24);
    }
    sub_100093B44(v12, (const std::string *)(a1 + 4));
  }
  *(_WORD *)(a2 + 40) = *((_WORD *)a1 + 36);
}

void sub_100C8AF7C(_Unwind_Exception *a1)
{
  sub_100193ACC(v1);
  _Unwind_Resume(a1);
}

void sub_100C8AF98(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = (a1[1] - *a1) >> 6;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      sub_1001A145C((uint64_t)a1, *a1 + (a2 << 6));
    }
  }
  else
  {
    sub_100C91C60(a1, a2 - v2);
  }
}

void sub_100C8AFC8()
{
}

void sub_100C8B498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C8B538(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_1001A104C((uint64_t *)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t sub_100C8B5B4(uint64_t a1, long long *a2)
{
  if (*(unsigned char *)(a1 + 32))
  {
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    long long v4 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v4;
    *((unsigned char *)a2 + 23) = 0;
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a1 + 24) = *((unsigned char *)a2 + 24);
  }
  else
  {
    long long v5 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v5;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(unsigned char *)(a1 + 24) = *((unsigned char *)a2 + 24);
    *(unsigned char *)(a1 + 32) = 1;
  }
  return a1;
}

__CFDictionary *sub_100C8B640(int **a1)
{
  v42 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v3 = v42;
    v42 = Mutable;
    valuePtr = v3;
    sub_10005717C((const void **)&valuePtr);
  }
  if (*((unsigned char *)a1 + 24))
  {
    v41 = 0;
    CFMutableArrayRef v4 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v4)
    {
      long long v5 = v41;
      v41 = v4;
      valuePtr = v5;
      sub_1000440D4((const void **)&valuePtr);
    }
    unint64_t v6 = *a1;
    uint64_t v7 = a1[1];
    uint64_t v37 = a1;
    if (*a1 != v7)
    {
      do
      {
        long long v40 = 0;
        CFMutableDictionaryRef v8 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v8)
        {
          int v9 = v40;
          long long v40 = v8;
          valuePtr = v9;
          sub_10005717C((const void **)&valuePtr);
        }
        if (*((unsigned char *)v6 + 4))
        {
          int v10 = v40;
          int v11 = *v6;
          CFNumberRef v43 = 0;
          LODWORD(valuePtr) = v11;
          CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
          if (v12)
          {
            uint64_t v13 = v43;
            CFNumberRef v43 = v12;
            valuePtr = v13;
            sub_1000570E8((const void **)&valuePtr);
          }
          value = v43;
          CFNumberRef v43 = 0;
          sub_1000570E8((const void **)&v43);
          CFDictionarySetValue(v10, @"type", value);
          sub_1000570E8((const void **)&value);
        }
        if (*((unsigned char *)v6 + 9))
        {
          uint64_t v14 = v40;
          if (*((unsigned char *)v6 + 8)) {
            CFBooleanRef v15 = kCFBooleanTrue;
          }
          else {
            CFBooleanRef v15 = kCFBooleanFalse;
          }
          CFNumberRef v43 = v15;
          valuePtr = 0;
          sub_100062778((const void **)&valuePtr);
          value = v43;
          CFNumberRef v43 = 0;
          sub_100062778((const void **)&v43);
          CFDictionarySetValue(v14, @"experience", value);
          sub_100062778((const void **)&value);
        }
        if (*((unsigned char *)v6 + 16))
        {
          long long v16 = v40;
          int v17 = v6[3];
          CFNumberRef v43 = 0;
          LODWORD(valuePtr) = v17;
          CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
          if (v18)
          {
            BOOL v19 = v43;
            CFNumberRef v43 = v18;
            valuePtr = v19;
            sub_1000570E8((const void **)&valuePtr);
          }
          value = v43;
          CFNumberRef v43 = 0;
          sub_1000570E8((const void **)&v43);
          CFDictionarySetValue(v16, @"volumeCapGb", value);
          sub_1000570E8((const void **)&value);
        }
        if (*((unsigned char *)v6 + 48))
        {
          value = 0;
          CFMutableArrayRef v20 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          if (v20)
          {
            long long v21 = (__CFDictionary *)value;
            value = v20;
            valuePtr = v21;
            sub_1000440D4((const void **)&valuePtr);
          }
          uint64_t v23 = (int *)*((void *)v6 + 3);
          long long v22 = (int *)*((void *)v6 + 4);
          while (v23 != v22)
          {
            long long v24 = (__CFArray *)value;
            int v25 = *v23;
            CFNumberRef v43 = 0;
            LODWORD(valuePtr) = v25;
            CFNumberRef v26 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
            if (v26)
            {
              long long v27 = v43;
              CFNumberRef v43 = v26;
              valuePtr = v27;
              sub_1000570E8((const void **)&valuePtr);
            }
            v38 = v43;
            CFNumberRef v43 = 0;
            sub_1000570E8((const void **)&v43);
            CFArrayAppendValue(v24, v38);
            sub_1000570E8((const void **)&v38);
            ++v23;
          }
          CFDictionarySetValue(v40, @"supportedRat", value);
          sub_1000440D4((const void **)&value);
        }
        if (*((unsigned char *)v6 + 57))
        {
          uint64_t v28 = v40;
          if (*((unsigned char *)v6 + 56)) {
            CFBooleanRef v29 = kCFBooleanTrue;
          }
          else {
            CFBooleanRef v29 = kCFBooleanFalse;
          }
          CFNumberRef v43 = v29;
          valuePtr = 0;
          sub_100062778((const void **)&valuePtr);
          value = v43;
          CFNumberRef v43 = 0;
          sub_100062778((const void **)&v43);
          CFDictionarySetValue(v28, @"saProvisioned", value);
          sub_100062778((const void **)&value);
        }
        CFArrayAppendValue(v41, v40);
        sub_10005717C((const void **)&v40);
        v6 += 16;
      }
      while (v6 != v7);
    }
    CFDictionarySetValue(v42, @"5g-property", v41);
    a1 = v37;
    sub_1000440D4((const void **)&v41);
  }
  if (*((unsigned char *)a1 + 64))
  {
    CFNumberRef v43 = 0;
    CFMutableDictionaryRef v30 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v30)
    {
      v31 = v43;
      CFNumberRef v43 = v30;
      valuePtr = v31;
      sub_10005717C((const void **)&valuePtr);
    }
    CFDictionarySetValue(v42, @"alt-server", v43);
    sub_10005717C((const void **)&v43);
  }
  if (*((unsigned char *)a1 + 73))
  {
    uint64_t v32 = v42;
    v33 = &kCFBooleanTrue;
    if (!*((unsigned char *)a1 + 72)) {
      v33 = &kCFBooleanFalse;
    }
    CFBooleanRef v34 = *v33;
    valuePtr = 0;
    sub_100062778((const void **)&valuePtr);
    CFNumberRef v43 = v34;
    valuePtr = 0;
    sub_100062778((const void **)&valuePtr);
    CFDictionarySetValue(v32, @"acct-holder", v34);
    sub_100062778((const void **)&v43);
  }
  v35 = v42;
  v42 = 0;
  sub_10005717C((const void **)&v42);
  return v35;
}

void sub_100C8BAAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, const void *);
  sub_100062778((const void **)va1);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100C8BB64(void *a1, uint64_t a2)
{
  CFMutableArrayRef v4 = sub_10004B96C(a1, (uint64_t)"[CSR: ", 6);
  long long v5 = v4;
  if (!*(_DWORD *)((char *)v4 + *(void *)(*v4 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 24))
    {
      int v6 = *(char *)(a2 + 23);
      if (v6 >= 0) {
        uint64_t v7 = (const char *)a2;
      }
      else {
        uint64_t v7 = *(const char **)a2;
      }
      if (v6 >= 0) {
        uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        uint64_t v8 = *(void *)(a2 + 8);
      }
    }
    else
    {
      uint64_t v7 = "none";
      uint64_t v8 = 4;
    }
    sub_10004B96C(v4, (uint64_t)v7, v8);
  }
  sub_10004B96C(v5, (uint64_t)", ", 2);
  int v9 = sub_10004B96C(a1, (uint64_t)"SIP Reg URI: ", 13);
  int v10 = v9;
  if (!*(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 56))
    {
      int v11 = *(char *)(a2 + 55);
      if (v11 >= 0) {
        CFNumberRef v12 = (const char *)(a2 + 32);
      }
      else {
        CFNumberRef v12 = *(const char **)(a2 + 32);
      }
      if (v11 >= 0) {
        uint64_t v13 = *(unsigned __int8 *)(a2 + 55);
      }
      else {
        uint64_t v13 = *(void *)(a2 + 40);
      }
    }
    else
    {
      CFNumberRef v12 = "none";
      uint64_t v13 = 4;
    }
    sub_10004B96C(v9, (uint64_t)v12, v13);
  }
  sub_10004B96C(v10, (uint64_t)", ", 2);
  uint64_t v14 = sub_10004B96C(a1, (uint64_t)"APN: ", 5);
  CFBooleanRef v15 = v14;
  if (!*(_DWORD *)((char *)v14 + *(void *)(*v14 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 88))
    {
      int v16 = *(char *)(a2 + 87);
      if (v16 >= 0) {
        int v17 = (const char *)(a2 + 64);
      }
      else {
        int v17 = *(const char **)(a2 + 64);
      }
      if (v16 >= 0) {
        uint64_t v18 = *(unsigned __int8 *)(a2 + 87);
      }
      else {
        uint64_t v18 = *(void *)(a2 + 72);
      }
    }
    else
    {
      int v17 = "none";
      uint64_t v18 = 4;
    }
    sub_10004B96C(v14, (uint64_t)v17, v18);
  }
  sub_10004B96C(v15, (uint64_t)", ", 2);
  BOOL v19 = sub_10004B96C(a1, (uint64_t)"SIP Username: ", 14);
  CFMutableArrayRef v20 = v19;
  if (!*(_DWORD *)((char *)v19 + *(void *)(*v19 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 120))
    {
      int v21 = *(char *)(a2 + 119);
      if (v21 >= 0) {
        long long v22 = (const char *)(a2 + 96);
      }
      else {
        long long v22 = *(const char **)(a2 + 96);
      }
      if (v21 >= 0) {
        uint64_t v23 = *(unsigned __int8 *)(a2 + 119);
      }
      else {
        uint64_t v23 = *(void *)(a2 + 104);
      }
    }
    else
    {
      long long v22 = "none";
      uint64_t v23 = 4;
    }
    sub_10004B96C(v19, (uint64_t)v22, v23);
  }
  sub_10004B96C(v20, (uint64_t)", ", 2);
  long long v24 = sub_10004B96C(a1, (uint64_t)"IMSI: ", 6);
  int v25 = v24;
  if (!*(_DWORD *)((char *)v24 + *(void *)(*v24 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 184))
    {
      int v26 = *(char *)(a2 + 183);
      if (v26 >= 0) {
        long long v27 = (const char *)(a2 + 160);
      }
      else {
        long long v27 = *(const char **)(a2 + 160);
      }
      if (v26 >= 0) {
        uint64_t v28 = *(unsigned __int8 *)(a2 + 183);
      }
      else {
        uint64_t v28 = *(void *)(a2 + 168);
      }
    }
    else
    {
      long long v27 = "none";
      uint64_t v28 = 4;
    }
    sub_10004B96C(v24, (uint64_t)v27, v28);
  }
  sub_10004B96C(v25, (uint64_t)", ", 2);
  CFBooleanRef v29 = sub_10004B96C(a1, (uint64_t)"Public ID: ", 11);
  CFMutableDictionaryRef v30 = v29;
  if (!*(_DWORD *)((char *)v29 + *(void *)(*v29 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 216))
    {
      int v31 = *(char *)(a2 + 215);
      if (v31 >= 0) {
        uint64_t v32 = (const char *)(a2 + 192);
      }
      else {
        uint64_t v32 = *(const char **)(a2 + 192);
      }
      if (v31 >= 0) {
        uint64_t v33 = *(unsigned __int8 *)(a2 + 215);
      }
      else {
        uint64_t v33 = *(void *)(a2 + 200);
      }
    }
    else
    {
      uint64_t v32 = "none";
      uint64_t v33 = 4;
    }
    sub_10004B96C(v29, (uint64_t)v32, v33);
  }
  sub_10004B96C(v30, (uint64_t)", ", 2);
  CFBooleanRef v34 = sub_10004B96C(a1, (uint64_t)"Proxy Address: ", 15);
  v35 = v34;
  if (!*(_DWORD *)((char *)v34 + *(void *)(*v34 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 248))
    {
      int v36 = *(char *)(a2 + 247);
      if (v36 >= 0) {
        uint64_t v37 = (const char *)(a2 + 224);
      }
      else {
        uint64_t v37 = *(const char **)(a2 + 224);
      }
      if (v36 >= 0) {
        uint64_t v38 = *(unsigned __int8 *)(a2 + 247);
      }
      else {
        uint64_t v38 = *(void *)(a2 + 232);
      }
    }
    else
    {
      uint64_t v37 = "none";
      uint64_t v38 = 4;
    }
    sub_10004B96C(v34, (uint64_t)v37, v38);
  }
  sub_10004B96C(v35, (uint64_t)"]", 1);
  return a1;
}

uint64_t sub_100C8BF60@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_100C8BB64(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C8C0C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_100C8C0D4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (!sub_100C8C178(a1, a2)
    || !sub_100C8C178(a1 + 32, a2 + 32)
    || !sub_100C8C178(a1 + 64, a2 + 64)
    || !sub_100C8C178(a1 + 96, a2 + 96)
    || !sub_100C8C178(a1 + 128, a2 + 128)
    || !sub_100C8C178(a1 + 160, a2 + 160))
  {
    return 0;
  }

  return sub_100C8C178(a1 + 192, a2 + 192);
}

BOOL sub_100C8C178(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = a2[24];
  BOOL v3 = (v2 | a1[24]) == 0;
  if (a1[24]) {
    BOOL v4 = v2 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v5 = a1[23];
    if ((v5 & 0x80u) == 0) {
      uint64_t v6 = a1[23];
    }
    else {
      uint64_t v6 = *((void *)a1 + 1);
    }
    uint64_t v7 = a2[23];
    int v8 = (char)v7;
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *((void *)a2 + 1);
    }
    if (v6 == v7)
    {
      if (v8 < 0) {
        a2 = *(unsigned __int8 **)a2;
      }
      if ((v5 & 0x80) != 0)
      {
        return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
      }
      else if (a1[23])
      {
        uint64_t v9 = v5 - 1;
        do
        {
          int v11 = *a1++;
          int v10 = v11;
          int v13 = *a2++;
          int v12 = v13;
          BOOL v15 = v9-- != 0;
          BOOL v4 = v10 == v12;
          BOOL v3 = v10 == v12;
        }
        while (v4 && v15);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t sub_100C8C23C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (!sub_100C8C2FC((uint64_t)(a1 + 32), (uint64_t)(a2 + 32))
    || !sub_100C8C178(a1 + 96, a2 + 96)
    || !sub_100C8C3A0((uint64_t)(a1 + 128), (uint64_t)(a2 + 128))
    || !sub_100C8C178(a1 + 160, a2 + 160)
    || !sub_100C8C178(a1 + 192, a2 + 192))
  {
    return 0;
  }
  if (!a1[448])
  {
    if (!a2[448]) {
      goto LABEL_9;
    }
    return 0;
  }
  if (!a2[448] || !sub_100C8C0D4(a1 + 224, a2 + 224)) {
    return 0;
  }
LABEL_9:

  return sub_100C8C2FC((uint64_t)(a1 + 64), (uint64_t)(a2 + 64));
}

uint64_t sub_100C8C2FC(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 24);
  int v4 = *(unsigned __int8 *)(a2 + 24);
  uint64_t result = (v4 | v3) == 0;
  if (v3) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    uint64_t v7 = *(unsigned __int8 **)a1;
    int v8 = *(unsigned __int8 **)(a1 + 8);
    uint64_t v9 = *(unsigned __int8 **)a2;
    if (&v8[-*(void *)a1] == (unsigned __int8 *)(*(void *)(a2 + 8) - *(void *)a2))
    {
      if (v7 == v8)
      {
        return 1;
      }
      else
      {
        do
        {
          uint64_t result = sub_1000609C0((uint64_t)&v10, v7, v9);
          if (!result) {
            break;
          }
          v7 += 24;
          v9 += 24;
        }
        while (v7 != v8);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL sub_100C8C3A0(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 24);
  int v4 = *(unsigned __int8 *)(a2 + 24);
  BOOL result = (v4 | v3) == 0;
  if (v3) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    uint64_t v7 = *(unsigned __int8 **)a1;
    int v8 = *(unsigned __int8 **)(a1 + 8);
    uint64_t v9 = *(unsigned __int8 **)a2;
    if (&v8[-*(void *)a1] == (unsigned __int8 *)(*(void *)(a2 + 8) - *(void *)a2))
    {
      while (v7 != v8)
      {
        BOOL result = sub_100C8C178(v7, v9);
        if (!result) {
          return result;
        }
        char v10 = v7 + 32;
        int v11 = v9 + 32;
        BOOL result = sub_100C8C178(v10, v11);
        if (!result) {
          return result;
        }
        uint64_t v7 = v10 + 32;
        uint64_t v9 = v11 + 32;
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *sub_100C8C448(uint64_t a1, void *a2)
{
  int v4 = sub_10004B96C(a2, (uint64_t)"IMS Cred: ", 10);
  uint64_t v5 = sub_100C8BB64(v4, a1 + 16);
  sub_10004B96C(v5, (uint64_t)", State: ", 9);
  std::ostream::operator<<();
  return a2;
}

void *sub_100C8C4A4(uint64_t a1, void *a2)
{
  int v4 = sub_10004B96C(a2, (uint64_t)"Cert: ", 6);
  uint64_t v5 = v4;
  if (!*(_DWORD *)((char *)v4 + *(void *)(*v4 - 24) + 32))
  {
    if (*(unsigned char *)(a1 + 32))
    {
      int v6 = *(char *)(a1 + 31);
      if (v6 >= 0) {
        uint64_t v7 = (const char *)(a1 + 8);
      }
      else {
        uint64_t v7 = *(const char **)(a1 + 8);
      }
      if (v6 >= 0) {
        uint64_t v8 = *(unsigned __int8 *)(a1 + 31);
      }
      else {
        uint64_t v8 = *(void *)(a1 + 16);
      }
    }
    else
    {
      uint64_t v7 = "none";
      uint64_t v8 = 4;
    }
    sub_10004B96C(v4, (uint64_t)v7, v8);
  }
  uint64_t v9 = sub_10004B96C(v5, (uint64_t)", gateway-local-id: ", 20);
  char v10 = v9;
  if (!*(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 32))
  {
    if (*(unsigned char *)(a1 + 64))
    {
      int v11 = *(char *)(a1 + 63);
      if (v11 >= 0) {
        int v12 = (const char *)(a1 + 40);
      }
      else {
        int v12 = *(const char **)(a1 + 40);
      }
      if (v11 >= 0) {
        uint64_t v13 = *(unsigned __int8 *)(a1 + 63);
      }
      else {
        uint64_t v13 = *(void *)(a1 + 48);
      }
    }
    else
    {
      int v12 = "none";
      uint64_t v13 = 4;
    }
    sub_10004B96C(v9, (uint64_t)v12, v13);
  }
  long long v14 = sub_10004B96C(v10, (uint64_t)", ims-private-identity: ", 24);
  BOOL v15 = v14;
  if (!*(_DWORD *)((char *)v14 + *(void *)(*v14 - 24) + 32))
  {
    if (*(unsigned char *)(a1 + 96))
    {
      int v16 = *(char *)(a1 + 95);
      if (v16 >= 0) {
        long long v17 = (const char *)(a1 + 72);
      }
      else {
        long long v17 = *(const char **)(a1 + 72);
      }
      if (v16 >= 0) {
        uint64_t v18 = *(unsigned __int8 *)(a1 + 95);
      }
      else {
        uint64_t v18 = *(void *)(a1 + 80);
      }
    }
    else
    {
      long long v17 = "none";
      uint64_t v18 = 4;
    }
    sub_10004B96C(v14, (uint64_t)v17, v18);
  }
  BOOL v19 = sub_10004B96C(v15, (uint64_t)", ims-public-identity: ", 23);
  if (!*(_DWORD *)((char *)v19 + *(void *)(*v19 - 24) + 32))
  {
    if (*(unsigned char *)(a1 + 128))
    {
      int v20 = *(char *)(a1 + 127);
      if (v20 >= 0) {
        int v21 = (const char *)(a1 + 104);
      }
      else {
        int v21 = *(const char **)(a1 + 104);
      }
      if (v20 >= 0) {
        uint64_t v22 = *(unsigned __int8 *)(a1 + 127);
      }
      else {
        uint64_t v22 = *(void *)(a1 + 112);
      }
    }
    else
    {
      int v21 = "none";
      uint64_t v22 = 4;
    }
    sub_10004B96C(v19, (uint64_t)v21, v22);
  }
  return a2;
}

void *sub_100C8C6A8(void *a1, _DWORD *a2)
{
  unsigned int v3 = *a2 + 1;
  if (v3 > 4) {
    int v4 = "address status unknown";
  }
  else {
    int v4 = off_101A4D7C8[v3];
  }
  size_t v5 = strlen(v4);
  sub_10004B96C(a1, (uint64_t)v4, v5);
  return a1;
}

void *sub_100C8C70C(void *a1, _DWORD *a2)
{
  unsigned int v3 = *a2 + 1;
  if (v3 > 4) {
    int v4 = "TC status unknown";
  }
  else {
    int v4 = off_101A4D7F0[v3];
  }
  size_t v5 = strlen(v4);
  sub_10004B96C(a1, (uint64_t)v4, v5);
  return a1;
}

void *sub_100C8C770(void *a1, _DWORD *a2)
{
  unsigned int v3 = *a2 + 1;
  if (v3 > 5) {
    int v4 = "provisioning status unknown";
  }
  else {
    int v4 = off_101A4D818[v3];
  }
  size_t v5 = strlen(v4);
  sub_10004B96C(a1, (uint64_t)v4, v5);
  return a1;
}

void *sub_100C8C7D4(void *a1, uint64_t a2)
{
  int v4 = sub_10004B96C(a1, (uint64_t)"[Display Name: ", 15);
  int v5 = *(char *)(a2 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *(void *)a2;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a2 + 8);
  }
  uint64_t v8 = sub_10004B96C(v4, v6, v7);
  uint64_t v9 = sub_10004B96C(v8, (uint64_t)", SIP User Name: ", 17);
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t v11 = a2 + 24;
  uint64_t v10 = v12;
  int v13 = *(char *)(v11 + 23);
  if (v13 >= 0) {
    uint64_t v14 = v11;
  }
  else {
    uint64_t v14 = v10;
  }
  if (v13 >= 0) {
    uint64_t v15 = *(unsigned __int8 *)(v11 + 23);
  }
  else {
    uint64_t v15 = *(void *)(v11 + 8);
  }
  int v16 = sub_10004B96C(v9, v14, v15);
  sub_10004B96C(v16, (uint64_t)"]", 1);
  return a1;
}

void *sub_100C8C868(void *a1, uint64_t a2)
{
  int v4 = sub_10004B96C(a1, (uint64_t)"[", 1);
  int v5 = sub_10004B96C(v4, (uint64_t)"Sub ID: ", 8);
  uint64_t v6 = v5;
  if (!*(_DWORD *)((char *)v5 + *(void *)(*v5 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 24))
    {
      int v7 = *(char *)(a2 + 23);
      if (v7 >= 0) {
        uint64_t v8 = (const char *)a2;
      }
      else {
        uint64_t v8 = *(const char **)a2;
      }
      if (v7 >= 0) {
        uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        uint64_t v9 = *(void *)(a2 + 8);
      }
    }
    else
    {
      uint64_t v8 = "none";
      uint64_t v9 = 4;
    }
    sub_10004B96C(v5, (uint64_t)v8, v9);
  }
  uint64_t v10 = sub_10004B96C(v6, (uint64_t)", ", 2);
  uint64_t v11 = sub_10004B96C(v10, (uint64_t)"Service tokens : ", 17);
  uint64_t v12 = sub_100C8D374(v11, a2 + 32);
  int v13 = sub_10004B96C(v12, (uint64_t)", ", 2);
  uint64_t v14 = sub_10004B96C(v13, (uint64_t)"Subscriber IDs: ", 16);
  uint64_t v15 = sub_100C8D374(v14, a2 + 64);
  int v16 = sub_10004B96C(v15, (uint64_t)", ", 2);
  long long v17 = sub_10004B96C(v16, (uint64_t)"Auth-type: ", 11);
  uint64_t v18 = v17;
  if (!*(_DWORD *)((char *)v17 + *(void *)(*v17 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 120))
    {
      int v19 = *(char *)(a2 + 119);
      if (v19 >= 0) {
        int v20 = (const char *)(a2 + 96);
      }
      else {
        int v20 = *(const char **)(a2 + 96);
      }
      if (v19 >= 0) {
        uint64_t v21 = *(unsigned __int8 *)(a2 + 119);
      }
      else {
        uint64_t v21 = *(void *)(a2 + 104);
      }
    }
    else
    {
      int v20 = "none";
      uint64_t v21 = 4;
    }
    sub_10004B96C(v17, (uint64_t)v20, v21);
  }
  uint64_t v22 = sub_10004B96C(v18, (uint64_t)", ", 2);
  uint64_t v23 = sub_10004B96C(v22, (uint64_t)"MS Chap: ", 9);
  long long v24 = v23;
  if (!*(_DWORD *)((char *)v23 + *(void *)(*v23 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 152))
    {
      sub_10004B96C(v23, (uint64_t)"{", 1);
      uint64_t v25 = *(void *)(a2 + 128);
      uint64_t v26 = *(void *)(a2 + 136);
      if (v25 != v26)
      {
        uint64_t v27 = v25 + 32;
        do
        {
          uint64_t v28 = sub_10004B96C(v24, (uint64_t)"[", 1);
          CFBooleanRef v29 = v28;
          if (!*(_DWORD *)((char *)v28 + *(void *)(*v28 - 24) + 32))
          {
            if (*(unsigned char *)(v27 - 8))
            {
              int v30 = *(char *)(v27 - 9);
              if (v30 >= 0) {
                int v31 = (const char *)(v27 - 32);
              }
              else {
                int v31 = *(const char **)(v27 - 32);
              }
              if (v30 >= 0) {
                uint64_t v32 = *(unsigned __int8 *)(v27 - 9);
              }
              else {
                uint64_t v32 = *(void *)(v27 - 24);
              }
            }
            else
            {
              int v31 = "none";
              uint64_t v32 = 4;
            }
            sub_10004B96C(v28, (uint64_t)v31, v32);
          }
          uint64_t v33 = sub_10004B96C(v29, (uint64_t)", ", 2);
          CFBooleanRef v34 = v33;
          if (!*(_DWORD *)((char *)v33 + *(void *)(*v33 - 24) + 32))
          {
            if (*(unsigned char *)(v27 + 24))
            {
              int v35 = *(char *)(v27 + 23);
              if (v35 >= 0) {
                int v36 = (const char *)v27;
              }
              else {
                int v36 = *(const char **)v27;
              }
              if (v35 >= 0) {
                uint64_t v37 = *(unsigned __int8 *)(v27 + 23);
              }
              else {
                uint64_t v37 = *(void *)(v27 + 8);
              }
            }
            else
            {
              int v36 = "none";
              uint64_t v37 = 4;
            }
            sub_10004B96C(v33, (uint64_t)v36, v37);
          }
          sub_10004B96C(v34, (uint64_t)"], ", 3);
          uint64_t v38 = v27 + 32;
          v27 += 64;
        }
        while (v38 != v26);
      }
      unsigned __int8 v39 = "}";
      uint64_t v23 = v24;
      uint64_t v40 = 1;
    }
    else
    {
      unsigned __int8 v39 = "none";
      uint64_t v40 = 4;
    }
    sub_10004B96C(v23, (uint64_t)v39, v40);
  }
  v41 = sub_10004B96C(v24, (uint64_t)", ", 2);
  v42 = sub_10004B96C(v41, (uint64_t)"Gateway: ", 9);
  CFNumberRef v43 = v42;
  if (!*(_DWORD *)((char *)v42 + *(void *)(*v42 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 184))
    {
      int v44 = *(char *)(a2 + 183);
      if (v44 >= 0) {
        long long v45 = (const char *)(a2 + 160);
      }
      else {
        long long v45 = *(const char **)(a2 + 160);
      }
      if (v44 >= 0) {
        uint64_t v46 = *(unsigned __int8 *)(a2 + 183);
      }
      else {
        uint64_t v46 = *(void *)(a2 + 168);
      }
    }
    else
    {
      long long v45 = "none";
      uint64_t v46 = 4;
    }
    sub_10004B96C(v42, (uint64_t)v45, v46);
  }
  long long v47 = sub_10004B96C(v43, (uint64_t)", ", 2);
  long long v48 = sub_10004B96C(v47, (uint64_t)"EntitlementServerAddress: ", 26);
  long long v49 = v48;
  if (!*(_DWORD *)((char *)v48 + *(void *)(*v48 - 24) + 32))
  {
    if (*(unsigned char *)(a2 + 216))
    {
      int v50 = *(char *)(a2 + 215);
      if (v50 >= 0) {
        long long v51 = (const char *)(a2 + 192);
      }
      else {
        long long v51 = *(const char **)(a2 + 192);
      }
      if (v50 >= 0) {
        uint64_t v52 = *(unsigned __int8 *)(a2 + 215);
      }
      else {
        uint64_t v52 = *(void *)(a2 + 200);
      }
    }
    else
    {
      long long v51 = "none";
      uint64_t v52 = 4;
    }
    sub_10004B96C(v48, (uint64_t)v51, v52);
  }
  long long v53 = sub_10004B96C(v49, (uint64_t)", ", 2);
  uint64_t v54 = sub_10004B96C(v53, (uint64_t)"Cert Info: ", 11);
  if (*(unsigned char *)(a2 + 448))
  {
    uint64_t v115 = 0;
    long long v113 = 0u;
    long long v114 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    long long v106 = 0u;
    long long v104 = 0u;
    long long v105 = 0u;
    *(_OWORD *)std::string __p = 0u;
    memset(v102, 0, sizeof(v102));
    sub_10004DE24((uint64_t)v102);
    v55 = sub_10004B96C(v102, (uint64_t)"[", 1);
    v56 = sub_10004B96C(v55, (uint64_t)"DN: ", 4);
    long long v57 = v56;
    if (!*(_DWORD *)((char *)v56 + *(void *)(*v56 - 24) + 32))
    {
      if (*(unsigned char *)(a2 + 248))
      {
        int v58 = *(char *)(a2 + 247);
        if (v58 >= 0) {
          uint64_t v59 = a2 + 224;
        }
        else {
          uint64_t v59 = *(void *)(a2 + 224);
        }
        if (v58 >= 0) {
          uint64_t v60 = *(unsigned __int8 *)(a2 + 247);
        }
        else {
          uint64_t v60 = *(void *)(a2 + 232);
        }
        sub_10004B96C(v56, v59, v60);
      }
      else
      {
        sub_10004B96C(v56, (uint64_t)"none", 4);
      }
    }
    long long v61 = sub_10004B96C(v57, (uint64_t)", ", 2);
    long long v62 = sub_10004B96C(v61, (uint64_t)"Org: ", 5);
    long long v63 = v62;
    if (!*(_DWORD *)((char *)v62 + *(void *)(*v62 - 24) + 32))
    {
      if (*(unsigned char *)(a2 + 280))
      {
        int v64 = *(char *)(a2 + 279);
        if (v64 >= 0) {
          uint64_t v65 = a2 + 256;
        }
        else {
          uint64_t v65 = *(void *)(a2 + 256);
        }
        if (v64 >= 0) {
          uint64_t v66 = *(unsigned __int8 *)(a2 + 279);
        }
        else {
          uint64_t v66 = *(void *)(a2 + 264);
        }
        sub_10004B96C(v62, v65, v66);
      }
      else
      {
        sub_10004B96C(v62, (uint64_t)"none", 4);
      }
    }
    long long v67 = sub_10004B96C(v63, (uint64_t)", ", 2);
    long long v68 = sub_10004B96C(v67, (uint64_t)"Dept: ", 6);
    uint64_t v69 = v68;
    if (!*(_DWORD *)((char *)v68 + *(void *)(*v68 - 24) + 32))
    {
      if (*(unsigned char *)(a2 + 312))
      {
        int v70 = *(char *)(a2 + 311);
        if (v70 >= 0) {
          uint64_t v71 = a2 + 288;
        }
        else {
          uint64_t v71 = *(void *)(a2 + 288);
        }
        if (v70 >= 0) {
          uint64_t v72 = *(unsigned __int8 *)(a2 + 311);
        }
        else {
          uint64_t v72 = *(void *)(a2 + 296);
        }
        sub_10004B96C(v68, v71, v72);
      }
      else
      {
        sub_10004B96C(v68, (uint64_t)"none", 4);
      }
    }
    v73 = sub_10004B96C(v69, (uint64_t)", ", 2);
    v74 = sub_10004B96C(v73, (uint64_t)"City: ", 6);
    v75 = v74;
    if (!*(_DWORD *)((char *)v74 + *(void *)(*v74 - 24) + 32))
    {
      if (*(unsigned char *)(a2 + 344))
      {
        int v76 = *(char *)(a2 + 343);
        if (v76 >= 0) {
          uint64_t v77 = a2 + 320;
        }
        else {
          uint64_t v77 = *(void *)(a2 + 320);
        }
        if (v76 >= 0) {
          uint64_t v78 = *(unsigned __int8 *)(a2 + 343);
        }
        else {
          uint64_t v78 = *(void *)(a2 + 328);
        }
        sub_10004B96C(v74, v77, v78);
      }
      else
      {
        sub_10004B96C(v74, (uint64_t)"none", 4);
      }
    }
    v79 = sub_10004B96C(v75, (uint64_t)", ", 2);
    v80 = sub_10004B96C(v79, (uint64_t)"State: ", 7);
    v81 = v80;
    if (!*(_DWORD *)((char *)v80 + *(void *)(*v80 - 24) + 32))
    {
      if (*(unsigned char *)(a2 + 376))
      {
        int v82 = *(char *)(a2 + 375);
        if (v82 >= 0) {
          uint64_t v83 = a2 + 352;
        }
        else {
          uint64_t v83 = *(void *)(a2 + 352);
        }
        if (v82 >= 0) {
          uint64_t v84 = *(unsigned __int8 *)(a2 + 375);
        }
        else {
          uint64_t v84 = *(void *)(a2 + 360);
        }
        sub_10004B96C(v80, v83, v84);
      }
      else
      {
        sub_10004B96C(v80, (uint64_t)"none", 4);
      }
    }
    v85 = sub_10004B96C(v81, (uint64_t)", ", 2);
    v86 = sub_10004B96C(v85, (uint64_t)"Country: ", 9);
    v87 = v86;
    if (!*(_DWORD *)((char *)v86 + *(void *)(*v86 - 24) + 32))
    {
      if (*(unsigned char *)(a2 + 408))
      {
        int v88 = *(char *)(a2 + 407);
        if (v88 >= 0) {
          uint64_t v89 = a2 + 384;
        }
        else {
          uint64_t v89 = *(void *)(a2 + 384);
        }
        if (v88 >= 0) {
          uint64_t v90 = *(unsigned __int8 *)(a2 + 407);
        }
        else {
          uint64_t v90 = *(void *)(a2 + 392);
        }
        sub_10004B96C(v86, v89, v90);
      }
      else
      {
        sub_10004B96C(v86, (uint64_t)"none", 4);
      }
    }
    v91 = sub_10004B96C(v87, (uint64_t)", ", 2);
    v92 = sub_10004B96C(v91, (uint64_t)"Email: ", 7);
    v93 = v92;
    if (!*(_DWORD *)((char *)v92 + *(void *)(*v92 - 24) + 32))
    {
      if (*(unsigned char *)(a2 + 440))
      {
        int v94 = *(char *)(a2 + 439);
        if (v94 >= 0) {
          uint64_t v95 = a2 + 416;
        }
        else {
          uint64_t v95 = *(void *)(a2 + 416);
        }
        if (v94 >= 0) {
          uint64_t v96 = *(unsigned __int8 *)(a2 + 439);
        }
        else {
          uint64_t v96 = *(void *)(a2 + 424);
        }
        sub_10004B96C(v92, v95, v96);
      }
      else
      {
        sub_10004B96C(v92, (uint64_t)"none", 4);
      }
    }
    sub_10004B96C(v93, (uint64_t)"]", 1);
    sub_10004BC98((uint64_t)v102 + 8, v100);
    if (SHIBYTE(v104) < 0) {
      operator delete(__p[1]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  else
  {
    sub_100058DB0(v100, "< Not Present >");
  }
  if ((v101 & 0x80u) == 0) {
    v97 = v100;
  }
  else {
    v97 = (void **)v100[0];
  }
  if ((v101 & 0x80u) == 0) {
    uint64_t v98 = v101;
  }
  else {
    uint64_t v98 = (uint64_t)v100[1];
  }
  sub_10004B96C(v54, (uint64_t)v97, v98);
  if ((char)v101 < 0) {
    operator delete(v100[0]);
  }
  sub_10004B96C(v54, (uint64_t)"]", 1);
  return a1;
}

void sub_100C8D274(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100C8D374(void *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v28 = 0;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v19 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    *(_OWORD *)std::string __p = 0u;
    memset(v15, 0, sizeof(v15));
    sub_10004DE24((uint64_t)v15);
    sub_10004B96C(v15, (uint64_t)"{", 1);
    uint64_t v4 = *(void *)a2;
    uint64_t v5 = *(void *)(a2 + 8);
    if (*(void *)a2 != v5)
    {
      do
      {
        int v6 = *(char *)(v4 + 23);
        if (v6 >= 0) {
          uint64_t v7 = v4;
        }
        else {
          uint64_t v7 = *(void *)v4;
        }
        if (v6 >= 0) {
          uint64_t v8 = *(unsigned __int8 *)(v4 + 23);
        }
        else {
          uint64_t v8 = *(void *)(v4 + 8);
        }
        uint64_t v9 = sub_10004B96C(v15, v7, v8);
        sub_10004B96C(v9, (uint64_t)", ", 2);
        v4 += 24;
      }
      while (v4 != v5);
    }
    sub_10004B96C(v15, (uint64_t)"}", 1);
    sub_10004BC98((uint64_t)v15 + 8, v13);
    if (SHIBYTE(v17) < 0) {
      operator delete(__p[1]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
  }
  else
  {
    sub_100058DB0(v13, "< Not Present >");
  }
  if ((v14 & 0x80u) == 0) {
    uint64_t v10 = v13;
  }
  else {
    uint64_t v10 = (void **)v13[0];
  }
  if ((v14 & 0x80u) == 0) {
    uint64_t v11 = v14;
  }
  else {
    uint64_t v11 = (uint64_t)v13[1];
  }
  sub_10004B96C(a1, (uint64_t)v10, v11);
  if ((char)v14 < 0) {
    operator delete(v13[0]);
  }
  return a1;
}

void sub_100C8D5A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C8D6A4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v32 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  *(_OWORD *)long long v20 = 0u;
  long long v21 = 0u;
  memset(v19, 0, sizeof(v19));
  long long v18 = 0u;
  sub_10004BD84((uint64_t)&v18);
  uint64_t v4 = sub_10004B96C(v19, (uint64_t)"[", 1);
  uint64_t v5 = sub_10004B96C(v4, (uint64_t)"Sub ID: ", 8);
  int v6 = v5;
  if (!*(_DWORD *)((char *)v5 + *(void *)(*v5 - 24) + 32))
  {
    if (*(unsigned char *)(a1 + 24))
    {
      int v7 = *(char *)(a1 + 23);
      if (v7 >= 0) {
        uint64_t v8 = a1;
      }
      else {
        uint64_t v8 = *(void *)a1;
      }
      if (v7 >= 0) {
        uint64_t v9 = *(unsigned __int8 *)(a1 + 23);
      }
      else {
        uint64_t v9 = *(void *)(a1 + 8);
      }
      sub_10004B96C(v5, v8, v9);
    }
    else
    {
      sub_10004B96C(v5, (uint64_t)"none", 4);
    }
  }
  uint64_t v10 = sub_10004B96C(v6, (uint64_t)", ", 2);
  uint64_t v11 = sub_10004B96C(v10, (uint64_t)"Service tokens : ", 17);
  uint64_t v12 = sub_100C8D374(v11, a1 + 32);
  sub_10004B96C(v12, (uint64_t)"]", 1);
  sub_10004BC98((uint64_t)v19 + 8, __p);
  if (SHIBYTE(v17) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v35 = v17;
  }
  uint64_t v33 = 0;
  if (SHIBYTE(v35) < 0)
  {
    sub_10004FC84(&v36, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v36 = __dst;
    uint64_t v37 = v35;
  }
  uint64_t v38 = 0;
  if (ctu::cf::convert_copy())
  {
    int v13 = v33;
    uint64_t v33 = v38;
    unsigned __int8 v39 = v13;
    sub_1000558F4(&v39);
  }
  if (SHIBYTE(v37) < 0) {
    operator delete((void *)v36);
  }
  *a2 = v33;
  uint64_t v33 = 0;
  sub_1000558F4(&v33);
  if (SHIBYTE(v35) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
  *(void *)((char *)&v19[-1]
  *(void *)&v19[0] = v14;
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100C8D9D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_1000558F4((const void **)(v16 - 136));
  if (*(char *)(v16 - 105) < 0) {
    operator delete(*(void **)(v16 - 128));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10008248C((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void *sub_100C8DA3C(void *a1, int *a2)
{
  uint64_t v4 = sub_10004B96C(a1, (uint64_t)"[Entitlement topic type: ", 25);
  uint64_t v5 = *a2;
  if (v5 > 0xA) {
    int v6 = "????";
  }
  else {
    int v6 = off_101A4D848[v5];
  }
  size_t v7 = strlen(v6);
  uint64_t v8 = sub_10004B96C(v4, (uint64_t)v6, v7);
  uint64_t v9 = sub_10004B96C(v8, (uint64_t)", Old push token: ", 18);
  uint64_t v10 = v9;
  if (!*(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 32))
  {
    if (*((unsigned char *)a2 + 32))
    {
      int v11 = *((char *)a2 + 31);
      if (v11 >= 0) {
        uint64_t v12 = (const char *)(a2 + 2);
      }
      else {
        uint64_t v12 = (const char *)*((void *)a2 + 1);
      }
      if (v11 >= 0) {
        uint64_t v13 = *((unsigned __int8 *)a2 + 31);
      }
      else {
        uint64_t v13 = *((void *)a2 + 2);
      }
    }
    else
    {
      uint64_t v12 = "none";
      uint64_t v13 = 4;
    }
    sub_10004B96C(v9, (uint64_t)v12, v13);
  }
  uint64_t v14 = sub_10004B96C(v10, (uint64_t)", New push token: ", 18);
  if (!*(_DWORD *)((char *)v14 + *(void *)(*v14 - 24) + 32))
  {
    if (*((unsigned char *)a2 + 64))
    {
      int v15 = *((char *)a2 + 63);
      if (v15 >= 0) {
        uint64_t v16 = (const char *)(a2 + 10);
      }
      else {
        uint64_t v16 = (const char *)*((void *)a2 + 5);
      }
      if (v15 >= 0) {
        uint64_t v17 = *((unsigned __int8 *)a2 + 63);
      }
      else {
        uint64_t v17 = *((void *)a2 + 6);
      }
    }
    else
    {
      uint64_t v16 = "none";
      uint64_t v17 = 4;
    }
    sub_10004B96C(v14, (uint64_t)v16, v17);
  }
  return a1;
}

void *sub_100C8DB9C(void *a1, int **a2)
{
  sub_10004B96C(a1, (uint64_t)"{", 1);
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    do
    {
      int v6 = sub_10004B96C(a1, (uint64_t)"[", 1);
      size_t v7 = sub_100C8DA3C(v6, v4);
      sub_10004B96C(v7, (uint64_t)"]", 1);
      v4 += 18;
    }
    while (v4 != v5);
  }
  sub_10004B96C(a1, (uint64_t)"}", 1);
  return a1;
}

void *sub_100C8DC44(void *a1, int *a2)
{
  uint64_t v4 = sub_10004B96C(a1, (uint64_t)"[Entitlement topic type: ", 25);
  uint64_t v5 = *a2;
  if (v5 > 0xA) {
    int v6 = "????";
  }
  else {
    int v6 = off_101A4D848[v5];
  }
  size_t v7 = strlen(v6);
  uint64_t v8 = sub_10004B96C(v4, (uint64_t)v6, v7);
  uint64_t v9 = sub_10004B96C(v8, (uint64_t)", Push token: ", 14);
  if (!*(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 32))
  {
    if (*((unsigned char *)a2 + 32))
    {
      int v10 = *((char *)a2 + 31);
      if (v10 >= 0) {
        int v11 = (const char *)(a2 + 2);
      }
      else {
        int v11 = (const char *)*((void *)a2 + 1);
      }
      if (v10 >= 0) {
        uint64_t v12 = *((unsigned __int8 *)a2 + 31);
      }
      else {
        uint64_t v12 = *((void *)a2 + 2);
      }
    }
    else
    {
      int v11 = "none";
      uint64_t v12 = 4;
    }
    sub_10004B96C(v9, (uint64_t)v11, v12);
  }
  return a1;
}

void *sub_100C8DD2C(void *a1, int **a2)
{
  sub_10004B96C(a1, (uint64_t)"{", 1);
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    do
    {
      int v6 = sub_10004B96C(a1, (uint64_t)"[", 1);
      size_t v7 = sub_100C8DC44(v6, v4);
      sub_10004B96C(v7, (uint64_t)"]", 1);
      v4 += 10;
    }
    while (v4 != v5);
  }
  sub_10004B96C(a1, (uint64_t)"}", 1);
  return a1;
}

uint64_t sub_100C8DDD4(unint64_t *a1)
{
  int v1 = *((char *)a1 + 23);
  uint64_t v2 = a1[1];
  if (v1 >= 0) {
    uint64_t v2 = *((unsigned __int8 *)a1 + 23);
  }
  unsigned __int8 v3 = 4;
  if (v2 > 16)
  {
    if (v2 == 17)
    {
      if (v1 >= 0) {
        int v11 = a1;
      }
      else {
        int v11 = (unint64_t *)*a1;
      }
      unint64_t v12 = 0x56564D2D53455256;
      unint64_t v13 = bswap64(*v11);
      if (v13 == 0x56564D2D53455256
        && (unint64_t v12 = 0x45524348414E4745, v13 = bswap64(v11[1]), v13 == 0x45524348414E4745))
      {
        int v14 = *((unsigned __int8 *)v11 + 16) - 68;
      }
      else if (v13 < v12)
      {
        int v14 = -1;
      }
      else
      {
        int v14 = 1;
      }
      if (v14) {
        return 4;
      }
      else {
        return 3;
      }
    }
    else if (v2 == 19)
    {
      uint64_t v5 = (void *)*a1;
      if (v1 >= 0) {
        uint64_t v5 = a1;
      }
      if (*v5 ^ 0x454552472D4D5656 | v5[1] ^ 0x4E414843474E4954 | *(void *)((char *)v5 + 11) ^ 0x4445474E41484347) {
        return 4;
      }
      else {
        return 2;
      }
    }
  }
  else if (v2 == 9)
  {
    int v6 = (uint64_t *)*a1;
    if (v1 >= 0) {
      int v6 = (uint64_t *)a1;
    }
    uint64_t v7 = *v6;
    int v8 = *((unsigned __int8 *)v6 + 8);
    BOOL v10 = v7 != 0x544154532D4D5656 || v8 != 69;
    return (4 * v10);
  }
  else if (v2 == 14)
  {
    uint64_t v4 = (void *)*a1;
    if (v1 >= 0) {
      uint64_t v4 = a1;
    }
    if (*v4 ^ 0x584F424D2D4D5656 | *(void *)((char *)v4 + 6) ^ 0x455441445055584FLL) {
      return 4;
    }
    else {
      return 1;
    }
  }
  return v3;
}

void *sub_100C8DF84@<X0>(void *result@<X0>, void *a2@<X8>)
{
  switch((int)result)
  {
    case 0:
      uint64_t v2 = "VVM-STATE";
      goto LABEL_7;
    case 1:
      uint64_t v2 = "VVM-MBOXUPDATE";
      goto LABEL_7;
    case 2:
      uint64_t v2 = "VVM-GREETINGCHANGED";
      goto LABEL_7;
    case 3:
      uint64_t v2 = "VVM-SERVERCHANGED";
LABEL_7:
      BOOL result = sub_100058DB0(a2, v2);
      break;
    default:
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      break;
  }
  return result;
}

std::string *sub_100C8E000@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  BOOL result = (std::string *)sub_100C8DF84(a1, (void *)a2);
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  BOOL v5 = (v4 & 0x80u) != 0;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a2 + 8);
  }
  if (v5) {
    int v6 = *(std::string **)a2;
  }
  else {
    int v6 = (std::string *)a2;
  }
  if (v4 >= 4)
  {
    uint64_t v7 = (std::string *)((char *)v6 + v4);
    BOOL result = v6;
    do
    {
      BOOL result = (std::string *)memchr(result, 86, v4 - 3);
      if (!result) {
        break;
      }
      if (LODWORD(result->__r_.__value_.__l.__data_) == 760043094)
      {
        if (result != v7 && result == v6) {
          return std::string::erase((std::string *)a2, 0, 4uLL);
        }
        return result;
      }
      BOOL result = (std::string *)((char *)result + 1);
      uint64_t v4 = (char *)v7 - (char *)result;
    }
    while ((char *)v7 - (char *)result >= 4);
  }
  return result;
}

void sub_100C8E0B4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100C8E0D0(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_10004B96C(a1, (uint64_t)"{ mcc: ", 7);
  int v5 = *(char *)(a2 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *(void *)a2;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a2 + 8);
  }
  int v8 = sub_10004B96C(v4, v6, v7);
  uint64_t v9 = sub_10004B96C(v8, (uint64_t)", mnc: ", 7);
  if (*(unsigned char *)(a2 + 48))
  {
    if (*(char *)(a2 + 47) < 0)
    {
      sub_10004FC84(__p, *(void **)(a2 + 24), *(void *)(a2 + 32));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 24);
      uint64_t v15 = *(void *)(a2 + 40);
    }
  }
  else
  {
    sub_100058DB0(__p, "*");
  }
  if (v15 >= 0) {
    BOOL v10 = __p;
  }
  else {
    BOOL v10 = (void **)__p[0];
  }
  if (v15 >= 0) {
    uint64_t v11 = HIBYTE(v15);
  }
  else {
    uint64_t v11 = (uint64_t)__p[1];
  }
  unint64_t v12 = sub_10004B96C(v9, (uint64_t)v10, v11);
  sub_10004B96C(v12, (uint64_t)" }", 2);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_100C8E1D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100C8E1F0(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_10004B96C(a1, (uint64_t)"{ plmn: ", 8);
  int v5 = sub_100C8E0D0(v4, a2);
  sub_10004B96C(v5, (uint64_t)", rat-mask: ", 12);
  uint64_t v6 = (void *)std::ostream::operator<<();
  sub_10004B96C(v6, (uint64_t)", priority: ", 12);
  uint64_t v7 = (void *)std::ostream::operator<<();
  sub_10004B96C(v7, (uint64_t)" }", 2);
  return a1;
}

void *sub_100C8E27C(void *a1, uint64_t *a2)
{
  sub_10004B96C(a1, (uint64_t)"[ ", 2);
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    do
    {
      uint64_t v6 = sub_100C8E1F0(a1, v4);
      sub_10004B96C(v6, (uint64_t)", ", 2);
      v4 += 72;
    }
    while (v4 != v5);
  }
  sub_10004B96C(a1, (uint64_t)" ]", 2);
  return a1;
}

void *sub_100C8E308(void *a1, uint64_t *a2)
{
  memset(v14, 0, sizeof(v14));
  sub_10004B96C(a1, (uint64_t)"{ ", 2);
  uint64_t v4 = sub_10004B96C(a1, (uint64_t)"unlimited: ", 11);
  if (*((unsigned char *)a2 + 24)) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = v14;
  }
  uint64_t v6 = sub_100C8E27C(v4, v5);
  sub_10004B96C(v6, (uint64_t)", ", 2);
  uint64_t v7 = sub_10004B96C(a1, (uint64_t)"metered: ", 9);
  if (*((unsigned char *)a2 + 56)) {
    int v8 = a2 + 4;
  }
  else {
    int v8 = v14;
  }
  uint64_t v9 = sub_100C8E27C(v7, v8);
  sub_10004B96C(v9, (uint64_t)", ", 2);
  BOOL v10 = sub_10004B96C(a1, (uint64_t)"others: ", 8);
  if (*((unsigned char *)a2 + 88)) {
    uint64_t v11 = a2 + 8;
  }
  else {
    uint64_t v11 = v14;
  }
  unint64_t v12 = sub_100C8E27C(v10, v11);
  sub_10004B96C(v12, (uint64_t)" ", 1);
  sub_10004B96C(a1, (uint64_t)" }", 2);
  return a1;
}

uint64_t sub_100C8E414@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_100C8E308(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C8E574(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_100C8E588(uint64_t a1, uint64_t a2)
{
  BOOL result = sub_100C8E5F8((unsigned __int8 *)a1, (unsigned __int8 *)a2);
  if (result)
  {
    if (*(_DWORD *)(a1 + 56) == *(_DWORD *)(a2 + 56))
    {
      BOOL result = (*(unsigned __int8 *)(a2 + 64) | *(unsigned __int8 *)(a1 + 64)) == 0;
      if (*(unsigned char *)(a1 + 64))
      {
        if (*(unsigned char *)(a2 + 64)) {
          return *(_DWORD *)(a1 + 60) == *(_DWORD *)(a2 + 60);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL sub_100C8E5F8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  uint64_t v6 = a2;
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0)
  {
    if (!memcmp(*(const void **)a1, a2, *((void *)a1 + 1))) {
      goto LABEL_17;
    }
    return 0;
  }
  if (a1[23])
  {
    long long v8 = a1;
    while (*v8 == *a2)
    {
      ++v8;
      ++a2;
      if (!--v2) {
        goto LABEL_17;
      }
    }
    return 0;
  }
LABEL_17:

  return sub_100C8C178(a1 + 24, v6 + 24);
}

void sub_100C8E6BC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v2 = (void **)a1;
    sub_10019E86C(&v2);
    *(unsigned char *)(a1 + 24) = 0;
  }
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = (void **)(a1 + 32);
    sub_10019E86C(&v2);
    *(unsigned char *)(a1 + 56) = 0;
  }
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v2 = (void **)(a1 + 64);
    sub_10019E86C(&v2);
    *(unsigned char *)(a1 + 88) = 0;
  }
}

BOOL sub_100C8E734(uint64_t a1, uint64_t a2)
{
  if (!sub_100C8E798(a1, a2) || !sub_100C8E798(a1 + 32, a2 + 32)) {
    return 0;
  }

  return sub_100C8E798(a1 + 64, a2 + 64);
}

BOOL sub_100C8E798(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 24);
  int v4 = *(unsigned __int8 *)(a2 + 24);
  BOOL result = (v4 | v3) == 0;
  if (v3) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    uint64_t v7 = *(void *)a1;
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = *(void *)a2;
    if (v8 - *(void *)a1 == *(void *)(a2 + 8) - *(void *)a2)
    {
      if (v7 == v8)
      {
        return 1;
      }
      else
      {
        do
        {
          BOOL result = sub_100C8E588(v7, v9);
          if (!result) {
            break;
          }
          v7 += 72;
          v9 += 72;
        }
        while (v7 != v8);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

__CFArray *sub_100C8E830@<X0>(uint64_t *a1@<X0>, __CFArray **a2@<X8>)
{
  *a2 = 0;
  BOOL result = CFArrayCreateMutable(kCFAllocatorDefault, 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3), &kCFTypeArrayCallBacks);
  *a2 = result;
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  if (*a1 != v6)
  {
    uint64_t v7 = result;
    do
    {
      CFDictionaryRef v32 = 0;
      CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionaryRef v32 = Mutable;
      CFDictionaryRef v9 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionaryRef theDict = v9;
      if (*(char *)(v5 + 23) < 0)
      {
        unint64_t v11 = *(void *)(v5 + 8);
        if (!v11) {
          goto LABEL_29;
        }
        CFStringRef theString = 0;
        sub_10004FC84(__dst, *(void **)v5, v11);
      }
      else
      {
        if (!*(unsigned char *)(v5 + 23)) {
          goto LABEL_29;
        }
        uint64_t v10 = *(void *)(v5 + 16);
        *(_OWORD *)long long __dst = *(_OWORD *)v5;
        uint64_t v38 = v10;
        CFStringRef theString = 0;
      }
      if (SHIBYTE(v38) < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)__dst;
        uint64_t v41 = v38;
      }
      CFStringRef v44 = 0;
      if (SHIBYTE(v41) < 0)
      {
        sub_10004FC84(&valuePtr, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        long long valuePtr = *(_OWORD *)__p;
        uint64_t v43 = v41;
      }
      CFStringRef v45 = 0;
      if (ctu::cf::convert_copy())
      {
        CFStringRef v12 = v44;
        CFStringRef v44 = v45;
        v34[0] = (void *)v12;
        sub_1000558F4((const void **)v34);
      }
      if (SHIBYTE(v43) < 0) {
        operator delete((void *)valuePtr);
      }
      CFStringRef theString = v44;
      CFStringRef v44 = 0;
      sub_1000558F4((const void **)&v44);
      if (SHIBYTE(v41) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v38) < 0) {
        operator delete(__dst[0]);
      }
      if (theString) {
        long long v13 = sub_1000810B8;
      }
      else {
        long long v13 = 0;
      }
      if (v13 && CFStringGetLength(theString)) {
        CFDictionarySetValue(v9, @"kCarrierPLMNPriorityMCC", theString);
      }
      sub_1000558F4((const void **)&theString);
LABEL_29:
      if (*(unsigned char *)(v5 + 48))
      {
        long long v14 = (void **)(v5 + 24);
        if (*(char *)(v5 + 47) < 0)
        {
          unint64_t v16 = *(void *)(v5 + 32);
          if (v16)
          {
            sub_10004FC84(v34, *v14, v16);
            goto LABEL_35;
          }
        }
        else if (*(unsigned char *)(v5 + 47))
        {
          uint64_t v15 = *(void *)(v5 + 40);
          *(_OWORD *)CFBooleanRef v34 = *(_OWORD *)v14;
          uint64_t v35 = v15;
          value = 0;
LABEL_35:
          if (SHIBYTE(v35) < 0)
          {
            sub_10004FC84(__p, v34[0], (unint64_t)v34[1]);
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)v34;
            uint64_t v41 = v35;
          }
          CFStringRef theString = 0;
          if (SHIBYTE(v41) < 0)
          {
            sub_10004FC84(&valuePtr, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            long long valuePtr = *(_OWORD *)__p;
            uint64_t v43 = v41;
          }
          CFStringRef v44 = 0;
          if (ctu::cf::convert_copy())
          {
            CFStringRef v17 = theString;
            CFStringRef theString = v44;
            CFStringRef v45 = v17;
            sub_1000558F4((const void **)&v45);
          }
          if (SHIBYTE(v43) < 0) {
            operator delete((void *)valuePtr);
          }
          CFStringRef v18 = theString;
          value = (void *)theString;
          CFStringRef theString = 0;
          sub_1000558F4((const void **)&theString);
          if (SHIBYTE(v41) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v35) < 0) {
            operator delete(v34[0]);
          }
          if (v18) {
            long long v19 = sub_1000810B8;
          }
          else {
            long long v19 = 0;
          }
          if (v19 && CFStringGetLength(v18)) {
            CFDictionarySetValue(v9, @"kCarrierPLMNPriorityMNC", value);
          }
          sub_1000558F4((const void **)&value);
        }
      }
      if (theDict) {
        long long v20 = sub_1000C06D0;
      }
      else {
        long long v20 = 0;
      }
      if (v20 && CFDictionaryGetCount(theDict)) {
        CFDictionarySetValue(Mutable, @"kCarrierPLMNPriorityPLMN", theDict);
      }
      uint64_t v21 = *(unsigned int *)(v5 + 56);
      __p[0] = 0;
      *(void *)&long long valuePtr = v21;
      CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
      if (v22)
      {
        long long v23 = __p[0];
        __p[0] = v22;
        *(void *)&long long valuePtr = v23;
        sub_1000570E8((const void **)&valuePtr);
      }
      long long v24 = __p[0];
      __dst[0] = __p[0];
      __p[0] = 0;
      sub_1000570E8((const void **)__p);
      if (v24) {
        long long v25 = sub_100081E58;
      }
      else {
        long long v25 = 0;
      }
      if (v25) {
        CFDictionarySetValue(Mutable, @"kCarrierPLMNPriorityRatMask", v24);
      }
      if (*(unsigned char *)(v5 + 64))
      {
        uint64_t v26 = *(unsigned int *)(v5 + 60);
        __p[0] = 0;
        *(void *)&long long valuePtr = v26;
        CFNumberRef v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
        if (v27)
        {
          long long v28 = __p[0];
          __p[0] = v27;
          *(void *)&long long valuePtr = v28;
          sub_1000570E8((const void **)&valuePtr);
        }
        long long v29 = __p[0];
        v34[0] = __p[0];
        __p[0] = 0;
        sub_1000570E8((const void **)__p);
        if (v29) {
          long long v30 = sub_100081E58;
        }
        else {
          long long v30 = 0;
        }
        if (v30) {
          CFDictionarySetValue(Mutable, @"kCarrierPLMNPriorityValue", v29);
        }
        sub_1000570E8((const void **)v34);
      }
      sub_1000570E8((const void **)__dst);
      sub_10005717C((const void **)&theDict);
      if (v32) {
        long long v31 = sub_1000C06D0;
      }
      else {
        long long v31 = 0;
      }
      if (v31)
      {
        if (CFDictionaryGetCount(v32)) {
          CFArrayAppendValue(v7, v32);
        }
      }
      BOOL result = (__CFArray *)sub_10005717C((const void **)&v32);
      v5 += 72;
    }
    while (v5 != v6);
  }
  return result;
}

void sub_100C8ED88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, const void *a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,const void *a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_10005717C(&a16);
  sub_10005717C(&a15);
  sub_1000440D4(a10);
  _Unwind_Resume(a1);
}

void sub_100C8EECC(uint64_t *a1, CFArrayRef theArray)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
      CFDictionaryRef v7 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeID v8 = CFGetTypeID(ValueAtIndex);
        if (v8 == CFDictionaryGetTypeID())
        {
          uint64_t v32 = 0;
          long long v30 = 0u;
          long long v31 = 0u;
          *(_OWORD *)long long v28 = 0u;
          *(_OWORD *)long long v29 = 0u;
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v7, @"kCarrierPLMNPriorityPLMN");
          CFDictionaryRef v10 = Value;
          if (Value)
          {
            CFTypeID v11 = CFGetTypeID(Value);
            if (v11 == CFDictionaryGetTypeID())
            {
              uint64_t v35 = 0;
              long long v34 = 0u;
              memset(v33, 0, sizeof(v33));
              CFStringRef v12 = CFDictionaryGetValue(v10, @"kCarrierPLMNPriorityMCC");
              if (v12)
              {
                CFTypeID v13 = CFGetTypeID(v12);
                if (v13 == CFStringGetTypeID())
                {
                  long long v36 = 0;
                  long long v37 = 0uLL;
                  ctu::cf::assign();
                  v33[1] = (void *)v37;
                  *(void **)((char *)&v33[1] + 7) = *(void **)((char *)&v37 + 7);
                  v33[0] = v36;
                  HIBYTE(v33[2]) = HIBYTE(v37);
                }
              }
              long long v14 = CFDictionaryGetValue(v10, @"kCarrierPLMNPriorityMNC");
              if (v14)
              {
                CFTypeID v15 = CFGetTypeID(v14);
                if (v15 == CFStringGetTypeID())
                {
                  long long v36 = 0;
                  long long v37 = 0uLL;
                  ctu::cf::assign();
                  unint64_t v16 = v36;
                  v38[0] = v37;
                  *(void *)((char *)v38 + 7) = *(void *)((char *)&v37 + 7);
                  char v17 = HIBYTE(v37);
                  if ((_BYTE)v35)
                  {
                    if (SHIBYTE(v34) < 0) {
                      operator delete(v33[3]);
                    }
                    v33[3] = v16;
                    *(void *)&long long v34 = v38[0];
                    *(void *)((char *)&v34 + 7) = *(void *)((char *)v38 + 7);
                    HIBYTE(v34) = v17;
                  }
                  else
                  {
                    v33[3] = v36;
                    *(void *)&long long v34 = v38[0];
                    *(void *)((char *)&v34 + 7) = *(void *)((char *)v38 + 7);
                    HIBYTE(v34) = HIBYTE(v37);
                    LOBYTE(v35) = 1;
                  }
                }
              }
              *(_OWORD *)long long v28 = *(_OWORD *)v33;
              v29[0] = v33[2];
              HIBYTE(v33[2]) = 0;
              LOBYTE(v33[0]) = 0;
              sub_100179CB0((uint64_t)&v29[1], (__n128 *)&v33[3]);
              if ((_BYTE)v35 && SHIBYTE(v34) < 0) {
                operator delete(v33[3]);
              }
              if (SHIBYTE(v33[2]) < 0) {
                operator delete(v33[0]);
              }
            }
          }
          CFStringRef v18 = (unsigned int *)CFDictionaryGetValue(v7, @"kCarrierPLMNPriorityRatMask");
          long long v19 = v18;
          if (v18)
          {
            CFTypeID v20 = CFGetTypeID(v18);
            if (v20 == CFNumberGetTypeID())
            {
              LODWORD(v33[0]) = 0;
              ctu::cf::assign((ctu::cf *)v33, v19, v21);
              DWORD2(v31) = v33[0];
            }
          }
          CFNumberRef v22 = (unsigned int *)CFDictionaryGetValue(v7, @"kCarrierPLMNPriorityValue");
          long long v23 = v22;
          if (v22)
          {
            CFTypeID v24 = CFGetTypeID(v22);
            if (v24 == CFNumberGetTypeID())
            {
              LODWORD(v33[0]) = 0;
              ctu::cf::assign((ctu::cf *)v33, v23, v25);
              HIDWORD(v31) = v33[0];
              LOBYTE(v32) = 1;
            }
          }
          unint64_t v26 = a1[1];
          if (v26 >= a1[2])
          {
            uint64_t v27 = sub_100C9238C(a1, (long long *)v28);
          }
          else
          {
            sub_100C924AC((void *)a1[1], (long long *)v28);
            uint64_t v27 = v26 + 72;
            a1[1] = v26 + 72;
          }
          a1[1] = v27;
          if ((_BYTE)v31 && SHIBYTE(v30) < 0) {
            operator delete(v29[1]);
          }
          if (SHIBYTE(v29[0]) < 0) {
            operator delete(v28[0]);
          }
        }
      }
    }
  }
}

void sub_100C8F2B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  if (*(char *)(v27 - 121) < 0) {
    operator delete(*(void **)(v27 - 144));
  }
  sub_1001F8E8C((uint64_t)&a27);
  sub_1001F8E8C((uint64_t)&a17);
  sub_10019E86C(&a17);
  _Unwind_Resume(a1);
}

const void **sub_100C8F340@<X0>(uint64_t a1@<X0>, const void ***a2@<X8>)
{
  *a2 = 0;
  BOOL result = (const void **)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v5 = (__CFDictionary *)result;
  *a2 = result;
  if (*(unsigned char *)(a1 + 24))
  {
    CFArrayRef theArray = 0;
    sub_100C8E830((uint64_t *)a1, &theArray);
    if (CFArrayGetCount(theArray)) {
      CFDictionarySetValue(v5, @"kCarrierPLMNPriorityUnlimited", theArray);
    }
    BOOL result = sub_1000440D4((const void **)&theArray);
  }
  if (*(unsigned char *)(a1 + 56))
  {
    CFArrayRef theArray = 0;
    sub_100C8E830((uint64_t *)(a1 + 32), &theArray);
    if (CFArrayGetCount(theArray)) {
      CFDictionarySetValue(v5, @"kCarrierPLMNPriorityMetered", theArray);
    }
    BOOL result = sub_1000440D4((const void **)&theArray);
  }
  if (*(unsigned char *)(a1 + 88))
  {
    CFArrayRef theArray = 0;
    sub_100C8E830((uint64_t *)(a1 + 64), &theArray);
    if (CFArrayGetCount(theArray)) {
      CFDictionarySetValue(v5, @"kCarrierPLMNPriorityOthers", theArray);
    }
    return sub_1000440D4((const void **)&theArray);
  }
  return result;
}

void sub_100C8F470(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

void sub_100C8F4A4(const __CFDictionary *a1@<X0>, _OWORD *a2@<X8>)
{
  a2[2] = 0u;
  uint64_t v4 = (uint64_t)(a2 + 2);
  a2[4] = 0u;
  uint64_t v5 = (uint64_t)(a2 + 4);
  a2[5] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a1, @"kCarrierPLMNPriorityUnlimited");
  CFArrayRef v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFArrayGetTypeID())
    {
      sub_100C8EECC(v15, v7);
      sub_100C8F638((uint64_t)a2, (uint64_t)v15);
      unint64_t v16 = (void **)v15;
      sub_10019E86C(&v16);
    }
  }
  CFArrayRef v9 = (const __CFArray *)CFDictionaryGetValue(a1, @"kCarrierPLMNPriorityMetered");
  CFArrayRef v10 = v9;
  if (v9)
  {
    CFTypeID v11 = CFGetTypeID(v9);
    if (v11 == CFArrayGetTypeID())
    {
      sub_100C8EECC(v15, v10);
      sub_100C8F638(v4, (uint64_t)v15);
      unint64_t v16 = (void **)v15;
      sub_10019E86C(&v16);
    }
  }
  CFArrayRef v12 = (const __CFArray *)CFDictionaryGetValue(a1, @"kCarrierPLMNPriorityOthers");
  CFArrayRef v13 = v12;
  if (v12)
  {
    CFTypeID v14 = CFGetTypeID(v12);
    if (v14 == CFArrayGetTypeID())
    {
      sub_100C8EECC(v15, v13);
      sub_100C8F638(v5, (uint64_t)v15);
      unint64_t v16 = (void **)v15;
      sub_10019E86C(&v16);
    }
  }
}

void sub_100C8F610(_Unwind_Exception *a1)
{
  sub_10018A0E8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100C8F638(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_1001A085C((void **)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t sub_100C8F6B4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v58 = 0;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  *(_OWORD *)uint64_t v46 = 0u;
  long long v47 = 0u;
  memset(v45, 0, sizeof(v45));
  long long v44 = 0u;
  sub_10004BD84((uint64_t)&v44);
  uint64_t v4 = sub_10004B96C(v45, (uint64_t)"max:", 4);
  if (!*(_DWORD *)((char *)v4 + *(void *)(*v4 - 24) + 32))
  {
    if (*(unsigned char *)(a1 + 4)) {
      std::ostream::operator<<();
    }
    else {
      sub_10004B96C(v4, (uint64_t)"none", 4);
    }
  }
  if (*(unsigned char *)(a1 + 32)) {
    uint64_t v5 = (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 7;
  }
  else {
    uint64_t v5 = 0;
  }
  sub_10004B96C(v45, (uint64_t)" devices:", 9);
  std::ostream::operator<<();
  if (v5)
  {
    sub_10004B96C(v45, (uint64_t)" [", 2);
    uint64_t v6 = 120;
    do
    {
      uint64_t v9 = *(void *)(a1 + 8);
      uint64_t v73 = 0;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      memset(v60, 0, sizeof(v60));
      long long v59 = 0u;
      sub_10004BD84((uint64_t)&v59);
      sub_10004B96C(v60, (uint64_t)"{", 1);
      CFArrayRef v10 = sub_10004B96C(v60, (uint64_t)" id:", 4);
      if (!*(_DWORD *)((char *)v10 + *(void *)(*v10 - 24) + 32))
      {
        uint64_t v11 = v9 + v6;
        if (*(unsigned char *)(v9 + v6 - 96))
        {
          uint64_t v12 = *(unsigned __int8 *)(v11 - 97);
          uint64_t v13 = *(void *)(v11 - 112);
          if ((v12 & 0x80u) == 0) {
            uint64_t v14 = v9 + v6 - 120;
          }
          else {
            uint64_t v14 = *(void *)(v9 + v6 - 120);
          }
          if ((v12 & 0x80u) == 0) {
            uint64_t v15 = v12;
          }
          else {
            uint64_t v15 = v13;
          }
          sub_10004B96C(v10, v14, v15);
        }
        else
        {
          sub_10004B96C(v10, (uint64_t)"none", 4);
        }
      }
      unint64_t v16 = sub_10004B96C(v60, (uint64_t)" name:", 6);
      if (!*(_DWORD *)((char *)v16 + *(void *)(*v16 - 24) + 32))
      {
        uint64_t v17 = v9 + v6;
        if (*(unsigned char *)(v9 + v6 - 64))
        {
          int v18 = *(char *)(v9 + v6 - 65);
          uint64_t v21 = *(void *)(v17 - 88);
          uint64_t v19 = v17 - 88;
          uint64_t v20 = v21;
          if (v18 >= 0) {
            uint64_t v22 = v19;
          }
          else {
            uint64_t v22 = v20;
          }
          if (v18 >= 0) {
            uint64_t v23 = *(unsigned __int8 *)(v9 + v6 - 65);
          }
          else {
            uint64_t v23 = *(void *)(v9 + v6 - 80);
          }
          sub_10004B96C(v16, v22, v23);
        }
        else
        {
          sub_10004B96C(v16, (uint64_t)"none", 4);
        }
      }
      CFTypeID v24 = sub_10004B96C(v60, (uint64_t)" impu:", 6);
      if (!*(_DWORD *)((char *)v24 + *(void *)(*v24 - 24) + 32))
      {
        uint64_t v25 = v9 + v6;
        if (*(unsigned char *)(v9 + v6 - 32))
        {
          int v26 = *(char *)(v9 + v6 - 33);
          uint64_t v29 = *(void *)(v25 - 56);
          uint64_t v27 = v25 - 56;
          uint64_t v28 = v29;
          if (v26 >= 0) {
            uint64_t v30 = v27;
          }
          else {
            uint64_t v30 = v28;
          }
          if (v26 >= 0) {
            uint64_t v31 = *(unsigned __int8 *)(v9 + v6 - 33);
          }
          else {
            uint64_t v31 = *(void *)(v9 + v6 - 48);
          }
          sub_10004B96C(v24, v30, v31);
        }
        else
        {
          sub_10004B96C(v24, (uint64_t)"none", 4);
        }
      }
      uint64_t v32 = sub_10004B96C(v60, (uint64_t)" impi:", 6);
      if (!*(_DWORD *)((char *)v32 + *(void *)(*v32 - 24) + 32))
      {
        if (*(unsigned char *)(v9 + v6))
        {
          int v33 = *(char *)(v9 + v6 - 1);
          if (v33 >= 0) {
            uint64_t v34 = v9 + v6 - 24;
          }
          else {
            uint64_t v34 = *(void *)(v9 + v6 - 24);
          }
          if (v33 >= 0) {
            uint64_t v35 = *(unsigned __int8 *)(v9 + v6 - 1);
          }
          else {
            uint64_t v35 = *(void *)(v9 + v6 - 16);
          }
          sub_10004B96C(v32, v34, v35);
        }
        else
        {
          sub_10004B96C(v32, (uint64_t)"none", 4);
        }
      }
      sub_10004B96C(v60, (uint64_t)" }", 2);
      sub_10004BC98((uint64_t)&v60[1], v42);
      *(void *)&long long v59 = v41;
      *(void *)((char *)&v60[-2] + *(v41 - 3)) = v7;
      v60[0] = v8;
      if (SHIBYTE(v62) < 0) {
        operator delete(*((void **)&v61 + 1));
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      std::ios::~ios();
      if ((v43 & 0x80u) == 0) {
        long long v36 = v42;
      }
      else {
        long long v36 = (void **)v42[0];
      }
      if ((v43 & 0x80u) == 0) {
        uint64_t v37 = v43;
      }
      else {
        uint64_t v37 = (uint64_t)v42[1];
      }
      uint64_t v38 = sub_10004B96C(v45, (uint64_t)v36, v37);
      sub_10004B96C(v38, (uint64_t)", ", 2);
      if ((char)v43 < 0) {
        operator delete(v42[0]);
      }
      v6 += 128;
      --v5;
    }
    while (v5);
    sub_10004B96C(v45, (uint64_t)"]", 1);
  }
  sub_10004BC98((uint64_t)v45 + 8, a2);
  *(void *)((char *)&v45[-1]
  *(void *)&v45[0] = v39;
  if (SHIBYTE(v47) < 0) {
    operator delete(v46[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100C8FD00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
}

const void **sub_100C8FD44@<X0>(unsigned int *a1@<X0>, void *a2@<X8>)
{
  uint64_t v41 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v5 = v41;
    uint64_t v41 = Mutable;
    *(void *)&long long valuePtr = v5;
    sub_10005717C((const void **)&valuePtr);
  }
  if (*((unsigned char *)a1 + 4))
  {
    uint64_t v6 = *a1;
    *(void *)&long long __p = 0;
    *(void *)&long long valuePtr = v6;
    CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
    if (v7)
    {
      uint64_t v8 = __p;
      *(void *)&long long __p = v7;
      *(void *)&long long valuePtr = v8;
      sub_1000570E8((const void **)&valuePtr);
    }
    uint64_t v9 = (const void *)__p;
    __dst[0] = (void *)__p;
    *(void *)&long long __p = 0;
    sub_1000570E8((const void **)&__p);
    CFDictionaryAddValue(v41, @"fProvisionedDevicesLimit", v9);
    sub_1000570E8((const void **)__dst);
  }
  if (*((unsigned char *)a1 + 32))
  {
    CFMutableArrayRef v40 = 0;
    CFMutableArrayRef v10 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v10)
    {
      CFMutableArrayRef v11 = v40;
      CFMutableArrayRef v40 = v10;
      *(void *)&long long valuePtr = v11;
      sub_1000440D4((const void **)&valuePtr);
    }
    uint64_t v12 = *((void *)a1 + 1);
    if (*((void *)a1 + 2) != v12)
    {
      unint64_t v13 = 0;
      uint64_t v14 = 120;
      do
      {
        uint64_t v15 = v40;
        CFMutableDictionaryRef v51 = 0;
        CFMutableDictionaryRef v16 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v16)
        {
          CFMutableDictionaryRef v17 = v51;
          CFMutableDictionaryRef v51 = v16;
          *(void *)&long long valuePtr = v17;
          sub_10005717C((const void **)&valuePtr);
        }
        uint64_t v18 = v12 + v14;
        if (*(unsigned char *)(v12 + v14 - 96))
        {
          uint64_t v19 = (void **)(v12 + v14 - 120);
          uint64_t v20 = v51;
          if (*(char *)(v18 - 97) < 0)
          {
            sub_10004FC84(__dst, *v19, *(void *)(v12 + v14 - 112));
          }
          else
          {
            long long v21 = *(_OWORD *)v19;
            uint64_t v50 = *(void *)(v12 + v14 - 104);
            *(_OWORD *)long long __dst = v21;
          }
          if (SHIBYTE(v50) < 0)
          {
            sub_10004FC84(&__p, __dst[0], (unint64_t)__dst[1]);
          }
          else
          {
            long long __p = *(_OWORD *)__dst;
            uint64_t v54 = v50;
          }
          v42[0] = 0;
          if (SHIBYTE(v54) < 0)
          {
            sub_10004FC84(&valuePtr, (void *)__p, *((unint64_t *)&__p + 1));
          }
          else
          {
            long long valuePtr = __p;
            uint64_t v56 = v54;
          }
          v45[0] = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v22 = v42[0];
            v42[0] = v45[0];
            v47[0] = v22;
            sub_1000558F4((const void **)v47);
          }
          if (SHIBYTE(v56) < 0) {
            operator delete((void *)valuePtr);
          }
          v58[0] = v42[0];
          v42[0] = 0;
          sub_1000558F4((const void **)v42);
          if (SHIBYTE(v54) < 0) {
            operator delete((void *)__p);
          }
          CFDictionaryAddValue(v20, @"fUniqueId", v58[0]);
          sub_1000558F4(v58);
          if (SHIBYTE(v50) < 0) {
            operator delete(__dst[0]);
          }
        }
        if (*(unsigned char *)(v18 - 64))
        {
          uint64_t v23 = (void **)(v18 - 88);
          CFTypeID v24 = v51;
          if (*(char *)(v12 + v14 - 65) < 0)
          {
            sub_10004FC84(v47, *v23, *(void *)(v12 + v14 - 80));
          }
          else
          {
            long long v25 = *(_OWORD *)v23;
            uint64_t v48 = *(void *)(v18 - 72);
            *(_OWORD *)long long v47 = v25;
          }
          if (SHIBYTE(v48) < 0)
          {
            sub_10004FC84(&__p, v47[0], (unint64_t)v47[1]);
          }
          else
          {
            long long __p = *(_OWORD *)v47;
            uint64_t v54 = v48;
          }
          v58[0] = 0;
          if (SHIBYTE(v54) < 0)
          {
            sub_10004FC84(&valuePtr, (void *)__p, *((unint64_t *)&__p + 1));
          }
          else
          {
            long long valuePtr = __p;
            uint64_t v56 = v54;
          }
          v42[0] = 0;
          if (ctu::cf::convert_copy())
          {
            int v26 = (void *)v58[0];
            v58[0] = v42[0];
            v45[0] = v26;
            sub_1000558F4((const void **)v45);
          }
          if (SHIBYTE(v56) < 0) {
            operator delete((void *)valuePtr);
          }
          long long v57 = (void *)v58[0];
          v58[0] = 0;
          sub_1000558F4(v58);
          if (SHIBYTE(v54) < 0) {
            operator delete((void *)__p);
          }
          CFDictionaryAddValue(v24, @"fDisplayName", v57);
          sub_1000558F4((const void **)&v57);
          if (SHIBYTE(v48) < 0) {
            operator delete(v47[0]);
          }
        }
        uint64_t v27 = (unsigned __int8 *)(v12 + v14);
        if (*(unsigned char *)(v12 + v14 - 32))
        {
          uint64_t v28 = (void **)(v27 - 56);
          uint64_t v29 = v51;
          if ((char)*(v27 - 33) < 0)
          {
            sub_10004FC84(v45, *v28, *(void *)(v12 + v14 - 48));
          }
          else
          {
            long long v30 = *(_OWORD *)v28;
            uint64_t v46 = *((void *)v27 - 5);
            *(_OWORD *)CFStringRef v45 = v30;
          }
          if (SHIBYTE(v46) < 0)
          {
            sub_10004FC84(&__p, v45[0], (unint64_t)v45[1]);
          }
          else
          {
            long long __p = *(_OWORD *)v45;
            uint64_t v54 = v46;
          }
          long long v57 = 0;
          if (SHIBYTE(v54) < 0)
          {
            sub_10004FC84(&valuePtr, (void *)__p, *((unint64_t *)&__p + 1));
          }
          else
          {
            long long valuePtr = __p;
            uint64_t v56 = v54;
          }
          v58[0] = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v31 = v57;
            long long v57 = (void *)v58[0];
            v42[0] = v31;
            sub_1000558F4((const void **)v42);
          }
          if (SHIBYTE(v56) < 0) {
            operator delete((void *)valuePtr);
          }
          value = v57;
          long long v57 = 0;
          sub_1000558F4((const void **)&v57);
          if (SHIBYTE(v54) < 0) {
            operator delete((void *)__p);
          }
          CFDictionaryAddValue(v29, @"fIMPU", value);
          sub_1000558F4((const void **)&value);
          if (SHIBYTE(v46) < 0) {
            operator delete(v45[0]);
          }
        }
        int v33 = *v27;
        uint64_t v32 = v27 - 24;
        if (v33)
        {
          uint64_t v34 = v51;
          if (*(char *)(v12 + v14 - 1) < 0)
          {
            sub_10004FC84(v42, *(void **)v32, *(void *)(v12 + v14 - 16));
          }
          else
          {
            long long v35 = *(_OWORD *)v32;
            uint64_t v43 = *((void *)v32 + 2);
            *(_OWORD *)v42 = v35;
          }
          if (SHIBYTE(v43) < 0)
          {
            sub_10004FC84(&__p, v42[0], (unint64_t)v42[1]);
          }
          else
          {
            long long __p = *(_OWORD *)v42;
            uint64_t v54 = v43;
          }
          value = 0;
          if (SHIBYTE(v54) < 0)
          {
            sub_10004FC84(&valuePtr, (void *)__p, *((unint64_t *)&__p + 1));
          }
          else
          {
            long long valuePtr = __p;
            uint64_t v56 = v54;
          }
          long long v57 = 0;
          if (ctu::cf::convert_copy())
          {
            long long v36 = value;
            value = v57;
            v58[0] = v36;
            sub_1000558F4(v58);
          }
          if (SHIBYTE(v56) < 0) {
            operator delete((void *)valuePtr);
          }
          uint64_t v37 = value;
          long long v44 = value;
          value = 0;
          sub_1000558F4((const void **)&value);
          if (SHIBYTE(v54) < 0) {
            operator delete((void *)__p);
          }
          CFDictionaryAddValue(v34, @"fIMPI", v37);
          sub_1000558F4((const void **)&v44);
          if (SHIBYTE(v43) < 0) {
            operator delete(v42[0]);
          }
        }
        sub_10004EFE4(&v39, (CFTypeRef *)&v51);
        sub_10005717C((const void **)&v51);
        CFArrayAppendValue(v15, v39);
        sub_100057D78((const void **)&v39);
        ++v13;
        uint64_t v12 = *((void *)a1 + 1);
        v14 += 128;
      }
      while (v13 < (*((void *)a1 + 2) - v12) >> 7);
    }
    CFDictionaryAddValue(v41, @"fDeviceList", v40);
    sub_1000440D4((const void **)&v40);
  }
  sub_10004EFE4(a2, (CFTypeRef *)&v41);
  return sub_10005717C((const void **)&v41);
}

void sub_100C903F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, const void *a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,char a45,int a46,__int16 a47,char a48,char a49,void *__p,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
}

void sub_100C905DC()
{
}

void sub_100C909BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
}

uint64_t sub_100C90A38(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_100C9264C((void **)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t sub_100C90AB4(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *a1) >> 7;
    if ((unint64_t)(v10 + 1) >> 57) {
      sub_10006A748();
    }
    uint64_t v11 = v5 - *a1;
    uint64_t v12 = v11 >> 6;
    if (v11 >> 6 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFF80) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      uint64_t v14 = (char *)sub_100043864(v4, v13);
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = v14;
    CFMutableDictionaryRef v16 = &v14[128 * v10];
    uint64_t v18 = &v14[128 * v13];
    sub_100C927D0((uint64_t)v16, a2);
    CFMutableDictionaryRef v17 = v16 + 128;
    sub_100C92894(a1, &v15);
    uint64_t v9 = a1[1];
    uint64_t result = sub_100C929F8((uint64_t)&v15);
  }
  else
  {
    uint64_t result = sub_100C927D0(*(void *)(v4 - 8), a2);
    uint64_t v9 = v7 + 128;
    a1[1] = v7 + 128;
  }
  a1[1] = v9;
  return result;
}

void sub_100C90BA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C90BC8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_100C8A0B8(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C90D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100C90D3C@<X0>(void (***a1)(void, _OWORD *)@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  (**a1)(a1, v5);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C90ED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100C90EE4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 136)) {
    return (void *)sub_100C90D3C((void (***)(void, _OWORD *))a1, a2);
  }
  else {
    return sub_100058DB0(a2, "< Not Present >");
  }
}

void *sub_100C90F00(void *a1, uint64_t a2)
{
  sub_100C90EE4(a2, __p);
  if ((v7 & 0x80u) == 0) {
    int v3 = __p;
  }
  else {
    int v3 = (void **)__p[0];
  }
  if ((v7 & 0x80u) == 0) {
    uint64_t v4 = v7;
  }
  else {
    uint64_t v4 = (uint64_t)__p[1];
  }
  sub_10004B96C(a1, (uint64_t)v3, v4);
  if ((char)v7 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_100C90F6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C90F88@<X0>(_DWORD *a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_100C8C6A8(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C910E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100C910FC@<X0>(_DWORD *a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_100C8C70C(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C9125C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100C91270@<X0>(_DWORD *a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_100C8C770(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C913D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100C913E4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_100C8C7D4(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C91544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100C91558@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_100C8C868(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C916B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100C916CC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 456)) {
    return (void *)sub_100C91558(a1, a2);
  }
  else {
    return sub_100058DB0(a2, "< Not Present >");
  }
}

void *sub_100C916E8(void *a1, uint64_t a2)
{
  sub_100C916CC(a2, __p);
  if ((v7 & 0x80u) == 0) {
    int v3 = __p;
  }
  else {
    int v3 = (void **)__p[0];
  }
  if ((v7 & 0x80u) == 0) {
    uint64_t v4 = v7;
  }
  else {
    uint64_t v4 = (uint64_t)__p[1];
  }
  sub_10004B96C(a1, (uint64_t)v3, v4);
  if ((char)v7 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_100C91754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C91770@<X0>(int **a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_100C8DB9C(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C918D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100C918E4@<X0>(int **a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_100C8DD2C(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C91A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100C91A58(void *a1)
{
  *a1 = off_101A4D368;
  sub_1003AA7DC((uint64_t)(a1 + 2));
  return a1;
}

void sub_100C91A9C(void *a1)
{
  *a1 = off_101A4D368;
  sub_1003AA7DC((uint64_t)(a1 + 2));

  operator delete();
}

uint64_t sub_100C91B00(uint64_t a1)
{
  *(void *)a1 = off_101A4D3B8;
  if (*(unsigned char *)(a1 + 128) && *(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(unsigned char *)(a1 + 96) && *(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(unsigned char *)(a1 + 64) && *(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(unsigned char *)(a1 + 32) && *(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100C91BA0(uint64_t a1)
{
  *(void *)a1 = off_101A4D3B8;
  if (*(unsigned char *)(a1 + 128) && *(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(unsigned char *)(a1 + 96) && *(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(unsigned char *)(a1 + 64) && *(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(unsigned char *)(a1 + 32) && *(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void sub_100C91C60(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 6)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), a2 << 6);
      v7 += a2 << 6;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - *a1;
    unint64_t v9 = a2 + (v8 >> 6);
    if (v9 >> 58) {
      sub_10006A748();
    }
    uint64_t v10 = v8 >> 6;
    uint64_t v11 = v5 - *a1;
    if (v11 >> 5 > v9) {
      unint64_t v9 = v11 >> 5;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    uint64_t v18 = v4;
    if (v12) {
      long long v13 = (char *)sub_1001A14BC(v4, v12);
    }
    else {
      long long v13 = 0;
    }
    long long v14 = v13;
    long long v15 = &v13[64 * v10];
    long long v17 = &v13[64 * v12];
    bzero(v15, a2 << 6);
    long long v16 = &v15[64 * a2];
    sub_1003B74AC(a1, &v14);
    sub_1003B7684((uint64_t)&v14);
  }
}

void sub_100C91D50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003B7684((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100C91D64(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 6;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 58) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 5 > v5) {
    unint64_t v5 = v8 >> 5;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFC0) {
    unint64_t v9 = 0x3FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v18 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_1001A14BC(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = &v10[64 * v4];
  v15[0] = v10;
  v15[1] = v11;
  long long v16 = v11;
  long long v17 = &v10[64 * v9];
  long long v12 = *a2;
  v11[16] = *((unsigned char *)a2 + 16);
  *(_OWORD *)uint64_t v11 = v12;
  sub_1001A118C((uint64_t)(v11 + 24), (uint64_t)a2 + 24);
  *((_WORD *)v11 + 28) = *((_WORD *)a2 + 28);
  v16 += 64;
  sub_100C91E64(a1, v15);
  uint64_t v13 = a1[1];
  sub_1003B7684((uint64_t)v15);
  return v13;
}

void sub_100C91E50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003B7684((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100C91E64(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100C91EDC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100C91EDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v12[0] = a1;
  v12[1] = &v13;
  v12[2] = &v14;
  v12[3] = 1;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    do
    {
      long long v8 = *(_OWORD *)(a3 - 64);
      char v9 = *(unsigned char *)(a3 - 48);
      *(unsigned char *)(v7 - 40) = 0;
      *(unsigned char *)(v7 - 48) = v9;
      *(_OWORD *)(v7 - 64) = v8;
      *(unsigned char *)(v7 - 16) = 0;
      if (*(unsigned char *)(a3 - 16))
      {
        *(void *)(v7 - 40) = 0;
        *(void *)(v7 - 32) = 0;
        *(void *)(v7 - 24) = 0;
        *(_OWORD *)(v7 - 40) = *(_OWORD *)(a3 - 40);
        *(void *)(v7 - 24) = *(void *)(a3 - 24);
        *(void *)(a3 - 40) = 0;
        *(void *)(a3 - 32) = 0;
        *(void *)(a3 - 24) = 0;
        *(unsigned char *)(v7 - 16) = 1;
      }
      *(_WORD *)(v7 - 8) = *(_WORD *)(a3 - 8);
      uint64_t v7 = *((void *)&v14 + 1) - 64;
      *((void *)&v14 + 1) -= 64;
      a3 -= 64;
    }
    while (a3 != a5);
    uint64_t v10 = v14;
  }
  sub_100C91FB4((uint64_t)v12);
  return v10;
}

uint64_t sub_100C91FB4(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1003B7634(a1);
  }
  return a1;
}

void *sub_100C91FEC(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_100C92074(result, a4);
    uint64_t result = (void *)sub_100C920F0((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100C92054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100C92308(&a9);
  _Unwind_Resume(a1);
}

char *sub_100C92074(void *a1, unint64_t a2)
{
  if (HIBYTE(a2)) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_100C920B8((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[256 * v4];
  return result;
}

void *sub_100C920B8(uint64_t a1, unint64_t a2)
{
  if (HIBYTE(a2)) {
    sub_10006A7CC();
  }
  return operator new(a2 << 8);
}

uint64_t sub_100C920F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_100C92174(a4 + v7, (long long *)(a2 + v7));
      v7 += 256;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_100C92150(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 256;
    do
    {
      sub_1003AA7DC(v4 + v2);
      v2 -= 256;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C92174(uint64_t a1, long long *a2)
{
  uint64_t v4 = sub_1000593FC(a1, a2);
  sub_1000593FC(v4 + 32, a2 + 2);
  sub_1000593FC(a1 + 64, a2 + 4);
  sub_1000593FC(a1 + 96, a2 + 6);
  sub_1000593FC(a1 + 128, a2 + 8);
  sub_1000593FC(a1 + 160, a2 + 10);
  sub_1000593FC(a1 + 192, a2 + 12);
  sub_1000593FC(a1 + 224, a2 + 14);
  return a1;
}

void sub_100C92224(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 216) && *(char *)(v1 + 215) < 0) {
    operator delete(*v7);
  }
  if (*(unsigned char *)(v1 + 184) && *(char *)(v1 + 183) < 0) {
    operator delete(*v6);
  }
  if (*(unsigned char *)(v1 + 152) && *(char *)(v1 + 151) < 0) {
    operator delete(*v5);
  }
  if (*(unsigned char *)(v1 + 120) && *(char *)(v1 + 119) < 0) {
    operator delete(*v4);
  }
  if (*(unsigned char *)(v1 + 88) && *(char *)(v1 + 87) < 0) {
    operator delete(*v3);
  }
  if (*(unsigned char *)(v1 + 56) && *(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100C92308(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_1003AA7DC(v4 - 256);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100C9238C(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x8E38E38E38E38E39 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1C71C71C71C71C7) {
    unint64_t v9 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v9 = v5;
  }
  long long v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10016ACDC(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  long long v13 = v10;
  long long v14 = &v10[72 * v4];
  long long v16 = &v10[72 * v9];
  sub_100C924AC(v14, a2);
  long long v15 = v14 + 72;
  sub_100C92534(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100C925FC((uint64_t)&v13);
  return v11;
}

void sub_100C92498(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100C925FC((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_100C924AC(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  sub_1000593FC((uint64_t)(__dst + 3), (long long *)((char *)a2 + 24));
  uint64_t v5 = *((void *)a2 + 7);
  *((unsigned char *)__dst + 64) = *((unsigned char *)a2 + 64);
  __dst[7] = v5;
  return __dst;
}

void sub_100C92518(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100C92534(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      long long v8 = *(_OWORD *)(v2 + v5 - 72);
      *(void *)(v6 - 56) = *(void *)(v2 + v5 - 56);
      *(_OWORD *)(v6 - 72) = v8;
      *(void *)(v7 - 64) = 0;
      *(void *)(v7 - 56) = 0;
      *(void *)(v7 - 72) = 0;
      *(unsigned char *)(v4 + v5 - 48) = 0;
      *(unsigned char *)(v6 - 24) = 0;
      if (*(unsigned char *)(v2 + v5 - 24))
      {
        long long v9 = *(_OWORD *)(v7 - 48);
        *(void *)(v4 + v5 - 32) = *(void *)(v7 - 32);
        *(_OWORD *)(v4 + v5 - 48) = v9;
        *(void *)(v7 - 40) = 0;
        *(void *)(v7 - 32) = 0;
        *(void *)(v7 - 48) = 0;
        *(unsigned char *)(v6 - 24) = 1;
      }
      uint64_t v10 = *(void *)(v7 - 16);
      *(unsigned char *)(v6 - 8) = *(unsigned char *)(v7 - 8);
      *(void *)(v6 - 16) = v10;
      v5 -= 72;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v11 = *result;
  *uint64_t result = v4;
  a2[1] = v11;
  uint64_t v12 = result[1];
  result[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = result[2];
  result[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100C925FC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 72;
    sub_10019E80C(i - 72);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100C9264C(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 128;
        sub_100C926B4(v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_100C926B4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_100C9274C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 128;
        sub_100C926B4(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100C927D0(uint64_t a1, long long *a2)
{
  uint64_t v4 = sub_1000593FC(a1, a2);
  sub_1000593FC(v4 + 32, a2 + 2);
  sub_1000593FC(a1 + 64, a2 + 4);
  sub_1000593FC(a1 + 96, a2 + 6);
  return a1;
}

void sub_100C92830(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 88) && *(char *)(v1 + 87) < 0) {
    operator delete(*v3);
  }
  if (*(unsigned char *)(v1 + 56) && *(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100C92894(uint64_t *a1, void *a2)
{
  uint64_t v5 = (__n128 *)*a1;
  uint64_t v4 = (__n128 *)a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 128;
    v4 -= 8;
    sub_100C92928(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

__n128 sub_100C92928(uint64_t a1, __n128 *a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  if (a2[1].n128_u8[8])
  {
    __n128 result = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    *(__n128 *)a1 = result;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    a2->n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  if (a2[3].n128_u8[8])
  {
    __n128 result = a2[2];
    *(void *)(a1 + 48) = a2[3].n128_u64[0];
    *(__n128 *)(a1 + 32) = result;
    a2[2].n128_u64[1] = 0;
    a2[3].n128_u64[0] = 0;
    a2[2].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 56) = 1;
  }
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 88) = 0;
  if (a2[5].n128_u8[8])
  {
    __n128 result = a2[4];
    *(void *)(a1 + 80) = a2[5].n128_u64[0];
    *(__n128 *)(a1 + 64) = result;
    a2[4].n128_u64[1] = 0;
    a2[5].n128_u64[0] = 0;
    a2[4].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 88) = 1;
  }
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  if (a2[7].n128_u8[8])
  {
    __n128 result = a2[6];
    *(void *)(a1 + 112) = a2[7].n128_u64[0];
    *(__n128 *)(a1 + 96) = result;
    a2[6].n128_u64[1] = 0;
    a2[7].n128_u64[0] = 0;
    a2[6].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 120) = 1;
  }
  return result;
}

uint64_t sub_100C929F8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 128;
    sub_100C926B4(i - 128);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100C92A48(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 2)
  {
    if (a2 >> 62) {
      sub_10006A748();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v4 = (char *)sub_1000492A8(a2);
    uint64_t v5 = &v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    uint64_t v7 = &v4[4 * v6];
    uint64_t v8 = (char *)*a1;
    uint64_t v9 = (char *)a1[1];
    uint64_t v10 = v5;
    if (v9 != *a1)
    {
      uint64_t v10 = v5;
      do
      {
        int v11 = *((_DWORD *)v9 - 1);
        v9 -= 4;
        *((_DWORD *)v10 - 1) = v11;
        v10 -= 4;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t sub_100C92AF0(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      uint64_t v7 = (uint64_t *)v2;
    }
    else {
      uint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0;
  }
  sub_100C92B58((uint64_t **)a1, (uint64_t *)v4);
  return 1;
}

uint64_t *sub_100C92B58(uint64_t **a1, uint64_t *a2)
{
  int v3 = sub_10006C514(a1, a2);
  uint64_t v4 = (std::__shared_weak_count *)a2[6];
  if (v4) {
    sub_10004D2C8(v4);
  }
  operator delete(a2);
  return v3;
}

void sub_100C92B9C()
{
}

__n128 sub_100C92BB0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A4D408;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100C92C04(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4D408;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t *sub_100C92C3C(uint64_t *a1, int *a2)
{
  int v3 = *a2;
  int v51 = *a2;
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[1];
  uint64_t v8 = *(void *)(v5 + 16);
  uint64_t v6 = v5 + 16;
  uint64_t v7 = v8;
  if (v8)
  {
    uint64_t v9 = v6;
    do
    {
      int v10 = *(_DWORD *)(v7 + 28);
      BOOL v11 = v10 < v3;
      if (v10 >= v3) {
        uint64_t v12 = (uint64_t *)v7;
      }
      else {
        uint64_t v12 = (uint64_t *)(v7 + 8);
      }
      if (!v11) {
        uint64_t v9 = v7;
      }
      uint64_t v7 = *v12;
    }
    while (*v12);
    if (v9 != v6 && *(_DWORD *)(v9 + 28) <= v3)
    {
      uint64_t v13 = (unsigned char *)a1[2];
      if (!*v13)
      {
        uint64_t v14 = *(void *)(v4 + 16);
        if (!v14) {
          goto LABEL_23;
        }
        uint64_t v15 = v4 + 16;
        do
        {
          int v16 = *(_DWORD *)(v14 + 28);
          BOOL v17 = v16 < v3;
          if (v16 >= v3) {
            uint64_t v18 = (uint64_t *)v14;
          }
          else {
            uint64_t v18 = (uint64_t *)(v14 + 8);
          }
          if (!v17) {
            uint64_t v15 = v14;
          }
          uint64_t v14 = *v18;
        }
        while (*v18);
        if (v15 == v4 + 16 || *(_DWORD *)(v15 + 28) > v3 || *(_DWORD *)(v15 + 32) != *(_DWORD *)(v9 + 32)) {
LABEL_23:
        }
          unsigned char *v13 = 1;
      }
      int v19 = *(_DWORD *)(v9 + 32);
      long long v53 = &v51;
      *((_DWORD *)sub_10030B04C((uint64_t **)(v4 + 8), &v51, (uint64_t)&unk_10144E20E, (unsigned int **)&v53) + 8) = v19;
      uint64_t v20 = a1[1];
      uint64_t v23 = *(void *)(v20 + 64);
      uint64_t v21 = v20 + 64;
      uint64_t v22 = v23;
      if (!v23) {
        goto LABEL_34;
      }
      uint64_t v24 = v21;
      do
      {
        int v25 = *(_DWORD *)(v22 + 32);
        BOOL v26 = v25 < v51;
        if (v25 >= v51) {
          uint64_t v27 = (uint64_t *)v22;
        }
        else {
          uint64_t v27 = (uint64_t *)(v22 + 8);
        }
        if (!v26) {
          uint64_t v24 = v22;
        }
        uint64_t v22 = *v27;
      }
      while (*v27);
      if (v24 == v21 || v51 < *(_DWORD *)(v24 + 32))
      {
LABEL_34:
        sub_100C92AF0(v4 + 56, &v51);
        *(unsigned char *)a1[2] = 1;
        goto LABEL_35;
      }
      xpc_object_t v39 = (unsigned char *)a1[2];
      if (*v39) {
        goto LABEL_67;
      }
      uint64_t v40 = *(void *)(v4 + 64);
      if (v40)
      {
        uint64_t v41 = v4 + 64;
        do
        {
          int v42 = *(_DWORD *)(v40 + 32);
          BOOL v43 = v42 < v51;
          if (v42 >= v51) {
            long long v44 = (uint64_t *)v40;
          }
          else {
            long long v44 = (uint64_t *)(v40 + 8);
          }
          if (!v43) {
            uint64_t v41 = v40;
          }
          uint64_t v40 = *v44;
        }
        while (*v44);
        if (v41 != v4 + 64 && v51 >= *(_DWORD *)(v41 + 32))
        {
          CFStringRef v45 = *(uint64_t **)(v24 + 40);
          uint64_t v46 = *(unsigned __int8 **)(v41 + 40);
          if ((v45 != 0) == (v46 != 0))
          {
            if (!v45 || (sub_100C8A520(v45, v46) & 1) != 0) {
              goto LABEL_67;
            }
            xpc_object_t v39 = (unsigned char *)a1[2];
          }
        }
      }
      *xpc_object_t v39 = 1;
LABEL_67:
      long long v53 = &v51;
      long long v47 = sub_1001B0B78((uint64_t **)(v4 + 56), &v51, (uint64_t)&unk_10144E20E, &v53);
      long long v49 = *(uint64_t **)(v24 + 40);
      uint64_t v48 = *(uint64_t **)(v24 + 48);
      if (v48) {
        atomic_fetch_add_explicit(v48 + 1, 1uLL, memory_order_relaxed);
      }
      uint64_t v50 = (std::__shared_weak_count *)v47[6];
      v47[5] = v49;
      v47[6] = v48;
      if (v50) {
        sub_10004D2C8(v50);
      }
    }
  }
LABEL_35:
  unint64_t v28 = sub_100C89C88(a1[1], v51);
  if (HIDWORD(v28))
  {
    long long v53 = &v51;
    *((_DWORD *)sub_10030B04C((uint64_t **)(v4 + 32), &v51, (uint64_t)&unk_10144E20E, (unsigned int **)&v53) + 8) = v28;
  }
  else
  {
    sub_100AE8A00(v4 + 32, &v51);
  }
  uint64_t v29 = a1[1];
  uint64_t v32 = *(void *)(v29 + 88);
  uint64_t v30 = v29 + 88;
  uint64_t v31 = v32;
  if (!v32) {
    goto LABEL_48;
  }
  uint64_t v33 = v30;
  do
  {
    int v34 = *(_DWORD *)(v31 + 28);
    BOOL v35 = v34 < v51;
    if (v34 >= v51) {
      long long v36 = (uint64_t *)v31;
    }
    else {
      long long v36 = (uint64_t *)(v31 + 8);
    }
    if (!v35) {
      uint64_t v33 = v31;
    }
    uint64_t v31 = *v36;
  }
  while (*v36);
  if (v33 != v30 && *(_DWORD *)(v33 + 28) <= v51) {
    int v37 = *(_DWORD *)(v33 + 32);
  }
  else {
LABEL_48:
  }
    int v37 = 0;
  int v52 = v51;
  long long v53 = &v52;
  __n128 result = sub_10030B04C((uint64_t **)(v4 + 80), &v52, (uint64_t)&unk_10144E20E, (unsigned int **)&v53);
  *((_DWORD *)result + 8) = v37;
  return result;
}

uint64_t sub_100C92F44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C92F84()
{
}

void sub_100C92F94()
{
}

__n128 sub_100C92FA8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A4D488;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100C92FFC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4D488;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100C93034(uint64_t a1, int *a2)
{
  int v3 = *a2;
  unint64_t v4 = sub_100022DE8(*(void *)(a1 + 8), *a2);
  if (**(unsigned char **)(a1 + 24)) {
    uint64_t v5 = "";
  }
  else {
    uint64_t v5 = ", ";
  }
  uint64_t v6 = sub_10004B96C(*(void **)(a1 + 16), (uint64_t)v5, 2 * (**(unsigned char **)(a1 + 24) == 0));
  uint64_t v7 = sub_100059954(v3);
  size_t v8 = strlen(v7);
  uint64_t v9 = sub_10004B96C(v6, (uint64_t)v7, v8);
  int v10 = sub_10004B96C(v9, (uint64_t)":", 1);
  if (HIDWORD(v4))
  {
    if ((v4 - 1) > 5) {
      BOOL v11 = "???";
    }
    else {
      BOOL v11 = off_101A4D8A0[(int)v4 - 1];
    }
  }
  else
  {
    BOOL v11 = "--";
  }
  size_t v12 = strlen(v11);
  uint64_t result = (uint64_t)sub_10004B96C(v10, (uint64_t)v11, v12);
  uint64_t v14 = *(void *)(a1 + 8);
  uint64_t v17 = *(void *)(v14 + 88);
  uint64_t v15 = v14 + 88;
  uint64_t v16 = v17;
  if (v17)
  {
    uint64_t v18 = v15;
    do
    {
      int v19 = *(_DWORD *)(v16 + 28);
      BOOL v20 = v19 < v3;
      if (v19 >= v3) {
        uint64_t v21 = (uint64_t *)v16;
      }
      else {
        uint64_t v21 = (uint64_t *)(v16 + 8);
      }
      if (!v20) {
        uint64_t v18 = v16;
      }
      uint64_t v16 = *v21;
    }
    while (*v21);
    if (v18 != v15 && *(_DWORD *)(v18 + 28) <= v3 && *(_DWORD *)(v18 + 32))
    {
      sub_10004B96C(*(void **)(a1 + 16), (uint64_t)" skip:", 6);
      uint64_t result = std::ostream::operator<<();
    }
  }
  **(unsigned char **)(a1 + 24) = 0;
  return result;
}

uint64_t sub_100C93198(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C931D8()
{
}

void sub_100C931E8()
{
}

__n128 sub_100C931FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A4D508;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100C93250(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4D508;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100C93288(uint64_t a1, int *a2)
{
  int v3 = *a2;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  sub_100C89CF8(*(void *)(a1 + 8), v3, (uint64_t)&v16);
  if ((_BYTE)v18)
  {
    unint64_t v4 = v16;
    if (v16)
    {
      if (**(unsigned char **)(a1 + 24)) {
        uint64_t v5 = "; details>> ";
      }
      else {
        uint64_t v5 = ", ";
      }
      if (**(unsigned char **)(a1 + 24)) {
        uint64_t v6 = 12;
      }
      else {
        uint64_t v6 = 2;
      }
      uint64_t v7 = sub_10004B96C(*(void **)(a1 + 16), (uint64_t)v5, v6);
      size_t v8 = sub_100059954(v3);
      size_t v9 = strlen(v8);
      int v10 = sub_10004B96C(v7, (uint64_t)v8, v9);
      BOOL v11 = sub_10004B96C(v10, (uint64_t)":", 1);
      sub_100C8A778(v4, __p);
      if ((v15 & 0x80u) == 0) {
        size_t v12 = __p;
      }
      else {
        size_t v12 = (void **)__p[0];
      }
      if ((v15 & 0x80u) == 0) {
        uint64_t v13 = v15;
      }
      else {
        uint64_t v13 = (uint64_t)__p[1];
      }
      sub_10004B96C(v11, (uint64_t)v12, v13);
      if ((char)v15 < 0) {
        operator delete(__p[0]);
      }
      **(unsigned char **)(a1 + 24) = 0;
    }
    if (v17) {
      sub_10004D2C8(v17);
    }
  }
}

void sub_100C933A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C933D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100C93414()
{
}

void sub_100C93424()
{
}

__n128 sub_100C93438(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A4D588;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100C93484(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4D588;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100C934B0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100C934F0()
{
}

uint64_t **sub_100C934FC(uint64_t **a1, unsigned __int8 *a2, unsigned char *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        size_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((unsigned __int8 *)v5 + 25);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    size_t v8 = a1 + 1;
LABEL_10:
    int v10 = (uint64_t *)operator new(0x20uLL);
    *((unsigned char *)v10 + 25) = *a3;
    sub_100046C38(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_100C935BC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100C935F4(uint64_t a1)
{
  return sub_100C93640(*(void *)(a1 + 24));
}

uint64_t sub_100C935FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100C93640(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 120) && *(char *)(result + 119) < 0) {
      operator delete(*(void **)(result + 96));
    }
    if (*(unsigned char *)(v1 + 88) && *(char *)(v1 + 87) < 0) {
      operator delete(*(void **)(v1 + 64));
    }
    if (*(unsigned char *)(v1 + 56) && *(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(unsigned char *)(v1 + 24) && *(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  return result;
}

BOOL sub_100C936EC(const __CFArray *a1, const void *a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    BOOL v6 = 0;
    CFIndex v7 = 0;
    while (1)
    {
      CFDictionaryRef theDict = 0;
      CFNumberRef number = (CFNumberRef)CFArrayGetValueAtIndex(a1, v7);
      sub_10004EFE4(&theDict, (CFTypeRef *)&number);
      if (theDict) {
        size_t v8 = sub_100080778;
      }
      else {
        size_t v8 = 0;
      }
      if (v8)
      {
        CFNumberRef number = 0;
        CFTypeRef valuePtr = CFDictionaryGetValue(theDict, a2);
        sub_1000842D0(&number, &valuePtr);
        if (number) {
          unsigned int v9 = sub_100081E58;
        }
        else {
          unsigned int v9 = 0;
        }
        if (v9)
        {
          LODWORD(valuePtr) = 0;
          if (CFNumberGetValue(number, kCFNumberIntType, &valuePtr))
          {
            if ((valuePtr & 0x10) != 0)
            {
              sub_1000570E8((const void **)&number);
              sub_100057D78((const void **)&theDict);
              return v6;
            }
          }
        }
        sub_1000570E8((const void **)&number);
      }
      sub_100057D78((const void **)&theDict);
      BOOL v6 = ++v7 >= v5;
      if (v5 == v7) {
        return v6;
      }
    }
  }
  return 1;
}

void sub_100C9381C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  unint64_t v4 = va_arg(va1, const void *);
  sub_1000570E8((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100C93840@<X0>(char a1@<W0>, void *a2@<X8>)
{
  uint64_t v33 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v22 = 0u;
  memset(v20, 0, sizeof(v20));
  long long v19 = 0u;
  sub_10004BD84((uint64_t)&v19);
  sub_10004B96C(v20, (uint64_t)"[", 1);
  BOOL v4 = (a1 & 1) == 0;
  if (a1)
  {
    CFIndex v5 = sub_10004B96C(v20, (uint64_t)"", 0);
    sub_10004B96C(v5, (uint64_t)"UMTS", 4);
  }
  if ((a1 & 2) != 0)
  {
    if (a1) {
      BOOL v6 = ", ";
    }
    else {
      BOOL v6 = "";
    }
    CFIndex v7 = sub_10004B96C(v20, (uint64_t)v6, 2 * (a1 & 1u));
    sub_10004B96C(v7, (uint64_t)"CDMA", 4);
    BOOL v4 = 0;
  }
  if ((a1 & 4) != 0)
  {
    if (v4) {
      size_t v8 = "";
    }
    else {
      size_t v8 = ", ";
    }
    if (v4) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = 2;
    }
    int v10 = sub_10004B96C(v20, (uint64_t)v8, v9);
    sub_10004B96C(v10, (uint64_t)"eHRPD", 5);
    BOOL v4 = 0;
  }
  if ((a1 & 8) != 0)
  {
    if (v4) {
      BOOL v11 = "";
    }
    else {
      BOOL v11 = ", ";
    }
    if (v4) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = 2;
    }
    uint64_t v13 = sub_10004B96C(v20, (uint64_t)v11, v12);
    sub_10004B96C(v13, (uint64_t)"LTE", 3);
    BOOL v4 = 0;
  }
  if ((a1 & 0x10) != 0)
  {
    if (v4) {
      uint64_t v14 = "";
    }
    else {
      uint64_t v14 = ", ";
    }
    if (v4) {
      uint64_t v15 = 0;
    }
    else {
      uint64_t v15 = 2;
    }
    uint64_t v16 = sub_10004B96C(v20, (uint64_t)v14, v15);
    sub_10004B96C(v16, (uint64_t)"NR", 2);
  }
  sub_10004B96C(v20, (uint64_t)"]", 1);
  sub_10004BC98((uint64_t)v20 + 8, a2);
  *(void *)((char *)&v20[-1]
  *(void *)&v20[0] = v17;
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100C93B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100C93B3C(uint64_t a1)
{
  *(void *)a1 = off_101A4D8E0;
  uint64_t v2 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "DATA.xx-apn");
  sub_100C93BF8(v2, "DATA.xx-apn", QOS_CLASS_UTILITY, &v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  *(void *)a1 = off_101A4D8E0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  return a1;
}

void sub_100C93BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100C93BF8(void *a1, const char *a2, dispatch_qos_class_t a3, const OsLogContext *a4)
{
  dispatch_object_t object = 0;
  sub_10058A678(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&object, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&object);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  return a1;
}

void sub_100C93C60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100C93C98(uint64_t a1)
{
  *(void *)a1 = off_101A4D8E0;
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100C93D30(uint64_t a1)
{
  sub_100C93C98(a1);

  operator delete();
}

uint64_t sub_100C93D68(void *a1, uint64_t a2)
{
  uint64_t v43 = 0;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v32 = 0u;
  memset(v30, 0, sizeof(v30));
  long long v29 = 0u;
  sub_10004BD84((uint64_t)&v29);
  OsLogContext v4 = sub_10004B96C(v30, (uint64_t)"name:'", 6);
  int v5 = *(char *)(a2 + 71);
  if (v5 >= 0) {
    uint64_t v6 = a2 + 48;
  }
  else {
    uint64_t v6 = *(void *)(a2 + 48);
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 71);
  }
  else {
    uint64_t v7 = *(void *)(a2 + 56);
  }
  size_t v8 = sub_10004B96C(v4, v6, v7);
  uint64_t v9 = sub_10004B96C(v8, (uint64_t)"', username:'", 13);
  int v10 = *(char *)(a2 + 95);
  if (v10 >= 0) {
    uint64_t v11 = a2 + 72;
  }
  else {
    uint64_t v11 = *(void *)(a2 + 72);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a2 + 95);
  }
  else {
    uint64_t v12 = *(void *)(a2 + 80);
  }
  uint64_t v13 = sub_10004B96C(v9, v11, v12);
  uint64_t v14 = sub_10004B96C(v13, (uint64_t)"', password:'", 13);
  int v15 = *(char *)(a2 + 119);
  if (v15 >= 0) {
    uint64_t v16 = a2 + 96;
  }
  else {
    uint64_t v16 = *(void *)(a2 + 96);
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(a2 + 119);
  }
  else {
    uint64_t v17 = *(void *)(a2 + 104);
  }
  uint64_t v18 = sub_10004B96C(v14, v16, v17);
  long long v19 = sub_10004B96C(v18, (uint64_t)"', auth-type:'", 14);
  uint64_t v22 = *(void *)(a2 + 120);
  uint64_t v21 = a2 + 120;
  uint64_t v20 = v22;
  int v23 = *(char *)(v21 + 23);
  if (v23 >= 0) {
    uint64_t v24 = v21;
  }
  else {
    uint64_t v24 = v20;
  }
  if (v23 >= 0) {
    uint64_t v25 = *(unsigned __int8 *)(v21 + 23);
  }
  else {
    uint64_t v25 = *(void *)(v21 + 8);
  }
  long long v26 = sub_10004B96C(v19, v24, v25);
  sub_10004B96C(v26, (uint64_t)"'", 1);
  sub_10004BC98((uint64_t)v30 + 8, a1);
  *(void *)((char *)&v30[-1]
  *(void *)&v30[0] = v27;
  if (SHIBYTE(v32) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100C93FE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100C93FF4(uint64_t a1)
{
  *(void *)a1 = off_101A4D900;
  if (*(unsigned char *)(a1 + 336))
  {
    uint64_t v2 = *(void **)(a1 + 312);
    if (v2)
    {
      *(void *)(a1 + 320) = v2;
      operator delete(v2);
    }
  }
  if (*(unsigned char *)(a1 + 304) && *(char *)(a1 + 303) < 0) {
    operator delete(*(void **)(a1 + 280));
  }
  if (*(unsigned char *)(a1 + 272) && *(char *)(a1 + 271) < 0) {
    operator delete(*(void **)(a1 + 248));
  }
  OsLogContext v4 = (void **)(a1 + 224);
  sub_100BC5188(&v4);
  sub_100057D78((const void **)(a1 + 208));
  return sub_100C93C98(a1);
}

void sub_100C940A4(uint64_t a1)
{
  sub_100C93FF4(a1);

  operator delete();
}

const void **sub_100C940DC@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  CFMutableDictionaryRef MutableCopy = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v122 = Mutable;
  if (Mutable) {
    uint64_t v7 = sub_1000C06D0;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v7)
  {
    __TUAssertTrigger();
    CFMutableDictionaryRef Mutable = v122;
  }
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    long long __dst = *(_OWORD *)(a1 + 48);
    v121 = *(void **)(a1 + 64);
  }
  if (SHIBYTE(v121) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long valuePtr = __dst;
    v125 = v121;
  }
  value[0] = 0;
  if (SHIBYTE(v125) < 0)
  {
    sub_10004FC84(__p, (void *)valuePtr, *((unint64_t *)&valuePtr + 1));
  }
  else
  {
    *(_OWORD *)long long __p = valuePtr;
    v106[0] = v125;
  }
  v116[0] = 0;
  if (ctu::cf::convert_copy())
  {
    size_t v8 = value[0];
    value[0] = v116[0];
    *(void *)&long long v118 = v8;
    sub_1000558F4((const void **)&v118);
  }
  if (SHIBYTE(v106[0]) < 0) {
    operator delete(__p[0]);
  }
  v127[0] = value[0];
  value[0] = 0;
  sub_1000558F4((const void **)value);
  if (SHIBYTE(v125) < 0) {
    operator delete((void *)valuePtr);
  }
  CFDictionaryAddValue(Mutable, @"apn", v127[0]);
  sub_1000558F4(v127);
  if (SHIBYTE(v121) < 0) {
    operator delete((void *)__dst);
  }
  uint64_t v9 = v122;
  if (*(char *)(a1 + 95) < 0)
  {
    sub_10004FC84(&v118, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    long long v118 = *(_OWORD *)(a1 + 72);
    v119 = *(void **)(a1 + 88);
  }
  if (SHIBYTE(v119) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)v118, *((unint64_t *)&v118 + 1));
  }
  else
  {
    long long valuePtr = v118;
    v125 = v119;
  }
  v127[0] = 0;
  if (SHIBYTE(v125) < 0)
  {
    sub_10004FC84(__p, (void *)valuePtr, *((unint64_t *)&valuePtr + 1));
  }
  else
  {
    *(_OWORD *)long long __p = valuePtr;
    v106[0] = v125;
  }
  value[0] = 0;
  if (ctu::cf::convert_copy())
  {
    int v10 = (void *)v127[0];
    v127[0] = value[0];
    v116[0] = v10;
    sub_1000558F4((const void **)v116);
  }
  if (SHIBYTE(v106[0]) < 0) {
    operator delete(__p[0]);
  }
  CFMutableArrayRef v126 = (CFMutableArrayRef)v127[0];
  v127[0] = 0;
  sub_1000558F4(v127);
  if (SHIBYTE(v125) < 0) {
    operator delete((void *)valuePtr);
  }
  CFDictionaryAddValue(v9, @"username", v126);
  sub_1000558F4((const void **)&v126);
  if (SHIBYTE(v119) < 0) {
    operator delete((void *)v118);
  }
  uint64_t v11 = v122;
  if (*(char *)(a1 + 119) < 0)
  {
    sub_10004FC84(v116, *(void **)(a1 + 96), *(void *)(a1 + 104));
  }
  else
  {
    *(_OWORD *)v116 = *(_OWORD *)(a1 + 96);
    v117 = *(void **)(a1 + 112);
  }
  if (SHIBYTE(v117) < 0)
  {
    sub_10004FC84(&valuePtr, v116[0], (unint64_t)v116[1]);
  }
  else
  {
    long long valuePtr = *(_OWORD *)v116;
    v125 = v117;
  }
  CFMutableArrayRef v126 = 0;
  if (SHIBYTE(v125) < 0)
  {
    sub_10004FC84(__p, (void *)valuePtr, *((unint64_t *)&valuePtr + 1));
  }
  else
  {
    *(_OWORD *)long long __p = valuePtr;
    v106[0] = v125;
  }
  v127[0] = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableArrayRef v12 = v126;
    CFMutableArrayRef v126 = (CFMutableArrayRef)v127[0];
    value[0] = v12;
    sub_1000558F4((const void **)value);
  }
  if (SHIBYTE(v106[0]) < 0) {
    operator delete(__p[0]);
  }
  CFMutableDictionaryRef v123 = v126;
  CFMutableArrayRef v126 = 0;
  sub_1000558F4((const void **)&v126);
  if (SHIBYTE(v125) < 0) {
    operator delete((void *)valuePtr);
  }
  CFDictionaryAddValue(v11, @"password", v123);
  sub_1000558F4((const void **)&v123);
  if (SHIBYTE(v117) < 0) {
    operator delete(v116[0]);
  }
  uint64_t v13 = (void **)(a1 + 120);
  if (*(char *)(a1 + 143) < 0)
  {
    unint64_t v15 = *(void *)(a1 + 128);
    if (!v15) {
      goto LABEL_76;
    }
    uint64_t v14 = v122;
    sub_10004FC84(value, *v13, v15);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 143)) {
      goto LABEL_76;
    }
    uint64_t v14 = v122;
    *(_OWORD *)value = *(_OWORD *)v13;
    long long v114 = *(void **)(a1 + 136);
  }
  if (SHIBYTE(v114) < 0)
  {
    sub_10004FC84(&valuePtr, value[0], (unint64_t)value[1]);
  }
  else
  {
    long long valuePtr = *(_OWORD *)value;
    v125 = v114;
  }
  CFMutableDictionaryRef v123 = 0;
  if (SHIBYTE(v125) < 0)
  {
    sub_10004FC84(__p, (void *)valuePtr, *((unint64_t *)&valuePtr + 1));
  }
  else
  {
    *(_OWORD *)long long __p = valuePtr;
    v106[0] = v125;
  }
  CFMutableArrayRef v126 = 0;
  if (ctu::cf::convert_copy())
  {
    CFMutableDictionaryRef v16 = v123;
    CFMutableDictionaryRef v123 = v126;
    v127[0] = v16;
    sub_1000558F4(v127);
  }
  if (SHIBYTE(v106[0]) < 0) {
    operator delete(__p[0]);
  }
  CFMutableDictionaryRef v17 = v123;
  CFMutableDictionaryRef v115 = v123;
  CFMutableDictionaryRef v123 = 0;
  sub_1000558F4((const void **)&v123);
  if (SHIBYTE(v125) < 0) {
    operator delete((void *)valuePtr);
  }
  CFDictionaryAddValue(v14, @"auth_type", v17);
  sub_1000558F4((const void **)&v115);
  if (SHIBYTE(v114) < 0) {
    operator delete(value[0]);
  }
LABEL_76:
  sub_10004EFE4(&theDict, (CFTypeRef *)&v122);
  sub_10005717C((const void **)&v122);
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
  sub_100057D78((const void **)&theDict);
  __p[0] = 0;
  __p[0] = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, (const void *)(a1 + 152));
  CFDictionaryAddValue(MutableCopy, @"type-mask", __p[0]);
  sub_1000570E8((const void **)__p);
  if (*(void *)(a1 + 160))
  {
    __p[0] = 0;
    __p[0] = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, (const void *)(a1 + 160));
    CFDictionaryAddValue(MutableCopy, @"tech-type-mask", __p[0]);
    sub_1000570E8((const void **)__p);
  }
  uint64_t v18 = (void *)*(unsigned int *)(a1 + 168);
  if (v18)
  {
    long long v19 = MutableCopy;
    *(void *)&long long valuePtr = 0;
    __p[0] = v18;
    CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, __p);
    if (v20)
    {
      uint64_t v21 = (void *)valuePtr;
      *(void *)&long long valuePtr = v20;
      __p[0] = v21;
      sub_1000570E8((const void **)__p);
    }
    *(void *)&long long __dst = valuePtr;
    *(void *)&long long valuePtr = 0;
    sub_1000570E8((const void **)&valuePtr);
    CFDictionaryAddValue(v19, @"AllowedProtocolMask", (const void *)__dst);
    sub_1000570E8((const void **)&__dst);
  }
  uint64_t v22 = (void *)*(unsigned int *)(a1 + 172);
  if (v22)
  {
    int v23 = MutableCopy;
    *(void *)&long long valuePtr = 0;
    __p[0] = v22;
    CFNumberRef v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, __p);
    if (v24)
    {
      uint64_t v25 = (void *)valuePtr;
      *(void *)&long long valuePtr = v24;
      __p[0] = v25;
      sub_1000570E8((const void **)__p);
    }
    *(void *)&long long __dst = valuePtr;
    *(void *)&long long valuePtr = 0;
    sub_1000570E8((const void **)&valuePtr);
    CFDictionaryAddValue(v23, @"AllowedProtocolMaskInRoaming", (const void *)__dst);
    sub_1000570E8((const void **)&__dst);
  }
  if (*(unsigned char *)(a1 + 180))
  {
    long long v26 = MutableCopy;
    xpc_object_t v27 = (void *)*(unsigned int *)(a1 + 176);
    *(void *)&long long valuePtr = 0;
    __p[0] = v27;
    CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, __p);
    if (v28)
    {
      long long v29 = (void *)valuePtr;
      *(void *)&long long valuePtr = v28;
      __p[0] = v29;
      sub_1000570E8((const void **)__p);
    }
    *(void *)&long long __dst = valuePtr;
    *(void *)&long long valuePtr = 0;
    sub_1000570E8((const void **)&valuePtr);
    CFDictionaryAddValue(v26, @"AllowedProtocolMaskInDomesticRoaming", (const void *)__dst);
    sub_1000570E8((const void **)&__dst);
  }
  if (a2)
  {
    long long v30 = MutableCopy;
    long long v31 = (void *)*(unsigned int *)(a1 + 184);
    *(void *)&long long valuePtr = 0;
    __p[0] = v31;
    CFNumberRef v32 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, __p);
    if (v32)
    {
      long long v33 = (void *)valuePtr;
      *(void *)&long long valuePtr = v32;
      __p[0] = v33;
      sub_1000570E8((const void **)__p);
    }
    *(void *)&long long __dst = valuePtr;
    *(void *)&long long valuePtr = 0;
    sub_1000570E8((const void **)&valuePtr);
    CFDictionaryAddValue(v30, @"InactivityTimer", (const void *)__dst);
    sub_1000570E8((const void **)&__dst);
    long long v34 = MutableCopy;
    long long v35 = (void *)*(unsigned int *)(a1 + 188);
    *(void *)&long long valuePtr = 0;
    __p[0] = v35;
    CFNumberRef v36 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, __p);
    if (v36)
    {
      long long v37 = (void *)valuePtr;
      *(void *)&long long valuePtr = v36;
      __p[0] = v37;
      sub_1000570E8((const void **)__p);
    }
    *(void *)&long long __dst = valuePtr;
    *(void *)&long long valuePtr = 0;
    sub_1000570E8((const void **)&valuePtr);
    CFDictionaryAddValue(v34, @"TechnologyMask", (const void *)__dst);
    sub_1000570E8((const void **)&__dst);
  }
  if (*(unsigned char *)(a1 + 192))
  {
    long long v38 = MutableCopy;
    *(void *)&long long valuePtr = 0;
    LODWORD(__p[0]) = 1;
    CFNumberRef v39 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, __p);
    if (v39)
    {
      long long v40 = (void *)valuePtr;
      *(void *)&long long valuePtr = v39;
      __p[0] = v40;
      sub_1000570E8((const void **)__p);
    }
    *(void *)&long long __dst = valuePtr;
    *(void *)&long long valuePtr = 0;
    sub_1000570E8((const void **)&valuePtr);
    CFDictionaryAddValue(v38, @"AllowNoDNS", (const void *)__dst);
    sub_1000570E8((const void **)&__dst);
  }
  long long v41 = MutableCopy;
  if (*(unsigned char *)(a1 + 193)) {
    CFBooleanRef v42 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v42 = kCFBooleanFalse;
  }
  *(void *)&long long valuePtr = v42;
  __p[0] = 0;
  sub_100062778((const void **)__p);
  *(void *)&long long __dst = valuePtr;
  *(void *)&long long valuePtr = 0;
  sub_100062778((const void **)&valuePtr);
  CFDictionaryAddValue(v41, @"SupportSwitchOver", (const void *)__dst);
  sub_100062778((const void **)&__dst);
  uint64_t v43 = MutableCopy;
  if (*(unsigned char *)(a1 + 194)) {
    CFBooleanRef v44 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v44 = kCFBooleanFalse;
  }
  *(void *)&long long valuePtr = v44;
  __p[0] = 0;
  sub_100062778((const void **)__p);
  *(void *)&long long __dst = valuePtr;
  *(void *)&long long valuePtr = 0;
  sub_100062778((const void **)&valuePtr);
  CFDictionaryAddValue(v43, @"AlwaysOnPDU", (const void *)__dst);
  sub_100062778((const void **)&__dst);
  CFStringRef v45 = MutableCopy;
  if (*(unsigned char *)(a1 + 195)) {
    CFBooleanRef v46 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v46 = kCFBooleanFalse;
  }
  *(void *)&long long valuePtr = v46;
  __p[0] = 0;
  sub_100062778((const void **)__p);
  *(void *)&long long __dst = valuePtr;
  *(void *)&long long valuePtr = 0;
  sub_100062778((const void **)&valuePtr);
  CFDictionaryAddValue(v45, @"SuppressPdnTearDown", (const void *)__dst);
  sub_100062778((const void **)&__dst);
  long long v47 = MutableCopy;
  if (*(unsigned char *)(a1 + 196)) {
    CFBooleanRef v48 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v48 = kCFBooleanFalse;
  }
  *(void *)&long long valuePtr = v48;
  __p[0] = 0;
  sub_100062778((const void **)__p);
  *(void *)&long long __dst = valuePtr;
  *(void *)&long long valuePtr = 0;
  sub_100062778((const void **)&valuePtr);
  CFDictionaryAddValue(v47, @"Support5GSaHandOver", (const void *)__dst);
  sub_100062778((const void **)&__dst);
  if (*(unsigned char *)(a1 + 198))
  {
    long long v49 = MutableCopy;
    if (*(unsigned char *)(a1 + 197)) {
      CFBooleanRef v50 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v50 = kCFBooleanFalse;
    }
    *(void *)&long long valuePtr = v50;
    __p[0] = 0;
    sub_100062778((const void **)__p);
    *(void *)&long long __dst = valuePtr;
    *(void *)&long long valuePtr = 0;
    sub_100062778((const void **)&valuePtr);
    CFDictionaryAddValue(v49, @"DontSuspend", (const void *)__dst);
    sub_100062778((const void **)&__dst);
  }
  if (*(unsigned char *)(a1 + 200))
  {
    int v51 = MutableCopy;
    if (*(unsigned char *)(a1 + 199)) {
      CFBooleanRef v52 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v52 = kCFBooleanFalse;
    }
    *(void *)&long long valuePtr = v52;
    __p[0] = 0;
    sub_100062778((const void **)__p);
    *(void *)&long long __dst = valuePtr;
    *(void *)&long long valuePtr = 0;
    sub_100062778((const void **)&valuePtr);
    CFDictionaryAddValue(v51, @"SuspendOnBBCall", (const void *)__dst);
    sub_100062778((const void **)&__dst);
  }
  long long v53 = MutableCopy;
  uint64_t v54 = (void *)*(unsigned __int16 *)(a1 + 202);
  *(void *)&long long valuePtr = 0;
  __p[0] = v54;
  CFNumberRef v55 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, __p);
  if (v55)
  {
    uint64_t v56 = (void *)valuePtr;
    *(void *)&long long valuePtr = v55;
    __p[0] = v56;
    sub_1000570E8((const void **)__p);
  }
  *(void *)&long long __dst = valuePtr;
  *(void *)&long long valuePtr = 0;
  sub_1000570E8((const void **)&valuePtr);
  CFDictionaryAddValue(v53, @"PcoContainerId", (const void *)__dst);
  sub_1000570E8((const void **)&__dst);
  if (a2)
  {
    long long v57 = *(const void **)(a1 + 208);
    if (v57) {
      uint64_t v58 = sub_100080778;
    }
    else {
      uint64_t v58 = 0;
    }
    if (v58) {
      CFDictionaryAddValue(MutableCopy, @"ProxyConfiguration", v57);
    }
    long long v59 = MutableCopy;
    if (*(unsigned char *)(a1 + 216)) {
      CFBooleanRef v60 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v60 = kCFBooleanFalse;
    }
    *(void *)&long long valuePtr = v60;
    __p[0] = 0;
    sub_100062778((const void **)__p);
    *(void *)&long long __dst = valuePtr;
    *(void *)&long long valuePtr = 0;
    sub_100062778((const void **)&valuePtr);
    CFDictionaryAddValue(v59, @"UseNetworkMTU", (const void *)__dst);
    sub_100062778((const void **)&__dst);
  }
  if (*(unsigned char *)(a1 + 272))
  {
    long long v61 = MutableCopy;
    if (*(char *)(a1 + 271) < 0)
    {
      sub_10004FC84(v109, *(void **)(a1 + 248), *(void *)(a1 + 256));
    }
    else
    {
      *(_OWORD *)long long v109 = *(_OWORD *)(a1 + 248);
      long long v110 = *(void **)(a1 + 264);
    }
    if (SHIBYTE(v110) < 0)
    {
      sub_10004FC84(&valuePtr, v109[0], (unint64_t)v109[1]);
    }
    else
    {
      long long valuePtr = *(_OWORD *)v109;
      v125 = v110;
    }
    v116[0] = 0;
    if (SHIBYTE(v125) < 0)
    {
      sub_10004FC84(__p, (void *)valuePtr, *((unint64_t *)&valuePtr + 1));
    }
    else
    {
      *(_OWORD *)long long __p = valuePtr;
      v106[0] = v125;
    }
    *(void *)&long long v118 = 0;
    if (ctu::cf::convert_copy())
    {
      long long v62 = v116[0];
      v116[0] = (void *)v118;
      *(void *)&long long __dst = v62;
      sub_1000558F4((const void **)&__dst);
    }
    if (SHIBYTE(v106[0]) < 0) {
      operator delete(__p[0]);
    }
    value[0] = v116[0];
    v116[0] = 0;
    sub_1000558F4((const void **)v116);
    if (SHIBYTE(v125) < 0) {
      operator delete((void *)valuePtr);
    }
    CFDictionaryAddValue(v61, @"alt-name", value[0]);
    sub_1000558F4((const void **)value);
    if (SHIBYTE(v110) < 0) {
      operator delete(v109[0]);
    }
  }
  long long v63 = MutableCopy;
  if (*(unsigned char *)(a1 + 344)) {
    CFBooleanRef v64 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v64 = kCFBooleanFalse;
  }
  *(void *)&long long valuePtr = v64;
  __p[0] = 0;
  sub_100062778((const void **)__p);
  *(void *)&long long __dst = valuePtr;
  *(void *)&long long valuePtr = 0;
  sub_100062778((const void **)&valuePtr);
  CFDictionaryAddValue(v63, @"enableXLAT464", (const void *)__dst);
  sub_100062778((const void **)&__dst);
  if (*(void *)(a1 + 232) != *(void *)(a1 + 224))
  {
    v100 = a3;
    CFMutableArrayRef v126 = 0;
    CFMutableArrayRef v65 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFMutableArrayRef v126 = v65;
    long long v67 = *(long long **)(a1 + 224);
    long long v66 = *(long long **)(a1 + 232);
    if (v67 != v66)
    {
      do
      {
        uint64_t v108 = 0;
        *(_OWORD *)long long v106 = 0u;
        long long v107 = 0u;
        *(_OWORD *)long long __p = 0u;
        long long v68 = *v67;
        v106[0] = *((void **)v67 + 2);
        *(_OWORD *)long long __p = v68;
        long long v107 = 0uLL;
        v106[1] = 0;
        sub_100448664(&v106[1], *((const void **)v67 + 3), *((void *)v67 + 4), (uint64_t)(*((void *)v67 + 4) - *((void *)v67 + 3)) >> 2);
        LOBYTE(v108) = *((unsigned char *)v67 + 48);
        CFMutableDictionaryRef v123 = 0;
        CFMutableDictionaryRef v123 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        long long v118 = 0uLL;
        v119 = 0;
        long long v69 = (char *)asString();
        sub_100058DB0(&v118, v69);
        long long v70 = v123;
        if (SHIBYTE(v119) < 0)
        {
          sub_10004FC84(v103, (void *)v118, *((unint64_t *)&v118 + 1));
        }
        else
        {
          *(_OWORD *)v103 = v118;
          long long v104 = v119;
        }
        if (SHIBYTE(v104) < 0)
        {
          sub_10004FC84(&__dst, v103[0], (unint64_t)v103[1]);
        }
        else
        {
          long long __dst = *(_OWORD *)v103;
          v121 = v104;
        }
        v127[0] = 0;
        if (SHIBYTE(v121) < 0)
        {
          sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
        }
        else
        {
          long long valuePtr = __dst;
          v125 = v121;
        }
        value[0] = 0;
        if (ctu::cf::convert_copy())
        {
          long long v71 = (void *)v127[0];
          v127[0] = value[0];
          v116[0] = v71;
          sub_1000558F4((const void **)v116);
        }
        if (SHIBYTE(v125) < 0) {
          operator delete((void *)valuePtr);
        }
        v122 = (__CFDictionary *)v127[0];
        v127[0] = 0;
        sub_1000558F4(v127);
        if (SHIBYTE(v121) < 0) {
          operator delete((void *)__dst);
        }
        CFDictionaryAddValue(v70, @"Type", v122);
        sub_1000558F4((const void **)&v122);
        if (SHIBYTE(v104) < 0) {
          operator delete(v103[0]);
        }
        long long v72 = v123;
        if (BYTE4(__p[0])) {
          CFBooleanRef v73 = kCFBooleanTrue;
        }
        else {
          CFBooleanRef v73 = kCFBooleanFalse;
        }
        *(void *)&long long __dst = v73;
        *(void *)&long long valuePtr = 0;
        sub_100062778((const void **)&valuePtr);
        v116[0] = (void *)__dst;
        *(void *)&long long __dst = 0;
        sub_100062778((const void **)&__dst);
        CFDictionaryAddValue(v72, @"RecoversOnAirplaneMode", v116[0]);
        sub_100062778((const void **)v116);
        v74 = v123;
        if ((_BYTE)v108) {
          CFBooleanRef v75 = kCFBooleanTrue;
        }
        else {
          CFBooleanRef v75 = kCFBooleanFalse;
        }
        *(void *)&long long __dst = v75;
        *(void *)&long long valuePtr = 0;
        sub_100062778((const void **)&valuePtr);
        v116[0] = (void *)__dst;
        *(void *)&long long __dst = 0;
        sub_100062778((const void **)&__dst);
        CFDictionaryAddValue(v74, @"RecoversOnWiFiAPChange", v116[0]);
        sub_100062778((const void **)v116);
        int v76 = v123;
        *(void *)&long long __dst = 0;
        *(void *)&long long valuePtr = LODWORD(__p[1]);
        CFNumberRef v77 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
        if (v77)
        {
          uint64_t v78 = __dst;
          *(void *)&long long __dst = v77;
          *(void *)&long long valuePtr = v78;
          sub_1000570E8((const void **)&valuePtr);
        }
        v116[0] = (void *)__dst;
        *(void *)&long long __dst = 0;
        sub_1000570E8((const void **)&__dst);
        CFDictionaryAddValue(v76, @"NumTriesAllowed", v116[0]);
        sub_1000570E8((const void **)v116);
        v79 = v123;
        *(void *)&long long __dst = 0;
        *(void **)&long long valuePtr = v106[0];
        CFNumberRef v80 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
        if (v80)
        {
          uint64_t v81 = __dst;
          *(void *)&long long __dst = v80;
          *(void *)&long long valuePtr = v81;
          sub_1000570E8((const void **)&valuePtr);
        }
        v116[0] = (void *)__dst;
        *(void *)&long long __dst = 0;
        sub_1000570E8((const void **)&__dst);
        CFDictionaryAddValue(v79, @"Timeout", v116[0]);
        sub_1000570E8((const void **)v116);
        v116[0] = 0;
        CFMutableArrayRef v82 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        v116[0] = v82;
        uint64_t v83 = (int *)v106[1];
        uint64_t v84 = (int *)v107;
        if (v106[1] != (void *)v107)
        {
          do
          {
            int v85 = *v83;
            v86 = (__CFArray *)v116[0];
            *(void *)&long long __dst = 0;
            LODWORD(valuePtr) = v85;
            CFNumberRef v87 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
            if (v87)
            {
              uint64_t v88 = __dst;
              *(void *)&long long __dst = v87;
              *(void *)&long long valuePtr = v88;
              sub_1000570E8((const void **)&valuePtr);
            }
            value[0] = (void *)__dst;
            *(void *)&long long __dst = 0;
            sub_1000570E8((const void **)&__dst);
            CFArrayAppendValue(v86, value[0]);
            sub_1000570E8((const void **)value);
            ++v83;
          }
          while (v83 != v84);
          CFMutableArrayRef v82 = (CFMutableArrayRef)v116[0];
        }
        CFDictionaryAddValue(v123, @"CauseCodes", v82);
        CFArrayAppendValue(v126, v123);
        sub_1000440D4((const void **)v116);
        if (SHIBYTE(v119) < 0) {
          operator delete((void *)v118);
        }
        sub_10005717C((const void **)&v123);
        if (v106[1])
        {
          *(void **)&long long v107 = v106[1];
          operator delete(v106[1]);
        }
        long long v67 = (long long *)((char *)v67 + 56);
      }
      while (v67 != v66);
      CFMutableArrayRef v65 = v126;
    }
    CFDictionaryAddValue(MutableCopy, @"NoCellularReconnectCauseCodes", v65);
    a3 = v100;
    sub_1000440D4((const void **)&v126);
  }
  if (*(unsigned char *)(a1 + 304))
  {
    uint64_t v89 = MutableCopy;
    if (*(char *)(a1 + 303) < 0)
    {
      sub_10004FC84(v101, *(void **)(a1 + 280), *(void *)(a1 + 288));
    }
    else
    {
      *(_OWORD *)unsigned __int8 v101 = *(_OWORD *)(a1 + 280);
      v102 = *(void **)(a1 + 296);
    }
    if (SHIBYTE(v102) < 0)
    {
      sub_10004FC84(&valuePtr, v101[0], (unint64_t)v101[1]);
    }
    else
    {
      long long valuePtr = *(_OWORD *)v101;
      v125 = v102;
    }
    v116[0] = 0;
    if (SHIBYTE(v125) < 0)
    {
      sub_10004FC84(__p, (void *)valuePtr, *((unint64_t *)&valuePtr + 1));
    }
    else
    {
      *(_OWORD *)long long __p = valuePtr;
      v106[0] = v125;
    }
    *(void *)&long long v118 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v90 = v116[0];
      v116[0] = (void *)v118;
      *(void *)&long long __dst = v90;
      sub_1000558F4((const void **)&__dst);
    }
    if (SHIBYTE(v106[0]) < 0) {
      operator delete(__p[0]);
    }
    value[0] = v116[0];
    v116[0] = 0;
    sub_1000558F4((const void **)v116);
    if (SHIBYTE(v125) < 0) {
      operator delete((void *)valuePtr);
    }
    CFDictionaryAddValue(v89, @"OrigApn", value[0]);
    sub_1000558F4((const void **)value);
    if (SHIBYTE(v102) < 0) {
      operator delete(v101[0]);
    }
  }
  if (*(unsigned char *)(a1 + 336))
  {
    *(void *)&long long __dst = 0;
    CFMutableArrayRef v91 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v91)
    {
      v92 = (void *)__dst;
      *(void *)&long long __dst = v91;
      __p[0] = v92;
      sub_1000440D4((const void **)__p);
    }
    if (!*(unsigned char *)(a1 + 336)) {
      sub_10016C840();
    }
    int v94 = *(int **)(a1 + 312);
    v93 = *(int **)(a1 + 320);
    while (v94 != v93)
    {
      int v95 = *v94;
      uint64_t v96 = (__CFArray *)__dst;
      *(void *)&long long valuePtr = 0;
      LODWORD(__p[0]) = v95;
      CFNumberRef v97 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, __p);
      if (v97)
      {
        uint64_t v98 = (void *)valuePtr;
        *(void *)&long long valuePtr = v97;
        __p[0] = v98;
        sub_1000570E8((const void **)__p);
      }
      *(void *)&long long v118 = valuePtr;
      *(void *)&long long valuePtr = 0;
      sub_1000570E8((const void **)&valuePtr);
      CFArrayAppendValue(v96, (const void *)v118);
      sub_1000570E8((const void **)&v118);
      ++v94;
    }
    CFDictionaryAddValue(MutableCopy, @"APNSwitchCauseCodes", (const void *)__dst);
    sub_1000440D4((const void **)&__dst);
  }
  sub_10004EFE4(a3, (CFTypeRef *)&MutableCopy);
  return sub_10005717C((const void **)&MutableCopy);
}

void sub_100C95408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,char a43,int a44,const void *a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,char a52,uint64_t a53,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  sub_1000558F4((const void **)&a53);
  if (*(char *)(v58 - 105) < 0) {
    operator delete(*(void **)(v58 - 128));
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10005717C(&a45);
  _Unwind_Resume(a1);
}

uint64_t sub_100C9585C(uint64_t a1, CFDictionaryRef theDict, int a3)
{
  CFDictionaryRef v4 = theDict;
  CFDictionaryGetValue(theDict, @"apn");
  __p[0] = 0;
  __p[1] = 0;
  unint64_t v232 = 0;
  ctu::cf::assign();
  *(void *)&long long v236 = 0;
  *(void *)((char *)&v236 + 7) = 0;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v6 = v236;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = v6;
  *(void *)(a1 + 63) = *(void *)((char *)&v236 + 7);
  *(unsigned char *)(a1 + 71) = 0;
  CFDictionaryGetValue(v4, @"username");
  __p[0] = 0;
  __p[1] = 0;
  unint64_t v232 = 0;
  ctu::cf::assign();
  *(void *)&long long v236 = 0;
  *(void *)((char *)&v236 + 7) = 0;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v7 = v236;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = v7;
  *(void *)(a1 + 87) = *(void *)((char *)&v236 + 7);
  *(unsigned char *)(a1 + 95) = 0;
  CFDictionaryGetValue(v4, @"password");
  __p[0] = 0;
  __p[1] = 0;
  unint64_t v232 = 0;
  ctu::cf::assign();
  *(void *)&long long v236 = 0;
  *(void *)((char *)&v236 + 7) = 0;
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  uint64_t v8 = v236;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = v8;
  *(void *)(a1 + 111) = *(void *)((char *)&v236 + 7);
  *(unsigned char *)(a1 + 119) = 0;
  CFDictionaryGetValue(v4, @"auth_type");
  __p[0] = 0;
  __p[1] = 0;
  unint64_t v232 = 0;
  ctu::cf::assign();
  *(void *)&long long v236 = 0;
  *(void *)((char *)&v236 + 7) = 0;
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  uint64_t v9 = v236;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = v9;
  *(void *)(a1 + 135) = *(void *)((char *)&v236 + 7);
  *(unsigned char *)(a1 + 143) = 0;
  CFArrayRef Value = (unsigned int *)CFDictionaryGetValue(v4, @"type-mask");
  LODWORD(__p[0]) = 0;
  if (Value && (v11 = Value, CFTypeID v12 = CFGetTypeID(Value), v12 == CFNumberGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)__p, v11, v13);
    unsigned int v14 = __p[0];
  }
  else
  {
    unsigned int v14 = 0;
  }
  *(void *)(a1 + 152) = v14;
  unint64_t v15 = (unsigned int *)CFDictionaryGetValue(v4, @"tech-type-mask");
  CFMutableDictionaryRef v16 = v15;
  LODWORD(__p[0]) = 0;
  if (v15)
  {
    CFTypeID v17 = CFGetTypeID(v15);
    if (v17 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v16, v18);
    }
  }
  *(void *)(a1 + 160) = LODWORD(__p[0]);
  long long v19 = (unsigned int *)CFDictionaryGetValue(v4, @"AllowedProtocolMask");
  CFNumberRef v20 = v19;
  LODWORD(__p[0]) = 0;
  if (!v19) {
    goto LABEL_20;
  }
  CFTypeID v21 = CFGetTypeID(v19);
  if (v21 == CFNumberGetTypeID()) {
    ctu::cf::assign((ctu::cf *)__p, v20, v22);
  }
  int v23 = (int)__p[0];
  if (!LODWORD(__p[0]))
  {
LABEL_20:
    if (*(_DWORD *)(a1 + 144) >= 3u)
    {
      uint64_t v24 = *(void *)(a1 + 152);
      int v23 = 3;
      if ((v24 & 0x20000) == 0)
      {
        if ((v24 & 0x40000) != 0) {
          int v23 = 3;
        }
        else {
          int v23 = 1;
        }
      }
    }
    else
    {
      int v23 = 0;
    }
  }
  *(_DWORD *)(a1 + 168) = v23;
  uint64_t v25 = (unsigned int *)CFDictionaryGetValue(v4, @"AllowedProtocolMaskInRoaming");
  long long v26 = v25;
  LODWORD(__p[0]) = 0;
  if (!v25) {
    goto LABEL_30;
  }
  CFTypeID v27 = CFGetTypeID(v25);
  if (v27 == CFNumberGetTypeID()) {
    ctu::cf::assign((ctu::cf *)__p, v26, v28);
  }
  int v29 = (int)__p[0];
  if (!LODWORD(__p[0]))
  {
LABEL_30:
    if (*(_DWORD *)(a1 + 144) >= 3u)
    {
      uint64_t v30 = *(void *)(a1 + 152);
      int v29 = 3;
      if ((v30 & 0x20000) == 0)
      {
        if ((v30 & 0x40000) != 0) {
          int v29 = 3;
        }
        else {
          int v29 = 1;
        }
      }
    }
    else
    {
      int v29 = 0;
    }
  }
  *(_DWORD *)(a1 + 172) = v29;
  long long v31 = (unsigned int *)CFDictionaryGetValue(v4, @"AllowedProtocolMaskInDomesticRoaming");
  CFNumberRef v32 = v31;
  if (v31)
  {
    CFTypeID v33 = CFGetTypeID(v31);
    if (v33 == CFNumberGetTypeID())
    {
      LODWORD(__p[0]) = 0;
      ctu::cf::assign((ctu::cf *)__p, v32, v34);
      *(_DWORD *)(a1 + 176) = __p[0];
      *(unsigned char *)(a1 + 180) = 1;
    }
  }
  if (a3)
  {
    long long v35 = (unsigned int *)CFDictionaryGetValue(v4, @"InactivityTimer");
    CFNumberRef v36 = v35;
    LODWORD(__p[0]) = 0;
    if (v35)
    {
      CFTypeID v37 = CFGetTypeID(v35);
      if (v37 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)__p, v36, v38);
      }
    }
    *(_DWORD *)(a1 + 184) = __p[0];
    CFNumberRef v39 = (unsigned int *)CFDictionaryGetValue(v4, @"TechnologyMask");
    long long v40 = v39;
    LODWORD(__p[0]) = 0;
    if (v39)
    {
      CFTypeID v41 = CFGetTypeID(v39);
      if (v41 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)__p, v40, v42);
      }
    }
    *(_DWORD *)(a1 + 188) = __p[0];
  }
  uint64_t v43 = (unsigned int *)CFDictionaryGetValue(v4, @"AllowNoDNS");
  CFBooleanRef v44 = v43;
  LODWORD(__p[0]) = 0;
  if (v43)
  {
    CFTypeID v45 = CFGetTypeID(v43);
    if (v45 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v44, v46);
    }
  }
  *(unsigned char *)(a1 + 192) = LODWORD(__p[0]) == 1;
  long long v47 = (BOOL *)CFDictionaryGetValue(v4, @"SupportSwitchOver");
  CFBooleanRef v48 = v47;
  LOBYTE(__p[0]) = 0;
  if (v47)
  {
    CFTypeID v49 = CFGetTypeID(v47);
    if (v49 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v48, v50);
    }
  }
  *(unsigned char *)(a1 + 193) = __p[0];
  int v51 = (BOOL *)CFDictionaryGetValue(v4, @"AlwaysOnPDU");
  CFBooleanRef v52 = v51;
  LOBYTE(__p[0]) = 0;
  if (v51)
  {
    CFTypeID v53 = CFGetTypeID(v51);
    if (v53 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v52, v54);
    }
  }
  *(unsigned char *)(a1 + 194) = __p[0];
  CFNumberRef v55 = (BOOL *)CFDictionaryGetValue(v4, @"SuppressPdnTearDown");
  uint64_t v56 = v55;
  LOBYTE(__p[0]) = 0;
  if (v55)
  {
    CFTypeID v57 = CFGetTypeID(v55);
    if (v57 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v56, v58);
    }
  }
  *(unsigned char *)(a1 + 195) = __p[0];
  long long v59 = (BOOL *)CFDictionaryGetValue(v4, @"Support5GSaHandOver");
  CFBooleanRef v60 = v59;
  LOBYTE(__p[0]) = 0;
  if (v59)
  {
    CFTypeID v61 = CFGetTypeID(v59);
    if (v61 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v60, v62);
    }
  }
  *(unsigned char *)(a1 + 196) = __p[0];
  long long v63 = (BOOL *)CFDictionaryGetValue(v4, @"DontSuspend");
  CFBooleanRef v64 = v63;
  if (v63)
  {
    LOBYTE(__p[0]) = 0;
    CFTypeID v65 = CFGetTypeID(v63);
    if (v65 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v64, v66);
    }
    *(_WORD *)(a1 + 197) = LOBYTE(__p[0]) | 0x100;
  }
  long long v67 = (BOOL *)CFDictionaryGetValue(v4, @"SuspendOnBBCall");
  long long v68 = v67;
  if (v67)
  {
    LOBYTE(__p[0]) = 0;
    CFTypeID v69 = CFGetTypeID(v67);
    if (v69 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v68, v70);
    }
    *(_WORD *)(a1 + 199) = LOBYTE(__p[0]) | 0x100;
  }
  long long v71 = (unsigned __int16 *)CFDictionaryGetValue(v4, @"PcoContainerId");
  long long v72 = v71;
  LOWORD(__p[0]) = 0;
  if (v71)
  {
    CFTypeID v73 = CFGetTypeID(v71);
    if (v73 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v72, v74);
    }
  }
  *(_WORD *)(a1 + 202) = __p[0];
  CFBooleanRef v75 = (void *)CFDictionaryGetValue(v4, @"ProxyConfiguration");
  int v76 = v75;
  if (v75)
  {
    CFTypeID v77 = CFGetTypeID(v75);
    if (v77 == CFDictionaryGetTypeID())
    {
      __p[0] = v76;
      sub_100282490((const void **)(a1 + 208), (CFTypeRef *)__p);
    }
  }
  uint64_t v78 = (BOOL *)CFDictionaryGetValue(v4, @"UseNetworkMTU");
  v79 = v78;
  LOBYTE(__p[0]) = 0;
  if (v78)
  {
    CFTypeID v80 = CFGetTypeID(v78);
    if (v80 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v79, v81);
    }
  }
  *(unsigned char *)(a1 + 216) = __p[0];
  if (CFDictionaryGetValue(v4, @"alt-name"))
  {
    ctu::cf::assign();
    *(_OWORD *)long long __p = 0u;
    unint64_t v232 = 0;
    v229[1] = 0;
    uint64_t v230 = 0;
    v229[0] = 0;
    sub_10008BE4C(a1 + 248, (long long *)__p);
    if (SHIBYTE(v232) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v230) < 0) {
      operator delete(v229[0]);
    }
  }
  CFMutableArrayRef v82 = (BOOL *)CFDictionaryGetValue(v4, @"enableXLAT464");
  uint64_t v83 = v82;
  LOBYTE(__p[0]) = 0;
  if (v82)
  {
    CFTypeID v84 = CFGetTypeID(v82);
    if (v84 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)__p, v83, v85);
    }
  }
  *(unsigned char *)(a1 + 344) = __p[0];
  v218 = (void *)(a1 + 224);
  sub_100BC5088((uint64_t *)(a1 + 224));
  if (CFDictionaryGetValue(v4, @"NoCellularReconnectCauseCodes"))
  {
    CFArrayRef theArray = 0;
    __p[0] = (void *)CFDictionaryGetValue(v4, @"NoCellularReconnectCauseCodes");
    sub_100044D6C(&theArray, (CFTypeRef *)__p);
    CFDictionaryRef v217 = v4;
    if (theArray) {
      v86 = sub_100083F10;
    }
    else {
      v86 = 0;
    }
    if (v86)
    {
      CFIndex Count = CFArrayGetCount(theArray);
      CFIndex v88 = Count;
      if (Count >= 1)
      {
        CFIndex v89 = 0;
        CFIndex v219 = Count;
        do
        {
          CFDictionaryRef theDicta = 0;
          __p[0] = (void *)CFArrayGetValueAtIndex(theArray, v89);
          sub_10004EFE4(&theDicta, (CFTypeRef *)__p);
          if (theDicta) {
            uint64_t v90 = sub_100080778;
          }
          else {
            uint64_t v90 = 0;
          }
          if (!v90) {
            goto LABEL_238;
          }
          CFMutableArrayRef v91 = CFDictionaryGetValue(theDicta, @"Type");
          CFDictionaryRef v92 = theDicta;
          if (!v91)
          {
            int v98 = 1;
            goto LABEL_130;
          }
          CFDictionaryGetValue(theDicta, @"Type");
          __p[0] = 0;
          __p[1] = 0;
          unint64_t v232 = 0;
          ctu::cf::assign();
          long long v236 = *(_OWORD *)__p;
          v237 = (char *)v232;
          unint64_t v93 = HIBYTE(v232);
          unint64_t v94 = HIBYTE(v232);
          if ((v232 & 0x8000000000000000) == 0) {
            unint64_t v95 = HIBYTE(v232);
          }
          else {
            unint64_t v95 = *((void *)&v236 + 1);
          }
          if (v95 == 7)
          {
            if ((v232 & 0x8000000000000000) != 0)
            {
              unsigned __int8 v101 = (void *)v236;
              if (!memcmp((const void *)v236, "Non3GPP", (size_t)__p[1]))
              {
                int v98 = 3;
                goto LABEL_128;
              }
              goto LABEL_124;
            }
            if (!v94)
            {
              int v98 = 3;
              goto LABEL_129;
            }
            v99 = (unsigned __int8 *)&v236;
            v100 = "Non3GPP";
            while (*v99 == *(unsigned __int8 *)v100)
            {
              ++v99;
              ++v100;
              if (!--v93)
              {
                int v98 = 3;
                if ((v232 & 0x8000000000000000) == 0) {
                  goto LABEL_129;
                }
                goto LABEL_120;
              }
            }
          }
          else if (v95 == 5)
          {
            if ((v232 & 0x8000000000000000) != 0)
            {
              unsigned __int8 v101 = (void *)v236;
              if (!memcmp((const void *)v236, "3GPP2", (size_t)__p[1]))
              {
                int v98 = 2;
                goto LABEL_128;
              }
LABEL_124:
              int v98 = 1;
              goto LABEL_128;
            }
            if (!v94)
            {
              int v98 = 2;
              goto LABEL_129;
            }
            uint64_t v96 = (unsigned __int8 *)&v236;
            CFNumberRef v97 = "3GPP2";
            while (*v96 == *(unsigned __int8 *)v97)
            {
              ++v96;
              ++v97;
              if (!--v93)
              {
                int v98 = 2;
                if ((v232 & 0x8000000000000000) == 0) {
                  goto LABEL_129;
                }
                goto LABEL_120;
              }
            }
          }
          int v98 = 1;
          if ((v232 & 0x8000000000000000) != 0)
          {
LABEL_120:
            unsigned __int8 v101 = (void *)v236;
LABEL_128:
            operator delete(v101);
          }
LABEL_129:
          CFDictionaryRef v92 = theDicta;
LABEL_130:
          if (CFDictionaryGetValue(v92, @"RecoversOnAirplaneMode"))
          {
            v102 = (BOOL *)CFDictionaryGetValue(theDicta, @"RecoversOnAirplaneMode");
            v103 = v102;
            LOBYTE(__p[0]) = 0;
            if (v102)
            {
              CFTypeID v104 = CFGetTypeID(v102);
              if (v104 == CFBooleanGetTypeID()) {
                ctu::cf::assign((ctu::cf *)__p, v103, v105);
              }
            }
            BOOL v106 = LOBYTE(__p[0]) != 0;
          }
          else
          {
            BOOL v106 = 0;
          }
          if (CFDictionaryGetValue(theDicta, @"RecoversOnWiFiAPChange"))
          {
            long long v107 = (BOOL *)CFDictionaryGetValue(theDicta, @"RecoversOnWiFiAPChange");
            uint64_t v108 = v107;
            LOBYTE(__p[0]) = 0;
            if (v107)
            {
              CFTypeID v109 = CFGetTypeID(v107);
              if (v109 == CFBooleanGetTypeID()) {
                ctu::cf::assign((ctu::cf *)__p, v108, v110);
              }
            }
            BOOL v111 = LOBYTE(__p[0]) != 0;
          }
          else
          {
            BOOL v111 = 0;
          }
          if (CFDictionaryGetValue(theDicta, @"NumTriesAllowed"))
          {
            long long v112 = (unsigned int *)CFDictionaryGetValue(theDicta, @"NumTriesAllowed");
            long long v113 = v112;
            LODWORD(__p[0]) = 0;
            if (v112)
            {
              CFTypeID v114 = CFGetTypeID(v112);
              if (v114 == CFNumberGetTypeID()) {
                ctu::cf::assign((ctu::cf *)__p, v113, v115);
              }
            }
            int v116 = (int)__p[0];
          }
          else
          {
            int v116 = 1;
          }
          BOOL v221 = v111;
          if (CFDictionaryGetValue(theDicta, @"Timeout"))
          {
            v117 = (uint64_t *)CFDictionaryGetValue(theDicta, @"Timeout");
            long long v118 = v117;
            __p[0] = 0;
            if (v117)
            {
              CFTypeID v119 = CFGetTypeID(v117);
              if (v119 == CFNumberGetTypeID()) {
                ctu::cf::assign((ctu::cf *)__p, v118, v120);
              }
            }
            v220 = __p[0];
          }
          else
          {
            v220 = 0;
          }
          long long v236 = 0uLL;
          v237 = 0;
          v121 = (int *)CFDictionaryGetValue(theDicta, @"CauseCodes");
          v122 = v121;
          if (v121)
          {
            CFTypeID v123 = CFGetTypeID(v121);
            if (v123 == CFNumberGetTypeID())
            {
              __p[0] = 0;
              v226 = v122;
              sub_1000842D0(__p, (CFTypeRef *)&v226);
              if (__p[0]) {
                v125 = sub_100081E58;
              }
              else {
                v125 = 0;
              }
              if (v125)
              {
                LODWORD(v226) = 0;
                ctu::cf::assign((ctu::cf *)&v226, (int *)__p[0], v124);
                int v126 = (int)v226;
                v127 = (char *)*((void *)&v236 + 1);
                if (*((void *)&v236 + 1) >= (unint64_t)v237)
                {
                  v147 = (char *)v236;
                  uint64_t v148 = (uint64_t)(*((void *)&v236 + 1) - v236) >> 2;
                  unint64_t v149 = v148 + 1;
                  if ((unint64_t)(v148 + 1) >> 62) {
                    sub_10006A748();
                  }
                  uint64_t v150 = (uint64_t)&v237[-v236];
                  if ((uint64_t)&v237[-v236] >> 1 > v149) {
                    unint64_t v149 = v150 >> 1;
                  }
                  if ((unint64_t)v150 >= 0x7FFFFFFFFFFFFFFCLL) {
                    unint64_t v151 = 0x3FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v151 = v149;
                  }
                  if (v151)
                  {
                    v152 = (char *)sub_10005ECD8((uint64_t)&v237, v151);
                    v127 = (char *)*((void *)&v236 + 1);
                    v147 = (char *)v236;
                  }
                  else
                  {
                    v152 = 0;
                  }
                  v153 = &v152[4 * v148];
                  *(_DWORD *)v153 = v126;
                  v128 = v153 + 4;
                  while (v127 != v147)
                  {
                    int v154 = *((_DWORD *)v127 - 1);
                    v127 -= 4;
                    *((_DWORD *)v153 - 1) = v154;
                    v153 -= 4;
                  }
                  *(void *)&long long v236 = v153;
                  *((void *)&v236 + 1) = v128;
                  v237 = &v152[4 * v151];
                  if (v147) {
                    operator delete(v147);
                  }
                }
                else
                {
                  **((_DWORD **)&v236 + 1) = v226;
                  v128 = v127 + 4;
                }
                *((void *)&v236 + 1) = v128;
              }
              sub_1000570E8((const void **)__p);
            }
            else
            {
              CFTypeID v129 = CFGetTypeID(v122);
              if (v129 == CFArrayGetTypeID())
              {
                __p[0] = 0;
                v226 = v122;
                sub_100044D6C(__p, (CFTypeRef *)&v226);
                if (__p[0]) {
                  v130 = sub_100083F10;
                }
                else {
                  v130 = 0;
                }
                if (v130)
                {
                  CFIndex v131 = CFArrayGetCount((CFArrayRef)__p[0]);
                  if (v131 >= 1)
                  {
                    for (CFIndex i = 0; i != v131; ++i)
                    {
                      v226 = 0;
                      CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)__p[0], i);
                      sub_1000842D0(&v226, &ValueAtIndex);
                      if (v226) {
                        v134 = sub_100081E58;
                      }
                      else {
                        v134 = 0;
                      }
                      if (v134)
                      {
                        LODWORD(ValueAtIndex) = 0;
                        ctu::cf::assign((ctu::cf *)&ValueAtIndex, v226, v133);
                        int v135 = (int)ValueAtIndex;
                        v136 = (char *)*((void *)&v236 + 1);
                        if (*((void *)&v236 + 1) >= (unint64_t)v237)
                        {
                          v138 = (char *)v236;
                          uint64_t v139 = (uint64_t)(*((void *)&v236 + 1) - v236) >> 2;
                          unint64_t v140 = v139 + 1;
                          if ((unint64_t)(v139 + 1) >> 62) {
                            sub_10006A748();
                          }
                          uint64_t v141 = (uint64_t)&v237[-v236];
                          if ((uint64_t)&v237[-v236] >> 1 > v140) {
                            unint64_t v140 = v141 >> 1;
                          }
                          if ((unint64_t)v141 >= 0x7FFFFFFFFFFFFFFCLL) {
                            unint64_t v142 = 0x3FFFFFFFFFFFFFFFLL;
                          }
                          else {
                            unint64_t v142 = v140;
                          }
                          if (v142)
                          {
                            v143 = (char *)sub_10005ECD8((uint64_t)&v237, v142);
                            v136 = (char *)*((void *)&v236 + 1);
                            v138 = (char *)v236;
                          }
                          else
                          {
                            v143 = 0;
                          }
                          v144 = &v143[4 * v139];
                          *(_DWORD *)v144 = v135;
                          v137 = v144 + 4;
                          while (v136 != v138)
                          {
                            int v145 = *((_DWORD *)v136 - 1);
                            v136 -= 4;
                            *((_DWORD *)v144 - 1) = v145;
                            v144 -= 4;
                          }
                          *(void *)&long long v236 = v144;
                          *((void *)&v236 + 1) = v137;
                          v237 = &v143[4 * v142];
                          if (v138) {
                            operator delete(v138);
                          }
                        }
                        else
                        {
                          **((_DWORD **)&v236 + 1) = ValueAtIndex;
                          v137 = v136 + 4;
                        }
                        *((void *)&v236 + 1) = v137;
                      }
                      sub_1000570E8((const void **)&v226);
                    }
                  }
                }
                sub_100044D00((const void **)__p);
              }
              else
              {
                v146 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(__p[0]) = 136315138;
                  *(void **)((char *)__p + 4) = "fromDict";
                  _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong data type in CauseCodes", (uint8_t *)__p, 0xCu);
                }
              }
            }
          }
          v155 = (void *)*((void *)&v236 + 1);
          if (*((void *)&v236 + 1) == (void)v236)
          {
            CFIndex v88 = v219;
            if (!*((void *)&v236 + 1)) {
              goto LABEL_238;
            }
          }
          else
          {
            v223 = 0;
            uint64_t v224 = 0;
            v222 = 0;
            sub_100448664(&v222, (const void *)v236, *((uint64_t *)&v236 + 1), (uint64_t)(*((void *)&v236 + 1) - v236) >> 2);
            LODWORD(__p[0]) = v98;
            BYTE4(__p[0]) = v106;
            LODWORD(__p[1]) = v116;
            unint64_t v232 = (unint64_t)v220;
            uint64_t v234 = 0;
            long long v233 = 0uLL;
            sub_100448664(&v233, v222, (uint64_t)v223, (v223 - (unsigned char *)v222) >> 2);
            BOOL v235 = v221;
            unint64_t v156 = *(void *)(a1 + 232);
            unint64_t v157 = *(void *)(a1 + 240);
            CFIndex v88 = v219;
            if (v156 >= v157)
            {
              uint64_t v159 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v156 - *v218) >> 3);
              unint64_t v160 = v159 + 1;
              if ((unint64_t)(v159 + 1) > 0x492492492492492) {
                sub_10006A748();
              }
              unint64_t v161 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v157 - *v218) >> 3);
              if (2 * v161 > v160) {
                unint64_t v160 = 2 * v161;
              }
              if (v161 >= 0x249249249249249) {
                unint64_t v162 = 0x492492492492492;
              }
              else {
                unint64_t v162 = v160;
              }
              v163 = (char *)sub_100341ECC(a1 + 240, v162);
              v165 = &v163[56 * v159];
              unint64_t v166 = v232;
              *(_OWORD *)v165 = *(_OWORD *)__p;
              *((void *)v165 + 2) = v166;
              *((void *)v165 + 3) = 0;
              *((void *)v165 + 4) = 0;
              *((void *)v165 + 5) = 0;
              *(_OWORD *)(v165 + 24) = v233;
              *((void *)v165 + 5) = v234;
              long long v233 = 0uLL;
              uint64_t v234 = 0;
              v165[48] = v235;
              v167 = *(char **)(a1 + 224);
              v168 = *(char **)(a1 + 232);
              if (v168 == v167)
              {
                v174 = v165 + 56;
                *(void *)(a1 + 224) = v165;
                *(void *)(a1 + 232) = v165 + 56;
                *(void *)(a1 + 240) = &v163[56 * v164];
              }
              else
              {
                uint64_t v169 = 0;
                do
                {
                  v170 = &v165[v169];
                  v171 = &v168[v169];
                  uint64_t v172 = *(void *)&v168[v169 - 40];
                  *(_OWORD *)(v170 - 56) = *(_OWORD *)&v168[v169 - 56];
                  *((void *)v170 - 5) = v172;
                  *((void *)v170 - 4) = 0;
                  *((void *)v170 - 3) = 0;
                  *((void *)v170 - 2) = 0;
                  *((_OWORD *)v170 - 2) = *(_OWORD *)&v168[v169 - 32];
                  *((void *)v170 - 2) = *(void *)&v168[v169 - 16];
                  *((void *)v171 - 4) = 0;
                  *((void *)v171 - 3) = 0;
                  *((void *)v171 - 2) = 0;
                  *(v170 - 8) = v168[v169 - 8];
                  v169 -= 56;
                }
                while (&v168[v169] != v167);
                v168 = *(char **)(a1 + 224);
                v173 = *(char **)(a1 + 232);
                v174 = v165 + 56;
                *(void *)(a1 + 224) = &v165[v169];
                *(void *)(a1 + 232) = v165 + 56;
                *(void *)(a1 + 240) = &v163[56 * v164];
                while (v173 != v168)
                {
                  v175 = (void *)*((void *)v173 - 4);
                  if (v175)
                  {
                    *((void *)v173 - 3) = v175;
                    operator delete(v175);
                  }
                  v173 -= 56;
                }
              }
              if (v168) {
                operator delete(v168);
              }
              v176 = (void *)v233;
              *(void *)(a1 + 232) = v174;
              if (v176)
              {
                *((void *)&v233 + 1) = v176;
                operator delete(v176);
              }
            }
            else
            {
              unint64_t v158 = v232;
              *(_OWORD *)unint64_t v156 = *(_OWORD *)__p;
              *(void *)(v156 + 16) = v158;
              *(void *)(v156 + 24) = 0;
              *(void *)(v156 + 32) = 0;
              *(void *)(v156 + 40) = 0;
              *(_OWORD *)(v156 + 24) = v233;
              *(void *)(v156 + 40) = v234;
              long long v233 = 0uLL;
              uint64_t v234 = 0;
              *(unsigned char *)(v156 + 48) = v235;
              *(void *)(a1 + 232) = v156 + 56;
            }
            if (v222)
            {
              v223 = v222;
              operator delete(v222);
            }
            v155 = (void *)v236;
            if (!(void)v236) {
              goto LABEL_238;
            }
          }
          *((void *)&v236 + 1) = v155;
          operator delete(v155);
LABEL_238:
          sub_100057D78((const void **)&theDicta);
          ++v89;
        }
        while (v89 != v88);
      }
    }
    sub_100044D00((const void **)&theArray);
    CFDictionaryRef v4 = v217;
  }
  if (*(unsigned char *)(a1 + 304))
  {
    if (*(char *)(a1 + 303) < 0) {
      operator delete(*(void **)(a1 + 280));
    }
    *(unsigned char *)(a1 + 304) = 0;
  }
  if (CFDictionaryGetValue(v4, @"OrigApn"))
  {
    ctu::cf::assign();
    *(_OWORD *)long long __p = 0u;
    unint64_t v232 = 0;
    sub_10008BE4C(a1 + 280, (long long *)__p);
    if (SHIBYTE(v232) < 0) {
      operator delete(__p[0]);
    }
  }
  v177 = (void **)(a1 + 312);
  if (*(unsigned char *)(a1 + 336))
  {
    v178 = *v177;
    if (*v177)
    {
      *(void *)(a1 + 320) = v178;
      operator delete(v178);
    }
    *(unsigned char *)(a1 + 336) = 0;
  }
  v179 = (void *)CFDictionaryGetValue(v4, @"APNSwitchCauseCodes");
  v180 = v179;
  if (v179)
  {
    CFTypeID v181 = CFGetTypeID(v179);
    if (v181 == CFNumberGetTypeID())
    {
      *(void *)&long long v236 = 0;
      __p[0] = v180;
      sub_1000842D0(&v236, (CFTypeRef *)__p);
      if ((void)v236) {
        v182 = sub_100081E58;
      }
      else {
        v182 = 0;
      }
      if (v182)
      {
        __p[0] = 0;
        __p[1] = 0;
        unint64_t v232 = 0;
        sub_100195D74(a1 + 312, (__n128 *)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        if (!*(unsigned char *)(a1 + 336)) {
          sub_10016C840();
        }
        LODWORD(__p[0]) = 0;
        ctu::cf::assign((ctu::cf *)__p, (int *)v236, v183);
        int v184 = (int)__p[0];
        v186 = *(char **)(a1 + 320);
        unint64_t v185 = *(void *)(a1 + 328);
        if ((unint64_t)v186 >= v185)
        {
          v207 = (char *)*v177;
          uint64_t v208 = (v186 - (unsigned char *)*v177) >> 2;
          unint64_t v209 = v208 + 1;
          if ((unint64_t)(v208 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v210 = v185 - (void)v207;
          if (v210 >> 1 > v209) {
            unint64_t v209 = v210 >> 1;
          }
          if ((unint64_t)v210 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v211 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v211 = v209;
          }
          if (v211)
          {
            v212 = (char *)sub_10005ECD8(a1 + 328, v211);
            v207 = *(char **)(a1 + 312);
            v186 = *(char **)(a1 + 320);
          }
          else
          {
            v212 = 0;
          }
          v213 = &v212[4 * v208];
          v214 = &v212[4 * v211];
          *(_DWORD *)v213 = v184;
          v187 = v213 + 4;
          while (v186 != v207)
          {
            int v215 = *((_DWORD *)v186 - 1);
            v186 -= 4;
            *((_DWORD *)v213 - 1) = v215;
            v213 -= 4;
          }
          *(void *)(a1 + 312) = v213;
          *(void *)(a1 + 320) = v187;
          *(void *)(a1 + 328) = v214;
          if (v207) {
            operator delete(v207);
          }
        }
        else
        {
          *(_DWORD *)v186 = __p[0];
          v187 = v186 + 4;
        }
        *(void *)(a1 + 320) = v187;
      }
      sub_1000570E8((const void **)&v236);
    }
    else
    {
      CFTypeID v188 = CFGetTypeID(v180);
      if (v188 == CFArrayGetTypeID())
      {
        *(void *)&long long v236 = 0;
        __p[0] = v180;
        sub_100044D6C(&v236, (CFTypeRef *)__p);
        if ((void)v236) {
          v189 = sub_100083F10;
        }
        else {
          v189 = 0;
        }
        if (v189)
        {
          __p[0] = 0;
          __p[1] = 0;
          unint64_t v232 = 0;
          sub_100195D74(a1 + 312, (__n128 *)__p);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          CFIndex v190 = CFArrayGetCount((CFArrayRef)v236);
          if (v190 >= 1)
          {
            for (CFIndex j = 0; j != v190; ++j)
            {
              __p[0] = 0;
              CFArrayRef theArray = (CFArrayRef)CFArrayGetValueAtIndex((CFArrayRef)v236, j);
              sub_1000842D0(__p, (CFTypeRef *)&theArray);
              if (__p[0]) {
                v193 = sub_100081E58;
              }
              else {
                v193 = 0;
              }
              if (v193)
              {
                if (!*(unsigned char *)(a1 + 336)) {
                  sub_10016C840();
                }
                LODWORD(theArray) = 0;
                ctu::cf::assign((ctu::cf *)&theArray, (int *)__p[0], v192);
                int v194 = (int)theArray;
                v196 = *(char **)(a1 + 320);
                unint64_t v195 = *(void *)(a1 + 328);
                if ((unint64_t)v196 >= v195)
                {
                  v198 = (char *)*v177;
                  uint64_t v199 = (v196 - (unsigned char *)*v177) >> 2;
                  unint64_t v200 = v199 + 1;
                  if ((unint64_t)(v199 + 1) >> 62) {
                    sub_10006A748();
                  }
                  uint64_t v201 = v195 - (void)v198;
                  if (v201 >> 1 > v200) {
                    unint64_t v200 = v201 >> 1;
                  }
                  if ((unint64_t)v201 >= 0x7FFFFFFFFFFFFFFCLL) {
                    unint64_t v202 = 0x3FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v202 = v200;
                  }
                  if (v202)
                  {
                    v203 = (char *)sub_10005ECD8(a1 + 328, v202);
                    v198 = *(char **)(a1 + 312);
                    v196 = *(char **)(a1 + 320);
                  }
                  else
                  {
                    v203 = 0;
                  }
                  v204 = &v203[4 * v199];
                  *(_DWORD *)v204 = v194;
                  v197 = v204 + 4;
                  while (v196 != v198)
                  {
                    int v205 = *((_DWORD *)v196 - 1);
                    v196 -= 4;
                    *((_DWORD *)v204 - 1) = v205;
                    v204 -= 4;
                  }
                  *(void *)(a1 + 312) = v204;
                  *(void *)(a1 + 320) = v197;
                  *(void *)(a1 + 328) = &v203[4 * v202];
                  if (v198) {
                    operator delete(v198);
                  }
                }
                else
                {
                  *(_DWORD *)v196 = theArray;
                  v197 = v196 + 4;
                }
                *(void *)(a1 + 320) = v197;
              }
              sub_1000570E8((const void **)__p);
            }
          }
        }
        sub_100044D00((const void **)&v236);
      }
      else
      {
        v206 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = "fromDict";
          _os_log_impl((void *)&_mh_execute_header, v206, OS_LOG_TYPE_DEFAULT, "#I %s: Wrong data type in APNSwitchCauseCodes", (uint8_t *)__p, 0xCu);
        }
      }
    }
  }
  return 1;
}

void sub_100C96DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,int a29,__int16 a30,char a31,char a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50)
{
  sub_100044D00((const void **)(v50 - 128));
  _Unwind_Resume(a1);
}

const void **sub_100C96FA4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  sub_100C940DC(a1, 0, &v4);
  sub_100C97000((CFDictionaryRef *)&v4, a2);
  return sub_100057D78(&v4);
}

void sub_100C96FEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100C97000@<X0>(CFDictionaryRef *a1@<X0>, void *a2@<X8>)
{
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *a1);
  CFDictionaryRef v4 = operator new(0x60uLL);
  uint64_t v5 = 0;
  v4[2] = *(_OWORD *)off_101A4D930;
  v4[3] = *(_OWORD *)off_101A4D940;
  v4[4] = *(_OWORD *)off_101A4D950;
  v4[5] = *(_OWORD *)off_101A4D960;
  _OWORD *v4 = *(_OWORD *)off_101A4D910;
  v4[1] = *(_OWORD *)off_101A4D920;
  do
  {
    uint64_t v6 = MutableCopy;
    uint64_t v7 = *(const __CFString ***)((char *)v4 + v5);
    CFTypeID v12 = 0;
    CFNumberRef v13 = 0;
    if (ctu::cf::convert_copy((ctu::cf *)&v13, v7, (const char *)0x8000100, kCFAllocatorDefault, v3))
    {
      uint64_t v8 = v12;
      CFTypeID v12 = v13;
      unsigned int v14 = v8;
      sub_1000558F4(&v14);
    }
    key = v12;
    CFTypeID v12 = 0;
    sub_1000558F4((const void **)&v12);
    CFDictionaryRemoveValue(v6, key);
    sub_1000558F4((const void **)&key);
    v5 += 8;
  }
  while (v5 != 96);
  sub_10004EFE4(a2, (CFTypeRef *)&MutableCopy);
  operator delete(v4);
  return sub_10005717C((const void **)&MutableCopy);
}

void sub_100C97110(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, const void *a12, __int16 a13, char a14, char a15)
{
  operator delete(v15);
  sub_10005717C(&a12);
  _Unwind_Resume(a1);
}

void sub_100C97150(uint64_t a1, os_log_t *a2)
{
  uint64_t v3 = a1;
  int v4 = *(unsigned __int8 *)(a1 + 180);
  os_log_t v5 = *a2;
  BOOL v6 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (!v6) {
      goto LABEL_90;
    }
    unsigned int v7 = *(_DWORD *)(v3 + 144) - 1;
    if (v7 > 4) {
      uint64_t v8 = "UI";
    }
    else {
      uint64_t v8 = off_101A4DF50[v7];
    }
    int v11 = *(_DWORD *)(v3 + 148);
    uint64_t v12 = v3;
    sub_100C93D68(v125, v3);
    if (v128 >= 0) {
      CFNumberRef v13 = v125;
    }
    else {
      CFNumberRef v13 = *(unsigned char **)v125;
    }
    asStringMask((uint64_t *)v123, *(void *)(v12 + 152));
    if (v124 >= 0) {
      unsigned int v14 = v123;
    }
    else {
      unsigned int v14 = (void **)v123[0];
    }
    uint64_t v15 = *(void *)(v12 + 152);
    asStringMask((uint64_t *)v121, *(void *)(v12 + 160));
    CFMutableDictionaryRef v16 = (void **)v121[0];
    if (v122 >= 0) {
      CFMutableDictionaryRef v16 = v121;
    }
    long long v112 = v16;
    if (*(unsigned char *)(v12 + 180)) {
      int v17 = *(_DWORD *)(v12 + 176);
    }
    else {
      int v17 = 0;
    }
    uint64_t v104 = *(void *)(v12 + 160);
    int v106 = *(_DWORD *)(v12 + 168);
    int v108 = *(_DWORD *)(v12 + 172);
    int v110 = *(_DWORD *)(v12 + 184);
    WirelessTechnologyList::asString((uint64_t *)v119, (WirelessTechnologyList *)(v12 + 188));
    if (v120 >= 0) {
      CFNumberRef v18 = v119;
    }
    else {
      CFNumberRef v18 = (void **)v119[0];
    }
    int v98 = v18;
    int v100 = *(_DWORD *)(v12 + 188);
    uint64_t v96 = asStringBool(*(unsigned char *)(v12 + 192));
    uint64_t v94 = asStringBool(*(unsigned char *)(v12 + 193));
    uint64_t v92 = asStringBool();
    uint64_t v90 = asStringBool();
    int v76 = *(unsigned __int16 *)(v12 + 202);
    CFNumberRef v20 = *(ctu **)(v12 + 208);
    if (v20) {
      CFTypeID v21 = sub_100080778;
    }
    else {
      CFTypeID v21 = 0;
    }
    v102 = v21;
    log = v5;
    CFIndex v88 = v8;
    int v86 = v11;
    uint64_t v82 = v15;
    CFTypeID v84 = v13;
    CFTypeID v80 = v14;
    int v78 = v17;
    if (v21)
    {
      ctu::cf_to_xpc((uint64_t *)&object, v20, v19);
      xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
      if (v118 >= 0) {
        CFNumberRef v22 = __p;
      }
      else {
        CFNumberRef v22 = (void **)__p[0];
      }
    }
    else
    {
      CFNumberRef v22 = (void **)"";
    }
    CFNumberRef v74 = v22;
    uint64_t v73 = asStringBool(*(unsigned char *)(v12 + 216));
    uint64_t v23 = v12;
    if (*(unsigned char *)(v12 + 272))
    {
      uint64_t v24 = (const char *)(v12 + 248);
      if (*(char *)(v12 + 271) < 0) {
        uint64_t v24 = *(const char **)v24;
      }
    }
    else
    {
      uint64_t v24 = "no alt name";
    }
    uint64_t v25 = asStringBool(*(unsigned char *)(v12 + 344));
    if (*(unsigned char *)(v12 + 304))
    {
      long long v26 = (const char *)(v12 + 280);
      if (*(char *)(v12 + 303) < 0) {
        long long v26 = *(const char **)v26;
      }
    }
    else
    {
      long long v26 = "no orig apn";
    }
    if (*(unsigned char *)(v12 + 336)) {
      uint64_t v27 = (*(void *)(v12 + 320) - *(void *)(v12 + 312)) >> 2;
    }
    else {
      LODWORD(v27) = 0;
    }
    uint64_t v28 = *(void *)(v23 + 224);
    uint64_t v29 = *(void *)(v23 + 232);
    uint64_t v30 = asStringBool(*(unsigned char *)(v23 + 194));
    uint64_t v31 = asStringBool(*(unsigned char *)(v23 + 196));
    uint64_t v32 = asStringBool(*(unsigned char *)(v23 + 195));
    *(_DWORD *)std::string buf = 136322050;
    *(void *)&uint8_t buf[4] = v88;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v86;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v84;
    *(_WORD *)&buf[28] = 2082;
    *(void *)&buf[30] = v80;
    *(_WORD *)&buf[38] = 2048;
    uint64_t v133 = v82;
    *(_WORD *)v134 = 2082;
    *(void *)&v134[2] = v112;
    __int16 v135 = 2048;
    uint64_t v136 = v104;
    __int16 v137 = 1024;
    int v138 = v106;
    __int16 v139 = 1024;
    int v140 = v108;
    __int16 v141 = 1024;
    int v142 = v78;
    __int16 v143 = 1024;
    *(_DWORD *)v144 = v110;
    *(_WORD *)&v144[4] = 2082;
    *(void *)&v144[6] = v98;
    __int16 v145 = 1024;
    *(_DWORD *)v146 = v100;
    *(_WORD *)&v146[4] = 2080;
    *(void *)&v146[6] = v96;
    *(_WORD *)&v146[14] = 2080;
    *(void *)&v146[16] = v94;
    *(_WORD *)&v146[24] = 2080;
    *(void *)&v146[26] = v92;
    *(_WORD *)&v146[34] = 2080;
    *(void *)&v146[36] = v90;
    __int16 v147 = 1024;
    *(_DWORD *)uint64_t v148 = v76;
    *(_WORD *)&v148[4] = 2080;
    *(void *)&v148[6] = v74;
    *(_WORD *)&v148[14] = 2080;
    *(void *)&v148[16] = v73;
    *(_WORD *)&v148[24] = 2080;
    *(void *)&v148[26] = v24;
    *(_WORD *)&v148[34] = 2080;
    *(void *)&v148[36] = v25;
    __int16 v149 = 1024;
    *(_DWORD *)uint64_t v150 = -1227133513 * ((unint64_t)(v29 - v28) >> 3);
    *(_WORD *)&v150[4] = 2080;
    *(void *)&v150[6] = v26;
    __int16 v151 = 1024;
    *(_DWORD *)v152 = v27;
    *(_WORD *)&v152[4] = 2080;
    *(void *)&v152[6] = v30;
    *(_WORD *)&v152[14] = 2080;
    *(void *)&v152[16] = v31;
    *(_WORD *)&v152[24] = 2080;
    *(void *)&v152[26] = v32;
    _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t APNInfo: src: %s.%d, base: %{public}s, type-mask: %{public}s (0x%llx), tech-type-mask: %{public}s (0x%llx), AllowedProtocolMask: 0x%x, AllowedProtocolMaskInRoaming: 0x%x, AllowedProtocolMaskInDomesticRoaming: 0x%x, inactivity: %u, tech-mask: %{public}s (0x%x), allow no DNS: %s, support SwitchOver: %s, don't suspend context: %s, suspend context on BBCall: %s, Pco Container Id: %u, proxy:{%s}, use network MTU: %s, alt-name:'%s', xlat464: %s, blockers: %u, OrigApn:'%s', APNSwitchCauseCodes: %u, alwaysOnPDU: %s, support5GSaHandOver: %s, SuppressPdnTearDown: %s", buf, 0xF6u);
    uint64_t v3 = v23;
    if (!v102) {
      goto LABEL_82;
    }
    if (v118 < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_81;
  }
  if (!v6) {
    goto LABEL_90;
  }
  unsigned int v9 = *(_DWORD *)(v3 + 144) - 1;
  if (v9 > 4) {
    int v10 = "UI";
  }
  else {
    int v10 = off_101A4DF50[v9];
  }
  int v33 = *(_DWORD *)(v3 + 148);
  uint64_t v34 = v3;
  sub_100C93D68(v125, v3);
  if (v128 >= 0) {
    long long v35 = v125;
  }
  else {
    long long v35 = *(unsigned char **)v125;
  }
  asStringMask((uint64_t *)v123, *(void *)(v34 + 152));
  if (v124 >= 0) {
    CFNumberRef v36 = v123;
  }
  else {
    CFNumberRef v36 = (void **)v123[0];
  }
  uint64_t v37 = *(void *)(v34 + 152);
  asStringMask((uint64_t *)v121, *(void *)(v34 + 160));
  if (v122 >= 0) {
    CFNumberRef v38 = v121;
  }
  else {
    CFNumberRef v38 = (void **)v121[0];
  }
  long long v107 = v38;
  uint64_t v109 = *(void *)(v34 + 160);
  int v111 = *(_DWORD *)(v34 + 168);
  int v113 = *(_DWORD *)(v34 + 172);
  int v39 = *(_DWORD *)(v34 + 184);
  WirelessTechnologyList::asString((uint64_t *)v119, (WirelessTechnologyList *)(v34 + 188));
  if (v120 >= 0) {
    long long v40 = v119;
  }
  else {
    long long v40 = (void **)v119[0];
  }
  unsigned __int8 v101 = v40;
  int v103 = *(_DWORD *)(v34 + 188);
  uint64_t v99 = asStringBool(*(unsigned char *)(v34 + 192));
  uint64_t v97 = asStringBool(*(unsigned char *)(v34 + 193));
  uint64_t v95 = asStringBool();
  uint64_t v93 = asStringBool();
  int v79 = *(unsigned __int16 *)(v34 + 202);
  int v81 = v39;
  CFNumberRef v42 = *(ctu **)(v34 + 208);
  if (v42) {
    uint64_t v43 = sub_100080778;
  }
  else {
    uint64_t v43 = 0;
  }
  CFBooleanRef v105 = v43;
  loga = v5;
  CFMutableArrayRef v91 = v10;
  int v89 = v33;
  uint64_t v85 = v37;
  CFNumberRef v87 = v35;
  uint64_t v83 = v36;
  if (v43)
  {
    ctu::cf_to_xpc((uint64_t *)&object, v42, v41);
    xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
    if (v118 >= 0) {
      CFBooleanRef v44 = __p;
    }
    else {
      CFBooleanRef v44 = (void **)__p[0];
    }
  }
  else
  {
    CFBooleanRef v44 = (void **)"";
  }
  CFTypeID v77 = v44;
  uint64_t v75 = asStringBool(*(unsigned char *)(v34 + 216));
  uint64_t v45 = v34;
  if (*(unsigned char *)(v34 + 272))
  {
    CFNumberRef v46 = (const char *)(v34 + 248);
    if (*(char *)(v34 + 271) < 0) {
      CFNumberRef v46 = *(const char **)v46;
    }
  }
  else
  {
    CFNumberRef v46 = "no alt name";
  }
  uint64_t v47 = asStringBool(*(unsigned char *)(v34 + 344));
  if (*(unsigned char *)(v34 + 304))
  {
    CFBooleanRef v48 = (const char *)(v34 + 280);
    if (*(char *)(v34 + 303) < 0) {
      CFBooleanRef v48 = *(const char **)v48;
    }
  }
  else
  {
    CFBooleanRef v48 = "no orig apn";
  }
  if (*(unsigned char *)(v34 + 336)) {
    uint64_t v49 = (*(void *)(v34 + 320) - *(void *)(v34 + 312)) >> 2;
  }
  else {
    LODWORD(v49) = 0;
  }
  uint64_t v50 = *(void *)(v45 + 224);
  uint64_t v51 = *(void *)(v45 + 232);
  uint64_t v52 = asStringBool(*(unsigned char *)(v45 + 194));
  uint64_t v53 = asStringBool(*(unsigned char *)(v45 + 196));
  uint64_t v54 = asStringBool(*(unsigned char *)(v45 + 195));
  *(_DWORD *)std::string buf = 136321794;
  *(void *)&uint8_t buf[4] = v91;
  *(_WORD *)&buf[12] = 1024;
  *(_DWORD *)&buf[14] = v89;
  *(_WORD *)&buf[18] = 2082;
  *(void *)&buf[20] = v87;
  *(_WORD *)&buf[28] = 2082;
  *(void *)&buf[30] = v83;
  *(_WORD *)&buf[38] = 2048;
  uint64_t v133 = v85;
  *(_WORD *)v134 = 2082;
  *(void *)&v134[2] = v107;
  __int16 v135 = 2048;
  uint64_t v136 = v109;
  __int16 v137 = 1024;
  int v138 = v111;
  __int16 v139 = 1024;
  int v140 = v113;
  __int16 v141 = 1024;
  int v142 = v81;
  __int16 v143 = 2082;
  *(void *)v144 = v101;
  *(_WORD *)&v144[8] = 1024;
  *(_DWORD *)&v144[10] = v103;
  __int16 v145 = 2080;
  *(void *)v146 = v99;
  *(_WORD *)&v146[8] = 2080;
  *(void *)&v146[10] = v97;
  *(_WORD *)&v146[18] = 2080;
  *(void *)&v146[20] = v95;
  *(_WORD *)&v146[28] = 2080;
  *(void *)&v146[30] = v93;
  *(_WORD *)&v146[38] = 1024;
  *(_DWORD *)&v146[40] = v79;
  __int16 v147 = 2080;
  *(void *)uint64_t v148 = v77;
  *(_WORD *)&v148[8] = 2080;
  *(void *)&v148[10] = v75;
  *(_WORD *)&v148[18] = 2080;
  *(void *)&v148[20] = v46;
  *(_WORD *)&v148[28] = 2080;
  *(void *)&v148[30] = v47;
  *(_WORD *)&v148[38] = 1024;
  *(_DWORD *)&v148[40] = -1227133513 * ((unint64_t)(v51 - v50) >> 3);
  __int16 v149 = 2080;
  *(void *)uint64_t v150 = v48;
  *(_WORD *)&v150[8] = 1024;
  *(_DWORD *)&v150[10] = v49;
  __int16 v151 = 2080;
  *(void *)v152 = v52;
  *(_WORD *)&v152[8] = 2080;
  *(void *)&v152[10] = v53;
  *(_WORD *)&v152[18] = 2080;
  *(void *)&v152[20] = v54;
  _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t APNInfo: src: %s.%d, base: %{public}s, type-mask: %{public}s (0x%llx), tech-type-mask: %{public}s (0x%llx), AllowedProtocolMask: 0x%x, AllowedProtocolMaskInRoaming: 0x%x, inactivity: %u, tech-mask: %{public}s (0x%x), allow no DNS: %s, support SwitchOver: %s, don't suspend context: %s, suspend context on BBCall: %s, Pco Container Id: %u, proxy:{%s}, use network MTU: %s, alt-name:'%s', xlat464: %s, blockers: %u, OrigApn:'%s', APNSwitchCauseCodes: %u, alwaysOnPDU: %s, support5GSaHandOver: %s, SuppressPdnTearDown: %s", buf, 0xF0u);
  uint64_t v3 = v45;
  if (v105)
  {
    if (v118 < 0) {
      operator delete(__p[0]);
    }
LABEL_81:
    xpc_release(object);
  }
LABEL_82:
  if (v120 < 0) {
    operator delete(v119[0]);
  }
  if (v122 < 0) {
    operator delete(v121[0]);
  }
  if (v124 < 0) {
    operator delete(v123[0]);
  }
  if (SHIBYTE(v128) < 0) {
    operator delete(*(void **)v125);
  }
LABEL_90:
  uint64_t v56 = *(long long **)(v3 + 224);
  CFNumberRef v55 = *(long long **)(v3 + 232);
  if (v55 != v56)
  {
    CFTypeID v57 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t APNInfo: blockers: {", buf, 2u);
      uint64_t v56 = *(long long **)(v3 + 224);
      CFNumberRef v55 = *(long long **)(v3 + 232);
    }
    for (; v56 != v55; uint64_t v56 = (long long *)((char *)v56 + 56))
    {
      *(void *)v134 = 0;
      long long v58 = *v56;
      *(void *)&uint8_t buf[16] = *((void *)v56 + 2);
      *(_OWORD *)std::string buf = v58;
      *(void *)&buf[32] = 0;
      uint64_t v133 = 0;
      *(void *)&buf[24] = 0;
      sub_100448664(&buf[24], *((const void **)v56 + 3), *((void *)v56 + 4), (uint64_t)(*((void *)v56 + 4) - *((void *)v56 + 3)) >> 2);
      v134[0] = *((unsigned char *)v56 + 48);
      long long v59 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v60 = asString();
        uint64_t v61 = asStringBool(buf[4]);
        *(_DWORD *)v125 = 136315906;
        *(void *)&v125[4] = v60;
        __int16 v126 = 2080;
        uint64_t v127 = v61;
        __int16 v128 = 1024;
        int v129 = *(_DWORD *)&buf[8];
        __int16 v130 = 2048;
        uint64_t v131 = *(void *)&buf[16];
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t xpc_type_t type = %s fAirplaneModeRecovery = %s fTries = %u fTimeout = %ld", v125, 0x26u);
      }
      long long v63 = *(int **)&buf[24];
      CFBooleanRef v62 = *(int **)&buf[32];
      if (*(void *)&buf[24] != *(void *)&buf[32])
      {
        do
        {
          CFBooleanRef v64 = *a2;
          if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
          {
            int v65 = *v63;
            *(_DWORD *)v125 = 67109120;
            *(_DWORD *)&v125[4] = v65;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t cause = %d", v125, 8u);
          }
          ++v63;
        }
        while (v63 != v62);
        long long v63 = *(int **)&buf[24];
      }
      if (v63)
      {
        *(void *)&buf[32] = v63;
        operator delete(v63);
      }
    }
    CFBooleanRef v66 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t }", buf, 2u);
    }
  }
  if (*(unsigned char *)(v3 + 336))
  {
    long long v67 = *(int **)(v3 + 312);
    long long v68 = *(int **)(v3 + 320);
    if (v68 != v67)
    {
      CFTypeID v69 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t APNInfo: APNSwitchCauseCodes: {", buf, 2u);
        if (!*(unsigned char *)(v3 + 336)) {
          sub_10016C840();
        }
        long long v67 = *(int **)(v3 + 312);
        long long v68 = *(int **)(v3 + 320);
      }
      for (; v67 != v68; ++v67)
      {
        CFBooleanRef v70 = *a2;
        if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
        {
          int v71 = *v67;
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v71;
          _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t code = %d", buf, 8u);
        }
      }
      long long v72 = *a2;
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t }", buf, 2u);
      }
    }
  }
}

void sub_100C97CE8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100C97DFC(uint64_t a1, os_log_t *a2, uint64_t a3)
{
  uint64_t v3 = a1;
  if (a2) {
    int v4 = a2;
  }
  else {
    int v4 = (os_log_t *)(a1 + 40);
  }
  int v5 = *(unsigned __int8 *)(a1 + 180);
  os_log_t v6 = *v4;
  BOOL v7 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!v7) {
      goto LABEL_93;
    }
    unsigned int v8 = *(_DWORD *)(v3 + 144) - 1;
    if (v8 > 4) {
      unsigned int v9 = "UI";
    }
    else {
      unsigned int v9 = off_101A4DF50[v8];
    }
    int v12 = *(_DWORD *)(v3 + 148);
    uint64_t v13 = v3;
    sub_100C93D68(v121, v3);
    if (v124 >= 0) {
      unsigned int v14 = v121;
    }
    else {
      unsigned int v14 = *(unsigned char **)v121;
    }
    asStringMask((uint64_t *)v119, *(void *)(v13 + 152));
    if (v120 >= 0) {
      uint64_t v15 = v119;
    }
    else {
      uint64_t v15 = (void **)v119[0];
    }
    uint64_t v16 = *(void *)(v13 + 152);
    asStringMask((uint64_t *)v117, *(void *)(v13 + 160));
    int v17 = (void **)v117[0];
    if (v118 >= 0) {
      int v17 = v117;
    }
    CFBooleanRef v105 = v17;
    if (*(unsigned char *)(v13 + 180)) {
      int v107 = *(_DWORD *)(v13 + 176);
    }
    else {
      int v107 = 0;
    }
    uint64_t v97 = *(void *)(v13 + 160);
    int v99 = *(_DWORD *)(v13 + 168);
    int v101 = *(_DWORD *)(v13 + 172);
    int v103 = *(_DWORD *)(v13 + 184);
    WirelessTechnologyList::asString((uint64_t *)v115, (WirelessTechnologyList *)(v13 + 188));
    if (v116 >= 0) {
      CFNumberRef v18 = v115;
    }
    else {
      CFNumberRef v18 = (void **)v115[0];
    }
    CFMutableArrayRef v91 = v18;
    int v93 = *(_DWORD *)(v13 + 188);
    uint64_t v89 = asStringBool(*(unsigned char *)(v13 + 192));
    uint64_t v87 = asStringBool(*(unsigned char *)(v13 + 193));
    uint64_t v85 = asStringBool();
    uint64_t v83 = asStringBool();
    int v71 = *(unsigned __int16 *)(v13 + 202);
    CFNumberRef v20 = *(ctu **)(v13 + 208);
    if (v20) {
      CFTypeID v21 = sub_100080778;
    }
    else {
      CFTypeID v21 = 0;
    }
    uint64_t v95 = v21;
    log = v6;
    int v81 = v9;
    int v79 = v12;
    uint64_t v75 = v16;
    CFTypeID v77 = v14;
    uint64_t v73 = v15;
    if (v21)
    {
      ctu::cf_to_xpc((uint64_t *)&object, v20, v19);
      xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
      if (v114 >= 0) {
        CFNumberRef v22 = __p;
      }
      else {
        CFNumberRef v22 = (void **)__p[0];
      }
    }
    else
    {
      CFNumberRef v22 = (void **)"";
    }
    uint64_t v69 = asStringBool(*(unsigned char *)(v13 + 216));
    if (*(unsigned char *)(v13 + 272))
    {
      uint64_t v23 = (const char *)(v13 + 248);
      if (*(char *)(v13 + 271) < 0) {
        uint64_t v23 = *(const char **)v23;
      }
    }
    else
    {
      uint64_t v23 = "no alt name";
    }
    uint64_t v68 = asStringBool(*(unsigned char *)(v13 + 344));
    uint64_t v3 = v13;
    if (*(unsigned char *)(v13 + 304))
    {
      uint64_t v24 = (const char *)(v13 + 280);
      if (*(char *)(v13 + 303) < 0) {
        uint64_t v24 = *(const char **)v24;
      }
    }
    else
    {
      uint64_t v24 = "no orig apn";
    }
    if (*(unsigned char *)(v13 + 336)) {
      uint64_t v25 = (*(void *)(v13 + 320) - *(void *)(v13 + 312)) >> 2;
    }
    else {
      LODWORD(v25) = 0;
    }
    uint64_t v26 = *(void *)(v3 + 224);
    uint64_t v27 = *(void *)(v3 + 232);
    uint64_t v28 = asStringBool(*(unsigned char *)(v3 + 194));
    uint64_t v29 = asStringBool(*(unsigned char *)(v3 + 196));
    uint64_t v30 = asStringBool(*(unsigned char *)(v3 + 195));
    *(void *)&buf[14] = v81;
    LODWORD(v131) = v79;
    *(void *)((char *)&v131 + 6) = v77;
    v132 = v73;
    *(void *)&v133[2] = v75;
    __int16 v135 = v105;
    *(_WORD *)uint64_t v133 = 2048;
    __int16 v136 = 2048;
    uint64_t v137 = v97;
    int v139 = v99;
    int v141 = v101;
    int v143 = v107;
    *(_DWORD *)__int16 v145 = v103;
    WORD2(v131) = 2082;
    HIWORD(v131) = 2082;
    __int16 v134 = 2082;
    *(_WORD *)&v145[4] = 2082;
    *(void *)&v145[6] = v91;
    *(_DWORD *)__int16 v147 = v93;
    *(void *)&v147[6] = v89;
    *(void *)&v147[16] = v87;
    *(void *)&v147[26] = v85;
    *(void *)&v147[36] = v83;
    *(_DWORD *)__int16 v149 = v71;
    *(void *)&v149[6] = v22;
    *(void *)&v149[16] = v69;
    *(void *)&v149[26] = v23;
    *(void *)&v149[36] = v68;
    *(_DWORD *)__int16 v151 = -1227133513 * ((unint64_t)(v27 - v26) >> 3);
    *(void *)&v151[6] = v24;
    *(_WORD *)&buf[22] = 1024;
    __int16 v138 = 1024;
    __int16 v140 = 1024;
    __int16 v142 = 1024;
    __int16 v144 = 1024;
    __int16 v146 = 1024;
    __int16 v148 = 1024;
    __int16 v150 = 1024;
    __int16 v152 = 1024;
    *(_DWORD *)v153 = v25;
    *(void *)&v153[6] = v28;
    *(void *)&v153[16] = v29;
    *(_WORD *)&buf[12] = 2080;
    *(_WORD *)&v147[4] = 2080;
    *(_WORD *)&v147[14] = 2080;
    *(_WORD *)&v147[24] = 2080;
    *(_WORD *)&v147[34] = 2080;
    *(_WORD *)&v149[4] = 2080;
    *(_WORD *)&v149[14] = 2080;
    *(_WORD *)&v149[24] = 2080;
    *(_WORD *)&v149[34] = 2080;
    *(_WORD *)&v151[4] = 2080;
    *(_WORD *)&v153[4] = 2080;
    *(_WORD *)&v153[14] = 2080;
    *(_WORD *)&v153[24] = 2080;
    *(void *)&v153[26] = v30;
    *(_DWORD *)std::string buf = 136322306;
    *(void *)&uint8_t buf[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I \t%s APNInfo: src: %s.%d, base: %{public}s, type-mask: %{public}s (0x%llx), tech-type-mask: %{public}s (0x%llx), AllowedProtocolMask: 0x%x, AllowedProtocolMaskInRoaming: 0x%x, AllowedProtocolMaskInDomesticRoaming: 0x%x, inactivity: %u, tech-mask: %{public}s (0x%x), allow no DNS: %s, support SwitchOver: %s, don't suspend context: %s, suspend context on BBCall: %s, Pco Container Id: %u, proxy:{%s}, use network MTU: %s, alt-name:'%s', xlat464: %s, blockers: %u, OrigApn:'%s', APNSwitchCauseCodes: %u, alwaysOnPDU: %s, support5GSaHandOver: %s, SuppressPdnTearDown: %s", buf, 0x100u);
    if (!v95) {
      goto LABEL_85;
    }
    if (v114 < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_84;
  }
  if (!v7) {
    goto LABEL_93;
  }
  unsigned int v10 = *(_DWORD *)(v3 + 144) - 1;
  if (v10 > 4) {
    int v11 = "UI";
  }
  else {
    int v11 = off_101A4DF50[v10];
  }
  int v31 = *(_DWORD *)(v3 + 148);
  uint64_t v32 = v3;
  sub_100C93D68(v121, v3);
  if (v124 >= 0) {
    int v33 = v121;
  }
  else {
    int v33 = *(unsigned char **)v121;
  }
  asStringMask((uint64_t *)v119, *(void *)(v32 + 152));
  if (v120 >= 0) {
    uint64_t v34 = v119;
  }
  else {
    uint64_t v34 = (void **)v119[0];
  }
  uint64_t v35 = *(void *)(v32 + 152);
  asStringMask((uint64_t *)v117, *(void *)(v32 + 160));
  if (v118 >= 0) {
    CFNumberRef v36 = v117;
  }
  else {
    CFNumberRef v36 = (void **)v117[0];
  }
  int v100 = v36;
  uint64_t v102 = *(void *)(v32 + 160);
  int v104 = *(_DWORD *)(v32 + 168);
  int v106 = *(_DWORD *)(v32 + 172);
  int v108 = *(_DWORD *)(v32 + 184);
  WirelessTechnologyList::asString((uint64_t *)v115, (WirelessTechnologyList *)(v32 + 188));
  if (v116 >= 0) {
    uint64_t v37 = v115;
  }
  else {
    uint64_t v37 = (void **)v115[0];
  }
  uint64_t v94 = v37;
  int v96 = *(_DWORD *)(v32 + 188);
  uint64_t v92 = asStringBool(*(unsigned char *)(v32 + 192));
  uint64_t v90 = asStringBool(*(unsigned char *)(v32 + 193));
  uint64_t v88 = asStringBool();
  uint64_t v86 = asStringBool();
  int v74 = *(unsigned __int16 *)(v32 + 202);
  int v39 = *(ctu **)(v32 + 208);
  if (v39) {
    long long v40 = sub_100080778;
  }
  else {
    long long v40 = 0;
  }
  int v98 = v40;
  loga = v6;
  CFTypeID v84 = v11;
  int v82 = v31;
  uint64_t v78 = v35;
  CFTypeID v80 = v33;
  int v76 = v34;
  if (v40)
  {
    ctu::cf_to_xpc((uint64_t *)&object, v39, v38);
    xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
    if (v114 >= 0) {
      CFTypeID v41 = __p;
    }
    else {
      CFTypeID v41 = (void **)__p[0];
    }
  }
  else
  {
    CFTypeID v41 = (void **)"";
  }
  uint64_t v72 = asStringBool(*(unsigned char *)(v32 + 216));
  if (*(unsigned char *)(v32 + 272))
  {
    CFNumberRef v42 = (const char *)(v32 + 248);
    if (*(char *)(v32 + 271) < 0) {
      CFNumberRef v42 = *(const char **)v42;
    }
  }
  else
  {
    CFNumberRef v42 = "no alt name";
  }
  uint64_t v70 = asStringBool(*(unsigned char *)(v32 + 344));
  uint64_t v3 = v32;
  if (*(unsigned char *)(v32 + 304))
  {
    uint64_t v43 = (const char *)(v32 + 280);
    if (*(char *)(v32 + 303) < 0) {
      uint64_t v43 = *(const char **)v43;
    }
  }
  else
  {
    uint64_t v43 = "no orig apn";
  }
  if (*(unsigned char *)(v32 + 336)) {
    uint64_t v44 = (*(void *)(v32 + 320) - *(void *)(v32 + 312)) >> 2;
  }
  else {
    LODWORD(v44) = 0;
  }
  uint64_t v45 = *(void *)(v3 + 224);
  uint64_t v46 = *(void *)(v3 + 232);
  uint64_t v47 = asStringBool(*(unsigned char *)(v3 + 194));
  uint64_t v48 = asStringBool(*(unsigned char *)(v3 + 196));
  uint64_t v49 = asStringBool(*(unsigned char *)(v3 + 195));
  *(_DWORD *)std::string buf = 136322050;
  *(void *)&uint8_t buf[4] = a3;
  *(_WORD *)&buf[12] = 2080;
  *(void *)&buf[14] = v84;
  *(_WORD *)&buf[22] = 1024;
  LODWORD(v131) = v82;
  WORD2(v131) = 2082;
  *(void *)((char *)&v131 + 6) = v80;
  HIWORD(v131) = 2082;
  v132 = v76;
  *(_WORD *)uint64_t v133 = 2048;
  *(void *)&v133[2] = v78;
  __int16 v134 = 2082;
  __int16 v135 = v100;
  __int16 v136 = 2048;
  uint64_t v137 = v102;
  __int16 v138 = 1024;
  int v139 = v104;
  __int16 v140 = 1024;
  int v141 = v106;
  __int16 v142 = 1024;
  int v143 = v108;
  __int16 v144 = 2082;
  *(void *)__int16 v145 = v94;
  *(_WORD *)&v145[8] = 1024;
  *(_DWORD *)&v145[10] = v96;
  __int16 v146 = 2080;
  *(void *)__int16 v147 = v92;
  *(_WORD *)&v147[8] = 2080;
  *(void *)&v147[10] = v90;
  *(_WORD *)&v147[18] = 2080;
  *(void *)&v147[20] = v88;
  *(_WORD *)&v147[28] = 2080;
  *(void *)&v147[30] = v86;
  *(_WORD *)&v147[38] = 1024;
  *(_DWORD *)&v147[40] = v74;
  __int16 v148 = 2080;
  *(void *)__int16 v149 = v41;
  *(_WORD *)&v149[8] = 2080;
  *(void *)&v149[10] = v72;
  *(_WORD *)&v149[18] = 2080;
  *(void *)&v149[20] = v42;
  *(_WORD *)&v149[28] = 2080;
  *(void *)&v149[30] = v70;
  *(_WORD *)&v149[38] = 1024;
  *(_DWORD *)&v149[40] = -1227133513 * ((unint64_t)(v46 - v45) >> 3);
  __int16 v150 = 2080;
  *(void *)__int16 v151 = v43;
  *(_WORD *)&v151[8] = 1024;
  *(_DWORD *)&v151[10] = v44;
  __int16 v152 = 2080;
  *(void *)v153 = v47;
  *(_WORD *)&v153[8] = 2080;
  *(void *)&v153[10] = v48;
  *(_WORD *)&v153[18] = 2080;
  *(void *)&v153[20] = v49;
  _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_DEFAULT, "#I \t%s APNInfo: src: %s.%d, base: %{public}s, type-mask: %{public}s (0x%llx), tech-type-mask: %{public}s (0x%llx), AllowedProtocolMask: 0x%x, AllowedProtocolMaskInRoaming: 0x%x, inactivity: %u, tech-mask: %{public}s (0x%x), allow no DNS: %s, support SwitchOver: %s, don't suspend context: %s, suspend context on BBCall: %s, Pco Container Id: %u, proxy:{%s}, use network MTU: %s, alt-name:'%s', xlat464: %s, blockers: %u, OrigApn:'%s', APNSwitchCauseCodes: %u, alwaysOnPDU %s, support5GSaHandOver: %s, SuppressPdnTearDown: %s", buf, 0xFAu);
  if (v98)
  {
    if (v114 < 0) {
      operator delete(__p[0]);
    }
LABEL_84:
    xpc_release(object);
  }
LABEL_85:
  if (v116 < 0) {
    operator delete(v115[0]);
  }
  if (v118 < 0) {
    operator delete(v117[0]);
  }
  if (v120 < 0) {
    operator delete(v119[0]);
  }
  if (SHIBYTE(v124) < 0) {
    operator delete(*(void **)v121);
  }
LABEL_93:
  uint64_t v51 = *(long long **)(v3 + 224);
  uint64_t v50 = *(long long **)(v3 + 232);
  if (v50 != v51)
  {
    uint64_t v52 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = a3;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I \t%s APNInfo: blockers: {", buf, 0xCu);
      uint64_t v51 = *(long long **)(v3 + 224);
      uint64_t v50 = *(long long **)(v3 + 232);
    }
    for (; v51 != v50; uint64_t v51 = (long long *)((char *)v51 + 56))
    {
      *(void *)uint64_t v133 = 0;
      long long v53 = *v51;
      *(void *)&uint8_t buf[16] = *((void *)v51 + 2);
      *(_OWORD *)std::string buf = v53;
      v132 = 0;
      long long v131 = 0uLL;
      sub_100448664(&v131, *((const void **)v51 + 3), *((void *)v51 + 4), (uint64_t)(*((void *)v51 + 4) - *((void *)v51 + 3)) >> 2);
      v133[0] = *((unsigned char *)v51 + 48);
      uint64_t v54 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v55 = asString();
        uint64_t v56 = asStringBool(buf[4]);
        *(_DWORD *)v121 = 136316162;
        *(void *)&v121[4] = a3;
        __int16 v122 = 2080;
        uint64_t v123 = v55;
        __int16 v124 = 2080;
        uint64_t v125 = v56;
        __int16 v126 = 1024;
        int v127 = *(_DWORD *)&buf[8];
        __int16 v128 = 2048;
        uint64_t v129 = *(void *)&buf[16];
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I \t%s \t xpc_type_t type = %s fAirplaneModeRecovery = %s fTries = %u fTimeout = %ld", v121, 0x30u);
      }
      CFTypeID v57 = (int *)*((void *)&v131 + 1);
      long long v58 = (int *)v131;
      if ((void)v131 != *((void *)&v131 + 1))
      {
        do
        {
          long long v59 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            int v60 = *v58;
            *(_DWORD *)v121 = 136315394;
            *(void *)&v121[4] = a3;
            __int16 v122 = 1024;
            LODWORD(v123) = v60;
            _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I \t%s \t\t cause = %d", v121, 0x12u);
          }
          ++v58;
        }
        while (v58 != v57);
        long long v58 = (int *)v131;
      }
      if (v58)
      {
        *((void *)&v131 + 1) = v58;
        operator delete(v58);
      }
    }
    uint64_t v61 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = a3;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I \t%s }", buf, 0xCu);
    }
  }
  if (*(unsigned char *)(v3 + 336))
  {
    CFBooleanRef v62 = *(int **)(v3 + 312);
    long long v63 = *(int **)(v3 + 320);
    if (v63 != v62)
    {
      CFBooleanRef v64 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I \t APNInfo: APNSwitchCauseCodes: {", buf, 2u);
        if (!*(unsigned char *)(v3 + 336)) {
          sub_10016C840();
        }
        CFBooleanRef v62 = *(int **)(v3 + 312);
        long long v63 = *(int **)(v3 + 320);
      }
      for (; v62 != v63; ++v62)
      {
        int v65 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          int v66 = *v62;
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v66;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#I \t\t code = %d", buf, 8u);
        }
      }
      long long v67 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I \t }", buf, 2u);
      }
    }
  }
}

void sub_100C989F8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100C98B0C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v13 = 0u;
  memset(v11, 0, sizeof(v11));
  long long v10 = 0u;
  sub_10004BD84((uint64_t)&v10);
  unsigned int v4 = *(_DWORD *)(a1 + 144) - 1;
  if (v4 > 4) {
    int v5 = "UI";
  }
  else {
    int v5 = off_101A4DF50[v4];
  }
  size_t v6 = strlen(v5);
  BOOL v7 = sub_10004B96C(v11, (uint64_t)v5, v6);
  sub_10004B96C(v7, (uint64_t)".", 1);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v11 + 8, a2);
  *(void *)((char *)&v11[-1]
  *(void *)&v11[0] = v8;
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100C98CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_100C98D10(uint64_t a1, uint64_t a2, char a3, int a4, int a5)
{
  uint64_t v10 = *(unsigned __int8 *)(a1 + 71);
  if ((v10 & 0x80u) == 0) {
    uint64_t v11 = *(unsigned __int8 *)(a1 + 71);
  }
  else {
    uint64_t v11 = *(void *)(a1 + 56);
  }
  uint64_t v12 = *(unsigned __int8 *)(a2 + 71);
  int v13 = (char)v12;
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *(void *)(a2 + 56);
  }
  if (v11 != v12) {
    goto LABEL_61;
  }
  long long v14 = (const void **)(a1 + 48);
  if (v13 >= 0) {
    long long v15 = (unsigned __int8 *)(a2 + 48);
  }
  else {
    long long v15 = *(unsigned __int8 **)(a2 + 48);
  }
  if ((v10 & 0x80) != 0)
  {
    if (memcmp(*v14, v15, *(void *)(a1 + 56))) {
      goto LABEL_61;
    }
  }
  else if (*(unsigned char *)(a1 + 71))
  {
    while (*(unsigned __int8 *)v14 == *v15)
    {
      long long v14 = (const void **)((char *)v14 + 1);
      ++v15;
      if (!--v10) {
        goto LABEL_16;
      }
    }
LABEL_61:
    BOOL v34 = 0;
    if (a3) {
      goto LABEL_62;
    }
LABEL_65:
    if (!v34) {
      goto LABEL_68;
    }
    goto LABEL_66;
  }
LABEL_16:
  uint64_t v16 = *(unsigned __int8 *)(a1 + 95);
  if ((v16 & 0x80u) == 0) {
    uint64_t v17 = *(unsigned __int8 *)(a1 + 95);
  }
  else {
    uint64_t v17 = *(void *)(a1 + 80);
  }
  uint64_t v18 = *(unsigned __int8 *)(a2 + 95);
  int v19 = (char)v18;
  if ((v18 & 0x80u) != 0) {
    uint64_t v18 = *(void *)(a2 + 80);
  }
  if (v17 != v18) {
    goto LABEL_61;
  }
  long long v20 = (const void **)(a1 + 72);
  if (v19 >= 0) {
    long long v21 = (unsigned __int8 *)(a2 + 72);
  }
  else {
    long long v21 = *(unsigned __int8 **)(a2 + 72);
  }
  if ((v16 & 0x80) != 0)
  {
    if (memcmp(*v20, v21, *(void *)(a1 + 80))) {
      goto LABEL_61;
    }
  }
  else if (*(unsigned char *)(a1 + 95))
  {
    while (*(unsigned __int8 *)v20 == *v21)
    {
      long long v20 = (const void **)((char *)v20 + 1);
      ++v21;
      if (!--v16) {
        goto LABEL_31;
      }
    }
    goto LABEL_61;
  }
LABEL_31:
  uint64_t v22 = *(unsigned __int8 *)(a1 + 119);
  if ((v22 & 0x80u) == 0) {
    uint64_t v23 = *(unsigned __int8 *)(a1 + 119);
  }
  else {
    uint64_t v23 = *(void *)(a1 + 104);
  }
  uint64_t v24 = *(unsigned __int8 *)(a2 + 119);
  int v25 = (char)v24;
  if ((v24 & 0x80u) != 0) {
    uint64_t v24 = *(void *)(a2 + 104);
  }
  if (v23 != v24) {
    goto LABEL_61;
  }
  uint64_t v26 = (const void **)(a1 + 96);
  if (v25 >= 0) {
    uint64_t v27 = (unsigned __int8 *)(a2 + 96);
  }
  else {
    uint64_t v27 = *(unsigned __int8 **)(a2 + 96);
  }
  if ((v22 & 0x80) != 0)
  {
    if (memcmp(*v26, v27, *(void *)(a1 + 104))) {
      goto LABEL_61;
    }
  }
  else if (*(unsigned char *)(a1 + 119))
  {
    while (*(unsigned __int8 *)v26 == *v27)
    {
      uint64_t v26 = (const void **)((char *)v26 + 1);
      ++v27;
      if (!--v22) {
        goto LABEL_46;
      }
    }
    goto LABEL_61;
  }
LABEL_46:
  uint64_t v28 = *(unsigned __int8 *)(a1 + 143);
  if ((v28 & 0x80u) == 0) {
    uint64_t v29 = *(unsigned __int8 *)(a1 + 143);
  }
  else {
    uint64_t v29 = *(void *)(a1 + 128);
  }
  uint64_t v30 = *(unsigned __int8 *)(a2 + 143);
  int v31 = (char)v30;
  if ((v30 & 0x80u) != 0) {
    uint64_t v30 = *(void *)(a2 + 128);
  }
  if (v29 != v30) {
    goto LABEL_61;
  }
  uint64_t v32 = (const void **)(a1 + 120);
  if (v31 >= 0) {
    int v33 = (unsigned __int8 *)(a2 + 120);
  }
  else {
    int v33 = *(unsigned __int8 **)(a2 + 120);
  }
  if ((v28 & 0x80) != 0)
  {
    BOOL v34 = memcmp(*v32, v33, *(void *)(a1 + 128)) == 0;
    if (a3)
    {
LABEL_62:
      if (!v34) {
        goto LABEL_68;
      }
      goto LABEL_63;
    }
    goto LABEL_65;
  }
  if (*(unsigned char *)(a1 + 143))
  {
    while (*(unsigned __int8 *)v32 == *v33)
    {
      uint64_t v32 = (const void **)((char *)v32 + 1);
      ++v33;
      if (!--v28) {
        goto LABEL_59;
      }
    }
    goto LABEL_61;
  }
LABEL_59:
  if ((a3 & 1) == 0)
  {
LABEL_66:
    uint64_t v35 = *(void *)(a1 + 152);
    uint64_t v36 = *(void *)(a2 + 152);
    goto LABEL_67;
  }
LABEL_63:
  uint64_t v35 = *(void *)(a1 + 160);
  uint64_t v36 = *(void *)(a2 + 160);
LABEL_67:
  BOOL v34 = v35 == v36;
LABEL_68:
  if (a4)
  {
    int v37 = *(_DWORD *)(a1 + 168);
    int v38 = *(_DWORD *)(a2 + 168);
    if (a5)
    {
      if (*(unsigned char *)(a1 + 180)) {
        int v37 = *(_DWORD *)(a1 + 176);
      }
      if (*(unsigned char *)(a2 + 180)) {
        int v38 = *(_DWORD *)(a2 + 176);
      }
    }
    return v37 == v38 && v34;
  }
  else
  {
    return v34 && *(_DWORD *)(a1 + 172) == *(_DWORD *)(a2 + 172);
  }
}

uint64_t sub_100C98FCC(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 144) != *(_DWORD *)(a2 + 144)) {
    return 0;
  }
  uint64_t v4 = *(unsigned __int8 *)(a1 + 71);
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 71);
  }
  else {
    uint64_t v5 = *(void *)(a1 + 56);
  }
  uint64_t v6 = *(unsigned __int8 *)(a2 + 71);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a2 + 56);
  }
  if (v5 != v6) {
    return 0;
  }
  xpc_object_t v8 = (const void **)(a1 + 48);
  if (v7 >= 0) {
    unsigned int v9 = (unsigned __int8 *)(a2 + 48);
  }
  else {
    unsigned int v9 = *(unsigned __int8 **)(a2 + 48);
  }
  if ((v4 & 0x80) != 0)
  {
    if (memcmp(*v8, v9, *(void *)(a1 + 56))) {
      return 0;
    }
  }
  else if (*(unsigned char *)(a1 + 71))
  {
    while (*(unsigned __int8 *)v8 == *v9)
    {
      xpc_object_t v8 = (const void **)((char *)v8 + 1);
      ++v9;
      if (!--v4) {
        goto LABEL_17;
      }
    }
    return 0;
  }
LABEL_17:
  uint64_t v10 = *(unsigned __int8 *)(a1 + 95);
  if ((v10 & 0x80u) == 0) {
    uint64_t v11 = *(unsigned __int8 *)(a1 + 95);
  }
  else {
    uint64_t v11 = *(void *)(a1 + 80);
  }
  uint64_t v12 = *(unsigned __int8 *)(a2 + 95);
  int v13 = (char)v12;
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *(void *)(a2 + 80);
  }
  if (v11 != v12) {
    return 0;
  }
  long long v14 = (const void **)(a1 + 72);
  if (v13 >= 0) {
    long long v15 = (unsigned __int8 *)(a2 + 72);
  }
  else {
    long long v15 = *(unsigned __int8 **)(a2 + 72);
  }
  if ((v10 & 0x80) != 0)
  {
    if (memcmp(*v14, v15, *(void *)(a1 + 80))) {
      return 0;
    }
  }
  else if (*(unsigned char *)(a1 + 95))
  {
    while (*(unsigned __int8 *)v14 == *v15)
    {
      long long v14 = (const void **)((char *)v14 + 1);
      ++v15;
      if (!--v10) {
        goto LABEL_32;
      }
    }
    return 0;
  }
LABEL_32:
  uint64_t v16 = *(unsigned __int8 *)(a1 + 119);
  if ((v16 & 0x80u) == 0) {
    uint64_t v17 = *(unsigned __int8 *)(a1 + 119);
  }
  else {
    uint64_t v17 = *(void *)(a1 + 104);
  }
  uint64_t v18 = *(unsigned __int8 *)(a2 + 119);
  int v19 = (char)v18;
  if ((v18 & 0x80u) != 0) {
    uint64_t v18 = *(void *)(a2 + 104);
  }
  if (v17 != v18) {
    return 0;
  }
  long long v20 = (const void **)(a1 + 96);
  if (v19 >= 0) {
    long long v21 = (unsigned __int8 *)(a2 + 96);
  }
  else {
    long long v21 = *(unsigned __int8 **)(a2 + 96);
  }
  if ((v16 & 0x80) != 0)
  {
    if (memcmp(*v20, v21, *(void *)(a1 + 104))) {
      return 0;
    }
  }
  else if (*(unsigned char *)(a1 + 119))
  {
    while (*(unsigned __int8 *)v20 == *v21)
    {
      long long v20 = (const void **)((char *)v20 + 1);
      ++v21;
      if (!--v16) {
        goto LABEL_47;
      }
    }
    return 0;
  }
LABEL_47:
  uint64_t v22 = *(unsigned __int8 *)(a1 + 143);
  if ((v22 & 0x80u) == 0) {
    uint64_t v23 = *(unsigned __int8 *)(a1 + 143);
  }
  else {
    uint64_t v23 = *(void *)(a1 + 128);
  }
  uint64_t v24 = *(unsigned __int8 *)(a2 + 143);
  int v25 = (char)v24;
  if ((v24 & 0x80u) != 0) {
    uint64_t v24 = *(void *)(a2 + 128);
  }
  if (v23 != v24) {
    return 0;
  }
  uint64_t v26 = (const void **)(a1 + 120);
  if (v25 >= 0) {
    uint64_t v27 = (unsigned __int8 *)(a2 + 120);
  }
  else {
    uint64_t v27 = *(unsigned __int8 **)(a2 + 120);
  }
  if ((v22 & 0x80) != 0)
  {
    if (memcmp(*v26, v27, *(void *)(a1 + 128))) {
      return 0;
    }
  }
  else if (*(unsigned char *)(a1 + 143))
  {
    while (*(unsigned __int8 *)v26 == *v27)
    {
      uint64_t v26 = (const void **)((char *)v26 + 1);
      ++v27;
      if (!--v22) {
        goto LABEL_62;
      }
    }
    return 0;
  }
LABEL_62:
  if (*(_DWORD *)(a1 + 148) != *(_DWORD *)(a2 + 148)
    || *(void *)(a1 + 152) != *(void *)(a2 + 152)
    || *(void *)(a1 + 160) != *(void *)(a2 + 160)
    || *(_DWORD *)(a1 + 168) != *(_DWORD *)(a2 + 168)
    || *(_DWORD *)(a1 + 172) != *(_DWORD *)(a2 + 172))
  {
    return 0;
  }
  if (*(unsigned char *)(a1 + 180) && *(unsigned char *)(a2 + 180))
  {
    if (*(_DWORD *)(a1 + 176) != *(_DWORD *)(a2 + 176)) {
      return 0;
    }
  }
  else if ((*(unsigned char *)(a1 + 180) != 0) != (*(unsigned char *)(a2 + 180) != 0))
  {
    return 0;
  }
  if (*(unsigned __int8 *)(a1 + 193) != *(unsigned __int8 *)(a2 + 193)
    || *(unsigned __int8 *)(a1 + 196) != *(unsigned __int8 *)(a2 + 196))
  {
    return 0;
  }
  if (*(unsigned char *)(a1 + 198) && *(unsigned char *)(a2 + 198))
  {
    if (*(unsigned __int8 *)(a1 + 197) != *(unsigned __int8 *)(a2 + 197)) {
      return 0;
    }
  }
  else if ((*(unsigned char *)(a1 + 198) != 0) != (*(unsigned char *)(a2 + 198) != 0))
  {
    return 0;
  }
  if (*(unsigned char *)(a1 + 200) && *(unsigned char *)(a2 + 200))
  {
    if (*(unsigned __int8 *)(a1 + 199) != *(unsigned __int8 *)(a2 + 199)) {
      return 0;
    }
  }
  else if ((*(unsigned char *)(a1 + 200) != 0) != (*(unsigned char *)(a2 + 200) != 0))
  {
    return 0;
  }
  if (*(unsigned __int16 *)(a1 + 202) != *(unsigned __int16 *)(a2 + 202)
    || *(unsigned __int8 *)(a1 + 192) != *(unsigned __int8 *)(a2 + 192))
  {
    return 0;
  }
  uint64_t v28 = *(const void **)(a1 + 208);
  uint64_t v29 = v28 ? sub_100080778 : 0;
  uint64_t v30 = *(const void **)(a2 + 208);
  int v31 = v30 ? sub_100080778 : 0;
  if ((v29 == 0) == (v31 != 0)) {
    return 0;
  }
  if (!v29 || (uint64_t result = CFEqual(v28, v30), result))
  {
    if (*(unsigned __int8 *)(a1 + 216) == *(unsigned __int8 *)(a2 + 216))
    {
      if (*(unsigned char *)(a1 + 272))
      {
        if (!*(unsigned char *)(a2 + 272)) {
          return 0;
        }
        uint64_t result = sub_10001D294((unsigned __int8 *)(a1 + 248), (unsigned __int8 *)(a2 + 248));
        if (!result) {
          return result;
        }
      }
      else if (*(unsigned char *)(a2 + 272))
      {
        return 0;
      }
      uint64_t result = sub_100C99438(*(void *)(a1 + 224), *(void *)(a1 + 232), *(void *)(a2 + 224), *(void *)(a2 + 232));
      if (!result) {
        return result;
      }
      if (*(unsigned char *)(a1 + 304))
      {
        if (*(unsigned char *)(a2 + 304))
        {
          uint64_t result = sub_10001D294((unsigned __int8 *)(a1 + 280), (unsigned __int8 *)(a2 + 280));
          if (!result) {
            return result;
          }
          goto LABEL_109;
        }
      }
      else if (!*(unsigned char *)(a2 + 304))
      {
LABEL_109:
        uint64_t result = (*(unsigned __int8 *)(a2 + 336) | *(unsigned __int8 *)(a1 + 336)) == 0;
        if (*(unsigned char *)(a1 + 336) && *(unsigned char *)(a2 + 336))
        {
          int v33 = *(const void **)(a1 + 312);
          BOOL v34 = *(const void **)(a2 + 312);
          size_t v35 = *(void *)(a1 + 320) - (void)v33;
          if (v35 == *(void *)(a2 + 320) - (void)v34) {
            return memcmp(v33, v34, v35) == 0;
          }
          return 0;
        }
        return result;
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_100C99438(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 - a1 != a4 - a3) {
    return 0;
  }
  uint64_t v5 = a1;
  if (a1 == a2) {
    return 1;
  }
  for (uint64_t i = a3; *(_DWORD *)v5 == *(_DWORD *)i; i += 56)
  {
    if (*(unsigned __int8 *)(v5 + 4) != *(unsigned __int8 *)(i + 4)) {
      break;
    }
    if (*(_DWORD *)(v5 + 8) != *(_DWORD *)(i + 8)) {
      break;
    }
    if (*(void *)(v5 + 16) != *(void *)(i + 16)) {
      break;
    }
    int v7 = *(const void **)(v5 + 24);
    size_t v8 = *(void *)(v5 + 32) - (void)v7;
    unsigned int v9 = *(const void **)(i + 24);
    if (v8 != *(void *)(i + 32) - (void)v9
      || memcmp(v7, v9, v8)
      || *(unsigned __int8 *)(v5 + 48) != *(unsigned __int8 *)(i + 48))
    {
      break;
    }
    v5 += 56;
    if (v5 == a2) {
      return 1;
    }
  }
  return 0;
}

void sub_100C99544(void *a1@<X0>, int a2@<W1>, dispatch_object_t *a3@<X2>, void *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  int v7 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  size_t v8 = (char *)operator new(0xC0uLL);
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *(void *)size_t v8 = off_101A4DC60;
  unsigned int v9 = v8 + 24;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_retain(v7);
  }
  *((void *)v8 + 3) = off_101A4D980;
  *((_DWORD *)v8 + 8) = a2;
  *((void *)v8 + 5) = v7;
  if (v7)
  {
    dispatch_retain(v7);
    *((void *)v8 + 3) = off_101A4DAB8;
    dispatch_release(v7);
    a2 = *((_DWORD *)v8 + 8);
  }
  else
  {
    void *v9 = off_101A4DAB8;
  }
  *((void *)v8 + 3) = off_101A4DCB0;
  uint64_t v10 = "ui-apn.?";
  if (a2 == 2) {
    uint64_t v10 = "ui-apn.2";
  }
  if (a2 == 1) {
    uint64_t v11 = "ui-apn.1";
  }
  else {
    uint64_t v11 = v10;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v20, kCtLoggingSystemName, v11);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v22, (const OsLogContext *)&v20);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v8 + 48), (const ctu::OsLogLogger *)v22);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v22);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  *((void *)v8 + 3) = off_101A4DCB0;
  *((void *)v8 + 7) = 850045863;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_OWORD *)v8 + 6) = 0u;
  *((_OWORD *)v8 + 7) = 0u;
  *((_OWORD *)v8 + 8) = 0u;
  *((_OWORD *)v8 + 9) = 0u;
  *((_OWORD *)v8 + 10) = 0u;
  uint64_t v12 = a1[1];
  *((void *)v8 + 22) = *a1;
  *((void *)v8 + 23) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  if (v7) {
    dispatch_release(v7);
  }
  CFDictionaryRef v19 = 0;
  CFTypeRef v20 = CFPreferencesCopyValue(@"apns.per.iccid", @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  sub_100084068(&v19, &v20);
  CFDictionaryRef v13 = v19;
  if (v19) {
    long long v14 = sub_100080778;
  }
  else {
    long long v14 = 0;
  }
  if (v14)
  {
    sub_100C9DBA0((const void **)&key, *((_DWORD *)v8 + 8), @"last.iccid");
    CFDictionaryGetValue(v13, key);
    CFTypeRef v20 = 0;
    OsLogContext v21 = (OsLogContext)0;
    ctu::cf::assign();
    CFTypeRef v15 = v20;
    *(void *)uint64_t v22 = v21.var0;
    *(void *)&v22[7] = *(char **)((char *)&v21.var0 + 7);
    char fRef_high = HIBYTE(v21.var1.fRef);
    if (v8[175] < 0) {
      operator delete(*((void **)v8 + 19));
    }
    uint64_t v17 = *(void *)v22;
    *((void *)v8 + 19) = v15;
    *((void *)v8 + 20) = v17;
    *(void *)(v8 + 167) = *(void *)&v22[7];
    v8[175] = fRef_high;
    sub_1000558F4((const void **)&key);
  }
  sub_100057D78((const void **)&v19);
  *a4 = v9;
  a4[1] = v8;
  if (v7) {
    dispatch_release(v7);
  }
}

void sub_100C99844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)&a9);
  sub_100057D78(&a10);
  sub_10004D2C8(v18);
  if (v17) {
    dispatch_release(v17);
  }
  _Unwind_Resume(a1);
}

void sub_100C998F4(void *a1@<X0>, int a2@<W1>, dispatch_object_t *a3@<X2>, void *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  int v7 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  size_t v8 = operator new(0x100uLL);
  v8[1] = 0;
  v8[2] = 0;
  void *v8 = off_101A4DE58;
  unsigned int v9 = v8 + 3;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_retain(v7);
  }
  v8[3] = off_101A4D980;
  *((_DWORD *)v8 + 8) = a2;
  v8[5] = v7;
  if (v7)
  {
    dispatch_retain(v7);
    v8[3] = off_101A4D9D0;
    dispatch_release(v7);
    a2 = *((_DWORD *)v8 + 8);
  }
  else
  {
    void *v9 = off_101A4D9D0;
  }
  v8[3] = off_101A4DEA8;
  uint64_t v10 = "cb-apn.?";
  if (a2 == 2) {
    uint64_t v10 = "cb-apn.2";
  }
  if (a2 == 1) {
    uint64_t v11 = "cb-apn.1";
  }
  else {
    uint64_t v11 = v10;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, v11);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &v13);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v8 + 6), (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  v8[3] = off_101A4DEA8;
  v8[7] = 850045863;
  *((unsigned char *)v8 + 168) = 0;
  *((unsigned char *)v8 + 176) = 0;
  *((unsigned char *)v8 + 200) = 0;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_OWORD *)v8 + 6) = 0u;
  *((_OWORD *)v8 + 7) = 0u;
  *((_OWORD *)v8 + 8) = 0u;
  *((unsigned char *)v8 + 144) = 0;
  uint64_t v12 = a1[1];
  v8[26] = *a1;
  v8[27] = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  *((unsigned char *)v8 + 224) = 0;
  *((unsigned char *)v8 + 248) = 0;
  if (v7)
  {
    dispatch_release(v7);
    dispatch_release(v7);
  }
  *a4 = v9;
  a4[1] = v8;
}

void sub_100C99AFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  v3[1].__vftable = v4;
  shared_weak_owners = v3[1].__shared_weak_owners_;
  if (shared_weak_owners) {
    dispatch_release(shared_weak_owners);
  }
  if (v2) {
    dispatch_release(v2);
  }
  std::__shared_weak_count::~__shared_weak_count(v3);
  operator delete(v7);
  if (v2) {
    dispatch_release(v2);
  }
  _Unwind_Resume(a1);
}

void sub_100C99B64(char a1@<W0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v6 = 0;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (a1)
  {
    int v7 = operator new(4uLL);
    *int v7 = 1;
    a3[1] = v7 + 1;
    a3[2] = v7 + 1;
    uint64_t v8 = (char **)(a3 + 2);
    *a3 = v7;
    unsigned int v9 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), 2uLL);
    uint64_t v10 = (char *)*a3;
    uint64_t v11 = (char *)a3[1];
    *((_DWORD *)v9 + 1) = 2;
    uint64_t v12 = v9 + 4;
    long long v14 = &v9[4 * v13];
    CFTypeRef v15 = v9 + 8;
    while (v11 != v10)
    {
      int v16 = *((_DWORD *)v11 - 1);
      v11 -= 4;
      *((_DWORD *)v12 - 1) = v16;
      v12 -= 4;
    }
    *a3 = v12;
    a3[1] = v15;
    a3[2] = v14;
    if (v10)
    {
      operator delete(v10);
      long long v14 = *v8;
    }
    a3[1] = v15;
    if (v15 >= v14)
    {
      uint64_t v18 = (char *)*a3;
      uint64_t v19 = (uint64_t)&v15[-*a3] >> 2;
      unint64_t v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v21 = v14 - v18;
      if (v21 >> 1 > v20) {
        unint64_t v20 = v21 >> 1;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        uint64_t v23 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v22);
        uint64_t v18 = (char *)*a3;
        CFTypeRef v15 = (char *)a3[1];
      }
      else
      {
        uint64_t v23 = 0;
      }
      uint64_t v24 = &v23[4 * v19];
      long long v14 = &v23[4 * v22];
      *(_DWORD *)uint64_t v24 = 4;
      uint64_t v17 = v24 + 4;
      while (v15 != v18)
      {
        int v25 = *((_DWORD *)v15 - 1);
        v15 -= 4;
        *((_DWORD *)v24 - 1) = v25;
        v24 -= 4;
      }
      *a3 = v24;
      a3[1] = v17;
      a3[2] = v14;
      if (v18)
      {
        operator delete(v18);
        long long v14 = *v8;
      }
    }
    else
    {
      *((_DWORD *)v9 + 2) = 4;
      uint64_t v17 = v9 + 12;
    }
    a3[1] = v17;
    if (v17 >= v14)
    {
      uint64_t v26 = (char *)*a3;
      uint64_t v27 = (uint64_t)&v17[-*a3] >> 2;
      unint64_t v28 = v27 + 1;
      if ((unint64_t)(v27 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v29 = v14 - v26;
      if (v29 >> 1 > v28) {
        unint64_t v28 = v29 >> 1;
      }
      if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v30 = v28;
      }
      if (v30)
      {
        int v31 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v30);
        uint64_t v26 = (char *)*a3;
        uint64_t v17 = (char *)a3[1];
      }
      else
      {
        int v31 = 0;
      }
      uint64_t v32 = &v31[4 * v27];
      int v33 = &v31[4 * v30];
      *(_DWORD *)uint64_t v32 = 5;
      uint64_t v6 = v32 + 4;
      while (v17 != v26)
      {
        int v34 = *((_DWORD *)v17 - 1);
        v17 -= 4;
        *((_DWORD *)v32 - 1) = v34;
        v32 -= 4;
      }
      *a3 = v32;
      a3[1] = v6;
      a3[2] = v33;
      if (v26) {
        operator delete(v26);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v17 = 5;
      uint64_t v6 = v17 + 4;
    }
    a3[1] = v6;
  }
  if ((a1 & 2) != 0)
  {
    uint64_t v36 = (char **)(a3 + 2);
    size_t v35 = (char *)a3[2];
    if (v6 >= v35)
    {
      int v38 = (char *)*a3;
      uint64_t v39 = (uint64_t)&v6[-*a3] >> 2;
      unint64_t v40 = v39 + 1;
      if ((unint64_t)(v39 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v41 = v35 - v38;
      if (v41 >> 1 > v40) {
        unint64_t v40 = v41 >> 1;
      }
      if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v42 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v42 = v40;
      }
      if (v42)
      {
        uint64_t v43 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v42);
        int v38 = (char *)*a3;
        uint64_t v6 = (char *)a3[1];
      }
      else
      {
        uint64_t v43 = 0;
      }
      uint64_t v44 = &v43[4 * v39];
      size_t v35 = &v43[4 * v42];
      *(_DWORD *)uint64_t v44 = 10;
      int v37 = v44 + 4;
      while (v6 != v38)
      {
        int v45 = *((_DWORD *)v6 - 1);
        v6 -= 4;
        *((_DWORD *)v44 - 1) = v45;
        v44 -= 4;
      }
      *a3 = v44;
      a3[1] = v37;
      a3[2] = v35;
      if (v38)
      {
        operator delete(v38);
        size_t v35 = *v36;
      }
    }
    else
    {
      *(_DWORD *)uint64_t v6 = 10;
      int v37 = v6 + 4;
    }
    a3[1] = v37;
    if (v37 >= v35)
    {
      uint64_t v47 = (char *)*a3;
      uint64_t v48 = (uint64_t)&v37[-*a3] >> 2;
      unint64_t v49 = v48 + 1;
      if ((unint64_t)(v48 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v50 = v35 - v47;
      if (v50 >> 1 > v49) {
        unint64_t v49 = v50 >> 1;
      }
      if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v51 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v51 = v49;
      }
      if (v51)
      {
        uint64_t v52 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v51);
        uint64_t v47 = (char *)*a3;
        int v37 = (char *)a3[1];
      }
      else
      {
        uint64_t v52 = 0;
      }
      long long v53 = &v52[4 * v48];
      size_t v35 = &v52[4 * v51];
      *(_DWORD *)long long v53 = 11;
      uint64_t v46 = v53 + 4;
      while (v37 != v47)
      {
        int v54 = *((_DWORD *)v37 - 1);
        v37 -= 4;
        *((_DWORD *)v53 - 1) = v54;
        v53 -= 4;
      }
      *a3 = v53;
      a3[1] = v46;
      a3[2] = v35;
      if (v47)
      {
        operator delete(v47);
        size_t v35 = *v36;
      }
    }
    else
    {
      *(_DWORD *)int v37 = 11;
      uint64_t v46 = v37 + 4;
    }
    a3[1] = v46;
    if (v46 >= v35)
    {
      uint64_t v56 = (char *)*a3;
      uint64_t v57 = (uint64_t)&v46[-*a3] >> 2;
      unint64_t v58 = v57 + 1;
      if ((unint64_t)(v57 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v59 = v35 - v56;
      if (v59 >> 1 > v58) {
        unint64_t v58 = v59 >> 1;
      }
      if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v60 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v60 = v58;
      }
      if (v60)
      {
        uint64_t v61 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v60);
        uint64_t v56 = (char *)*a3;
        uint64_t v46 = (char *)a3[1];
      }
      else
      {
        uint64_t v61 = 0;
      }
      CFBooleanRef v62 = &v61[4 * v57];
      size_t v35 = &v61[4 * v60];
      *(_DWORD *)CFBooleanRef v62 = 12;
      uint64_t v55 = v62 + 4;
      while (v46 != v56)
      {
        int v63 = *((_DWORD *)v46 - 1);
        v46 -= 4;
        *((_DWORD *)v62 - 1) = v63;
        v62 -= 4;
      }
      *a3 = v62;
      a3[1] = v55;
      a3[2] = v35;
      if (v56)
      {
        operator delete(v56);
        size_t v35 = *v36;
      }
    }
    else
    {
      *(_DWORD *)uint64_t v46 = 12;
      uint64_t v55 = v46 + 4;
    }
    a3[1] = v55;
    if (v55 >= v35)
    {
      CFBooleanRef v64 = (char *)*a3;
      uint64_t v65 = (uint64_t)&v55[-*a3] >> 2;
      unint64_t v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v67 = v35 - v64;
      if (v67 >> 1 > v66) {
        unint64_t v66 = v67 >> 1;
      }
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v68 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v68 = v66;
      }
      if (v68)
      {
        uint64_t v69 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v68);
        CFBooleanRef v64 = (char *)*a3;
        uint64_t v55 = (char *)a3[1];
      }
      else
      {
        uint64_t v69 = 0;
      }
      uint64_t v70 = &v69[4 * v65];
      int v71 = &v69[4 * v68];
      *(_DWORD *)uint64_t v70 = 15;
      uint64_t v6 = v70 + 4;
      while (v55 != v64)
      {
        int v72 = *((_DWORD *)v55 - 1);
        v55 -= 4;
        *((_DWORD *)v70 - 1) = v72;
        v70 -= 4;
      }
      *a3 = v70;
      a3[1] = v6;
      a3[2] = v71;
      if (v64) {
        operator delete(v64);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v55 = 15;
      uint64_t v6 = v55 + 4;
    }
    a3[1] = v6;
  }
  if ((a1 & 4) != 0)
  {
    unint64_t v73 = a3[2];
    if ((unint64_t)v6 >= v73)
    {
      uint64_t v75 = (char *)*a3;
      uint64_t v76 = (uint64_t)&v6[-*a3] >> 2;
      unint64_t v77 = v76 + 1;
      if ((unint64_t)(v76 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v78 = v73 - (void)v75;
      if (v78 >> 1 > v77) {
        unint64_t v77 = v78 >> 1;
      }
      if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v79 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v79 = v77;
      }
      if (v79)
      {
        CFTypeID v80 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v79);
        uint64_t v75 = (char *)*a3;
        uint64_t v6 = (char *)a3[1];
      }
      else
      {
        CFTypeID v80 = 0;
      }
      int v81 = &v80[4 * v76];
      int v82 = &v80[4 * v79];
      *(_DWORD *)int v81 = 13;
      int v74 = v81 + 4;
      while (v6 != v75)
      {
        int v83 = *((_DWORD *)v6 - 1);
        v6 -= 4;
        *((_DWORD *)v81 - 1) = v83;
        v81 -= 4;
      }
      *a3 = v81;
      a3[1] = v74;
      a3[2] = v82;
      if (v75) {
        operator delete(v75);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v6 = 13;
      int v74 = v6 + 4;
    }
    a3[1] = v74;
    uint64_t v6 = v74;
  }
  if ((a1 & 8) == 0)
  {
LABEL_145:
    if ((a1 & 0x10) == 0) {
      return;
    }
    goto LABEL_146;
  }
  uint64_t v85 = (char **)(a3 + 2);
  unint64_t v84 = a3[2];
  if ((unint64_t)v6 >= v84)
  {
    uint64_t v87 = (char *)*a3;
    uint64_t v88 = (uint64_t)&v6[-*a3] >> 2;
    unint64_t v89 = v88 + 1;
    if ((unint64_t)(v88 + 1) >> 62) {
      sub_10006A748();
    }
    uint64_t v90 = v84 - (void)v87;
    if (v90 >> 1 > v89) {
      unint64_t v89 = v90 >> 1;
    }
    if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v91 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v91 = v89;
    }
    if (v91)
    {
      uint64_t v92 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v91);
      uint64_t v87 = (char *)*a3;
      uint64_t v6 = (char *)a3[1];
    }
    else
    {
      uint64_t v92 = 0;
    }
    int v93 = &v92[4 * v88];
    uint64_t v94 = &v92[4 * v91];
    *(_DWORD *)int v93 = 14;
    uint64_t v86 = v93 + 4;
    while (v6 != v87)
    {
      int v95 = *((_DWORD *)v6 - 1);
      v6 -= 4;
      *((_DWORD *)v93 - 1) = v95;
      v93 -= 4;
    }
    *a3 = v93;
    a3[1] = v86;
    a3[2] = v94;
    if (v87) {
      operator delete(v87);
    }
  }
  else
  {
    *(_DWORD *)uint64_t v6 = 14;
    uint64_t v86 = v6 + 4;
  }
  a3[1] = v86;
  if (!a2)
  {
    uint64_t v6 = v86;
    goto LABEL_145;
  }
  int v96 = *v85;
  if (v86 >= *v85)
  {
    int v106 = (char *)*a3;
    uint64_t v107 = (uint64_t)&v86[-*a3] >> 2;
    unint64_t v108 = v107 + 1;
    if ((unint64_t)(v107 + 1) >> 62) {
      sub_10006A748();
    }
    uint64_t v109 = v96 - v106;
    if (v109 >> 1 > v108) {
      unint64_t v108 = v109 >> 1;
    }
    if ((unint64_t)v109 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v110 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v110 = v108;
    }
    if (v110)
    {
      int v111 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v110);
      int v106 = (char *)*a3;
      uint64_t v86 = (char *)a3[1];
    }
    else
    {
      int v111 = 0;
    }
    __int16 v124 = &v111[4 * v107];
    int v96 = &v111[4 * v110];
    *(_DWORD *)__int16 v124 = 16;
    uint64_t v97 = v124 + 4;
    while (v86 != v106)
    {
      int v125 = *((_DWORD *)v86 - 1);
      v86 -= 4;
      *((_DWORD *)v124 - 1) = v125;
      v124 -= 4;
    }
    *a3 = v124;
    a3[1] = v97;
    a3[2] = v96;
    if (v106)
    {
      operator delete(v106);
      int v96 = *v85;
    }
  }
  else
  {
    *(_DWORD *)uint64_t v86 = 16;
    uint64_t v97 = v86 + 4;
  }
  a3[1] = v97;
  if (v97 >= v96)
  {
    __int16 v126 = (char *)*a3;
    uint64_t v127 = (uint64_t)&v97[-*a3] >> 2;
    unint64_t v128 = v127 + 1;
    if ((unint64_t)(v127 + 1) >> 62) {
      sub_10006A748();
    }
    uint64_t v129 = v96 - v126;
    if (v129 >> 1 > v128) {
      unint64_t v128 = v129 >> 1;
    }
    if ((unint64_t)v129 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v130 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v130 = v128;
    }
    if (v130)
    {
      long long v131 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v130);
      __int16 v126 = (char *)*a3;
      uint64_t v97 = (char *)a3[1];
    }
    else
    {
      long long v131 = 0;
    }
    v132 = &v131[4 * v127];
    uint64_t v133 = &v131[4 * v130];
    *(_DWORD *)v132 = 17;
    uint64_t v6 = v132 + 4;
    while (v97 != v126)
    {
      int v134 = *((_DWORD *)v97 - 1);
      v97 -= 4;
      *((_DWORD *)v132 - 1) = v134;
      v132 -= 4;
    }
    *a3 = v132;
    a3[1] = v6;
    a3[2] = v133;
    if (v126) {
      operator delete(v126);
    }
  }
  else
  {
    *(_DWORD *)uint64_t v97 = 17;
    uint64_t v6 = v97 + 4;
  }
  a3[1] = v6;
  if ((a1 & 0x10) != 0)
  {
LABEL_146:
    int v98 = (char *)a3[2];
    if (v6 >= v98)
    {
      int v100 = (char *)*a3;
      uint64_t v101 = (uint64_t)&v6[-*a3] >> 2;
      unint64_t v102 = v101 + 1;
      if ((unint64_t)(v101 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v103 = v98 - v100;
      if (v103 >> 1 > v102) {
        unint64_t v102 = v103 >> 1;
      }
      if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v104 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v104 = v102;
      }
      if (v104)
      {
        CFBooleanRef v105 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v104);
        int v100 = (char *)*a3;
        uint64_t v6 = (char *)a3[1];
      }
      else
      {
        CFBooleanRef v105 = 0;
      }
      long long v112 = &v105[4 * v101];
      int v98 = &v105[4 * v104];
      *(_DWORD *)long long v112 = 16;
      int v99 = v112 + 4;
      while (v6 != v100)
      {
        int v113 = *((_DWORD *)v6 - 1);
        v6 -= 4;
        *((_DWORD *)v112 - 1) = v113;
        v112 -= 4;
      }
      *a3 = v112;
      a3[1] = v99;
      a3[2] = v98;
      if (v100)
      {
        operator delete(v100);
        int v98 = (char *)a3[2];
      }
    }
    else
    {
      *(_DWORD *)uint64_t v6 = 16;
      int v99 = v6 + 4;
    }
    a3[1] = v99;
    if (v99 >= v98)
    {
      CFNumberRef v115 = (char *)*a3;
      uint64_t v116 = (uint64_t)&v99[-*a3] >> 2;
      unint64_t v117 = v116 + 1;
      if ((unint64_t)(v116 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v118 = v98 - v115;
      if (v118 >> 1 > v117) {
        unint64_t v117 = v118 >> 1;
      }
      if ((unint64_t)v118 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v119 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v119 = v117;
      }
      if (v119)
      {
        char v120 = (char *)sub_10005ECD8((uint64_t)(a3 + 2), v119);
        CFNumberRef v115 = (char *)*a3;
        int v99 = (char *)a3[1];
      }
      else
      {
        char v120 = 0;
      }
      v121 = &v120[4 * v116];
      __int16 v122 = &v120[4 * v119];
      *(_DWORD *)v121 = 17;
      char v114 = v121 + 4;
      while (v99 != v115)
      {
        int v123 = *((_DWORD *)v99 - 1);
        v99 -= 4;
        *((_DWORD *)v121 - 1) = v123;
        v121 -= 4;
      }
      *a3 = v121;
      a3[1] = v114;
      a3[2] = v122;
      if (v115) {
        operator delete(v115);
      }
    }
    else
    {
      *(_DWORD *)int v99 = 17;
      char v114 = v99 + 4;
    }
    a3[1] = v114;
  }
}

void sub_100C9A4F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C9A548(uint64_t a1, Registry **a2, uint64_t a3)
{
  CFStringRef v6 = (const __CFString *)sub_1003F26E0();
  CFPreferencesSynchronize(@"com.apple.tethering_override", v6, kCFPreferencesCurrentHost);
  CFStringRef v7 = (const __CFString *)sub_1003F26E0();
  uint64_t v8 = (void *)CFPreferencesCopyValue(@"AllowTethering", @"com.apple.tethering_override", v7, kCFPreferencesAnyHost);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *a2);
  uint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long __p = v12;
  int v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)__p);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v20 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  uint64_t v17 = 0;
  char v20 = 1;
LABEL_9:
  __p[0] = 0;
  if (v8)
  {
    CFTypeID v21 = CFGetTypeID(v8);
    if (v21 == CFBooleanGetTypeID()
      && (uint64_t v23 = (capabilities::ct *)ctu::cf::assign((ctu::cf *)__p, (BOOL *)v8, v22), __p[0])
      && ((v24 = capabilities::ct::supportsVoiceCall(v23), !v18) ? (char v25 = 1) : (char v25 = v24), (v25 & 1) == 0))
    {
      int v26 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 32))(v18);
    }
    else
    {
      int v26 = 0;
    }
    CFRelease(v8);
    if ((v20 & 1) == 0) {
      goto LABEL_18;
    }
  }
  else
  {
    int v26 = 0;
    if ((v20 & 1) == 0) {
LABEL_18:
    }
      sub_10004D2C8(v17);
  }
  if (v26)
  {
    uint64_t v27 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
      return 1;
    }
    sub_100C98B0C(a1, __p);
    if (v52 >= 0) {
      unint64_t v28 = __p;
    }
    else {
      unint64_t v28 = *(unsigned char **)__p;
    }
    *(_DWORD *)int v45 = 136315394;
    *(void *)&_OWORD v45[4] = "is_wireless_modem_allowed";
    __int16 v46 = 2080;
    uint64_t v47 = v28;
    uint64_t v29 = "#I %s: %s, Validation of wireless modem connection was not necessary because: tethering override is in place";
LABEL_45:
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v29, v45, 0x16u);
    if (SHIBYTE(v52) < 0)
    {
      uint64_t v36 = *(void **)__p;
LABEL_47:
      operator delete(v36);
    }
    return 1;
  }
  if ((capabilities::ct::supportsWirelessModem(v19) & 1) == 0)
  {
    unint64_t v30 = *(NSObject **)(a1 + 40);
    BOOL v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v31) {
      return result;
    }
    sub_100C98B0C(a1, __p);
    if (v52 >= 0) {
      int v33 = __p;
    }
    else {
      int v33 = *(unsigned char **)__p;
    }
    *(_DWORD *)int v45 = 136315394;
    *(void *)&_OWORD v45[4] = "is_wireless_modem_allowed";
    __int16 v46 = 2080;
    uint64_t v47 = v33;
    int v34 = "#I %s: %s, Failed to validate wireless modem connection: it is not supported";
    goto LABEL_36;
  }
  if ((byte_101B12AA0 & 1) == 0)
  {
    byte_101B12AA0 = 1;
    if (sub_1005B6F60())
    {
      byte_101B12AA1 = 1;
LABEL_40:
      uint64_t v27 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
        return 1;
      }
      sub_100C98B0C(a1, __p);
      if (v52 >= 0) {
        size_t v35 = __p;
      }
      else {
        size_t v35 = *(unsigned char **)__p;
      }
      *(_DWORD *)int v45 = 136315394;
      *(void *)&_OWORD v45[4] = "is_wireless_modem_allowed";
      __int16 v46 = 2080;
      uint64_t v47 = v35;
      uint64_t v29 = "#I %s: %s, Validation of wireless modem connection ignored because: carrier settings override";
      goto LABEL_45;
    }
  }
  if (byte_101B12AA1 == 1) {
    goto LABEL_40;
  }
  if (sub_100C9AB68(a2, a3))
  {
    int v37 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
      return 1;
    }
    uint64_t v38 = subscriber::asString();
    sub_100C98B0C(a1, v45);
    uint64_t v39 = v48 >= 0 ? v45 : *(unsigned char **)v45;
    *(_DWORD *)long long __p = 136315650;
    *(void *)&__p[4] = "is_wireless_modem_allowed";
    __int16 v50 = 2080;
    uint64_t v51 = v38;
    __int16 v52 = 2080;
    long long v53 = v39;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s: %s, Tethering editing supported for sim %s, so wireless modem allowed", __p, 0x20u);
    if ((v48 & 0x80000000) == 0) {
      return 1;
    }
    uint64_t v36 = *(void **)v45;
    goto LABEL_47;
  }
  int v40 = *(_DWORD *)(a1 + 144);
  if ((v40 - 2) < 2)
  {
    uint64_t v27 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
      return 1;
    }
    sub_100C98B0C(a1, __p);
    if (v52 >= 0) {
      unint64_t v42 = __p;
    }
    else {
      unint64_t v42 = *(unsigned char **)__p;
    }
    *(_DWORD *)int v45 = 136315394;
    *(void *)&_OWORD v45[4] = "is_wireless_modem_allowed";
    __int16 v46 = 2080;
    uint64_t v47 = v42;
    uint64_t v29 = "#I %s: %s, wireless modem allowed";
    goto LABEL_45;
  }
  if (v40)
  {
    if (v40 == 1)
    {
      uint64_t v27 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
        return 1;
      }
      sub_100C98B0C(a1, __p);
      if (v52 >= 0) {
        uint64_t v41 = __p;
      }
      else {
        uint64_t v41 = *(unsigned char **)__p;
      }
      *(_DWORD *)int v45 = 136315394;
      *(void *)&_OWORD v45[4] = "is_wireless_modem_allowed";
      __int16 v46 = 2080;
      uint64_t v47 = v41;
      uint64_t v29 = "#I %s: %s, No tethering validation for OMA/IPCU APNs, so wireless modem allowed";
      goto LABEL_45;
    }
    return 0;
  }
  unint64_t v30 = *(NSObject **)(a1 + 40);
  BOOL v43 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v43)
  {
    sub_100C98B0C(a1, __p);
    if (v52 >= 0) {
      uint64_t v44 = __p;
    }
    else {
      uint64_t v44 = *(unsigned char **)__p;
    }
    *(_DWORD *)int v45 = 136315394;
    *(void *)&_OWORD v45[4] = "is_wireless_modem_allowed";
    __int16 v46 = 2080;
    uint64_t v47 = v44;
    int v34 = "#I %s: %s, Tethering alteration prohibited, so wireless modem is not allowed";
LABEL_36:
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v34, v45, 0x16u);
    if (SHIBYTE(v52) < 0) {
      operator delete(*(void **)__p);
    }
    return 0;
  }
  return result;
}

void sub_100C9AB38(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100C9AB68(Registry **a1, uint64_t a2)
{
  CFDictionaryRef theDict = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    CFStringRef v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v42 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v42);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v12 + 96))(&cf1, v12, a2, 1, @"MandatoryVerify", 0, 0);
  sub_10004EFE4(&theDict, &cf1);
  sub_1000577C4(&cf1);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  CFTypeRef cf1 = 0;
  uint64_t v14 = (std::mutex *)Registry::getServiceMap(*a1);
  unsigned int v15 = v14;
  if ((v16 & 0x8000000000000000) != 0)
  {
    uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      unint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(v14);
  unint64_t v42 = v16;
  char v20 = sub_10004D37C(&v15[1].__m_.__sig, &v42);
  if (v20)
  {
    uint64_t v22 = v20[3];
    CFTypeID v21 = (std::__shared_weak_count *)v20[4];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v15);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      char v23 = 0;
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  std::mutex::unlock(v15);
  CFTypeID v21 = 0;
  char v23 = 1;
LABEL_19:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t))(*(void *)v22 + 192))(&cf1, v22, a2);
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  if (theDict) {
    char v24 = sub_100080778;
  }
  else {
    char v24 = 0;
  }
  if (v24
    && (cf1 ? (char v25 = sub_1000810B8) : (char v25 = 0),
        v25
     && (Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"SIMs"), (CFArrayRef v27 = Value) != 0)
     && (CFTypeID v28 = CFGetTypeID(Value), v28 == CFArrayGetTypeID())))
  {
    CFIndex Count = CFArrayGetCount(v27);
    CFIndex v30 = Count - 1;
    if (Count < 1)
    {
      BOOL v37 = 1;
    }
    else
    {
      CFIndex v31 = 0;
      do
      {
        CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(v27, v31);
        int v33 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v34 = CFGetTypeID(ValueAtIndex);
          if (v34 == CFStringGetTypeID()) {
            size_t v35 = v33;
          }
          else {
            size_t v35 = 0;
          }
        }
        else
        {
          size_t v35 = 0;
        }
        int v36 = CFEqual(cf1, v35);
        BOOL v37 = v36 == 0;
        if (v36) {
          BOOL v38 = 1;
        }
        else {
          BOOL v38 = v30 == v31;
        }
        ++v31;
      }
      while (!v38);
    }
  }
  else
  {
    BOOL v37 = 0;
  }
  sub_1000558F4(&cf1);
  sub_100057D78((const void **)&theDict);
  return v37;
}

void sub_100C9AE78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  sub_1000558F4((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100C9AEE4@<X0>(Registry **a1@<X0>, uint64_t a2@<X1>, const __CFNumber *a3@<X2>, uint64_t *a4@<X8>)
{
  unint64_t v6 = 0;
  size_t v35 = 0;
  if (a3) {
    goto LABEL_13;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *a1);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  int v36 = (unsigned int *)v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v36);
  if (!v13)
  {
    uint64_t v15 = 0;
    goto LABEL_9;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14)
  {
LABEL_9:
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
LABEL_10:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v15 + 80))(&v33, v15, a2, 1, @"APNEditabilityTypemaskNew", 0, 0);
  sub_1000842D0(&v34, &v33);
  uint64_t v17 = v35;
  size_t v35 = v34;
  int v36 = v17;
  CFTypeID v34 = 0;
  sub_1000570E8((const void **)&v36);
  sub_1000570E8((const void **)&v34);
  sub_1000577C4(&v33);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  unint64_t v6 = v35;
LABEL_13:
  if (v6) {
    uint64_t v18 = sub_100081E58;
  }
  else {
    uint64_t v18 = 0;
  }
  if (v18) {
    goto LABEL_28;
  }
  unsigned int v19 = (std::mutex *)Registry::getServiceMap(0, *a1);
  char v20 = v19;
  if (v21 < 0)
  {
    uint64_t v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(v19);
  int v36 = (unsigned int *)v21;
  char v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)&v36);
  if (!v25)
  {
    uint64_t v27 = 0;
    goto LABEL_24;
  }
  uint64_t v27 = v25[3];
  int v26 = (std::__shared_weak_count *)v25[4];
  if (!v26)
  {
LABEL_24:
    std::mutex::unlock(v20);
    int v26 = 0;
    char v28 = 1;
    goto LABEL_25;
  }
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v20);
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v26);
  char v28 = 0;
LABEL_25:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v27 + 80))(&v33, v27, a2, 1, @"APNEditabilityTypemask", 0, 0);
  sub_1000842D0(&v34, &v33);
  uint64_t v29 = v35;
  size_t v35 = v34;
  int v36 = v29;
  CFTypeID v34 = 0;
  sub_1000570E8((const void **)&v36);
  sub_1000570E8((const void **)&v34);
  sub_1000577C4(&v33);
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  unint64_t v6 = v35;
LABEL_28:
  LODWORD(v36) = 0;
  ctu::cf::assign((ctu::cf *)&v36, v6, a3);
  if (v35) {
    CFIndex v30 = sub_100081E58;
  }
  else {
    CFIndex v30 = 0;
  }
  if (v30) {
    uint64_t v31 = v36;
  }
  else {
    uint64_t v31 = 5;
  }
  sub_1000570E8((const void **)&v35);
  return v31;
}

void sub_100C9B1CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11)
{
  sub_1000577C4(&a9);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  sub_1000570E8(&a11);
  _Unwind_Resume(a1);
}

BOOL sub_100C9B234@<W0>(Registry *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v17 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    CFStringRef v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v18);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v12 + 80))(&v17, v12, a2, 1, @"APNEditabilityTypemaskNew", 0, 0);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (v17) {
    uint64_t v14 = sub_100080934;
  }
  else {
    uint64_t v14 = 0;
  }
  BOOL v15 = v14 != 0;
  sub_1000577C4(&v17);
  return v15;
}

void sub_100C9B384(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C9B3A0(Registry **a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  unint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v16);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v13 + 80))(&v15, v13, a2, 1, @"OTAActivationAPN", 0, 0);
  sub_10004EFE4(a3, &v15);
  sub_1000577C4(&v15);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_100C9B4E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000577C4(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_100C9B50C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A4DC60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100C9B52C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A4DC60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100C9B580(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

const char *sub_100C9B5A8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  uint64_t v2 = "ui-apn.?";
  if (v1 == 2) {
    uint64_t v2 = "ui-apn.2";
  }
  if (v1 == 1) {
    return "ui-apn.1";
  }
  else {
    return v2;
  }
}

uint64_t sub_100C9B5D8(uint64_t a1)
{
  *(void *)a1 = off_101A4DCB0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 160);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  sub_100057D78((const void **)(a1 + 120));
  uint64_t v5 = (void **)(a1 + 96);
  sub_10005CBF0(&v5);
  std::mutex::~mutex((std::mutex *)(a1 + 32));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
  *(void *)a1 = off_101A4D980;
  uint64_t v3 = *(NSObject **)(a1 + 16);
  if (v3) {
    dispatch_release(v3);
  }
  return a1;
}

void sub_100C9B68C(uint64_t a1)
{
  *(void *)a1 = off_101A4DCB0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 160);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  sub_100057D78((const void **)(a1 + 120));
  uint64_t v4 = (void **)(a1 + 96);
  sub_10005CBF0(&v4);
  std::mutex::~mutex((std::mutex *)(a1 + 32));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
  *(void *)a1 = off_101A4D980;
  uint64_t v3 = *(NSObject **)(a1 + 16);
  if (v3) {
    dispatch_release(v3);
  }
  operator delete();
}

uint64_t sub_100C9B754(uint64_t a1)
{
  return sub_100C9B9AC(a1, (const std::string *)(a1 + 128));
}

uint64_t sub_100C9B75C(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  uint64_t v3 = (uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 4;
  std::mutex::unlock(v2);
  return v3;
}

void sub_100C9B7A0(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  uint64_t v3 = (os_log_t *)(a1 + 24);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I DATA:: UI_APN_Storage:", buf, 2u);
    uint64_t v4 = *v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 4;
    *(_DWORD *)std::string buf = 134217984;
    unint64_t v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t %lu APN(s) found", buf, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 96);
  if (*(void *)(a1 + 104) != v6)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = *v3;
      if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        unint64_t v13 = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t APNx%zu:", buf, 0xCu);
        uint64_t v6 = *(void *)(a1 + 96);
      }
      sub_100C97150(*(void *)(v6 + v7), (os_log_t *)(a1 + 24));
      ++v8;
      uint64_t v6 = *(void *)(a1 + 96);
      v7 += 16;
    }
    while (v8 < (*(void *)(a1 + 104) - v6) >> 4);
  }
  char v10 = *v3;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v11 = *(void *)(a1 + 120);
    *(_DWORD *)std::string buf = 138412290;
    unint64_t v13 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t AttachAPN: %@", buf, 0xCu);
  }
  std::mutex::unlock(v2);
}

void sub_100C9B998(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100C9B9AC(uint64_t a1, const std::string *a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  int v5 = SHIBYTE(a2->__r_.__value_.__r.__words[2]);
  std::string::size_type size = a2->__r_.__value_.__l.__size_;
  if (v5 >= 0) {
    std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  }
  if (!size) {
    goto LABEL_24;
  }
  uint64_t v7 = (const void **)(a1 + 128);
  uint64_t v8 = *(unsigned __int8 *)(a1 + 151);
  if ((v8 & 0x80u) == 0) {
    uint64_t v9 = *(unsigned __int8 *)(a1 + 151);
  }
  else {
    uint64_t v9 = *(void *)(a1 + 136);
  }
  if (v9 == size)
  {
    if (v5 >= 0) {
      char v10 = a2;
    }
    else {
      char v10 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    }
    if ((v8 & 0x80) == 0)
    {
      if (*(unsigned char *)(a1 + 151))
      {
        unint64_t v11 = (unsigned __int8 *)(a1 + 128);
        while (*v11 == v10->__r_.__value_.__s.__data_[0])
        {
          ++v11;
          char v10 = (const std::string *)((char *)v10 + 1);
          if (!--v8) {
            goto LABEL_24;
          }
        }
        goto LABEL_18;
      }
LABEL_24:
      int v17 = 1;
      goto LABEL_42;
    }
    if (!memcmp(*v7, v10, *(void *)(a1 + 136))) {
      goto LABEL_24;
    }
  }
LABEL_18:
  std::string::operator=((std::string *)(a1 + 128), a2);
  CFDictionaryRef theDict = 0;
  *(void *)long long __p = CFPreferencesCopyValue(@"apns.per.iccid", @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  sub_100084068(&theDict, (CFTypeRef *)__p);
  CFPropertyListRef value = 0;
  if (theDict) {
    uint64_t v12 = sub_100080778;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v12)
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
    CFPropertyListRef v14 = value;
    CFPropertyListRef value = MutableCopy;
    *(void *)long long __p = v14;
    sub_10005717C((const void **)__p);
    BOOL v15 = (__CFDictionary *)value;
    sub_100C9DBA0(&v27, *(_DWORD *)(a1 + 8), @"last.iccid");
    unint64_t v16 = v27;
    if (*(char *)(a1 + 151) < 0)
    {
      sub_10004FC84(v24, *(void **)(a1 + 128), *(void *)(a1 + 136));
    }
    else
    {
      *(_OWORD *)unsigned int v24 = *(_OWORD *)v7;
      uint64_t v25 = *(void *)(a1 + 144);
    }
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(__dst, v24[0], (unint64_t)v24[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v24;
      uint64_t v32 = v25;
    }
    CFIndex v30 = 0;
    if (SHIBYTE(v32) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)__dst;
      *(void *)&__p[16] = v32;
    }
    int v33 = 0;
    if (ctu::cf::convert_copy())
    {
      unint64_t v18 = v30;
      CFIndex v30 = v33;
      CFTypeID v34 = v18;
      sub_1000558F4(&v34);
    }
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    unsigned int v19 = v30;
    int v26 = v30;
    CFIndex v30 = 0;
    sub_1000558F4(&v30);
    if (SHIBYTE(v32) < 0) {
      operator delete(__dst[0]);
    }
    CFDictionarySetValue(v15, v16, v19);
    sub_1000558F4(&v26);
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[0]);
    }
    sub_1000558F4(&v27);
    CFPreferencesSetValue(@"apns.per.iccid", value, @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  }
  sub_10005717C(&value);
  sub_100057D78((const void **)&theDict);
  int v17 = 0;
LABEL_42:
  char v20 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = (void *)(a1 + 128);
    if (*(char *)(a1 + 151) < 0) {
      uint64_t v21 = (void *)*v21;
    }
    *(_DWORD *)long long __p = 136315650;
    *(void *)&__p[4] = "refresh";
    *(_WORD *)&unsigned char __p[12] = 2080;
    *(void *)&__p[14] = v21;
    if (v17) {
      uint64_t v22 = " (same)";
    }
    else {
      uint64_t v22 = " (new one)";
    }
    *(_WORD *)&__p[22] = 2080;
    int v36 = v22;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s: refresh for subscriber:'%s'%s", __p, 0x20u);
  }
  *(void *)long long __p = 0;
  sub_100C9CDD8((const __CFDictionary **)__p, a1);
  sub_100C9D360(a1, *(const __CFDictionary **)__p);
  sub_100057D78((const void **)__p);
  std::mutex::unlock(v4);
  return v17 ^ 1u;
}

void sub_100C9BD74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, const void *a19, const void *a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  sub_1000558F4(&a20);
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_1000558F4(&a17);
  sub_10005717C(&a18);
  sub_100057D78(&a19);
  std::mutex::unlock(v35);
  _Unwind_Resume(a1);
}

void sub_100C9BE28(uint64_t a1, char a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  CFMutableDictionaryRef v21 = 0;
  if (*(char *)(a1 + 151) < 0) {
    uint64_t v5 = *(void *)(a1 + 136);
  }
  else {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 151);
  }
  uint64_t v6 = 0;
  if (v5 && (a2 & 1) == 0)
  {
    CFDictionaryRef theDict = 0;
    *(void *)std::string buf = CFPreferencesCopyValue(@"apns.per.iccid", @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
    sub_100084068(&theDict, (CFTypeRef *)buf);
    if (theDict) {
      uint64_t v7 = sub_100080778;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7)
    {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
      CFMutableDictionaryRef v9 = v21;
      CFMutableDictionaryRef v21 = MutableCopy;
      *(void *)std::string buf = v9;
      sub_10005717C((const void **)buf);
    }
    if (v21) {
      char v10 = sub_1000C06D0;
    }
    else {
      char v10 = 0;
    }
    if (v10)
    {
      unint64_t v11 = (_OWORD *)(a1 + 128);
      if (*(char *)(a1 + 151) < 0)
      {
        sub_10004FC84(v17, *(void **)(a1 + 128), *(void *)(a1 + 136));
      }
      else
      {
        *(_OWORD *)int v17 = *v11;
        uint64_t v18 = *(void *)(a1 + 144);
      }
      if (SHIBYTE(v18) < 0)
      {
        sub_10004FC84(__p, v17[0], (unint64_t)v17[1]);
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)v17;
        uint64_t v24 = v18;
      }
      uint64_t v22 = 0;
      if (SHIBYTE(v24) < 0)
      {
        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)std::string buf = *(_OWORD *)__p;
        *(void *)&uint8_t buf[16] = v24;
      }
      uint64_t v25 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v12 = v22;
        uint64_t v22 = v25;
        int v26 = v12;
        sub_1000558F4(&v26);
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      unint64_t v13 = v22;
      unsigned int v19 = v22;
      uint64_t v22 = 0;
      sub_1000558F4(&v22);
      if (SHIBYTE(v24) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v18) < 0) {
        operator delete(v17[0]);
      }
      CFDictionaryRemoveValue(v21, v13);
      CFPropertyListRef v14 = *(NSObject **)(a1 + 24);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 151) < 0) {
          unint64_t v11 = *(_OWORD **)v11;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = "erase";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v11;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: removed UI APNs for subscriber:%s", buf, 0x16u);
      }
      if (!CFDictionaryGetCount(v21))
      {
        CFMutableDictionaryRef v15 = v21;
        CFMutableDictionaryRef v21 = 0;
        *(void *)std::string buf = v15;
        sub_10005717C((const void **)buf);
      }
      sub_1000558F4(&v19);
    }
    sub_100057D78((const void **)&theDict);
    if (v21) {
      uint64_t v6 = sub_1000C06D0;
    }
    else {
      uint64_t v6 = 0;
    }
  }
  if (!v6)
  {
    unint64_t v16 = *(NSObject **)(a1 + 24);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "erase";
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: reset UI APN storage completely", buf, 0xCu);
    }
  }
  CFPreferencesSetValue(@"apns stuff", 0, @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  CFPreferencesSetValue(@"apns.per.iccid", v21, @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  CFPreferencesSynchronize(@"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  sub_100C9CDD8((const __CFDictionary **)buf, a1);
  sub_100C9D360(a1, *(const __CFDictionary **)buf);
  sub_100057D78((const void **)buf);
  sub_10005717C((const void **)&v21);
  std::mutex::unlock(v4);
}

void sub_100C9C21C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, const void *a19, const void *a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  sub_1000558F4(&a20);
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_100057D78(&a18);
  sub_10005717C(&a19);
  std::mutex::unlock(v26);
  _Unwind_Resume(a1);
}

void sub_100C9C2C0(uint64_t a1@<X0>, const void **a2@<X8>)
{
  uint64_t v4 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  sub_100058198(a2, (const void **)(a1 + 120));

  std::mutex::unlock(v4);
}

void sub_100C9C318(uint64_t a1@<X0>, const __CFDictionary **a2@<X8>)
{
  uint64_t v4 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  uint64_t v5 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136315138;
    uint64_t v7 = "getAPNs";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: reading UI configuration from storage", (uint8_t *)&v6, 0xCu);
  }
  sub_100C9CDD8(a2, a1);
  std::mutex::unlock(v4);
}

void sub_100C9C3E8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_100C9C3FC(uint64_t a1, char a2, uint64_t a3)
{
  if (*(void *)(a1 + 16)) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 16));
  }
  uint64_t v6 = a1;
  char v7 = a2;
  sub_1000F0058((uint64_t)&v8, a3);
  operator new();
}

void sub_100C9C508(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C9C530(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  CFTypeRef v6 = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (*(void *)(a1 + 16)) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 16));
  }
  uint64_t v7 = a1;
  CFTypeRef v8 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_1000DFC90((uint64_t)&v9, a3);
  operator new();
}

void sub_100C9C660(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C9C6A0(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  CFTypeRef v6 = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (*(void *)(a1 + 16)) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 16));
  }
  uint64_t v7 = a1;
  CFTypeRef v8 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_1000DFC90((uint64_t)&v9, a3);
  operator new();
}

void sub_100C9C7D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C9C810(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 16)) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 16));
  }
  uint64_t v4 = a1;
  sub_10062B11C((uint64_t)&v5, a2);
  operator new();
}

void sub_100C9C908(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C9C930(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 16)) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 16));
  }
  uint64_t v4 = a1;
  sub_10062B11C((uint64_t)&v5, a2);
  operator new();
}

void sub_100C9CA28(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100C9CA50(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W4>, void *a4@<X8>)
{
  CFTypeRef v8 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  uint64_t v9 = *(void **)(a1 + 96);
  uint64_t v10 = *(void *)(a1 + 104) - (void)v9;
  if (v10)
  {
    unint64_t v11 = v10 >> 4;
    if (v11 <= 1) {
      unint64_t v11 = 1;
    }
    do
    {
      if (a3) {
        uint64_t v12 = 160;
      }
      else {
        uint64_t v12 = 152;
      }
      if ((*(void *)(*v9 + v12) & a2) != 0) {
        operator new();
      }
      v9 += 2;
      --v11;
    }
    while (v11);
  }
  *a4 = 0;
  a4[1] = 0;
  std::mutex::unlock(v8);
}

void sub_100C9CD34()
{
}

const void **sub_100C9CDD8(const __CFDictionary **a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 8);
  theDict[0] = 0;
  CFStringRef v5 = (const __CFString *)kCacheUI;
  sub_100C9DBA0((const void **)&v33, v4, kCacheUI);
  AttachAPNDevicePersistentCopyValue((uint64_t *)buf, v33, 0);
  sub_10004EFE4(theDict, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  sub_1000558F4((const void **)&v33);
  if (theDict[0]) {
    CFTypeRef v6 = sub_100080778;
  }
  else {
    CFTypeRef v6 = 0;
  }
  if (!v6) {
    goto LABEL_17;
  }
  CFArrayRef Value = CFDictionaryGetValue(theDict[0], k3GPP);
  unint64_t v8 = (unint64_t)Value;
  if (Value && (CFTypeID v9 = CFGetTypeID(Value), v9 == CFDictionaryGetTypeID()))
  {
    sub_100C9DE78((void **)buf, a2, 0, v8);
    if (*(void *)buf) {
      uint64_t v10 = sub_100080778;
    }
    else {
      uint64_t v10 = 0;
    }
    sub_100057D78((const void **)buf);
    if (!v10) {
      goto LABEL_17;
    }
  }
  else
  {
    unint64_t v11 = *(NSObject **)(a2 + 24);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "migrateAttachApn";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: Invalid AttachAPN dictionary - dropping", buf, 0xCu);
    }
  }
  uint64_t v12 = *(NSObject **)(a2 + 24);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "migrateAttachApn";
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: Migration complete", buf, 0xCu);
  }
  sub_100C9DBA0((const void **)buf, v4, v5);
  AttachAPNDevicePersistentSaveValue(*(const __CFString **)buf, 0);
  sub_1000558F4((const void **)buf);
LABEL_17:
  sub_100057D78((const void **)theDict);
  *a1 = 0;
  theDict[0] = (CFDictionaryRef)CFPreferencesCopyValue(@"apns stuff", @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  *(void *)std::string buf = 0;
  unint64_t v13 = (const void **)sub_100084068(buf, (CFTypeRef *)theDict);
  CFDictionaryRef v14 = *a1;
  *a1 = *(const __CFDictionary **)buf;
  *(void *)std::string buf = v14;
  uint64_t result = sub_100057D78(v13);
  if (*(char *)(a2 + 151) < 0)
  {
    if (!*(void *)(a2 + 136)) {
      return result;
    }
  }
  else if (!*(unsigned char *)(a2 + 151))
  {
    return result;
  }
  if (*a1) {
    unint64_t v16 = sub_100080778;
  }
  else {
    unint64_t v16 = 0;
  }
  if (v16)
  {
    CFPreferencesSetValue(@"apns stuff", 0, @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
    sub_100C9DE78((void **)theDict, a2, *a1, 0);
    if (theDict != a1)
    {
      *(void *)std::string buf = *a1;
      *a1 = theDict[0];
      theDict[0] = 0;
      sub_100057D78((const void **)buf);
    }
    int v17 = (const void **)theDict;
  }
  else
  {
    CFDictionaryRef v28 = 0;
    *(void *)std::string buf = CFPreferencesCopyValue(@"apns.per.iccid", @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
    sub_100084068(&v28, (CFTypeRef *)buf);
    CFDictionaryRef v18 = v28;
    if (v28) {
      unsigned int v19 = sub_100080778;
    }
    else {
      unsigned int v19 = 0;
    }
    if (v19)
    {
      if (*(char *)(a2 + 151) < 0)
      {
        sub_10004FC84(__p, *(void **)(a2 + 128), *(void *)(a2 + 136));
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)(a2 + 128);
        uint64_t v25 = *(void *)(a2 + 144);
      }
      if (SHIBYTE(v25) < 0)
      {
        sub_10004FC84(theDict, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)CFDictionaryRef theDict = *(_OWORD *)__p;
        uint64_t v31 = v25;
      }
      CFStringRef v29 = 0;
      if (SHIBYTE(v31) < 0)
      {
        sub_10004FC84(buf, theDict[0], (unint64_t)theDict[1]);
      }
      else
      {
        *(_OWORD *)std::string buf = *(_OWORD *)theDict;
        uint64_t v35 = v31;
      }
      CFStringRef v32 = 0;
      if (ctu::cf::convert_copy())
      {
        CFStringRef v20 = v29;
        CFStringRef v29 = v32;
        CFStringRef v33 = v20;
        sub_1000558F4((const void **)&v33);
      }
      if (SHIBYTE(v35) < 0) {
        operator delete(*(void **)buf);
      }
      CFStringRef v21 = v29;
      CFStringRef v26 = v29;
      CFStringRef v29 = 0;
      sub_1000558F4((const void **)&v29);
      if (SHIBYTE(v31) < 0) {
        operator delete(theDict[0]);
      }
      CFTypeRef v27 = CFDictionaryGetValue(v18, v21);
      *(void *)std::string buf = 0;
      uint64_t v22 = (const void **)sub_10004EFE4(buf, &v27);
      CFDictionaryRef v23 = *a1;
      *a1 = *(const __CFDictionary **)buf;
      *(void *)std::string buf = v23;
      sub_100057D78(v22);
      sub_1000558F4((const void **)&v26);
      if (SHIBYTE(v25) < 0) {
        operator delete(__p[0]);
      }
    }
    int v17 = (const void **)&v28;
  }
  return sub_100057D78(v17);
}

void sub_100C9D284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, const void *a18, const void *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  sub_1000558F4(&a19);
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_100057D78(&a18);
  sub_100057D78(v25);
  _Unwind_Resume(a1);
}

const void **sub_100C9D360(uint64_t a1, const __CFDictionary *a2)
{
  CFTypeRef cf1 = 0;
  int v4 = (CFTypeRef *)(a1 + 120);
  sub_100058198(&cf1, (const void **)(a1 + 120));
  sub_10019E028((uint64_t *)(a1 + 96));
  uint64_t v5 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = 0;
  *(void *)std::string buf = v5;
  sub_100057D78((const void **)buf);
  if (a2)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"source");
    CFStringRef v7 = Value;
    if (Value)
    {
      CFTypeID v8 = CFGetTypeID(Value);
      if (v8 == CFStringGetTypeID()) {
        CFStringCompare(v7, @"usersettings", 0);
      }
    }
    CFArrayRef theArray = 0;
    *(void *)std::string buf = CFDictionaryGetValue(a2, @"apns");
    sub_100044D6C(&theArray, (CFTypeRef *)buf);
    if (theArray) {
      CFTypeID v9 = sub_100083F10;
    }
    else {
      CFTypeID v9 = 0;
    }
    if (v9)
    {
      CFIndex Count = CFArrayGetCount(theArray);
      unint64_t v11 = CFDictionaryGetValue(a2, @"APNEditabilityTypemaskNew");
      if (v11)
      {
        CFGetTypeID(v11);
        CFNumberGetTypeID();
      }
      if (Count >= 1)
      {
        uint64_t v38 = 0;
        *(void *)std::string buf = CFArrayGetValueAtIndex(theArray, 0);
        sub_10004EFE4(&v38, (CFTypeRef *)buf);
        if (v38) {
          uint64_t v12 = sub_100080778;
        }
        else {
          uint64_t v12 = 0;
        }
        if (!v12) {
          __TUAssertTrigger();
        }
        *(void *)std::string buf = 0;
        *(void *)&buf[8] = 0;
        sub_100BBEC88(buf);
      }
    }
    CFTypeRef v41 = CFDictionaryGetValue(a2, @"attachApn");
    *(void *)std::string buf = 0;
    sub_10004EFE4(buf, &v41);
    CFTypeRef v13 = *v4;
    CFTypeRef *v4 = *(CFTypeRef *)buf;
    *(void *)std::string buf = v13;
    sub_100057D78((const void **)buf);
    sub_100044D00((const void **)&theArray);
  }
  CFMutableDictionaryRef v15 = (os_log_t *)(a1 + 24);
  CFDictionaryRef v14 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = (uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 4;
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "apply";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: %zu APN(s) ==>> ", buf, 0x16u);
  }
  uint64_t v17 = *(void *)(a1 + 96);
  if (*(void *)(a1 + 104) != v17)
  {
    uint64_t v18 = 0;
    unint64_t v19 = 0;
    do
    {
      sub_100C97DFC(*(void *)(v17 + v18), (os_log_t *)(a1 + 24), (uint64_t)"");
      ++v19;
      uint64_t v17 = *(void *)(a1 + 96);
      v18 += 16;
    }
    while (v19 < (*(void *)(a1 + 104) - v17) >> 4);
  }
  CFStringRef v20 = *v15;
  if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "apply";
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s: <<== APN(s)", buf, 0xCu);
    CFStringRef v20 = *v15;
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    CFTypeRef v21 = *v4;
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "apply";
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s: AttachAPN: %@", buf, 0x16u);
  }
  if (cf1) {
    uint64_t v22 = sub_100080778;
  }
  else {
    uint64_t v22 = 0;
  }
  BOOL v23 = v22 == 0;
  if (*v4) {
    uint64_t v24 = sub_100080778;
  }
  else {
    uint64_t v24 = 0;
  }
  if (v23 == (v24 != 0) || v24 && !CFEqual(cf1, *v4)) {
    sub_100C9E680((uint64_t)&event::data::refreshAttachApn, *(_DWORD *)(a1 + 8), "ui-apn");
  }
  uint64_t v25 = *(uint64_t **)(a1 + 104);
  if (v25 == *(uint64_t **)(a1 + 96))
  {
    if (*v4) {
      uint64_t v25 = (uint64_t *)sub_100080778;
    }
    else {
      uint64_t v25 = 0;
    }
    BOOL v26 = v25 != 0;
  }
  else
  {
    BOOL v26 = 1;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v25, *(Registry **)(a1 + 152));
  CFDictionaryRef v28 = ServiceMap;
  if (v29 < 0)
  {
    CFIndex v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      uint64_t v29 = v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v29;
  CFStringRef v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)buf);
  if (!v33)
  {
    uint64_t v35 = 0;
LABEL_52:
    std::mutex::unlock(v28);
    CFTypeID v34 = 0;
    char v36 = 1;
    if (!v35) {
      goto LABEL_54;
    }
    goto LABEL_53;
  }
  uint64_t v35 = v33[3];
  CFTypeID v34 = (std::__shared_weak_count *)v33[4];
  if (!v34) {
    goto LABEL_52;
  }
  atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v28);
  atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v34);
  char v36 = 0;
  if (v35) {
LABEL_53:
  }
    (*(void (**)(uint64_t, void, BOOL, void))(*(void *)v35 + 48))(v35, *(unsigned int *)(a1 + 8), v26, 0);
LABEL_54:
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  return sub_100057D78(&cf1);
}

void sub_100C9DAE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100C9DBA0(const void **a1, int a2, const __CFString *cf)
{
  CFStringRef theString2 = cf;
  if (cf)
  {
    CFRetain(cf);
    CFStringRef v6 = theString2;
  }
  else
  {
    CFStringRef v6 = 0;
  }
  if (v6) {
    CFStringRef v7 = sub_1000810B8;
  }
  else {
    CFStringRef v7 = 0;
  }
  if (v7 && a2 == 2)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12AA8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B12AA8))
    {
      qword_101B12AC0 = 0;
      qword_101B12AB8 = 0;
      qword_101B12AB0 = (uint64_t)&qword_101B12AB8;
      __cxa_atexit((void (*)(void *))sub_100C9DE4C, &qword_101B12AB0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B12AA8);
    }
    uint64_t v9 = qword_101B12AB8;
    if (qword_101B12AB8)
    {
      uint64_t v10 = &qword_101B12AB8;
      do
      {
        CFComparisonResult v11 = CFStringCompare(*(CFStringRef *)(v9 + 32), theString2, 0);
        uint64_t v12 = (uint64_t *)(v9 + 8);
        if (v11 != kCFCompareLessThan)
        {
          uint64_t v12 = (uint64_t *)v9;
          uint64_t v10 = (uint64_t *)v9;
        }
        uint64_t v9 = *v12;
      }
      while (*v12);
      if (v10 != &qword_101B12AB8 && CFStringCompare(theString2, (CFStringRef)v10[4], 0) != kCFCompareLessThan)
      {
        sub_100083DA4(a1, (const void **)v10 + 5);
        return sub_1000558F4((const void **)&theString2);
      }
    }
    *a1 = 0;
    *a1 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-%d", cf, 2);
    uint64_t v13 = qword_101B12AB8;
    if (qword_101B12AB8)
    {
      CFDictionaryRef v14 = (void **)&qword_101B12AB8;
      while (1)
      {
        while (1)
        {
          CFMutableDictionaryRef v15 = (uint64_t *)v13;
          if (CFStringCompare(theString2, *(CFStringRef *)(v13 + 32), 0) != kCFCompareLessThan) {
            break;
          }
          uint64_t v13 = *v15;
          CFDictionaryRef v14 = (void **)v15;
          if (!*v15) {
            goto LABEL_29;
          }
        }
        if (CFStringCompare((CFStringRef)v15[4], theString2, 0) != kCFCompareLessThan) {
          break;
        }
        CFDictionaryRef v14 = (void **)(v15 + 1);
        uint64_t v13 = v15[1];
        if (!v13) {
          goto LABEL_29;
        }
      }
      uint64_t v16 = (const void **)*v14;
      if (*v14) {
        goto LABEL_32;
      }
    }
    else
    {
      CFDictionaryRef v14 = (void **)&qword_101B12AB8;
      CFMutableDictionaryRef v15 = &qword_101B12AB8;
    }
LABEL_29:
    uint64_t v16 = (const void **)operator new(0x30uLL);
    sub_100083DA4(v16 + 4, (const void **)&theString2);
    v16[5] = 0;
    NSObject *v16 = 0;
    v16[1] = 0;
    v16[2] = v15;
    NSObject *v14 = v16;
    uint64_t v17 = (uint64_t *)v16;
    if (*(void *)qword_101B12AB0)
    {
      qword_101B12AB0 = *(void *)qword_101B12AB0;
      uint64_t v17 = (uint64_t *)*v14;
    }
    sub_100046C90((uint64_t *)qword_101B12AB8, v17);
    ++qword_101B12AC0;
LABEL_32:
    sub_100083EB8(v16 + 5, a1);
    return sub_1000558F4((const void **)&theString2);
  }
  *a1 = v6;
  CFStringRef theString2 = 0;
  return sub_1000558F4((const void **)&theString2);
}

void sub_100C9DE18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100C9DE4C(uint64_t a1)
{
  return a1;
}

void sub_100C9DE78(void **a1, uint64_t a2, const __CFDictionary *a3, unint64_t a4)
{
  *a1 = 0;
  if (!((unint64_t)a3 | a4))
  {
    uint64_t v9 = *(NSObject **)(a2 + 24);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "save";
    uint64_t v10 = "#I %s: save() called with empty parameters - ignored";
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 0xCu);
    return;
  }
  CFTypeID v8 = (void **)(a2 + 128);
  if ((*(char *)(a2 + 151) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a2 + 151))
    {
      key = 0;
      *(_OWORD *)long long __dst = *(_OWORD *)v8;
      uint64_t v35 = *(void *)(a2 + 144);
      goto LABEL_9;
    }
    goto LABEL_11;
  }
  unint64_t v11 = *(void *)(a2 + 136);
  if (!v11)
  {
LABEL_11:
    uint64_t v9 = *(NSObject **)(a2 + 24);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "save";
    uint64_t v10 = "#I %s: UI APN(s)/AttachAPN cannot be stored, no ICCID to tie to";
    goto LABEL_13;
  }
  key = 0;
  sub_10004FC84(__dst, *v8, v11);
LABEL_9:
  if (SHIBYTE(v35) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v41 = v35;
  }
  CFMutableDictionaryRef v37 = 0;
  if (SHIBYTE(v41) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    *(void *)&uint8_t buf[16] = v41;
  }
  CFDictionaryRef v38 = 0;
  if (ctu::cf::convert_copy())
  {
    CFDictionaryRef v12 = v37;
    CFMutableDictionaryRef v37 = v38;
    CFDictionaryRef theDict = v12;
    sub_1000558F4((const void **)&theDict);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  key = v37;
  CFMutableDictionaryRef v37 = 0;
  sub_1000558F4((const void **)&v37);
  if (SHIBYTE(v41) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(__dst[0]);
  }
  CFDictionaryRef theDict = 0;
  *(void *)std::string buf = CFPreferencesCopyValue(@"apns.per.iccid", @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  sub_100084068(&theDict, (CFTypeRef *)buf);
  CFDictionaryRef v38 = 0;
  if (theDict) {
    uint64_t v13 = sub_100080778;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13)
  {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
LABEL_32:
    CFDictionaryRef v15 = v38;
    CFDictionaryRef v38 = MutableCopy;
    *(void *)std::string buf = v15;
    sub_10005717C((const void **)buf);
    goto LABEL_33;
  }
  CFDictionaryRef MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (MutableCopy) {
    goto LABEL_32;
  }
LABEL_33:
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v38, key);
  CFDictionaryRef v17 = Value;
  if (Value)
  {
    CFTypeID v18 = CFGetTypeID(Value);
    if (v18 == CFDictionaryGetTypeID())
    {
      CFMutableDictionaryRef v37 = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutableCopy(0, 0, v17);
LABEL_37:
      CFMutableDictionaryRef v20 = v37;
      CFMutableDictionaryRef v37 = Mutable;
      *(void *)std::string buf = v20;
      sub_10005717C((const void **)buf);
      goto LABEL_38;
    }
  }
  CFMutableDictionaryRef v37 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable) {
    goto LABEL_37;
  }
LABEL_38:
  if (a3)
  {
    CFTypeRef v21 = v37;
    CFIndex Count = CFDictionaryGetCount(a3);
    memset(buf, 0, sizeof(buf));
    sub_10004EE3C(buf, Count);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v41 = 0;
    sub_10004EE3C(__p, Count);
    CFDictionaryGetKeysAndValues(a3, *(const void ***)buf, (const void **)__p[0]);
    if (Count >= 1)
    {
      for (uint64_t i = 0; i != Count; ++i)
        CFDictionarySetValue(v21, *(const void **)(*(void *)buf + 8 * i), *((const void **)__p[0] + i));
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (*(void *)buf)
    {
      *(void *)&buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if (sub_100C9B234(*(Registry **)(a2 + 152), *(unsigned int *)(a2 + 8), v23))
    {
      BOOL v26 = v37;
      unsigned int v27 = sub_100C9AEE4((Registry **)(a2 + 152), *(unsigned int *)(a2 + 8), 0, v25);
      __p[0] = 0;
      *(void *)std::string buf = v27;
      CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
      if (v28)
      {
        uint64_t v29 = __p[0];
        __p[0] = v28;
        *(void *)std::string buf = v29;
        sub_1000570E8((const void **)buf);
      }
      CFIndex v30 = __p[0];
      CFStringRef v33 = __p[0];
      __p[0] = 0;
      sub_1000570E8((const void **)__p);
      CFDictionarySetValue(v26, @"APNEditabilityTypemaskNew", v30);
      sub_1000570E8((const void **)&v33);
    }
  }
  if (a4) {
    CFDictionarySetValue(v37, @"attachApn", (const void *)a4);
  }
  CFDictionarySetValue(v38, key, v37);
  uint64_t v31 = v38;
  sub_100C9DBA0((const void **)buf, *(_DWORD *)(a2 + 8), @"last.iccid");
  CFDictionarySetValue(v31, *(const void **)buf, key);
  sub_1000558F4((const void **)buf);
  unsigned int v32 = *(NSObject **)(a2 + 24);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 151) < 0) {
      CFTypeID v8 = (void **)*v8;
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "save";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s: saved UI APNs for subscriber:%s", buf, 0x16u);
  }
  sub_10004EFE4(__p, (CFTypeRef *)&v37);
  if (__p != a1)
  {
    *(void *)std::string buf = *a1;
    *a1 = __p[0];
    __p[0] = 0;
    sub_100057D78((const void **)buf);
  }
  sub_100057D78((const void **)__p);
  CFPreferencesSetValue(@"apns.per.iccid", v38, @"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  CFPreferencesSynchronize(@"com.apple.commcenter.user_apns", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  sub_10005717C((const void **)&v37);
  sub_10005717C((const void **)&v38);
  sub_100057D78((const void **)&theDict);
  sub_1000558F4((const void **)&key);
}

void sub_100C9E44C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, const void *a18, const void *a19, const void *a20,const void *a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  sub_1000570E8(&a10);
  sub_10005717C(&a19);
  sub_10005717C(&a20);
  sub_100057D78(&a21);
  sub_1000558F4(&a18);
  sub_100057D78(v34);
  _Unwind_Resume(a1);
}

void **sub_100C9E564(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  CFStringRef v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    CFDictionaryRef v14 = (char *)sub_10006A794((uint64_t)result, v13);
    CFDictionaryRef v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)CFDictionaryRef v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    sub_100BC52B0(a1, v18);
    uint64_t v9 = (void *)a1[1];
    uint64_t result = sub_1006C59A4(v18);
  }
  else
  {
    *CFStringRef v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_100C9E66C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006C59A4((void **)va);
  _Unwind_Resume(a1);
}

void sub_100C9E680(uint64_t a1, int a2, char *a3)
{
  sub_100C9E70C((uint64_t *)(a1 + 24), a2, a3);
  sub_100058DB0(__p, a3);
  unint64_t v6 = (uint64_t *)sub_100C9E8D8((uint64_t *)(a1 + 8));
  sub_100C9E91C(v6, a2, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100C9E6F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C9E70C(uint64_t *a1, int a2, const char *a3)
{
  int v25 = a2;
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)uint64_t v12 = 0u;
  memset(v11, 0, sizeof(v11));
  sub_10004DE24((uint64_t)v11);
  unint64_t v5 = (void *)subscriber::operator<<();
  unint64_t v6 = sub_10004B96C(v5, (uint64_t)", ", 2);
  size_t v7 = strlen(a3);
  sub_10004B96C(v6, (uint64_t)a3, v7);
  sub_10004BC98((uint64_t)v11 + 8, __p);
  sub_1001AA668(a1, (uint64_t *)__p);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100C9E8C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100C9E8D8(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_100C9E91C(uint64_t *a1, int a2, uint64_t a3)
{
  int v26 = a2;
  long long v25 = 0uLL;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  unint64_t v5 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(&v29, v5);
  uint64_t v6 = a1[1];
  if (v6)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) == 1) {
      sub_100C9EB9C(a1, &v29, 0, 1);
    }
    uint64_t v7 = *a1;
    uint64_t v8 = a1[1];
    if (v8) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v8 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v7 = *a1;
  }
  long long v9 = v25;
  *(void *)&long long v25 = v7;
  *((void *)&v25 + 1) = v8;
  v28[0] = v9;
  sub_10000A740((atomic_uint **)v28 + 1);
  sub_10000A6C8(*((pthread_mutex_t **)&v40 + 1));
  sub_10000A5F8(&v29);
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  uint64_t v44 = 0;
  uint64_t v45 = 10;
  __int16 v46 = (char *)&v29 + 8;
  uint64_t v47 = 0;
  char v48 = &v26;
  uint64_t v49 = a3;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  char v10 = (uint64_t *)sub_100C9EC50((uint64_t *)&v25);
  v24[0] = &v29;
  v24[1] = a1;
  v24[2] = sub_100C9EEC0(v10);
  uint64_t v11 = sub_100C9EC50((uint64_t *)&v25);
  uint64_t v12 = sub_100060EA8((uint64_t *)(v11 + 16));
  long long v13 = (uint64_t *)sub_100C9EC50((uint64_t *)&v25);
  uint64_t v14 = *(void *)(sub_100C9EEC0(v13) + 8);
  long long v15 = (uint64_t *)sub_100C9EC50((uint64_t *)&v25);
  *(void *)&long long v22 = v14;
  *((void *)&v22 + 1) = sub_100C9EEC0(v15);
  *(void *)&long long v23 = &v29;
  *((void *)&v23 + 1) = *((void *)&v22 + 1);
  sub_100C9F124((uint64_t *)&v22);
  long long v16 = (uint64_t *)sub_100C9EC50((uint64_t *)&v25);
  uint64_t v17 = sub_100C9EEC0(v16);
  long long v18 = (uint64_t *)sub_100C9EC50((uint64_t *)&v25);
  *(void *)&long long v20 = v17;
  *((void *)&v20 + 1) = sub_100C9EEC0(v18);
  *(void *)&long long v21 = &v29;
  *((void *)&v21 + 1) = *((void *)&v20 + 1);
  sub_100C9F124((uint64_t *)&v20);
  v28[0] = v22;
  v28[1] = v23;
  v27[0] = v20;
  v27[1] = v21;
  sub_100C9EF04(v12, (uint64_t *)v28, v27);
  sub_100C9F4E4((uint64_t)v24);
  sub_100C9FDBC((uint64_t)&v29);
  return sub_10000A740((atomic_uint **)&v25 + 1);
}

void sub_100C9EB48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,atomic_uint *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

uint64_t *sub_100C9EB9C(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  long long v9 = (uint64_t *)sub_100C9EC50(a1);
  uint64_t v10 = sub_100C9EEC0(v9);
  uint64_t v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    uint64_t v12 = (uint64_t *)sub_100C9EC50(a1);
    uint64_t v11 = *(uint64_t **)(sub_100C9EEC0(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_100C9EC94(a1, a2, a3, &v14, a4);
}

uint64_t sub_100C9EC50(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100C9EC94(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  long long v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_100C9EC50(a1);
  uint64_t result = (uint64_t *)sub_100C9EEC0(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_100C9EDD0(result + 2);
        sub_100C9EE14(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_100C9EDD0(result + 2) + 24))
      {
        long long v15 = (atomic_uint *)v22[1];
      }
      else
      {
        long long v16 = (uint64_t *)sub_100C9EC50(a1);
        uint64_t v17 = sub_100C9EEC0(v16);
        uint64_t v18 = sub_100C9EDD0(v22 + 2);
        long long v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      long long v22 = (uint64_t *)v15;
      long long v19 = (uint64_t *)sub_100C9EC50(a1);
      long long v20 = (uint64_t *)sub_100C9EEC0(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t sub_100C9EDD0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100C9EE14(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_100C9EE7C(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_100C9EE7C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_100C9EEC0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100C9EF04(uint64_t a1, uint64_t *a2, void *a3)
{
  while (*a2 != *a3)
  {
    sub_100C9EF84(a2);
    *a2 = *(void *)(*a2 + 8);
    sub_100C9F124(a2);
    uint64_t v5 = (unsigned char *)a2[2];
    if (*v5) {
      unsigned char *v5 = 0;
    }
  }
}

unsigned char *sub_100C9EF84(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[2];
  if (!*v2)
  {
    sub_100C9F040((uint64_t)(v2 + 272), (uint64_t *)(*a1 + 16));
    if (!*v2) {
      unsigned char *v2 = 1;
    }
  }
  uint64_t v3 = (unsigned char *)a1[2];
  if (!*v3) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  return v3 + 1;
}

uint64_t sub_100C9F040(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = sub_100C9EDD0(a2);
  uint64_t v3 = (void *)(sub_100C9EE7C((uint64_t *)(v2 + 32)) + 24);

  return sub_100C9F08C(v3);
}

uint64_t sub_100C9F08C(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  int v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_100C9F110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_100C9F124(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_15;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      uint64_t v3 = (uint64_t *)(*a1 + 16);
      long long v15 = 0u;
      long long v16 = 0u;
      uint64_t v4 = sub_100C9F380(v3);
      sub_10000A4EC(&v15, v4);
      uint64_t v5 = (atomic_uint **)sub_100C9EDD0((uint64_t *)(*a1 + 16));
      sub_100C9F3C4(v5, &v15, (void *)(a1[2] + 8));
      uint64_t v6 = sub_100C9EDD0((uint64_t *)(*a1 + 16));
      uint64_t v7 = a1[2];
      if (*(unsigned char *)(v6 + 24)) {
        ++*(_DWORD *)(v7 + 288);
      }
      else {
        ++*(_DWORD *)(v7 + 292);
      }
      uint64_t v8 = sub_100C9EDD0((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v8 + 24)
        || (uint64_t v9 = *(void *)(v8 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v9 + 8), memory_order_acquire))
      {
        int v10 = 1;
      }
      else
      {
        sub_1007B631C(a1, &v15, *a1);
        int v10 = 0;
      }
      (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
      sub_10000A5F8(&v15);
      uint64_t v1 = *a1;
      uint64_t v11 = a1[1];
      if (!v10) {
        break;
      }
      uint64_t v12 = *(void *)(v1 + 8);
      *a1 = v12;
      if (v12 == v11)
      {
        uint64_t v1 = v11;
        goto LABEL_15;
      }
    }
    if (v1 == v11)
    {
LABEL_15:
      uint64_t v13 = a1[3];
      if (v13 != v1)
      {
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        uint64_t v14 = sub_100C9F380((uint64_t *)(v13 + 16));
        sub_10000A4EC(&v15, v14);
        sub_1007B631C(a1, &v15, a1[1]);
        (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
        sub_10000A5F8(&v15);
      }
    }
  }
}

void sub_100C9F344(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100C9F380(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_100C9F3C4(atomic_uint **result, void *a2, void *a3)
{
  uint64_t v3 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v6 = result;
    for (uint64_t i = *(atomic_uint **)sub_100C9EE7C((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_100C9EE7C(v3);
      if (i == result[1]) {
        break;
      }
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v6 + 24))
        {
          *((unsigned char *)v6 + 24) = 0;
          sub_100060D70(v6, a2);
        }
        return sub_1000624B4((uint64_t)v8);
      }
      sub_100062188(a3, (uint64_t)v8);
      sub_1000624B4((uint64_t)v8);
    }
  }
  return result;
}

void sub_100C9F4C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100C9F4E4(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)a1 + 292) > *(_DWORD *)(*(void *)a1 + 288)) {
    sub_100C9F528(*(uint64_t **)(a1 + 8), *(void *)(a1 + 16));
  }
  return a1;
}

void sub_100C9F528(uint64_t *a1, uint64_t a2)
{
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  uint64_t v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v9, v4);
  uint64_t v5 = (uint64_t *)sub_100C9EC50(a1);
  if (sub_100C9EEC0(v5) == a2)
  {
    uint64_t v6 = a1[1];
    if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
      operator new();
    }
    uint64_t v7 = (uint64_t *)sub_100C9EC50(a1);
    uint64_t v8 = *(uint64_t **)(sub_100C9EEC0(v7) + 8);
    sub_100C9EC94(a1, v9, 0, &v8, 0);
  }
  sub_10000A6C8(*((pthread_mutex_t **)&v10 + 1));
  sub_10000A5F8(v9);
}

void sub_100C9F674()
{
}

void sub_100C9F6C8(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_100C9F788(&v2, a2);
}

uint64_t sub_100C9F744(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100C9F788(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100C9F7F4(&v2);
}

void sub_100C9F7E0(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100C9F7F4(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100C9F864(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_100C9F878(_Unwind_Exception *a1)
{
}

void sub_100C9F890()
{
}

uint64_t sub_100C9F8A4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100C9F908()
{
  return 0;
}

uint64_t sub_100C9F910()
{
  return 0;
}

uint64_t sub_100C9F918()
{
  return 0;
}

void sub_100C9F920()
{
}

void sub_100C9F99C()
{
}

uint64_t sub_100C9F9C0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100C9FB4C((uint64_t *)a1, a2);
  sub_100C9FBB8((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      long long v10 = (void *)v5[1];
      uint64_t v11 = v10;
      uint64_t v12 = v5;
      if (v10)
      {
        do
        {
          uint64_t v13 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          uint64_t v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          long long v16 = v10;
          long long v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          long long v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      long long v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          long long v18 = v17;
          long long v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          long long v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      uint64_t v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_100C9FB24(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100C9FB4C(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_100C9FBA4(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100C9FBB8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100C9FC08(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100C9FC20(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100C9FC8C(&v2);
}

void sub_100C9FC78(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100C9FC8C(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100C9FCFC(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_100C9FD10(_Unwind_Exception *a1)
{
}

void sub_100C9FD28()
{
}

uint64_t sub_100C9FD3C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100C9FDA4()
{
  return 0;
}

uint64_t sub_100C9FDAC()
{
  return 0;
}

uint64_t sub_100C9FDB4()
{
  return 0;
}

uint64_t sub_100C9FDBC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 296);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 296), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100C9FE90(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_100C9FEB0(uint64_t a1)
{
  uint64_t v4 = a1;
  sub_100C9BE28(*(void *)a1, *(unsigned char *)(a1 + 8));
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }
  return sub_100B69D30(&v4);
}

void sub_100C9FF1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B69D30((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100C9FF30(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 16));
    sub_100057D78((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_100C9FF88(uint64_t *a1)
{
  uint64_t v8 = a1;
  uint64_t v2 = *a1;
  CFDictionaryRef v3 = (const __CFDictionary *)a1[1];
  uint64_t v4 = (std::mutex *)(*a1 + 32);
  std::mutex::lock(v4);
  long long v5 = *(NSObject **)(v2 + 24);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (void *)(v2 + 128);
    if (*(char *)(v2 + 151) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "setAPNs";
    __int16 v10 = 2080;
    uint64_t v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: UI APN(s) update for ICCID:'%s'", buf, 0x16u);
  }
  *(void *)std::string buf = 0;
  sub_100C9DE78((void **)buf, v2, v3, 0);
  sub_100C9D360(v2, *(const __CFDictionary **)buf);
  sub_100057D78((const void **)buf);
  std::mutex::unlock(v4);
  if (a1[5]) {
    sub_1000607A8((uint64_t)(a1 + 2), 1);
  }
  return sub_100C9FF30((uint64_t *)&v8);
}

void sub_100CA00BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  sub_100057D78((const void **)va1);
  std::mutex::unlock(v2);
  sub_100C9FF30((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100CA00F0(uint64_t *a1)
{
  uint64_t v8 = a1;
  uint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  uint64_t v4 = (std::mutex *)(*a1 + 32);
  std::mutex::lock(v4);
  long long v5 = *(NSObject **)(v2 + 24);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (void *)(v2 + 128);
    if (*(char *)(v2 + 151) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "setAttachAPN";
    __int16 v10 = 2080;
    uint64_t v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: UI AttachAPN update for ICCID:'%s'", buf, 0x16u);
  }
  *(void *)std::string buf = 0;
  sub_100C9DE78((void **)buf, v2, 0, v3);
  sub_100C9D360(v2, *(const __CFDictionary **)buf);
  sub_100057D78((const void **)buf);
  std::mutex::unlock(v4);
  if (a1[5]) {
    sub_1000607A8((uint64_t)(a1 + 2), 1);
  }
  return sub_100C9FF30((uint64_t *)&v8);
}

void sub_100CA0224(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  sub_100057D78((const void **)va1);
  std::mutex::unlock(v2);
  sub_100C9FF30((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100CA0258(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10010E020((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_100CA02A8(uint64_t *a1)
{
  uint64_t v4 = a1;
  if (a1[4])
  {
    sub_100C9C318(*a1, (const __CFDictionary **)&v5);
    uint64_t v2 = a1[4];
    if (!v2) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, const void **))(*(void *)v2 + 48))(v2, &v5);
    sub_100057D78(&v5);
  }
  return sub_100CA0258((uint64_t *)&v4);
}

void sub_100CA0330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_100CA0354(void *a1)
{
  uint64_t v6 = a1;
  if (a1[4])
  {
    uint64_t v2 = *a1;
    unint64_t v3 = (std::mutex *)(*a1 + 32);
    std::mutex::lock(v3);
    sub_100058198(&v7, (const void **)(v2 + 120));
    std::mutex::unlock(v3);
    uint64_t v4 = a1[4];
    if (!v4) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, const void **))(*(void *)v4 + 48))(v4, &v7);
    sub_100057D78(&v7);
  }
  return sub_100CA0258((uint64_t *)&v6);
}

void sub_100CA03FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100CA0420(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A4DE58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100CA0440(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A4DE58;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100CA0494(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

const char *sub_100CA04BC(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  uint64_t v2 = "cb-apn.?";
  if (v1 == 2) {
    uint64_t v2 = "cb-apn.2";
  }
  if (v1 == 1) {
    return "cb-apn.1";
  }
  else {
    return v2;
  }
}

uint64_t sub_100CA04EC(uint64_t a1)
{
  *(void *)a1 = off_101A4DEA8;
  if (*(unsigned char *)(a1 + 224))
  {
    long long v5 = (void **)(a1 + 200);
    sub_10005CBF0(&v5);
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 192);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(unsigned char *)(a1 + 176))
  {
    long long v5 = (void **)(a1 + 152);
    sub_100702E5C(&v5);
  }
  if (*(unsigned char *)(a1 + 144))
  {
    long long v5 = (void **)(a1 + 120);
    sub_10005CBF0(&v5);
  }
  long long v5 = (void **)(a1 + 96);
  sub_10005CBF0(&v5);
  std::mutex::~mutex((std::mutex *)(a1 + 32));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
  *(void *)a1 = off_101A4D980;
  unint64_t v3 = *(NSObject **)(a1 + 16);
  if (v3) {
    dispatch_release(v3);
  }
  return a1;
}

void sub_100CA05D0(uint64_t a1)
{
  sub_100CA04EC(a1);

  operator delete();
}

uint64_t sub_100CA060C(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  uint64_t v3 = (uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 4;
  std::mutex::unlock(v2);
  return v3;
}

void sub_100CA0650(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  uint64_t v3 = (os_log_t *)(a1 + 24);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I DATA:: CB_APN_Storage:", buf, 2u);
    uint64_t v4 = *v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 4;
    *(_DWORD *)std::string buf = 134217984;
    unint64_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t %lu APN(s) found", buf, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 96);
  if (*(void *)(a1 + 104) != v6)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = *v3;
      if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        unint64_t v17 = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t APNx%zu:", buf, 0xCu);
        uint64_t v6 = *(void *)(a1 + 96);
      }
      sub_100C97150(*(void *)(v6 + v7), (os_log_t *)(a1 + 24));
      ++v8;
      uint64_t v6 = *(void *)(a1 + 96);
      v7 += 16;
    }
    while (v8 < (*(void *)(a1 + 104) - v6) >> 4);
  }
  if (*(unsigned char *)(a1 + 144))
  {
    __int16 v10 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = (uint64_t)(*(void *)(a1 + 128) - *(void *)(a1 + 120)) >> 4;
      *(_DWORD *)std::string buf = 134217984;
      unint64_t v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t %lu FallbackAPN(s) found", buf, 0xCu);
      if (!*(unsigned char *)(a1 + 144)) {
LABEL_19:
      }
        sub_10016C840();
    }
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = *(void *)(a1 + 120);
      if (v13 >= (*(void *)(a1 + 128) - v14) >> 4) {
        break;
      }
      uint64_t v15 = *v3;
      if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        unint64_t v17 = v13;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t FallbackAPNx%zu:", buf, 0xCu);
        if (!*(unsigned char *)(a1 + 144)) {
          goto LABEL_19;
        }
        uint64_t v14 = *(void *)(a1 + 120);
      }
      sub_100C97150(*(void *)(v14 + v12), (os_log_t *)(a1 + 24));
      ++v13;
      v12 += 16;
      if (!*(unsigned char *)(a1 + 144)) {
        goto LABEL_19;
      }
    }
  }
  std::mutex::unlock(v2);
}

void sub_100CA08F8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_100CA0914(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  int v3 = a1 + 96;
  sub_10019E028((uint64_t *)(a1 + 96));
  uint64_t v4 = a1 + 120;
  if (*(unsigned char *)(a1 + 144))
  {
    *(void *)std::string buf = a1 + 120;
    sub_10005CBF0((void ***)buf);
    *(unsigned char *)(a1 + 144) = 0;
  }
  uint64_t v5 = (uint64_t *)*(unsigned __int8 *)(a1 + 176);
  if (*(unsigned char *)(a1 + 176))
  {
    *(void *)std::string buf = a1 + 152;
    sub_100702E5C((void ***)buf);
    *(unsigned char *)(a1 + 176) = 0;
  }
  int v81 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v80 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 184));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unint64_t v13 = 0;
  char v15 = 1;
LABEL_13:
  (*(void (**)(void ***__return_ptr, uint64_t, void))(*(void *)v14 + 192))(&ValueAtIndex, v14, *(unsigned int *)(a1 + 8));
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  uint64_t v80 = *(void *)&buf[16];
  sub_1000558F4((const void **)&ValueAtIndex);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  long long v16 = (os_log_t *)(a1 + 24);
  unint64_t v17 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    long long v19 = __p;
    if (v80 < 0) {
      long long v19 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "refresh";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: reading APNs from: %s", buf, 0x16u);
  }
  CFArrayRef v78 = 0;
  long long v20 = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)(a1 + 184));
  long long v21 = v20;
  uint64_t v23 = v22;
  if (v22 < 0)
  {
    long long v24 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v25 = 5381;
    do
    {
      uint64_t v23 = v25;
      unsigned int v26 = *v24++;
      uint64_t v25 = (33 * v25) ^ v26;
    }
    while (v26);
  }
  std::mutex::lock(v20);
  *(void *)std::string buf = v23;
  unsigned int v27 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)buf);
  if (v27)
  {
    uint64_t v29 = v27[3];
    CFNumberRef v28 = (std::__shared_weak_count *)v27[4];
    if (v28)
    {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v21);
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v4 = a1 + 120;
      int v3 = a1 + 96;
      sub_10004D2C8(v28);
      char v30 = 0;
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v29 = 0;
  }
  std::mutex::unlock(v21);
  CFNumberRef v28 = 0;
  char v30 = 1;
LABEL_27:
  (*(void (**)(void ***__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v29 + 80))(&ValueAtIndex, v29, *(unsigned int *)(a1 + 8), 1, @"apns", 0, 0);
  sub_100044D6C(&v78, (CFTypeRef *)&ValueAtIndex);
  sub_1000577C4((const void **)&ValueAtIndex);
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  CFArrayRef theArray = 0;
  long long v32 = (std::mutex *)Registry::getServiceMap(v31, *(Registry **)(a1 + 184));
  long long v33 = v32;
  if (v22 < 0)
  {
    long long v34 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v35 = 5381;
    do
    {
      uint64_t v22 = v35;
      unsigned int v36 = *v34++;
      uint64_t v35 = (33 * v35) ^ v36;
    }
    while (v36);
  }
  std::mutex::lock(v32);
  *(void *)std::string buf = v22;
  long long v37 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)buf);
  if (v37)
  {
    uint64_t v39 = v37[3];
    long long v38 = (std::__shared_weak_count *)v37[4];
    if (v38)
    {
      atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v33);
      atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v38);
      char v40 = 0;
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v39 = 0;
  }
  std::mutex::unlock(v33);
  long long v38 = 0;
  char v40 = 1;
LABEL_37:
  (*(void (**)(void ***__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v39 + 80))(&ValueAtIndex, v39, *(unsigned int *)(a1 + 8), 1, @"fallback-apns", 0, 0);
  sub_100044D6C(&theArray, (CFTypeRef *)&ValueAtIndex);
  sub_1000577C4((const void **)&ValueAtIndex);
  if ((v40 & 1) == 0) {
    sub_10004D2C8(v38);
  }
  if (theArray) {
    long long v41 = sub_100083F10;
  }
  else {
    long long v41 = 0;
  }
  if (v41 && CFArrayGetCount(theArray))
  {
    os_log_t v42 = *v16;
    if (!os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_53;
    }
    int v43 = SHIBYTE(v80);
    uint64_t v44 = (void **)__p[0];
    int Count = CFArrayGetCount(theArray);
    __int16 v46 = __p;
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = "refresh";
    if (v43 < 0) {
      __int16 v46 = v44;
    }
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v46;
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v84 = Count;
    uint64_t v47 = "#I %s: Fallback APNS in %s: count %d";
    char v48 = v42;
    uint32_t v49 = 28;
  }
  else
  {
    os_log_t v50 = *v16;
    if (!os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_53;
    }
    uint64_t v51 = __p;
    if (v80 < 0) {
      uint64_t v51 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "refresh";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v51;
    uint64_t v47 = "#I %s: No Fallback APNS in %s";
    char v48 = v50;
    uint32_t v49 = 22;
  }
  _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, v47, buf, v49);
LABEL_53:
  if (v78) {
    __int16 v52 = sub_100083F10;
  }
  else {
    __int16 v52 = 0;
  }
  if (v52 && CFArrayGetCount(v78))
  {
    *(void *)std::string buf = 0;
    CFTypeRef ValueAtIndex = (void **)CFArrayGetValueAtIndex(v78, 0);
    sub_10004EFE4(buf, (CFTypeRef *)&ValueAtIndex);
    if (*(void *)buf) {
      long long v53 = sub_100080778;
    }
    else {
      long long v53 = 0;
    }
    BOOL v54 = v53
       && (!CFDictionaryContainsKey(*(CFDictionaryRef *)buf, @"configuration")
        || !CFDictionaryContainsKey(*(CFDictionaryRef *)buf, @"technology-mask"));
    sub_100057D78((const void **)buf);
    BOOL v57 = sub_100C936EC(v78, @"technology-mask");
    if (v54)
    {
      int v76 = 236;
      sub_100CA1B54(a1, v3, v78, 3, (uint64_t)&v76, &v81);
      int v75 = 236;
      sub_100CA1CE4(a1, (WirelessTechnologyList *)&v75);
      if (theArray) {
        unint64_t v58 = sub_100083F10;
      }
      else {
        unint64_t v58 = 0;
      }
      if (v58)
      {
        memset(buf, 0, sizeof(buf));
        sub_100CA2DBC(v4, (uint64_t)buf);
        CFTypeRef ValueAtIndex = (void **)buf;
        sub_10005CBF0(&ValueAtIndex);
        if (!*(unsigned char *)(a1 + 144)) {
          sub_10016C840();
        }
        int v74 = 236;
        sub_100CA1B54(a1, v4, theArray, 3, (uint64_t)&v74, &v81);
      }
    }
    else
    {
      int v59 = v57;
      *(void *)std::string buf = v78;
      sub_100CA2E38(a1, (uint64_t *)__p, v57, &v81, (CFArrayRef *)buf, v3, (CFIndex)"", &v73, 1);
      if (theArray) {
        unint64_t v60 = sub_100083F10;
      }
      else {
        unint64_t v60 = 0;
      }
      if (v60)
      {
        memset(buf, 0, sizeof(buf));
        sub_100CA2DBC(v4, (uint64_t)buf);
        CFTypeRef ValueAtIndex = (void **)buf;
        sub_10005CBF0(&ValueAtIndex);
        *(void *)std::string buf = theArray;
        if (!*(unsigned char *)(a1 + 144)) {
          sub_10016C840();
        }
        sub_100CA2E38(a1, (uint64_t *)__p, v59, &v81, (CFArrayRef *)buf, v4, (CFIndex)"Fallback ", &v73, 0);
      }
    }
  }
  else
  {
    uint64_t v55 = *v16;
    if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v56 = __p;
      if (v80 < 0) {
        uint64_t v56 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "refresh";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v56;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I %s: No APNS in %s", buf, 0x16u);
    }
  }
  uint64_t v61 = *v16;
  if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v62 = (uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 4;
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "refresh";
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v62;
    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I %s: %zu APN(s) in CB ==>> ", buf, 0x16u);
  }
  uint64_t v63 = *(void *)(a1 + 96);
  if (*(void *)(a1 + 104) != v63)
  {
    uint64_t v64 = 0;
    unint64_t v65 = 0;
    do
    {
      sub_100C97DFC(*(void *)(v63 + v64), (os_log_t *)(a1 + 24), (uint64_t)"");
      ++v65;
      uint64_t v63 = *(void *)(a1 + 96);
      v64 += 16;
    }
    while (v65 < (*(void *)(a1 + 104) - v63) >> 4);
  }
  unint64_t v66 = *v16;
  if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "refresh";
    _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I %s: <<== APN(s)", buf, 0xCu);
  }
  if (*(unsigned char *)(a1 + 144))
  {
    uint64_t v67 = *v16;
    if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v68 = (uint64_t)(*(void *)(a1 + 128) - *(void *)(a1 + 120)) >> 4;
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "refresh";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v68;
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I %s: %zu Fallback APN(s) in CB ==>> ", buf, 0x16u);
      if (!*(unsigned char *)(a1 + 144)) {
LABEL_96:
      }
        sub_10016C840();
    }
    uint64_t v69 = 0;
    uint64_t v70 = -1;
    while (1)
    {
      uint64_t v71 = *(void *)(a1 + 120);
      if (++v70 >= (unint64_t)((*(void *)(a1 + 128) - v71) >> 4)) {
        break;
      }
      sub_100C97DFC(*(void *)(v71 + v69), (os_log_t *)(a1 + 24), (uint64_t)"");
      v69 += 16;
      if (!*(unsigned char *)(a1 + 144)) {
        goto LABEL_96;
      }
    }
    int v72 = *v16;
    if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "refresh";
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I %s: <<== Fallback APN(s)", buf, 0xCu);
    }
  }
  sub_100044D00((const void **)&theArray);
  sub_100044D00((const void **)&v78);
  if (SHIBYTE(v80) < 0) {
    operator delete(__p[0]);
  }
  std::mutex::unlock(v2);
}

void sub_100CA135C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  sub_100044D00(&a11);
  sub_100044D00(&a12);
  if (a18 < 0) {
    operator delete(__p);
  }
  std::mutex::unlock(v27);
  _Unwind_Resume(a1);
}

void sub_100CA1470(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, _OWORD *a5@<X8>)
{
  uint64_t v10 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  sub_100CA3248(&v11, a1, a2, a3, a4, 1);
  *a5 = v11;

  std::mutex::unlock(v10);
}

void sub_100CA14FC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100CA1510(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 96);
  uint64_t v4 = *(void *)(a1 + 104) - v3;
  if (v4)
  {
    unint64_t v5 = v4 >> 4;
    if (v5 <= 1) {
      unint64_t v5 = 1;
    }
    while (1)
    {
      int v6 = *(_DWORD *)(*(void *)v3 + 188);
      if ((v6 & 4) == 0) {
        break;
      }
      v3 += 16;
      if (!--v5) {
        goto LABEL_6;
      }
    }
    if ((v6 & 8) != 0)
    {
      uint64_t v7 = 8;
    }
    else if ((v6 & 0x20) != 0)
    {
      uint64_t v7 = 32;
    }
    else if ((v6 & 0x40) != 0)
    {
      uint64_t v7 = 64;
    }
    else if ((v6 & 0x80) != 0)
    {
      uint64_t v7 = 128;
    }
    else
    {
      uint64_t v7 = 4;
    }
  }
  else
  {
LABEL_6:
    uint64_t v7 = 4;
  }
  std::mutex::unlock(v2);
  return v7;
}

uint64_t sub_100CA15B4(uint64_t a1, uint64_t *a2, __int32 a3)
{
  uint64_t result = 0;
  if (!a3 || !*a2) {
    return result;
  }
  if (!*(unsigned char *)(a1 + 144)) {
    return 0;
  }
  uint64_t v7 = *(const std::string ***)(a1 + 120);
  uint64_t v8 = *(const std::string ***)(a1 + 128);
  if (v7 == v8)
  {
LABEL_14:
    int v13 = 0;
    return v13 & v3;
  }
  while (1)
  {
    if (sub_100CA3618((unsigned __int8 *)&(*v7)[11].__r_.__value_.__s.__data_[16], (unsigned __int8 *)(*a2 + 48)))
    {
      uint64_t v10 = *v7;
      LODWORD(v3) = *(_DWORD *)(*a2 + 188);
      if (HIDWORD((*v7)[7].__r_.__value_.__r.__words[2]) == v3)
      {
        LODWORD(v3) = v10[14].__r_.__value_.__s.__data_[0];
        if (v10[14].__r_.__value_.__s.__data_[0])
        {
          std::string::size_type size = (__int32 *)v10[13].__r_.__value_.__l.__size_;
          uint64_t v12 = wmemchr((__int32 *)v10[13].__r_.__value_.__l.__data_, a3, (uint64_t)((uint64_t)size - v10[13].__r_.__value_.__r.__words[0]) >> 2);
          if (!(*v7)[14].__r_.__value_.__s.__data_[0]) {
            goto LABEL_92;
          }
          uint64_t v3 = v12 ? v12 : size;
          if (v3 != (__int32 *)(*v7)[13].__r_.__value_.__l.__size_) {
            break;
          }
        }
      }
    }
    v7 += 2;
    if (v7 == v8) {
      goto LABEL_14;
    }
  }
  uint64_t v14 = (int64x2_t *)(a1 + 152);
  if (!*(unsigned char *)(a1 + 176))
  {
    v55[0] = 0;
    v55[1] = 0;
    uint64_t v56 = 0;
    sub_100CA36C4(a1 + 152, (uint64_t)v55);
    unint64_t v60 = v55;
    sub_100702E5C(&v60);
    if (!*(unsigned char *)(a1 + 176)) {
LABEL_92:
    }
      sub_10016C840();
  }
  uint64_t v15 = *(void *)(a1 + 152);
  uint64_t v16 = *(void *)(a1 + 160);
  uint64_t v17 = *a2;
  uint64_t v18 = *(unsigned __int8 *)(*a2 + 71);
  if (v15 == v16)
  {
LABEL_40:
    long long v24 = *v7;
    if ((v18 & 0x80) != 0)
    {
      sub_10004FC84(v55, *(void **)(v17 + 48), *(void *)(v17 + 56));
    }
    else
    {
      *(_OWORD *)uint64_t v55 = *(_OWORD *)(v17 + 48);
      uint64_t v56 = *(void **)(v17 + 64);
    }
    if (SHIBYTE(v24[2].__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(&__p, v24[2].__r_.__value_.__l.__data_, v24[2].__r_.__value_.__l.__size_);
    }
    else
    {
      long long __p = *(_OWORD *)&v24[2].__r_.__value_.__l.__data_;
      unint64_t v58 = (void *)v24[2].__r_.__value_.__r.__words[2];
    }
    int v25 = *(_DWORD *)(v17 + 188);
    int v59 = v25;
    unint64_t v26 = *(void *)(a1 + 168);
    unint64_t v27 = *(void *)(a1 + 160);
    if (v27 >= v26)
    {
      uint64_t v30 = v14->i64[0];
      uint64_t v31 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v27 - v14->i64[0]) >> 3);
      unint64_t v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) > 0x492492492492492) {
        sub_10006A748();
      }
      if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v26 - v30) >> 3) > v32) {
        unint64_t v32 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v26 - v30) >> 3);
      }
      if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v26 - v30) >> 3)) >= 0x249249249249249) {
        unint64_t v33 = 0x492492492492492;
      }
      else {
        unint64_t v33 = v32;
      }
      uint64_t v63 = a1 + 168;
      if (v33)
      {
        if (v33 > 0x492492492492492) {
          sub_10006A7CC();
        }
        long long v34 = (void **)operator new(56 * v33);
      }
      else
      {
        long long v34 = 0;
      }
      uint64_t v35 = &v34[7 * v31];
      unint64_t v60 = v34;
      v61.i64[0] = (uint64_t)v35;
      *(_OWORD *)uint64_t v35 = *(_OWORD *)v55;
      unsigned int v36 = &v34[7 * v33];
      v35[2] = v56;
      v55[0] = 0;
      v55[1] = 0;
      uint64_t v56 = 0;
      *(_OWORD *)(v35 + 3) = __p;
      v35[5] = v58;
      long long __p = 0uLL;
      unint64_t v58 = 0;
      *((_DWORD *)v35 + 12) = v25;
      long long v37 = v35 + 7;
      v61.i64[1] = (uint64_t)(v35 + 7);
      uint64_t v62 = v36;
      if (v27 == v30)
      {
        int64x2_t v45 = vdupq_n_s64(v27);
      }
      else
      {
        unint64_t v38 = 0;
        do
        {
          uint64_t v39 = &v35[v38 / 8 - 7];
          char v40 = (void **)(v27 + v38 - 56);
          if (*(char *)(v27 + v38 - 33) < 0)
          {
            sub_10004FC84(v39, *v40, *(void *)(v27 + v38 - 48));
          }
          else
          {
            long long v41 = *(_OWORD *)v40;
            v35[v38 / 8 - 5] = *(void **)(v27 + v38 - 40);
            *(_OWORD *)uint64_t v39 = v41;
          }
          os_log_t v42 = &v35[v38 / 8 - 4];
          int v43 = (void **)(v27 + v38 - 32);
          if (*(char *)(v27 + v38 - 9) < 0)
          {
            sub_10004FC84(v42, *v43, *(void *)(v27 + v38 - 24));
          }
          else
          {
            long long v44 = *(_OWORD *)v43;
            v35[v38 / 8 - 2] = *(void **)(v27 + v38 - 16);
            *(_OWORD *)os_log_t v42 = v44;
          }
          LODWORD(v35[v38 / 8 - 1]) = *(_DWORD *)(v27 + v38 - 8);
          v38 -= 56;
        }
        while (v27 + v38 != v30);
        int64x2_t v45 = *v14;
        long long v37 = (void **)v61.i64[1];
        unsigned int v36 = v62;
        uint64_t v35 = (void **)((char *)v35 + v38);
        unint64_t v26 = *(void *)(a1 + 168);
      }
      *(void *)(a1 + 152) = v35;
      *(void *)(a1 + 160) = v37;
      int64x2_t v61 = v45;
      *(void *)(a1 + 168) = v36;
      uint64_t v62 = (void **)v26;
      unint64_t v60 = (void **)v45.i64[0];
      sub_100703144((uint64_t)&v60);
      int v46 = SHIBYTE(v58);
      *(void *)(a1 + 160) = v37;
      if (v46 < 0) {
        operator delete((void *)__p);
      }
    }
    else
    {
      long long v28 = *(_OWORD *)v55;
      *(void *)(v27 + 16) = v56;
      *(_OWORD *)unint64_t v27 = v28;
      v55[1] = 0;
      uint64_t v56 = 0;
      v55[0] = 0;
      uint64_t v29 = v58;
      *(_OWORD *)(v27 + 24) = __p;
      *(void *)(v27 + 40) = v29;
      unint64_t v58 = 0;
      long long __p = 0uLL;
      *(_DWORD *)(v27 + 48) = v59;
      *(void *)(a1 + 160) = v27 + 56;
    }
    if (SHIBYTE(v56) < 0) {
      operator delete(v55[0]);
    }
    goto LABEL_90;
  }
  if ((v18 & 0x80u) == 0) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = *(void *)(v17 + 56);
  }
  while (1)
  {
    uint64_t v20 = *(unsigned __int8 *)(v15 + 23);
    if ((v20 & 0x80u) == 0) {
      uint64_t v21 = *(unsigned __int8 *)(v15 + 23);
    }
    else {
      uint64_t v21 = *(void *)(v15 + 8);
    }
    if (v21 != v19) {
      goto LABEL_39;
    }
    uint64_t v22 = (v18 & 0x80u) == 0 ? (unsigned __int8 *)(v17 + 48) : *(unsigned __int8 **)(v17 + 48);
    if ((v20 & 0x80) == 0) {
      break;
    }
    if (!memcmp(*(const void **)v15, v22, *(void *)(v15 + 8))) {
      goto LABEL_38;
    }
LABEL_39:
    v15 += 56;
    if (v15 == v16) {
      goto LABEL_40;
    }
  }
  if (*(unsigned char *)(v15 + 23))
  {
    uint64_t v23 = 0;
    while (*(unsigned __int8 *)(v15 + v23) == v22[v23])
    {
      if (v20 == ++v23) {
        goto LABEL_38;
      }
    }
    goto LABEL_39;
  }
LABEL_38:
  if (*(_DWORD *)(v15 + 48) != *(_DWORD *)(v17 + 188)) {
    goto LABEL_39;
  }
  uint64_t v47 = *v7;
  char v48 = *v7 + 2;
  uint64_t v49 = *(unsigned __int8 *)(v15 + 47);
  if ((v49 & 0x80u) == 0) {
    uint64_t v50 = *(unsigned __int8 *)(v15 + 47);
  }
  else {
    uint64_t v50 = *(void *)(v15 + 32);
  }
  std::string::size_type v51 = HIBYTE(v47[2].__r_.__value_.__r.__words[2]);
  std::string::size_type v52 = v47[2].__r_.__value_.__l.__size_;
  if ((v51 & 0x80u) == 0) {
    std::string::size_type v52 = v51;
  }
  if (v50 != v52) {
    goto LABEL_89;
  }
  if ((v51 & 0x80u) == 0) {
    long long v53 = *v7 + 2;
  }
  else {
    long long v53 = (const std::string *)v48->__r_.__value_.__r.__words[0];
  }
  if ((v49 & 0x80) != 0)
  {
    if (memcmp(*(const void **)(v15 + 24), v53, *(void *)(v15 + 32))) {
      goto LABEL_89;
    }
    goto LABEL_91;
  }
  if (!*(unsigned char *)(v15 + 47))
  {
LABEL_91:
    LODWORD(v3) = 0;
    int v13 = 1;
    return v13 & v3;
  }
  uint64_t v54 = 0;
  while (*(unsigned __int8 *)(v15 + v54 + 24) == v53->__r_.__value_.__s.__data_[v54])
  {
    LODWORD(v3) = 0;
    ++v54;
    int v13 = 1;
    if (v49 == v54) {
      return v13 & v3;
    }
  }
LABEL_89:
  std::string::operator=((std::string *)(v15 + 24), v48);
LABEL_90:
  int v13 = 1;
  LODWORD(v3) = 1;
  return v13 & v3;
}

void sub_100CA1AE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CA1B54(int a1, int a2, CFArrayRef theArray, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  if (theArray && CFArrayGetCount(theArray) >= 1)
  {
    uint64_t v10 = 0;
    v9[0] = CFArrayGetValueAtIndex(theArray, 0);
    sub_10004EFE4(&v10, v9);
    if (v10) {
      uint64_t v8 = sub_100080778;
    }
    else {
      uint64_t v8 = 0;
    }
    if (!v8) {
      __TUAssertTrigger();
    }
    v9[0] = 0;
    v9[1] = 0;
    ++*a6;
    sub_100BBEC88(v9);
  }
}

void sub_100CA1CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100CA1CE4(uint64_t a1, WirelessTechnologyList *a2)
{
  uint64_t v2 = (int *)a2;
  uint64_t v4 = (uint64_t *)*(unsigned __int8 *)(a1 + 224);
  if (!*(unsigned char *)(a1 + 224))
  {
    long long __p = 0;
    uint64_t v126 = 0;
    uint64_t v127 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 184));
    int v6 = ServiceMap;
    if (v7 < 0)
    {
      uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        uint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v7;
    long long v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
LABEL_10:
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 56))(&__p, v13, 4, 1);
    if ((v14 & 1) == 0) {
      sub_10004D2C8(v12);
    }
    uint64_t v15 = HIBYTE(v127);
    if (v127 < 0) {
      uint64_t v15 = v126;
    }
    if (!v15)
    {
      uint64_t v30 = *(NSObject **)(a1 + 24);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = "readDefaultBundleApns";
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s: Default bundle not yet settled", buf, 0xCu);
      }
      goto LABEL_73;
    }
    memset(buf, 0, sizeof(buf));
    sub_100CA2DBC(a1 + 200, (uint64_t)buf);
    CFArrayRef theArray = (CFArrayRef)buf;
    sub_10005CBF0((void ***)&theArray);
    uint64_t v16 = (os_log_t *)(a1 + 24);
    uint64_t v17 = *(NSObject **)(a1 + 24);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      p_p = &__p;
      if (v127 < 0) {
        p_p = __p;
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "readDefaultBundleApns";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: reading default APNs from: %s", buf, 0x16u);
    }
    CFArrayRef theArray = 0;
    uint64_t v20 = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)(a1 + 184));
    uint64_t v21 = v20;
    if (v22 < 0)
    {
      uint64_t v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v24 = 5381;
      do
      {
        uint64_t v22 = v24;
        unsigned int v25 = *v23++;
        uint64_t v24 = (33 * v24) ^ v25;
      }
      while (v25);
    }
    std::mutex::lock(v20);
    *(void *)std::string buf = v22;
    unint64_t v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)buf);
    if (v26)
    {
      uint64_t v28 = v26[3];
      unint64_t v27 = (std::__shared_weak_count *)v26[4];
      if (v27)
      {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v21);
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v27);
        char v29 = 0;
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v28 = 0;
    }
    std::mutex::unlock(v21);
    unint64_t v27 = 0;
    char v29 = 1;
LABEL_29:
    (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v28 + 80))(&theDict, v28, 1, 4, @"apns", 0, 0);
    sub_100044D6C(&theArray, (CFTypeRef *)&theDict);
    sub_1000577C4((const void **)&theDict);
    if ((v29 & 1) == 0) {
      sub_10004D2C8(v27);
    }
    if (theArray) {
      uint64_t v31 = sub_100083F10;
    }
    else {
      uint64_t v31 = 0;
    }
    if (v31 && (CFIndex Count = CFArrayGetCount(theArray)) != 0)
    {
      unint64_t v33 = *v16;
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
      {
        long long v34 = &__p;
        if (v127 < 0) {
          long long v34 = __p;
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = "readDefaultBundleApns";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = Count;
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v129 = v34;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s: Found %zu set(s) of APNS in %s", buf, 0x20u);
      }
      BOOL v35 = sub_100C936EC(theArray, @"technology-mask");
      int v124 = 0;
      if (Count >= 1)
      {
        CFIndex v36 = 0;
        if (v35) {
          int v37 = 224;
        }
        else {
          int v37 = 32;
        }
        do
        {
          CFDictionaryRef theDict = 0;
          *(void *)std::string buf = CFArrayGetValueAtIndex(theArray, v36);
          sub_10004EFE4(&theDict, (CFTypeRef *)buf);
          CFDictionaryRef v38 = theDict;
          if (theDict) {
            uint64_t v39 = sub_100080778;
          }
          else {
            uint64_t v39 = 0;
          }
          if (!v39)
          {
            __TUAssertTrigger();
            CFDictionaryRef v38 = theDict;
          }
          CFNumberRef number = 0;
          *(void *)std::string buf = CFDictionaryGetValue(v38, @"technology-mask");
          sub_1000842D0(&number, (CFTypeRef *)buf);
          if (number) {
            char v40 = sub_100081E58;
          }
          else {
            char v40 = 0;
          }
          if (v40)
          {
            int valuePtr = 0;
            CFNumberGetValue(number, kCFNumberIntType, &valuePtr);
            if ((valuePtr & 0x10) != 0) {
              int v41 = v37 & (valuePtr << 28 >> 31) | (4 * (valuePtr & 3)) | 0xC0;
            }
            else {
              int v41 = v37 & (valuePtr << 28 >> 31) | (4 * (valuePtr & 3));
            }
            *(void *)std::string buf = 0;
            CFTypeRef Value = CFDictionaryGetValue(theDict, @"configuration");
            sub_100044D6C(buf, &Value);
            int v120 = v41;
            sub_100CA1B54(a1, a1 + 200, *(CFArrayRef *)buf, 5, (uint64_t)&v120, &v124);
            sub_100044D00((const void **)buf);
          }
          else
          {
            os_log_t v42 = *v16;
            if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = "readDefaultBundleApns";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v36;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %s: No technology mask for default APN configuration %ld, - ignore whole section", buf, 0x16u);
            }
          }
          sub_1000570E8((const void **)&number);
          sub_100057D78((const void **)&theDict);
          ++v36;
          uint64_t v2 = (int *)a2;
        }
        while (Count != v36);
      }
      int v43 = *v16;
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v44 = (uint64_t)(*(void *)(a1 + 208) - *(void *)(a1 + 200)) >> 4;
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = "readDefaultBundleApns";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v44;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I %s: %zu APN(s) in default bundle ==>> ", buf, 0x16u);
      }
      uint64_t v45 = *(void *)(a1 + 200);
      if (*(void *)(a1 + 208) != v45)
      {
        uint64_t v46 = 0;
        unint64_t v47 = 0;
        do
        {
          sub_100C97DFC(*(void *)(v45 + v46), (os_log_t *)(a1 + 24), (uint64_t)"");
          ++v47;
          uint64_t v45 = *(void *)(a1 + 200);
          v46 += 16;
        }
        while (v47 < (*(void *)(a1 + 208) - v45) >> 4);
      }
      char v48 = *v16;
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_72;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "readDefaultBundleApns";
      uint64_t v49 = "#I %s: <<== APN(s)";
      uint64_t v50 = v48;
      uint32_t v51 = 12;
    }
    else
    {
      std::string::size_type v52 = *v16;
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
LABEL_72:
        sub_100044D00((const void **)&theArray);
LABEL_73:
        if (SHIBYTE(v127) < 0) {
          operator delete(__p);
        }
        goto LABEL_75;
      }
      long long v53 = &__p;
      if (v127 < 0) {
        long long v53 = __p;
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "readDefaultBundleApns";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v53;
      uint64_t v49 = "#I %s: No default APNS in %s";
      uint64_t v50 = v52;
      uint32_t v51 = 22;
    }
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v49, buf, v51);
    goto LABEL_72;
  }
LABEL_75:
  unint64_t v54 = 2;
  do
  {
    CFArrayRef theArray = 0;
    unint64_t v119 = 0;
    sub_100CA3248(&theArray, a1, v54, *v2, 0, 1);
    int v55 = *v2;
    if (!*(unsigned char *)(a1 + 224)) {
      goto LABEL_85;
    }
    uint64_t v56 = *(void **)(a1 + 200);
    BOOL v57 = *(void **)(a1 + 208);
    if (v56 != v57)
    {
      while ((*(_DWORD *)(*v56 + 188) & v55) == 0 || (*(void *)(*v56 + 152) & v54) == 0)
      {
        v56 += 2;
        if (v56 == v57) {
          goto LABEL_85;
        }
      }
    }
    if (v56 == v57)
    {
LABEL_85:
      uint64_t v58 = 0;
      int v59 = 0;
    }
    else
    {
      uint64_t v58 = *v56;
      int v59 = (std::__shared_weak_count *)v56[1];
      if (v59)
      {
        atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
        int v55 = *v2;
      }
    }
    CFDictionaryRef theDict = 0;
    unint64_t v117 = 0;
    sub_100CA3248(&theDict, a1, v54, v55, 1, 0);
    CFArrayRef v60 = theArray;
    if (theArray)
    {
      if (!theDict && v58 && (*(void *)(v58 + 160) & v54) != 0)
      {
        int64x2_t v61 = *(NSObject **)(a1 + 24);
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v62 = (void *)(v58 + 48);
          if (*(char *)(v58 + 71) < 0) {
            uint64_t v62 = (void *)*v62;
          }
          unsigned int v63 = *(_DWORD *)(v58 + 144) - 1;
          uint64_t v64 = "UI";
          if (v63 <= 4) {
            uint64_t v64 = off_101A4DF50[v63];
          }
          int v65 = *(_DWORD *)(v58 + 148);
          WirelessTechnologyList::asString((uint64_t *)&__p, (WirelessTechnologyList *)v2);
          unint64_t v66 = __p;
          if (v127 >= 0) {
            unint64_t v66 = &__p;
          }
          uint64_t v67 = (void *)((char *)v60 + 48);
          if (*((char *)v60 + 71) < 0) {
            uint64_t v67 = (void *)*v67;
          }
          *(_DWORD *)std::string buf = 136316674;
          *(void *)&uint8_t buf[4] = "fillMissingApnsFromDefaultBundle";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v54;
          *(_WORD *)&unsigned char buf[22] = 2082;
          uint64_t v129 = v62;
          __int16 v130 = 2080;
          long long v131 = v64;
          __int16 v132 = 1024;
          int v133 = v65;
          __int16 v134 = 2082;
          __int16 v135 = v66;
          __int16 v136 = 2082;
          uint64_t v137 = v67;
          _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I %s: Service 0x%llx: merging tech-type-mask of APN '%{public}s' (%s.%d) from default bundle for %{public}s into %{public}s", buf, 0x44u);
          if (SHIBYTE(v127) < 0) {
            operator delete(__p);
          }
        }
        *((void *)v60 + 20) |= v54;
        *((unsigned char *)v60 + 193) = *(unsigned char *)(v58 + 193);
      }
      goto LABEL_212;
    }
    if (!v58) {
      goto LABEL_212;
    }
    int v68 = *v2;
    uint64_t v69 = (uint64_t *)(v58 + 48);
    uint64_t v70 = *(void **)(a1 + 96);
    uint64_t v71 = *(void **)(a1 + 104);
    if (*(char *)(v58 + 71) < 0)
    {
      sub_10004FC84(buf, *(void **)(v58 + 48), *(void *)(v58 + 56));
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)v69;
      *(void *)&uint8_t buf[16] = *(void *)(v58 + 64);
    }
    LODWORD(v129) = v68;
    uint8_t v72 = buf[23];
    if (v70 != v71)
    {
      if ((buf[23] & 0x80u) == 0) {
        uint64_t v73 = buf[23];
      }
      else {
        uint64_t v73 = *(void *)&buf[8];
      }
      if ((buf[23] & 0x80u) == 0) {
        int v74 = buf;
      }
      else {
        int v74 = *(uint8_t **)buf;
      }
      do
      {
        uint64_t v75 = *v70;
        if ((*(_DWORD *)(*v70 + 188) & v68) != 0)
        {
          uint64_t v76 = *(unsigned __int8 *)(v75 + 71);
          size_t v77 = *(void *)(v75 + 56);
          uint64_t v78 = (v76 & 0x80u) == 0 ? *(unsigned __int8 *)(v75 + 71) : *(void *)(v75 + 56);
          if (v78 == v73)
          {
            unint64_t v79 = (const void **)(v75 + 48);
            if ((v76 & 0x80) != 0)
            {
              if (!memcmp(*v79, v74, v77)) {
                goto LABEL_127;
              }
            }
            else
            {
              if (!v76) {
                goto LABEL_127;
              }
              uint64_t v80 = v74;
              while (*(unsigned __int8 *)v79 == *v80)
              {
                unint64_t v79 = (const void **)((char *)v79 + 1);
                ++v80;
                if (!--v76) {
                  goto LABEL_127;
                }
              }
            }
          }
        }
        v70 += 2;
      }
      while (v70 != v71);
      uint64_t v70 = v71;
LABEL_127:
      uint64_t v69 = (uint64_t *)(v58 + 48);
    }
    if ((v72 & 0x80) != 0) {
      operator delete(*(void **)buf);
    }
    if (v70 == *(void **)(a1 + 104))
    {
      int v81 = 0;
    }
    else
    {
      uint64_t v82 = *v70;
      int v81 = (std::__shared_weak_count *)v70[1];
      if (v81) {
        atomic_fetch_add_explicit(&v81->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v82)
      {
        int v83 = v81;
        goto LABEL_169;
      }
      uint64_t v70 = *(void **)(a1 + 104);
    }
    int v84 = *(void **)(a1 + 96);
    if (*(char *)(v58 + 71) < 0)
    {
      sub_10004FC84(buf, *(void **)(v58 + 48), *(void *)(v58 + 56));
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)v69;
      *(void *)&uint8_t buf[16] = v69[2];
    }
    uint8_t v85 = buf[23];
    if (v84 == v70) {
      goto LABEL_162;
    }
    if ((buf[23] & 0x80u) == 0) {
      uint64_t v86 = buf[23];
    }
    else {
      uint64_t v86 = *(void *)&buf[8];
    }
    if ((buf[23] & 0x80u) == 0) {
      uint64_t v87 = buf;
    }
    else {
      uint64_t v87 = *(uint8_t **)buf;
    }
    while (1)
    {
      uint64_t v88 = *(unsigned __int8 *)(*v84 + 71);
      if ((v88 & 0x80u) == 0) {
        uint64_t v89 = *(unsigned __int8 *)(*v84 + 71);
      }
      else {
        uint64_t v89 = *(void *)(*v84 + 56);
      }
      if (v89 != v86) {
        goto LABEL_158;
      }
      uint64_t v90 = (const void **)(*v84 + 48);
      if ((v88 & 0x80) != 0) {
        break;
      }
      if (!*(unsigned char *)(*v84 + 71)) {
        goto LABEL_160;
      }
      unint64_t v91 = v87;
      while (*(unsigned __int8 *)v90 == *v91)
      {
        uint64_t v90 = (const void **)((char *)v90 + 1);
        ++v91;
        if (!--v88) {
          goto LABEL_160;
        }
      }
LABEL_158:
      v84 += 2;
      if (v84 == v70) {
        goto LABEL_161;
      }
    }
    if (memcmp(*v90, v87, *(void *)(*v84 + 56))) {
      goto LABEL_158;
    }
LABEL_160:
    uint64_t v70 = v84;
LABEL_161:
    uint64_t v69 = (uint64_t *)(v58 + 48);
LABEL_162:
    if ((v85 & 0x80) != 0) {
      operator delete(*(void **)buf);
    }
    if (v70 == *(void **)(a1 + 104))
    {
      uint64_t v82 = 0;
      int v83 = 0;
      if (v81) {
        goto LABEL_168;
      }
    }
    else
    {
      uint64_t v82 = *v70;
      int v83 = (std::__shared_weak_count *)v70[1];
      if (v83) {
        atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v81) {
LABEL_168:
      }
        sub_10004D2C8(v81);
    }
LABEL_169:
    CFDictionaryRef v92 = theDict;
    if (theDict)
    {
      int v93 = *(NSObject **)(a1 + 24);
      uint64_t v2 = (int *)a2;
      if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
      {
        char v114 = v83;
        if (*(char *)(v58 + 71) < 0) {
          uint64_t v69 = (uint64_t *)*v69;
        }
        uint64_t v94 = v69;
        unsigned int v95 = *(_DWORD *)(v58 + 144) - 1;
        int v96 = "UI";
        if (v95 <= 4) {
          int v96 = off_101A4DF50[v95];
        }
        int v97 = *(_DWORD *)(v58 + 148);
        WirelessTechnologyList::asString((uint64_t *)&__p, a2);
        int v98 = __p;
        if (v127 >= 0) {
          int v98 = &__p;
        }
        int v99 = (void *)((char *)v92 + 48);
        if (*((char *)v92 + 71) < 0) {
          int v99 = (void *)*v99;
        }
        *(_DWORD *)std::string buf = 136316674;
        *(void *)&uint8_t buf[4] = "fillMissingApnsFromDefaultBundle";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v54;
        *(_WORD *)&unsigned char buf[22] = 2082;
        uint64_t v129 = v94;
        __int16 v130 = 2080;
        long long v131 = v96;
        __int16 v132 = 1024;
        int v133 = v97;
        __int16 v134 = 2082;
        __int16 v135 = v98;
        __int16 v136 = 2082;
        uint64_t v137 = v99;
        _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#I %s: Service 0x%llx: merging type-mask of APN '%{public}s' (%s.%d) from default bundle for %{public}s into %{public}s", buf, 0x44u);
        if (SHIBYTE(v127) < 0) {
          operator delete(__p);
        }
        int v83 = v114;
      }
      *((void *)v92 + 19) |= v54;
    }
    else
    {
      int v100 = *(NSObject **)(a1 + 24);
      BOOL v101 = os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT);
      if (!v82)
      {
        if (v101)
        {
          if (*(char *)(v58 + 71) < 0) {
            uint64_t v69 = (uint64_t *)*v69;
          }
          unint64_t v108 = v69;
          unsigned int v109 = *(_DWORD *)(v58 + 144) - 1;
          unint64_t v110 = "UI";
          if (v109 <= 4) {
            unint64_t v110 = off_101A4DF50[v109];
          }
          int v111 = *(_DWORD *)(v58 + 148);
          WirelessTechnologyList::asString((uint64_t *)&__p, a2);
          long long v112 = &__p;
          if (v127 < 0) {
            long long v112 = __p;
          }
          *(_DWORD *)std::string buf = 136316418;
          *(void *)&uint8_t buf[4] = "fillMissingApnsFromDefaultBundle";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v54;
          *(_WORD *)&unsigned char buf[22] = 2082;
          uint64_t v129 = v108;
          __int16 v130 = 2080;
          long long v131 = v110;
          __int16 v132 = 1024;
          int v133 = v111;
          __int16 v134 = 2082;
          __int16 v135 = v112;
          _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I %s: Service 0x%llx: using APN '%{public}s' (%s.%d) from default bundle for %{public}s", buf, 0x3Au);
          if (SHIBYTE(v127) < 0) {
            operator delete(__p);
          }
        }
        *(void *)std::string buf = 0;
        *(void *)&buf[8] = 0;
        sub_100BBEBF8();
      }
      if (v101)
      {
        if (*(char *)(v58 + 71) < 0) {
          uint64_t v69 = (uint64_t *)*v69;
        }
        unint64_t v102 = v69;
        unsigned int v103 = *(_DWORD *)(v58 + 144) - 1;
        unint64_t v104 = "UI";
        if (v103 <= 4) {
          unint64_t v104 = off_101A4DF50[v103];
        }
        int v105 = *(_DWORD *)(v58 + 148);
        WirelessTechnologyList::asString((uint64_t *)&__p, a2);
        int v106 = __p;
        if (v127 >= 0) {
          int v106 = &__p;
        }
        uint64_t v107 = (void *)(v82 + 48);
        if (*(char *)(v82 + 71) < 0) {
          uint64_t v107 = (void *)*v107;
        }
        *(_DWORD *)std::string buf = 136316674;
        *(void *)&uint8_t buf[4] = "fillMissingApnsFromDefaultBundle";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v54;
        *(_WORD *)&unsigned char buf[22] = 2082;
        uint64_t v129 = v102;
        __int16 v130 = 2080;
        long long v131 = v104;
        __int16 v132 = 1024;
        int v133 = v105;
        __int16 v134 = 2082;
        __int16 v135 = v106;
        __int16 v136 = 2082;
        uint64_t v137 = v107;
        _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I %s: Service 0x%llx: merging APN of same name '%{public}s' (%s.%d) from default bundle for %{public}s into %{public}s", buf, 0x44u);
        if (SHIBYTE(v127) < 0) {
          operator delete(__p);
        }
      }
      *(void *)(v82 + 152) |= v54;
      if ((*(void *)(v58 + 160) & v54) != 0) {
        *(void *)(v82 + 160) |= v54;
      }
      *(_DWORD *)(v82 + 188) |= *(_DWORD *)a2;
      uint64_t v2 = (int *)a2;
    }
    if (v83) {
      sub_10004D2C8(v83);
    }
LABEL_212:
    if (v117) {
      sub_10004D2C8(v117);
    }
    if (v59) {
      sub_10004D2C8(v59);
    }
    if (v119) {
      sub_10004D2C8(v119);
    }
    unint64_t v113 = v54 >> 35;
    v54 *= 2;
  }
  while (!v113);
}

void sub_100CA2C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,const void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34,uint64_t a35)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CA2DBC(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_10019E074((uint64_t *)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_100CA2E38(uint64_t a1, uint64_t *a2, int a3, _DWORD *a4, CFArrayRef *a5, int a6, CFIndex a7, unsigned char *a8, char a9)
{
  CFIndex Count = CFArrayGetCount(*a5);
  uint64_t v16 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v17 = a2;
    }
    else {
      uint64_t v17 = (uint64_t *)*a2;
    }
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = "readNonLegacyAPNs";
    __int16 v39 = 2048;
    CFIndex v40 = Count;
    __int16 v41 = 2080;
    CFIndex v42 = a7;
    __int16 v43 = 2080;
    uint64_t v44 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: Found %zu set(s) of %sAPNS in %s", buf, 0x2Au);
  }
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFDictionaryRef theDict = 0;
      *(void *)std::string buf = CFArrayGetValueAtIndex(*a5, i);
      sub_10004EFE4(&theDict, (CFTypeRef *)buf);
      CFDictionaryRef v19 = theDict;
      if (theDict) {
        uint64_t v20 = sub_100080778;
      }
      else {
        uint64_t v20 = 0;
      }
      if (!v20)
      {
        __TUAssertTrigger();
        CFDictionaryRef v19 = theDict;
      }
      CFNumberRef number = 0;
      *(void *)std::string buf = CFDictionaryGetValue(v19, @"technology-mask");
      sub_1000842D0(&number, (CFTypeRef *)buf);
      if (number) {
        uint64_t v21 = sub_100081E58;
      }
      else {
        uint64_t v21 = 0;
      }
      if (v21)
      {
        int valuePtr = 0;
        CFNumberGetValue(number, kCFNumberIntType, &valuePtr);
        int v22 = 4 * (valuePtr & 3);
        int v31 = v22;
        int v23 = v22;
        if ((valuePtr & 8) != 0)
        {
          int v23 = v22 | 0x20;
          int v31 = v22 | 0x20;
          if (a3)
          {
            int v23 = v22 | 0xE0;
            int v31 = v22 | 0xE0;
          }
        }
        if ((valuePtr & 0x10) != 0)
        {
          v23 |= 0xC0u;
          int v31 = v23;
        }
        if (*a8 && Count == 1 && (v23 & 0xEC) != 0xEC)
        {
          uint64_t v24 = *(NSObject **)(a1 + 24);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            WirelessTechnologyList::asString((uint64_t *)buf, (WirelessTechnologyList *)&v31);
            unsigned int v25 = buf;
            if (v41 < 0) {
              unsigned int v25 = *(unsigned char **)buf;
            }
            *(_DWORD *)BOOL v35 = 136315394;
            *(void *)&v35[4] = "readNonLegacyAPNs";
            __int16 v36 = 2080;
            int v37 = v25;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s: The only set of APNs is for %s. Reassign it to all technologies.", v35, 0x16u);
            if (SHIBYTE(v41) < 0) {
              operator delete(*(void **)buf);
            }
          }
          int v31 = 236;
        }
        else
        {
          *a8 = 0;
        }
        *(void *)std::string buf = 0;
        *(void *)BOOL v35 = CFDictionaryGetValue(theDict, @"configuration");
        sub_100044D6C(buf, (CFTypeRef *)v35);
        int v30 = v31;
        sub_100CA1B54(a1, a6, *(CFArrayRef *)buf, 3, (uint64_t)&v30, a4);
        sub_100044D00((const void **)buf);
      }
      else
      {
        unint64_t v26 = *(NSObject **)(a1 + 24);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315650;
          *(void *)&uint8_t buf[4] = "readNonLegacyAPNs";
          __int16 v39 = 2080;
          CFIndex v40 = a7;
          __int16 v41 = 2048;
          CFIndex v42 = i;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s: No technology mask for CB %sAPN configuration %ld, - ignore whole section", buf, 0x20u);
        }
      }
      sub_1000570E8((const void **)&number);
      sub_100057D78((const void **)&theDict);
    }
  }
  if (a9)
  {
    int v29 = 236;
    sub_100CA1CE4(a1, (WirelessTechnologyList *)&v29);
  }
}

void sub_100CA3200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  unsigned int v10 = va_arg(va1, const void *);
  sub_1000570E8((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100CA3248(void *a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v6 = *(void *)(a2 + 96);
  uint64_t v7 = *(void *)(a2 + 104) - v6;
  if (!v7) {
    return;
  }
  int v8 = a5;
  uint64_t v9 = a3;
  long long v11 = a1;
  unint64_t v12 = v7 >> 4;
  if (v12 <= 1) {
    unint64_t v12 = 1;
  }
  uint64_t v13 = (std::__shared_weak_count **)(v6 + 8);
  unint64_t v14 = v12;
  do
  {
    uint64_t v15 = (uint64_t)*(v13 - 1);
    if ((*(_DWORD *)(v15 + 188) & a4) != 0)
    {
      uint64_t v16 = a5 ? 160 : 152;
      if ((*(void *)(v15 + v16) & a3) != 0) {
        goto LABEL_22;
      }
    }
    v13 += 2;
    --v14;
  }
  while (v14);
  if (a5 && a6)
  {
    uint64_t v13 = (std::__shared_weak_count **)(v6 + 8);
    unint64_t v17 = v12;
    while (1)
    {
      uint64_t v15 = (uint64_t)*(v13 - 1);
      if ((*(void *)(v15 + 160) & a3) != 0) {
        break;
      }
      v13 += 2;
      if (!--v17) {
        goto LABEL_16;
      }
    }
LABEL_22:
    CFDictionaryRef v19 = *v13;
    if (!*v13) {
      goto LABEL_24;
    }
LABEL_23:
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_24;
  }
LABEL_16:
  if (a3 != 1 || (a5 & 1) != 0) {
    return;
  }
  for (CFIndex i = (std::__shared_weak_count **)(v6 + 8); ; i += 2)
  {
    uint64_t v15 = (uint64_t)*(i - 1);
    if ((*(_DWORD *)(v15 + 188) & a4) != 0) {
      break;
    }
    if (!--v12) {
      return;
    }
  }
  *(void *)(v15 + 152) |= 1uLL;
  CFDictionaryRef v19 = *i;
  if (*i) {
    goto LABEL_23;
  }
LABEL_24:
  *a1 = v15;
  a1[1] = v19;
  do
  {
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v15 || !*(unsigned char *)(a2 + 176) || !*(unsigned char *)(a2 + 144))
    {
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      if (!v19) {
        goto LABEL_30;
      }
LABEL_29:
      sub_10004D2C8(v19);
      goto LABEL_30;
    }
    uint64_t v26 = *(void *)(a2 + 152);
    uint64_t v25 = *(void *)(a2 + 160);
    if (v26 == v25)
    {
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      goto LABEL_93;
    }
    while (1)
    {
      uint64_t v27 = *(unsigned __int8 *)(v26 + 23);
      if ((v27 & 0x80u) == 0) {
        uint64_t v28 = *(unsigned __int8 *)(v26 + 23);
      }
      else {
        uint64_t v28 = *(void *)(v26 + 8);
      }
      uint64_t v29 = *(unsigned __int8 *)(v15 + 71);
      int v30 = (char)v29;
      if ((v29 & 0x80u) != 0) {
        uint64_t v29 = *(void *)(v15 + 56);
      }
      if (v28 != v29) {
        goto LABEL_75;
      }
      int v31 = v30 >= 0 ? (unsigned __int8 *)(v15 + 48) : *(unsigned __int8 **)(v15 + 48);
      if ((v27 & 0x80) != 0) {
        break;
      }
      if (!*(unsigned char *)(v26 + 23)) {
        goto LABEL_54;
      }
      uint64_t v32 = 0;
      while (*(unsigned __int8 *)(v26 + v32) == v31[v32])
      {
        if (v27 == ++v32) {
          goto LABEL_54;
        }
      }
LABEL_75:
      v26 += 56;
      if (v26 == v25)
      {
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        goto LABEL_91;
      }
    }
    if (memcmp(*(const void **)v26, v31, *(void *)(v26 + 8))) {
      goto LABEL_75;
    }
LABEL_54:
    if (*(_DWORD *)(v26 + 48) != *(_DWORD *)(v15 + 188)) {
      goto LABEL_75;
    }
    if (!*(unsigned char *)(a2 + 144)) {
      sub_10016C840();
    }
    unint64_t v33 = *(void **)(a2 + 120);
    long long v34 = *(void **)(a2 + 128);
    if (v33 == v34) {
      goto LABEL_75;
    }
    while (1)
    {
      if (*(_DWORD *)(*v33 + 188) != *(_DWORD *)(v15 + 188)
        || !sub_100CA3618((unsigned __int8 *)(*v33 + 280), (unsigned __int8 *)(v15 + 48)))
      {
        goto LABEL_74;
      }
      uint64_t v21 = *v33;
      uint64_t v35 = *(unsigned __int8 *)(*v33 + 71);
      if ((v35 & 0x80u) == 0) {
        uint64_t v36 = *(unsigned __int8 *)(*v33 + 71);
      }
      else {
        uint64_t v36 = *(void *)(*v33 + 56);
      }
      uint64_t v37 = *(unsigned __int8 *)(v26 + 47);
      int v38 = (char)v37;
      if ((v37 & 0x80u) != 0) {
        uint64_t v37 = *(void *)(v26 + 32);
      }
      if (v36 != v37) {
        goto LABEL_74;
      }
      __int16 v39 = (const void **)(v21 + 48);
      CFIndex v40 = v38 >= 0 ? (unsigned __int8 *)(v26 + 24) : *(unsigned __int8 **)(v26 + 24);
      if ((v35 & 0x80) != 0) {
        break;
      }
      if (!*(unsigned char *)(*v33 + 71)) {
        goto LABEL_89;
      }
      while (*(unsigned __int8 *)v39 == *v40)
      {
        __int16 v39 = (const void **)((char *)v39 + 1);
        ++v40;
        if (!--v35) {
          goto LABEL_89;
        }
      }
LABEL_74:
      v33 += 2;
      if (v33 == v34) {
        goto LABEL_75;
      }
    }
    if (memcmp(*v39, v40, *(void *)(*v33 + 56))) {
      goto LABEL_74;
    }
LABEL_89:
    uint64_t v20 = (std::__shared_weak_count *)v33[1];
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
LABEL_91:
    int v8 = a5;
LABEL_93:
    long long v11 = a1;
    uint64_t v9 = a3;
    if (v19) {
      goto LABEL_29;
    }
LABEL_30:
    char v22 = 0;
    if (!v21 || v21 == v15)
    {
      uint64_t v24 = v19;
      uint64_t v21 = v15;
    }
    else
    {
      if (v8) {
        uint64_t v23 = *(void *)(v21 + 160);
      }
      else {
        uint64_t v23 = *(void *)(v21 + 152);
      }
      if ((v23 & v9) != 0)
      {
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        void *v11 = v21;
        v11[1] = v20;
        char v22 = 1;
        uint64_t v24 = v20;
        if (v19) {
LABEL_82:
        }
          sub_10004D2C8(v19);
      }
      else
      {
        uint64_t v24 = 0;
        uint64_t v21 = 0;
        char v22 = 0;
        void *v11 = 0;
        v11[1] = 0;
        if (v19) {
          goto LABEL_82;
        }
      }
    }
    if (v20) {
      sub_10004D2C8(v20);
    }
    CFDictionaryRef v19 = v24;
    uint64_t v15 = v21;
  }
  while ((v22 & 1) != 0);
}

void sub_100CA35F8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100CA3618(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[24];
  if (a1[24])
  {
    uint64_t v3 = a1[23];
    if ((v3 & 0x80u) == 0) {
      uint64_t v4 = a1[23];
    }
    else {
      uint64_t v4 = *((void *)a1 + 1);
    }
    uint64_t v5 = a2[23];
    int v6 = (char)v5;
    if ((v5 & 0x80u) != 0) {
      uint64_t v5 = *((void *)a2 + 1);
    }
    if (v4 == v5)
    {
      if (v6 < 0) {
        a2 = *(unsigned __int8 **)a2;
      }
      if ((v3 & 0x80) != 0)
      {
        return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
      }
      else if (a1[23])
      {
        uint64_t v7 = v3 - 1;
        do
        {
          int v9 = *a1++;
          int v8 = v9;
          int v11 = *a2++;
          int v10 = v11;
          BOOL v13 = v7-- != 0;
          BOOL v14 = v8 == v10;
          uint64_t v2 = v8 == v10;
        }
        while (v14 && v13);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t sub_100CA36C4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v4 = *(void **)a1;
    if (*(void *)a1)
    {
      uint64_t v5 = *(void *)(a1 + 8);
      int v6 = *(void **)a1;
      if ((void *)v5 != v4)
      {
        do
        {
          v5 -= 56;
          sub_1000FECD4(v5);
        }
        while ((void *)v5 != v4);
        int v6 = *(void **)a1;
      }
      *(void *)(a1 + 8) = v4;
      operator delete(v6);
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t CellularPlanListModelLocal::CellularPlanListModelLocal(uint64_t a1, NSObject **a2, void *a3, void *a4, void *a5)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, "cp.l.list");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  int v10 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v16, &v17);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v16);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v16);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  *(void *)a1 = off_101A4DF88;
  *(void *)(a1 + 48) = off_101A4E200;
  *(void *)(a1 + 56) = *a3;
  uint64_t v11 = a3[1];
  *(void *)(a1 + 64) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 104) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 112) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 120) = *a5;
  uint64_t v13 = a5[1];
  *(void *)(a1 + 128) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 136) = 0uLL;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 184) = a1 + 192;
  *(void *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 152) = 0uLL;
  *(_OWORD *)(a1 + 168) = 0uLL;
  *(unsigned char *)(a1 + 208) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 216) = a1 + 224;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 240) = a1 + 248;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = a1 + 272;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = a1 + 296;
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 312) = a1 + 320;
  *(_DWORD *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 340) = 0;
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 344) = a1 + 352;
  *(unsigned char *)(a1 + 368) = 0;
  *(unsigned char *)(a1 + 416) = 0;
  *(unsigned char *)(a1 + 424) = 0;
  *(unsigned char *)(a1 + 752) = 0;
  *(void *)(a1 + 768) = 0;
  *(void *)(a1 + 776) = 0;
  *(void *)(a1 + 760) = a1 + 768;
  *(unsigned char *)(a1 + 784) = 0;
  (**(void (***)(OsLogContext *__return_ptr))*a3)(&v16);
  OsLogContext v17 = v16;
  OsLogContext v16 = (OsLogContext)0;
  unsigned int v14 = subscriber::expectedSimCount();
  if (v17.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v17.var1.fRef);
  }
  if (v16.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v16.var1.fRef);
  }
  *(_DWORD *)(a1 + 788) = v14;
  *(void *)(a1 + 808) = 0;
  *(void *)(a1 + 800) = 0;
  *(void *)(a1 + 792) = a1 + 800;
  *(void *)(a1 + 968) = 0;
  *(void *)(a1 + 960) = 0;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_DWORD *)(a1 + 864) = 0;
  *(void *)(a1 + 872) = 0;
  *(void *)(a1 + 888) = 0;
  *(void *)(a1 + 880) = 0;
  *(_OWORD *)(a1 + 904) = 0u;
  *(_OWORD *)(a1 + 920) = 0u;
  *(_OWORD *)(a1 + 936) = 0u;
  *(void *)(a1 + 952) = a1 + 960;
  *(void *)(a1 + 992) = 0;
  *(void *)(a1 + 984) = 0;
  *(void *)(a1 + 976) = a1 + 984;
  *(unsigned char *)(a1 + 1128) = 0;
  *(void *)(a1 + 1192) = 0;
  *(void *)(a1 + 1184) = 0;
  *(_OWORD *)(a1 + 1000) = 0u;
  *(_OWORD *)(a1 + 1016) = 0u;
  *(_OWORD *)(a1 + 1032) = 0u;
  *(unsigned char *)(a1 + 1048) = 0;
  *(_OWORD *)(a1 + 1136) = 0u;
  *(_OWORD *)(a1 + 1152) = 0u;
  *(void *)(a1 + 1168) = 0;
  *(void *)(a1 + 1176) = a1 + 1184;
  *(_DWORD *)(a1 + 896) = v14 < 2;
  return a1;
}

void sub_100CA3A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, _Unwind_Exception *exception_object, char a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10005CD2C(v16 + 624, *(char **)(v17 + 768));
  sub_100CC21AC(v16 + 288);
  if (*(unsigned char *)(v17 + 416) && *(char *)(v17 + 407) < 0) {
    operator delete(*(void **)(v17 + 384));
  }
  sub_10005CD2C(v16 + 208, *(char **)(v17 + 352));
  sub_10023A670(v16 + 176, *(void **)(v17 + 320));
  sub_10030AAD0(v16 + 152, *(void **)(v17 + 296));
  sub_100CC31C4(*(void **)(v17 + 272));
  sub_1000346F8(v22, *(void **)(v17 + 248));
  sub_10010C0E0(v21, *(void **)(v17 + 224));
  sub_100087ED0(v20, *(void **)(v17 + 192));
  a15 = v16 + 24;
  sub_10008A88C((void ***)&a15);
  a15 = v16;
  sub_1000C56F4((void ***)&a15);
  uint64_t v24 = *(std::__shared_weak_count **)(v17 + 128);
  if (v24) {
    sub_10004D2C8(v24);
  }
  uint64_t v25 = *(std::__shared_weak_count **)(v17 + 112);
  if (v25) {
    sub_10004D2C8(v25);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(v17 + 96);
  if (v26) {
    sub_10004D2C8(v26);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v17 + 80);
  if (v27) {
    std::__shared_weak_count::__release_weak(v27);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v17 + 64);
  if (v28) {
    sub_10004D2C8(v28);
  }
  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate(v19);
  ctu::OsLogLogger::~OsLogLogger(v18);
  sub_100087E88(v23);
  _Unwind_Resume(a1);
}

uint64_t sub_100CA3BF4(uint64_t a1)
{
  *(void *)a1 = off_101A4DF88;
  uint64_t v2 = (CellularPlanProvisioningMonitorModeDelegate *)(a1 + 48);
  *(void *)(a1 + 48) = off_101A4E200;
  sub_10005CD2C(a1 + 1176, *(char **)(a1 + 1184));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 1168);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 1159) < 0) {
    operator delete(*(void **)(a1 + 1136));
  }
  if (*(unsigned char *)(a1 + 1128) && *(char *)(a1 + 1111) < 0) {
    operator delete(*(void **)(a1 + 1088));
  }
  if (*(char *)(a1 + 1047) < 0) {
    operator delete(*(void **)(a1 + 1024));
  }
  if (*(char *)(a1 + 1023) < 0) {
    operator delete(*(void **)(a1 + 1000));
  }
  sub_10010C0E0(a1 + 976, *(void **)(a1 + 984));
  sub_10005CD2C(a1 + 952, *(char **)(a1 + 960));
  if (*(char *)(a1 + 951) < 0) {
    operator delete(*(void **)(a1 + 928));
  }
  if (*(char *)(a1 + 927) < 0) {
    operator delete(*(void **)(a1 + 904));
  }
  if (*(char *)(a1 + 895) < 0) {
    operator delete(*(void **)(a1 + 872));
  }
  if (*(char *)(a1 + 863) < 0) {
    operator delete(*(void **)(a1 + 840));
  }
  if (*(char *)(a1 + 839) < 0) {
    operator delete(*(void **)(a1 + 816));
  }
  sub_10005CD2C(a1 + 792, *(char **)(a1 + 800));
  sub_10005CD2C(a1 + 760, *(char **)(a1 + 768));
  sub_100CC21AC(a1 + 424);
  if (*(unsigned char *)(a1 + 416) && *(char *)(a1 + 407) < 0) {
    operator delete(*(void **)(a1 + 384));
  }
  sub_10005CD2C(a1 + 344, *(char **)(a1 + 352));
  sub_10023A670(a1 + 312, *(void **)(a1 + 320));
  sub_10030AAD0(a1 + 288, *(void **)(a1 + 296));
  sub_100CC31C4(*(void **)(a1 + 272));
  sub_1000346F8(a1 + 240, *(void **)(a1 + 248));
  sub_10010C0E0(a1 + 216, *(void **)(a1 + 224));
  sub_100087ED0(a1 + 184, *(void **)(a1 + 192));
  int v10 = (void **)(a1 + 160);
  sub_10008A88C(&v10);
  int v10 = (void **)(a1 + 136);
  sub_1000C56F4(&v10);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 128);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 112);
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = *(std::__shared_weak_count **)(a1 + 96);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 80);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  int v8 = *(std::__shared_weak_count **)(a1 + 64);
  if (v8) {
    sub_10004D2C8(v8);
  }
  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate(v2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100CA3E34(uint64_t a1)
{
  return sub_100CA3BF4(a1 - 48);
}

void sub_100CA3E3C(uint64_t a1)
{
  sub_100CA3BF4(a1);

  operator delete();
}

void sub_100CA3E74(uint64_t a1)
{
  sub_100CA3BF4(a1 - 48);

  operator delete();
}

void sub_100CA3EB0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
  *(void *)(a1 + 72) = v3;
  *(void *)(a1 + 80) = v2;
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_100CA3EDC(uint64_t a1, int a2, int a3)
{
  (***(void (****)(long long *__return_ptr))(a1 + 56))(&v9);
  *(_OWORD *)std::string buf = v9;
  long long v9 = 0uLL;
  char isValidSimSlot = subscriber::isValidSimSlot();
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (*((void *)&v9 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v9 + 1));
  }
  if (isValidSimSlot)
  {
    if ((a3 - 1) >= 3)
    {
      if (!a3) {
        sub_100CA405C(a1, a2);
      }
    }
    else
    {
      sub_100CA460C((void *)a1, a2);
      sub_100CA405C(a1, a2);
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I invalid slot : %s for update CarrierBundle", buf, 0xCu);
    }
  }
}

void sub_100CA4030(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CA405C(uint64_t result, int a2)
{
  uint64_t v3 = *(unsigned int **)(result + 160);
  uint64_t v2 = *(unsigned int **)(result + 168);
  if (v3 != v2)
  {
    uint64_t v5 = result;
    int v6 = (uint64_t **)(result + 264);
    do
    {
      if (*v3 == a2)
      {
        if (*((char *)v3 + 95) < 0)
        {
          if (!*((void *)v3 + 10)) {
            goto LABEL_48;
          }
        }
        else if (!*((unsigned char *)v3 + 95))
        {
          goto LABEL_48;
        }
        uint64_t result = subscriber::isEsimCapable();
        if ((result & 1) == 0)
        {
          uint64_t v40 = 0;
          __int16 v41 = 0;
          (***(void (****)(unsigned char *__return_ptr))(v5 + 56))(buf);
          ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)buf);
          long long v9 = ServiceMap;
          if ((v10 & 0x8000000000000000) != 0)
          {
            uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v12 = 5381;
            do
            {
              unint64_t v10 = v12;
              unsigned int v13 = *v11++;
              uint64_t v12 = (33 * v12) ^ v13;
            }
            while (v13);
          }
          std::mutex::lock(ServiceMap);
          unint64_t v38 = v10;
          unsigned int v14 = sub_10004D37C(&v9[1].__m_.__sig, &v38);
          if (v14)
          {
            uint64_t v15 = v14[3];
            uint64_t v16 = (std::__shared_weak_count *)v14[4];
            if (v16)
            {
              atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v9);
              atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v16);
              char v17 = 0;
LABEL_17:
              (*(void (**)(uint64_t *__return_ptr, uint64_t, void))(*(void *)v15 + 8))(&v40, v15, *v3);
              if ((v17 & 1) == 0) {
                sub_10004D2C8(v16);
              }
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
              if (v40)
              {
                unint64_t v38 = 0;
                __int16 v39 = 0;
                (*(void (**)(unint64_t *__return_ptr))(*(void *)v40 + 64))(&v38);
                if (v38)
                {
                  uint64_t v37 = 0;
                  CFTypeRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v38 + 64), @"SupportPhysicalSIMtoESIMTransfer");
                  uint64_t v35 = Value;
                  if (Value) {
                    CFRetain(Value);
                  }
                  sub_1000057AC(&v36, &v35);
                  *(void *)std::string buf = v37;
                  CFDictionaryRef v19 = v36;
                  uint64_t v36 = 0;
                  uint64_t v37 = v19;
                  sub_100062778((const void **)buf);
                  sub_100062778((const void **)&v36);
                  sub_1000577C4(&v35);
                  buf[0] = 0;
                  ctu::cf::assign((ctu::cf *)buf, v37, v20);
                  if (!buf[0]) {
                    goto LABEL_39;
                  }
                  uint64_t v21 = CFDictionaryGetValue(*(CFDictionaryRef *)(v38 + 64), @"SupportsOnDevicePhysicalSIMConvert");
                  uint64_t v35 = v21;
                  if (v21) {
                    CFRetain(v21);
                  }
                  sub_1000057AC(&v36, &v35);
                  *(void *)std::string buf = v37;
                  uint64_t v22 = v36;
                  uint64_t v36 = 0;
                  uint64_t v37 = v22;
                  sub_100062778((const void **)buf);
                  sub_100062778((const void **)&v36);
                  sub_1000577C4(&v35);
                  buf[0] = 0;
                  ctu::cf::assign((ctu::cf *)buf, v37, v23);
                  if (!buf[0]) {
                    goto LABEL_39;
                  }
                  uint64_t v24 = CFDictionaryGetValue(*(CFDictionaryRef *)(v38 + 64), @"AllowCellularPlanTransferTarget");
                  uint64_t v35 = v24;
                  if (v24) {
                    CFRetain(v24);
                  }
                  sub_1000057AC(&v36, &v35);
                  *(void *)std::string buf = v37;
                  uint64_t v25 = v36;
                  uint64_t v36 = 0;
                  uint64_t v37 = v25;
                  sub_100062778((const void **)buf);
                  sub_100062778((const void **)&v36);
                  sub_1000577C4(&v35);
                  uint64_t v27 = v37 ? sub_100084B4C : 0;
                  if (!v27 || (buf[0] = 0, ctu::cf::assign((ctu::cf *)buf, v37, v26), buf[0])) {
                    int v28 = 2;
                  }
                  else {
LABEL_39:
                  }
                    int v28 = 1;
                  sub_100062778((const void **)&v37);
                }
                else
                {
                  int v30 = *(NSObject **)(v5 + 40);
                  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v33 = subscriber::asString();
                    if (*((char *)v3 + 95) >= 0) {
                      long long v34 = v3 + 18;
                    }
                    else {
                      long long v34 = (unsigned int *)*((void *)v3 + 9);
                    }
                    *(_DWORD *)std::string buf = 136315650;
                    *(void *)&uint8_t buf[4] = "TransferSIMService";
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = v33;
                    __int16 v43 = 2080;
                    uint64_t v44 = v34;
                    _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "No CarrierEntitlements settings for task %s at slot:%s, iccid:%s", buf, 0x20u);
                  }
                  int v28 = 0;
                }
                if (v39) {
                  sub_10004D2C8(v39);
                }
              }
              else
              {
                uint64_t v29 = *(NSObject **)(v5 + 40);
                if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v31 = subscriber::asString();
                  if (*((char *)v3 + 95) >= 0) {
                    uint64_t v32 = v3 + 18;
                  }
                  else {
                    uint64_t v32 = (unsigned int *)*((void *)v3 + 9);
                  }
                  *(_DWORD *)std::string buf = 136315394;
                  *(void *)&uint8_t buf[4] = v31;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = v32;
                  _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "No CarrierEntitlements controller for slot:%s, iccid:%s", buf, 0x16u);
                }
                int v28 = 0;
              }
              if (v41) {
                sub_10004D2C8(v41);
              }
              *(void *)std::string buf = v3 + 18;
              uint64_t result = (uint64_t)sub_100CC3268(v6, (void **)v3 + 9, (long long **)buf);
              *(_DWORD *)(result + 180) = v28;
              goto LABEL_48;
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          std::mutex::unlock(v9);
          uint64_t v16 = 0;
          char v17 = 1;
          goto LABEL_17;
        }
      }
LABEL_48:
      v3 += 42;
    }
    while (v3 != v2);
  }
  return result;
}

void sub_100CA4560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CA460C(void *a1, int a2)
{
  uint64_t v4 = a1[20];
  uint64_t v3 = a1[21];
  if (v4 == v3)
  {
    if (a2 == 3)
    {
      char v61 = 0;
      goto LABEL_84;
    }
    return;
  }
  char v61 = 0;
  uint64_t v5 = a1;
  int v6 = (uint64_t **)(a1 + 33);
  uint64_t v7 = &_mh_execute_header;
  do
  {
    v4 += 168;
    while (((a2 == 3) & subscriber::isEsimCapable()) != 0)
    {
      BOOL v8 = v4 == v3;
      v4 += 168;
      if (v8) {
        goto LABEL_83;
      }
    }
    if (*(char *)(v4 - 73) < 0)
    {
      if (!*(void *)(v4 - 88)) {
        continue;
      }
    }
    else if (!*(unsigned char *)(v4 - 73))
    {
      continue;
    }
    if (subscriber::isSimLocked()) {
      continue;
    }
    long long v65 = 0u;
    memset(__str, 0, sizeof(__str));
    sub_100E63EA4((uint64_t)__str);
    long long v9 = (void *)(v4 - 96);
    if ((subscriber::isEsimCapable() & 1) == 0)
    {
      int isSimReady = subscriber::isSimReady();
      int v11 = *(_DWORD *)(v4 - 168) ? isSimReady : 0;
      if (v11 == 1)
      {
        __s1.__r_.__value_.__r.__words[0] = v4 - 96;
        uint64_t v12 = sub_100CC3268(v6, (void **)(v4 - 96), (long long **)&__s1);
        if (v12[103] < 0)
        {
          if (!*((void *)v12 + 11))
          {
LABEL_26:
            __s1.__r_.__value_.__r.__words[0] = v4 - 96;
            uint64_t v15 = sub_100CC3268(v6, (void **)(v4 - 96), (long long **)&__s1);
            std::string::operator=((std::string *)(v15 + 80), (const std::string *)__str);
            __s1.__r_.__value_.__r.__words[0] = v4 - 96;
            uint64_t v16 = sub_100CC3268(v6, (void **)(v4 - 96), (long long **)&__s1);
            std::string::operator=((std::string *)(v16 + 104), (const std::string *)&__str[24]);
            __s1.__r_.__value_.__r.__words[0] = v4 - 96;
            char v17 = sub_100CC3268(v6, (void **)(v4 - 96), (long long **)&__s1);
            std::string::operator=((std::string *)(v17 + 128), (const std::string *)(v4 - 48));
            __s1.__r_.__value_.__r.__words[0] = v4 - 96;
            uint64_t v18 = sub_100CC3268(v6, (void **)(v4 - 96), (long long **)&__s1);
            std::string::operator=((std::string *)(v18 + 152), (const std::string *)(v4 - 24));
            uint64_t v19 = __str[23];
            if (__str[23] < 0) {
              uint64_t v19 = *(void *)&__str[8];
            }
            if (v19) {
              goto LABEL_36;
            }
            uint64_t v20 = HIBYTE(v65);
            if (v65 < 0) {
              uint64_t v20 = v65;
            }
            if (v20
              || (*(char *)(v4 - 25) < 0 ? (uint64_t v21 = *(void *)(v4 - 40)) : (uint64_t v21 = *(unsigned __int8 *)(v4 - 25)), v21))
            {
LABEL_36:
              BOOL v22 = 0;
            }
            else
            {
              if (*(char *)(v4 - 1) < 0) {
                uint64_t v39 = *(void *)(v4 - 16);
              }
              else {
                uint64_t v39 = *(unsigned __int8 *)(v4 - 1);
              }
              BOOL v22 = v39 == 0;
            }
            char v61 = !v22;
            goto LABEL_38;
          }
        }
        else if (!v12[103])
        {
          goto LABEL_26;
        }
        __s1.__r_.__value_.__r.__words[0] = v4 - 96;
        unsigned int v13 = sub_100CC3268(v6, (void **)(v4 - 96), (long long **)&__s1);
        if (v13[127] < 0) {
          uint64_t v14 = *((void *)v13 + 14);
        }
        else {
          uint64_t v14 = v13[127];
        }
        if (v14) {
          goto LABEL_38;
        }
        goto LABEL_26;
      }
    }
LABEL_38:
    __s1.__r_.__value_.__r.__words[0] = v4 - 96;
    CFBooleanRef v23 = sub_100CC3268(v6, (void **)(v4 - 96), (long long **)&__s1);
    if (v23[79] < 0)
    {
      if (!*((void *)v23 + 8)) {
        goto LABEL_43;
      }
    }
    else if (!v23[79])
    {
      goto LABEL_43;
    }
    if (*(_DWORD *)(v4 - 168) == a2)
    {
LABEL_43:
      memset(&__s1, 0, sizeof(__s1));
      (*(void (**)(std::string *__return_ptr))(*(void *)v5[7] + 160))(&__s1);
      std::string::size_type size = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
      if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = __s1.__r_.__value_.__l.__size_;
      }
      if (size)
      {
        buf.__r_.__value_.__r.__words[0] = v4 - 96;
        uint64_t v25 = sub_100CC3268(v6, (void **)(v4 - 96), (long long **)&buf);
        uint64_t v26 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
        if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v27 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v27 = __s1.__r_.__value_.__l.__size_;
        }
        uint64_t v28 = v25[79];
        int v29 = (char)v28;
        if ((v28 & 0x80u) != 0) {
          uint64_t v28 = *((void *)v25 + 8);
        }
        if (v27 != v28) {
          goto LABEL_64;
        }
        uint64_t v32 = (unsigned __int8 *)*((void *)v25 + 7);
        int v30 = v25 + 56;
        uint64_t v31 = (char *)v32;
        if (v29 >= 0) {
          uint64_t v33 = v30;
        }
        else {
          uint64_t v33 = v31;
        }
        if ((*((unsigned char *)&__s1.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          if (memcmp(__s1.__r_.__value_.__l.__data_, v33, __s1.__r_.__value_.__l.__size_)) {
            goto LABEL_64;
          }
        }
        else if (*((unsigned char *)&__s1.__r_.__value_.__s + 23))
        {
          p_s1 = &__s1;
          while (p_s1->__r_.__value_.__s.__data_[0] == *v33)
          {
            p_s1 = (std::string *)((char *)p_s1 + 1);
            ++v33;
            if (!--v26) {
              goto LABEL_65;
            }
          }
LABEL_64:
          buf.__r_.__value_.__r.__words[0] = v4 - 96;
          uint64_t v37 = sub_100CC3268(v6, (void **)(v4 - 96), (long long **)&buf);
          std::string::operator=((std::string *)(v37 + 56), &__s1);
          char v61 = 1;
        }
      }
      else
      {
        uint64_t v35 = (mach_header_64 *)v7;
        uint64_t v36 = v5[5];
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          if (*(char *)(v4 - 73) < 0) {
            long long v9 = (void *)*v9;
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
          unint64_t v38 = v36;
          uint64_t v7 = v35;
          _os_log_error_impl(v35, v38, OS_LOG_TYPE_ERROR, "Missing carrier name from bundle for: %s", (uint8_t *)&buf, 0xCu);
        }
        else
        {
          uint64_t v7 = v35;
        }
      }
LABEL_65:
      if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__s1.__r_.__value_.__l.__data_);
      }
    }
    if (SHIBYTE(v65) < 0) {
      operator delete(*(void **)&__str[24]);
    }
    if ((__str[23] & 0x80000000) != 0) {
      operator delete(*(void **)__str);
    }
  }
  while (v4 != v3);
  if (a2 == 3)
  {
LABEL_83:
    a1 = v5;
LABEL_84:
    uint64_t v40 = a1[17];
    uint64_t v41 = a1[18];
    if (v40 != v41)
    {
      uint64_t v42 = (uint64_t)a1;
      __int16 v43 = (uint64_t **)(a1 + 33);
      while (*(_DWORD *)(v40 + 12) != 3 || !*(unsigned char *)(v40 + 80))
      {
LABEL_129:
        v40 += 88;
        if (v40 == v41) {
          goto LABEL_132;
        }
      }
      uint64_t v45 = *(void *)(v40 + 56);
      uint64_t v44 = *(void *)(v40 + 64);
      while (2)
      {
        if (v45 == v44) {
          goto LABEL_129;
        }
        uint64_t v76 = 0;
        long long v74 = 0u;
        long long v75 = 0u;
        long long v72 = 0u;
        long long v73 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v65 = 0u;
        memset(__str, 0, sizeof(__str));
        sub_1000C5AB4((uint64_t)__str, v45);
        if (BYTE8(v68)) {
          goto LABEL_128;
        }
        __s1.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str[16];
        uint64_t v46 = sub_100CC3268(v43, (void **)&__str[16], (long long **)&__s1);
        if ((v46[79] & 0x80000000) == 0)
        {
          if (v46[79]) {
            goto LABEL_128;
          }
LABEL_95:
          memset(&__s1, 0, sizeof(__s1));
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str[16];
          unint64_t v47 = sub_100CC3268(v43, (void **)&__str[16], (long long **)&buf);
          char v48 = v47;
          if (!v47[392]) {
            goto LABEL_101;
          }
          if (v47[271] < 0)
          {
            if (!*((void *)v47 + 32)) {
              goto LABEL_101;
            }
          }
          else if (!v47[271])
          {
LABEL_101:
            std::string::size_type v49 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
            if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v49 = __s1.__r_.__value_.__l.__size_;
            }
            if (!v49)
            {
              (*(void (**)(std::string *__return_ptr))(**(void **)(v42 + 56) + 160))(&buf);
              if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__s1.__r_.__value_.__l.__data_);
              }
              std::string __s1 = buf;
            }
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str[16];
            uint64_t v50 = sub_100CC3268(v43, (void **)&__str[16], (long long **)&buf);
            uint64_t v51 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
            if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v52 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v52 = __s1.__r_.__value_.__l.__size_;
            }
            uint64_t v53 = v50[79];
            int v54 = (char)v53;
            if ((v53 & 0x80u) != 0) {
              uint64_t v53 = *((void *)v50 + 8);
            }
            if (v52 != v53) {
              goto LABEL_123;
            }
            BOOL v57 = (unsigned __int8 *)*((void *)v50 + 7);
            int v55 = v50 + 56;
            uint64_t v56 = (char *)v57;
            if (v54 >= 0) {
              uint64_t v58 = v55;
            }
            else {
              uint64_t v58 = v56;
            }
            if ((*((unsigned char *)&__s1.__r_.__value_.__s + 23) & 0x80) != 0)
            {
              if (memcmp(__s1.__r_.__value_.__l.__data_, v58, __s1.__r_.__value_.__l.__size_)) {
                goto LABEL_123;
              }
            }
            else if (*((unsigned char *)&__s1.__r_.__value_.__s + 23))
            {
              int v59 = &__s1;
              while (v59->__r_.__value_.__s.__data_[0] == *v58)
              {
                int v59 = (std::string *)((char *)v59 + 1);
                ++v58;
                if (!--v51) {
                  goto LABEL_124;
                }
              }
LABEL_123:
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str[16];
              CFArrayRef v60 = sub_100CC3268(v43, (void **)&__str[16], (long long **)&buf);
              std::string::operator=((std::string *)(v60 + 56), &__s1);
              char v61 = 1;
            }
LABEL_124:
            if (v48[392]) {
              std::string::operator=((std::string *)(v48 + 248), &__s1);
            }
            if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__s1.__r_.__value_.__l.__data_);
            }
LABEL_128:
            sub_1000C584C((uint64_t)__str);
            v45 += 216;
            continue;
          }
          std::string::operator=(&__s1, (const std::string *)(v47 + 248));
          goto LABEL_101;
        }
        break;
      }
      if (!*((void *)v46 + 8)) {
        goto LABEL_95;
      }
      goto LABEL_128;
    }
    uint64_t v42 = (uint64_t)a1;
  }
  else
  {
    uint64_t v42 = (uint64_t)v5;
  }
LABEL_132:
  if (v61) {
    sub_100CA4DAC(v42);
  }
}

void sub_100CA4D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_100CA4DAC(uint64_t a1)
{
  std::string::size_type v49 = &v50;
  uint64_t v50 = 0;
  v56[0] = 0;
  v56[1] = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  uint64_t v51 = 0;
  int v55 = (uint64_t *)v56;
  v58[1] = 0;
  memset(&v59, 0, sizeof(v59));
  BOOL v57 = (uint64_t *)v58;
  v58[0] = 0;
  sub_100CA8010((uint64_t *)__dst, a1);
  sub_10005CD2C((uint64_t)&v49, v50);
  uint64_t v2 = (char *)__dst[1];
  std::string::size_type v49 = (char **)__dst[0];
  uint64_t v50 = (char *)__dst[1];
  uint64_t v51 = v39;
  if (v39)
  {
    *((void *)__dst[1] + 2) = &v50;
    __dst[0] = (Registry *)&__dst[1];
    __dst[1] = 0;
    uint64_t v39 = 0;
    uint64_t v2 = 0;
  }
  else
  {
    std::string::size_type v49 = &v50;
  }
  sub_10005CD2C((uint64_t)__dst, v2);
  uint64_t v3 = std::string::operator=((std::string *)&v52, (const std::string *)(a1 + 872));
  if (capabilities::ct::supportsVoiceCall((capabilities::ct *)v3)) {
    std::string::operator=((std::string *)((char *)&v53 + 8), (const std::string *)(a1 + 840));
  }
  uint64_t v28 = a1;
  uint64_t v4 = *(void **)(a1 + 264);
  if (v4 != (void *)(a1 + 272))
  {
    do
    {
      __dst[0] = (Registry *)(v4 + 4);
      uint64_t v5 = sub_100366370(&v55, (void **)v4 + 4, (uint64_t)&unk_10144E20E, (long long **)__dst);
      std::string::operator=((std::string *)(v5 + 7), (const std::string *)(v4 + 7));
      if (*((char *)v4 + 55) < 0)
      {
        sub_10004FC84(__dst, (void *)v4[4], v4[5]);
      }
      else
      {
        *(_OWORD *)long long __dst = *((_OWORD *)v4 + 2);
        uint64_t v39 = v4[6];
      }
      char v40 = 1;
      if (*((char *)v4 + 103) < 0)
      {
        sub_10004FC84(&v41, (void *)v4[10], v4[11]);
      }
      else
      {
        long long v41 = *((_OWORD *)v4 + 5);
        uint64_t v42 = v4[12];
      }
      if (*((char *)v4 + 127) < 0)
      {
        sub_10004FC84(&v43, (void *)v4[13], v4[14]);
      }
      else
      {
        long long v43 = *(_OWORD *)(v4 + 13);
        uint64_t v44 = v4[15];
      }
      if (*((char *)v4 + 151) < 0)
      {
        sub_10004FC84(&__p, (void *)v4[16], v4[17]);
      }
      else
      {
        long long __p = *((_OWORD *)v4 + 8);
        uint64_t v46 = v4[18];
      }
      if (*((char *)v4 + 175) < 0)
      {
        sub_10004FC84(&v47, (void *)v4[19], v4[20]);
      }
      else
      {
        long long v47 = *(_OWORD *)(v4 + 19);
        uint64_t v48 = v4[21];
      }
      v60[0] = (long long *)(v4 + 4);
      int v6 = sub_10086299C(&v57, (void **)v4 + 4, (uint64_t)&unk_10144E20E, v60);
      sub_100179CB0((uint64_t)(v6 + 7), (__n128 *)__dst);
      uint64_t v7 = (void **)(v6 + 11);
      if (*((char *)v6 + 111) < 0) {
        operator delete(*v7);
      }
      v6[13] = v42;
      *(_OWORD *)uint64_t v7 = v41;
      HIBYTE(v42) = 0;
      LOBYTE(v41) = 0;
      BOOL v8 = (void **)(v6 + 14);
      if (*((char *)v6 + 135) < 0) {
        operator delete(*v8);
      }
      v6[16] = v44;
      *(_OWORD *)BOOL v8 = v43;
      HIBYTE(v44) = 0;
      LOBYTE(v43) = 0;
      long long v9 = (void **)(v6 + 17);
      if (*((char *)v6 + 159) < 0) {
        operator delete(*v9);
      }
      v6[19] = v46;
      *(_OWORD *)long long v9 = __p;
      HIBYTE(v46) = 0;
      LOBYTE(__p) = 0;
      unint64_t v10 = (void **)(v6 + 20);
      if (*((char *)v6 + 183) < 0)
      {
        operator delete(*v10);
        int v11 = SHIBYTE(v46);
        *(_OWORD *)unint64_t v10 = v47;
        v6[22] = v48;
        HIBYTE(v48) = 0;
        LOBYTE(v47) = 0;
        if (v11 < 0) {
          operator delete((void *)__p);
        }
      }
      else
      {
        *(_OWORD *)unint64_t v10 = v47;
        v6[22] = v48;
        HIBYTE(v48) = 0;
        LOBYTE(v47) = 0;
      }
      if (SHIBYTE(v44) < 0) {
        operator delete((void *)v43);
      }
      if (SHIBYTE(v42) < 0) {
        operator delete((void *)v41);
      }
      if (v40 && SHIBYTE(v39) < 0) {
        operator delete(__dst[0]);
      }
      uint64_t v12 = (void *)v4[1];
      if (v12)
      {
        do
        {
          unsigned int v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v4[2];
          BOOL v14 = *v13 == (void)v4;
          uint64_t v4 = v13;
        }
        while (!v14);
      }
      uint64_t v4 = v13;
    }
    while (v13 != (void *)(a1 + 272));
  }
  if (*(char *)(a1 + 839) < 0) {
    uint64_t v15 = *(void *)(a1 + 824);
  }
  else {
    uint64_t v15 = *(unsigned __int8 *)(a1 + 839);
  }
  if (v15) {
    std::string::operator=(&v59, (const std::string *)(a1 + 816));
  }
  uint64_t v16 = *(void *)(a1 + 120);
  sub_100860AEC((uint64_t)v29, (uint64_t)&v49);
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v16 + 24))(v16, v29);
  if (v37 < 0) {
    operator delete(v36[3]);
  }
  sub_10010E37C((uint64_t)v36, v36[1]);
  sub_10010C0E0((uint64_t)v35, v35[1]);
  if (v34 < 0) {
    operator delete(v33);
  }
  if (v32 < 0) {
    operator delete(v31);
  }
  sub_10005CD2C((uint64_t)v29, v30);
  (***(void (****)(Registry **__return_ptr))(v28 + 56))(__dst);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v17, __dst[0]);
  uint64_t v19 = ServiceMap;
  if (v20 < 0)
  {
    uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(ServiceMap);
  v60[0] = (long long *)v20;
  uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)v60);
  if (v24)
  {
    uint64_t v26 = v24[3];
    uint64_t v25 = (std::__shared_weak_count *)v24[4];
    if (v25)
    {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v25);
      char v27 = 0;
      goto LABEL_64;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v19);
  uint64_t v25 = 0;
  char v27 = 1;
LABEL_64:
  if (__dst[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__dst[1]);
  }
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 72))(v26);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  sub_100CA5528(v28);
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v59.__r_.__value_.__l.__data_);
  }
  sub_10010E37C((uint64_t)&v57, v58[0]);
  sub_10010C0E0((uint64_t)&v55, v56[0]);
  if (SHIBYTE(v54) < 0) {
    operator delete(*((void **)&v53 + 1));
  }
  if (SBYTE7(v53) < 0) {
    operator delete((void *)v52);
  }
  sub_10005CD2C((uint64_t)&v49, v50);
}

void sub_100CA538C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *__p,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  if ((v53 & 1) == 0) {
    sub_10004D2C8(v54);
  }
  sub_100859044(v55 - 256);
  _Unwind_Resume(a1);
}

void sub_100CA5464(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t **)(a1 + 312);
  if (*(unsigned char *)(a2 + 24)) {
    BOOL v4 = v3 == (uint64_t **)a2;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4) {
    sub_100426EA4(v3, *(long long **)a2, (long long *)(a2 + 8));
  }
  sub_100CA5528(a1);
  sub_100CA5980(a1);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 80);
  if (v5)
  {
    int v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(a1 + 72);
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 64))(v8);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100CA5514(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100CA5528(uint64_t a1)
{
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56)) & 1) == 0
    && *(_DWORD *)(a1 + 336) >= 2u)
  {
    long long v23 = 0uLL;
    uint64_t v22 = &v23;
    uint64_t v2 = *(void **)(a1 + 792);
    if (v2 != (void *)(a1 + 800))
    {
      while ((sub_100CBFD40((unsigned __int8 **)v2 + 4, *(void *)(a1 + 160), *(void *)(a1 + 168)) & 1) != 0)
      {
        memset(&v20, 0, sizeof(v20));
        if (*((char *)v2 + 55) < 0)
        {
          sub_10004FC84(__p, (void *)v2[4], v2[5]);
        }
        else
        {
          *(_OWORD *)long long __p = *((_OWORD *)v2 + 2);
          uint64_t v16 = v2[6];
        }
        uint64_t v3 = sub_100046F68(a1 + 312, __p);
        if (SHIBYTE(v16) < 0) {
          operator delete(__p[0]);
        }
        if ((void **)(a1 + 320) != v3) {
          std::string::operator=(&v20, (const std::string *)(v3 + 17));
        }
        sub_1002C3E94((uint64_t **)&v22, (void **)v2 + 4, (long long *)v2 + 2, (long long *)&v20);
        if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v20.__r_.__value_.__l.__data_);
        }
        BOOL v4 = (void *)v2[1];
        if (v4)
        {
          do
          {
            uint64_t v5 = v4;
            BOOL v4 = (void *)*v4;
          }
          while (v4);
        }
        else
        {
          do
          {
            uint64_t v5 = (void *)v2[2];
            BOOL v6 = *v5 == (void)v2;
            uint64_t v2 = v5;
          }
          while (!v6);
        }
        uint64_t v2 = v5;
        if (v5 == (void *)(a1 + 800)) {
          goto LABEL_20;
        }
      }
      goto LABEL_48;
    }
LABEL_20:
    (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 120) + 200))(&v20);
    if (v21 && v20.__r_.__value_.__r.__words[2] > *((void *)&v23 + 1))
    {
      std::string::size_type v7 = v20.__r_.__value_.__r.__words[0];
      if ((std::string::size_type *)v20.__r_.__value_.__l.__data_ == &v20.__r_.__value_.__r.__words[1])
      {
LABEL_47:
        sub_1008618BC((uint64_t)&v20);
LABEL_48:
        sub_10010C0E0((uint64_t)&v22, (void *)v23);
        return;
      }
      while (1)
      {
        if (*(char *)(v7 + 55) < 0)
        {
          sub_10004FC84(__p, *(void **)(v7 + 32), *(void *)(v7 + 40));
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)(v7 + 32);
          uint64_t v16 = *(void *)(v7 + 48);
        }
        uint64_t v8 = sub_10010E128(a1 + 312, __p);
        if (SHIBYTE(v16) < 0) {
          operator delete(__p[0]);
        }
        if (!v8) {
          break;
        }
        long long v9 = *(std::string **)(v7 + 8);
        if (v9)
        {
          do
          {
            unint64_t v10 = v9;
            long long v9 = (std::string *)v9->__r_.__value_.__r.__words[0];
          }
          while (v9);
        }
        else
        {
          do
          {
            unint64_t v10 = *(std::string **)(v7 + 16);
            BOOL v6 = v10->__r_.__value_.__r.__words[0] == v7;
            std::string::size_type v7 = (std::string::size_type)v10;
          }
          while (!v6);
        }
        std::string::size_type v7 = (std::string::size_type)v10;
        if (v10 == (std::string *)&v20.__r_.__value_.__r.__words[1]) {
          goto LABEL_47;
        }
      }
    }
    __p[1] = 0;
    uint64_t v16 = 0;
    __p[0] = &__p[1];
    *(_OWORD *)char v17 = 0u;
    *(_OWORD *)uint64_t v18 = 0u;
    long long v19 = 0u;
    sub_100328AC0((uint64_t **)__p, v22, &v23);
    std::string::operator=((std::string *)v17, (const std::string *)(a1 + 872));
    std::string::operator=((std::string *)&v18[1], (const std::string *)(a1 + 840));
    int v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      sub_1008A2650((uint64_t)__p, v13);
      uint64_t v12 = v14 >= 0 ? v13 : (void **)v13[0];
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v25 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Persist multi SIM preferences: %s", buf, 0xCu);
      if (v14 < 0) {
        operator delete(v13[0]);
      }
    }
    (*(void (**)(void, void **))(**(void **)(a1 + 120) + 192))(*(void *)(a1 + 120), __p);
    if (SHIBYTE(v19) < 0) {
      operator delete(v18[1]);
    }
    if (SHIBYTE(v18[0]) < 0) {
      operator delete(v17[0]);
    }
    sub_10010C0E0((uint64_t)__p, (void *)__p[1]);
    goto LABEL_47;
  }
}

void sub_100CA58F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  sub_10085D480((uint64_t)&__p);
  sub_1008618BC((uint64_t)&a25);
  sub_10010C0E0(v30 - 136, *(void **)(v30 - 128));
  _Unwind_Resume(a1);
}

void sub_100CA5980(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      BOOL v4 = v3;
      uint64_t v5 = *(void *)(a1 + 72);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100CA5A00(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100CA5A14(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = &v118;
  uint64_t v117 = 0;
  long long v119 = 0u;
  uint64_t v118 = &v119;
  if (*(void *)(a2 + 808) <= 1uLL)
  {
    uint64_t v4 = 0;
    *(unsigned char *)a1 = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 16) = 0;
    uint64_t v5 = a1 + 16;
LABEL_3:
    *(void *)(a1 + 8) = v5;
    goto LABEL_193;
  }
  uint64_t v7 = *(void *)(a2 + 160);
  uint64_t v8 = *(void *)(a2 + 168);
  if (v7 == v8)
  {
    uint8_t v55 = 0;
    uint64_t v12 = &v127;
    *(void *)uint64_t v126 = 0;
    long long v127 = 0uLL;
    *(void *)&v126[8] = &v127;
    goto LABEL_145;
  }
  do
  {
    (***(void (****)(uint8_t *__return_ptr))(a2 + 56))(v126);
    *(_OWORD *)std::string buf = *(_OWORD *)v126;
    memset(v126, 0, sizeof(v126));
    char isValidSimSlot = subscriber::isValidSimSlot();
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (*(void *)&v126[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v126[8]);
    }
    if (isValidSimSlot)
    {
      if (*(char *)(v7 + 95) < 0)
      {
        if (!*(void *)(v7 + 80)) {
          goto LABEL_131;
        }
      }
      else if (!*(unsigned char *)(v7 + 95))
      {
        goto LABEL_131;
      }
      if ((subscriber::isSimReady() & 1) == 0)
      {
LABEL_131:
        *(unsigned char *)a1 = v117;
        uint64_t v4 = v119;
        *(void *)(a1 + 8) = v118;
        *(void *)(a1 + 16) = v4;
        uint64_t v5 = a1 + 16;
        uint64_t v56 = *((void *)&v119 + 1);
        *(void *)(a1 + 24) = *((void *)&v119 + 1);
        if (!v56) {
          goto LABEL_3;
        }
LABEL_153:
        *(void *)(v4 + 16) = v5;
        uint64_t v118 = &v119;
        long long v119 = 0uLL;
        uint64_t v4 = 0;
        goto LABEL_193;
      }
    }
    v7 += 168;
  }
  while (v7 != v8);
  uint64_t v10 = *(void *)(a2 + 160);
  uint64_t v11 = *(void *)(a2 + 168);
  uint64_t v12 = &v127;
  *(void *)uint64_t v126 = 0;
  long long v127 = 0u;
  *(void *)&v126[8] = &v127;
  if (v10 == v11)
  {
    uint8_t v55 = 0;
    goto LABEL_145;
  }
  int v112 = 0;
  int v111 = (uint64_t *)(a2 + 248);
  while (1)
  {
    (***(void (****)(uint8_t *__return_ptr))(a2 + 56))(v135);
    *(_OWORD *)std::string buf = *(_OWORD *)v135;
    memset(v135, 0, sizeof(v135));
    if (!subscriber::isValidSimSlot())
    {
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (*(void *)&v135[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v135[8]);
      }
      goto LABEL_128;
    }
    char isSimReady = subscriber::isSimReady();
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (*(void *)&v135[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v135[8]);
    }
    if (isSimReady) {
      break;
    }
LABEL_128:
    v10 += 168;
    if (v10 == v11) {
      goto LABEL_139;
    }
  }
  char v14 = (void **)(v10 + 72);
  if (*(char *)(v10 + 95) < 0)
  {
    unint64_t v15 = *(void *)(v10 + 80);
    if (!v15)
    {
LABEL_38:
      char v17 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = subscriber::asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I empty iccid for %s", buf, 0xCu);
      }
      goto LABEL_128;
    }
    sub_10004FC84(buf, *v14, v15);
  }
  else
  {
    if (!*(unsigned char *)(v10 + 95)) {
      goto LABEL_38;
    }
    *(_OWORD *)std::string buf = *(_OWORD *)v14;
    *(void *)&long long v129 = *(void *)(v10 + 88);
  }
  uint64_t v16 = sub_100046F68(a2 + 312, (void **)buf);
  if (SBYTE7(v129) < 0) {
    operator delete(*(void **)buf);
  }
  if ((void **)(a2 + 320) != v16)
  {
    if (*(char *)(v10 + 95) < 0)
    {
      sub_10004FC84(__p, *(void **)(v10 + 72), *(void *)(v10 + 80));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v14;
      uint64_t v125 = *(void *)(v10 + 88);
    }
    int v19 = sub_100CA6C24(a2, (uint64_t)__p);
    if (SHIBYTE(v125) < 0) {
      operator delete(__p[0]);
    }
    if (v19) {
      goto LABEL_138;
    }
    if (!sub_100CA6CF8(a2, (unsigned __int8 **)(v10 + 72)))
    {
      if (*((unsigned char *)v16 + 128)) {
        goto LABEL_128;
      }
      uint64_t v20 = *(void *)(a2 + 160);
      uint64_t v21 = *(void *)(a2 + 168);
      if (v20 != v21)
      {
        uint64_t v22 = v20 + 168;
        do
        {
          int isEsimCapable = subscriber::isEsimCapable();
          if (*(_DWORD *)(v22 - 104) == 5) {
            int v24 = 0;
          }
          else {
            int v24 = isEsimCapable;
          }
          if (v24) {
            break;
          }
          BOOL v25 = v22 == v21;
          v22 += 168;
        }
        while (!v25);
        if (v24)
        {
          uint64_t v26 = *(unsigned __int8 *)(v10 + 95);
          if ((v26 & 0x80u) == 0) {
            uint64_t v27 = *(unsigned __int8 *)(v10 + 95);
          }
          else {
            uint64_t v27 = *(void *)(v10 + 80);
          }
          uint64_t v28 = *(unsigned __int8 *)(a2 + 1159);
          int v29 = (char)v28;
          if ((v28 & 0x80u) != 0) {
            uint64_t v28 = *(void *)(a2 + 1144);
          }
          if (v27 == v28)
          {
            if (v29 >= 0) {
              uint64_t v30 = (unsigned __int8 *)(a2 + 1136);
            }
            else {
              uint64_t v30 = *(unsigned __int8 **)(a2 + 1136);
            }
            if ((v26 & 0x80) != 0)
            {
              if (!memcmp(*v14, v30, *(void *)(v10 + 80))) {
                goto LABEL_128;
              }
            }
            else
            {
              if (!*(unsigned char *)(v10 + 95)) {
                goto LABEL_128;
              }
              uint64_t v31 = 0;
              while (*(unsigned __int8 *)(v10 + v31 + 72) == v30[v31])
              {
                if (v26 == ++v31) {
                  goto LABEL_128;
                }
              }
            }
          }
          long long v132 = 0u;
          long long v133 = 0u;
          long long v130 = 0u;
          long long v131 = 0u;
          *(_OWORD *)std::string buf = 0u;
          long long v129 = 0u;
          sub_100CA6DF4((char *)buf, a2, *(_DWORD *)v10);
          if (!BYTE8(v133))
          {
            int v32 = *(_DWORD *)v10;
            *(_DWORD *)__int16 v135 = *(_DWORD *)v10;
            uint64_t v33 = *v111;
            if (!*v111) {
              goto LABEL_83;
            }
            uint64_t v34 = a2 + 248;
            do
            {
              int v35 = *(_DWORD *)(v33 + 28);
              BOOL v36 = v35 < v32;
              if (v35 >= v32) {
                char v37 = (uint64_t *)v33;
              }
              else {
                char v37 = (uint64_t *)(v33 + 8);
              }
              if (!v36) {
                uint64_t v34 = v33;
              }
              uint64_t v33 = *v37;
            }
            while (*v37);
            if ((uint64_t *)v34 == v111
              || *(_DWORD *)(v34 + 28) > v32
              || !*(unsigned char *)sub_10012EF5C(a2 + 240, (int *)v135))
            {
LABEL_83:
              if (!sub_10010E128(a2 + 1176, (void **)(v10 + 72)))
              {
                int v106 = *(NSObject **)(a2 + 40);
                if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v107 = subscriber::asString();
                  *(_DWORD *)__int16 v135 = 136315138;
                  *(void *)&v135[4] = v107;
                  _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "#I empty phone number for (%s)", v135, 0xCu);
                }
                sub_100CC2224((uint64_t)buf);
                goto LABEL_139;
              }
            }
          }
          sub_100CC2224((uint64_t)buf);
        }
      }
      memset(v135, 0, sizeof(v135));
      uint64_t v136 = 0;
      sub_100CA6EAC(v135, (void *)a2, (void **)(v10 + 72), *(_DWORD *)v10);
      if (v136 >= 0) {
        uint64_t v38 = HIBYTE(v136);
      }
      else {
        uint64_t v38 = *(void *)&v135[8];
      }
      if (v38)
      {
        LOBYTE(v114) = v126[0];
        CFNumberRef v115 = *(long long **)&v126[8];
        long long v116 = v127;
        if (*((void *)&v127 + 1))
        {
          *(void *)(v127 + 16) = &v116;
          *(void *)&v126[8] = v12;
          *(void *)uint64_t v12 = 0;
          *((void *)v12 + 1) = 0;
        }
        else
        {
          CFNumberRef v115 = &v116;
        }
        goto LABEL_125;
      }
      uint64_t v39 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        char v40 = (void *)(v10 + 72);
        if (*(char *)(v10 + 95) < 0) {
          char v40 = *v14;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v40;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I plan [%s] is marked to launch setup", buf, 0xCu);
      }
      long long v41 = (char *)(v10 + 72);
      if (*(char *)(v10 + 95) < 0) {
        long long v41 = (char *)*v14;
      }
      *(void *)std::string buf = v10;
      unsigned int v109 = v3;
      uint64_t v42 = sub_10008CC40((uint64_t **)&v126[8], (int *)v10, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      sub_10003ED78((std::string *)(v42 + 5), v41);
      uint64_t v134 = 0;
      long long v132 = 0u;
      long long v133 = 0u;
      long long v130 = 0u;
      long long v131 = 0u;
      *(_OWORD *)std::string buf = 0u;
      long long v129 = 0u;
      (***(void (****)(Registry **__return_ptr))(a2 + 56))(&v122);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v43, v122);
      uint64_t v45 = ServiceMap;
      if (v46 < 0)
      {
        long long v47 = (unsigned __int8 *)(v46 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v48 = 5381;
        do
        {
          uint64_t v46 = v48;
          unsigned int v49 = *v47++;
          uint64_t v48 = (33 * v48) ^ v49;
        }
        while (v49);
      }
      std::mutex::lock(ServiceMap);
      __dst[0] = (void *)v46;
      uint64_t v50 = sub_10004D37C(&v45[1].__m_.__sig, (unint64_t *)__dst);
      if (v50)
      {
        unint64_t v108 = v12;
        uint64_t v52 = v50[3];
        uint64_t v51 = (std::__shared_weak_count *)v50[4];
        if (v51)
        {
          atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v45);
          atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
          char v53 = v51;
          sub_10004D2C8(v51);
          char v54 = 0;
          uint64_t v12 = v108;
LABEL_107:
          if (*(char *)(v10 + 95) < 0)
          {
            sub_10004FC84(__dst, *(void **)(v10 + 72), *(void *)(v10 + 80));
          }
          else
          {
            *(_OWORD *)long long __dst = *(_OWORD *)v14;
            uint64_t v121 = *(void *)(v10 + 88);
          }
          (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v52 + 176))(buf, v52, __dst);
          uint64_t v3 = v109;
          if (SHIBYTE(v121) < 0) {
            operator delete(__dst[0]);
          }
          if ((v54 & 1) == 0) {
            sub_10004D2C8(v53);
          }
          if (v123) {
            sub_10004D2C8(v123);
          }
          uint64_t v38 = 0;
          if (SHIBYTE(v134) < 0) {
            operator delete((void *)v133);
          }
          if (SBYTE7(v132) < 0) {
            operator delete((void *)v131);
          }
          if (SHIBYTE(v130) < 0) {
            operator delete(*((void **)&v129 + 1));
          }
          if (SBYTE7(v129) < 0) {
            operator delete(*(void **)buf);
          }
          ++v112;
LABEL_125:
          if (SHIBYTE(v136) < 0) {
            operator delete(*(void **)v135);
          }
          if (v38) {
            goto LABEL_148;
          }
          goto LABEL_128;
        }
        uint64_t v12 = v108;
      }
      else
      {
        uint64_t v52 = 0;
      }
      std::mutex::unlock(v45);
      char v53 = 0;
      char v54 = 1;
      goto LABEL_107;
    }
    long long v67 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      long long v68 = (void *)(v10 + 72);
      if (*(char *)(v10 + 95) < 0) {
        long long v68 = *v14;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v68;
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I Do not launch SIMSetup with offload sim present, marking [%s] as setup", buf, 0xCu);
    }
    (***(void (****)(uint8_t *__return_ptr))(a2 + 56))(v135);
    long long v70 = (std::mutex *)Registry::getServiceMap(v69, *(Registry **)v135);
    long long v71 = v70;
    uint64_t v113 = v72;
    if (v72 < 0)
    {
      long long v73 = (unsigned __int8 *)(v72 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v74 = 5381;
      do
      {
        uint64_t v72 = v74;
        unsigned int v75 = *v73++;
        uint64_t v74 = (33 * v74) ^ v75;
      }
      while (v75);
    }
    std::mutex::lock(v70);
    *(void *)std::string buf = v72;
    uint64_t v76 = sub_10004D37C(&v71[1].__m_.__sig, (unint64_t *)buf);
    if (v76)
    {
      uint64_t v78 = v76[3];
      size_t v77 = (std::__shared_weak_count *)v76[4];
      if (v77)
      {
        atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v71);
        atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v77);
        char v79 = 0;
        goto LABEL_196;
      }
    }
    else
    {
      uint64_t v78 = 0;
    }
    std::mutex::unlock(v71);
    size_t v77 = 0;
    char v79 = 1;
LABEL_196:
    if (*(char *)(v10 + 95) < 0)
    {
      sub_10004FC84(buf, *(void **)(v10 + 72), *(void *)(v10 + 80));
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)v14;
      *(void *)&long long v129 = *(void *)(v10 + 88);
    }
    (*(void (**)(uint64_t, uint8_t *, uint64_t))(*(void *)v78 + 232))(v78, buf, 1);
    if (SBYTE7(v129) < 0) {
      operator delete(*(void **)buf);
    }
    if ((v79 & 1) == 0) {
      sub_10004D2C8(v77);
    }
    if (*(void *)&v135[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v135[8]);
    }
    uint8_t v85 = *(void **)(a2 + 216);
    uint64_t v86 = (void *)(a2 + 224);
    if (v85 == (void *)(a2 + 224))
    {
LABEL_246:
      uint64_t v114 = 0;
      long long v116 = 0u;
      CFNumberRef v115 = &v116;
      goto LABEL_148;
    }
    unint64_t v110 = v3;
    while (1)
    {
      uint64_t v87 = *(unsigned __int8 *)(v10 + 95);
      if ((v87 & 0x80u) == 0) {
        uint64_t v88 = *(unsigned __int8 *)(v10 + 95);
      }
      else {
        uint64_t v88 = *(void *)(v10 + 80);
      }
      uint64_t v89 = *((unsigned __int8 *)v85 + 79);
      int v90 = (char)v89;
      if ((v89 & 0x80u) != 0) {
        uint64_t v89 = v85[8];
      }
      if (v88 != v89) {
        goto LABEL_240;
      }
      unint64_t v91 = v90 >= 0 ? (unsigned __int8 *)(v85 + 7) : (unsigned __int8 *)v85[7];
      if ((v87 & 0x80) == 0) {
        break;
      }
      if (!memcmp(*v14, v91, *(void *)(v10 + 80))) {
        goto LABEL_223;
      }
LABEL_240:
      unint64_t v104 = (void *)v85[1];
      if (v104)
      {
        do
        {
          int v105 = v104;
          unint64_t v104 = (void *)*v104;
        }
        while (v104);
      }
      else
      {
        do
        {
          int v105 = (void *)v85[2];
          BOOL v25 = *v105 == (void)v85;
          uint8_t v85 = v105;
        }
        while (!v25);
      }
      uint8_t v85 = v105;
      if (v105 == v86) {
        goto LABEL_246;
      }
    }
    if (*(unsigned char *)(v10 + 95))
    {
      uint64_t v92 = 0;
      while (*(unsigned __int8 *)(v10 + v92 + 72) == v91[v92])
      {
        if (v87 == ++v92) {
          goto LABEL_223;
        }
      }
      goto LABEL_240;
    }
LABEL_223:
    (***(void (****)(uint8_t *__return_ptr))(a2 + 56))(v135);
    uint64_t v94 = (std::mutex *)Registry::getServiceMap(v93, *(Registry **)v135);
    unsigned int v95 = v94;
    uint64_t v96 = v113;
    if (v113 < 0)
    {
      int v97 = (unsigned __int8 *)(v113 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v98 = 5381;
      do
      {
        uint64_t v96 = v98;
        unsigned int v99 = *v97++;
        uint64_t v98 = (33 * v98) ^ v99;
      }
      while (v99);
    }
    std::mutex::lock(v94);
    *(void *)std::string buf = v96;
    int v100 = sub_10004D37C(&v95[1].__m_.__sig, (unint64_t *)buf);
    if (v100)
    {
      uint64_t v102 = v100[3];
      BOOL v101 = (std::__shared_weak_count *)v100[4];
      if (v101)
      {
        atomic_fetch_add_explicit(&v101->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v95);
        atomic_fetch_add_explicit(&v101->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v3 = v110;
        sub_10004D2C8(v101);
        char v103 = 0;
LABEL_231:
        if (*((char *)v85 + 55) < 0)
        {
          sub_10004FC84(buf, (void *)v85[4], v85[5]);
        }
        else
        {
          *(_OWORD *)std::string buf = *((_OWORD *)v85 + 2);
          *(void *)&long long v129 = v85[6];
        }
        (*(void (**)(uint64_t, uint8_t *, uint64_t))(*(void *)v102 + 232))(v102, buf, 1);
        uint64_t v86 = (void *)(a2 + 224);
        if (SBYTE7(v129) < 0) {
          operator delete(*(void **)buf);
        }
        if ((v103 & 1) == 0) {
          sub_10004D2C8(v101);
        }
        if (*(void *)&v135[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v135[8]);
        }
        goto LABEL_240;
      }
    }
    else
    {
      uint64_t v102 = 0;
    }
    std::mutex::unlock(v95);
    BOOL v101 = 0;
    char v103 = 1;
    goto LABEL_231;
  }
  BOOL v57 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(v10 + 95) < 0) {
      char v14 = (void **)*v14;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I No label for (%s) - force wait update", buf, 0xCu);
  }
LABEL_138:
  v126[0] = 0;
LABEL_139:
  if (v112 == 1)
  {
    uint8_t v55 = 8;
LABEL_143:
    v126[0] = v55;
  }
  else
  {
    if (v112 == 2)
    {
      uint8_t v55 = 1;
      goto LABEL_143;
    }
    uint8_t v55 = v126[0];
  }
LABEL_145:
  LOBYTE(v114) = v55;
  CFNumberRef v115 = *(long long **)&v126[8];
  long long v116 = v127;
  if (*((void *)&v127 + 1))
  {
    *(void *)(v127 + 16) = &v116;
    *(void *)&v126[8] = v12;
    *(void *)uint64_t v12 = 0;
    *((void *)v12 + 1) = 0;
  }
  else
  {
    CFNumberRef v115 = &v116;
  }
LABEL_148:
  sub_1000886C0((uint64_t)&v126[8], (char *)v127);
  LOBYTE(v117) = v114;
  sub_1000886C0((uint64_t)v3, (char *)v119);
  uint64_t v58 = (char *)v116;
  uint64_t v118 = v115;
  long long v119 = v116;
  if (*((void *)&v116 + 1))
  {
    *(void *)(v116 + 16) = &v119;
    CFNumberRef v115 = &v116;
    long long v116 = 0uLL;
    uint64_t v58 = 0;
  }
  else
  {
    uint64_t v118 = &v119;
  }
  sub_1000886C0((uint64_t)&v115, v58);
  if ((_BYTE)v117)
  {
    *(unsigned char *)a1 = v117;
    uint64_t v4 = v119;
    *(void *)(a1 + 8) = v118;
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = a1 + 16;
    uint64_t v59 = *((void *)&v119 + 1);
    *(void *)(a1 + 24) = *((void *)&v119 + 1);
    if (!v59)
    {
      *(void *)(a1 + 8) = v5;
      goto LABEL_193;
    }
    goto LABEL_153;
  }
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)(a1 + 8) = a1 + 16;
  uint64_t v60 = *(void *)(a2 + 160);
  uint64_t v61 = *(void *)(a2 + 168);
  while (v60 != v61)
  {
    if (sub_100CA6CF8(a2, (unsigned __int8 **)(v60 + 72)))
    {
      unsigned int v63 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "#I Do not launch SIMSetup for Preferences with offload sim present, return empty flow info", buf, 2u);
      }
      goto LABEL_192;
    }
    v60 += 168;
  }
  LOBYTE(v114) = 0;
  LOBYTE(__p[0]) = 0;
  sub_100CA8010((uint64_t *)v126, a2);
  sub_100CA7400((std::string *)buf, a2, &v114, __p, (std::string **)v126);
  sub_10005CD2C((uint64_t)v126, *(char **)&v126[8]);
  if ((_BYTE)v114)
  {
    if (LOBYTE(__p[0]))
    {
      if (BYTE8(v132))
      {
        sub_100CA80B8(a2, (uint64_t)buf);
        if (*(char *)(a2 + 895) < 0) {
          uint64_t v62 = *(void *)(a2 + 880);
        }
        else {
          uint64_t v62 = *(unsigned __int8 *)(a2 + 895);
        }
        if (v62)
        {
          uint64_t v80 = *(std::__shared_weak_count **)(a2 + 80);
          if (v80)
          {
            int v81 = std::__shared_weak_count::lock(v80);
            if (v81)
            {
              uint64_t v82 = v81;
              uint64_t v83 = *(void *)(a2 + 72);
              if (v83)
              {
                uint64_t v84 = sub_100CA8388((void *)a2, (unsigned __int8 *)(a2 + 872));
                (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v83 + 32))(v83, v84, a2 + 872);
              }
              sub_10004D2C8(v82);
            }
          }
        }
        sub_100CA85A0(a2);
      }
      else
      {
        long long v66 = *(NSObject **)(a2 + 40);
        if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v126 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "preferences matched, but unknown???", v126, 2u);
        }
      }
    }
    else
    {
      long long v65 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v126 = 0;
        _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#I need to launch SIMSetup to setup preferences other than labels", v126, 2u);
      }
      *(unsigned char *)a1 = 1;
    }
  }
  else
  {
    uint64_t v64 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v126 = 0;
      _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I source device preferences unknown, do not launch SIMSetup", v126, 2u);
    }
  }
  sub_1008618BC((uint64_t)buf);
LABEL_192:
  uint64_t v4 = v119;
LABEL_193:
  sub_1000886C0((uint64_t)v3, (char *)v4);
}

void sub_100CA6A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char *a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,char a47,uint64_t a48,char *a49)
{
  sub_100CC2224(v50 - 240);
  sub_1000886C0(a20, a49);
  sub_1000886C0(v49, a29);
  _Unwind_Resume(a1);
}

uint64_t sub_100CA6C24(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
  }
  sub_100CB60FC(a1, (uint64_t)__p, (uint64_t)v7);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v3 = v7[88];
  sub_1000C584C((uint64_t)v7);
  return v3;
}

void sub_100CA6CD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_100CA6CF8(uint64_t a1, unsigned __int8 **a2)
{
  int v2 = *((char *)a2 + 23);
  if (v2 >= 0) {
    uint64_t v3 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v3 = a2[1];
  }
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void **)(a1 + 216);
  uint64_t v5 = (void *)(a1 + 224);
  if (v4 == (void *)(a1 + 224)) {
    return 0;
  }
  if (v2 >= 0) {
    uint64_t v6 = (unsigned __int8 *)a2;
  }
  else {
    uint64_t v6 = *a2;
  }
  while (1)
  {
    uint64_t v7 = *((unsigned __int8 *)v4 + 79);
    if ((v7 & 0x80u) == 0) {
      uint64_t v8 = (unsigned __int8 *)*((unsigned __int8 *)v4 + 79);
    }
    else {
      uint64_t v8 = (unsigned __int8 *)v4[8];
    }
    if (v8 != v3) {
      goto LABEL_20;
    }
    long long v9 = (const void **)(v4 + 7);
    if ((v7 & 0x80) != 0) {
      break;
    }
    if (!*((unsigned char *)v4 + 79)) {
      return 1;
    }
    for (CFIndex i = v6; *(unsigned __int8 *)v9 == *i; ++i)
    {
      long long v9 = (const void **)((char *)v9 + 1);
      if (!--v7) {
        return 1;
      }
    }
LABEL_20:
    uint64_t v11 = (void *)v4[1];
    if (v11)
    {
      do
      {
        uint64_t v12 = v11;
        uint64_t v11 = (void *)*v11;
      }
      while (v11);
    }
    else
    {
      do
      {
        uint64_t v12 = (void *)v4[2];
        BOOL v13 = *v12 == (void)v4;
        uint64_t v4 = v12;
      }
      while (!v13);
    }
    uint64_t v4 = v12;
    if (v12 == v5) {
      return 0;
    }
  }
  if (memcmp(*v9, v6, v4[8])) {
    goto LABEL_20;
  }
  return 1;
}

char *sub_100CA6DF4(char *result, uint64_t a2, int a3)
{
  uint64_t v5 = *(uint64_t **)(a2 + 192);
  uint64_t v3 = (uint64_t *)(a2 + 192);
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_21;
  }
  uint64_t v6 = v3;
  uint64_t v7 = v4;
  do
  {
    int v8 = *((_DWORD *)v7 + 8);
    BOOL v9 = v8 < a3;
    if (v8 >= a3) {
      uint64_t v10 = (uint64_t **)v7;
    }
    else {
      uint64_t v10 = (uint64_t **)(v7 + 1);
    }
    if (!v9) {
      uint64_t v6 = v7;
    }
    uint64_t v7 = *v10;
  }
  while (*v10);
  if (v6 == v3 || *((_DWORD *)v6 + 8) > a3) {
    goto LABEL_21;
  }
  if ((*((char *)v6 + 87) & 0x80000000) == 0)
  {
    if (*((unsigned char *)v6 + 87)) {
      goto LABEL_13;
    }
    goto LABEL_21;
  }
  if (!v6[9])
  {
LABEL_21:
    char v12 = 0;
    *uint64_t result = 0;
    goto LABEL_22;
  }
  while (1)
  {
LABEL_13:
    while (1)
    {
      int v11 = *((_DWORD *)v4 + 8);
      if (v11 <= a3) {
        break;
      }
      uint64_t v4 = (uint64_t *)*v4;
      if (!v4) {
        goto LABEL_19;
      }
    }
    if (v11 >= a3) {
      break;
    }
    uint64_t v4 = (uint64_t *)v4[1];
    if (!v4) {
LABEL_19:
    }
      sub_1000C14F0("map::at:  key not found");
  }
  uint64_t result = sub_100897414(result, (long long *)(v4 + 5));
  char v12 = 1;
LABEL_22:
  result[88] = v12;
  return result;
}

void sub_100CA6EAC(void *a1, void *a2, void **a3, int a4)
{
  uint64_t v7 = (uint64_t)a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v8 = (std::__shared_weak_count *)a2[10];
  if (!v8) {
    goto LABEL_27;
  }
  BOOL v9 = std::__shared_weak_count::lock(v8);
  if (!v9) {
    goto LABEL_27;
  }
  uint64_t v10 = v9;
  uint64_t v11 = a2[9];
  if (v11)
  {
    (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)v11 + 104))(&v42);
    if (v52)
    {
      memset(&v59, 0, 24);
      if (v51)
      {
        char v12 = (const std::string *)v50;
      }
      else
      {
        if (BYTE1(v42.var0) != 12)
        {
LABEL_10:
          int v13 = sub_100CB1134((uint64_t)a2, (uint64_t)&v59);
          int v14 = v13;
          if (v59.var2.__r_.__value_.var0.var0.__data_[15] < 0)
          {
            operator delete(*(void **)&v59.var0);
            if (v14) {
              goto LABEL_12;
            }
          }
          else if (v13)
          {
LABEL_12:
            if (v51) {
              unint64_t v15 = (const std::string *)v50;
            }
            else {
              unint64_t v15 = (const std::string *)v49;
            }
            std::string::operator=((std::string *)v7, v15);
            sub_100CC1D8C((uint64_t)a2, a3, v7);
            uint64_t v16 = a2[5];
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              if (*(char *)(v7 + 23) >= 0) {
                char v17 = (void *)v7;
              }
              else {
                char v17 = *(void **)v7;
              }
              v59.var0 = 136315138;
              *(void *)&v59.var1 = v17;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Cold SIM (%s) is moved over after transfer", (uint8_t *)&v59, 0xCu);
            }
            if (v52) {
              sub_10030D10C((uint64_t)&v42);
            }
            sub_10004D2C8(v10);
            return;
          }
          if (v52) {
            sub_10030D10C((uint64_t)&v42);
          }
          goto LABEL_26;
        }
        char v12 = (const std::string *)v49;
      }
      std::string::operator=((std::string *)&v59, v12);
      goto LABEL_10;
    }
  }
LABEL_26:
  sub_10004D2C8(v10);
LABEL_27:
  long long v41 = 0u;
  memset(v40, 0, sizeof(v40));
  sub_100CA6DF4((char *)v40, (uint64_t)a2, a4);
  if (BYTE8(v41))
  {
    uint64_t v19 = a2[20];
    uint64_t v18 = a2[21];
    if (v19 != v18)
    {
      uint64_t v20 = (char *)&v40[1] + 8;
      long long v21 = 0uLL;
      uint64_t v31 = v7;
      do
      {
        if (*(_DWORD *)v19 != a4)
        {
          long long v38 = v21;
          long long v39 = v21;
          long long v36 = v21;
          long long v37 = v21;
          long long v34 = v21;
          long long v35 = v21;
          sub_100CA6DF4((char *)&v34, (uint64_t)a2, *(_DWORD *)v19);
          if (BYTE8(v39))
          {
            uint64_t v48 = 0;
            long long v46 = 0u;
            long long v47 = 0u;
            *(_OWORD *)uint64_t v44 = 0u;
            *(_OWORD *)long long __p = 0u;
            long long v43 = 0u;
            memset(&v42, 0, sizeof(v42));
            CSIPhoneNumber::CSIPhoneNumber();
            uint64_t v65 = 0;
            long long v63 = 0u;
            long long v64 = 0u;
            long long v61 = 0u;
            long long v62 = 0u;
            long long v60 = 0u;
            memset(&v59, 0, sizeof(v59));
            CSIPhoneNumber::CSIPhoneNumber();
            int isOriginalNumberSame = CSIPhoneNumber::isOriginalNumberSame(&v42, &v59);
            char v23 = isOriginalNumberSame;
            if (isOriginalNumberSame)
            {
              int v24 = a2[5];
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
              {
                BOOL v25 = v20;
                uint64_t v26 = a3;
                uint64_t v27 = subscriber::asString();
                uint64_t v28 = subscriber::asString();
                if (v36 >= 0) {
                  int v29 = (char *)&v35 + 8;
                }
                else {
                  int v29 = (char *)*((void *)&v35 + 1);
                }
                *(_DWORD *)std::string buf = 136315650;
                uint64_t v54 = v27;
                __int16 v55 = 2080;
                uint64_t v56 = v28;
                __int16 v57 = 2080;
                uint64_t v58 = v29;
                _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Slot %s and %s have same phone number %s", buf, 0x20u);
                a3 = v26;
                uint64_t v20 = v25;
                uint64_t v7 = v31;
              }
              if (*(char *)(v19 + 95) < 0)
              {
                sub_10004FC84(&__dst, *(void **)(v19 + 72), *(void *)(v19 + 80));
              }
              else
              {
                long long v30 = *(_OWORD *)(v19 + 72);
                uint64_t v33 = *(void *)(v19 + 88);
                long long __dst = v30;
              }
            }
            if (SHIBYTE(v63) < 0) {
              operator delete(*((void **)&v62 + 1));
            }
            if (SBYTE7(v62) < 0) {
              operator delete((void *)v61);
            }
            if (SBYTE7(v60) < 0) {
              operator delete(*(void **)&v59.var2.__r_.var0);
            }
            if (*((char *)&v59.var2.__r_.__value_.var0.var1 + 23) < 0) {
              operator delete(v59.var2.__r_.__value_.var0.var1.__data_);
            }
            if (SHIBYTE(v46) < 0) {
              operator delete(__p[1]);
            }
            if (SHIBYTE(__p[0]) < 0) {
              operator delete(v44[0]);
            }
            if (SBYTE7(v43) < 0) {
              operator delete(*(void **)&v42.var2.__r_.var0);
            }
            if (*((char *)&v42.var2.__r_.__value_.var0.var1 + 23) < 0) {
              operator delete(v42.var2.__r_.__value_.var0.var1.__data_);
            }
            sub_100CC2224((uint64_t)&v34);
            long long v21 = 0uLL;
            if (v23) {
              goto LABEL_61;
            }
          }
          else
          {
            sub_100CC2224((uint64_t)&v34);
            long long v21 = 0uLL;
          }
        }
        v19 += 168;
      }
      while (v19 != v18);
    }
  }
  sub_100058DB0(&__dst, "");
LABEL_61:
  sub_100CC2224((uint64_t)v40);
  if (*(char *)(v7 + 23) < 0) {
    operator delete(*(void **)v7);
  }
  *(_OWORD *)uint64_t v7 = __dst;
  *(void *)(v7 + 16) = v33;
  sub_100CC1D8C((uint64_t)a2, a3, v7);
}

void sub_100CA733C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  if (LOBYTE(STACK[0x5E0])) {
    sub_10030D10C((uint64_t)&a41);
  }
  sub_10004D2C8(v42);
  if (*(char *)(v41 + 23) < 0) {
    operator delete(*(void **)v41);
  }
  _Unwind_Resume(a1);
}

void sub_100CA7400(std::string *a1, uint64_t a2, unsigned char *a3, unsigned char *a4, std::string **a5)
{
  *a3 = 0;
  *a4 = 0;
  if (*(_DWORD *)(a2 + 336) <= 1u)
  {
    a1->__r_.__value_.__s.__data_[0] = 0;
    a1[3].__r_.__value_.__s.__data_[0] = 0;
    return;
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a2 + 80);
  if (!v7)
  {
    char v12 = 0;
    goto LABEL_48;
  }
  uint64_t v11 = std::__shared_weak_count::lock(v7);
  char v12 = v11;
  if (!v11 || (uint64_t v13 = *(void *)(a2 + 72)) == 0)
  {
LABEL_48:
    uint64_t v27 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "delegate is not available to apply user preferences", (uint8_t *)&__p, 2u);
    }
    a1->__r_.__value_.__s.__data_[0] = 0;
    a1[3].__r_.__value_.__s.__data_[0] = 0;
    if (!v12) {
      return;
    }
    goto LABEL_51;
  }
  int v14 = *(std::string **)(a2 + 992);
  if (!v14)
  {
    a1->__r_.__value_.__s.__data_[0] = 0;
    a1[3].__r_.__value_.__s.__data_[0] = 0;
    goto LABEL_51;
  }
  v77[0] = 0;
  v77[1] = 0;
  v76.__r_.__value_.__r.__words[2] = (std::string::size_type)v77;
  unsigned int v75 = &v76;
  *(_OWORD *)&v76.__r_.__value_.__l.__data_ = 0uLL;
  long long v63 = a5;
  unint64_t v15 = *a5;
  long long v64 = v11;
  uint64_t v65 = (std::string *)(a5 + 1);
  if (*a5 == (std::string *)(a5 + 1))
  {
LABEL_29:
    if (v14 != a5[2])
    {
      a1->__r_.__value_.__s.__data_[0] = 0;
      a1[3].__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_132;
    }
    *a3 = 1;
    long long v73 = 0;
    v74[0] = 0;
    v74[1] = 0;
    sub_100346B40((uint64_t)&v73, a2 + 976);
    v72[0] = 0;
    v72[1] = 0;
    v71.__r_.__value_.__r.__words[2] = (std::string::size_type)v72;
    v70.__r_.__value_.__r.__words[2] = (std::string::size_type)&v71;
    *(_OWORD *)&v71.__r_.__value_.__l.__data_ = 0uLL;
    *(_OWORD *)&v70.__r_.__value_.__l.__data_ = 0uLL;
    long long v69 = &v70;
    uint64_t v22 = v73;
    if (v73 == (uint64_t *)v74)
    {
      std::string::size_type size = 0;
    }
    else
    {
      do
      {
        (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t *))(*(void *)v13 + 104))(&__p, v13, v22 + 4);
        if (!v86) {
          goto LABEL_36;
        }
        uint64_t v23 = v85;
        if ((v85 & 0x80u) != 0) {
          uint64_t v23 = *((void *)&v84 + 1);
        }
        if (v23)
        {
          sub_10010E5A0((uint64_t **)&v71.__r_.__value_.__r.__words[2], (void **)v22 + 4, (long long *)v22 + 2, &v84);
          sub_100046BAC((uint64_t **)&v70.__r_.__value_.__r.__words[2], (void **)&v84, (uint64_t)&v84);
        }
        else
        {
LABEL_36:
          sub_10010E5A0((uint64_t **)&v71.__r_.__value_.__r.__words[2], (void **)v22 + 4, (long long *)v22 + 2, (long long *)v22 + 2);
          sub_100046BAC((uint64_t **)&v70.__r_.__value_.__r.__words[2], (void **)v22 + 4, (uint64_t)(v22 + 4));
        }
        sub_100046BAC((uint64_t **)&v69, (void **)v22 + 7, (uint64_t)(v22 + 7));
        if (v86) {
          sub_10030D10C((uint64_t)&__p);
        }
        int v24 = (uint64_t *)v22[1];
        if (v24)
        {
          do
          {
            BOOL v25 = v24;
            int v24 = (uint64_t *)*v24;
          }
          while (v24);
        }
        else
        {
          do
          {
            BOOL v25 = (uint64_t *)v22[2];
            BOOL v21 = *v25 == (void)v22;
            uint64_t v22 = v25;
          }
          while (!v21);
        }
        uint64_t v22 = v25;
      }
      while (v25 != (uint64_t *)v74);
      std::string::size_type size = v71.__r_.__value_.__l.__size_;
    }
    if (v63[2] == (std::string *)size)
    {
      long long v30 = *v63;
      if (*v63 == v65)
      {
        int v32 = 1;
      }
      else
      {
        uint64_t v31 = (unsigned __int8 *)v70.__r_.__value_.__r.__words[2];
        do
        {
          int v32 = sub_1000609C0((uint64_t)&__p, (unsigned __int8 *)&v30[1].__r_.__value_.__s.__data_[8], v31 + 32);
          if (!v32) {
            break;
          }
          uint64_t v33 = (std::string *)v30->__r_.__value_.__l.__size_;
          long long v34 = v30;
          if (v33)
          {
            do
            {
              long long v30 = v33;
              uint64_t v33 = (std::string *)v33->__r_.__value_.__r.__words[0];
            }
            while (v33);
          }
          else
          {
            do
            {
              long long v30 = (std::string *)v34->__r_.__value_.__r.__words[2];
              BOOL v21 = v30->__r_.__value_.__r.__words[0] == (void)v34;
              long long v34 = v30;
            }
            while (!v21);
          }
          long long v35 = (unsigned __int8 *)*((void *)v31 + 1);
          if (v35)
          {
            do
            {
              long long v36 = v35;
              long long v35 = *(unsigned __int8 **)v35;
            }
            while (v35);
          }
          else
          {
            do
            {
              long long v36 = (unsigned __int8 *)*((void *)v31 + 2);
              BOOL v21 = *(void *)v36 == (void)v31;
              uint64_t v31 = v36;
            }
            while (!v21);
          }
          uint64_t v31 = v36;
        }
        while (v30 != v65);
      }
    }
    else
    {
      int v32 = 0;
    }
    long long v37 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      long long v38 = "no";
      if (v32) {
        long long v38 = "yes";
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I device has same active equivalent iccids as source device: %s", (uint8_t *)&__p, 0xCu);
    }
    int v39 = sub_100CD7498(&v75, &v69);
    char v40 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = "no";
      if (v39) {
        uint64_t v41 = "yes";
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v41;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I device has same phone numbers as source device: %s", (uint8_t *)&__p, 0xCu);
    }
    memset(&__str, 0, sizeof(__str));
    memset(&v67, 0, sizeof(v67));
    if (v32)
    {
      __p.__r_.__value_.__r.__words[0] = a2 + 1000;
      char v12 = v64;
      CSIPhoneNumber v42 = sub_100366370((uint64_t **)&v71.__r_.__value_.__r.__words[2], (void **)(a2 + 1000), (uint64_t)&unk_10144E20E, (long long **)&__p);
      std::string::operator=(&__str, (const std::string *)(v42 + 7));
      __p.__r_.__value_.__r.__words[0] = a2 + 1024;
      long long v43 = sub_100366370((uint64_t **)&v71.__r_.__value_.__r.__words[2], (void **)(a2 + 1024), (uint64_t)&unk_10144E20E, (long long **)&__p);
    }
    else
    {
      if (!v39)
      {
        uint64_t v54 = *(NSObject **)(a2 + 40);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          sub_1000E8F34((std::string *)v70.__r_.__value_.__r.__words[2], &v71, ",", 1uLL, &__p);
          int v55 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
          std::string::size_type v56 = __p.__r_.__value_.__r.__words[0];
          char v12 = v64;
          sub_1000E8F34(*v63, v65, ",", 1uLL, &v66);
          p_p = &__p;
          if (v55 < 0) {
            p_p = (std::string *)v56;
          }
          if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v58 = &v66;
          }
          else {
            uint64_t v58 = (std::string *)v66.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315394;
          char v79 = p_p;
          __int16 v80 = 2080;
          int v81 = v58;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I source iccids: [%s], device iccids: [%s]", buf, 0x16u);
          if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v66.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          uint64_t v54 = *(NSObject **)(a2 + 40);
        }
        else
        {
          char v12 = v64;
        }
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          sub_1000E8F34(v69, &v70, ",", 1uLL, &__p);
          int v59 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
          std::string::size_type v60 = __p.__r_.__value_.__r.__words[0];
          sub_1000E8F34(v75, &v76, ",", 1uLL, &v66);
          long long v61 = &__p;
          if (v59 < 0) {
            long long v61 = (std::string *)v60;
          }
          if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v62 = &v66;
          }
          else {
            long long v62 = (std::string *)v66.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315394;
          char v79 = v61;
          __int16 v80 = 2080;
          int v81 = v62;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I source phone numbers: [%s], device phone numbers: [%s]", buf, 0x16u);
          if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v66.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        goto LABEL_97;
      }
      __p.__r_.__value_.__r.__words[0] = a2 + 1000;
      char v12 = v64;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)(sub_100366370(&v73, (void **)(a2 + 1000), (uint64_t)&unk_10144E20E, (long long **)&__p)+ 7);
      uint64_t v44 = sub_100366370((uint64_t **)&v76.__r_.__value_.__r.__words[2], (void **)__p.__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, (long long **)&__p);
      std::string::operator=(&__str, (const std::string *)(v44 + 7));
      __p.__r_.__value_.__r.__words[0] = a2 + 1024;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)(sub_100366370(&v73, (void **)(a2 + 1024), (uint64_t)&unk_10144E20E, (long long **)&__p)+ 7);
      long long v43 = sub_100366370((uint64_t **)&v76.__r_.__value_.__r.__words[2], (void **)__p.__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, (long long **)&__p);
    }
    std::string::operator=(&v67, (const std::string *)(v43 + 7));
LABEL_97:
    uint64_t v45 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      p_str = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      long long v47 = &v67;
      if ((v67.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v47 = (std::string *)v67.__r_.__value_.__r.__words[0];
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_str;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v47;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I based on source, data sim should be [%s], voice sim should be [%s]", (uint8_t *)&__p, 0x16u);
    }
    std::string::size_type v48 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v48 = __str.__r_.__value_.__l.__size_;
    }
    if (!v48) {
      goto LABEL_111;
    }
    std::string::size_type v49 = HIBYTE(v67.__r_.__value_.__r.__words[2]);
    if ((v67.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v49 = v67.__r_.__value_.__l.__size_;
    }
    if (v49)
    {
      *a4 = 1;
      *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
      memset(v83, 0, 48);
      std::string::operator=(v83, &__str);
      std::string::operator=(&v83[1], &v67);
      std::string::size_type v50 = __p.__r_.__value_.__l.__size_;
      a1->__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0];
      a1->__r_.__value_.__l.__size_ = v50;
      p_std::string::size_type size = &a1->__r_.__value_.__l.__size_;
      std::string::size_type v52 = __p.__r_.__value_.__r.__words[2];
      a1->__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[2];
      if (v52)
      {
        *(void *)(v50 + 16) = p_size;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
        *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
      }
      else
      {
        a1->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
      }
      a1[1] = v83[0];
      memset(v83, 0, 24);
      a1[2] = v83[1];
      memset(&v83[1], 0, sizeof(std::string));
      a1[3].__r_.__value_.__s.__data_[0] = 1;
      sub_10085D480((uint64_t)&__p);
    }
    else
    {
LABEL_111:
      char v53 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I source device preferences not matching", (uint8_t *)&__p, 2u);
      }
      a1->__r_.__value_.__s.__data_[0] = 0;
      a1[3].__r_.__value_.__s.__data_[0] = 0;
    }
    if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v67.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    sub_10005CD2C((uint64_t)&v69, v70.__r_.__value_.__l.__data_);
    sub_10005CD2C((uint64_t)&v70.__r_.__value_.__r.__words[2], v71.__r_.__value_.__l.__data_);
    sub_10010C0E0((uint64_t)&v71.__r_.__value_.__r.__words[2], v72[0]);
    sub_10010C0E0((uint64_t)&v73, v74[0]);
    goto LABEL_132;
  }
  while (1)
  {
    uint64_t v16 = &v15[1].__r_.__value_.__l.__size_;
    if (v15[2].__r_.__value_.__s.__data_[7] < 0)
    {
      sub_10004FC84(&__p, (void *)v15[1].__r_.__value_.__l.__size_, v15[1].__r_.__value_.__r.__words[2]);
    }
    else
    {
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)v16;
      __p.__r_.__value_.__r.__words[2] = v15[2].__r_.__value_.__r.__words[0];
    }
    char v17 = sub_100046F68(a2 + 312, (void **)&__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if ((void **)(a2 + 320) == v17)
    {
      uint64_t v28 = *(NSObject **)(a2 + 40);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_64;
      }
      if (v15[2].__r_.__value_.__s.__data_[7] < 0) {
        uint64_t v16 = (std::string::size_type *)*v16;
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
      int v29 = "#I plan [%s] doesn't have a label assigned yet";
      goto LABEL_63;
    }
    if (*((char *)v17 + 127) < 0) {
      break;
    }
    if (!*((unsigned char *)v17 + 127)) {
      goto LABEL_59;
    }
LABEL_17:
    if ((*((char *)v17 + 159) & 0x80000000) == 0)
    {
      if (!*((unsigned char *)v17 + 159)) {
        goto LABEL_22;
      }
LABEL_21:
      uint64_t v18 = v17 + 17;
      sub_10010E5A0((uint64_t **)&v76.__r_.__value_.__r.__words[2], v18, (long long *)v18, (long long *)&v15[1].__r_.__value_.__r.__words[1]);
      sub_100046BAC((uint64_t **)&v75, v18, (uint64_t)v18);
      goto LABEL_22;
    }
    if (v17[18]) {
      goto LABEL_21;
    }
LABEL_22:
    uint64_t v19 = (std::string *)v15->__r_.__value_.__l.__size_;
    if (v19)
    {
      do
      {
        uint64_t v20 = v19;
        uint64_t v19 = (std::string *)v19->__r_.__value_.__r.__words[0];
      }
      while (v19);
    }
    else
    {
      do
      {
        uint64_t v20 = (std::string *)v15->__r_.__value_.__r.__words[2];
        BOOL v21 = v20->__r_.__value_.__r.__words[0] == (void)v15;
        unint64_t v15 = v20;
      }
      while (!v21);
    }
    unint64_t v15 = v20;
    if (v20 == v65)
    {
      int v14 = *(std::string **)(a2 + 992);
      a5 = v63;
      char v12 = v64;
      goto LABEL_29;
    }
  }
  if (v17[14]) {
    goto LABEL_17;
  }
LABEL_59:
  uint64_t v28 = *(NSObject **)(a2 + 40);
  if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_64;
  }
  if (v15[2].__r_.__value_.__s.__data_[7] < 0) {
    uint64_t v16 = (std::string::size_type *)*v16;
  }
  LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
  *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
  int v29 = "#I plan [%s] doesn't have a valid label";
LABEL_63:
  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v29, (uint8_t *)&__p, 0xCu);
LABEL_64:
  a1->__r_.__value_.__s.__data_[0] = 0;
  a1[3].__r_.__value_.__s.__data_[0] = 0;
  char v12 = v64;
LABEL_132:
  sub_10005CD2C((uint64_t)&v75, v76.__r_.__value_.__l.__data_);
  sub_10010C0E0((uint64_t)&v76.__r_.__value_.__r.__words[2], v77[0]);
  if (v12) {
LABEL_51:
  }
    sub_10004D2C8(v12);
}

void sub_100CA7F10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  sub_10005CD2C((uint64_t)&a29, (char *)a30);
  sub_10005CD2C((uint64_t)&a32, (char *)a33);
  sub_10010C0E0((uint64_t)&a35, (void *)a36);
  sub_10010C0E0((uint64_t)&a38, (void *)a39);
  sub_10005CD2C((uint64_t)&a41, (char *)a42);
  sub_10010C0E0((uint64_t)&a44, (void *)a45);
  sub_10004D2C8(a12);
  _Unwind_Resume(a1);
}

uint64_t *sub_100CA8010(uint64_t *result, uint64_t a2)
{
  result[2] = 0;
  result[1] = 0;
  *uint64_t result = (uint64_t)(result + 1);
  int v2 = *(void ***)(a2 + 792);
  uint64_t v3 = (void **)(a2 + 800);
  if (v2 != (void **)(a2 + 800))
  {
    uint64_t v4 = (uint64_t **)result;
    do
    {
      uint64_t result = sub_100046BAC(v4, v2 + 4, (uint64_t)(v2 + 4));
      uint64_t v5 = (void **)v2[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          uint64_t v5 = (void **)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void **)v2[2];
          BOOL v7 = *v6 == v2;
          int v2 = v6;
        }
        while (!v7);
      }
      int v2 = v6;
    }
    while (v6 != v3);
  }
  return result;
}

void sub_100CA80A0(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100CA80B8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a2 + 24);
    if (*(char *)(a2 + 47) >= 0) {
      uint64_t v5 = a2 + 24;
    }
    uint64_t v6 = a2 + 48;
    if (*(char *)(a2 + 71) < 0) {
      uint64_t v6 = *(void *)(a2 + 48);
    }
    int v31 = 136315394;
    uint64_t v32 = v5;
    __int16 v33 = 2080;
    uint64_t v34 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Applying new preferences: Data (%s) Voice (%s)", (uint8_t *)&v31, 0x16u);
  }
  int v7 = *(char *)(a2 + 47);
  uint64_t v8 = *(void *)(a2 + 32);
  if (v7 >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(a2 + 47);
  }
  if (!v8) {
    goto LABEL_26;
  }
  uint64_t v9 = *(unsigned __int8 *)(a1 + 895);
  uint64_t v10 = *(void *)(a1 + 880);
  if ((v9 & 0x80u) == 0) {
    uint64_t v11 = *(unsigned __int8 *)(a1 + 895);
  }
  else {
    uint64_t v11 = *(void *)(a1 + 880);
  }
  if (v11 == v8)
  {
    if (v7 >= 0) {
      char v12 = (unsigned __int8 *)(a2 + 24);
    }
    else {
      char v12 = *(unsigned __int8 **)(a2 + 24);
    }
    if ((v9 & 0x80) == 0)
    {
      if (*(unsigned char *)(a1 + 895))
      {
        uint64_t v13 = (unsigned __int8 *)(a1 + 872);
        while (*v13 == *v12)
        {
          ++v13;
          ++v12;
          if (!--v9) {
            goto LABEL_26;
          }
        }
        goto LABEL_25;
      }
LABEL_26:
      BOOL v15 = 0;
      goto LABEL_29;
    }
    int v14 = memcmp(*(const void **)(a1 + 872), v12, *(void *)(a1 + 880));
    uint64_t v11 = v10;
    if (!v14) {
      goto LABEL_26;
    }
  }
  if (!v11)
  {
    BOOL v15 = 0;
    goto LABEL_28;
  }
LABEL_25:
  BOOL v15 = !sub_100CBF930(a1, (unsigned __int8 *)(a1 + 872), (unsigned __int8 *)(a2 + 24));
LABEL_28:
  std::string::operator=((std::string *)(a1 + 872), (const std::string *)(a2 + 24));
LABEL_29:
  int v16 = *(char *)(a2 + 71);
  if (v16 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(a2 + 71);
  }
  else {
    uint64_t v17 = *(void *)(a2 + 56);
  }
  if (!v17) {
    goto LABEL_48;
  }
  uint64_t v18 = (const std::string *)(a2 + 48);
  uint64_t v19 = *(unsigned __int8 *)(a1 + 863);
  uint64_t v20 = *(void *)(a1 + 848);
  if ((v19 & 0x80u) == 0) {
    uint64_t v21 = *(unsigned __int8 *)(a1 + 863);
  }
  else {
    uint64_t v21 = *(void *)(a1 + 848);
  }
  if (v21 == v17)
  {
    if (v16 >= 0) {
      uint64_t v22 = v18;
    }
    else {
      uint64_t v22 = (const std::string *)v18->__r_.__value_.__r.__words[0];
    }
    if ((v19 & 0x80) == 0)
    {
      if (*(unsigned char *)(a1 + 863))
      {
        uint64_t v21 = 1;
        uint64_t v23 = (unsigned __int8 *)(a1 + 840);
        while (*v23 == v22->__r_.__value_.__s.__data_[0])
        {
          ++v23;
          uint64_t v22 = (const std::string *)((char *)v22 + 1);
          if (!--v19) {
            goto LABEL_48;
          }
        }
        goto LABEL_47;
      }
LABEL_48:
      BOOL v25 = 0;
      goto LABEL_49;
    }
    int v24 = memcmp(*(const void **)(a1 + 840), v22, *(void *)(a1 + 848));
    uint64_t v21 = v20;
    if (!v24) {
      goto LABEL_48;
    }
  }
LABEL_47:
  BOOL v25 = v21 != 0;
  std::string::operator=((std::string *)(a1 + 840), v18);
  *(_DWORD *)(a1 + 864) = 0;
LABEL_49:
  if (v25 || v15)
  {
    uint64_t v26 = *(std::__shared_weak_count **)(a1 + 80);
    if (v26)
    {
      uint64_t v27 = std::__shared_weak_count::lock(v26);
      if (v27)
      {
        uint64_t v28 = v27;
        uint64_t v29 = *(void *)(a1 + 72);
        if (v29) {
          (*(void (**)(uint64_t, BOOL, BOOL))(*(void *)v29 + 72))(v29, v15, v25);
        }
        sub_10004D2C8(v28);
      }
    }
  }
  return sub_100CA88D4(a1);
}

void sub_100CA836C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100CA8388(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = a2[23];
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *((void *)a2 + 1);
  }
  if (!v3)
  {
    uint64_t v22 = a1[5];
    BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v23) {
      return result;
    }
    LOWORD(v25) = 0;
    uint64_t v19 = "#I Empty ICCID - default to unknown slot";
    uint64_t v20 = v22;
    uint32_t v21 = 2;
    goto LABEL_34;
  }
  uint64_t v5 = a1[17];
  uint64_t v6 = a1[18];
  while (v5 != v6)
  {
    VinylInfo::findProfile();
    if (v27)
    {
      sub_1000C584C((uint64_t)&v25);
      return *(unsigned int *)(v5 + 4);
    }
    v5 += 88;
  }
  uint64_t v7 = a1[20];
  uint64_t v8 = a1[21];
  if (v7 == v8)
  {
LABEL_27:
    BOOL v15 = a1[5];
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v16) {
      return result;
    }
    if ((a2[23] & 0x80u) == 0) {
      uint64_t v18 = a2;
    }
    else {
      uint64_t v18 = *(unsigned __int8 **)a2;
    }
    int v25 = 136315138;
    uint64_t v26 = v18;
    uint64_t v19 = "#I Unknown ICCID (%s)";
    uint64_t v20 = v15;
    uint32_t v21 = 12;
LABEL_34:
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v25, v21);
    return 0;
  }
  unsigned __int8 v9 = a2[23];
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = a2[23];
  }
  else {
    uint64_t v10 = *((void *)a2 + 1);
  }
  if ((v9 & 0x80u) == 0) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = *(unsigned __int8 **)a2;
  }
  while (1)
  {
    uint64_t v12 = *(unsigned __int8 *)(v7 + 95);
    if ((v12 & 0x80u) == 0) {
      uint64_t v13 = *(unsigned __int8 *)(v7 + 95);
    }
    else {
      uint64_t v13 = *(void *)(v7 + 80);
    }
    if (v13 != v10) {
      goto LABEL_26;
    }
    if ((v12 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v7 + 95)) {
      goto LABEL_35;
    }
    uint64_t v14 = 0;
    while (*(unsigned __int8 *)(v7 + v14 + 72) == v11[v14])
    {
      if (v12 == ++v14) {
        goto LABEL_35;
      }
    }
LABEL_26:
    v7 += 168;
    if (v7 == v8) {
      goto LABEL_27;
    }
  }
  if (memcmp(*(const void **)(v7 + 72), v11, *(void *)(v7 + 80))) {
    goto LABEL_26;
  }
LABEL_35:
  uint64_t v24 = *(int *)(v7 + 4);
  if (v24 < 4) {
    return dword_101562970[v24];
  }
  return 0;
}

void sub_100CA85A0(uint64_t a1)
{
  sub_100CB3890(a1);
  sub_100CB3DD4(a1);
  uint64_t v2 = a1 + 928;
  if (*(char *)(a1 + 951) < 0) {
    uint64_t v3 = *(void *)(a1 + 936);
  }
  else {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 951);
  }
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v15 = 0;
  BOOL v4 = v3 == 0;
  uint64_t v5 = 928;
  if (v4)
  {
    uint64_t v5 = 872;
    uint64_t v2 = a1 + 872;
  }
  if (*(char *)(v2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)(a1 + v5), *(void *)(v2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v2;
    uint64_t v15 = *(void *)(v2 + 16);
  }
  int v6 = sub_100CA8388((void *)a1, (unsigned __int8 *)__dst);
  if (v6 != *(_DWORD *)(a1 + 896))
  {
    *(_DWORD *)(a1 + 896) = v6;
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 80);
    if (v7)
    {
      uint64_t v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        unsigned __int8 v9 = v8;
        uint64_t v10 = *(void *)(a1 + 72);
        if (v10)
        {
          uint64_t v11 = *(unsigned int *)(a1 + 896);
          sub_100058DB0(__p, "");
          (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v10 + 32))(v10, v11, __p);
          if (v13 < 0) {
            operator delete(__p[0]);
          }
        }
        sub_10004D2C8(v9);
      }
    }
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_100CA86E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v21);
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CA8728(uint64_t a1)
{
  (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v16);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, v16);
  BOOL v4 = ServiceMap;
  if (v5 < 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v5;
  unsigned __int8 v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v15 = 0;
  (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v11 + 232))(v11, __p, 1);
  if ((SHIBYTE(v15) & 0x80000000) == 0)
  {
    if (v12) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  operator delete(__p[0]);
  if ((v12 & 1) == 0) {
LABEL_11:
  }
    sub_10004D2C8(v10);
LABEL_12:
  if (v17) {
    sub_10004D2C8(v17);
  }
  return sub_100CA88D4(a1);
}

void sub_100CA8894(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CA88D4(uint64_t result)
{
  if (*(_DWORD *)(result + 788) != 1)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I clearing source device user preferences", (uint8_t *)&v9, 2u);
    }
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    unsigned __int8 v9 = &v10;
    uint64_t v3 = v1 + 984;
    *(_OWORD *)std::string __p = 0u;
    memset(v13, 0, sizeof(v13));
    sub_10010C0E0(v1 + 976, *(void **)(v1 + 984));
    BOOL v4 = v10;
    *(void *)(v1 + 976) = v9;
    *(void *)(v1 + 984) = v4;
    uint64_t v5 = v11;
    *(void *)(v1 + 992) = v11;
    if (v5)
    {
      v4[2] = v3;
      unsigned __int8 v9 = &v10;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
    }
    else
    {
      *(void *)(v1 + 976) = v3;
    }
    int v6 = (void **)(v1 + 1000);
    if (*(char *)(v1 + 1023) < 0) {
      operator delete(*v6);
    }
    *(_OWORD *)int v6 = *(_OWORD *)__p;
    *(void *)(v1 + 1016) = *(void *)&v13[0];
    BYTE7(v13[0]) = 0;
    LOBYTE(__p[0]) = 0;
    uint64_t v7 = (void **)(v1 + 1024);
    if (*(char *)(v1 + 1047) < 0)
    {
      operator delete(*v7);
      int v8 = SBYTE7(v13[0]);
      *(_OWORD *)uint64_t v7 = *(_OWORD *)((char *)v13 + 8);
      *(void *)(v1 + 1040) = *((void *)&v13[1] + 1);
      HIBYTE(v13[1]) = 0;
      BYTE8(v13[0]) = 0;
      if (v8 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      *(_OWORD *)uint64_t v7 = *(_OWORD *)((char *)v13 + 8);
      *(void *)(v1 + 1040) = *((void *)&v13[1] + 1);
      HIBYTE(v13[1]) = 0;
      BYTE8(v13[0]) = 0;
    }
    sub_10010C0E0((uint64_t)&v9, v10);
    return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 120) + 208))(*(void *)(v1 + 120), v1 + 976, 1);
  }
  return result;
}

void sub_100CA8A7C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

void *sub_100CA8A88(uint64_t a1)
{
  (***(void (****)(std::string *__return_ptr))(a1 + 56))(&__p);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, (Registry *)__p.__r_.__value_.__l.__data_);
  BOOL v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      std::string::size_type v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v5;
  unsigned __int8 v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  if (__p.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
  }
  if (v11)
  {
    (*(void (**)(uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v11 + 48))(v11, @"com.apple.commcenter.cellular_plan", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    *(void *)CFArrayRef theArray = 0;
    (*(void (**)(std::string *__return_ptr, uint64_t, const __CFString *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v11 + 40))(&__p, v11, @"kLocalTransferredPlans", @"com.apple.commcenter.cellular_plan", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_100044D6C(theArray, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
    sub_1000577C4((const void **)&__p.__r_.__value_.__l.__data_);
    if (*(void *)theArray) {
      char v13 = sub_100083F10;
    }
    else {
      char v13 = 0;
    }
    if (v13)
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)theArray);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          memset(&buf, 0, sizeof(buf));
          CFArrayGetValueAtIndex(*(CFArrayRef *)theArray, i);
          memset(&__p, 0, sizeof(__p));
          ctu::cf::assign();
          std::string buf = __p;
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
          char v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }
          if (size)
          {
            sub_1000EA6A0((uint64_t **)(a1 + 760), (void **)&buf.__r_.__value_.__l.__data_, (uint64_t)&buf);
            char v17 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
          }
          if (v17 < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
      }
      char v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        sub_1000E8F34(*(std::string **)(a1 + 760), (std::string *)(a1 + 768), ",", 1uLL, &__p);
        uint64_t v19 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &__p
            : (std::string *)__p.__r_.__value_.__r.__words[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Local transferred plans: [%s]", (uint8_t *)&buf, 0xCu);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
    }
    else
    {
      uint64_t v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I No local transferred plans.", (uint8_t *)&__p, 2u);
      }
    }
    sub_100044D00((const void **)theArray);
  }
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  uint64_t v21 = *(void *)(a1 + 120);
  v60[0] = off_101A4E318;
  v60[1] = a1;
  v60[3] = v60;
  (*(void (**)(uint64_t, void *))(*(void *)v21 + 32))(v21, v60);
  sub_100860F10(v60);
  uint64_t v22 = *(void *)(a1 + 120);
  v59[0] = off_101A4E3A8;
  v59[1] = a1;
  v59[3] = v59;
  (*(void (**)(uint64_t, void *))(*(void *)v22 + 64))(v22, v59);
  sub_100861838(v59);
  (***(void (****)(std::string *__return_ptr))(a1 + 56))(&__p);
  uint64_t v24 = (std::mutex *)Registry::getServiceMap(v23, (Registry *)__p.__r_.__value_.__l.__data_);
  int v25 = v24;
  if ((v26 & 0x8000000000000000) != 0)
  {
    char v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v28 = 5381;
    do
    {
      std::string::size_type v26 = v28;
      unsigned int v29 = *v27++;
      uint64_t v28 = (33 * v28) ^ v29;
    }
    while (v29);
  }
  std::mutex::lock(v24);
  buf.__r_.__value_.__r.__words[0] = v26;
  long long v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)&buf);
  if (v30)
  {
    uint64_t v32 = v30[3];
    int v31 = (std::__shared_weak_count *)v30[4];
    if (v31)
    {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v25);
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v31);
      char v33 = 0;
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v32 = 0;
  }
  std::mutex::unlock(v25);
  int v31 = 0;
  char v33 = 1;
LABEL_44:
  uint64_t v34 = (capabilities::ct *)__p.__r_.__value_.__l.__size_;
  if (__p.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
  }
  if (!v32)
  {
    long long v43 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I SimSetupProxyInterface not found", (uint8_t *)&__p, 2u);
    }
    if ((v33 & 1) == 0) {
      sub_10004D2C8(v31);
    }
LABEL_82:
    (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 120) + 216))(&__p);
    if (v57)
    {
      if ((std::string::size_type *)(a1 + 976) != &__p.__r_.__value_.__r.__words[1]) {
        sub_100328AC0((uint64_t **)(a1 + 976), (long long *)__p.__r_.__value_.__l.__size_, (long long *)&__p.__r_.__value_.__r.__words[2]);
      }
      std::string::operator=((std::string *)(a1 + 1000), (const std::string *)&v54[1]);
      std::string::operator=((std::string *)(a1 + 1024), &v56);
      uint64_t v45 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        sub_1008A2650(a1 + 976, &buf);
        long long v46 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &buf
            : (std::string *)buf.__r_.__value_.__r.__words[0];
        *(_DWORD *)CFArrayRef theArray = 136315138;
        *(void *)&theArray[4] = v46;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I previously cached user preferences from source device: %s", theArray, 0xCu);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
    }
    else if (!__p.__r_.__value_.__s.__data_[0])
    {
      (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 120) + 200))(&buf);
      if (!v69)
      {
        std::string::size_type v52 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CFArrayRef theArray = 0;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I any known user preferences not found", theArray, 2u);
        }
        sub_1008618BC((uint64_t)&buf);
        goto LABEL_107;
      }
      if ((std::string *)(a1 + 976) != &buf) {
        sub_100328AC0((uint64_t **)(a1 + 976), (long long *)buf.__r_.__value_.__l.__data_, (long long *)&buf.__r_.__value_.__r.__words[1]);
      }
      std::string::operator=((std::string *)(a1 + 1000), (const std::string *)&v66);
      std::string::operator=((std::string *)(a1 + 1024), (const std::string *)((char *)&v67 + 8));
      long long v47 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        sub_1008A2650(a1 + 976, theArray);
        std::string::size_type v48 = v62 >= 0 ? theArray : *(unsigned char **)theArray;
        *(_DWORD *)long long v63 = 136315138;
        long long v64 = v48;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I user preferences from backup: %s", v63, 0xCu);
        if (v62 < 0) {
          operator delete(*(void **)theArray);
        }
      }
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 120) + 208))(*(void *)(a1 + 120), a1 + 976, 1);
      sub_1008618BC((uint64_t)&buf);
    }
    uint64_t v49 = *(void *)(a1 + 120);
    *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0uLL;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf.__r_.__value_.__l.__size_;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    (*(void (**)(uint64_t, std::string *))(*(void *)v49 + 192))(v49, &buf);
    if (SHIBYTE(v68) < 0) {
      operator delete(*((void **)&v67 + 1));
    }
    if (SBYTE7(v67) < 0) {
      operator delete((void *)v66);
    }
    sub_10010C0E0((uint64_t)&buf, (void *)buf.__r_.__value_.__l.__size_);
LABEL_107:
    sub_1008618BC((uint64_t)&__p.__r_.__value_.__l.__size_);
    goto LABEL_108;
  }
  if (capabilities::ct::supportsVoiceCall(v34))
  {
    memset(&__p, 0, sizeof(__p));
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v32 + 56))(&__p, v32);
    std::string::size_type v35 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    int v36 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v35 = __p.__r_.__value_.__l.__size_;
    }
    if (v35)
    {
      long long v37 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if (v36 >= 0) {
          p_p = &__p;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I user selected default voice iccid found, (%s)", (uint8_t *)&buf, 0xCu);
      }
      std::string::operator=((std::string *)(a1 + 840), &__p);
      LOBYTE(v36) = *((unsigned char *)&__p.__r_.__value_.__s + 23);
    }
    if ((v36 & 0x80) != 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  memset(&__p, 0, sizeof(__p));
  (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v32 + 64))(&__p, v32);
  int v39 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v40 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v40 = __p.__r_.__value_.__l.__size_;
  }
  if (v40)
  {
    uint64_t v41 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      CSIPhoneNumber v42 = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (v39 >= 0) {
        CSIPhoneNumber v42 = &__p;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v42;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I user selected default data iccid found, (%s)", (uint8_t *)&buf, 0xCu);
    }
    std::string::operator=((std::string *)(a1 + 872), &__p);
    LOBYTE(v39) = *((unsigned char *)&__p.__r_.__value_.__s + 23);
  }
  if ((v39 & 0x80) == 0)
  {
    if (v33) {
      goto LABEL_69;
    }
LABEL_76:
    sub_10004D2C8(v31);
    if (!v40) {
      goto LABEL_82;
    }
    goto LABEL_77;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if ((v33 & 1) == 0) {
    goto LABEL_76;
  }
LABEL_69:
  if (!v40) {
    goto LABEL_82;
  }
LABEL_77:
  uint64_t v44 = *(void *)(a1 + 120);
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
  *(_OWORD *)uint64_t v54 = 0u;
  *(_OWORD *)int v55 = 0u;
  *(_OWORD *)&v56.__r_.__value_.__l.__data_ = 0u;
  (*(void (**)(uint64_t, std::string *))(*(void *)v44 + 192))(v44, &__p);
  if (v56.__r_.__value_.__s.__data_[15] < 0) {
    operator delete(v55[1]);
  }
  if (SHIBYTE(v55[0]) < 0) {
    operator delete(v54[0]);
  }
  sub_10010C0E0((uint64_t)&__p, (void *)__p.__r_.__value_.__l.__size_);
LABEL_108:
  uint64_t v50 = *(void *)(a1 + 120);
  v58[0] = off_101A4E438;
  v58[1] = a1;
  v58[3] = v58;
  (*(void (**)(uint64_t, void *))(*(void *)v50 + 288))(v50, v58);
  return sub_100861914(v58);
}

void sub_100CA9544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  sub_1008618BC(v37 - 176);
  sub_1008618BC(v36);
  _Unwind_Resume(a1);
}

void sub_100CA9690(uint64_t a1)
{
  if (capabilities::ct::supportsHydra((capabilities::ct *)a1))
  {
    char v12 = 0;
    char v13 = 0;
    uint64_t v2 = a1 + 792;
    uint64_t v14 = 0;
    sub_10005DD08((uint64_t *)&v12, a1 + 792);
    if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56)) & 1) == 0
      && v14 == 2)
    {
      uint64_t v3 = (uint64_t *)v12;
      if (v12 == &v13)
      {
LABEL_12:
        uint64_t v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Hydra is not supported, need to disable non-user data plans", buf, 2u);
        }
        sub_10005CD2C((uint64_t)&v12, v13);
        char v13 = 0;
        uint64_t v14 = 0;
        char v12 = &v13;
        if (sub_10010E128(a1 + 792, (void **)(a1 + 872)))
        {
          char v8 = *(unsigned char *)sub_10005DDEC(a1 + 792, (void **)(a1 + 872));
          *(void *)std::string buf = a1 + 872;
          *((unsigned char *)sub_1000ED870((uint64_t **)&v12, (void **)(a1 + 872), (uint64_t)&unk_10144E20E, (long long **)buf) + 56) = v8;
        }
        else if (*(void *)(a1 + 808))
        {
          uint64_t v10 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            uint64_t v11 = (void *)(*(void *)v2 + 32);
            if (*(char *)(*(void *)v2 + 55) < 0) {
              uint64_t v11 = (void *)*v11;
            }
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v11;
            _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "User data sim not enabled, selecting (%s)", buf, 0xCu);
          }
          *(void *)std::string buf = *(void *)v2 + 32;
          *((unsigned char *)sub_1000ED870((uint64_t **)&v12, *(void ***)buf, (uint64_t)&unk_10144E20E, (long long **)buf) + 56) = 1;
        }
      }
      else
      {
        while (sIsProfileInstalled())
        {
          BOOL v4 = (char *)v3[1];
          if (v4)
          {
            do
            {
              std::string::size_type v5 = (char **)v4;
              BOOL v4 = *(char **)v4;
            }
            while (v4);
          }
          else
          {
            do
            {
              std::string::size_type v5 = (char **)v3[2];
              BOOL v6 = *v5 == (char *)v3;
              uint64_t v3 = (uint64_t *)v5;
            }
            while (!v6);
          }
          uint64_t v3 = (uint64_t *)v5;
          if (v5 == &v13) {
            goto LABEL_12;
          }
        }
      }
    }
    sub_100CA9968((uint64_t *)a1, &v12, 1, 0);
    sub_10005CD2C((uint64_t)&v12, v13);
  }
  else
  {
    unsigned __int8 v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Ignore eSIM activation flagset change for non-hydra device", (uint8_t *)&v12, 2u);
    }
  }
}

void sub_100CA993C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10)
{
}

uint64_t sub_100CA9968(uint64_t *a1, void *a2, char a3, int a4)
{
  uint64_t v7 = (uint64_t)a1;
  *(_OWORD *)&v107.__r_.__value_.__l.__data_ = 0uLL;
  int v106 = &v107;
  unsigned __int8 v9 = (void **)(a2 + 1);
  char v8 = (void **)*a2;
  if ((void *)*a2 == a2 + 1) {
    goto LABEL_11;
  }
  do
  {
    a1 = sub_100046BAC((uint64_t **)&v106, v8 + 4, (uint64_t)(v8 + 4));
    uint64_t v10 = (void **)v8[1];
    if (v10)
    {
      do
      {
        uint64_t v11 = v10;
        uint64_t v10 = (void **)*v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        uint64_t v11 = (void **)v8[2];
        BOOL v12 = *v11 == v8;
        char v8 = v11;
      }
      while (!v12);
    }
    char v8 = v11;
  }
  while (v11 != v9);
  if (!v107.__r_.__value_.__l.__size_)
  {
LABEL_11:
    char v13 = (capabilities::ct *)capabilities::ct::supportsGemini((capabilities::ct *)a1);
    if ((v13 & 1) == 0)
    {
      uint64_t v14 = (capabilities::ct *)capabilities::ct::supportsDynamicSID(v13);
      if ((v14 & 1) == 0 && (capabilities::ct::dataOnlySingleSIMDevice(v14) & 1) == 0)
      {
        uint64_t v15 = *(NSObject **)(v7 + 40);
        if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          goto LABEL_14;
        }
        LOWORD(buf) = 0;
        uint64_t v36 = "No ICCIDs enabled";
        goto LABEL_212;
      }
    }
  }
  if (v107.__r_.__value_.__l.__size_ > *(unsigned int *)(v7 + 788))
  {
    uint64_t v15 = *(NSObject **)(v7 + 40);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    LOWORD(buf) = 0;
    uint64_t v36 = "Too many ICCIDs to enable";
LABEL_212:
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v36, (uint8_t *)&buf, 2u);
    goto LABEL_14;
  }
  if (*(unsigned char *)(v7 + 752))
  {
    sub_100CA8010((uint64_t *)&buf, v7);
    std::string::size_type size = v107.__r_.__value_.__l.__size_;
    if (v107.__r_.__value_.__l.__size_ == (void)v112)
    {
      uint64_t v19 = v106;
      if (v106 == &v107)
      {
LABEL_197:
        sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
LABEL_205:
        int v17 = 0;
        LODWORD(v16) = 0;
        goto LABEL_206;
      }
      uint64_t v20 = (unsigned __int8 *)buf;
      while ((sub_1000609C0((uint64_t)&v125, (unsigned __int8 *)&v19[1].__r_.__value_.__s.__data_[8], v20 + 32) & 1) != 0)
      {
        uint64_t v21 = (std::string *)v19->__r_.__value_.__l.__size_;
        uint64_t v22 = v19;
        if (v21)
        {
          do
          {
            uint64_t v19 = v21;
            uint64_t v21 = (std::string *)v21->__r_.__value_.__r.__words[0];
          }
          while (v21);
        }
        else
        {
          do
          {
            uint64_t v19 = (std::string *)v22->__r_.__value_.__r.__words[2];
            BOOL v12 = v19->__r_.__value_.__r.__words[0] == (void)v22;
            uint64_t v22 = v19;
          }
          while (!v12);
        }
        BOOL v23 = (unsigned __int8 *)*((void *)v20 + 1);
        if (v23)
        {
          do
          {
            uint64_t v24 = v23;
            BOOL v23 = *(unsigned __int8 **)v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            uint64_t v24 = (unsigned __int8 *)*((void *)v20 + 2);
            BOOL v12 = *(void *)v24 == (void)v20;
            uint64_t v20 = v24;
          }
          while (!v12);
        }
        uint64_t v20 = v24;
        if (v19 == &v107) {
          goto LABEL_197;
        }
      }
      std::string::size_type size = v107.__r_.__value_.__l.__size_;
    }
    if (*(void *)(v7 + 688) != size)
    {
LABEL_198:
      sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
      uint64_t v88 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        sub_1000E8F34(v106, &v107, ",", 1uLL, (std::string *)&buf);
        uint64_t v89 = (SBYTE7(v112) & 0x80u) == 0 ? &buf : (long long *)buf;
        LODWORD(v125.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v125.__r_.__value_.__r.__words + 4) = (std::string::size_type)v89;
        _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I Attempting to add plans into (%s) provisioning placeholder.", (uint8_t *)&v125, 0xCu);
        if (SBYTE7(v112) < 0) {
          operator delete((void *)buf);
        }
      }
      sub_100CBCA80(v7, (void **)&v106, a4);
      goto LABEL_205;
    }
    uint64_t v82 = *(unsigned __int8 **)(v7 + 672);
    if (v82 != (unsigned __int8 *)(v7 + 680))
    {
      uint64_t v83 = (uint64_t *)v106;
      while ((sub_1000609C0((uint64_t)&v125, v82 + 32, (unsigned __int8 *)v83 + 32) & 1) != 0)
      {
        long long v84 = (unsigned __int8 *)*((void *)v82 + 1);
        unsigned __int8 v85 = v82;
        if (v84)
        {
          do
          {
            uint64_t v82 = v84;
            long long v84 = *(unsigned __int8 **)v84;
          }
          while (v84);
        }
        else
        {
          do
          {
            uint64_t v82 = (unsigned __int8 *)*((void *)v85 + 2);
            BOOL v12 = *(void *)v82 == (void)v85;
            unsigned __int8 v85 = v82;
          }
          while (!v12);
        }
        char v86 = (uint64_t *)v83[1];
        if (v86)
        {
          do
          {
            uint64_t v87 = v86;
            char v86 = (uint64_t *)*v86;
          }
          while (v86);
        }
        else
        {
          do
          {
            uint64_t v87 = (uint64_t *)v83[2];
            BOOL v12 = *v87 == (void)v83;
            uint64_t v83 = v87;
          }
          while (!v12);
        }
        uint64_t v83 = v87;
        if (v82 == (unsigned __int8 *)(v7 + 680)) {
          goto LABEL_197;
        }
      }
      goto LABEL_198;
    }
    goto LABEL_197;
  }
  if ((a3 & 1) == 0)
  {
    sub_100CA8010((uint64_t *)&buf, v7);
    if (v107.__r_.__value_.__l.__size_ == (void)v112)
    {
      int v25 = v106;
      if (v106 == &v107)
      {
LABEL_48:
        sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
        int v31 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Enabled ICCIDs already set", (uint8_t *)&buf, 2u);
        }
        sub_100CA8010((uint64_t *)&buf, v7);
        LODWORD(v16) = sub_100CC16E4(v7, (uint64_t)&buf, (unsigned __int8 **)&v106);
        sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
        if (v16)
        {
          uint64_t v32 = *(std::__shared_weak_count **)(v7 + 80);
          if (v32)
          {
            char v33 = std::__shared_weak_count::lock(v32);
            if (v33)
            {
              uint64_t v34 = v33;
              uint64_t v35 = *(void *)(v7 + 72);
              if (v35)
              {
                *(_DWORD *)(v7 + 896) = sub_100CA8388((void *)v7, (unsigned __int8 *)(v7 + 872));
                sub_100CA8010((uint64_t *)&buf, v7);
                (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)v35 + 160))(v35, &buf, v7 + 872);
                sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
              }
              sub_10004D2C8(v34);
            }
          }
          sub_100CA4DAC(v7);
          goto LABEL_205;
        }
        goto LABEL_245;
      }
      std::string::size_type v26 = (unsigned __int8 *)buf;
      while ((sub_1000609C0((uint64_t)&v125, (unsigned __int8 *)&v25[1].__r_.__value_.__s.__data_[8], v26 + 32) & 1) != 0)
      {
        char v27 = (std::string *)v25->__r_.__value_.__l.__size_;
        uint64_t v28 = v25;
        if (v27)
        {
          do
          {
            int v25 = v27;
            char v27 = (std::string *)v27->__r_.__value_.__r.__words[0];
          }
          while (v27);
        }
        else
        {
          do
          {
            int v25 = (std::string *)v28->__r_.__value_.__r.__words[2];
            BOOL v12 = v25->__r_.__value_.__r.__words[0] == (void)v28;
            uint64_t v28 = v25;
          }
          while (!v12);
        }
        unsigned int v29 = (unsigned __int8 *)*((void *)v26 + 1);
        if (v29)
        {
          do
          {
            long long v30 = v29;
            unsigned int v29 = *(unsigned __int8 **)v29;
          }
          while (v29);
        }
        else
        {
          do
          {
            long long v30 = (unsigned __int8 *)*((void *)v26 + 2);
            BOOL v12 = *(void *)v30 == (void)v26;
            std::string::size_type v26 = v30;
          }
          while (!v12);
        }
        std::string::size_type v26 = v30;
        if (v25 == &v107) {
          goto LABEL_48;
        }
      }
    }
    sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
  }
  BOOL v101 = (void **)a2;
  uint64_t v37 = (uint64_t *)v106;
  if (v106 == &v107)
  {
LABEL_98:
    sub_100CA8010((uint64_t *)&buf, v7);
    if (v107.__r_.__value_.__l.__size_ == (void)v112)
    {
      std::string::size_type v52 = v106;
      if (v106 == &v107)
      {
LABEL_113:
        sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
        goto LABEL_143;
      }
      char v53 = (unsigned __int8 *)buf;
      while ((sub_1000609C0((uint64_t)&v125, (unsigned __int8 *)&v52[1].__r_.__value_.__s.__data_[8], v53 + 32) & 1) != 0)
      {
        uint64_t v54 = (std::string *)v52->__r_.__value_.__l.__size_;
        int v55 = v52;
        if (v54)
        {
          do
          {
            std::string::size_type v52 = v54;
            uint64_t v54 = (std::string *)v54->__r_.__value_.__r.__words[0];
          }
          while (v54);
        }
        else
        {
          do
          {
            std::string::size_type v52 = (std::string *)v55->__r_.__value_.__r.__words[2];
            BOOL v12 = v52->__r_.__value_.__r.__words[0] == (void)v55;
            int v55 = v52;
          }
          while (!v12);
        }
        std::string v56 = (unsigned __int8 *)*((void *)v53 + 1);
        if (v56)
        {
          do
          {
            char v57 = v56;
            std::string v56 = *(unsigned __int8 **)v56;
          }
          while (v56);
        }
        else
        {
          do
          {
            char v57 = (unsigned __int8 *)*((void *)v53 + 2);
            BOOL v12 = *(void *)v57 == (void)v53;
            char v53 = v57;
          }
          while (!v12);
        }
        char v53 = v57;
        if (v52 == &v107) {
          goto LABEL_113;
        }
      }
    }
    sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
    sub_100CA8010(&v104, v7);
    uint64_t v58 = *(std::__shared_weak_count **)(v7 + 80);
    if (v58)
    {
      int v59 = std::__shared_weak_count::lock(v58);
      if (v59)
      {
        std::string::size_type v60 = v59;
        uint64_t v61 = *(void *)(v7 + 72);
        if (v61)
        {
          *((unsigned char *)&v107.__r_.__value_.__s + 23) = *(_DWORD *)(v7 + 336) < 2u;
          sub_100CC07AC((char **)&buf, v7, &v104);
          sub_100CC07AC(&v125.__r_.__value_.__l.__data_, v7, &v106);
          (*(void (**)(uint64_t, char *, long long *, std::string *))(*(void *)v61 + 88))(v61, (char *)&v107.__r_.__value_.__r.__words[2] + 7, &buf, &v125);
          *(void *)unint64_t v108 = &v125;
          sub_1003DDDFC((void ***)v108);
          v125.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
          sub_1003DDDFC((void ***)&v125);
        }
        sub_10004D2C8(v60);
      }
    }
    sub_10005CD2C((uint64_t)&v104, v105[0]);
    uint64_t v62 = *(void *)(v7 + 160);
    uint64_t v63 = *(void *)(v7 + 168);
    if (v62 != v63)
    {
      long long v64 = (const void **)(v7 + 816);
      do
      {
        if (sub_100CB1134(v7, v62 + 72))
        {
          if (sub_10010E128((uint64_t)&v106, (void **)(v62 + 72)))
          {
            uint64_t v65 = *(unsigned __int8 *)(v7 + 839);
            if ((v65 & 0x80u) == 0) {
              uint64_t v66 = *(unsigned __int8 *)(v7 + 839);
            }
            else {
              uint64_t v66 = *(void *)(v7 + 824);
            }
            uint64_t v67 = *(unsigned __int8 *)(v62 + 95);
            int v68 = (char)v67;
            if ((v67 & 0x80u) != 0) {
              uint64_t v67 = *(void *)(v62 + 80);
            }
            if (v66 == v67)
            {
              if (v68 >= 0) {
                char v69 = (unsigned __int8 *)(v62 + 72);
              }
              else {
                char v69 = *(unsigned __int8 **)(v62 + 72);
              }
              if ((v65 & 0x80) != 0)
              {
                std::string v71 = *v64;
                if (!memcmp(*v64, v69, *(void *)(v7 + 824)))
                {
                  *std::string v71 = 0;
                  *(void *)(v7 + 824) = 0;
                }
              }
              else if (*(unsigned char *)(v7 + 839))
              {
                std::string v70 = (unsigned __int8 *)(v7 + 816);
                while (*v70 == *v69)
                {
                  ++v70;
                  ++v69;
                  if (!--v65) {
                    goto LABEL_137;
                  }
                }
              }
              else
              {
LABEL_137:
                *(unsigned char *)(v7 + 816) = 0;
                *(unsigned char *)(v7 + 839) = 0;
              }
            }
          }
          else
          {
            std::string::operator=((std::string *)(v7 + 816), (const std::string *)(v62 + 72));
          }
        }
        v62 += 168;
      }
      while (v62 != v63);
    }
LABEL_143:
    sub_100CA8010((uint64_t *)&buf, v7);
    sub_100CC16E4(v7, (uint64_t)&buf, (unsigned __int8 **)&v106);
    sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
    if ((void **)(v7 + 792) != v101) {
      sub_1008619F0((uint64_t **)(v7 + 792), *v101, v9);
    }
    uint64_t v72 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v73 = *(void *)(v7 + 808);
      sub_100CA8010(&v104, v7);
      uint64_t v74 = v104;
      memset(&v125, 0, sizeof(v125));
      if ((char **)v104 != v105)
      {
        sub_100CC53AC((std::string *)&buf, v7, (unsigned __int8 *)(v104 + 32));
        unsigned int v75 = *(char **)(v74 + 8);
        *(_OWORD *)&v125.__r_.__value_.__l.__data_ = buf;
        v125.__r_.__value_.__r.__words[2] = v112;
        if (v75)
        {
          do
          {
            std::string v76 = (char **)v75;
            unsigned int v75 = *(char **)v75;
          }
          while (v75);
        }
        else
        {
          do
          {
            std::string v76 = *(char ***)(v74 + 16);
            BOOL v12 = *v76 == (char *)v74;
            uint64_t v74 = (uint64_t)v76;
          }
          while (!v12);
        }
        if (v76 != v105)
        {
          do
          {
            BYTE7(v112) = 1;
            strcpy((char *)&buf, ",");
            std::string::append(&v125, (const std::string::value_type *)&buf, 1uLL);
            if (SBYTE7(v112) < 0) {
              operator delete((void *)buf);
            }
            sub_100CC53AC((std::string *)&buf, v7, (unsigned __int8 *)v76 + 32);
            if ((SBYTE7(v112) & 0x80u) == 0) {
              p_long long buf = (const std::string::value_type *)&buf;
            }
            else {
              p_long long buf = (const std::string::value_type *)buf;
            }
            if ((SBYTE7(v112) & 0x80u) == 0) {
              std::string::size_type v78 = BYTE7(v112);
            }
            else {
              std::string::size_type v78 = *((void *)&buf + 1);
            }
            std::string::append(&v125, p_buf, v78);
            if (SBYTE7(v112) < 0) {
              operator delete((void *)buf);
            }
            char v79 = v76[1];
            if (v79)
            {
              do
              {
                __int16 v80 = (char **)v79;
                char v79 = *(char **)v79;
              }
              while (v79);
            }
            else
            {
              do
              {
                __int16 v80 = (char **)v76[2];
                BOOL v12 = *v80 == (char *)v76;
                std::string v76 = v80;
              }
              while (!v12);
            }
            std::string v76 = v80;
          }
          while (v80 != v105);
        }
      }
      int v81 = &v125;
      if ((v125.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        int v81 = (std::string *)v125.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)unint64_t v108 = 134218242;
      *(void *)&v108[4] = v73;
      __int16 v109 = 2080;
      unint64_t v110 = v81;
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I Enabling %lu SIMs (%s)", v108, 0x16u);
      if (SHIBYTE(v125.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v125.__r_.__value_.__l.__data_);
      }
      sub_10005CD2C((uint64_t)&v104, v105[0]);
    }
    if (sub_100CB4B88((void *)v7) && (*(_DWORD *)(v7 + 788) > 1u || *(void *)(v7 + 808))) {
      sub_100CA4DAC(v7);
    }
    if (*(char *)(v7 + 927) < 0)
    {
      if (!*(void *)(v7 + 912)) {
        goto LABEL_227;
      }
    }
    else if (!*(unsigned char *)(v7 + 927))
    {
      goto LABEL_227;
    }
    if (sub_100CBFD40((unsigned __int8 **)(v7 + 904), *(void *)(v7 + 160), *(void *)(v7 + 168))) {
      goto LABEL_205;
    }
    if (*(char *)(v7 + 927) < 0)
    {
      **(unsigned char **)(v7 + 904) = 0;
      *(void *)(v7 + 912) = 0;
    }
    else
    {
      *(unsigned char *)(v7 + 904) = 0;
      *(unsigned char *)(v7 + 927) = 0;
    }
    if (*(char *)(v7 + 951) < 0)
    {
      **(unsigned char **)(v7 + 928) = 0;
      *(void *)(v7 + 936) = 0;
    }
    else
    {
      *(unsigned char *)(v7 + 928) = 0;
      *(unsigned char *)(v7 + 951) = 0;
    }
    atomic_store(0, (unsigned __int8 *)(v7 + 784));
LABEL_227:
    if (*(void *)(v7 + 168) - *(void *)(v7 + 160) == 168)
    {
      if (!subscriber::isEsimCapable()) {
        goto LABEL_205;
      }
      uint64_t v96 = *(std::__shared_weak_count **)(v7 + 80);
      if (!v96) {
        goto LABEL_205;
      }
      BOOL v16 = std::__shared_weak_count::lock(v96);
      if (v16)
      {
        uint64_t v97 = *(void *)(v7 + 72);
        if (!v97) {
          goto LABEL_244;
        }
        sub_100CB4F1C((uint64_t)v103, v7);
        sub_100CB545C((uint64_t)&buf, v7);
        (*(void (**)(uint64_t, unsigned char *, long long *))(*(void *)v97 + 80))(v97, v103, &buf);
        if (SBYTE7(v112) < 0) {
          operator delete((void *)buf);
        }
        if (!v103[24]) {
          goto LABEL_244;
        }
        uint64_t v98 = v103;
LABEL_243:
        *(void *)&long long buf = v98;
        sub_100047F64((void ***)&buf);
LABEL_244:
        sub_10004D2C8(v16);
        goto LABEL_205;
      }
    }
    else
    {
      unsigned int v99 = *(std::__shared_weak_count **)(v7 + 80);
      if (!v99) {
        goto LABEL_205;
      }
      BOOL v16 = std::__shared_weak_count::lock(v99);
      if (v16)
      {
        uint64_t v100 = *(void *)(v7 + 72);
        if (!v100) {
          goto LABEL_244;
        }
        *(_DWORD *)(v7 + 896) = sub_100CA8388((void *)v7, (unsigned __int8 *)(v7 + 872));
        sub_100CA8010((uint64_t *)&buf, v7);
        (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)v100 + 160))(v100, &buf, v7 + 872);
        sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
        sub_100CB4F1C((uint64_t)v102, v7);
        sub_100CB545C((uint64_t)&buf, v7);
        (*(void (**)(uint64_t, unsigned char *, long long *))(*(void *)v100 + 80))(v100, v102, &buf);
        if (SBYTE7(v112) < 0) {
          operator delete((void *)buf);
        }
        if (!v102[24]) {
          goto LABEL_244;
        }
        uint64_t v98 = v102;
        goto LABEL_243;
      }
    }
LABEL_245:
    int v17 = 0;
    goto LABEL_206;
  }
  int v38 = 0;
  while (1)
  {
    int v39 = (const void **)(v37 + 4);
    uint64_t v41 = *(void *)(v7 + 160);
    uint64_t v40 = *(void *)(v7 + 168);
    if (v41 == v40)
    {
LABEL_82:
      if (v41 != v40)
      {
        v38 += subscriber::isEsimCapable();
        goto LABEL_92;
      }
    }
    else
    {
      int v42 = *((char *)v37 + 55);
      uint64_t v43 = v42 >= 0 ? *((unsigned __int8 *)v37 + 55) : v37[5];
      do
      {
        uint64_t v44 = *(unsigned __int8 *)(v41 + 95);
        if ((v44 & 0x80u) == 0) {
          uint64_t v45 = *(unsigned __int8 *)(v41 + 95);
        }
        else {
          uint64_t v45 = *(void *)(v41 + 80);
        }
        if (v45 == v43)
        {
          if (v42 >= 0) {
            long long v46 = (unsigned __int8 *)(v37 + 4);
          }
          else {
            long long v46 = (unsigned __int8 *)*v39;
          }
          if ((v44 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)(v41 + 72), v46, *(void *)(v41 + 80))) {
              goto LABEL_82;
            }
          }
          else
          {
            if (!*(unsigned char *)(v41 + 95)) {
              goto LABEL_82;
            }
            uint64_t v47 = 0;
            while (*(unsigned __int8 *)(v41 + v47 + 72) == v46[v47])
            {
              if (v44 == ++v47) {
                goto LABEL_82;
              }
            }
          }
        }
        v41 += 168;
      }
      while (v41 != v40);
    }
    long long v123 = 0u;
    long long v124 = 0u;
    long long v121 = 0u;
    long long v122 = 0u;
    long long v119 = 0u;
    long long v120 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    long long v115 = 0u;
    long long v116 = 0u;
    long long v113 = 0u;
    long long v114 = 0u;
    long long buf = 0u;
    long long v112 = 0u;
    sGetProfileDetails();
    if (!BYTE8(v124)) {
      break;
    }
    if (BYTE8(v116))
    {
      unsigned int v95 = *(NSObject **)(v7 + 40);
      if (!os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
        goto LABEL_220;
      }
      LOWORD(v125.__r_.__value_.__l.__data_) = 0;
      uint64_t v92 = "Cannot enable bootstrap profile";
LABEL_247:
      int v93 = v95;
      uint32_t v94 = 2;
      goto LABEL_248;
    }
    char v48 = sub_100CB1074(v7);
    if (++v38 < 2) {
      char v49 = 1;
    }
    else {
      char v49 = v48;
    }
    if ((v49 & 1) == 0)
    {
      unsigned int v95 = *(NSObject **)(v7 + 40);
      if (!os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
        goto LABEL_220;
      }
      LOWORD(v125.__r_.__value_.__l.__data_) = 0;
      uint64_t v92 = "Too many profiles to enable";
      goto LABEL_247;
    }
    if (BYTE8(v124)) {
      sub_1000C584C((uint64_t)&buf);
    }
LABEL_92:
    uint64_t v50 = (std::string *)v37[1];
    if (v50)
    {
      do
      {
        char v51 = v50;
        uint64_t v50 = (std::string *)v50->__r_.__value_.__r.__words[0];
      }
      while (v50);
    }
    else
    {
      do
      {
        char v51 = (std::string *)v37[2];
        BOOL v12 = v51->__r_.__value_.__r.__words[0] == (void)v37;
        uint64_t v37 = (uint64_t *)v51;
      }
      while (!v12);
    }
    uint64_t v37 = (uint64_t *)v51;
    if (v51 == &v107) {
      goto LABEL_98;
    }
  }
  unint64_t v91 = *(NSObject **)(v7 + 40);
  if (!os_log_type_enabled(v91, OS_LOG_TYPE_ERROR)) {
    goto LABEL_14;
  }
  if (*((char *)v37 + 55) < 0) {
    int v39 = (const void **)*v39;
  }
  LODWORD(v125.__r_.__value_.__l.__data_) = 136315138;
  *(std::string::size_type *)((char *)v125.__r_.__value_.__r.__words + 4) = (std::string::size_type)v39;
  uint64_t v92 = "ICCID (%s) unknown - aborting";
  int v93 = v91;
  uint32_t v94 = 12;
LABEL_248:
  _os_log_error_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_ERROR, v92, (uint8_t *)&v125, v94);
LABEL_220:
  if (BYTE8(v124)) {
    sub_1000C584C((uint64_t)&buf);
  }
LABEL_14:
  LODWORD(v16) = 1;
  int v17 = 6;
LABEL_206:
  sub_10005CD2C((uint64_t)&v106, v107.__r_.__value_.__l.__data_);
  return v17 | (v16 << 8);
}

void sub_100CAA7C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32)
{
  sub_10005CD2C((uint64_t)&__p, (char *)a32);
  sub_10004D2C8(v32);
  sub_10005CD2C((uint64_t)&a23, (char *)a24);
  _Unwind_Resume(a1);
}

uint64_t **sub_100CAA954(uint64_t a1, uint64_t a2, void *a3)
{
  std::string::size_type v5 = (void **)(a3 + 1);
  BOOL v6 = (void **)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    char v7 = 0;
    while (1)
    {
      if (*((char *)v6 + 55) < 0)
      {
        if (v6[5])
        {
LABEL_7:
          __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)(v6 + 4);
          char v8 = sub_100CC3268((uint64_t **)(a1 + 264), v6 + 4, (long long **)__p);
          int v9 = *((_DWORD *)v6 + 14);
          if (*((_DWORD *)v8 + 46) != v9)
          {
            __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)(v6 + 4);
            *((_DWORD *)sub_100CC3268((uint64_t **)(a1 + 264), v6 + 4, (long long **)__p) + 46) = v9;
            char v7 = 1;
          }
        }
      }
      else if (*((unsigned char *)v6 + 55))
      {
        goto LABEL_7;
      }
      uint64_t v10 = (void **)v6[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (void **)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void **)v6[2];
          BOOL v32 = *v11 == v6;
          BOOL v6 = v11;
        }
        while (!v32);
      }
      BOOL v6 = v11;
      if (v11 == v5) {
        goto LABEL_17;
      }
    }
  }
  char v7 = 0;
LABEL_17:
  uint64_t v12 = *(void *)(a1 + 160);
  uint64_t v13 = *(void *)(a1 + 168);
  while (v12 != v13)
  {
    __p[0].__r_.__value_.__r.__words[0] = v12 + 72;
    if (!*((_DWORD *)sub_100CC3268((uint64_t **)(a1 + 264), (void **)(v12 + 72), (long long **)__p) + 45))
    {
      if (*(char *)(v12 + 95) < 0)
      {
        if (*(void *)(v12 + 80))
        {
LABEL_25:
          if (subscriber::isSimReady() && *(_DWORD *)v12)
          {
            sub_100CA405C(a1, *(_DWORD *)v12);
            __p[0].__r_.__value_.__r.__words[0] = v12 + 72;
            v7 |= *((_DWORD *)sub_100CC3268((uint64_t **)(a1 + 264), (void **)(v12 + 72), (long long **)__p) + 45) != 0;
          }
        }
      }
      else if (*(unsigned char *)(v12 + 95))
      {
        goto LABEL_25;
      }
    }
    v12 += 168;
  }
  if (v7)
  {
    uint64_t v14 = *(std::__shared_weak_count **)(a1 + 80);
    if (v14)
    {
      uint64_t v15 = std::__shared_weak_count::lock(v14);
      if (v15)
      {
        BOOL v16 = v15;
        uint64_t v17 = *(void *)(a1 + 72);
        if (v17) {
          (*(void (**)(uint64_t))(*(void *)v17 + 40))(v17);
        }
        sub_10004D2C8(v16);
      }
    }
  }
  char v18 = *(std::__shared_weak_count **)(a1 + 80);
  if (v18)
  {
    uint64_t v19 = std::__shared_weak_count::lock(v18);
    if (v19)
    {
      uint64_t v20 = v19;
      uint64_t v21 = *(void *)(a1 + 72);
      if (!v21) {
        goto LABEL_168;
      }
      uint64_t v22 = *(void **)(a1 + 264);
      if (v22 == (void *)(a1 + 272)) {
        goto LABEL_168;
      }
      char v23 = 0;
      uint64_t v24 = (uint64_t **)(a1 + 760);
      __int16 v80 = v19;
      while (1)
      {
        if (*((_DWORD *)v22 + 46) == 2)
        {
          int v25 = (const void **)(v22 + 4);
          bzero(__p, 0x4E8uLL);
          (*(void (**)(std::string *__return_ptr, uint64_t, void *))(*(void *)v21 + 104))(__p, v21, v22 + 4);
          if (v94) {
            break;
          }
        }
LABEL_111:
        int v55 = (void *)v22[1];
        if (v55)
        {
          do
          {
            std::string v56 = v55;
            int v55 = (void *)*v55;
          }
          while (v55);
        }
        else
        {
          do
          {
            std::string v56 = (void *)v22[2];
            BOOL v32 = *v56 == (void)v22;
            uint64_t v22 = v56;
          }
          while (!v32);
        }
        uint64_t v22 = v56;
        if (v56 == (void *)(a1 + 272))
        {
          if (v23)
          {
            (***(void (****)(std::string *__return_ptr))(a1 + 56))(__p);
            ServiceMap = (std::mutex *)Registry::getServiceMap(v57, (Registry *)__p[0].__r_.__value_.__l.__data_);
            int v59 = ServiceMap;
            if ((v60 & 0x8000000000000000) != 0)
            {
              uint64_t v61 = (unsigned __int8 *)(v60 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v62 = 5381;
              do
              {
                std::string::size_type v60 = v62;
                unsigned int v63 = *v61++;
                uint64_t v62 = (33 * v62) ^ v63;
              }
              while (v63);
            }
            std::mutex::lock(ServiceMap);
            buf.__r_.__value_.__r.__words[0] = v60;
            long long v64 = sub_10004D37C(&v59[1].__m_.__sig, (unint64_t *)&buf);
            uint64_t v65 = (std::string **)v24;
            if (v64)
            {
              uint64_t v67 = v64[3];
              uint64_t v66 = (std::__shared_weak_count *)v64[4];
              if (v66)
              {
                atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v59);
                atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v66);
                char v68 = 0;
LABEL_129:
                if (__p[0].__r_.__value_.__l.__size_) {
                  sub_10004D2C8((std::__shared_weak_count *)__p[0].__r_.__value_.__l.__size_);
                }
                if (v67)
                {
                  long long v84 = 0;
                  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, *(void *)(a1 + 776), &kCFTypeArrayCallBacks);
                  if (Mutable)
                  {
                    std::string v70 = v84;
                    long long v84 = Mutable;
                    __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v70;
                    sub_1000440D4((const void **)&__p[0].__r_.__value_.__l.__data_);
                  }
                  std::string v71 = *(void **)(a1 + 760);
                  if (v71 != (void *)(a1 + 768))
                  {
                    do
                    {
                      uint64_t v83 = 0;
                      if (*((char *)v71 + 55) < 0) {
                        sub_10004FC84(&__dst, (void *)v71[4], v71[5]);
                      }
                      else {
                        std::string __dst = *(std::string *)(v71 + 4);
                      }
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                        sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                      }
                      else {
                        std::string buf = __dst;
                      }
                      unsigned __int8 v85 = 0;
                      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                        sub_10004FC84(__p, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
                      }
                      else {
                        __p[0] = buf;
                      }
                      char v86 = 0;
                      if (ctu::cf::convert_copy())
                      {
                        uint64_t v72 = v85;
                        unsigned __int8 v85 = v86;
                        uint64_t v87 = v72;
                        sub_1000558F4(&v87);
                      }
                      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__p[0].__r_.__value_.__l.__data_);
                      }
                      uint64_t v83 = v85;
                      unsigned __int8 v85 = 0;
                      sub_1000558F4(&v85);
                      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(buf.__r_.__value_.__l.__data_);
                      }
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(__dst.__r_.__value_.__l.__data_);
                      }
                      CFArrayAppendValue(v84, v83);
                      sub_1000558F4(&v83);
                      uint64_t v73 = (void *)v71[1];
                      if (v73)
                      {
                        do
                        {
                          uint64_t v74 = v73;
                          uint64_t v73 = (void *)*v73;
                        }
                        while (v73);
                      }
                      else
                      {
                        do
                        {
                          uint64_t v74 = (void *)v71[2];
                          BOOL v32 = *v74 == (void)v71;
                          std::string v71 = v74;
                        }
                        while (!v32);
                      }
                      std::string v71 = v74;
                    }
                    while (v74 != (void *)(a1 + 768));
                  }
                  unsigned int v75 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_1000E8F34(*v65, (std::string *)(a1 + 768), ",", 1uLL, __p);
                    std::string v76 = (__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                        ? __p
                        : (std::string *)__p[0].__r_.__value_.__r.__words[0];
                    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v76;
                    WORD2(buf.__r_.__value_.__r.__words[1]) = 2112;
                    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v84;
                    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I save local transferred plans: [%s], %@", (uint8_t *)&buf, 0x16u);
                    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p[0].__r_.__value_.__l.__data_);
                    }
                  }
                  (*(void (**)(uint64_t, const __CFString *, __CFArray *, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v67 + 16))(v67, @"kLocalTransferredPlans", v84, @"com.apple.commcenter.cellular_plan", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
                  (*(void (**)(uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v67 + 48))(v67, @"com.apple.commcenter.cellular_plan", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
                  sub_1000440D4((const void **)&v84);
                }
                if ((v68 & 1) == 0) {
                  sub_10004D2C8(v66);
                }
                uint64_t v20 = v80;
                goto LABEL_168;
              }
            }
            else
            {
              uint64_t v67 = 0;
            }
            std::mutex::unlock(v59);
            uint64_t v66 = 0;
            char v68 = 1;
            goto LABEL_129;
          }
LABEL_168:
          sub_10004D2C8(v20);
          goto LABEL_169;
        }
      }
      uint64_t v26 = v93;
      if ((v93 & 0x80u) == 0) {
        size_t v27 = v93;
      }
      else {
        size_t v27 = __n;
      }
      uint64_t v28 = *((unsigned __int8 *)v22 + 55);
      int v29 = (char)v28;
      if ((v28 & 0x80u) != 0) {
        uint64_t v28 = v22[5];
      }
      if (v27 != v28) {
        goto LABEL_109;
      }
      if (v29 >= 0) {
        long long v30 = (unsigned __int8 *)(v22 + 4);
      }
      else {
        long long v30 = (unsigned __int8 *)*v25;
      }
      if ((v93 & 0x80) != 0)
      {
        BOOL v32 = memcmp(__s1, v30, __n) || __p[0].__r_.__value_.__s.__data_[4] == 0;
        if (v32) {
          goto LABEL_109;
        }
      }
      else
      {
        if (v93)
        {
          p_s1 = &__s1;
          while (*(unsigned __int8 *)p_s1 == *v30)
          {
            p_s1 = (void **)((char *)p_s1 + 1);
            ++v30;
            if (!--v26) {
              goto LABEL_55;
            }
          }
          goto LABEL_109;
        }
LABEL_55:
        if (!__p[0].__r_.__value_.__s.__data_[4])
        {
LABEL_109:
          if (v94) {
            sub_10030D10C((uint64_t)__p);
          }
          goto LABEL_111;
        }
      }
      if (sub_10010E128((uint64_t)v24, v89)) {
        goto LABEL_109;
      }
      char v33 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        if (v90 >= 0) {
          uint64_t v34 = v89;
        }
        else {
          uint64_t v34 = (void **)v89[0];
        }
        std::string::size_type v35 = (std::string::size_type)(v22 + 4);
        if (*((char *)v22 + 55) < 0) {
          std::string::size_type v35 = (std::string::size_type)*v25;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v35;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I local transfer %s -> %s complete.", (uint8_t *)&buf, 0x16u);
      }
      char v79 = v24;
      sub_1000F29CC(v24, v89, (uint64_t)v89);
      sub_100CAF704(a1, 0, (uint64_t)v89, 0);
      uint64_t v78 = a2;
      uint64_t v37 = *(int **)(a1 + 160);
      uint64_t v36 = *(int **)(a1 + 168);
      if (v37 != v36)
      {
        unsigned int v81 = 0;
        uint64_t v38 = *((unsigned __int8 *)v22 + 55);
        size_t v39 = v22[5];
        if ((v38 & 0x80u) == 0) {
          uint64_t v40 = *((unsigned __int8 *)v22 + 55);
        }
        else {
          uint64_t v40 = v22[5];
        }
        while (1)
        {
          uint64_t v41 = *((unsigned __int8 *)v37 + 95);
          int v42 = (char)v41;
          if ((v41 & 0x80u) != 0) {
            uint64_t v41 = *((void *)v37 + 10);
          }
          if (v40 != v41) {
            goto LABEL_87;
          }
          uint64_t v43 = v42 >= 0 ? (unsigned __int8 *)(v37 + 18) : (unsigned __int8 *)*((void *)v37 + 9);
          if ((v38 & 0x80) == 0) {
            break;
          }
          if (!memcmp(*v25, v43, v39)) {
            goto LABEL_86;
          }
LABEL_87:
          v37 += 42;
          if (v37 == v36) {
            goto LABEL_90;
          }
        }
        if (v38)
        {
          uint64_t v44 = (unsigned __int8 *)(v22 + 4);
          uint64_t v45 = v38;
          while (*v44 == *v43)
          {
            ++v44;
            ++v43;
            if (!--v45) {
              goto LABEL_86;
            }
          }
          goto LABEL_87;
        }
LABEL_86:
        unsigned int v81 = *v37;
        goto LABEL_87;
      }
      unsigned int v81 = 0;
LABEL_90:
      uint64_t v46 = LODWORD(__p[0].__r_.__value_.__r.__words[1]);
      if (LODWORD(__p[0].__r_.__value_.__r.__words[1]) == v81)
      {
        char v23 = 1;
        a2 = v78;
        uint64_t v24 = v79;
        uint64_t v20 = v80;
        goto LABEL_109;
      }
      uint64_t v20 = v80;
      (***(void (****)(std::string *__return_ptr))(a1 + 56))(&__dst);
      a2 = v78;
      uint64_t v24 = v79;
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0uLL;
      char isValidSimSlot = subscriber::isValidSimSlot();
      if (buf.__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
      }
      if (__dst.__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_);
      }
      if (isValidSimSlot)
      {
        (***(void (****)(std::string *__return_ptr))(a1 + 56))(&__dst);
        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0uLL;
        char v48 = subscriber::isValidSimSlot();
        if (buf.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
        }
        if (__dst.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_);
        }
        char v49 = *(NSObject **)(a1 + 40);
        if (v48)
        {
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v50 = subscriber::asString();
            uint64_t v51 = subscriber::asString();
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v50;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v51;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I apply preference from %s -> %s", (uint8_t *)&buf, 0x16u);
          }
          sub_100CC1BB8(a1, v46, v81);
          goto LABEL_108;
        }
        if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
LABEL_108:
          char v23 = 1;
          goto LABEL_109;
        }
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        char v53 = v49;
        uint64_t v54 = "invalid source instance";
      }
      else
      {
        std::string::size_type v52 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
          goto LABEL_108;
        }
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        char v53 = v52;
        uint64_t v54 = "invalid target instance";
      }
      _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, v54, (uint8_t *)&buf, 2u);
      goto LABEL_108;
    }
  }
LABEL_169:
  uint64_t result = (uint64_t **)(a1 + 288);
  if (a1 + 288 != a2) {
    return sub_100429020(result, *(long long **)a2, (long long *)(a2 + 8));
  }
  return result;
}

void sub_100CAB404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, std::__shared_weak_count *a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  if (LOBYTE(STACK[0x560])) {
    sub_10030D10C((uint64_t)va);
  }
  sub_10004D2C8(a6);
  _Unwind_Resume(a1);
}

void sub_100CAB520(uint64_t a1, uint64_t a2)
{
  BOOL v4 = (uint64_t **)(a1 + 1176);
  if (v4 != (uint64_t **)a2) {
    sub_1000EA390(v4, *(void **)a2, (void *)(a2 + 8));
  }
  if (*(void *)(a2 + 16))
  {
    long long v9 = 0u;
    long long v10 = 0u;
    sub_100CA5A14((uint64_t)&v9, a1);
    if ((_BYTE)v9)
    {
      std::string::size_type v5 = *(std::__shared_weak_count **)(a1 + 80);
      if (v5)
      {
        BOOL v6 = std::__shared_weak_count::lock(v5);
        if (v6)
        {
          char v7 = v6;
          uint64_t v8 = *(void *)(a1 + 72);
          if (v8) {
            (*(void (**)(uint64_t))(*(void *)v8 + 64))(v8);
          }
          sub_10004D2C8(v7);
        }
      }
    }
    sub_1000886C0((uint64_t)&v9 + 8, (char *)v10);
  }
}

void sub_100CAB5E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char *a11)
{
  sub_10004D2C8(v11);
  sub_1000886C0((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t **sub_100CAB60C(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t **)(a1 + 216);
  if (result != (uint64_t **)a2) {
    return sub_100328AC0(result, *(long long **)a2, (long long *)(a2 + 8));
  }
  return result;
}

uint64_t **sub_100CAB628(uint64_t a1, uint64_t **a2)
{
  uint64_t result = (uint64_t **)(a1 + 240);
  if (result != a2) {
    return sub_10060B564(result, *a2, a2 + 1);
  }
  return result;
}

uint64_t sub_100CAB644(uint64_t result, char a2)
{
  *(unsigned char *)(result + 208) = a2;
  return result;
}

uint64_t sub_100CAB64C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 208);
}

void sub_100CAB654(uint64_t a1, uint64_t *a2)
{
  sub_100CAB664(a1, a2, *(void *)(a1 + 160) == *(void *)(a1 + 168));
}

void sub_100CAB664(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (0xCF3CF3CF3CF3CF3DLL * ((v4 - *a2) >> 3) < *(unsigned int *)(a1 + 788)
    || (int v12 = capabilities::ct::supportsDynamicSID((capabilities::ct *)a1), v5 = *a2, v4 = a2[1], v12)
    && 0xCF3CF3CF3CF3CF3DLL * ((v4 - v5) >> 3) <= 1)
  {
    BOOL v6 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LODWORD(v248.__r_.__value_.__r.__words[1]) = 134217984;
    *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = 0xCF3CF3CF3CF3CF3DLL
                                                                                * ((v4 - v5) >> 3);
    char v7 = "#I Not enough SIMs (%lu) - wait";
LABEL_4:
    uint64_t v8 = v6;
    uint32_t v9 = 12;
    goto LABEL_5;
  }
  int v244 = a3;
  if (v5 == v4)
  {
    int v13 = 0;
    char v14 = 0;
LABEL_85:
    std::string::size_type v35 = *(capabilities::ct **)(a1 + 88);
    if (v35) {
      std::string::size_type v35 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, uint64_t *))(*(void *)v35 + 56))(v35, a2);
    }
    uint64_t v37 = *(void *)(a1 + 160);
    uint64_t v36 = a1 + 160;
    uint64_t v38 = *a2;
    uint64_t v39 = a2[1];
    if (v39 - *a2 != *(void *)(a1 + 168) - v37) {
      goto LABEL_94;
    }
    while (v38 != v39)
    {
      std::string::size_type v35 = (capabilities::ct *)BasicSimInfo::operator==();
      if (!v35) {
        goto LABEL_94;
      }
      v38 += 168;
      v37 += 168;
    }
    if (v244)
    {
LABEL_94:
      if (*(void *)(a1 + 136) == *(void *)(a1 + 144) && capabilities::ct::supportedVinylSlotCount(v35))
      {
        uint64_t v46 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v248.__r_.__value_.__r.__words[1]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Vinyl info not ready - wait", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 2u);
        }
        if ((uint64_t *)v36 != a2) {
          sub_1003DB990(v36, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
        }
        return;
      }
      uint64_t v41 = *a2;
      uint64_t v42 = a2[1];
      if (*a2 == v42)
      {
        uint64_t v45 = *a2;
LABEL_108:
        uint64_t v48 = *(void *)(a1 + 160);
        uint64_t v47 = *(void *)(a1 + 168);
        if (v47 - v48 != v45 - v41) {
          goto LABEL_165;
        }
        while (v48 != v47)
        {
          if (!BasicSimInfo::operator==()) {
            goto LABEL_165;
          }
          v48 += 168;
          v41 += 168;
        }
        if (v244)
        {
LABEL_165:
          if ((uint64_t *)v36 != a2) {
            sub_1003DB990(a1 + 160, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
          }
          uint64_t v66 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v248.__r_.__value_.__r.__words[1]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I No SIMs inserted", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 2u);
          }
          uint64_t v67 = *(std::__shared_weak_count **)(a1 + 80);
          if (v67)
          {
            char v68 = std::__shared_weak_count::lock(v67);
            if (v68)
            {
              char v69 = v68;
              uint64_t v70 = *(void *)(a1 + 72);
              if (v70)
              {
                (*(void (**)(void, void))(*(void *)v70 + 16))(*(void *)(a1 + 72), 0);
                if ((v244 & 1) != 0
                  || (*(char *)(a1 + 839) < 0 ? (uint64_t v71 = *(void *)(a1 + 824)) : (uint64_t v71 = *(unsigned __int8 *)(a1 + 839)),
                      v71 || *(_DWORD *)(a1 + 788) == 1))
                {
                  v248.__r_.__value_.__r.__words[2] = 0;
                  *(void *)&long long v249 = 0;
                  v248.__r_.__value_.__l.__size_ = (std::string::size_type)&v248.__r_.__value_.__r.__words[2];
                  sub_100058DB0(&__dst, "");
                  (*(void (**)(uint64_t, std::string::size_type *, std::string *))(*(void *)v70 + 160))(v70, &v248.__r_.__value_.__l.__size_, &__dst);
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                  sub_10005CD2C((uint64_t)&v248.__r_.__value_.__l.__size_, (char *)v248.__r_.__value_.__r.__words[2]);
                  sub_10005CD2C(a1 + 792, *(char **)(a1 + 800));
                  *(void *)(a1 + 792) = a1 + 800;
                  *(void *)(a1 + 808) = 0;
                  *(void *)(a1 + 800) = 0;
                  if (*(_DWORD *)(a1 + 788) == 1) {
                    sub_100CA4DAC(a1);
                  }
                }
              }
              sub_10004D2C8(v69);
            }
          }
        }
        return;
      }
      while (1)
      {
        char isVirtualEsim = subscriber::isVirtualEsim();
        char v44 = *(_DWORD *)(v41 + 8) == 1 ? 1 : isVirtualEsim;
        if ((v44 & 1) == 0) {
          break;
        }
        v41 += 168;
        if (v41 == v42)
        {
          uint64_t v41 = *a2;
          uint64_t v45 = a2[1];
          goto LABEL_108;
        }
      }
      if ((v244 & 1) == 0)
      {
        BOOL v49 = *(_DWORD *)(a1 + 788) < 2u || v13 == 0;
        if (!v49 && v14 != 0)
        {
          uint64_t v96 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v248.__r_.__value_.__r.__words[1]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "#I Tray absence detected, do not evaluate selection", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 2u);
          }
          if ((uint64_t *)v36 != a2) {
            sub_1003DB990(a1 + 160, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
          }
          uint64_t v98 = *(void *)(a1 + 792);
          if (v98 != a1 + 800)
          {
            do
            {
              unsigned int v99 = (void *)(v98 + 32);
              if (sub_100CBFD40((unsigned __int8 **)(v98 + 32), *(void *)(a1 + 160), *(void *)(a1 + 168)))
              {
                uint64_t v100 = *(uint64_t **)(v98 + 8);
                if (v100)
                {
                  do
                  {
                    BOOL v101 = v100;
                    uint64_t v100 = (uint64_t *)*v100;
                  }
                  while (v100);
                }
                else
                {
                  do
                  {
                    BOOL v101 = *(uint64_t **)(v98 + 16);
                    BOOL v30 = *v101 == v98;
                    uint64_t v98 = (uint64_t)v101;
                  }
                  while (!v30);
                }
              }
              else
              {
                uint64_t v102 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
                {
                  if (*(char *)(v98 + 55) < 0) {
                    unsigned int v99 = (void *)*v99;
                  }
                  LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
                  *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)v99;
                  _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "#I Removing ICCID from cache (%s)", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 0xCu);
                }
                BOOL v101 = sub_1000E1C44((uint64_t **)(a1 + 792), v98);
              }
              uint64_t v98 = (uint64_t)v101;
            }
            while (v101 != (uint64_t *)(a1 + 800));
          }
          char v103 = *(std::__shared_weak_count **)(a1 + 80);
          if (v103)
          {
            uint64_t v104 = std::__shared_weak_count::lock(v103);
            if (v104)
            {
              int v105 = v104;
              uint64_t v106 = *(void *)(a1 + 72);
              if (v106) {
                (*(void (**)(uint64_t, void))(*(void *)v106 + 16))(v106, 0);
              }
              sub_10004D2C8(v105);
            }
          }
          if (*(char *)(a1 + 1159) < 0) {
            uint64_t v107 = *(void *)(a1 + 1144);
          }
          else {
            uint64_t v107 = *(unsigned __int8 *)(a1 + 1159);
          }
          if (!v107) {
            return;
          }
          uint64_t v172 = *(void *)(a1 + 160);
          uint64_t v173 = *(void *)(a1 + 168);
          if (v172 == v173) {
            return;
          }
          while (1)
          {
            uint64_t v174 = *(unsigned __int8 *)(v172 + 95);
            if ((v174 & 0x80u) == 0) {
              uint64_t v175 = *(unsigned __int8 *)(v172 + 95);
            }
            else {
              uint64_t v175 = *(void *)(v172 + 80);
            }
            uint64_t v176 = *(unsigned __int8 *)(a1 + 1159);
            int v177 = (char)v176;
            if ((v176 & 0x80u) != 0) {
              uint64_t v176 = *(void *)(a1 + 1144);
            }
            if (v175 != v176) {
              goto LABEL_453;
            }
            v178 = v177 >= 0 ? (unsigned __int8 *)(a1 + 1136) : *(unsigned __int8 **)(a1 + 1136);
            if ((v174 & 0x80) == 0) {
              break;
            }
            if (!memcmp(*(const void **)(v172 + 72), v178, *(void *)(v172 + 80))) {
              goto LABEL_452;
            }
LABEL_453:
            v172 += 168;
            if (v172 == v173) {
              return;
            }
          }
          if (*(unsigned char *)(v172 + 95))
          {
            uint64_t v179 = 0;
            while (*(unsigned __int8 *)(v172 + v179 + 72) == v178[v179])
            {
              if (v174 == ++v179) {
                goto LABEL_452;
              }
            }
            goto LABEL_453;
          }
LABEL_452:
          sub_100CAD864(a1);
          goto LABEL_453;
        }
      }
      *(_OWORD *)&v245.__r_.__value_.__r.__words[1] = 0uLL;
      v245.__r_.__value_.__r.__words[0] = (std::string::size_type)&v245.__r_.__value_.__l.__size_;
      if (*(void *)(a1 + 808))
      {
        uint64_t v51 = *(unsigned __int8 ***)(a1 + 792);
        if (v51 != (unsigned __int8 **)(a1 + 800))
        {
          std::string::size_type v52 = (const void **)(a1 + 816);
          while (1)
          {
            if (!sub_100CBFD40(v51 + 4, *a2, a2[1])) {
              goto LABEL_153;
            }
            uint64_t v53 = *(unsigned __int8 *)(a1 + 839);
            if ((v53 & 0x80u) == 0) {
              uint64_t v54 = (unsigned __int8 *)*(unsigned __int8 *)(a1 + 839);
            }
            else {
              uint64_t v54 = *(unsigned __int8 **)(a1 + 824);
            }
            int v55 = (unsigned __int8 *)*((unsigned __int8 *)v51 + 55);
            int v56 = (char)v55;
            if ((char)v55 < 0) {
              int v55 = v51[5];
            }
            if (v54 != v55) {
              goto LABEL_142;
            }
            if (v56 >= 0) {
              char v57 = (unsigned __int8 *)(v51 + 4);
            }
            else {
              char v57 = v51[4];
            }
            if ((v53 & 0x80) != 0)
            {
              std::string::size_type v60 = *v52;
              if (memcmp(*v52, v57, *(void *)(a1 + 824))) {
                goto LABEL_142;
              }
              int v59 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
                goto LABEL_151;
              }
            }
            else
            {
              if (*(unsigned char *)(a1 + 839))
              {
                uint64_t v58 = (unsigned __int8 *)(a1 + 816);
                while (*v58 == *v57)
                {
                  ++v58;
                  ++v57;
                  if (!--v53)
                  {
                    int v59 = *(NSObject **)(a1 + 40);
                    if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_153;
                    }
                    goto LABEL_149;
                  }
                }
LABEL_142:
                long long v260 = 0u;
                long long v261 = 0u;
                long long v258 = 0u;
                long long v259 = 0u;
                long long v256 = 0u;
                long long v257 = 0u;
                long long v254 = 0u;
                long long v255 = 0u;
                long long v252 = 0u;
                long long v253 = 0u;
                long long v250 = 0u;
                long long v251 = 0u;
                *(_OWORD *)&v248.__r_.__value_.__r.__words[1] = 0u;
                long long v249 = 0u;
                sGetProfileDetails();
                if (BYTE8(v261))
                {
                  if (BYTE8(v253))
                  {
                    uint64_t v61 = *(NSObject **)(a1 + 40);
                    if (!os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)
                      || (LOWORD(__dst.__r_.__value_.__l.__data_) = 0,
                          _os_log_error_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "Bootstrap set as user enabled profile - removing", (uint8_t *)&__dst, 2u), BYTE8(v261)))
                    {
                      sub_1000C584C((uint64_t)&v248.__r_.__value_.__l.__size_);
                    }
                    goto LABEL_153;
                  }
                  sub_1000C584C((uint64_t)&v248.__r_.__value_.__l.__size_);
                }
                sub_100046BAC((uint64_t **)&v245, (void **)v51 + 4, (uint64_t)(v51 + 4));
                goto LABEL_153;
              }
              int v59 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
              {
LABEL_149:
                std::string::size_type v60 = (const void *)(a1 + 816);
LABEL_151:
                LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
                *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)v60;
                _os_log_error_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "UserDisabledPhySimIccid (%s) set as user enabled profile - removing", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 0xCu);
              }
            }
LABEL_153:
            uint64_t v62 = v51[1];
            if (v62)
            {
              do
              {
                unsigned int v63 = (unsigned __int8 **)v62;
                uint64_t v62 = *(unsigned __int8 **)v62;
              }
              while (v62);
            }
            else
            {
              do
              {
                unsigned int v63 = (unsigned __int8 **)v51[2];
                BOOL v30 = *v63 == (unsigned __int8 *)v51;
                uint64_t v51 = v63;
              }
              while (!v30);
            }
            uint64_t v51 = v63;
            if (v63 == (unsigned __int8 **)(a1 + 800)) {
              goto LABEL_242;
            }
          }
        }
        goto LABEL_242;
      }
      if (!v244 || (v74 = *a2, uint64_t v75 = a2[1], *a2 == v75))
      {
LABEL_242:
        if ((sub_100CBFD40((unsigned __int8 **)(a1 + 816), *a2, a2[1]) & 1) == 0)
        {
          uint64_t v90 = *a2;
          uint64_t v91 = a2[1];
          while (v90 != v91)
          {
            if ((subscriber::isEsimCapable() & 1) == 0 && (*(_DWORD *)(a1 + 788) != 1 || *(_DWORD *)(v90 + 4) != 1))
            {
              if (!subscriber::isSimInserted()) {
                goto LABEL_290;
              }
              if (subscriber::isSimSettled())
              {
                uint64_t v93 = *(unsigned __int8 *)(v90 + 95);
                if ((v93 & 0x80u) != 0) {
                  uint64_t v93 = *(void *)(v90 + 80);
                }
                if (!v93) {
                  goto LABEL_290;
                }
              }
            }
            v90 += 168;
          }
          char v94 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v95 = a1 + 816;
            if (*(char *)(a1 + 839) < 0) {
              std::string::size_type v95 = *(void *)(a1 + 816);
            }
            LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
            *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = v95;
            _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I Clearing disabled ICCID (%s)", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 0xCu);
          }
          if (*(char *)(a1 + 839) < 0)
          {
            **(unsigned char **)(a1 + 816) = 0;
            *(void *)(a1 + 824) = 0;
          }
          else
          {
            *(unsigned char *)(a1 + 816) = 0;
            *(unsigned char *)(a1 + 839) = 0;
          }
        }
LABEL_290:
        std::string::size_type v110 = v245.__r_.__value_.__r.__words[2];
        std::string::size_type v111 = *(unsigned int *)(a1 + 788);
        v242 = (const void **)(a1 + 816);
        if (v245.__r_.__value_.__r.__words[2] < v111)
        {
          uint64_t v112 = *a2;
          uint64_t v113 = a2[1];
          if (*a2 == v113) {
            goto LABEL_379;
          }
          while (1)
          {
            if ((subscriber::isEsimCapable() & 1) == 0)
            {
              char v114 = *(unsigned char *)(v112 + 95);
              if (v114 < 0)
              {
                if (!*(void *)(v112 + 80)) {
                  goto LABEL_293;
                }
              }
              else if (!*(unsigned char *)(v112 + 95))
              {
                goto LABEL_293;
              }
              long long v115 = (unsigned __int8 **)(v112 + 72);
              uint64_t v116 = *(unsigned __int8 *)(a1 + 839);
              if ((v116 & 0x80u) == 0) {
                uint64_t v117 = *(unsigned __int8 *)(a1 + 839);
              }
              else {
                uint64_t v117 = *(void *)(a1 + 824);
              }
              if (v114 >= 0) {
                uint64_t v118 = *(unsigned __int8 *)(v112 + 95);
              }
              else {
                uint64_t v118 = *(void *)(v112 + 80);
              }
              if (v117 != v118) {
                goto LABEL_316;
              }
              if (v114 >= 0) {
                long long v119 = (unsigned __int8 **)(v112 + 72);
              }
              else {
                long long v119 = (unsigned __int8 **)*v115;
              }
              if ((v116 & 0x80) != 0)
              {
                if (memcmp(*v242, v119, *(void *)(a1 + 824))) {
                  goto LABEL_316;
                }
              }
              else if (*(unsigned char *)(a1 + 839))
              {
                long long v120 = (unsigned __int8 *)(a1 + 816);
                while (*v120 == *(unsigned __int8 *)v119)
                {
                  ++v120;
                  long long v119 = (unsigned __int8 **)((char *)v119 + 1);
                  if (!--v116) {
                    goto LABEL_293;
                  }
                }
LABEL_316:
                (***(void (****)(std::string::size_type *__return_ptr))(a1 + 56))(&v248.__r_.__value_.__l.__size_);
                ServiceMap = (std::mutex *)Registry::getServiceMap(v121, (Registry *)v248.__r_.__value_.__l.__size_);
                long long v123 = ServiceMap;
                if ((v124 & 0x8000000000000000) != 0)
                {
                  std::string v125 = (unsigned __int8 *)(v124 & 0x7FFFFFFFFFFFFFFFLL);
                  uint64_t v126 = 5381;
                  do
                  {
                    std::string::size_type v124 = v126;
                    unsigned int v127 = *v125++;
                    uint64_t v126 = (33 * v126) ^ v127;
                  }
                  while (v127);
                }
                std::mutex::lock(ServiceMap);
                __dst.__r_.__value_.__r.__words[0] = v124;
                unint64_t v128 = sub_10004D37C(&v123[1].__m_.__sig, (unint64_t *)&__dst);
                if (v128)
                {
                  uint64_t v129 = v128[3];
                  long long v130 = (std::__shared_weak_count *)v128[4];
                  if (v130)
                  {
                    atomic_fetch_add_explicit(&v130->__shared_owners_, 1uLL, memory_order_relaxed);
                    std::mutex::unlock(v123);
                    atomic_fetch_add_explicit(&v130->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v130);
                    char v131 = 0;
                    goto LABEL_324;
                  }
                }
                else
                {
                  uint64_t v129 = 0;
                }
                std::mutex::unlock(v123);
                long long v130 = 0;
                char v131 = 1;
LABEL_324:
                if (v248.__r_.__value_.__r.__words[2]) {
                  sub_10004D2C8((std::__shared_weak_count *)v248.__r_.__value_.__r.__words[2]);
                }
                if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v129 + 304))(v129, v112 + 72))
                {
                  long long v132 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(v248.__r_.__value_.__r.__words[1]) = 0;
                    long long v133 = v132;
                    uint64_t v134 = "#I SKIP auto enable abandoned 4FF";
                    uint32_t v135 = 2;
                    goto LABEL_334;
                  }
                }
                else
                {
                  sub_100046BAC((uint64_t **)&v245, (void **)(v112 + 72), v112 + 72);
                  if (v136)
                  {
                    uint64_t v137 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
                    {
                      if (*(char *)(v112 + 95) < 0) {
                        long long v115 = (unsigned __int8 **)*v115;
                      }
                      LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
                      *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)v115;
                      long long v133 = v137;
                      uint64_t v134 = "#I 4FF Inserted (%s)";
                      uint32_t v135 = 12;
LABEL_334:
                      _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, v134, (uint8_t *)&v248.__r_.__value_.__s.__data_[8], v135);
                    }
                  }
                }
                if ((v131 & 1) == 0) {
                  sub_10004D2C8(v130);
                }
              }
            }
LABEL_293:
            v112 += 168;
            if (v112 == v113)
            {
              LODWORD(v111) = *(_DWORD *)(a1 + 788);
              std::string::size_type v110 = v245.__r_.__value_.__r.__words[2];
LABEL_379:
              if (v111 != 1 || v110 != 0)
              {
LABEL_491:
                if (v245.__r_.__value_.__r.__words[2] > *(unsigned int *)(a1 + 788))
                {
                  v187 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v187, OS_LOG_TYPE_FAULT))
                  {
                    sub_1000E8F34((std::string *)v245.__r_.__value_.__l.__data_, (std::string *)&v245.__r_.__value_.__r.__words[1], ",", 1uLL, (std::string *)&v248.__r_.__value_.__r.__words[1]);
                    uint64_t v234 = (SBYTE7(v249) & 0x80u) == 0
                         ? &v248.__r_.__value_.__r.__words[1]
                         : (std::string::size_type *)v248.__r_.__value_.__l.__size_;
                    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v234;
                    _os_log_fault_impl((void *)&_mh_execute_header, v187, OS_LOG_TYPE_FAULT, "Uhh, too many ICCIDs - this is bad (%s)", (uint8_t *)&__dst, 0xCu);
                    if (SBYTE7(v249) < 0) {
                      operator delete((void *)v248.__r_.__value_.__l.__size_);
                    }
                  }
                }
                goto LABEL_493;
              }
              if (*(char *)(a1 + 839) < 0) {
                uint64_t v156 = *(void *)(a1 + 824);
              }
              else {
                uint64_t v156 = *(unsigned __int8 *)(a1 + 839);
              }
              if (v156) {
                sub_1000F29CC((uint64_t **)&v245, (void **)v242, (uint64_t)v242);
              }
              uint64_t v180 = *(void *)(a1 + 136);
              uint64_t v181 = *(void *)(a1 + 144);
              while (2)
              {
                if (v180 != v181)
                {
                  if (!*(unsigned char *)(v180 + 80))
                  {
LABEL_479:
                    v180 += 88;
                    continue;
                  }
                  uint64_t v182 = *(void *)(v180 + 56);
                  uint64_t v183 = *(void *)(v180 + 64);
                  while (2)
                  {
                    if (v182 == v183) {
                      goto LABEL_479;
                    }
                    if (*(unsigned char *)(v182 + 89))
                    {
                      if (*(unsigned char *)(v182 + 88))
                      {
                        v239 = *(NSObject **)(a1 + 40);
                        if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
                        {
                          LOWORD(v248.__r_.__value_.__r.__words[1]) = 0;
                          int v184 = "#I Bootstrap active - not selecting anything";
                          goto LABEL_482;
                        }
                        goto LABEL_483;
                      }
                      goto LABEL_473;
                    }
                    if (*(_DWORD *)v180 == 1 && *(void *)(a1 + 168) - *(void *)(a1 + 160) == 168)
                    {
                      if (v245.__r_.__value_.__r.__words[2])
                      {
                        v239 = *(NSObject **)(a1 + 40);
                        if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
                        {
                          LOWORD(v248.__r_.__value_.__r.__words[1]) = 0;
                          int v184 = "#I Multiple user profiles detected - not selecting anything";
LABEL_482:
                          _os_log_impl((void *)&_mh_execute_header, v239, OS_LOG_TYPE_DEFAULT, v184, (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 2u);
                        }
LABEL_483:
                        sub_10005CD2C((uint64_t)&v245, (char *)v245.__r_.__value_.__l.__size_);
                        *(_OWORD *)&v245.__r_.__value_.__r.__words[1] = 0uLL;
                        v245.__r_.__value_.__r.__words[0] = (std::string::size_type)&v245.__r_.__value_.__l.__size_;
                        goto LABEL_493;
                      }
LABEL_473:
                      sub_100046BAC((uint64_t **)&v245, (void **)(v182 + 16), v182 + 16);
                    }
                    v182 += 216;
                    continue;
                  }
                }
                break;
              }
              if (!sub_10010E128((uint64_t)&v245, (void **)v242)) {
                goto LABEL_491;
              }
              unint64_t v185 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v185, OS_LOG_TYPE_DEFAULT))
              {
                if (*(char *)(a1 + 839) < 0) {
                  v186 = *v242;
                }
                else {
                  v186 = (const void *)(a1 + 816);
                }
                LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
                *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)v186;
                _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_DEFAULT, "#I No eSIMs available - physical SIM present, enabling: (%s)", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 0xCu);
              }
              if (*(char *)(a1 + 839) < 0)
              {
                **(unsigned char **)(a1 + 816) = 0;
                *(void *)(a1 + 824) = 0;
              }
              else
              {
                *(unsigned char *)(a1 + 816) = 0;
                *(unsigned char *)(a1 + 839) = 0;
              }
LABEL_493:
              memset(&__dst, 0, sizeof(__dst));
              sub_1000C6BDC((uint64_t *)&__dst, (uint64_t)&v245);
              CFTypeID v188 = *(std::__shared_weak_count **)(a1 + 80);
              if (v188)
              {
                v189 = std::__shared_weak_count::lock(v188);
                if (v189)
                {
                  v243 = v189;
                  uint64_t v190 = *(void *)(a1 + 72);
                  if (v190)
                  {
                    std::string::size_type v191 = v245.__r_.__value_.__r.__words[0];
                    if ((std::string::size_type *)v245.__r_.__value_.__l.__data_ != &v245.__r_.__value_.__r.__words[1])
                    {
                      while (2)
                      {
                        if ((sub_100CB1134(a1, v191 + 32) & 1) == 0) {
                          goto LABEL_545;
                        }
                        (*(void (**)(std::string::size_type *__return_ptr, uint64_t, std::string::size_type))(*(void *)v190 + 104))(&v248.__r_.__value_.__l.__size_, v190, v191 + 32);
                        if (!v265) {
                          goto LABEL_545;
                        }
                        uint64_t v192 = v264;
                        size_t v193 = __n;
                        if ((v264 & 0x80u) == 0) {
                          size_t v194 = v264;
                        }
                        else {
                          size_t v194 = __n;
                        }
                        uint64_t v195 = *(unsigned __int8 *)(v191 + 55);
                        int v196 = (char)v195;
                        if ((v195 & 0x80u) != 0) {
                          uint64_t v195 = *(void *)(v191 + 40);
                        }
                        if (v194 == v195)
                        {
                          if (v196 >= 0) {
                            v197 = (unsigned __int8 *)(v191 + 32);
                          }
                          else {
                            v197 = *(unsigned __int8 **)(v191 + 32);
                          }
                          if ((v264 & 0x80) == 0)
                          {
                            if (v264)
                            {
                              p_s1 = &__s1;
                              uint64_t v199 = v264;
                              while (*(unsigned __int8 *)p_s1 == *v197)
                              {
                                p_s1 = (void **)((char *)p_s1 + 1);
                                ++v197;
                                if (!--v199) {
                                  goto LABEL_531;
                                }
                              }
                              goto LABEL_514;
                            }
LABEL_531:
                            int v205 = 3;
LABEL_541:
                            if (v265) {
                              sub_10030D10C((uint64_t)&v248.__r_.__value_.__l.__size_);
                            }
                            if (v205 != 3 && v205) {
                              goto LABEL_551;
                            }
LABEL_545:
                            uint64_t v208 = *(std::string **)(v191 + 8);
                            if (v208)
                            {
                              do
                              {
                                unint64_t v209 = v208;
                                uint64_t v208 = (std::string *)v208->__r_.__value_.__r.__words[0];
                              }
                              while (v208);
                            }
                            else
                            {
                              do
                              {
                                unint64_t v209 = *(std::string **)(v191 + 16);
                                BOOL v30 = v209->__r_.__value_.__r.__words[0] == v191;
                                std::string::size_type v191 = (std::string::size_type)v209;
                              }
                              while (!v30);
                            }
                            std::string::size_type v191 = (std::string::size_type)v209;
                            if (v209 == (std::string *)&v245.__r_.__value_.__r.__words[1]) {
                              goto LABEL_551;
                            }
                            continue;
                          }
                          if (!memcmp(__s1, v197, __n) || v248.__r_.__value_.__s.__data_[8] != 7) {
                            goto LABEL_531;
                          }
                        }
                        else
                        {
LABEL_514:
                          if (v248.__r_.__value_.__s.__data_[8] != 7) {
                            goto LABEL_531;
                          }
                        }
                        break;
                      }
                      uint64_t v200 = *(unsigned __int8 *)(a1 + 1159);
                      int v201 = (char)v200;
                      if ((v200 & 0x80u) != 0) {
                        uint64_t v200 = *(void *)(a1 + 1144);
                      }
                      if (v194 == v200)
                      {
                        if (v201 >= 0) {
                          unint64_t v202 = (unsigned __int8 *)(a1 + 1136);
                        }
                        else {
                          unint64_t v202 = *(unsigned __int8 **)(a1 + 1136);
                        }
                        if ((v192 & 0x80) != 0)
                        {
                          if (memcmp(__s1, v202, v193)) {
                            goto LABEL_533;
                          }
                        }
                        else if (v192)
                        {
                          v203 = &__s1;
                          while (*(unsigned __int8 *)v203 == *v202)
                          {
                            v203 = (void **)((char *)v203 + 1);
                            ++v202;
                            if (!--v192) {
                              goto LABEL_537;
                            }
                          }
                          goto LABEL_533;
                        }
LABEL_537:
                        v207 = *(NSObject **)(a1 + 40);
                        if (os_log_type_enabled(v207, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)v246 = 0;
                          int v205 = 2;
                          _os_log_impl((void *)&_mh_execute_header, v207, OS_LOG_TYPE_DEFAULT, "#I Monitor mode is in progress", v246, 2u);
                          goto LABEL_541;
                        }
                      }
                      else
                      {
LABEL_533:
                        if (!*((unsigned char *)&v248.__r_.__value_.__s + 23))
                        {
                          int v205 = 0;
                          goto LABEL_541;
                        }
                        v206 = *(NSObject **)(a1 + 40);
                        if (os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)v246 = 0;
                          _os_log_impl((void *)&_mh_execute_header, v206, OS_LOG_TYPE_DEFAULT, "#I Monitor mode was successfully completed", v246, 2u);
                        }
                        sub_1000E9358((uint64_t **)&__dst, (void **)(v191 + 32));
                      }
                      int v205 = 2;
                      goto LABEL_541;
                    }
                  }
LABEL_551:
                  sub_10004D2C8(v243);
                }
              }
              sub_10005CD2C((uint64_t)&v245, (char *)v245.__r_.__value_.__l.__size_);
              std::string::size_type size = (char *)__dst.__r_.__value_.__l.__size_;
              std::string v245 = __dst;
              if (__dst.__r_.__value_.__r.__words[2])
              {
                *(void *)(__dst.__r_.__value_.__l.__size_ + 16) = &v245.__r_.__value_.__l.__size_;
                __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst.__r_.__value_.__l.__size_;
                *(_OWORD *)&__dst.__r_.__value_.__r.__words[1] = 0uLL;
                std::string::size_type size = 0;
              }
              else
              {
                v245.__r_.__value_.__r.__words[0] = (std::string::size_type)&v245.__r_.__value_.__l.__size_;
              }
              sub_10005CD2C((uint64_t)&__dst, size);
              if (v245.__r_.__value_.__r.__words[2])
              {
                sub_100CA8010((uint64_t *)&v248.__r_.__value_.__l.__size_, a1);
                uint64_t v211 = sub_100CAE280(&v245, (unsigned __int8 **)&v248.__r_.__value_.__l.__size_) ^ 1;
                sub_10005CD2C((uint64_t)&v248.__r_.__value_.__l.__size_, (char *)v248.__r_.__value_.__r.__words[2]);
              }
              else
              {
                uint64_t v211 = 0;
              }
              if ((uint64_t *)v36 != a2) {
                sub_1003DB990(a1 + 160, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
              }
              if (v245.__r_.__value_.__r.__words[2] == 2) {
                sub_100CAE35C(a1, (std::string **)&v245);
              }
              sub_100CA460C((void *)a1, 3);
              *(_OWORD *)&__dst.__r_.__value_.__r.__words[1] = 0uLL;
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst.__r_.__value_.__l.__size_;
              std::string::size_type v212 = v245.__r_.__value_.__r.__words[0];
              if ((std::string::size_type *)v245.__r_.__value_.__l.__data_ != &v245.__r_.__value_.__r.__words[1])
              {
                do
                {
                  char v213 = sub_100CAE3E4(a1, (void **)(v212 + 32));
                  v248.__r_.__value_.__l.__size_ = v212 + 32;
                  *((unsigned char *)sub_1000ED870((uint64_t **)&__dst, (void **)(v212 + 32), (uint64_t)&unk_10144E20E, (long long **)&v248.__r_.__value_.__l.__size_)+ 56) = v213;
                  v214 = *(std::string **)(v212 + 8);
                  if (v214)
                  {
                    do
                    {
                      int v215 = v214;
                      v214 = (std::string *)v214->__r_.__value_.__r.__words[0];
                    }
                    while (v214);
                  }
                  else
                  {
                    do
                    {
                      int v215 = *(std::string **)(v212 + 16);
                      BOOL v30 = v215->__r_.__value_.__r.__words[0] == v212;
                      std::string::size_type v212 = (std::string::size_type)v215;
                    }
                    while (!v30);
                  }
                  std::string::size_type v212 = (std::string::size_type)v215;
                }
                while (v215 != (std::string *)&v245.__r_.__value_.__r.__words[1]);
              }
              sub_100CA9968((uint64_t *)a1, &__dst, v244, 0);
              sub_100CA85A0(a1);
              uint64_t v216 = *(void *)(a1 + 160);
              uint64_t v217 = *(void *)(a1 + 168);
              if (v216 != v217)
              {
                std::string::size_type v218 = v216 + 72;
                do
                {
                  if (*(char *)(v218 + 23) < 0)
                  {
                    if (*(void *)(v218 + 8))
                    {
LABEL_575:
                      CFIndex v219 = sub_100046F68(a1 + 264, (void **)v218);
                      if ((void **)(a1 + 272) == v219)
                      {
                        int v221 = dword_101B0B230++;
                        v248.__r_.__value_.__l.__size_ = v218;
                        *((_DWORD *)sub_100CC3268((uint64_t **)(a1 + 264), (void **)v218, (long long **)&v248.__r_.__value_.__l.__size_)+ 44) = v221;
                      }
                      else if (!*((_DWORD *)v219 + 44))
                      {
                        int v220 = dword_101B0B230++;
                        *((_DWORD *)v219 + 44) = v220;
                      }
                    }
                  }
                  else if (*(unsigned char *)(v218 + 23))
                  {
                    goto LABEL_575;
                  }
                  std::string::size_type v222 = v218 + 96;
                  v218 += 168;
                }
                while (v222 != v217);
              }
              uint64_t v223 = *(void *)(a1 + 136);
              uint64_t v224 = *(void *)(a1 + 144);
              if (v223 == v224)
              {
LABEL_593:
                v229 = *(std::__shared_weak_count **)(a1 + 80);
                if (v229)
                {
                  uint64_t v230 = std::__shared_weak_count::lock(v229);
                  if (v230)
                  {
                    v231 = v230;
                    uint64_t v232 = *(void *)(a1 + 72);
                    if (v232)
                    {
                      (*(void (**)(void, uint64_t))(*(void *)v232 + 16))(*(void *)(a1 + 72), v211);
                      sub_100CA5A14((uint64_t)&v248.__r_.__value_.__l.__size_, a1);
                      int v233 = v248.__r_.__value_.__s.__data_[8];
                      sub_1000886C0((uint64_t)&v248.__r_.__value_.__r.__words[2], (char *)v249);
                      if (v233) {
                        (*(void (**)(uint64_t))(*(void *)v232 + 64))(v232);
                      }
                    }
                    sub_10004D2C8(v231);
                  }
                }
                sub_100CAD864(a1);
                sub_10005CD2C((uint64_t)&__dst, (char *)__dst.__r_.__value_.__l.__size_);
                sub_10005CD2C((uint64_t)&v245, (char *)v245.__r_.__value_.__l.__size_);
                return;
              }
              while (!*(unsigned char *)(v223 + 80))
              {
LABEL_592:
                v223 += 88;
                if (v223 == v224) {
                  goto LABEL_593;
                }
              }
              uint64_t v225 = *(void *)(v223 + 56);
              uint64_t v226 = *(void *)(v223 + 64);
              while (2)
              {
                if (v225 == v226) {
                  goto LABEL_592;
                }
                if (*(char *)(v225 + 39) < 0)
                {
                  if (!*(void *)(v225 + 24))
                  {
LABEL_591:
                    v225 += 216;
                    continue;
                  }
                }
                else if (!*(unsigned char *)(v225 + 39))
                {
                  goto LABEL_591;
                }
                break;
              }
              v227 = sub_100046F68(a1 + 264, (void **)(v225 + 16));
              if ((void **)(a1 + 272) != v227 && !*((_DWORD *)v227 + 44))
              {
                int v228 = dword_101B0B230++;
                *((_DWORD *)v227 + 44) = v228;
              }
              goto LABEL_591;
            }
          }
        }
        if (v111 == 1)
        {
          uint64_t v139 = *(void *)(a1 + 160);
          uint64_t v138 = *(void *)(a1 + 168);
          for (uint64_t i = v138; ; v138 = i)
          {
            if (v139 == v138) {
              goto LABEL_491;
            }
            if ((subscriber::isEsimCapable() & 1) == 0)
            {
              uint64_t v140 = *a2;
              uint64_t v141 = a2[1];
              if (*a2 != v141) {
                break;
              }
            }
LABEL_378:
            v139 += 168;
          }
          while (1)
          {
            int v142 = *(char *)(v140 + 95);
            if (v142 < 0)
            {
              if (!*(void *)(v140 + 80)) {
                goto LABEL_377;
              }
            }
            else if (!*(unsigned char *)(v140 + 95))
            {
              goto LABEL_377;
            }
            if (*(_DWORD *)(v139 + 4) == *(_DWORD *)(v140 + 4))
            {
              int v143 = (const void **)(v140 + 72);
              char v144 = *(unsigned char *)(v140 + 95);
              int v145 = (char)v142;
              if ((v142 & 0x80u) == 0) {
                uint64_t v146 = *(unsigned __int8 *)(v140 + 95);
              }
              else {
                uint64_t v146 = *(void *)(v140 + 80);
              }
              uint64_t v147 = *(unsigned __int8 *)(v139 + 95);
              int v148 = (char)v147;
              if ((v147 & 0x80u) != 0) {
                uint64_t v147 = *(void *)(v139 + 80);
              }
              if (v146 == v147)
              {
                if (v148 >= 0) {
                  __int16 v149 = (unsigned __int8 *)(v139 + 72);
                }
                else {
                  __int16 v149 = *(unsigned __int8 **)(v139 + 72);
                }
                if ((*(unsigned char *)(v140 + 95) & 0x80) != 0)
                {
                  if (!memcmp(*v143, v149, *(void *)(v140 + 80))) {
                    goto LABEL_377;
                  }
                }
                else
                {
                  if (!*(unsigned char *)(v140 + 95)) {
                    goto LABEL_377;
                  }
                  uint64_t v150 = 0;
                  while (*(unsigned __int8 *)(v140 + v150 + 72) == v149[v150])
                  {
                    if (*(unsigned __int8 *)(v140 + 95) == ++v150) {
                      goto LABEL_377;
                    }
                  }
                }
              }
              uint64_t v151 = *(unsigned __int8 *)(a1 + 839);
              if ((v151 & 0x80u) == 0) {
                uint64_t v152 = *(unsigned __int8 *)(a1 + 839);
              }
              else {
                uint64_t v152 = *(void *)(a1 + 824);
              }
              if (v152 != v146) {
                goto LABEL_427;
              }
              if (v145 >= 0) {
                v153 = (unsigned __int8 *)(v140 + 72);
              }
              else {
                v153 = (unsigned __int8 *)*v143;
              }
              if ((v151 & 0x80) != 0)
              {
                if (memcmp(*v242, v153, *(void *)(a1 + 824))) {
                  goto LABEL_427;
                }
              }
              else if (*(unsigned char *)(a1 + 839))
              {
                int v154 = (unsigned __int8 *)(a1 + 816);
                while (*v154 == *v153)
                {
                  ++v154;
                  ++v153;
                  if (!--v151) {
                    goto LABEL_377;
                  }
                }
LABEL_427:
                v170 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
                {
                  v171 = (const void *)(v140 + 72);
                  if (v144 < 0) {
                    v171 = *v143;
                  }
                  LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
                  *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)v171;
                  _os_log_impl((void *)&_mh_execute_header, v170, OS_LOG_TYPE_DEFAULT, "#I New 4FF Detected (%s)", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 0xCu);
                  char v144 = *(unsigned char *)(v140 + 95);
                }
                if (v144 < 0)
                {
                  sub_10004FC84(&v248.__r_.__value_.__s.__data_[8], *(void **)(v140 + 72), *(void *)(v140 + 80));
                }
                else
                {
                  *(_OWORD *)&v248.__r_.__value_.__r.__words[1] = *(_OWORD *)v143;
                  *(void *)&long long v249 = *(void *)(v140 + 88);
                }
                sub_1002C4208((uint64_t **)&v245, (std::string *)&v248.__r_.__value_.__r.__words[1], (std::string *)((char *)&v249 + 8));
                if (SBYTE7(v249) < 0) {
                  operator delete((void *)v248.__r_.__value_.__l.__size_);
                }
                goto LABEL_491;
              }
            }
LABEL_377:
            v140 += 168;
            if (v140 == v141) {
              goto LABEL_378;
            }
          }
        }
        uint64_t v157 = *a2;
        uint64_t v158 = a2[1];
        if (*a2 == v158) {
          goto LABEL_491;
        }
        while (1)
        {
          if (*(char *)(v157 + 95) < 0)
          {
            if (!*(void *)(v157 + 80)) {
              goto LABEL_425;
            }
          }
          else if (!*(unsigned char *)(v157 + 95))
          {
            goto LABEL_425;
          }
          if ((subscriber::isEsimCapable() & 1) == 0)
          {
            uint64_t v159 = (std::string::size_type *)(v157 + 72);
            uint64_t v160 = *(unsigned __int8 *)(a1 + 839);
            if ((v160 & 0x80u) == 0) {
              uint64_t v161 = *(unsigned __int8 *)(a1 + 839);
            }
            else {
              uint64_t v161 = *(void *)(a1 + 824);
            }
            uint64_t v162 = *(unsigned __int8 *)(v157 + 95);
            int v163 = (char)v162;
            if ((v162 & 0x80u) != 0) {
              uint64_t v162 = *(void *)(v157 + 80);
            }
            if (v161 == v162)
            {
              if (v163 >= 0) {
                uint64_t v164 = (unsigned __int8 *)(v157 + 72);
              }
              else {
                uint64_t v164 = (unsigned __int8 *)*v159;
              }
              if ((v160 & 0x80) != 0)
              {
                if (!memcmp(*v242, v164, *(void *)(a1 + 824))) {
                  goto LABEL_425;
                }
              }
              else
              {
                if (!*(unsigned char *)(a1 + 839)) {
                  goto LABEL_425;
                }
                v165 = (unsigned __int8 *)(a1 + 816);
                while (*v165 == *v164)
                {
                  ++v165;
                  ++v164;
                  if (!--v160) {
                    goto LABEL_425;
                  }
                }
              }
            }
            if (!sub_10010E128((uint64_t)&v245, (void **)(v157 + 72)))
            {
              unint64_t v166 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v166, OS_LOG_TYPE_DEFAULT))
              {
                std::string::size_type v167 = v157 + 72;
                if (*(char *)(v157 + 95) < 0) {
                  std::string::size_type v167 = *v159;
                }
                LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
                *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = v167;
                _os_log_impl((void *)&_mh_execute_header, v166, OS_LOG_TYPE_DEFAULT, "#I New 4FF Inserted (%s)", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 0xCu);
              }
              if (*(void *)(a1 + 808) == *(_DWORD *)(a1 + 788) && sub_100CB1074(a1))
              {
                sub_100CB1888(a1, *a2, a2[1], v157 + 72);
                goto LABEL_491;
              }
              if (*(char *)(v157 + 95) < 0)
              {
                sub_10004FC84(&v248.__r_.__value_.__s.__data_[8], *(void **)(v157 + 72), *(void *)(v157 + 80));
              }
              else
              {
                *(_OWORD *)&v248.__r_.__value_.__r.__words[1] = *(_OWORD *)v159;
                *(void *)&long long v249 = *(void *)(v157 + 88);
              }
              v168 = sub_100046F68(a1 + 312, (void **)&v248.__r_.__value_.__l.__size_);
              if (SBYTE7(v249) < 0) {
                operator delete((void *)v248.__r_.__value_.__l.__size_);
              }
              if ((void **)(a1 + 320) == v168
                || (*((char *)v168 + 127) < 0 ? (uint64_t v169 = v168[14]) : (uint64_t v169 = (void *)*((unsigned __int8 *)v168 + 127)),
                    !v169))
              {
                BOOL v235 = *(std::__shared_weak_count **)(a1 + 80);
                if (v235)
                {
                  long long v236 = std::__shared_weak_count::lock(v235);
                  if (v236)
                  {
                    v237 = v236;
                    uint64_t v238 = *(void *)(a1 + 72);
                    if (v238) {
                      (*(void (**)(uint64_t))(*(void *)v238 + 64))(v238);
                    }
                    sub_10004D2C8(v237);
                  }
                }
                goto LABEL_491;
              }
            }
          }
LABEL_425:
          v157 += 168;
          if (v157 == v158) {
            goto LABEL_491;
          }
        }
      }
      while (1)
      {
        char v76 = *(unsigned char *)(v74 + 95);
        if (v76 < 0)
        {
          if (!*(void *)(v74 + 80)) {
            goto LABEL_235;
          }
        }
        else if (!*(unsigned char *)(v74 + 95))
        {
          goto LABEL_235;
        }
        size_t v77 = (unsigned __int8 **)(v74 + 72);
        uint64_t v78 = *(unsigned __int8 *)(a1 + 839);
        if ((v78 & 0x80u) == 0) {
          uint64_t v79 = *(unsigned __int8 *)(a1 + 839);
        }
        else {
          uint64_t v79 = *(void *)(a1 + 824);
        }
        if (v76 >= 0) {
          uint64_t v80 = *(unsigned __int8 *)(v74 + 95);
        }
        else {
          uint64_t v80 = *(void *)(v74 + 80);
        }
        if (v79 == v80)
        {
          if (v76 >= 0) {
            unsigned int v81 = (unsigned __int8 *)(v74 + 72);
          }
          else {
            unsigned int v81 = *v77;
          }
          if ((v78 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)(a1 + 816), v81, *(void *)(a1 + 824))) {
              goto LABEL_235;
            }
          }
          else
          {
            if (!*(unsigned char *)(a1 + 839)) {
              goto LABEL_235;
            }
            uint64_t v82 = (unsigned __int8 *)(a1 + 816);
            while (*v82 == *v81)
            {
              ++v82;
              ++v81;
              if (!--v78) {
                goto LABEL_235;
              }
            }
          }
        }
        uint64_t v83 = *(unsigned __int8 *)(a1 + 927);
        if ((v83 & 0x80u) == 0) {
          uint64_t v84 = *(unsigned __int8 *)(a1 + 927);
        }
        else {
          uint64_t v84 = *(void *)(a1 + 912);
        }
        if (v84 == v80)
        {
          if (v76 >= 0) {
            unsigned __int8 v85 = (unsigned __int8 *)(v74 + 72);
          }
          else {
            unsigned __int8 v85 = *v77;
          }
          if ((v83 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)(a1 + 904), v85, *(void *)(a1 + 912))) {
              goto LABEL_235;
            }
          }
          else
          {
            if (!*(unsigned char *)(a1 + 927)) {
              goto LABEL_235;
            }
            char v86 = (unsigned __int8 *)(a1 + 904);
            while (*v86 == *v85)
            {
              ++v86;
              ++v85;
              if (!--v83) {
                goto LABEL_235;
              }
            }
          }
        }
        long long v260 = 0u;
        long long v261 = 0u;
        long long v258 = 0u;
        long long v259 = 0u;
        long long v256 = 0u;
        long long v257 = 0u;
        long long v254 = 0u;
        long long v255 = 0u;
        long long v252 = 0u;
        long long v253 = 0u;
        long long v250 = 0u;
        long long v251 = 0u;
        *(_OWORD *)&v248.__r_.__value_.__r.__words[1] = 0u;
        long long v249 = 0u;
        sGetProfileDetails();
        if (BYTE8(v261))
        {
          if (BYTE8(v253))
          {
            BOOL v87 = 0;
            goto LABEL_219;
          }
          if (BYTE9(v253))
          {
            int v88 = *(_DWORD *)(a1 + 788);
            BOOL v87 = v88 == 1;
            if (v88 == 1)
            {
              if (*(char *)(v74 + 95) < 0)
              {
                sub_10004FC84(&__dst, *(void **)(v74 + 72), *(void *)(v74 + 80));
              }
              else
              {
                *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)v77;
                __dst.__r_.__value_.__r.__words[2] = *(void *)(v74 + 88);
              }
              sub_1002C4208((uint64_t **)&v245, &__dst, &v248);
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__dst.__r_.__value_.__l.__data_);
              }
            }
            else
            {
              sub_100046BAC((uint64_t **)&v245, (void **)(v74 + 72), v74 + 72);
            }
            if (!BYTE8(v261))
            {
LABEL_220:
              if (v87) {
                goto LABEL_242;
              }
              goto LABEL_235;
            }
LABEL_219:
            sub_1000C584C((uint64_t)&v248.__r_.__value_.__l.__size_);
            goto LABEL_220;
          }
          sub_1000C584C((uint64_t)&v248.__r_.__value_.__l.__size_);
        }
        (***(void (****)(std::string *__return_ptr))(a1 + 56))(&__dst);
        *(_OWORD *)&v248.__r_.__value_.__r.__words[1] = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0uLL;
        char isValidSimSlot = subscriber::isValidSimSlot();
        if (v248.__r_.__value_.__r.__words[2]) {
          sub_10004D2C8((std::__shared_weak_count *)v248.__r_.__value_.__r.__words[2]);
        }
        if (__dst.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_);
        }
        if ((isValidSimSlot & 1) != 0 && (subscriber::isSimAbsent() & 1) == 0) {
          sub_100046BAC((uint64_t **)&v245, (void **)(v74 + 72), v74 + 72);
        }
LABEL_235:
        v74 += 168;
        if (v74 == v75) {
          goto LABEL_242;
        }
      }
    }
    long long v64 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v248.__r_.__value_.__r.__words[1]) = 0;
    char v7 = "#I No SIM changes, re-evaluation not required";
    uint64_t v8 = v64;
    uint32_t v9 = 2;
LABEL_5:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v248.__r_.__value_.__s.__data_[8], v9);
    return;
  }
  int v13 = 0;
  char v14 = 0;
  while (1)
  {
    if (!*(_DWORD *)(v5 + 8))
    {
      BOOL v6 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v40 = subscriber::asString();
      LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
      *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = v40;
      char v7 = "#I SIM hardware slot %s in an Unknown state - wait";
      goto LABEL_4;
    }
    uint64_t v15 = *(unsigned __int8 *)(v5 + 95);
    if ((v15 & 0x80u) != 0) {
      uint64_t v15 = *(void *)(v5 + 80);
    }
    if (!v15) {
      break;
    }
    if (!subscriber::isSimLocked()) {
      goto LABEL_46;
    }
    uint64_t v16 = *(unsigned __int8 *)(v5 + 95);
    if ((v16 & 0x80u) == 0) {
      uint64_t v17 = *(unsigned __int8 *)(v5 + 95);
    }
    else {
      uint64_t v17 = *(void *)(v5 + 80);
    }
    uint64_t v18 = *(unsigned __int8 *)(a1 + 1159);
    int v19 = (char)v18;
    if ((v18 & 0x80u) != 0) {
      uint64_t v18 = *(void *)(a1 + 1144);
    }
    if (v17 != v18) {
      goto LABEL_46;
    }
    if (v19 >= 0) {
      uint64_t v20 = (unsigned __int8 *)(a1 + 1136);
    }
    else {
      uint64_t v20 = *(unsigned __int8 **)(a1 + 1136);
    }
    if ((v16 & 0x80) == 0)
    {
      if (*(unsigned char *)(v5 + 95))
      {
        uint64_t v21 = 0;
        while (*(unsigned __int8 *)(v5 + v21 + 72) == v20[v21])
        {
          if (v16 == ++v21) {
            goto LABEL_37;
          }
        }
        goto LABEL_46;
      }
LABEL_37:
      char v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = subscriber::asString();
        LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
        *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Clear monitor mode parameter for locked SIM on slot %s", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 0xCu);
      }
      if (*(unsigned char *)(a1 + 1128))
      {
        if (*(char *)(a1 + 1111) < 0) {
          operator delete(*(void **)(a1 + 1088));
        }
        *(unsigned char *)(a1 + 1128) = 0;
      }
      if (*(char *)(a1 + 1159) < 0)
      {
        **(unsigned char **)(a1 + 1136) = 0;
        *(void *)(a1 + 1144) = 0;
      }
      else
      {
        *(unsigned char *)(a1 + 1136) = 0;
        *(unsigned char *)(a1 + 1159) = 0;
      }
      goto LABEL_46;
    }
    if (!memcmp(*(const void **)(v5 + 72), v20, *(void *)(v5 + 80))) {
      goto LABEL_37;
    }
LABEL_46:
    if (*(_DWORD *)(a1 + 788) >= 2u)
    {
      int isSimReady = subscriber::isSimReady();
      if (*(_DWORD *)(v5 + 12) == 1) {
        int v26 = isSimReady;
      }
      else {
        int v26 = 0;
      }
      if (v26 == 1)
      {
        BOOL v6 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        uint64_t v65 = subscriber::asString();
        LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
        *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = v65;
        char v7 = "#I SIM %s 'ready', but tray indicates 'absent' - wait";
        goto LABEL_4;
      }
      if ((subscriber::isEsimCapable() & 1) == 0)
      {
        char isSimInserted = subscriber::isSimInserted();
        int v28 = *(_DWORD *)(v5 + 12);
        if (v28 == 2) {
          char v29 = isSimInserted;
        }
        else {
          char v29 = 1;
        }
        if ((v29 & 1) == 0)
        {
          BOOL v6 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          uint64_t v73 = subscriber::asString();
          LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
          *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = v73;
          char v7 = "#I Physical SIM %s 'absent', but tray indicates 'inserted' - wait";
          goto LABEL_4;
        }
        if (!v13)
        {
          BOOL v30 = v28 == 1;
          goto LABEL_78;
        }
        if (*(void *)(a1 + 808) <= 1uLL)
        {
          if (*(char *)(a1 + 839) < 0)
          {
            if (!*(void *)(a1 + 824)) {
              goto LABEL_75;
            }
          }
          else if (!*(unsigned char *)(a1 + 839))
          {
            goto LABEL_75;
          }
        }
        if (!v14 || v28 == 1)
        {
          if (!v14 && v28 == 1)
          {
            char v33 = *(NSObject **)(a1 + 40);
            BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
            if (v34)
            {
              LOWORD(v248.__r_.__value_.__r.__words[1]) = 0;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Detected dual physical with mismatching SIM tray state - wait", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 2u);
            }
            if (capabilities::ct::supportsDualPhysicalSIM((capabilities::ct *)v34)) {
              return;
            }
            char v14 = 0;
            goto LABEL_81;
          }
LABEL_75:
          if (v14) {
            BOOL v30 = v28 == 1;
          }
          else {
            BOOL v30 = 0;
          }
LABEL_78:
          char v14 = v30;
LABEL_81:
          int v13 = 1;
          goto LABEL_82;
        }
        int v31 = *(NSObject **)(a1 + 40);
        BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
        if (v32)
        {
          LOWORD(v248.__r_.__value_.__r.__words[1]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Detected dual physical with mismatching SIM tray state - wait", (uint8_t *)&v248.__r_.__value_.__s.__data_[8], 2u);
        }
        if (capabilities::ct::supportsDualPhysicalSIM((capabilities::ct *)v32)) {
          return;
        }
        int v13 = 1;
        char v14 = 1;
      }
    }
LABEL_82:
    v5 += 168;
    if (v5 == v4) {
      goto LABEL_85;
    }
  }
  if (subscriber::isSimPresentAndValid())
  {
    BOOL v6 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v72 = subscriber::asString();
    LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
    *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = v72;
    char v7 = "#I Detected SIM hardware slot %s with no ICCID - wait";
    goto LABEL_4;
  }
  if (*(_DWORD *)(v5 + 12) != 2) {
    goto LABEL_46;
  }
  uint64_t isEsimCapable = subscriber::isEsimCapable();
  if (isEsimCapable & 1) != 0 || (capabilities::ct::supportsVinylTestMode((capabilities::ct *)isEsimCapable)) {
    goto LABEL_46;
  }
  BOOL v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v109 = subscriber::asString();
    LODWORD(v248.__r_.__value_.__r.__words[1]) = 136315138;
    *(std::string::size_type *)((char *)&v248.__r_.__value_.__r.__words[1] + 4) = v109;
    char v7 = "#I 4FF SIM inserted on slot %s and ICCID is still unknown - wait";
    goto LABEL_4;
  }
}

void sub_100CAD678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21)
{
  sub_10004D2C8(v21);
  sub_10005CD2C((uint64_t)&a20, (char *)a21);
  _Unwind_Resume(a1);
}

uint64_t sub_100CAD850(uint64_t a1, unsigned __int8 **a2)
{
  return sub_100CBFD40(a2, *(void *)(a1 + 160), *(void *)(a1 + 168));
}

void sub_100CAD864(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 1128)) {
    return;
  }
  if (*(void *)(a1 + 88))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = (void *)(a1 + 1136);
      if (*(char *)(a1 + 1159) < 0) {
        uint64_t v3 = (void *)*v3;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Monitor mode is ongoing for (%s)", buf, 0xCu);
    }
    return;
  }
  uint64_t v4 = (void **)(a1 + 1088);
  uint64_t v5 = (_OWORD *)(a1 + 1136);
  std::string::operator=((std::string *)(a1 + 1136), (const std::string *)(a1 + 1088));
  uint64_t v7 = *(void *)(a1 + 160);
  uint64_t v6 = *(void *)(a1 + 168);
  if (*(char *)(a1 + 1159) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 1136), *(void *)(a1 + 1144));
  }
  else
  {
    *(_OWORD *)std::string __p = *v5;
    uint64_t v65 = *(void *)(a1 + 1152);
  }
  char v8 = HIBYTE(v65);
  if (v7 != v6)
  {
    if (v65 >= 0) {
      uint32_t v9 = (void *)HIBYTE(v65);
    }
    else {
      uint32_t v9 = __p[1];
    }
    if (v65 >= 0) {
      long long v10 = __p;
    }
    else {
      long long v10 = (void **)__p[0];
    }
    do
    {
      uint64_t v11 = *(unsigned __int8 *)(v7 + 95);
      if ((v11 & 0x80u) == 0) {
        int v12 = (void *)*(unsigned __int8 *)(v7 + 95);
      }
      else {
        int v12 = *(void **)(v7 + 80);
      }
      if (v12 == v9)
      {
        if ((v11 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v7 + 72), v10, *(void *)(v7 + 80))) {
            goto LABEL_30;
          }
        }
        else
        {
          if (!*(unsigned char *)(v7 + 95)) {
            goto LABEL_30;
          }
          uint64_t v13 = 0;
          while (*(unsigned __int8 *)(v7 + v13 + 72) == *((unsigned __int8 *)v10 + v13))
          {
            if (v11 == ++v13) {
              goto LABEL_30;
            }
          }
        }
      }
      v7 += 168;
    }
    while (v7 != v6);
    uint64_t v7 = v6;
  }
LABEL_30:
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  if (v7 == *(void *)(a1 + 168))
  {
    sGetProfileDetails();
    if (v73)
    {
      char v15 = sub_100CBDA1C(a1, 0);
      if (v73) {
        sub_1000C584C((uint64_t)buf);
      }
      if ((v15 & 1) == 0)
      {
        uint64_t v16 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a1 + 1159) < 0) {
            uint64_t v5 = *(_OWORD **)v5;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v5;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Need to enable ICCID (%s) to resume monitor mode!", buf, 0xCu);
        }
        long long v77 = *(_OWORD *)(a1 + 1072);
        if (*(char *)(a1 + 1111) < 0)
        {
          sub_10004FC84(&v78, *(void **)(a1 + 1088), *(void *)(a1 + 1096));
        }
        else
        {
          long long v78 = *(_OWORD *)v4;
          uint64_t v79 = *(void *)(a1 + 1104);
        }
        char v80 = *(unsigned char *)(a1 + 1112);
        sub_100CC0C98(a1, v17, v18, &v77);
      }
    }
  }
  else
  {
    if (!subscriber::isSimReady()) {
      return;
    }
    if ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56))) {
      int v14 = 1;
    }
    else {
      int v14 = *(_DWORD *)v7;
    }
    *(_DWORD *)(a1 + 1048) = v14;
    if (*(void *)(a1 + 88)) {
      goto LABEL_62;
    }
    uint64_t v19 = *(void *)(a1 + 56);
    uint64_t v20 = *(unsigned __int8 *)(a1 + 1120);
    uint64_t v21 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v21;
    if (v21) {
      dispatch_retain(v21);
    }
    uint64_t v22 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v22 || (uint64_t v23 = *(void *)(a1 + 8), (v24 = std::__shared_weak_count::lock(v22)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v25 = v23 + 48;
    if (!v23) {
      uint64_t v25 = 0;
    }
    uint64_t v61 = v25;
    uint64_t v62 = v24;
    int v26 = *(unsigned __int8 *)(a1 + 1121);
    char v52 = subscriber::isEsimCapable() ^ 1;
    (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t, dispatch_object_t *, uint64_t *, uint64_t, uint64_t, uint64_t, BOOL, char))(*(void *)v19 + 504))(buf, v19, v20, &object, &v61, a1 + 1048, a1 + 1052, a1 + 1072, v26 != 0, v52);
    long long v27 = *(_OWORD *)buf;
    *(void *)std::string buf = 0;
    *(void *)&buf[8] = 0;
    int v28 = *(std::__shared_weak_count **)(a1 + 96);
    *(_OWORD *)(a1 + 88) = v27;
    if (v28)
    {
      sub_10004D2C8(v28);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
    if (v62) {
      sub_10004D2C8(v62);
    }
    if (object) {
      dispatch_release(object);
    }
    if (*(void *)(a1 + 88))
    {
LABEL_62:
      (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 120) + 280))(*(void *)(a1 + 120), a1 + 1088, *(unsigned __int8 *)(a1 + 1121));
      char v29 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = subscriber::asString();
        BOOL v32 = (void *)(a1 + 1088);
        if (*(char *)(a1 + 1111) < 0) {
          BOOL v32 = *v4;
        }
        uint64_t v33 = printers::asString((printers *)(a1 + 1121), v30);
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = v31;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v32;
        __int16 v71 = 2080;
        uint64_t v72 = v33;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Created attach provisioning monitor mode on slot [%s] for iccid: [%s] entitlement: [%s]", buf, 0x20u);
      }
      if (*(char *)(a1 + 1111) < 0)
      {
        sub_10004FC84(__dst, *(void **)(a1 + 1088), *(void *)(a1 + 1096));
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)v4;
        uint64_t v60 = *(void *)(a1 + 1104);
      }
      sub_100CB60FC(a1, (uint64_t)__dst, (uint64_t)v76);
      if (SHIBYTE(v60) < 0) {
        operator delete(__dst[0]);
      }
      (*(void (**)(void **__return_ptr))(**(void **)(a1 + 56) + 968))(&v57);
      uint64_t v34 = *(void *)(a1 + 88);
      int v55 = 0;
      uint64_t v56 = 0;
      uint64_t v54 = 0;
      sub_10015C7D4(&v54, v57, (uint64_t)v58, (v58 - (unsigned char *)v57) >> 3);
      (*(void (**)(uint64_t, void **))(*(void *)v34 + 16))(v34, &v54);
      if (v54)
      {
        int v55 = v54;
        operator delete(v54);
      }
      (*(void (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 48))(*(void *)(a1 + 88), a1 + 136);
      if (*(unsigned char *)(a1 + 1128))
      {
        if (*(char *)(a1 + 1111) < 0) {
          operator delete(*v4);
        }
        *(unsigned char *)(a1 + 1128) = 0;
      }
      (***(void (****)(unsigned char *__return_ptr))(a1 + 56))(buf);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v35, *(Registry **)buf);
      uint64_t v37 = ServiceMap;
      if (v38 < 0)
      {
        uint64_t v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v40 = 5381;
        do
        {
          uint64_t v38 = v40;
          unsigned int v41 = *v39++;
          uint64_t v40 = (33 * v40) ^ v41;
        }
        while (v41);
      }
      std::mutex::lock(ServiceMap);
      v67[0] = (void *)v38;
      uint64_t v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)v67);
      if (v42)
      {
        uint64_t v44 = v42[3];
        uint64_t v43 = (std::__shared_weak_count *)v42[4];
        if (v43)
        {
          atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v37);
          atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v43);
          char v45 = 0;
LABEL_85:
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          if (v44) {
            (*(void (**)(uint64_t, uint64_t, void))(*(void *)v44 + 24))(v44, 257, 0);
          }
          uint64_t v46 = *(std::__shared_weak_count **)(a1 + 80);
          if (v46)
          {
            uint64_t v47 = std::__shared_weak_count::lock(v46);
            if (v47)
            {
              uint64_t v48 = v47;
              uint64_t v49 = *(void *)(a1 + 72);
              if (v49)
              {
                (*(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)v49 + 144))(v49, v5, 1);
                bzero(buf, 0x4E8uLL);
                (*(void (**)(unsigned char *__return_ptr, uint64_t, _OWORD *))(*(void *)v49 + 104))(buf, v49, v5);
                if (v75)
                {
                  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
                  sub_100058DB0(v67, "MonitorModeStartTime");
                  v69[1] = *(uint64_t (**)(void, void, void, void, void))&Current;
                  v69[0] = (uint64_t (*)(void, void, void, void, void))sub_100B71B34;
                  sub_100B4F35C(v53, (uint64_t)v67, 1uLL);
                  (*(void (**)(uint64_t, uint64_t *, void **))(*(void *)v49 + 112))(v49, &v74, v53);
                  uint64_t v66 = v53;
                  sub_100333C9C(&v66);
                  sub_100146540(v69);
                  if (v68 < 0) {
                    operator delete(v67[0]);
                  }
                  if (v75) {
                    sub_10030D10C((uint64_t)buf);
                  }
                }
              }
              sub_10004D2C8(v48);
            }
          }
          if ((v45 & 1) == 0) {
            sub_10004D2C8(v43);
          }
          if (v57)
          {
            uint64_t v58 = v57;
            operator delete(v57);
          }
          sub_1000C584C((uint64_t)v76);
          return;
        }
      }
      else
      {
        uint64_t v44 = 0;
      }
      std::mutex::unlock(v37);
      uint64_t v43 = 0;
      char v45 = 1;
      goto LABEL_85;
    }
    uint64_t v51 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "Error in Monitormode creation", buf, 2u);
    }
  }
}

void sub_100CAE140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,dispatch_object_t object,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  sub_100333C9C((void ***)&a29);
  sub_100B4F3FC((uint64_t)&a30);
  if (LOBYTE(STACK[0x5C0])) {
    sub_10030D10C((uint64_t)&a37);
  }
  sub_10004D2C8(v38);
  if ((v39 & 1) == 0) {
    sub_10004D2C8(v37);
  }
  if (__p) {
    operator delete(__p);
  }
  sub_1000C584C((uint64_t)&STACK[0x5C8]);
  _Unwind_Resume(a1);
}

uint64_t sub_100CAE280(void *a1, unsigned __int8 **a2)
{
  if ((unsigned __int8 *)a1[2] != a2[2]) {
    return 0;
  }
  uint64_t v2 = (unsigned __int8 *)(a1 + 1);
  uint64_t v3 = (unsigned __int8 *)*a1;
  if ((void *)*a1 == a1 + 1) {
    return 1;
  }
  uint64_t v4 = *a2;
  do
  {
    uint64_t result = sub_1000609C0((uint64_t)&v11, v3 + 32, v4 + 32);
    if (!result) {
      break;
    }
    uint64_t v6 = (unsigned __int8 *)*((void *)v3 + 1);
    uint64_t v7 = v3;
    if (v6)
    {
      do
      {
        uint64_t v3 = v6;
        uint64_t v6 = *(unsigned __int8 **)v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        uint64_t v3 = (unsigned __int8 *)*((void *)v7 + 2);
        BOOL v8 = *(void *)v3 == (void)v7;
        uint64_t v7 = v3;
      }
      while (!v8);
    }
    uint32_t v9 = (unsigned __int8 *)*((void *)v4 + 1);
    if (v9)
    {
      do
      {
        long long v10 = v9;
        uint32_t v9 = *(unsigned __int8 **)v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        long long v10 = (unsigned __int8 *)*((void *)v4 + 2);
        BOOL v8 = *(void *)v10 == (void)v4;
        uint64_t v4 = v10;
      }
      while (!v8);
    }
    uint64_t v4 = v10;
  }
  while (v3 != v2);
  return result;
}

uint64_t sub_100CAE35C(uint64_t a1, std::string **a2)
{
  __int16 v8 = 0;
  sub_100CA7400(v6, a1, (unsigned char *)&v8 + 1, &v8, a2);
  if (HIBYTE(v8)) {
    BOOL v3 = v8 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3 && v7 != 0) {
    sub_100CA80B8(a1, (uint64_t)v6);
  }
  return sub_1008618BC((uint64_t)v6);
}

void sub_100CAE3D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1008618BC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100CAE3E4(uint64_t a1, void **a2)
{
  uint64_t v3 = a1 + 792;
  uint64_t result = sub_10010E128(a1 + 792, a2);
  if (result)
  {
    uint64_t v6 = 0;
    uint64_t v5 = *sub_100046ED4(v3, &v6, a2);
    if (!v5) {
      sub_1000C14F0("map::at:  key not found");
    }
    return *(unsigned __int8 *)(v5 + 56) != 0;
  }
  return result;
}

void sub_100CAE450(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 88);
  if (v4) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 48))(v4, a2);
  }
  char v29 = a2;
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v7 = *(void *)(a1 + 136);
  uint64_t v28 = a1 + 136;
  uint64_t v8 = *(void *)(a1 + 144);
  if (v5 - v6 != v8 - v7) {
    goto LABEL_38;
  }
  if (v6 != v5 && v7 != v8)
  {
    do
    {
      if (!sub_100CC2280(v6, v7)) {
        break;
      }
      v6 += 88;
      v7 += 88;
      if (v6 == v5) {
        break;
      }
    }
    while (v7 != v8);
  }
  if (v6 != v5 && v7 != v8)
  {
    if (v5 - v6 == v8 - v7)
    {
      uint64_t v10 = 0;
      uint64_t v11 = v6;
      while (1)
      {
        uint64_t v12 = v6;
        if (v11 != v6)
        {
          uint64_t v13 = v10;
          uint64_t v12 = v6;
          while ((sub_100CC2280(v12, v11) & 1) == 0)
          {
            v12 += 88;
            v13 -= 88;
            if (!v13) {
              goto LABEL_19;
            }
          }
        }
        if (v12 == v11)
        {
LABEL_19:
          uint64_t v14 = 0;
          uint64_t v15 = v7;
          do
          {
            v14 += sub_100CC2280(v11, v15);
            v15 += 88;
          }
          while (v15 != v8);
          if (!v14) {
            break;
          }
          uint64_t v16 = v11 + 88;
          uint64_t v17 = 1;
          while (v16 != v5)
          {
            v17 += sub_100CC2280(v11, v16);
            v16 += 88;
          }
          if (v17 != v14) {
            break;
          }
        }
        v11 += 88;
        v10 += 88;
        if (v11 == v5) {
          goto LABEL_34;
        }
      }
    }
LABEL_38:
    uint64_t v20 = *v29;
    uint64_t v30 = v29[1];
    if (*v29 != v30)
    {
      uint64_t v21 = (void **)(a1 + 272);
      do
      {
        uint64_t v31 = v20;
        if (*(unsigned char *)(v20 + 80))
        {
          uint64_t v23 = *(void *)(v20 + 56);
          uint64_t v22 = *(void *)(v20 + 64);
          while (v23 != v22)
          {
            if (!*(unsigned char *)(v23 + 88))
            {
              uint64_t v24 = sub_100046F68(a1 + 264, (void **)(v23 + 16));
              uint64_t v25 = v24;
              if (v21 == v24 || !*((unsigned char *)v24 + 592))
              {
                if ((*(unsigned int (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 56) + 184))(*(void *)(a1 + 56), v23 + 96, v23 + 120, v23 + 144, v23 + 168, v23 + 16))
                {
                  long long v43 = 0u;
                  long long v44 = 0u;
                  memset(v42, 0, sizeof(v42));
                  long long v41 = 0u;
                  *(_OWORD *)char v39 = 0u;
                  long long v40 = 0u;
                  long long v37 = 0u;
                  *(_OWORD *)uint64_t v38 = 0u;
                  long long v35 = 0u;
                  *(_OWORD *)uint64_t v36 = 0u;
                  *(_OWORD *)std::string buf = 0u;
                  BYTE9(v44) = 1;
                  std::string::operator=((std::string *)v36, (const std::string *)(v23 + 16));
                  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 56) + 200))(&v32);
                  if (SHIBYTE(v42[3]) < 0) {
                    operator delete((void *)v42[1]);
                  }
                  *(_OWORD *)&v42[1] = v32;
                  v42[3] = v33;
                  *(void *)&long long v32 = v36;
                  int v26 = sub_100CC3268((uint64_t **)(a1 + 264), v36, (long long **)&v32);
                  sub_100CAE99C((uint64_t)(v26 + 400), (uint64_t)buf);
                  if (SBYTE7(v44) < 0) {
                    operator delete((void *)v43);
                  }
                  if (SHIBYTE(v42[3]) < 0) {
                    operator delete((void *)v42[1]);
                  }
                  if (SHIBYTE(v42[0]) < 0) {
                    operator delete((void *)v41);
                  }
                  if (SHIBYTE(v40) < 0) {
                    operator delete(v39[1]);
                  }
                  if (SHIBYTE(v39[0]) < 0) {
                    operator delete(v38[0]);
                  }
                  if (SBYTE7(v37) < 0) {
                    operator delete(v36[0]);
                  }
                  if (SHIBYTE(v35) < 0) {
                    operator delete(*(void **)&buf[8]);
                  }
                }
                uint64_t v21 = (void **)(a1 + 272);
                if ((void **)(a1 + 272) == v25) {
                  goto LABEL_65;
                }
              }
              if (!*((unsigned char *)v25 + 189))
              {
LABEL_65:
                __int16 v27 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 56) + 208))(*(void *)(a1 + 56), v23 + 96, v23 + 120, v23 + 144, v23 + 168, v23 + 16);
                *(void *)std::string buf = v23 + 16;
                *((_WORD *)sub_100CC3268((uint64_t **)(a1 + 264), (void **)(v23 + 16), (long long **)buf) + 94) = v27 | 0x100;
              }
            }
            v23 += 216;
          }
        }
        uint64_t v20 = v31 + 88;
      }
      while (v31 + 88 != v30);
    }
    if ((uint64_t *)v28 != v29) {
      sub_1003DB294(v28, *v29, v29[1], 0x2E8BA2E8BA2E8BA3 * ((v29[1] - *v29) >> 3));
    }
    sub_100CAEA50(a1);
    if (*(void *)(a1 + 168) != *(void *)(a1 + 160))
    {
      sub_100CAB664(a1, (uint64_t *)(a1 + 160), 1);
      return;
    }
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v19 = "#I No SIM info present - wait";
      goto LABEL_74;
    }
    return;
  }
  if (v6 != v5 || v7 != v8) {
    goto LABEL_38;
  }
LABEL_34:
  if ((uint64_t *)v28 != v29) {
    sub_1003DB294(v28, *v29, v29[1], 0x2E8BA2E8BA2E8BA3 * ((v29[1] - *v29) >> 3));
  }
  uint64_t v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    uint64_t v19 = "#I No change in profiles - skip";
LABEL_74:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 2u);
  }
}

void sub_100CAE984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_1000C62D8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100CAE99C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 192))
  {
    *(void *)a1 = *(void *)a2;
    std::string::operator=((std::string *)(a1 + 8), (const std::string *)(a2 + 8));
    std::string::operator=((std::string *)(a1 + 32), (const std::string *)(a2 + 32));
    *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
    std::string::operator=((std::string *)(a1 + 64), (const std::string *)(a2 + 64));
    std::string::operator=((std::string *)(a1 + 88), (const std::string *)(a2 + 88));
    std::string::operator=((std::string *)(a1 + 112), (const std::string *)(a2 + 112));
    std::string::operator=((std::string *)(a1 + 136), (const std::string *)(a2 + 136));
    std::string::operator=((std::string *)(a1 + 160), (const std::string *)(a2 + 160));
    *(_WORD *)(a1 + 184) = *(_WORD *)(a2 + 184);
  }
  else
  {
    sub_10023FB90(a1, a2);
    *(unsigned char *)(a1 + 192) = 1;
  }
  return a1;
}

void sub_100CAEA50(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 336) >= 2u
    && ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56)) & 1) == 0)
  {
    uint64_t v2 = *(void *)(a1 + 136);
    uint64_t v3 = *(void *)(a1 + 144);
    while (v2 != v3)
    {
      if (*(_DWORD *)(v2 + 12) == 3 && *(unsigned char *)(v2 + 80))
      {
        uint64_t v4 = *(void *)(v2 + 56);
        uint64_t v5 = *(void *)(v2 + 64);
        while (v4 != v5)
        {
          if (!*(unsigned char *)(v4 + 88)) {
            sub_100CBCF58(a1, (long long *)(v4 + 16), *(unsigned int *)(v2 + 4));
          }
          v4 += 216;
        }
      }
      v2 += 88;
    }
  }
}

void sub_100CAEB0C(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 336) = a2;
  sub_100CAEA50(a1);

  sub_100CA5528(a1);
}

void sub_100CAEB48(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 340) != a2)
  {
    *(unsigned char *)(a1 + 340) = a2;
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v6 = *(void *)(a1 + 72);
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
        }
        sub_10004D2C8(v5);
      }
    }
  }
}

void sub_100CAEBD8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100CAEBEC(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = (uint64_t **)(result + 43);
  if (result + 43 != a2)
  {
    uint64_t v3 = a2 + 1;
    uint64_t v4 = (void *)*a2;
    if (result[45])
    {
      uint64_t v5 = (void *)result[43];
      uint64_t v6 = result[44];
      result[43] = (uint64_t)(result + 44);
      *(void *)(v6 + 16) = 0;
      result[44] = 0;
      result[45] = 0;
      if (v5[1]) {
        uint64_t v7 = (void *)v5[1];
      }
      else {
        uint64_t v7 = v5;
      }
      uint64_t v17 = result + 43;
      uint64_t v18 = v7;
      uint64_t v19 = v7;
      if (!v7 || (uint64_t v18 = sub_1000EA590((uint64_t)v7), v4 == v3))
      {
        uint64_t v11 = v4;
      }
      else
      {
        do
        {
          std::string::operator=((std::string *)(v7 + 4), (const std::string *)(v4 + 4));
          v7[7] = v4[7];
          uint64_t v8 = v19;
          uint64_t v16 = 0;
          uint32_t v9 = (uint64_t **)sub_1000EA518((uint64_t)v2, &v16, v19 + 4);
          sub_100046C38(v2, v16, v9, v8);
          uint64_t v7 = v18;
          uint64_t v19 = v18;
          if (v18) {
            uint64_t v18 = sub_1000EA590((uint64_t)v18);
          }
          uint64_t v10 = (void *)v4[1];
          if (v10)
          {
            do
            {
              uint64_t v11 = v10;
              uint64_t v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              uint64_t v11 = (void *)v4[2];
              BOOL v12 = *v11 == (void)v4;
              uint64_t v4 = v11;
            }
            while (!v12);
          }
          if (!v7) {
            break;
          }
          uint64_t v4 = v11;
        }
        while (v11 != v3);
      }
      uint64_t result = (uint64_t *)sub_1000EA5E4((uint64_t)&v17);
      uint64_t v4 = v11;
    }
    if (v4 != v3)
    {
      do
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        sub_100406634((uint64_t)v2, (uint64_t)(v4 + 4), &v17);
        uint64_t v16 = 0;
        uint64_t v13 = (uint64_t **)sub_1000EA518((uint64_t)v2, &v16, v17 + 4);
        uint64_t result = sub_100046C38(v2, v16, v13, v17);
        uint64_t v14 = (void *)v4[1];
        if (v14)
        {
          do
          {
            uint64_t v15 = v14;
            uint64_t v14 = (void *)*v14;
          }
          while (v14);
        }
        else
        {
          do
          {
            uint64_t v15 = (void *)v4[2];
            BOOL v12 = *v15 == (void)v4;
            uint64_t v4 = v15;
          }
          while (!v12);
        }
        uint64_t v4 = v15;
      }
      while (v15 != v3);
    }
  }
  return result;
}

void sub_100CAEDA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000EA5E4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100CAEDB8(void *a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t **)(a1 + 23);
  if (a1 + 23 != a2)
  {
    uint64_t v5 = a2 + 1;
    uint64_t v6 = (uint64_t *)*a2;
    if (a1[25])
    {
      uint64_t v8 = (uint64_t **)(a1 + 24);
      uint64_t v7 = a1[24];
      uint32_t v9 = (char *)a1[23];
      a1[23] = a1 + 24;
      *(void *)(v7 + 16) = 0;
      a1[24] = 0;
      a1[25] = 0;
      if (*((void *)v9 + 1)) {
        uint64_t v10 = (char *)*((void *)v9 + 1);
      }
      else {
        uint64_t v10 = v9;
      }
      v45[0] = a1 + 23;
      v45[1] = v10;
      *(void *)&long long v46 = v10;
      if (!v10 || (v45[1] = sub_1000EA590((uint64_t)v10), v6 == v5))
      {
        uint64_t v15 = v6;
      }
      else
      {
        do
        {
          *((_DWORD *)v10 + 8) = *((_DWORD *)v6 + 8);
          std::string::operator=((std::string *)(v10 + 40), (const std::string *)(v6 + 5));
          std::string::operator=((std::string *)(v10 + 64), (const std::string *)(v6 + 8));
          *((_DWORD *)v10 + 22) = *((_DWORD *)v6 + 22);
          std::string::operator=((std::string *)v10 + 4, (const std::string *)v6 + 4);
          v10[120] = *((unsigned char *)v6 + 120);
          uint64_t v11 = *v8;
          BOOL v12 = (uint64_t **)(a1 + 24);
          uint64_t v13 = (uint64_t **)(a1 + 24);
          if (*v8)
          {
            do
            {
              while (1)
              {
                BOOL v12 = (uint64_t **)v11;
                if (*(_DWORD *)(v46 + 32) >= *((_DWORD *)v11 + 8)) {
                  break;
                }
                uint64_t v11 = (uint64_t *)*v11;
                uint64_t v13 = v12;
                if (!*v12) {
                  goto LABEL_14;
                }
              }
              uint64_t v11 = (uint64_t *)v11[1];
            }
            while (v11);
            uint64_t v13 = v12 + 1;
          }
LABEL_14:
          sub_100046C38(v4, (uint64_t)v12, v13, (uint64_t *)v46);
          uint64_t v10 = (char *)v45[1];
          *(void **)&long long v46 = v45[1];
          if (v45[1]) {
            v45[1] = sub_1000EA590((uint64_t)v45[1]);
          }
          uint64_t v14 = (uint64_t *)v6[1];
          if (v14)
          {
            do
            {
              uint64_t v15 = v14;
              uint64_t v14 = (uint64_t *)*v14;
            }
            while (v14);
          }
          else
          {
            do
            {
              uint64_t v15 = (uint64_t *)v6[2];
              BOOL v16 = *v15 == (void)v6;
              uint64_t v6 = v15;
            }
            while (!v16);
          }
          if (!v10) {
            break;
          }
          uint64_t v6 = v15;
        }
        while (v15 != v5);
      }
      sub_100CC46B4((uint64_t)v45);
      uint64_t v6 = v15;
    }
    if (v6 != v5)
    {
      uint64_t v17 = (uint64_t **)(a1 + 24);
      do
      {
        v45[0] = 0;
        v45[1] = 0;
        *(void *)&long long v46 = 0;
        sub_1009F828C((uint64_t)v4, (uint64_t)(v6 + 4), v45);
        uint64_t v18 = *v17;
        uint64_t v19 = (uint64_t **)(a1 + 24);
        uint64_t v20 = (uint64_t **)(a1 + 24);
        if (*v17)
        {
          do
          {
            while (1)
            {
              uint64_t v19 = (uint64_t **)v18;
              if (*((_DWORD *)v45[0] + 8) >= *((_DWORD *)v18 + 8)) {
                break;
              }
              uint64_t v18 = (uint64_t *)*v18;
              uint64_t v20 = v19;
              if (!*v19) {
                goto LABEL_34;
              }
            }
            uint64_t v18 = (uint64_t *)v18[1];
          }
          while (v18);
          uint64_t v20 = v19 + 1;
        }
LABEL_34:
        sub_100046C38(v4, (uint64_t)v19, v20, (uint64_t *)v45[0]);
        v45[0] = 0;
        sub_10008B8F0((uint64_t)v45, 0);
        uint64_t v21 = (uint64_t *)v6[1];
        if (v21)
        {
          do
          {
            uint64_t v22 = v21;
            uint64_t v21 = (uint64_t *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            uint64_t v22 = (uint64_t *)v6[2];
            BOOL v16 = *v22 == (void)v6;
            uint64_t v6 = v22;
          }
          while (!v16);
        }
        uint64_t v6 = v22;
      }
      while (v22 != v5);
    }
  }
  sub_100CA5980((uint64_t)a1);
  uint64_t v23 = (std::__shared_weak_count *)a1[10];
  if (v23)
  {
    uint64_t v24 = std::__shared_weak_count::lock(v23);
    if (v24)
    {
      uint64_t v25 = v24;
      uint64_t v26 = a1[9];
      if (!v26)
      {
LABEL_45:
        sub_10004D2C8(v25);
        return;
      }
      if (a1[11])
      {
LABEL_44:
        (*(void (**)(uint64_t))(*(void *)v26 + 64))(v26);
        goto LABEL_45;
      }
      if (*((char *)a1 + 1159) < 0)
      {
        if (a1[143]) {
          goto LABEL_44;
        }
      }
      else if (*((unsigned char *)a1 + 1159))
      {
        goto LABEL_44;
      }
      if (!a2[2]) {
        goto LABEL_44;
      }
      int v27 = *(_DWORD *)(*a2 + 32);
      *(_OWORD *)char v45 = 0u;
      long long v46 = 0u;
      sub_100CAF5D8(a1, v27, (uint64_t)v45);
      if (!BYTE8(v46)) {
        goto LABEL_44;
      }
      __p[0] = 0;
      __p[1] = 0;
      *(void *)&long long v44 = 0;
      sub_100CA6EAC(__p, a1, v45, v27);
      char v28 = BYTE7(v44);
      if ((SBYTE7(v44) & 0x80u) == 0) {
        char v29 = (void *)BYTE7(v44);
      }
      else {
        char v29 = __p[1];
      }
      if (!v29)
      {
        uint64_t v30 = a1[5];
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Cannot find a matching phone number to disable and early return", buf, 2u);
          char v28 = BYTE7(v44);
        }
      }
      if (v28 < 0) {
        operator delete(__p[0]);
      }
      if (BYTE8(v46) && SBYTE7(v46) < 0) {
        operator delete(v45[0]);
      }
      if (!v29) {
        goto LABEL_44;
      }
      unint64_t v31 = sub_100CAF3EC(a1, a2[2]);
      int v32 = v31;
      if (!HIDWORD(v31)) {
        goto LABEL_45;
      }
      *(_OWORD *)char v45 = 0u;
      long long v46 = 0u;
      sub_100CAF5D8(a1, v31, (uint64_t)v45);
      if (!BYTE8(v46)) {
        goto LABEL_45;
      }
      *(_OWORD *)std::string __p = 0u;
      long long v44 = 0u;
      if (v32 == 1) {
        int v33 = 2;
      }
      else {
        int v33 = 1;
      }
      sub_100CAF5D8(a1, v33, (uint64_t)__p);
      if ((sub_100CA6CF8((uint64_t)a1, (unsigned __int8 **)v45) & 1) != 0
        || sub_100CA6CF8((uint64_t)a1, (unsigned __int8 **)__p))
      {
        uint64_t v34 = a1[5];
        if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_85;
        }
        *(_WORD *)std::string buf = 0;
        long long v35 = "#I Do not disable offload SIM";
        uint64_t v36 = v34;
        uint32_t v37 = 2;
      }
      else
      {
        int v38 = sub_100CAE3E4((uint64_t)a1, v45);
        char v39 = a1[5];
        BOOL v40 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
        if (!v38)
        {
          if (v40)
          {
            uint64_t v42 = v45;
            if (SBYTE7(v46) < 0) {
              uint64_t v42 = (void **)v45[0];
            }
            *(_DWORD *)std::string buf = 136315138;
            uint64_t v48 = v42;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Disable SIM with iccid [%s].", buf, 0xCu);
          }
          sub_100CAF704((uint64_t)a1, 0, (uint64_t)v45, 0);
          sub_100CB0388((uint64_t)a1, (uint64_t)v45, (uint64_t)__p, 0);
          goto LABEL_85;
        }
        if (!v40)
        {
LABEL_85:
          if (BYTE8(v44) && SBYTE7(v44) < 0) {
            operator delete(__p[0]);
          }
          if (BYTE8(v46))
          {
            if (SBYTE7(v46) < 0) {
              operator delete(v45[0]);
            }
          }
          goto LABEL_45;
        }
        long long v41 = v45;
        if (SBYTE7(v46) < 0) {
          long long v41 = (void **)v45[0];
        }
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v48 = v41;
        long long v35 = "#I Iccid [%s] is explicitly enabled by user and do not disable it";
        uint64_t v36 = v39;
        uint32_t v37 = 12;
      }
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v35, buf, v37);
      goto LABEL_85;
    }
  }
}

void sub_100CAF344(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 && a14 < 0) {
    operator delete(__p);
  }
  if (a22)
  {
    if (a21 < 0) {
      operator delete(a16);
    }
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

BOOL sub_100CAF3BC(uint64_t a1)
{
  if (*(void *)(a1 + 88)) {
    return 1;
  }
  if (*(char *)(a1 + 1159) < 0) {
    uint64_t v2 = *(void *)(a1 + 1144);
  }
  else {
    uint64_t v2 = *(unsigned __int8 *)(a1 + 1159);
  }
  return v2 != 0;
}

unint64_t sub_100CAF3EC(void *a1, uint64_t a2)
{
  if (a2 == 2 && (v3 = (std::__shared_weak_count *)a1[10]) != 0 && (uint64_t v4 = std::__shared_weak_count::lock(v3)) != 0)
  {
    uint64_t v5 = v4;
    uint64_t v6 = (const mach_header_64 *)a1[9];
    if (v6)
    {
      subscriber::makeSimSlotRange();
      uint64_t v7 = v15;
      if (v15 == v16) {
        goto LABEL_27;
      }
      while ((v17(*v7) & 1) == 0)
      {
        if (++v7 == v16)
        {
          uint64_t v7 = v16;
          break;
        }
      }
      if (v7 == v16) {
        goto LABEL_27;
      }
      int v8 = 0;
      int v9 = 0;
      do
      {
        uint64_t v10 = *(uint64_t (**)(const mach_header_64 *, uint64_t))(*(void *)&v6->magic + 192);
        if (*v7 == 1) {
          int v9 = v10(v6, 1);
        }
        else {
          int v8 = v10(v6, 2);
        }
        uint64_t v11 = v7 + 1;
        uint64_t v7 = v16;
        if (v11 != v16)
        {
          uint64_t v7 = v11;
          while ((v17(*v7) & 1) == 0)
          {
            if (++v7 == v16)
            {
              uint64_t v7 = v16;
              break;
            }
          }
        }
      }
      while (v7 != v16);
      if (((v9 ^ v8) & 1) == 0)
      {
LABEL_27:
        uint64_t v14 = a1[5];
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v15) = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Both slots have same registration status", (uint8_t *)&v15, 2u);
        }
        uint64_t v12 = 0;
        uint64_t v6 = 0;
      }
      else
      {
        if (v9) {
          uint64_t v12 = 2;
        }
        else {
          uint64_t v12 = 1;
        }
        uint64_t v6 = &_mh_execute_header;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    sub_10004D2C8(v5);
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v12 = 0;
  }
  return (unint64_t)v6 & (unint64_t)&_mh_execute_header | v12;
}

void sub_100CAF5B8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100CAF5D8(void *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if ((a2 - 3) <= 0xFFFFFFFD)
  {
    uint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315138;
      uint64_t v10 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "invalid slot for query active iccid : %s", (uint8_t *)&v9, 0xCu);
    }
LABEL_11:
    char v8 = 0;
    *(unsigned char *)a3 = 0;
    goto LABEL_14;
  }
  uint64_t v5 = a1[20];
  uint64_t v6 = a1[21];
  if (v5 != v6)
  {
    while (*(_DWORD *)v5 != a2)
    {
      v5 += 168;
      if (v5 == v6) {
        goto LABEL_11;
      }
    }
  }
  if (v5 == v6) {
    goto LABEL_11;
  }
  if (*(char *)(v5 + 95) < 0)
  {
    sub_10004FC84((unsigned char *)a3, *(void **)(v5 + 72), *(void *)(v5 + 80));
  }
  else
  {
    long long v7 = *(_OWORD *)(v5 + 72);
    *(void *)(a3 + 16) = *(void *)(v5 + 88);
    *(_OWORD *)a3 = v7;
  }
  char v8 = 1;
LABEL_14:
  *(unsigned char *)(a3 + 24) = v8;
}

uint64_t sub_100CAF704(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (!a4) {
    goto LABEL_75;
  }
  sub_100CA88D4(a1);
  uint64_t v8 = *(void *)(a1 + 88);
  if (v8)
  {
    uint64_t v9 = *(unsigned __int8 *)(a1 + 1159);
    if ((v9 & 0x80u) == 0) {
      uint64_t v10 = *(unsigned __int8 *)(a1 + 1159);
    }
    else {
      uint64_t v10 = *(void *)(a1 + 1144);
    }
    uint64_t v11 = *(unsigned __int8 *)(a3 + 23);
    int v12 = (char)v11;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a3 + 8);
    }
    if (v10 == v11)
    {
      uint64_t v13 = (const void **)(a1 + 1136);
      if (v12 >= 0) {
        uint64_t v14 = (unsigned __int8 *)a3;
      }
      else {
        uint64_t v14 = *(unsigned __int8 **)a3;
      }
      if ((v9 & 0x80) != 0)
      {
        if (memcmp(*v13, v14, *(void *)(a1 + 1144))) {
          goto LABEL_19;
        }
      }
      else if (*(unsigned char *)(a1 + 1159))
      {
        while (*(unsigned __int8 *)v13 == *v14)
        {
          uint64_t v13 = (const void **)((char *)v13 + 1);
          ++v14;
          if (!--v9) {
            goto LABEL_18;
          }
        }
        goto LABEL_19;
      }
LABEL_18:
      (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 40))(v8, 256);
    }
  }
LABEL_19:
  if (!a2)
  {
    uint64_t v19 = *(unsigned __int8 *)(a3 + 23);
    if ((v19 & 0x80u) != 0) {
      uint64_t v19 = *(void *)(a3 + 8);
    }
    if (v19) {
      goto LABEL_82;
    }
    goto LABEL_87;
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 80);
  if (v15)
  {
    BOOL v16 = std::__shared_weak_count::lock(v15);
    if (v16)
    {
      uint64_t v17 = v16;
      uint64_t v18 = *(void *)(a1 + 72);
      if (!v18)
      {
LABEL_74:
        sub_10004D2C8(v17);
        goto LABEL_75;
      }
      memset(&v69, 0, sizeof(v69));
      memset(&v68, 0, sizeof(v68));
      memset(&v67, 0, sizeof(v67));
      memset(&v66, 0, sizeof(v66));
      long long v87 = 0u;
      long long v88 = 0u;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      sGetProfileDetails();
      uint64_t v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to get profile details and use supplementary plan info", (uint8_t *)&buf, 2u);
      }
      uint64_t v21 = sub_100046F68(a1 + 264, (void **)a3);
      if ((void **)(a1 + 272) != v21)
      {
        uint64_t v22 = v21;
        std::string::operator=(&v69, (const std::string *)(v21 + 10));
        std::string::operator=(&v68, (const std::string *)(v22 + 13));
        std::string::operator=(&v67, (const std::string *)(v22 + 16));
        std::string::operator=(&v66, (const std::string *)(v22 + 19));
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v18 + 176))(v18, a3))
      {
        if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56)) & 1) == 0)
        {
          uint64_t v23 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            if (*(char *)(a3 + 23) >= 0) {
              uint64_t v24 = (unsigned __int8 *)a3;
            }
            else {
              uint64_t v24 = *(unsigned __int8 **)a3;
            }
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v24;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I User re-enabled ICCID (%s) on source!", (uint8_t *)&buf, 0xCu);
          }
          char v25 = (*(uint64_t (**)(void, std::string *, std::string *, std::string *, std::string *, uint64_t))(**(void **)(a1 + 56) + 344))(*(void *)(a1 + 56), &v69, &v68, &v67, &v66, a3);
          long long v74 = 0uLL;
          if (*(char *)(a3 + 23) < 0)
          {
            sub_10004FC84(&__p, *(void **)a3, *(void *)(a3 + 8));
          }
          else
          {
            long long __p = *(_OWORD *)a3;
            uint64_t v72 = *(void *)(a3 + 16);
          }
          char v73 = 1;
          char v65 = 3;
          sub_100CB1258(a1, &v74, &buf, &v65, v25);
          if (SHIBYTE(v72) < 0) {
            operator delete((void *)__p);
          }
        }
LABEL_64:
        if (BYTE8(v88)) {
          sub_1000C584C((uint64_t)&v75);
        }
        if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v66.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v67.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v68.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v69.__r_.__value_.__l.__data_);
        }
        goto LABEL_74;
      }
      (***(void (****)(long long *__return_ptr))(a1 + 56))(&buf);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v26, (Registry *)buf);
      char v28 = ServiceMap;
      if (v29 < 0)
      {
        uint64_t v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v31 = 5381;
        do
        {
          uint64_t v29 = v31;
          unsigned int v32 = *v30++;
          uint64_t v31 = (33 * v31) ^ v32;
        }
        while (v32);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&long long v74 = v29;
      int v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)&v74);
      if (v33)
      {
        uint64_t v35 = v33[3];
        uint64_t v34 = (std::__shared_weak_count *)v33[4];
        if (v34)
        {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v28);
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v34);
          char v36 = 0;
LABEL_49:
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          if (v35 && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v35 + 304))(v35, a3))
          {
            uint32_t v37 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              if (*(char *)(a3 + 23) >= 0) {
                int v38 = (unsigned __int8 *)a3;
              }
              else {
                int v38 = *(unsigned __int8 **)a3;
              }
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v38;
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Out of band transferred and unmark SIM (%s) from abandon", (uint8_t *)&buf, 0xCu);
            }
            (*(void (**)(uint64_t, uint64_t))(*(void *)v35 + 296))(v35, a3);
          }
          if ((v36 & 1) == 0) {
            sub_10004D2C8(v34);
          }
          goto LABEL_64;
        }
      }
      else
      {
        uint64_t v35 = 0;
      }
      std::mutex::unlock(v28);
      uint64_t v34 = 0;
      char v36 = 1;
      goto LABEL_49;
    }
  }
LABEL_75:
  uint64_t v39 = *(unsigned __int8 *)(a3 + 23);
  if ((v39 & 0x80u) != 0) {
    uint64_t v39 = *(void *)(a3 + 8);
  }
  if (v39)
  {
    if (a2)
    {
      if (!sub_10010E128(a1 + 792, (void **)a3))
      {
        *((void *)&buf + 1) = 0;
        *(void *)&long long __p = 0;
        *(void *)&long long buf = (char *)&buf + 8;
        unint64_t v40 = *(unsigned int *)(a1 + 788);
        if (v40 == 1)
        {
LABEL_157:
          *(void *)&long long v75 = a3;
          *((unsigned char *)sub_1000ED870((uint64_t **)&buf, (void **)a3, (uint64_t)&unk_10144E20E, (long long **)&v75) + 56) = a4;
          goto LABEL_158;
        }
        if (*(void *)(a1 + 808) < v40)
        {
          if (sub_100CB1074(a1) || sub_100CB1134(a1, a3))
          {
            if (&buf != (long long *)(a1 + 792)) {
              sub_1008619F0((uint64_t **)&buf, *(void **)(a1 + 792), (void *)(a1 + 800));
            }
          }
          else
          {
            uint64_t v58 = *(void ***)(a1 + 792);
            if (v58 != (void **)(a1 + 800))
            {
              do
              {
                if (sub_100CB1134(a1, (uint64_t)(v58 + 4)))
                {
                  char v59 = sub_100CAE3E4(a1, v58 + 4);
                  *(void *)&long long v75 = v58 + 4;
                  *((unsigned char *)sub_1000ED870((uint64_t **)&buf, v58 + 4, (uint64_t)&unk_10144E20E, (long long **)&v75) + 56) = v59;
                }
                uint64_t v60 = (void **)v58[1];
                if (v60)
                {
                  do
                  {
                    uint64_t v61 = v60;
                    uint64_t v60 = (void **)*v60;
                  }
                  while (v60);
                }
                else
                {
                  do
                  {
                    uint64_t v61 = (void **)v58[2];
                    BOOL v62 = *v61 == v58;
                    uint64_t v58 = v61;
                  }
                  while (!v62);
                }
                uint64_t v58 = v61;
              }
              while (v61 != (void **)(a1 + 800));
            }
          }
          goto LABEL_157;
        }
        if (*(unsigned char *)(a1 + 752) && sub_10001D294((unsigned __int8 *)(a1 + 440), (unsigned __int8 *)a3))
        {
          sub_100058DB0(&v69, "");
          sub_100CB1424((std::string **)&v75, a1, (void **)&v69.__r_.__value_.__l.__data_, a3);
          sub_1006347E0(a1 + 672, &v75);
          sub_10005CD2C((uint64_t)&v75, *((char **)&v75 + 1));
          if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v69.__r_.__value_.__l.__data_);
          }
          goto LABEL_128;
        }
        if (sub_100CB1074(a1))
        {
          sub_100CB1888(a1, *(void *)(a1 + 160), *(void *)(a1 + 168), a3);
LABEL_128:
          unsigned __int8 v43 = 0;
          int v42 = 0;
LABEL_159:
          sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
          return v43 | (v42 << 8);
        }
        *(void *)&long long v75 = a3;
        *((unsigned char *)sub_1000ED870((uint64_t **)&buf, (void **)a3, (uint64_t)&unk_10144E20E, (long long **)&v75) + 56) = a4;
        uint64_t v53 = *(void *)(a1 + 160);
        uint64_t v54 = *(void *)(a1 + 168);
        if (v53 == v54)
        {
LABEL_158:
          __int16 v63 = sub_100CA9968((uint64_t *)a1, &buf, 0, a4);
          unsigned __int8 v43 = v63;
          int v42 = HIBYTE(v63);
          goto LABEL_159;
        }
        uint64_t v55 = v53 + 64;
        while (1)
        {
          if (*(char *)(v55 + 31) < 0)
          {
            if (*(void *)(v55 + 16))
            {
LABEL_137:
              if ((subscriber::isEsimCapable() & 1) == 0)
              {
                char v56 = sub_100CAE3E4(a1, (void **)(v55 + 8));
                *(void *)&long long v75 = v55 + 8;
                *((unsigned char *)sub_1000ED870((uint64_t **)&buf, (void **)(v55 + 8), (uint64_t)&unk_10144E20E, (long long **)&v75)+ 56) = v56;
              }
            }
          }
          else if (*(unsigned char *)(v55 + 31))
          {
            goto LABEL_137;
          }
          uint64_t v57 = v55 + 104;
          v55 += 168;
          if (v57 == v54) {
            goto LABEL_158;
          }
        }
      }
      goto LABEL_90;
    }
LABEL_82:
    if (!sub_10010E128(a1 + 792, (void **)a3))
    {
LABEL_90:
      unsigned __int8 v43 = 0;
      int v42 = 0;
      return v43 | (v42 << 8);
    }
    *((void *)&buf + 1) = 0;
    *(void *)&long long __p = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    if (*(void *)(a1 + 808) == 1)
    {
      if (*(char *)(a1 + 839) < 0)
      {
        if (!*(void *)(a1 + 824)) {
          goto LABEL_96;
        }
      }
      else if (!*(unsigned char *)(a1 + 839))
      {
        goto LABEL_96;
      }
      if (sub_100CB1134(a1, a3))
      {
        long long v44 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v75) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Cannot disable all plans for dual physical slot devices", (uint8_t *)&v75, 2u);
        }
        int v42 = 1;
        unsigned __int8 v43 = 6;
        goto LABEL_159;
      }
    }
LABEL_96:
    long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    sGetProfileDetails();
    if (BYTE11(v80))
    {
      char v45 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
LABEL_98:
        if (BYTE8(v88)) {
          sub_1000C584C((uint64_t)&v75);
        }
        int v42 = 1;
        unsigned __int8 v43 = 43;
        goto LABEL_159;
      }
      LOWORD(v69.__r_.__value_.__l.__data_) = 0;
      char v52 = "Cannot disable profile - not allowed";
LABEL_130:
      _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, v52, (uint8_t *)&v69, 2u);
      goto LABEL_98;
    }
    if (*(_DWORD *)(a1 + 788) != 1) {
      goto LABEL_144;
    }
    uint64_t v46 = *(unsigned __int8 *)(a3 + 23);
    if ((v46 & 0x80u) == 0) {
      uint64_t v47 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v47 = *(void *)(a3 + 8);
    }
    uint64_t v48 = *(unsigned __int8 *)(a1 + 1159);
    int v49 = (char)v48;
    if ((v48 & 0x80u) != 0) {
      uint64_t v48 = *(void *)(a1 + 1144);
    }
    if (v47 == v48)
    {
      if (v49 >= 0) {
        uint64_t v50 = (unsigned __int8 *)(a1 + 1136);
      }
      else {
        uint64_t v50 = *(unsigned __int8 **)(a1 + 1136);
      }
      if ((v46 & 0x80) == 0)
      {
        if (*(unsigned char *)(a3 + 23))
        {
          uint64_t v51 = (unsigned __int8 *)a3;
          while (*v51 == *v50)
          {
            ++v51;
            ++v50;
            if (!--v46) {
              goto LABEL_144;
            }
          }
          goto LABEL_142;
        }
LABEL_144:
        if (&buf != (long long *)(a1 + 792)) {
          sub_1008619F0((uint64_t **)&buf, *(void **)(a1 + 792), (void *)(a1 + 800));
        }
        sub_1000E9358((uint64_t **)&buf, (void **)a3);
        if (BYTE8(v88)) {
          sub_1000C584C((uint64_t)&v75);
        }
        goto LABEL_158;
      }
      if (!memcmp(*(const void **)a3, v50, *(void *)(a3 + 8))) {
        goto LABEL_144;
      }
    }
LABEL_142:
    char v45 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
      goto LABEL_98;
    }
    LOWORD(v69.__r_.__value_.__l.__data_) = 0;
    char v52 = "Cannot disable profile for single slot devices";
    goto LABEL_130;
  }
LABEL_87:
  long long v41 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v75) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "Invalid empty ICCID", (uint8_t *)&v75, 2u);
  }
  int v42 = 1;
  unsigned __int8 v43 = 6;
  return v43 | (v42 << 8);
}

void sub_100CB0264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a70) {
    sub_1000C584C((uint64_t)&a43);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  sub_10004D2C8(v70);
  _Unwind_Resume(a1);
}

void sub_100CB0388(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  long long v7 = *(std::__shared_weak_count **)(a1 + 80);
  if (v7)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v7);
    if (v9)
    {
      uint64_t v10 = v9;
      if (*(void *)(a1 + 72))
      {
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        memset(buf, 0, sizeof(buf));
        int v11 = sub_100CBFE90((void *)a1, (unsigned __int8 *)a2);
        sub_100CA6DF4((char *)buf, a1, v11);
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        memset(v35, 0, sizeof(v35));
        int v12 = sub_100CBFE90((void *)a1, (unsigned __int8 *)a3);
        sub_100CA6DF4((char *)v35, a1, v12);
        unsigned int v13 = HIBYTE(v41);
        if (v41 < 0) {
          unsigned int v13 = v41;
        }
        if (BYTE8(v44)) {
          unsigned int v14 = v13;
        }
        else {
          unsigned int v14 = 0;
        }
        unsigned int v15 = HIBYTE(v36);
        if (v36 < 0) {
          unsigned int v15 = v36;
        }
        if (BYTE8(v39)) {
          unsigned int v16 = v15;
        }
        else {
          unsigned int v16 = 0;
        }
        sub_100CBAC70(v33, a1, a2);
        sub_100CBAC70(__p, a1, a3);
        if (a4) {
          sub_100CBA80C(*(void (****)(Registry **__return_ptr))(a1 + 56), (uint64_t)v33, v14, (uint64_t)__p, v16, 1u);
        }
        else {
          sub_100CBA80C(*(void (****)(Registry **__return_ptr))(a1 + 56), (uint64_t)v33, v14, (uint64_t)__p, v16, 2u);
        }
        if (v32 < 0) {
          operator delete(__p[0]);
        }
        if (v34 < 0) {
          operator delete(v33[0]);
        }
        sub_100CC2224((uint64_t)v35);
        sub_100CC2224((uint64_t)buf);
        if (a4) {
          goto LABEL_45;
        }
      }
      sub_10004D2C8(v10);
    }
  }
  (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)buf);
  uint64_t v19 = ServiceMap;
  if (v20 < 0)
  {
    uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&v35[0] = v20;
  uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)v35);
  if (v24)
  {
    uint64_t v25 = v24[3];
    uint64_t v10 = (std::__shared_weak_count *)v24[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v26 = 0;
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v19);
  uint64_t v10 = 0;
  char v26 = 1;
LABEL_31:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (!v25) {
    goto LABEL_44;
  }
  int v27 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v28 = a2;
    }
    else {
      uint64_t v28 = *(void *)a2;
    }
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v29 = a3;
    }
    else {
      uint64_t v29 = *(void *)a3;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v28;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v29;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Force transferring SIM label from: %s to: %s", buf, 0x16u);
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v25 + 288))(v25, a2);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v25 + 272))(v25, a2, a3)
    && (uint64_t v30 = *(NSObject **)(a1 + 40), os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Failed transferring SIM label.", buf, 2u);
    if (v26) {
      return;
    }
  }
  else
  {
LABEL_44:
    if (v26) {
      return;
    }
  }
LABEL_45:
  sub_10004D2C8(v10);
}

void sub_100CB0784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  sub_100CC2224((uint64_t)&a21);
  sub_100CC2224((uint64_t)&a33);
  sub_10004D2C8(v34);
  _Unwind_Resume(a1);
}

uint64_t sub_100CB0828(uint64_t *a1, void *a2)
{
  sub_100CB089C(v5, a2, 1);
  uint64_t v3 = sub_100CA9968(a1, v5, 0, 1);
  sub_10005CD2C((uint64_t)v5, (char *)v5[1]);
  return v3;
}

void sub_100CB0884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t *sub_100CB089C(uint64_t *result, void *a2, char a3)
{
  result[2] = 0;
  result[1] = 0;
  *uint64_t result = (uint64_t)(result + 1);
  uint64_t v3 = a2 + 1;
  uint64_t v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v6 = (uint64_t **)result;
    do
    {
      uint64_t v10 = (long long *)(v4 + 4);
      uint64_t result = sub_1000ED870(v6, (void **)v4 + 4, (uint64_t)&unk_10144E20E, &v10);
      *((unsigned char *)result + 56) = a3;
      long long v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          long long v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != v3);
  }
  return result;
}

void sub_100CB0958(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100CB0970(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  if (!a2) {
    goto LABEL_7;
  }
  if (*(char *)(a1 + 927) < 0)
  {
    if (*(void *)(a1 + 912)) {
      goto LABEL_6;
    }
LABEL_7:
    if (*(unsigned char *)(a1 + 752) && *(void *)(a1 + 688))
    {
      sub_1000C6BDC(a3, a1 + 672);
    }
    else
    {
      sub_100CA8010(a3, a1);
    }
    return;
  }
  if (!*(unsigned char *)(a1 + 927)) {
    goto LABEL_7;
  }
LABEL_6:
  uint64_t v5 = (_OWORD *)(a1 + 904);
  if (sub_10010E128(a1 + 792, (void **)(a1 + 904))) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 788) == 1)
  {
    if (*(char *)(a1 + 927) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 904), *(void *)(a1 + 912));
    }
    else
    {
      *(_OWORD *)long long __p = *v5;
      *(void *)&long long v40 = *(void *)(a1 + 920);
    }
    sub_1000EA30C((uint64_t)a3, __p, 1);
    if (SBYTE7(v40) < 0) {
      operator delete(__p[0]);
    }
    return;
  }
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v40 = 0u;
  sGetProfileDetails();
  __dst[0] = 0;
  __dst[1] = 0;
  unint64_t v38 = 0;
  if (*(char *)(a1 + 927) < 0)
  {
    sub_10004FC84(&buf, *(void **)(a1 + 904), *(void *)(a1 + 912));
  }
  else
  {
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *v5;
    buf.__r_.__value_.__r.__words[2] = *(void *)(a1 + 920);
  }
  sub_1000EA30C((uint64_t)__dst, (void **)&buf.__r_.__value_.__l.__data_, 1);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (!sub_100CB1074(a1))
  {
    if (!sub_100CB1134(a1, a1 + 904))
    {
      char v26 = *(void ***)(a1 + 792);
      if (v26 != (void **)(a1 + 800))
      {
        do
        {
          if (sub_100CB1134(a1, (uint64_t)(v26 + 4))) {
            sub_100046BAC((uint64_t **)__dst, v26 + 4, (uint64_t)(v26 + 4));
          }
          int v27 = (void **)v26[1];
          if (v27)
          {
            do
            {
              uint64_t v28 = v27;
              int v27 = (void **)*v27;
            }
            while (v27);
          }
          else
          {
            do
            {
              uint64_t v28 = (void **)v26[2];
              BOOL v25 = *v28 == v26;
              char v26 = v28;
            }
            while (!v25);
          }
          char v26 = v28;
        }
        while (v28 != (void **)(a1 + 800));
      }
      goto LABEL_90;
    }
    goto LABEL_30;
  }
  if (*(void *)(a1 + 808) >= (unint64_t)*(unsigned int *)(a1 + 788))
  {
    uint64_t v6 = *(void **)(a1 + 792);
    if (v6 == (void *)(a1 + 800)) {
      goto LABEL_90;
    }
    long long v7 = (unsigned __int8 **)(a1 + 872);
    while (1)
    {
      uint64_t v8 = *(unsigned __int8 *)(a1 + 951);
      if (*(char *)(a1 + 951) < 0) {
        uint64_t v9 = *(void *)(a1 + 936);
      }
      else {
        uint64_t v9 = *(unsigned __int8 *)(a1 + 951);
      }
      uint64_t v10 = (const void **)(v6 + 4);
      if (!v9)
      {
        uint64_t v11 = *((unsigned __int8 *)v6 + 55);
        if ((v11 & 0x80u) == 0) {
          uint64_t v12 = *((unsigned __int8 *)v6 + 55);
        }
        else {
          uint64_t v12 = v6[5];
        }
        uint64_t v13 = *(unsigned __int8 *)(a1 + 895);
        int v14 = (char)v13;
        if ((v13 & 0x80u) != 0) {
          uint64_t v13 = *(void *)(a1 + 880);
        }
        if (v12 == v13)
        {
          if (v14 >= 0) {
            unsigned int v15 = (unsigned __int8 *)(a1 + 872);
          }
          else {
            unsigned int v15 = *v7;
          }
          if ((v11 & 0x80) != 0)
          {
            if (!memcmp(*v10, v15, v6[5])) {
              goto LABEL_73;
            }
          }
          else
          {
            if (!*((unsigned char *)v6 + 55)) {
              goto LABEL_73;
            }
            unsigned int v16 = (unsigned __int8 *)(v6 + 4);
            while (*v16 == *v15)
            {
              ++v16;
              ++v15;
              if (!--v11) {
                goto LABEL_73;
              }
            }
          }
        }
      }
      if ((v8 & 0x80) != 0)
      {
        if (!*(void *)(a1 + 936)) {
          goto LABEL_74;
        }
      }
      else if (!v8)
      {
        goto LABEL_74;
      }
      uint64_t v17 = *((unsigned __int8 *)v6 + 55);
      if ((v17 & 0x80u) == 0) {
        uint64_t v18 = *((unsigned __int8 *)v6 + 55);
      }
      else {
        uint64_t v18 = v6[5];
      }
      uint64_t v19 = *(unsigned __int8 *)(a1 + 895);
      int v20 = (char)v19;
      if ((v19 & 0x80u) != 0) {
        uint64_t v19 = *(void *)(a1 + 880);
      }
      if (v18 != v19) {
        goto LABEL_73;
      }
      if (v20 >= 0) {
        uint64_t v21 = (unsigned __int8 *)(a1 + 872);
      }
      else {
        uint64_t v21 = *v7;
      }
      if ((v17 & 0x80) != 0)
      {
        if (memcmp(*v10, v21, v6[5])) {
          goto LABEL_73;
        }
      }
      else if (*((unsigned char *)v6 + 55))
      {
        uint64_t v22 = (unsigned __int8 *)(v6 + 4);
        while (*v22 == *v21)
        {
          ++v22;
          ++v21;
          if (!--v17) {
            goto LABEL_74;
          }
        }
LABEL_73:
        sub_100046BAC((uint64_t **)__dst, (void **)v6 + 4, (uint64_t)(v6 + 4));
      }
LABEL_74:
      unsigned int v23 = (void *)v6[1];
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          unsigned int v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          uint64_t v24 = (void *)v6[2];
          BOOL v25 = *v24 == (void)v6;
          uint64_t v6 = v24;
        }
        while (!v25);
      }
      uint64_t v6 = v24;
      if (v24 == (void *)(a1 + 800)) {
        goto LABEL_90;
      }
    }
  }
LABEL_30:
  memset(&buf, 0, sizeof(buf));
  sub_100CA8010((uint64_t *)&buf, a1);
  sub_1000C6C34((uint64_t *)__dst, (void **)buf.__r_.__value_.__l.__data_, (void **)&buf.__r_.__value_.__l.__size_);
  sub_10005CD2C((uint64_t)&buf, (char *)buf.__r_.__value_.__l.__size_);
LABEL_90:
  unint64_t v29 = v38;
  uint64_t v30 = *(NSObject **)(a1 + 40);
  if (v38 <= *(unsigned int *)(a1 + 788))
  {
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      sub_1000E8F34((std::string *)__dst[0], (std::string *)&__dst[1], ",", 1uLL, &buf);
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v34 = 136315138;
      uint64_t v35 = p_buf;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I System selection applied: %s", (uint8_t *)&v34, 0xCu);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      unint64_t v29 = v38;
    }
    uint64_t v31 = (char *)__dst[1];
    *a3 = (uint64_t)__dst[0];
    a3[1] = (uint64_t)v31;
    int v33 = a3 + 1;
    a3[2] = v29;
    if (v29)
    {
      *((void *)v31 + 2) = v33;
      __dst[0] = &__dst[1];
      __dst[1] = 0;
      unint64_t v38 = 0;
      uint64_t v31 = 0;
    }
    else
    {
      *a3 = (uint64_t)v33;
    }
  }
  else
  {
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Too many plans to enable - simply reset to user enabled ICCIDs", (uint8_t *)&buf, 2u);
    }
    sub_100CA8010(a3, a1);
    uint64_t v31 = (char *)__dst[1];
  }
  sub_10005CD2C((uint64_t)__dst, v31);
  if (BYTE8(v52)) {
    sub_1000C584C((uint64_t)__p);
  }
}

void sub_100CB0FC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char *a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  if (a55) {
    sub_1000C584C((uint64_t)&a25);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CB1074(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56));
  if (result)
  {
    uint64_t v4 = *(void *)(a1 + 160);
    uint64_t v3 = *(void *)(a1 + 168);
    if (v4 == v3)
    {
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I SIM info empty", v9, 2u);
      }
      return 1;
    }
    else
    {
      uint64_t v5 = v4 + 168;
      do
      {
        int v6 = *(_DWORD *)(v5 - 104);
        uint64_t result = v6 == 4;
        BOOL v7 = v6 == 4 || v5 == v3;
        v5 += 168;
      }
      while (!v7);
    }
  }
  return result;
}

uint64_t sub_100CB1134(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 160);
  uint64_t v4 = *(void *)(a1 + 168);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
  }
  char v5 = HIBYTE(v13);
  if (v3 != v4)
  {
    if (v13 >= 0) {
      int v6 = (void *)HIBYTE(v13);
    }
    else {
      int v6 = __p[1];
    }
    if (v13 >= 0) {
      BOOL v7 = __p;
    }
    else {
      BOOL v7 = (void **)__p[0];
    }
    do
    {
      uint64_t v8 = *(unsigned __int8 *)(v3 + 95);
      if ((v8 & 0x80u) == 0) {
        uint64_t v9 = (void *)*(unsigned __int8 *)(v3 + 95);
      }
      else {
        uint64_t v9 = *(void **)(v3 + 80);
      }
      if (v9 == v6)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v3 + 72), v7, *(void *)(v3 + 80))) {
            goto LABEL_24;
          }
        }
        else
        {
          if (!*(unsigned char *)(v3 + 95)) {
            goto LABEL_24;
          }
          uint64_t v10 = 0;
          while (*(unsigned __int8 *)(v3 + v10 + 72) == *((unsigned __int8 *)v7 + v10))
          {
            if (v8 == ++v10) {
              goto LABEL_24;
            }
          }
        }
      }
      v3 += 168;
    }
    while (v3 != v4);
    uint64_t v3 = v4;
  }
LABEL_24:
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  if (v3 == *(void *)(a1 + 168)) {
    return 0;
  }
  else {
    return subscriber::isEsimCapable() ^ 1;
  }
}

void sub_100CB1258(uint64_t a1, _OWORD *a2, long long *a3, unsigned char *a4, char a5)
{
  *(_DWORD *)unsigned int v15 = 0;
  *(_OWORD *)&_OWORD v15[4] = *a2;
  long long v16 = *a3;
  uint64_t v9 = a3 + 1;
  if (*((char *)a3 + 39) < 0)
  {
    sub_10004FC84(&v17, *((void **)a3 + 2), *((void *)a3 + 3));
  }
  else
  {
    long long v17 = *v9;
    uint64_t v18 = *((void *)a3 + 4);
  }
  char v10 = *((unsigned char *)a3 + 40);
  char v19 = v10;
  LOBYTE(v20) = *a4;
  HIBYTE(v20) = a5;
  int v11 = *(unsigned __int8 *)(a1 + 1128);
  *(_DWORD *)(a1 + 1064) = *(_DWORD *)&v15[16];
  *(_OWORD *)(a1 + 1048) = *(_OWORD *)v15;
  *(_OWORD *)(a1 + 1072) = v16;
  uint64_t v12 = (void **)(a1 + 1088);
  if (v11)
  {
    if (*(char *)(a1 + 1111) < 0)
    {
      operator delete(*v12);
      char v10 = v19;
    }
    *(_OWORD *)uint64_t v12 = v17;
    *(void *)(a1 + 1104) = v18;
    HIBYTE(v18) = 0;
    LOBYTE(v17) = 0;
    *(unsigned char *)(a1 + 1112) = v10;
    *(_WORD *)(a1 + 1120) = v20;
  }
  else
  {
    *(_OWORD *)uint64_t v12 = v17;
    *(void *)(a1 + 1104) = v18;
    uint64_t v18 = 0;
    long long v17 = 0uLL;
    *(unsigned char *)(a1 + 1112) = v10;
    *(_WORD *)(a1 + 1120) = v20;
    *(unsigned char *)(a1 + 1128) = 1;
  }
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 39) >= 0) {
      int v14 = v9;
    }
    else {
      int v14 = (_OWORD *)*((void *)a3 + 2);
    }
    *(_DWORD *)unsigned int v15 = 136315138;
    *(void *)&_OWORD v15[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Provision Monitor mode for Iccid: %s", v15, 0xCu);
  }
  sub_100CAD864(a1);
}

void sub_100CB1424(std::string **a1, uint64_t a2, void **a3, uint64_t a4)
{
  *(_OWORD *)&v30.__r_.__value_.__r.__words[1] = 0uLL;
  v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30.__r_.__value_.__l.__size_;
  if (*(_DWORD *)(a2 + 788) == 1)
  {
    if (*(char *)(a4 + 23) < 0)
    {
      unint64_t v8 = *(void *)(a4 + 8);
      if (v8)
      {
        sub_10004FC84(&__p, *(void **)a4, v8);
        goto LABEL_7;
      }
    }
    else if (*(unsigned char *)(a4 + 23))
    {
      std::string __p = *(std::string *)a4;
LABEL_7:
      sub_1000EA30C((uint64_t)a1, (void **)&__p.__r_.__value_.__l.__data_, 1);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string::size_type size = v30.__r_.__value_.__l.__size_;
      goto LABEL_65;
    }
  }
  if (*(unsigned char *)(a2 + 752) && (char v10 = (std::string *)(a2 + 672), sub_10010E128(a2 + 672, (void **)a4)))
  {
    int v11 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a4 + 23) >= 0) {
        uint64_t v12 = (void *)a4;
      }
      else {
        uint64_t v12 = *(void **)a4;
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Placeholder enabled ICCID includes [%s] already", (uint8_t *)&__p, 0xCu);
    }
    if (&v30 != v10) {
      sub_1000EA390((uint64_t **)&v30, *(void **)(a2 + 672), (void *)(a2 + 680));
    }
  }
  else
  {
    sub_100CA8010((uint64_t *)&__p, a2);
    sub_10005CD2C((uint64_t)&v30, (char *)v30.__r_.__value_.__l.__size_);
    uint64_t v13 = (char *)__p.__r_.__value_.__l.__size_;
    std::string v30 = __p;
    if (__p.__r_.__value_.__r.__words[2])
    {
      *(void *)(__p.__r_.__value_.__l.__size_ + 16) = &v30.__r_.__value_.__l.__size_;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
      *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
      uint64_t v13 = 0;
    }
    else
    {
      v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30.__r_.__value_.__l.__size_;
    }
    sub_10005CD2C((uint64_t)&__p, v13);
  }
  sub_100046BAC((uint64_t **)&v30, (void **)a4, a4);
  sub_1000E9358((uint64_t **)&v30, a3);
  if (sub_100CB1074(a2)) {
    goto LABEL_50;
  }
  std::string::size_type v14 = v30.__r_.__value_.__r.__words[0];
  if ((std::string::size_type *)v30.__r_.__value_.__l.__data_ == &v30.__r_.__value_.__r.__words[1]) {
    goto LABEL_50;
  }
  while (1)
  {
    if (sub_100CB1134(a2, v14 + 32)) {
      goto LABEL_42;
    }
    uint64_t v15 = *(unsigned __int8 *)(v14 + 55);
    if ((v15 & 0x80u) == 0) {
      uint64_t v16 = *(unsigned __int8 *)(v14 + 55);
    }
    else {
      uint64_t v16 = *(void *)(v14 + 40);
    }
    uint64_t v17 = *(unsigned __int8 *)(a4 + 23);
    int v18 = (char)v17;
    if ((v17 & 0x80u) != 0) {
      uint64_t v17 = *(void *)(a4 + 8);
    }
    if (v16 != v17) {
      goto LABEL_49;
    }
    char v19 = v18 >= 0 ? (unsigned __int8 *)a4 : *(unsigned __int8 **)a4;
    if ((v15 & 0x80) == 0) {
      break;
    }
    if (memcmp(*(const void **)(v14 + 32), v19, *(void *)(v14 + 40))) {
      goto LABEL_49;
    }
LABEL_42:
    uint64_t v21 = *(std::string **)(v14 + 8);
    if (v21)
    {
      do
      {
        uint64_t v22 = v21;
        uint64_t v21 = (std::string *)v21->__r_.__value_.__r.__words[0];
      }
      while (v21);
    }
    else
    {
      do
      {
        uint64_t v22 = *(std::string **)(v14 + 16);
        BOOL v23 = v22->__r_.__value_.__r.__words[0] == v14;
        std::string::size_type v14 = (std::string::size_type)v22;
      }
      while (!v23);
    }
    std::string::size_type v14 = (std::string::size_type)v22;
    if (v22 == (std::string *)&v30.__r_.__value_.__r.__words[1]) {
      goto LABEL_50;
    }
  }
  if (!*(unsigned char *)(v14 + 55)) {
    goto LABEL_42;
  }
  __int16 v20 = (unsigned __int8 *)(v14 + 32);
  while (*v20 == *v19)
  {
    ++v20;
    ++v19;
    if (!--v15) {
      goto LABEL_42;
    }
  }
LABEL_49:
  sub_1000E9358((uint64_t **)&v30, (void **)(v14 + 32));
LABEL_50:
  uint64_t v24 = (std::string *)v30.__r_.__value_.__r.__words[2];
  if (v30.__r_.__value_.__r.__words[2] <= *(unsigned int *)(a2 + 788))
  {
    char v26 = (std::string *)v30.__r_.__value_.__r.__words[0];
  }
  else
  {
    BOOL v25 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Placeholder enabled ICCID calculation failure - clearing", (uint8_t *)&__p, 2u);
    }
    sub_10005CD2C((uint64_t)&v30, (char *)v30.__r_.__value_.__l.__size_);
    uint64_t v24 = 0;
    *(_OWORD *)&v30.__r_.__value_.__r.__words[1] = 0uLL;
    char v26 = (std::string *)&v30.__r_.__value_.__r.__words[1];
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30.__r_.__value_.__l.__size_;
  }
  int v27 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000E8F34(v26, (std::string *)&v30.__r_.__value_.__r.__words[1], ",", 1uLL, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    char v32 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Placeholder ICCIDs: %s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    char v26 = (std::string *)v30.__r_.__value_.__r.__words[0];
    uint64_t v24 = (std::string *)v30.__r_.__value_.__r.__words[2];
  }
  *a1 = v26;
  std::string::size_type size = v30.__r_.__value_.__l.__size_;
  a1[1] = (std::string *)v30.__r_.__value_.__l.__size_;
  unint64_t v29 = (std::string *)(a1 + 1);
  a1[2] = v24;
  if (v24)
  {
    *(void *)(size + 16) = v29;
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30.__r_.__value_.__l.__size_;
    *(_OWORD *)&v30.__r_.__value_.__r.__words[1] = 0uLL;
    std::string::size_type size = 0;
  }
  else
  {
    *a1 = v29;
  }
LABEL_65:
  sub_10005CD2C((uint64_t)&v30, (char *)size);
}

void sub_100CB1844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, char *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

void sub_100CB1888(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a1 + 1160) || *(_DWORD *)(a1 + 336) < 2u) {
    return;
  }
  uint64_t v7 = a2;
  unsigned int v99 = 0;
  unint64_t v100 = 0;
  unint64_t v101 = 0;
  if (a2 == a3)
  {
    if (*(_DWORD *)(a1 + 788)) {
      goto LABEL_223;
    }
LABEL_53:
    memset(v98, 0, sizeof(v98));
    std::string::operator=(v98, (const std::string *)a4);
    *(void *)&long long buf = a4;
    char v26 = sub_100CC3268((uint64_t **)(a1 + 264), (void **)a4, (long long **)&buf);
    std::string::operator=(&v98[1], (const std::string *)(v26 + 56));
    std::string::size_type v95 = 0;
    uint64_t v96 = 0;
    uint64_t v97 = 0;
    uint64_t v27 = (uint64_t)v99;
    if ((void **)v100 == v99 || 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v100 - (void)v99) >> 3) <= 1) {
      sub_10015B728();
    }
    (***(void (****)(long long *__return_ptr))(a1 + 56))(&buf);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v28, (Registry *)buf);
    std::string v30 = ServiceMap;
    if (v31 < 0)
    {
      char v32 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v33 = 5381;
      do
      {
        uint64_t v31 = v33;
        unsigned int v34 = *v32++;
        uint64_t v33 = (33 * v33) ^ v34;
      }
      while (v34);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long __p = v31;
    uint64_t v35 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)&__p);
    if (v35)
    {
      uint64_t v36 = v35[3];
      long long v37 = (std::__shared_weak_count *)v35[4];
      if (v37)
      {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v30);
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v91 = v37;
        sub_10004D2C8(v37);
        char v38 = 0;
        goto LABEL_63;
      }
    }
    else
    {
      uint64_t v36 = 0;
    }
    std::mutex::unlock(v30);
    uint64_t v91 = 0;
    char v38 = 1;
LABEL_63:
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    long long v115 = 0;
    long long v113 = 0u;
    long long __s1 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    long long buf = 0u;
    long long v110 = 0u;
    if (*(char *)(v27 + 23) < 0)
    {
      sub_10004FC84(&__p, *(void **)v27, *(void *)(v27 + 8));
    }
    else
    {
      long long v39 = *(_OWORD *)v27;
      *(void *)&long long v103 = *(void *)(v27 + 16);
      long long __p = v39;
    }
    (*(void (**)(long long *__return_ptr, uint64_t, long long *))(*(void *)v36 + 168))(&buf, v36, &__p);
    if (SBYTE7(v103) < 0) {
      operator delete((void *)__p);
    }
    long long v40 = (long long *)(v27 + 24);
    uint64_t v108 = 0;
    long long v106 = 0u;
    long long v107 = 0u;
    long long v104 = 0u;
    long long v105 = 0u;
    long long __p = 0u;
    long long v103 = 0u;
    if (*(char *)(v27 + 47) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(v27 + 24), *(void *)(v27 + 32));
    }
    else
    {
      long long __dst = *v40;
      long long v121 = *(void **)(v27 + 40);
    }
    (*(void (**)(long long *__return_ptr, uint64_t, long long *))(*(void *)v36 + 168))(&__p, v36, &__dst);
    if (SHIBYTE(v121) < 0) {
      operator delete((void *)__dst);
    }
    uint64_t v41 = BYTE7(v113);
    if (SBYTE7(v113) < 0) {
      uint64_t v41 = *((void *)&v112 + 1);
    }
    char v92 = v38;
    if (!v41) {
      goto LABEL_98;
    }
    uint64_t v42 = BYTE7(v106);
    if (SBYTE7(v106) < 0) {
      uint64_t v42 = *((void *)&v105 + 1);
    }
    if (v42)
    {
      unint64_t v43 = *((void *)&buf + 1);
      if ((SBYTE7(v110) & 0x80u) == 0) {
        uint64_t v44 = BYTE7(v110);
      }
      else {
        uint64_t v44 = *((void *)&buf + 1);
      }
      if (v44)
      {
        uint64_t v45 = BYTE7(v103);
        char v46 = BYTE7(v103);
        if (SBYTE7(v103) < 0) {
          uint64_t v45 = *((void *)&__p + 1);
        }
        if (v45)
        {
          if (v44 != v45)
          {
LABEL_100:
            if ((BYTE7(v110) & 0x80) == 0)
            {
              long long __dst = buf;
              long long v121 = (void *)v110;
              goto LABEL_105;
            }
            long long v51 = (void *)buf;
LABEL_104:
            sub_10004FC84(&__dst, v51, v43);
            char v46 = BYTE7(v103);
LABEL_105:
            if (v46 < 0)
            {
              sub_10004FC84(&v122, (void *)__p, *((unint64_t *)&__p + 1));
            }
            else
            {
              long long v122 = __p;
              v123[0] = v103;
            }
            std::string::size_type v95 = 0;
            uint64_t v96 = 0;
            uint64_t v97 = 0;
            uint64_t v116 = &v95;
            uint64_t v117 = 0;
            std::string::size_type v95 = (char *)operator new(0x30uLL);
            uint64_t v96 = v95;
            uint64_t v97 = v95 + 48;
            uint64_t v67 = 0;
            uint64_t v96 = sub_1000D8A18((uint64_t)&v97, &__dst, v124, v95);
            do
            {
              if (SHIBYTE(v123[v67]) < 0) {
                operator delete((void *)v123[v67 - 2]);
              }
              v67 -= 3;
            }
            while (v67 != -6);
LABEL_187:
            if (SHIBYTE(v108) < 0) {
              operator delete((void *)v107);
            }
            if (SBYTE7(v106) < 0) {
              operator delete((void *)v105);
            }
            if (SHIBYTE(v104) < 0) {
              operator delete(*((void **)&v103 + 1));
            }
            if (SBYTE7(v103) < 0) {
              operator delete((void *)__p);
            }
            if (SHIBYTE(v115) < 0) {
              operator delete((void *)__s1);
            }
            if (SBYTE7(v113) < 0) {
              operator delete((void *)v112);
            }
            if (SHIBYTE(v111) < 0) {
              operator delete(*((void **)&v110 + 1));
            }
            if (SBYTE7(v110) < 0) {
              operator delete((void *)buf);
            }
            if ((v92 & 1) == 0) {
              sub_10004D2C8(v91);
            }
            unint64_t v81 = 0;
            long long v113 = 0u;
            long long __s1 = 0u;
            long long v111 = 0u;
            long long v112 = 0u;
            char v82 = 1;
            long long buf = 0u;
            long long v110 = 0u;
            while (1)
            {
              char v83 = v82;
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v100 - (void)v99) >> 3) <= v81) {
                break;
              }
              std::string::operator=((std::string *)&buf + 2 * v81, (const std::string *)&v99[3 * v81]);
              if (0xAAAAAAAAAAAAAAABLL * ((v96 - v95) >> 3) <= v81) {
                break;
              }
              std::string::operator=((std::string *)((char *)&v110 + 48 * v81 + 8), (const std::string *)&v95[24 * v81]);
              char v82 = 0;
              unint64_t v81 = 1;
              if ((v83 & 1) == 0)
              {
                uint64_t v84 = *(void *)(a1 + 56);
                if (*(char *)(a4 + 23) < 0)
                {
                  sub_10004FC84(&v93, *(void **)a4, *(void *)(a4 + 8));
                }
                else
                {
                  long long v93 = *(_OWORD *)a4;
                  uint64_t v94 = *(void *)(a4 + 16);
                }
                long long v119 = 0;
                long long v85 = operator new(0x28uLL);
                void *v85 = off_101A4E4C8;
                v85[1] = a1;
                long long v86 = v85 + 2;
                if (SHIBYTE(v94) < 0)
                {
                  sub_10004FC84(v86, (void *)v93, *((unint64_t *)&v93 + 1));
                }
                else
                {
                  *(_OWORD *)long long v86 = v93;
                  v85[4] = v94;
                }
                long long v119 = v85;
                (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, long long *, std::string *, void *))(*(void *)v84 + 928))(&__p, v84, a1 + 24, &buf, v98, v118);
                long long v87 = __p;
                long long __p = 0uLL;
                long long v88 = *(std::__shared_weak_count **)(a1 + 1168);
                *(_OWORD *)(a1 + 1160) = v87;
                if (v88)
                {
                  sub_10004D2C8(v88);
                  if (*((void *)&__p + 1)) {
                    sub_10004D2C8(*((std::__shared_weak_count **)&__p + 1));
                  }
                }
                sub_1000D83A0(v118);
                if (SHIBYTE(v94) < 0) {
                  operator delete((void *)v93);
                }
                dispatch_get_global_queue(0, 0);
                uint64_t v89 = *(void *)(a1 + 1168);
                if (v89) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v89 + 8), 1uLL, memory_order_relaxed);
                }
                operator new();
              }
            }
            sub_10015B728();
          }
          if ((SBYTE7(v103) & 0x80u) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (long long *)__p;
          }
          if ((BYTE7(v110) & 0x80) != 0)
          {
            long long v51 = (void *)buf;
            if (memcmp((const void *)buf, p_p, *((size_t *)&buf + 1))) {
              goto LABEL_104;
            }
          }
          else if (BYTE7(v110))
          {
            p_long long buf = &buf;
            uint64_t v49 = BYTE7(v110);
            int v50 = 1;
            while (*(unsigned __int8 *)p_buf == *(unsigned __int8 *)p_p)
            {
              p_long long buf = (long long *)((char *)p_buf + 1);
              p_p = (long long *)((char *)p_p + 1);
              if (!--v49) {
                goto LABEL_108;
              }
            }
            goto LABEL_100;
          }
        }
      }
      int v50 = 1;
    }
    else
    {
LABEL_98:
      int v50 = 0;
    }
LABEL_108:
    long long v52 = sub_100046F68(a1 + 264, (void **)v27);
    uint64_t v53 = sub_100046F68(a1 + 264, (void **)(v27 + 24));
    if ((void **)(a1 + 272) != v52)
    {
      uint64_t v54 = v53;
      if ((void **)(a1 + 272) != v53)
      {
        unint64_t v55 = *((unsigned __int8 *)v52 + 79);
        if (*((char *)v52 + 79) < 0 ? v52[8] : (void *)*((unsigned __int8 *)v52 + 79))
        {
          int v57 = *((char *)v53 + 79);
          uint64_t v58 = (void *)*((unsigned __int8 *)v53 + 79);
          if (v57 < 0 ? v53[8] : (void *)*((unsigned __int8 *)v53 + 79))
          {
            uint64_t v60 = (long long *)(v53 + 7);
            uint64_t v61 = v52 + 7;
            unint64_t v62 = (unint64_t)v52[8];
            if ((v55 & 0x80u) == 0) {
              unint64_t v63 = v55;
            }
            else {
              unint64_t v63 = v62;
            }
            if (v57 < 0) {
              uint64_t v58 = v53[8];
            }
            if ((void *)v63 != v58)
            {
LABEL_133:
              if ((v55 & 0x80) == 0)
              {
                long long __dst = *(_OWORD *)v61;
                long long v121 = v61[2];
                goto LABEL_144;
              }
              std::string v68 = *v61;
LABEL_143:
              sub_10004FC84(&__dst, v68, v62);
              LOBYTE(v57) = *((unsigned char *)v54 + 79);
LABEL_144:
              if ((v57 & 0x80) != 0)
              {
                sub_10004FC84(&v122, v54[7], (unint64_t)v54[8]);
              }
              else
              {
                long long v122 = *v60;
                v123[0] = v54[9];
              }
              std::string::size_type v95 = 0;
              uint64_t v96 = 0;
              uint64_t v97 = 0;
              uint64_t v116 = &v95;
              uint64_t v117 = 0;
              std::string::size_type v95 = (char *)operator new(0x30uLL);
              uint64_t v96 = v95;
              uint64_t v97 = v95 + 48;
              uint64_t v76 = 0;
              uint64_t v96 = sub_1000D8A18((uint64_t)&v97, &__dst, v124, v95);
              do
              {
                if (SHIBYTE(v123[v76]) < 0) {
                  operator delete((void *)v123[v76 - 2]);
                }
                v76 -= 3;
              }
              while (v76 != -6);
              goto LABEL_187;
            }
            if (v57 >= 0) {
              long long v64 = (unsigned __int8 *)(v53 + 7);
            }
            else {
              long long v64 = *(unsigned __int8 **)v60;
            }
            if ((v55 & 0x80) != 0)
            {
              std::string v68 = *v61;
              if (memcmp(*v61, v64, v62)) {
                goto LABEL_143;
              }
            }
            else if (v55)
            {
              char v65 = v61;
              unint64_t v66 = v55;
              while (*(unsigned __int8 *)v65 == *v64)
              {
                char v65 = (void **)((char *)v65 + 1);
                ++v64;
                if (!--v66) {
                  goto LABEL_146;
                }
              }
              goto LABEL_133;
            }
          }
        }
      }
    }
LABEL_146:
    if (v50)
    {
      unint64_t v69 = *((void *)&__s1 + 1);
      uint64_t v70 = SHIBYTE(v115) >= 0 ? HIBYTE(v115) : *((void *)&__s1 + 1);
      if (v70)
      {
        char v71 = HIBYTE(v108);
        uint64_t v72 = *((void *)&v107 + 1);
        if (v108 >= 0) {
          uint64_t v72 = HIBYTE(v108);
        }
        if (v72)
        {
          if (v70 != v72)
          {
LABEL_164:
            if ((HIBYTE(v115) & 0x80) == 0)
            {
              long long __dst = __s1;
              long long v121 = v115;
              goto LABEL_175;
            }
            long long v77 = (void *)__s1;
LABEL_174:
            sub_10004FC84(&__dst, v77, v69);
            char v71 = HIBYTE(v108);
LABEL_175:
            if (v71 < 0)
            {
              sub_10004FC84(&v122, (void *)v107, *((unint64_t *)&v107 + 1));
            }
            else
            {
              long long v122 = v107;
              v123[0] = v108;
            }
            std::string::size_type v95 = 0;
            uint64_t v96 = 0;
            uint64_t v97 = 0;
            uint64_t v116 = &v95;
            uint64_t v117 = 0;
            std::string::size_type v95 = (char *)operator new(0x30uLL);
            uint64_t v96 = v95;
            uint64_t v97 = v95 + 48;
            uint64_t v90 = 0;
            uint64_t v96 = sub_1000D8A18((uint64_t)&v97, &__dst, v124, v95);
            do
            {
              if (SHIBYTE(v123[v90]) < 0) {
                operator delete((void *)v123[v90 - 2]);
              }
              v90 -= 3;
            }
            while (v90 != -6);
            goto LABEL_187;
          }
          if (v108 >= 0) {
            char v73 = &v107;
          }
          else {
            char v73 = (long long *)v107;
          }
          if ((HIBYTE(v115) & 0x80) != 0)
          {
            long long v77 = (void *)__s1;
            if (memcmp((const void *)__s1, v73, *((size_t *)&__s1 + 1))) {
              goto LABEL_174;
            }
          }
          else if (HIBYTE(v115))
          {
            p_s1 = &__s1;
            uint64_t v75 = HIBYTE(v115);
            while (*(unsigned __int8 *)p_s1 == *(unsigned __int8 *)v73)
            {
              p_s1 = (long long *)((char *)p_s1 + 1);
              char v73 = (long long *)((char *)v73 + 1);
              if (!--v75) {
                goto LABEL_177;
              }
            }
            goto LABEL_164;
          }
        }
      }
    }
LABEL_177:
    if (*(char *)(v27 + 23) < 0)
    {
      sub_10004FC84(&__dst, *(void **)v27, *(void *)(v27 + 8));
    }
    else
    {
      long long v78 = *(_OWORD *)v27;
      long long v121 = *(void **)(v27 + 16);
      long long __dst = v78;
    }
    if (*(char *)(v27 + 47) < 0)
    {
      sub_10004FC84(&v122, *(void **)(v27 + 24), *(void *)(v27 + 32));
    }
    else
    {
      long long v79 = *v40;
      v123[0] = *(void *)(v27 + 40);
      long long v122 = v79;
    }
    std::string::size_type v95 = 0;
    uint64_t v96 = 0;
    uint64_t v97 = 0;
    uint64_t v116 = &v95;
    uint64_t v117 = 0;
    std::string::size_type v95 = (char *)operator new(0x30uLL);
    uint64_t v96 = v95;
    uint64_t v97 = v95 + 48;
    uint64_t v80 = 0;
    uint64_t v96 = sub_1000D8A18((uint64_t)&v97, &__dst, v124, v95);
    do
    {
      if (SHIBYTE(v123[v80]) < 0) {
        operator delete((void *)v123[v80 - 2]);
      }
      v80 -= 3;
    }
    while (v80 != -6);
    goto LABEL_187;
  }
  do
  {
    if (subscriber::isSimAbsent()) {
      goto LABEL_39;
    }
    if (*(char *)(v7 + 95) < 0)
    {
      if (!*(void *)(v7 + 80)) {
        goto LABEL_39;
      }
    }
    else if (!*(unsigned char *)(v7 + 95))
    {
      goto LABEL_39;
    }
    (***(void (****)(long long *__return_ptr))(a1 + 56))(&__p);
    long long buf = __p;
    long long __p = 0uLL;
    char isValidSimSlot = subscriber::isValidSimSlot();
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    if (*((void *)&__p + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&__p + 1));
    }
    if (isValidSimSlot)
    {
      uint64_t v9 = (const void **)(v7 + 72);
      uint64_t v10 = *(unsigned __int8 *)(v7 + 95);
      unint64_t v11 = *(void *)(v7 + 80);
      if ((v10 & 0x80u) == 0) {
        uint64_t v12 = *(unsigned __int8 *)(v7 + 95);
      }
      else {
        uint64_t v12 = *(void *)(v7 + 80);
      }
      uint64_t v13 = *(unsigned __int8 *)(a4 + 23);
      int v14 = (char)v13;
      if ((v13 & 0x80u) != 0) {
        uint64_t v13 = *(void *)(a4 + 8);
      }
      if (v12 != v13) {
        goto LABEL_29;
      }
      if (v14 >= 0) {
        uint64_t v15 = (unsigned __int8 *)a4;
      }
      else {
        uint64_t v15 = *(unsigned __int8 **)a4;
      }
      if ((v10 & 0x80) != 0)
      {
        char v19 = (void *)*v9;
        if (!memcmp(*v9, v15, *(void *)(v7 + 80))) {
          goto LABEL_223;
        }
        uint64_t v17 = (unsigned char *)v100;
        if (v100 < v101) {
          goto LABEL_36;
        }
      }
      else
      {
        if (!*(unsigned char *)(v7 + 95)) {
          goto LABEL_223;
        }
        uint64_t v16 = 0;
        while (*(unsigned __int8 *)(v7 + v16 + 72) == v15[v16])
        {
          if (v10 == ++v16) {
            goto LABEL_223;
          }
        }
LABEL_29:
        uint64_t v17 = (unsigned char *)v100;
        if (v100 < v101)
        {
          if ((v10 & 0x80) == 0)
          {
            long long v18 = *(_OWORD *)v9;
            *(void *)(v100 + 16) = *(void *)(v7 + 88);
            *(_OWORD *)uint64_t v17 = v18;
            goto LABEL_37;
          }
          char v19 = (void *)*v9;
LABEL_36:
          sub_10004FC84(v17, v19, v11);
LABEL_37:
          uint64_t v20 = (uint64_t)(v17 + 24);
LABEL_38:
          unint64_t v100 = v20;
          goto LABEL_39;
        }
      }
      uint64_t v20 = sub_10030E9EC((uint64_t *)&v99, (long long *)(v7 + 72));
      goto LABEL_38;
    }
LABEL_39:
    v7 += 168;
  }
  while (v7 != a3);
  uint64_t v21 = v99;
  uint64_t v22 = (unsigned __int8 **)v100;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v100 - (void)v99) >> 3) != *(_DWORD *)(a1 + 788)) {
    goto LABEL_223;
  }
  if (v99 == (void **)v100) {
    goto LABEL_53;
  }
  uint64_t v23 = 0;
  uint64_t v24 = (unsigned __int8 **)v99;
  do
  {
    v23 += sub_100CA6CF8(a1, v24);
    v24 += 3;
  }
  while (v24 != v22);
  if (!v23) {
    goto LABEL_53;
  }
  BOOL v25 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Found offload Iccid in active plans, turn it off automatically", (uint8_t *)&buf, 2u);
    uint64_t v21 = v99;
    uint64_t v22 = (unsigned __int8 **)v100;
  }
  *((void *)&buf + 1) = 0;
  *(void *)&long long v110 = 0;
  *(void *)&long long buf = (char *)&buf + 8;
  while (v21 != (void **)v22)
  {
    if ((sub_100CA6CF8(a1, (unsigned __int8 **)v21) & 1) == 0) {
      sub_100046BAC((uint64_t **)&buf, v21, (uint64_t)v21);
    }
    v21 += 3;
  }
  sub_100046BAC((uint64_t **)&buf, (void **)a4, a4);
  sub_100CB089C((uint64_t *)&__p, &buf, 0);
  sub_100CA9968((uint64_t *)a1, &__p, 0, 0);
  sub_10005CD2C((uint64_t)&__p, *((char **)&__p + 1));
  sub_10005CD2C((uint64_t)&buf, *((char **)&buf + 1));
LABEL_223:
  *(void *)&long long buf = &v99;
  sub_100047F64((void ***)&buf);
}

void sub_100CB26C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  if (*(char *)(v51 - 137) < 0) {
    operator delete(*(void **)(v51 - 160));
  }
  sub_1001A7138((uint64_t)&a33);
  sub_1001A7138((uint64_t)&a50);
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  sub_1001085D8((uint64_t)&a23);
  a33 = &a30;
  sub_100047F64((void ***)&a33);
  _Unwind_Resume(a1);
}

void sub_100CB2988(uint64_t a1, std::string *a2, int a3)
{
  if (a3) {
    sub_100CA88D4(a1);
  }
  int v5 = SHIBYTE(a2->__r_.__value_.__r.__words[2]);
  if (v5 >= 0) {
    std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = a2->__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    unint64_t v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(v30) = 0;
    uint64_t v9 = "Active user data selection iccid is Empty";
LABEL_12:
    uint64_t v10 = v8;
    uint32_t v11 = 2;
    goto LABEL_13;
  }
  if (*(_DWORD *)(a1 + 788) <= 1u)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v30) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Cannot set active data ICCID on single stack device", (uint8_t *)&v30, 2u);
    }
    return;
  }
  uint64_t v12 = *(unsigned __int8 *)(a1 + 895);
  if ((v12 & 0x80u) == 0) {
    uint64_t v13 = *(unsigned __int8 *)(a1 + 895);
  }
  else {
    uint64_t v13 = *(void *)(a1 + 880);
  }
  if (v13 == size)
  {
    if (v5 >= 0) {
      int v14 = a2;
    }
    else {
      int v14 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    if ((v12 & 0x80) != 0)
    {
      if (!memcmp(*(const void **)(a1 + 872), v14, *(void *)(a1 + 880))) {
        return;
      }
    }
    else
    {
      if (!*(unsigned char *)(a1 + 895)) {
        return;
      }
      for (uint64_t i = (unsigned __int8 *)(a1 + 872); *i == v14->__r_.__value_.__s.__data_[0]; ++i)
      {
        int v14 = (std::string *)((char *)v14 + 1);
        if (!--v12) {
          return;
        }
      }
    }
  }
  if (*(unsigned char *)(a1 + 752))
  {
    uint64_t v16 = *(unsigned __int8 *)(a1 + 463);
    if ((v16 & 0x80u) == 0) {
      uint64_t v17 = *(unsigned __int8 *)(a1 + 463);
    }
    else {
      uint64_t v17 = *(void *)(a1 + 448);
    }
    if (v17 == size)
    {
      long long v18 = (const void **)(a1 + 440);
      if (v5 >= 0) {
        char v19 = a2;
      }
      else {
        char v19 = (std::string *)a2->__r_.__value_.__r.__words[0];
      }
      if ((v16 & 0x80) == 0)
      {
        if (*(unsigned char *)(a1 + 463))
        {
          while (*(unsigned __int8 *)v18 == v19->__r_.__value_.__s.__data_[0])
          {
            long long v18 = (const void **)((char *)v18 + 1);
            char v19 = (std::string *)((char *)v19 + 1);
            if (!--v16) {
              goto LABEL_59;
            }
          }
          goto LABEL_58;
        }
LABEL_59:
        uint64_t v28 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            unint64_t v29 = a2;
          }
          else {
            unint64_t v29 = (std::string *)a2->__r_.__value_.__r.__words[0];
          }
          int v30 = 136315138;
          v31[0] = v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I setting placeholder active user data %s", (uint8_t *)&v30, 0xCu);
        }
        std::string::operator=((std::string *)(a1 + 696), a2);
        return;
      }
      if (!memcmp(*v18, v19, *(void *)(a1 + 448))) {
        goto LABEL_59;
      }
    }
LABEL_58:
    if (sub_10010E128(a1 + 792, (void **)&a2->__r_.__value_.__l.__data_)) {
      goto LABEL_59;
    }
    unint64_t v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(v30) = 0;
    uint64_t v9 = "Invalid active user data selection - leaving unchanged";
    goto LABEL_12;
  }
  uint64_t v20 = sub_10010E128(a1 + 792, (void **)&a2->__r_.__value_.__l.__data_);
  uint64_t v21 = *(NSObject **)(a1 + 40);
  if (!v20)
  {
    if (!os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR)) {
      return;
    }
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v27 = a2;
    }
    else {
      uint64_t v27 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    int v30 = 136315138;
    v31[0] = v27;
    uint64_t v9 = "ICCID (%s) is not enabled";
    uint64_t v10 = v21;
    uint32_t v11 = 12;
LABEL_13:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v30, v11);
    return;
  }
  if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v22 = a2;
    }
    else {
      uint64_t v22 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    int v30 = 136315138;
    v31[0] = v22;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Setting user data selection (%s)", (uint8_t *)&v30, 0xCu);
  }
  std::string::operator=((std::string *)(a1 + 872), a2);
  sub_100CA4DAC(a1);
  uint64_t v23 = *(std::__shared_weak_count **)(a1 + 80);
  if (v23)
  {
    uint64_t v24 = std::__shared_weak_count::lock(v23);
    if (v24)
    {
      BOOL v25 = v24;
      uint64_t v26 = *(void *)(a1 + 72);
      if (v26)
      {
        *(_DWORD *)(a1 + 896) = sub_100CA8388((void *)a1, (unsigned __int8 *)(a1 + 872));
        sub_100CA8010((uint64_t *)&v30, a1);
        (*(void (**)(uint64_t, int *, uint64_t))(*(void *)v26 + 160))(v26, &v30, a1 + 872);
        sub_10005CD2C((uint64_t)&v30, *(char **)((char *)v31 + 4));
        (*(void (**)(uint64_t))(*(void *)v26 + 40))(v26);
      }
      sub_10004D2C8(v25);
    }
  }
}

void sub_100CB2D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10)
{
  sub_10005CD2C((uint64_t)&a9, a10);
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100CB2DC4(void *a1)
{
  for (uint64_t i = a1[17]; ; i += 88)
  {
    if (i == a1[18])
    {
      uint64_t v5 = a1[20];
      uint64_t v6 = a1[21];
      while (1)
      {
        if (v5 == v6) {
          return 1;
        }
        uint64_t v7 = (void **)(v5 + 72);
        if (*(char *)(v5 + 95) < 0)
        {
          unint64_t v9 = *(void *)(v5 + 80);
          if (!v9) {
            goto LABEL_21;
          }
          sub_10004FC84(__p, *v7, v9);
        }
        else
        {
          if (!*(unsigned char *)(v5 + 95)) {
            goto LABEL_21;
          }
          long long v8 = *(_OWORD *)v7;
          uint64_t v14 = *(void *)(v5 + 88);
          *(_OWORD *)long long __p = v8;
        }
        int v10 = sub_100CA6C24((uint64_t)a1, (uint64_t)__p);
        char v11 = v10;
        if (SHIBYTE(v14) < 0)
        {
          operator delete(__p[0]);
          if ((v11 & 1) == 0) {
            return 0;
          }
        }
        else if (!v10)
        {
          return 0;
        }
LABEL_21:
        v5 += 168;
      }
    }
    if (*(unsigned char *)(i + 80))
    {
      uint64_t v3 = *(void *)(i + 56);
      uint64_t v4 = *(void *)(i + 64);
      if (v3 != v4)
      {
        while (*(unsigned char *)(v3 + 88))
        {
          v3 += 216;
          if (v3 == v4) {
            goto LABEL_9;
          }
        }
      }
      if (v3 != v4) {
        break;
      }
    }
LABEL_9:
    ;
  }
  return 0;
}

void sub_100CB2EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CB2EDC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  uint64_t v2 = *(void **)(a1 + 264);
  uint64_t v3 = (void *)(a1 + 272);
  if (v2 != (void *)(a1 + 272))
  {
    uint64_t v4 = &v46;
    do
    {
      bzero(__dst, 0x238uLL);
      if (*((char *)v2 + 55) < 0)
      {
        sub_10004FC84(__dst, (void *)v2[4], v2[5]);
      }
      else
      {
        *(_OWORD *)long long __dst = *((_OWORD *)v2 + 2);
        uint64_t v32 = v2[6];
      }
      if (*((char *)v2 + 79) < 0)
      {
        sub_10004FC84(&v33, (void *)v2[7], v2[8]);
      }
      else
      {
        long long v33 = *(_OWORD *)(v2 + 7);
        uint64_t v34 = v2[9];
      }
      if (*((char *)v2 + 103) < 0)
      {
        sub_10004FC84(&v35, (void *)v2[10], v2[11]);
      }
      else
      {
        long long v35 = *((_OWORD *)v2 + 5);
        uint64_t v36 = v2[12];
      }
      if (*((char *)v2 + 127) < 0)
      {
        sub_10004FC84(&v37, (void *)v2[13], v2[14]);
      }
      else
      {
        long long v37 = *(_OWORD *)(v2 + 13);
        uint64_t v38 = v2[15];
      }
      if (*((char *)v2 + 151) < 0)
      {
        sub_10004FC84(&v39, (void *)v2[16], v2[17]);
      }
      else
      {
        long long v39 = *((_OWORD *)v2 + 8);
        uint64_t v40 = v2[18];
      }
      if (*((char *)v2 + 175) < 0)
      {
        sub_10004FC84(&v41, (void *)v2[19], v2[20]);
      }
      else
      {
        long long v41 = *(_OWORD *)(v2 + 19);
        uint64_t v42 = v2[21];
      }
      v43[0] = v2[22];
      *(void *)((char *)v43 + 6) = *(void *)((char *)v2 + 182);
      v44[0] = 0;
      char v45 = 0;
      if (*((unsigned char *)v2 + 392))
      {
        sub_10030FB14((uint64_t)v44, (uint64_t)(v2 + 24));
        char v45 = 1;
      }
      sub_100CC26CC(v4, (uint64_t)(v2 + 50));
      uint64_t v5 = HIBYTE(v36);
      char v6 = HIBYTE(v36);
      if (v36 < 0) {
        uint64_t v5 = *((void *)&v35 + 1);
      }
      if (v5)
      {
        uint64_t v7 = HIBYTE(v38);
        if (v38 < 0) {
          uint64_t v7 = *((void *)&v37 + 1);
        }
        if (v7)
        {
          if (SHIBYTE(v32) < 0)
          {
            sub_10004FC84(v20, __dst[0], (unint64_t)__dst[1]);
            char v6 = HIBYTE(v36);
          }
          else
          {
            *(_OWORD *)uint64_t v20 = *(_OWORD *)__dst;
            uint64_t v21 = v32;
          }
          char v22 = 1;
          if (v6 < 0)
          {
            sub_10004FC84(&v23, (void *)v35, *((unint64_t *)&v35 + 1));
          }
          else
          {
            long long v23 = v35;
            uint64_t v24 = v36;
          }
          if (SHIBYTE(v38) < 0)
          {
            sub_10004FC84(&v25, (void *)v37, *((unint64_t *)&v37 + 1));
          }
          else
          {
            long long v25 = v37;
            uint64_t v26 = v38;
          }
          if (SHIBYTE(v40) < 0)
          {
            sub_10004FC84(&__p, (void *)v39, *((unint64_t *)&v39 + 1));
          }
          else
          {
            long long __p = v39;
            uint64_t v28 = v40;
          }
          if (SHIBYTE(v42) < 0)
          {
            sub_10004FC84(&v29, (void *)v41, *((unint64_t *)&v41 + 1));
          }
          else
          {
            long long v29 = v41;
            uint64_t v30 = v42;
          }
          long long v8 = v4;
          long long v47 = __dst;
          unint64_t v9 = sub_10086299C((uint64_t **)a2, __dst, (uint64_t)&unk_10144E20E, (long long **)&v47);
          int v10 = v3;
          sub_100179CB0((uint64_t)(v9 + 7), (__n128 *)v20);
          char v11 = (void **)(v9 + 11);
          if (*((char *)v9 + 111) < 0) {
            operator delete(*v11);
          }
          v9[13] = v24;
          *(_OWORD *)char v11 = v23;
          HIBYTE(v24) = 0;
          LOBYTE(v23) = 0;
          uint64_t v12 = (void **)(v9 + 14);
          if (*((char *)v9 + 135) < 0) {
            operator delete(*v12);
          }
          uint8_t v9[16] = v26;
          *(_OWORD *)uint64_t v12 = v25;
          HIBYTE(v26) = 0;
          LOBYTE(v25) = 0;
          uint64_t v13 = (void **)(v9 + 17);
          if (*((char *)v9 + 159) < 0) {
            operator delete(*v13);
          }
          v9[19] = v28;
          *(_OWORD *)uint64_t v13 = __p;
          HIBYTE(v28) = 0;
          LOBYTE(__p) = 0;
          uint64_t v14 = (void **)(v9 + 20);
          if (*((char *)v9 + 183) < 0)
          {
            operator delete(*v14);
            int v15 = SHIBYTE(v28);
            *(_OWORD *)uint64_t v14 = v29;
            v9[22] = v30;
            HIBYTE(v30) = 0;
            LOBYTE(v29) = 0;
            if (v15 < 0) {
              operator delete((void *)__p);
            }
          }
          else
          {
            *(_OWORD *)uint64_t v14 = v29;
            v9[22] = v30;
            HIBYTE(v30) = 0;
            LOBYTE(v29) = 0;
          }
          uint64_t v3 = v10;
          if (SHIBYTE(v26) < 0) {
            operator delete((void *)v25);
          }
          uint64_t v4 = v8;
          if (SHIBYTE(v24) < 0) {
            operator delete((void *)v23);
          }
          if (v22 && SHIBYTE(v21) < 0) {
            operator delete(v20[0]);
          }
        }
      }
      sub_100CC272C((uint64_t)&v33);
      if (SHIBYTE(v32) < 0) {
        operator delete(__dst[0]);
      }
      uint64_t v16 = (void *)v2[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (void *)v2[2];
          BOOL v18 = *v17 == (void)v2;
          uint64_t v2 = v17;
        }
        while (!v18);
      }
      uint64_t v2 = v17;
    }
    while (v17 != v3);
  }
}

void sub_100CB33A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a23)
  {
    if (a22 < 0) {
      operator delete(a17);
    }
  }
  sub_100CB34E8((uint64_t)&a45);
  sub_10010E37C(a12, *(void **)(a12 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100CB34E8(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100CB3524(void *a1, int a2, int a3)
{
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  sub_100CAF5D8(a1, a2, (uint64_t)__p);
  if (BYTE8(v6))
  {
    sub_100CB2988((uint64_t)a1, (std::string *)__p, a3);
    if (BYTE8(v6))
    {
      if (SBYTE7(v6) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_100CB3590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100CB35B4(capabilities::ct *a1, std::string *a2, int a3)
{
  uint64_t v4 = (uint64_t)a1;
  if (a3) {
    a1 = (capabilities::ct *)sub_100CA88D4((uint64_t)a1);
  }
  if ((capabilities::ct::supportsVoiceCall(a1) & 1) == 0)
  {
    char v11 = *(NSObject **)(v4 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(v22) = 0;
    uint64_t v12 = "Voice not supported";
LABEL_25:
    uint64_t v13 = v11;
    uint32_t v14 = 2;
    goto LABEL_26;
  }
  int v5 = SHIBYTE(a2->__r_.__value_.__r.__words[2]);
  if (v5 >= 0) {
    std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = a2->__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    char v11 = *(NSObject **)(v4 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(v22) = 0;
    uint64_t v12 = "Default voice selection iccid is empty";
    goto LABEL_25;
  }
  uint64_t v7 = *(unsigned __int8 *)(v4 + 863);
  if ((v7 & 0x80u) == 0) {
    uint64_t v8 = *(unsigned __int8 *)(v4 + 863);
  }
  else {
    uint64_t v8 = *(void *)(v4 + 848);
  }
  if (v8 == size)
  {
    if (v5 >= 0) {
      unint64_t v9 = a2;
    }
    else {
      unint64_t v9 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    if ((v7 & 0x80) != 0)
    {
      if (!memcmp(*(const void **)(v4 + 840), v9, *(void *)(v4 + 848))) {
        return;
      }
    }
    else
    {
      if (!*(unsigned char *)(v4 + 863)) {
        return;
      }
      for (uint64_t i = (unsigned __int8 *)(v4 + 840); *i == v9->__r_.__value_.__s.__data_[0]; ++i)
      {
        unint64_t v9 = (std::string *)((char *)v9 + 1);
        if (!--v7) {
          return;
        }
      }
    }
  }
  if (*(unsigned char *)(v4 + 752))
  {
    uint64_t v15 = *(unsigned __int8 *)(v4 + 463);
    uint64_t v16 = (v15 & 0x80u) == 0 ? *(unsigned __int8 *)(v4 + 463) : *(void *)(v4 + 448);
    if (v16 == size)
    {
      uint64_t v17 = (const void **)(v4 + 440);
      if (v5 >= 0) {
        BOOL v18 = a2;
      }
      else {
        BOOL v18 = (std::string *)a2->__r_.__value_.__r.__words[0];
      }
      if ((v15 & 0x80) != 0)
      {
        if (memcmp(*v17, v18, *(void *)(v4 + 448))) {
          goto LABEL_42;
        }
      }
      else if (*(unsigned char *)(v4 + 463))
      {
        while (*(unsigned __int8 *)v17 == v18->__r_.__value_.__s.__data_[0])
        {
          uint64_t v17 = (const void **)((char *)v17 + 1);
          BOOL v18 = (std::string *)((char *)v18 + 1);
          if (!--v15) {
            goto LABEL_51;
          }
        }
        goto LABEL_42;
      }
LABEL_51:
      *(unsigned char *)(v4 + 720) = 1;
      uint64_t v21 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v22) = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I setting placeholder default voice", (uint8_t *)&v22, 2u);
      }
      return;
    }
  }
LABEL_42:
  if (!sub_10010E128(v4 + 792, (void **)&a2->__r_.__value_.__l.__data_))
  {
    char v19 = *(NSObject **)(v4 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v20 = a2;
    }
    else {
      uint64_t v20 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    int v22 = 136315138;
    long long v23 = v20;
    uint64_t v12 = "ICCID (%s) is not enabled";
    uint64_t v13 = v19;
    uint32_t v14 = 12;
LABEL_26:
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v22, v14);
    return;
  }
  std::string::operator=((std::string *)(v4 + 840), a2);
  *(_DWORD *)(v4 + 864) = 0;
  sub_100CA4DAC(v4);

  sub_100CB3890(v4);
}

void sub_100CB3890(uint64_t a1)
{
  if (*(char *)(a1 + 863) < 0)
  {
    unint64_t v5 = *(void *)(a1 + 848);
    if (!v5) {
      return;
    }
    uint64_t v3 = (int **)(a1 + 168);
    uint64_t v2 = *(int **)(a1 + 168);
    uint64_t v4 = *(void *)(a1 + 160);
    sub_10004FC84(__p, *(void **)(a1 + 840), v5);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 863)) {
      return;
    }
    uint64_t v3 = (int **)(a1 + 168);
    uint64_t v2 = *(int **)(a1 + 168);
    uint64_t v4 = *(void *)(a1 + 160);
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 840);
    uint64_t v18 = *(void *)(a1 + 856);
  }
  char v6 = HIBYTE(v18);
  if ((int *)v4 == v2) {
    goto LABEL_27;
  }
  if (v18 >= 0) {
    uint64_t v7 = (void *)HIBYTE(v18);
  }
  else {
    uint64_t v7 = __p[1];
  }
  if (v18 >= 0) {
    uint64_t v8 = __p;
  }
  else {
    uint64_t v8 = (void **)__p[0];
  }
  while (1)
  {
    uint64_t v9 = *(unsigned __int8 *)(v4 + 95);
    if ((v9 & 0x80u) == 0) {
      int v10 = (void *)*(unsigned __int8 *)(v4 + 95);
    }
    else {
      int v10 = *(void **)(v4 + 80);
    }
    if (v10 != v7) {
      goto LABEL_24;
    }
    if ((v9 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v4 + 95)) {
      goto LABEL_26;
    }
    uint64_t v11 = 0;
    while (*(unsigned __int8 *)(v4 + v11 + 72) == *((unsigned __int8 *)v8 + v11))
    {
      if (v9 == ++v11) {
        goto LABEL_26;
      }
    }
LABEL_24:
    v4 += 168;
    if ((int *)v4 == v2) {
      goto LABEL_27;
    }
  }
  if (memcmp(*(const void **)(v4 + 72), v8, *(void *)(v4 + 80))) {
    goto LABEL_24;
  }
LABEL_26:
  uint64_t v2 = (int *)v4;
LABEL_27:
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v2 != *v3)
  {
    int v12 = *v2;
    if (*(_DWORD *)(a1 + 864) != *v2)
    {
      *(_DWORD *)(a1 + 864) = v12;
      if (v12)
      {
        uint64_t v13 = *(std::__shared_weak_count **)(a1 + 80);
        if (v13)
        {
          uint32_t v14 = std::__shared_weak_count::lock(v13);
          if (v14)
          {
            uint64_t v15 = v14;
            uint64_t v16 = *(void *)(a1 + 72);
            if (v16) {
              (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 48))(v16, a1 + 864);
            }
            sub_10004D2C8(v15);
          }
        }
      }
    }
  }
}

void sub_100CB3A34(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100CB3A48(capabilities::ct *a1, int a2, int a3)
{
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  sub_100CAF5D8(a1, a2, (uint64_t)__p);
  if (BYTE8(v6))
  {
    sub_100CB35B4(a1, (std::string *)__p, a3);
    if (BYTE8(v6))
    {
      if (SBYTE7(v6) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_100CB3AB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100CB3AD8(uint64_t a1, unsigned __int8 **a2)
{
  if (*(unsigned __int8 **)(a1 + 968) == a2[2])
  {
    uint64_t v4 = *(unsigned __int8 **)(a1 + 952);
    uint64_t v5 = a1 + 960;
    if (v4 == (unsigned __int8 *)(a1 + 960)) {
      return 1;
    }
    long long v6 = *a2;
    while ((sub_1000609C0((uint64_t)&v19, v4 + 32, v6 + 32) & 1) != 0)
    {
      uint64_t v7 = (unsigned __int8 *)*((void *)v4 + 1);
      uint64_t v8 = v4;
      if (v7)
      {
        do
        {
          uint64_t v4 = v7;
          uint64_t v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v4 = (unsigned __int8 *)*((void *)v8 + 2);
          BOOL v9 = *(void *)v4 == (void)v8;
          uint64_t v8 = v4;
        }
        while (!v9);
      }
      int v10 = (unsigned __int8 *)*((void *)v6 + 1);
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          int v10 = *(unsigned __int8 **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (unsigned __int8 *)*((void *)v6 + 2);
          BOOL v9 = *(void *)v11 == (void)v6;
          long long v6 = v11;
        }
        while (!v9);
      }
      long long v6 = v11;
      if (v4 == (unsigned __int8 *)v5) {
        return 1;
      }
    }
  }
  int v12 = *a2;
  if (*a2 == (unsigned __int8 *)(a2 + 1))
  {
LABEL_28:
    if ((unsigned __int8 **)(a1 + 952) != a2) {
      sub_1000EA390((uint64_t **)(a1 + 952), *a2, a2 + 1);
    }
    sub_100CB3DD4(a1);
    return 1;
  }
  while (1)
  {
    uint64_t v13 = v12 + 32;
    if (sub_100CB3D28(a1, v12 + 32))
    {
      uint32_t v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v19) = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Wait for provisioning to complete", (uint8_t *)&v19, 2u);
      }
      goto LABEL_22;
    }
    if ((sub_100CBFD40((unsigned __int8 **)v12 + 4, *(void *)(a1 + 160), *(void *)(a1 + 168)) & 1) == 0) {
      break;
    }
LABEL_22:
    uint64_t v15 = (unsigned __int8 *)*((void *)v12 + 1);
    if (v15)
    {
      do
      {
        uint64_t v16 = v15;
        uint64_t v15 = *(unsigned __int8 **)v15;
      }
      while (v15);
    }
    else
    {
      do
      {
        uint64_t v16 = (unsigned __int8 *)*((void *)v12 + 2);
        BOOL v9 = *(void *)v16 == (void)v12;
        int v12 = v16;
      }
      while (!v9);
    }
    int v12 = v16;
    if (v16 == (unsigned __int8 *)(a2 + 1)) {
      goto LABEL_28;
    }
  }
  uint64_t v18 = *(NSObject **)(a1 + 40);
  BOOL result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
  if (result)
  {
    if ((char)v12[55] < 0) {
      uint64_t v13 = (void *)*v13;
    }
    int v19 = 136315138;
    uint64_t v20 = v13;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "ICCID (%s) does not exist", (uint8_t *)&v19, 0xCu);
    return 0;
  }
  return result;
}

uint64_t sub_100CB3D28(uint64_t a1, unsigned __int8 *a2)
{
  if (!*(unsigned char *)(a1 + 752)) {
    return 0;
  }
  uint64_t v2 = *(unsigned __int8 *)(a1 + 463);
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 463);
  }
  else {
    uint64_t v3 = *(void *)(a1 + 448);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  long long v6 = (const void **)(a1 + 440);
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*v6, a2, *(void *)(a1 + 448)) == 0;
  }
  if (!*(unsigned char *)(a1 + 463)) {
    return 1;
  }
  uint64_t v7 = v2 - 1;
  do
  {
    int v9 = *(unsigned __int8 *)v6;
    long long v6 = (const void **)((char *)v6 + 1);
    int v8 = v9;
    int v11 = *a2++;
    int v10 = v11;
    BOOL v13 = v7-- != 0;
    uint64_t result = v8 == v10;
  }
  while (v8 == v10 && v13);
  return result;
}

void sub_100CB3DD4(uint64_t a1)
{
  if (!*(void *)(a1 + 968)) {
    return;
  }
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  long long v37 = &v38;
  (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)buf);
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    long long v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (!v9)
  {
    uint64_t v10 = 0;
    goto LABEL_9;
  }
  uint64_t v10 = v9[3];
  int v11 = (std::__shared_weak_count *)v9[4];
  if (!v11)
  {
LABEL_9:
    std::mutex::unlock(v4);
    int v11 = 0;
    char v36 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v36 = 0;
LABEL_10:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  long long v35 = v11;
  int v12 = *(void **)(a1 + 952);
  BOOL v13 = (void *)(a1 + 960);
  if (v12 == (void *)(a1 + 960))
  {
LABEL_65:
    if (v39 == *(void *)(a1 + 968))
    {
      long long v29 = *(std::__shared_weak_count **)(a1 + 80);
      if (v29)
      {
        uint64_t v30 = std::__shared_weak_count::lock(v29);
        if (v30)
        {
          uint64_t v31 = v30;
          uint64_t v32 = *(void *)(a1 + 72);
          if (v32)
          {
            long long v33 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              sub_1000E8F34(*(std::string **)(a1 + 952), (std::string *)(a1 + 960), ",", 1uLL, (std::string *)buf);
              uint64_t v34 = SHIBYTE(v43[0]) >= 0 ? buf : *(uint8_t **)buf;
              LODWORD(__p[0]) = 136315138;
              *(void **)((char *)__p + 4) = v34;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Applying user selected iMessage iccids: [%s]", (uint8_t *)__p, 0xCu);
              if (SHIBYTE(v43[0]) < 0) {
                operator delete(*(void **)buf);
              }
            }
            (*(void (**)(uint64_t, char ***))(*(void *)v32 + 56))(v32, &v37);
          }
          sub_10004D2C8(v31);
        }
      }
      sub_10005CD2C(a1 + 952, *(char **)(a1 + 960));
      *(void *)(a1 + 952) = v13;
      *(_OWORD *)(a1 + 960) = 0u;
    }
    goto LABEL_78;
  }
LABEL_13:
  uint32_t v14 = (const void **)(v12 + 4);
  uint64_t v16 = *(void *)(a1 + 160);
  uint64_t v15 = *(void *)(a1 + 168);
  if (v16 != v15)
  {
    int v17 = *((char *)v12 + 55);
    if (v17 >= 0) {
      uint64_t v18 = *((unsigned __int8 *)v12 + 55);
    }
    else {
      uint64_t v18 = v12[5];
    }
    do
    {
      uint64_t v19 = *(unsigned __int8 *)(v16 + 95);
      if ((v19 & 0x80u) == 0) {
        uint64_t v20 = *(unsigned __int8 *)(v16 + 95);
      }
      else {
        uint64_t v20 = *(void *)(v16 + 80);
      }
      if (v20 == v18)
      {
        if (v17 >= 0) {
          uint64_t v21 = (const void **)(v12 + 4);
        }
        else {
          uint64_t v21 = (const void **)*v14;
        }
        if ((v19 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v16 + 72), v21, *(void *)(v16 + 80)))
          {
LABEL_33:
            uint64_t v48 = 0;
            long long v46 = 0u;
            *(_OWORD *)long long v47 = 0u;
            long long v44 = 0u;
            *(_OWORD *)char v45 = 0u;
            *(_OWORD *)long long buf = 0u;
            *(_OWORD *)unint64_t v43 = 0u;
            if (*((char *)v12 + 55) < 0)
            {
              sub_10004FC84(__p, (void *)v12[4], v12[5]);
            }
            else
            {
              *(_OWORD *)long long __p = *(_OWORD *)v14;
              uint64_t v41 = v12[6];
            }
            (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v10 + 176))(buf, v10, __p);
            if (SHIBYTE(v41) < 0) {
              operator delete(__p[0]);
            }
            long long v23 = (void *)BYTE7(v46);
            if (SBYTE7(v46) < 0) {
              long long v23 = v45[1];
            }
            if (v23)
            {
              sub_1000F29CC((uint64_t **)&v37, v45, (uint64_t)v45);
            }
            else
            {
              uint64_t v24 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              {
                if (*((char *)v12 + 55) < 0) {
                  uint32_t v14 = (const void **)*v14;
                }
                LODWORD(__p[0]) = 136315138;
                *(void **)((char *)__p + 4) = v14;
                _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "invalid label for : %s", (uint8_t *)__p, 0xCu);
              }
            }
            if (SHIBYTE(v48) < 0) {
              operator delete(v47[0]);
            }
            if (SBYTE7(v46) < 0) {
              operator delete(v45[0]);
            }
            if (SHIBYTE(v44) < 0) {
              operator delete(v43[1]);
            }
            if (SHIBYTE(v43[0]) < 0) {
              operator delete(*(void **)buf);
            }
            long long v25 = (void *)v12[1];
            if (v25)
            {
              do
              {
                uint64_t v26 = v25;
                long long v25 = (void *)*v25;
              }
              while (v25);
            }
            else
            {
              do
              {
                uint64_t v26 = (void *)v12[2];
                BOOL v27 = *v26 == (void)v12;
                int v12 = v26;
              }
              while (!v27);
            }
            int v12 = v26;
            if (v26 == v13) {
              goto LABEL_65;
            }
            goto LABEL_13;
          }
        }
        else
        {
          if (!*(unsigned char *)(v16 + 95)) {
            goto LABEL_33;
          }
          uint64_t v22 = 0;
          while (*(unsigned __int8 *)(v16 + v22 + 72) == *((unsigned __int8 *)v21 + v22))
          {
            if (v19 == ++v22) {
              goto LABEL_33;
            }
          }
        }
      }
      v16 += 168;
    }
    while (v16 != v15);
  }
  uint64_t v28 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)v12 + 55) < 0) {
      uint32_t v14 = (const void **)*v14;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v14;
    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "iMessage selected plan [%s] is not active", buf, 0xCu);
  }
LABEL_78:
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v35);
  }
  sub_10005CD2C((uint64_t)&v37, v38);
}

void sub_100CB42E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, int a13, char a14, char a15, char *a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,uint64_t a26)
{
  sub_10004D2C8(v26);
  if ((a14 & 1) == 0) {
    sub_10004D2C8(a12);
  }
  sub_10005CD2C((uint64_t)&a15, a16);
  _Unwind_Resume(a1);
}

void sub_100CB436C(uint64_t a1, long long *a2)
{
  uint64_t v2 = a2;
  if (*(unsigned char *)(a1 + 752))
  {
    uint64_t v4 = (uint64_t *)(a1 + 728);
    unint64_t v5 = *(void *)(a1 + 736);
    if (v5 >= *(void *)(a1 + 744))
    {
      uint64_t v6 = sub_1000D8CE8(v4, a2);
    }
    else
    {
      sub_10030BFC4(v4, a2);
      uint64_t v6 = v5 + 24;
    }
    *(void *)(a1 + 736) = v6;
    unsigned int v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)v2 + 23) < 0) {
        uint64_t v2 = *(long long **)v2;
      }
      int v9 = 136315138;
      uint64_t v10 = v2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Adding remap from iccid: %s", (uint8_t *)&v9, 0xCu);
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)v2 + 23) < 0) {
        uint64_t v2 = *(long long **)v2;
      }
      int v9 = 136315138;
      uint64_t v10 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No Placeholder when attempting remap for: %s", (uint8_t *)&v9, 0xCu);
    }
  }
}

void sub_100CB44AC(uint64_t a1, std::string *a2, const std::string *a3)
{
  if ((sub_100CBFD40((unsigned __int8 **)a2, *(void *)(a1 + 160), *(void *)(a1 + 168)) & 1) == 0)
  {
    uint32_t v14 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v15 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v15 = (unsigned __int8 *)a2->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    uint64_t v16 = "Cannot set system selection, ICCID (%s) does not exist";
    int v17 = v14;
    uint32_t v18 = 12;
    goto LABEL_54;
  }
  int v6 = SHIBYTE(a3->__r_.__value_.__r.__words[2]);
  if (v6 >= 0) {
    size_t size = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  }
  else {
    size_t size = a3->__r_.__value_.__l.__size_;
  }
  uint64_t v8 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  int v9 = (char)v8;
  if (size)
  {
    std::string::size_type v10 = a2->__r_.__value_.__l.__size_;
    if ((v8 & 0x80u) == 0) {
      std::string::size_type v11 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v11 = a2->__r_.__value_.__l.__size_;
    }
    if (v11 != size)
    {
LABEL_46:
      long long v29 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        return;
      }
      if (v9 >= 0) {
        uint64_t v30 = (unsigned __int8 *)a2;
      }
      else {
        uint64_t v30 = (unsigned __int8 *)a2->__r_.__value_.__r.__words[0];
      }
      if (v6 >= 0) {
        int v12 = a3;
      }
      else {
        int v12 = (const std::string *)a3->__r_.__value_.__r.__words[0];
      }
LABEL_53:
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v30;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v12;
      uint64_t v16 = "Invalid system selection - system data ICCID (%s) must match system selected ICCID (%s)";
      int v17 = v29;
      uint32_t v18 = 22;
LABEL_54:
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
      return;
    }
    if (v6 >= 0) {
      int v12 = a3;
    }
    else {
      int v12 = (const std::string *)a3->__r_.__value_.__r.__words[0];
    }
    if ((char)v8 < 0)
    {
      uint64_t v30 = (unsigned __int8 *)a2->__r_.__value_.__r.__words[0];
      if (memcmp(a2->__r_.__value_.__l.__data_, v12, a2->__r_.__value_.__l.__size_))
      {
        long long v29 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          return;
        }
        goto LABEL_53;
      }
    }
    else if ((_BYTE)v8)
    {
      BOOL v13 = a2;
      while (v13->__r_.__value_.__s.__data_[0] == v12->__r_.__value_.__s.__data_[0])
      {
        BOOL v13 = (std::string *)((char *)v13 + 1);
        int v12 = (const std::string *)((char *)v12 + 1);
        if (!--v8) {
          goto LABEL_25;
        }
      }
      goto LABEL_46;
    }
  }
  else
  {
    std::string::size_type v10 = a2->__r_.__value_.__l.__size_;
  }
LABEL_25:
  uint64_t v53 = (std::string *)(a1 + 904);
  uint64_t v19 = *(unsigned __int8 *)(a1 + 927);
  uint64_t v20 = *(void *)(a1 + 912);
  if ((v19 & 0x80u) == 0) {
    uint64_t v21 = *(unsigned __int8 *)(a1 + 927);
  }
  else {
    uint64_t v21 = *(void *)(a1 + 912);
  }
  std::string::size_type v22 = v9;
  if (v9 < 0) {
    std::string::size_type v22 = v10;
  }
  if (v21 != v22)
  {
LABEL_64:
    long long v33 = *(NSObject **)(a1 + 40);
    uint64_t v34 = (std::string *)(a1 + 904);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_71;
    }
    if ((v19 & 0x80) != 0)
    {
      long long v35 = (std::string *)v53->__r_.__value_.__r.__words[0];
      goto LABEL_68;
    }
LABEL_66:
    long long v35 = v34;
LABEL_68:
    char v36 = (unsigned __int8 *)a2->__r_.__value_.__r.__words[0];
    if (v9 >= 0) {
      char v36 = (unsigned __int8 *)a2;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v35;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v36;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Updating system selection (%s) -> (%s)", buf, 0x16u);
    goto LABEL_71;
  }
  if (v9 >= 0) {
    long long v23 = (unsigned __int8 *)a2;
  }
  else {
    long long v23 = (unsigned __int8 *)a2->__r_.__value_.__r.__words[0];
  }
  if ((v19 & 0x80) != 0)
  {
    uint64_t v31 = (const void *)v53->__r_.__value_.__r.__words[0];
    if (!memcmp(v53->__r_.__value_.__l.__data_, v23, *(void *)(a1 + 912)) && v20 == size)
    {
      uint64_t v32 = v6 >= 0 ? (unsigned __int8 *)a3 : (unsigned __int8 *)a3->__r_.__value_.__r.__words[0];
      if (!memcmp(v31, v32, size)) {
        return;
      }
    }
    goto LABEL_64;
  }
  if (*(unsigned char *)(a1 + 927))
  {
    uint64_t v24 = (unsigned __int8 *)(a1 + 904);
    uint64_t v25 = *(unsigned __int8 *)(a1 + 927);
    while (*v24 == *v23)
    {
      ++v24;
      ++v23;
      if (!--v25)
      {
        if (v21 == size)
        {
          uint64_t v26 = (const std::string *)a3->__r_.__value_.__r.__words[0];
          if (v6 >= 0) {
            uint64_t v26 = a3;
          }
          BOOL v27 = (unsigned __int8 *)(a1 + 904);
          uint64_t v28 = *(unsigned __int8 *)(a1 + 927);
          while (*v27 == v26->__r_.__value_.__s.__data_[0])
          {
            ++v27;
            uint64_t v26 = (const std::string *)((char *)v26 + 1);
            if (!--v28) {
              return;
            }
          }
        }
        goto LABEL_64;
      }
    }
    goto LABEL_64;
  }
  if (size == v19) {
    return;
  }
  long long v33 = *(NSObject **)(a1 + 40);
  uint64_t v34 = (std::string *)(a1 + 904);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_66;
  }
LABEL_71:
  std::string::operator=(v34, a2);
  std::string::operator=((std::string *)(a1 + 928), a3);
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  memset(buf, 0, sizeof(buf));
  sGetProfileDetails();
  if (BYTE8(v71)) {
    BOOL v37 = BYTE8(v63) == 0;
  }
  else {
    BOOL v37 = 1;
  }
  unsigned __int8 v38 = !v37;
  atomic_store(v38, (unsigned __int8 *)(a1 + 784));
  uint64_t v39 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v39) {
    goto LABEL_124;
  }
  uint64_t v40 = std::__shared_weak_count::lock(v39);
  if (!v40) {
    goto LABEL_124;
  }
  uint64_t v41 = v40;
  uint64_t v42 = *(void *)(a1 + 72);
  if (!v42) {
    goto LABEL_123;
  }
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v58 = 0;
  if (*(char *)(a1 + 951) < 0) {
    uint64_t v43 = *(void *)(a1 + 936);
  }
  else {
    uint64_t v43 = *(unsigned __int8 *)(a1 + 951);
  }
  if (v43) {
    uint64_t v44 = a1 + 928;
  }
  else {
    uint64_t v44 = a1 + 872;
  }
  if (*(char *)(v44 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)v44, *(void *)(v44 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v44;
    uint64_t v58 = *(void *)(v44 + 16);
  }
  *(_DWORD *)(a1 + 896) = sub_100CA8388((void *)a1, (unsigned __int8 *)__dst);
  sub_100CB0970(a1, 1, (uint64_t *)__p);
  (*(void (**)(uint64_t, void **, void **))(*(void *)v42 + 160))(v42, __p, __dst);
  sub_10005CD2C((uint64_t)__p, (char *)__p[1]);
  sub_100CB4B88((void *)a1);
  if ((*(char *)(a1 + 927) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a1 + 927)) {
      goto LABEL_94;
    }
LABEL_117:
    sub_100CB4F1C((uint64_t)v56, a1);
    sub_100CB545C((uint64_t)__p, a1);
    (*(void (**)(uint64_t, unsigned char *, void **))(*(void *)v42 + 80))(v42, v56, __p);
    if (v55 < 0) {
      operator delete(__p[0]);
    }
    if (v56[24])
    {
      __p[0] = v56;
      sub_100047F64((void ***)__p);
    }
    goto LABEL_121;
  }
  if (!*(void *)(a1 + 912)) {
    goto LABEL_117;
  }
LABEL_94:
  uint64_t v45 = *(void *)(a1 + 160);
  uint64_t v46 = *(void *)(a1 + 168);
  if (v45 == v46) {
    goto LABEL_121;
  }
  do
  {
    uint64_t v47 = *(unsigned __int8 *)(v45 + 95);
    if ((v47 & 0x80u) == 0) {
      uint64_t v48 = *(unsigned __int8 *)(v45 + 95);
    }
    else {
      uint64_t v48 = *(void *)(v45 + 80);
    }
    uint64_t v49 = *(unsigned __int8 *)(a1 + 927);
    int v50 = (char)v49;
    if ((v49 & 0x80u) != 0) {
      uint64_t v49 = *(void *)(a1 + 912);
    }
    if (v48 != v49) {
      goto LABEL_112;
    }
    if (v50 >= 0) {
      uint64_t v51 = v34;
    }
    else {
      uint64_t v51 = (std::string *)v34->__r_.__value_.__r.__words[0];
    }
    if ((v47 & 0x80) != 0)
    {
      if (memcmp(*(const void **)(v45 + 72), v51, *(void *)(v45 + 80))) {
        goto LABEL_112;
      }
    }
    else if (*(unsigned char *)(v45 + 95))
    {
      uint64_t v52 = 0;
      while (*(unsigned __int8 *)(v45 + v52 + 72) == v51->__r_.__value_.__s.__data_[v52])
      {
        if (v47 == ++v52) {
          goto LABEL_111;
        }
      }
      goto LABEL_112;
    }
LABEL_111:
    if (subscriber::isSimSettled()) {
      goto LABEL_114;
    }
LABEL_112:
    v45 += 168;
  }
  while (v45 != v46);
  uint64_t v45 = v46;
LABEL_114:
  if (v45 != *(void *)(a1 + 168)) {
    (*(void (**)(uint64_t, void))(*(void *)v42 + 16))(v42, 0);
  }
LABEL_121:
  if (SHIBYTE(v58) < 0) {
    operator delete(__dst[0]);
  }
LABEL_123:
  sub_10004D2C8(v41);
LABEL_124:
  if (BYTE8(v71)) {
    sub_1000C584C((uint64_t)buf);
  }
}

void sub_100CB4AF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a21)
  {
    long long __p = &a18;
    sub_100047F64((void ***)&__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  sub_10004D2C8(v56);
  if (a56) {
    sub_1000C584C((uint64_t)&a29);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CB4B88(void *a1)
{
  std::string::size_type v22 = 0;
  v23[0] = 0;
  v23[1] = 0;
  sub_100CB0970((uint64_t)a1, 1, (uint64_t *)&v22);
  uint64_t v2 = v22;
  if (v22 == (std::string *)v23)
  {
LABEL_9:
    uint64_t v6 = a1[17];
    for (uint64_t i = a1[18]; v6 != i; v6 += 88)
    {
      if (*(_DWORD *)(v6 + 12) == 3)
      {
        *((void *)&v30 + 1) = 0;
        uint64_t v31 = 0;
        *(void *)&long long v30 = (char *)&v30 + 8;
        uint64_t v8 = v22;
        if (v22 != (std::string *)v23)
        {
          do
          {
            VinylInfo::findProfile();
            if (v29)
            {
              sub_1000C584C((uint64_t)__p);
              sub_100046BAC((uint64_t **)&v30, (void **)&v8[1].__r_.__value_.__l.__size_, (uint64_t)&v8[1].__r_.__value_.__l.__size_);
            }
            size_t size = (char *)v8->__r_.__value_.__l.__size_;
            if (size)
            {
              do
              {
                std::string::size_type v10 = (char **)size;
                size_t size = *(char **)size;
              }
              while (size);
            }
            else
            {
              do
              {
                std::string::size_type v10 = (char **)v8->__r_.__value_.__r.__words[2];
                BOOL v5 = *v10 == (char *)v8;
                uint64_t v8 = (std::string *)v10;
              }
              while (!v5);
            }
            uint64_t v8 = (std::string *)v10;
          }
          while (v10 != v23);
        }
        std::string::size_type v11 = (std::__shared_weak_count *)a1[10];
        if (v11)
        {
          int v12 = std::__shared_weak_count::lock(v11);
          if (v12)
          {
            BOOL v13 = v12;
            uint64_t v14 = a1[9];
            if (v14)
            {
              uint64_t v15 = a1[5];
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v16 = v31;
                sub_1000E8F34((std::string *)v30, (std::string *)((char *)&v30 + 8), ",", 1uLL, __p);
                int v17 = __p;
                if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  int v17 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)long long buf = 134218242;
                uint64_t v25 = v16;
                __int16 v26 = 2080;
                BOOL v27 = v17;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Activating (%lu) profiles [%s]", buf, 0x16u);
                if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p[0].__r_.__value_.__l.__data_);
                }
              }
              (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v14 + 152))(v14, v6 + 16, &v30);
            }
            sub_10004D2C8(v13);
          }
        }
        sub_10005CD2C((uint64_t)&v30, *((char **)&v30 + 1));
      }
    }
    uint64_t v18 = 1;
  }
  else
  {
    while (sub_100CBFD40((unsigned __int8 **)&v2[1].__r_.__value_.__l.__size_, a1[20], a1[21]))
    {
      uint64_t v3 = (char *)v2->__r_.__value_.__l.__size_;
      if (v3)
      {
        do
        {
          uint64_t v4 = (char **)v3;
          uint64_t v3 = *(char **)v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (char **)v2->__r_.__value_.__r.__words[2];
          BOOL v5 = *v4 == (char *)v2;
          uint64_t v2 = (std::string *)v4;
        }
        while (!v5);
      }
      uint64_t v2 = (std::string *)v4;
      if (v4 == v23) {
        goto LABEL_9;
      }
    }
    uint64_t v19 = a1[5];
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      sub_1000E8F34(v22, (std::string *)v23, ",", 1uLL, __p);
      uint64_t v21 = (__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? __p
          : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(v30) = 136315138;
      *(void *)((char *)&v30 + 4) = v21;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Missing an ICCID (%s), delay profile enablement", (uint8_t *)&v30, 0xCu);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
    }
    uint64_t v18 = 0;
  }
  sub_10005CD2C((uint64_t)&v22, v23[0]);
  return v18;
}

void sub_100CB4ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char *a13)
{
}

void sub_100CB4F1C(uint64_t a1, uint64_t a2)
{
  if (((*(uint64_t (**)(void))(**(void **)(a2 + 56) + 40))(*(void *)(a2 + 56)) & 1) == 0) {
    goto LABEL_5;
  }
  unint64_t v4 = *(void *)(a2 + 808);
  if (v4 >= 2)
  {
    BOOL v5 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Invalid configuration for country list", buf, 2u);
    }
    goto LABEL_5;
  }
  if (!v4)
  {
    if (*(char *)(a2 + 927) < 0)
    {
      if (!*(void *)(a2 + 912))
      {
LABEL_5:
        *(unsigned char *)a1 = 0;
        *(unsigned char *)(a1 + 24) = 0;
        return;
      }
    }
    else if (!*(unsigned char *)(a2 + 927))
    {
      goto LABEL_5;
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)&long long v33 = 0;
    memset(buf, 0, sizeof(buf));
    *(unsigned char *)(a1 + 24) = 1;
    __dst[0] = buf;
    sub_100047F64((void ***)__dst);
    return;
  }
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v27 = 0;
  uint64_t v6 = *(void *)(a2 + 792);
  if (*(char *)(v6 + 55) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v6 + 32), *(void *)(v6 + 40));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)(v6 + 32);
    uint64_t v27 = *(void *)(v6 + 48);
  }
  uint64_t v7 = sub_100046F68(a2 + 264, __dst);
  if ((void **)(a2 + 272) != v7)
  {
    if (*((unsigned char *)v7 + 392))
    {
      uint64_t v8 = (long long *)v7[43];
      int v9 = (long long *)v7[44];
      if (v8 != v9)
      {
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = 0;
        sub_1000302C0((char *)a1, v8, v9, 0xAAAAAAAAAAAAAAABLL * (((char *)v9 - (char *)v8) >> 3));
        *(unsigned char *)(a1 + 24) = 1;
        goto LABEL_54;
      }
    }
  }
  if (*(char *)(a2 + 927) < 0)
  {
    if (*(void *)(a2 + 912))
    {
LABEL_20:
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      *(_OWORD *)long long buf = 0u;
      sGetProfileDetails();
      if (!BYTE8(v45))
      {
LABEL_51:
        *(unsigned char *)a1 = 0;
        *(unsigned char *)(a1 + 24) = 0;
LABEL_52:
        if (BYTE8(v45)) {
          sub_1000C584C((uint64_t)buf);
        }
        goto LABEL_54;
      }
      (***(void (****)(Registry **__return_ptr))(a2 + 56))(v24);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v24[0]);
      int v12 = ServiceMap;
      if (v13 < 0)
      {
        uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v15 = 5381;
        do
        {
          uint64_t v13 = v15;
          unsigned int v16 = *v14++;
          uint64_t v15 = (33 * v15) ^ v16;
        }
        while (v16);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long v30 = v13;
      int v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)v30);
      if (v17)
      {
        uint64_t v19 = v17[3];
        uint64_t v18 = (std::__shared_weak_count *)v17[4];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v12);
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v18);
          char v20 = 0;
          goto LABEL_33;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v12);
      uint64_t v18 = 0;
      char v20 = 1;
LABEL_33:
      if (v24[1]) {
        sub_10004D2C8((std::__shared_weak_count *)v24[1]);
      }
      if (!v19)
      {
LABEL_49:
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_51;
      }
      v24[0] = 0;
      v24[1] = 0;
      uint64_t v25 = 0;
      (*(void (**)(Registry **__return_ptr, uint64_t, long long *))(*(void *)v19 + 24))(v24, v19, &v38);
      if (SHIBYTE(v25) < 0)
      {
        if (v24[1])
        {
          memset(v30, 0, sizeof(v30));
          uint64_t v31 = 0;
          sub_10004FC84(__p, v24[0], (unint64_t)v24[1]);
          goto LABEL_41;
        }
      }
      else if (HIBYTE(v25))
      {
        memset(v30, 0, sizeof(v30));
        uint64_t v31 = 0;
        *(_OWORD *)long long __p = *(_OWORD *)v24;
        uint64_t v29 = v25;
LABEL_41:
        sub_1001F69F4((uint64_t)v30, (long long *)__p, 1uLL);
        if (SHIBYTE(v29) < 0) {
          operator delete(__p[0]);
        }
        *(_OWORD *)a1 = *(_OWORD *)v30;
        *(void *)(a1 + 16) = v31;
        memset(v30, 0, sizeof(v30));
        uint64_t v31 = 0;
        *(unsigned char *)(a1 + 24) = 1;
        __p[0] = v30;
        sub_100047F64((void ***)__p);
        char v21 = 0;
        goto LABEL_46;
      }
      std::string::size_type v22 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        if ((SBYTE7(v39) & 0x80u) == 0) {
          long long v23 = &v38;
        }
        else {
          long long v23 = (long long *)v38;
        }
        *(_DWORD *)long long v30 = 136315138;
        *(void *)&_OWORD v30[4] = v23;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Missing ISO country code for %s", v30, 0xCu);
      }
      char v21 = 1;
LABEL_46:
      if (SHIBYTE(v25) < 0) {
        operator delete(v24[0]);
      }
      if ((v21 & 1) == 0)
      {
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_52;
      }
      goto LABEL_49;
    }
  }
  else if (*(unsigned char *)(a2 + 927))
  {
    goto LABEL_20;
  }
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
LABEL_54:
  if (SHIBYTE(v27) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_100CB53B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v62 & 1) == 0) {
    sub_10004D2C8(v61);
  }
  if (a61) {
    sub_1000C584C((uint64_t)&a34);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CB545C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 872;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  std::string::operator=((std::string *)a1, (const std::string *)(a2 + 872));
  uint64_t result = sub_100CB1134(a2, v4);
  *(unsigned char *)(a1 + 24) = result ^ 1;
  *(_DWORD *)(a1 + 28) = 1;
  return result;
}

void sub_100CB54B8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CB54D4(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (*a2 != v4)
  {
    BOOL v5 = (uint64_t **)(a1 + 33);
    do
    {
      *(void *)long long buf = v3 + 8;
      uint64_t v6 = sub_100CC3268(v5, (void **)(v3 + 8), (long long **)buf);
      uint64_t v7 = v6;
      uint64_t v8 = v6 + 192;
      if (v6[392])
      {
        *((_DWORD *)v6 + 48) = *(_DWORD *)v3;
        std::string::operator=((std::string *)(v6 + 200), (const std::string *)(v3 + 8));
        uint64_t v9 = *(void *)(v3 + 48);
        *((_OWORD *)v7 + 14) = *(_OWORD *)(v3 + 32);
        *((void *)v7 + 30) = v9;
        std::string::operator=((std::string *)(v7 + 248), (const std::string *)(v3 + 56));
        v7[272] = *(unsigned char *)(v3 + 80);
        std::string::operator=((std::string *)(v7 + 280), (const std::string *)(v3 + 88));
        *((_DWORD *)v7 + 76) = *(_DWORD *)(v3 + 112);
        std::string::operator=((std::string *)v7 + 13, (const std::string *)(v3 + 120));
        *((void *)v7 + 42) = *(void *)(v3 + 144);
        if ((char *)v3 != v8)
        {
          sub_10005CA3C((uint64_t)(v7 + 344), *(std::string **)(v3 + 152), *(long long **)(v3 + 160), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v3 + 160) - *(void *)(v3 + 152)) >> 3));
          sub_100CC2900((uint64_t *)v7 + 46, *(long long **)(v3 + 176), *(long long **)(v3 + 184), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v3 + 184) - *(void *)(v3 + 176)) >> 3));
        }
      }
      else
      {
        sub_10030FB14((uint64_t)(v6 + 192), v3);
        v7[392] = 1;
      }
      v3 += 200;
    }
    while (v3 != v4);
  }
  uint64_t v10 = (uint64_t)a1;
  sub_100CA460C(a1, 3);
  if (*a2 != a2[1])
  {
    long long v33 = 0uLL;
    v34[0] = 0;
    std::string::size_type v11 = (void *)a1[33];
    if (v11 == a1 + 34)
    {
      unint64_t v12 = 0;
      uint64_t v23 = 0;
    }
    else
    {
      unint64_t v12 = 0;
      do
      {
        if (*((unsigned char *)v11 + 392))
        {
          if (v12 >= v34[0])
          {
            unint64_t v13 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v12 - v33) >> 3) + 1;
            if (v13 > 0x147AE147AE147AELL) {
              sub_10006A748();
            }
            if (0x1EB851EB851EB852 * ((uint64_t)(v34[0] - v33) >> 3) > v13) {
              unint64_t v13 = 0x1EB851EB851EB852 * ((uint64_t)(v34[0] - v33) >> 3);
            }
            if (0x8F5C28F5C28F5C29 * ((uint64_t)(v34[0] - v33) >> 3) >= 0xA3D70A3D70A3D7) {
              unint64_t v14 = 0x147AE147AE147AELL;
            }
            else {
              unint64_t v14 = v13;
            }
            long long v38 = v34;
            if (v14) {
              uint64_t v15 = (char *)sub_10030FA44((uint64_t)v34, v14);
            }
            else {
              uint64_t v15 = 0;
            }
            *(void *)long long buf = v15;
            v36.i64[0] = (uint64_t)&v15[8 * ((uint64_t)(v12 - v33) >> 3)];
            v36.i64[1] = v36.i64[0];
            long long v37 = &v15[200 * v14];
            sub_10030FB14(v36.i64[0], (uint64_t)(v11 + 24));
            uint64_t v16 = v36.i64[0];
            unint64_t v12 = v36.i64[1] + 200;
            v36.i64[1] += 200;
            uint64_t v17 = *((void *)&v33 + 1);
            if (*((void *)&v33 + 1) == (void)v33)
            {
              int64x2_t v18 = vdupq_n_s64(*((unint64_t *)&v33 + 1));
            }
            else
            {
              do
              {
                v16 -= 200;
                v17 -= 200;
                sub_100AA0EB8(v16, v17);
              }
              while (v17 != (void)v33);
              int64x2_t v18 = (int64x2_t)v33;
              unint64_t v12 = v36.u64[1];
            }
            *(void *)&long long v33 = v16;
            *((void *)&v33 + 1) = v12;
            int64x2_t v36 = v18;
            uint64_t v19 = (char *)v34[0];
            v34[0] = v37;
            long long v37 = v19;
            *(void *)long long buf = v18.i64[0];
            sub_100AA0F8C((uint64_t)buf);
          }
          else
          {
            sub_10030FB14(v12, (uint64_t)(v11 + 24));
            v12 += 200;
          }
          *((void *)&v33 + 1) = v12;
        }
        char v20 = (void *)v11[1];
        if (v20)
        {
          do
          {
            char v21 = v20;
            char v20 = (void *)*v20;
          }
          while (v20);
        }
        else
        {
          do
          {
            char v21 = (void *)v11[2];
            BOOL v22 = *v21 == (void)v11;
            std::string::size_type v11 = v21;
          }
          while (!v22);
        }
        std::string::size_type v11 = v21;
      }
      while (v21 != a1 + 34);
      uint64_t v23 = v33;
      uint64_t v10 = (uint64_t)a1;
    }
    uint64_t v24 = *(void *)(v10 + 120);
    memset(v32, 0, sizeof(v32));
    sub_10030F964(v32, v23, v12, 0x8F5C28F5C28F5C29 * ((uint64_t)(v12 - v23) >> 3));
    (*(void (**)(uint64_t, void *))(*(void *)v24 + 40))(v24, v32);
    *(void *)long long buf = v32;
    sub_100310018((void ***)buf);
    *(void *)long long buf = &v33;
    sub_100310018((void ***)buf);
  }
  if (*(char *)(v10 + 927) < 0)
  {
    if (*(void *)(v10 + 912))
    {
LABEL_40:
      uint64_t v25 = *(NSObject **)(v10 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#N System selecction enabled", buf, 2u);
      }
      return;
    }
  }
  else if (*(unsigned char *)(v10 + 927))
  {
    goto LABEL_40;
  }
  __int16 v26 = *(std::__shared_weak_count **)(v10 + 80);
  if (v26)
  {
    uint64_t v27 = std::__shared_weak_count::lock(v26);
    if (v27)
    {
      uint64_t v28 = v27;
      uint64_t v29 = *(void *)(v10 + 72);
      if (v29)
      {
        sub_100CB4F1C((uint64_t)v31, v10);
        sub_100CB545C((uint64_t)buf, v10);
        (*(void (**)(uint64_t, unsigned char *, uint8_t *))(*(void *)v29 + 80))(v29, v31, buf);
        if (v36.i8[15] < 0) {
          operator delete(*(void **)buf);
        }
        if (v31[24])
        {
          *(void *)long long buf = v31;
          sub_100047F64((void ***)buf);
        }
      }
      sub_10004D2C8(v28);
    }
  }
}

void sub_100CB5968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a13)
  {
    long long __p = &a10;
    sub_100047F64((void ***)&__p);
  }
  sub_10004D2C8(v26);
  _Unwind_Resume(a1);
}

void sub_100CB5A04(void *a1)
{
  memset(&__p, 0, sizeof(__p));
  sub_100CB5FE4((uint64_t)a1, &__p);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (*((unsigned char *)&__p.__r_.__value_.__s + 23))
    {
      uint64_t v2 = a1 + 21;
      uint64_t v3 = a1[21];
      uint64_t v4 = a1[20];
      std::string __s1 = __p;
      goto LABEL_6;
    }
LABEL_25:
    unint64_t v14 = a1[5];
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_44;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v15 = "#I No user selected esim";
LABEL_43:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 2u);
    goto LABEL_44;
  }
  if (!__p.__r_.__value_.__l.__size_) {
    goto LABEL_25;
  }
  uint64_t v2 = a1 + 21;
  uint64_t v3 = a1[21];
  uint64_t v4 = a1[20];
  sub_10004FC84(&__s1, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
LABEL_6:
  uint64_t v5 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
  if (v4 != v3)
  {
    size_t size = __s1.__r_.__value_.__l.__size_;
    uint64_t v7 = (const void *)__s1.__r_.__value_.__r.__words[0];
    if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v8 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v8 = __s1.__r_.__value_.__l.__size_;
    }
    do
    {
      uint64_t v9 = *(unsigned __int8 *)(v4 + 95);
      int v10 = (char)v9;
      if ((v9 & 0x80u) != 0) {
        uint64_t v9 = *(void *)(v4 + 80);
      }
      if (v8 == v9)
      {
        if (v10 >= 0) {
          std::string::size_type v11 = (unsigned __int8 *)(v4 + 72);
        }
        else {
          std::string::size_type v11 = *(unsigned __int8 **)(v4 + 72);
        }
        if ((v5 & 0x80) != 0)
        {
          if (!memcmp(v7, v11, size)) {
            goto LABEL_28;
          }
        }
        else
        {
          if (!v5) {
            goto LABEL_29;
          }
          p_s1 = &__s1;
          uint64_t v13 = v5;
          while (p_s1->__r_.__value_.__s.__data_[0] == *v11)
          {
            p_s1 = (std::string *)((char *)p_s1 + 1);
            ++v11;
            if (!--v13)
            {
              uint64_t v3 = v4;
              goto LABEL_27;
            }
          }
        }
      }
      v4 += 168;
    }
    while (v4 != v3);
  }
LABEL_27:
  uint64_t v4 = v3;
  if ((v5 & 0x80) != 0) {
LABEL_28:
  }
    operator delete(__s1.__r_.__value_.__l.__data_);
LABEL_29:
  if (v4 == *v2)
  {
    unint64_t v14 = a1[5];
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_44;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v15 = "#I SimInfo not present";
    goto LABEL_43;
  }
  if (!*(_DWORD *)v4)
  {
    unint64_t v14 = a1[5];
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_44;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v15 = "#I Sim is not active instance";
    goto LABEL_43;
  }
  if (*(_DWORD *)(v4 + 64) != 3)
  {
    unint64_t v14 = a1[5];
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_44;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v15 = "#I Sim info not tape capable";
    goto LABEL_43;
  }
  if (*(_DWORD *)(v4 + 8) != 5)
  {
    unint64_t v14 = a1[5];
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_44;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v15 = "#I Sim state not ready";
    goto LABEL_43;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = __p;
  }
  sub_100CB60FC((uint64_t)a1, (uint64_t)&__dst, (uint64_t)buf);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v40)
  {
    uint64_t v16 = a1[5];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v28[0]) = 0;
      uint64_t v17 = "#I Vinyl bootstrap profile";
LABEL_53:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)v28, 2u);
    }
  }
  else
  {
    int64x2_t v18 = sub_100046F68((uint64_t)(a1 + 33), &v39);
    if (a1 + 34 == v18 || !*((unsigned char *)v18 + 592) || (double v19 = *((double *)v18 + 50), v19 <= CFAbsoluteTimeGetCurrent()))
    {
      long long v31 = 0u;
      memset(v32, 0, sizeof(v32));
      long long v29 = 0u;
      long long v30 = 0u;
      memset(v28, 0, sizeof(v28));
      memset(__str, 0, sizeof(__str));
      std::string::operator=((std::string *)__str, &__p);
      sub_100CB6240(&v32[8], (std::string *)__str);
      v36[1] = 0;
      v36[0] = 0;
      char v37 = 0;
      sub_100CB62B0((uint64_t)a1, (uint64_t)&__p, v36);
      if (v37)
      {
        ctu::hex((uint64_t *)&v25, (ctu *)v36, (const void *)0x10, v20);
        if ((_BYTE)v29)
        {
          if (SHIBYTE(v28[2]) < 0) {
            operator delete(*((void **)&v28[1] + 1));
          }
          *(long long *)((char *)&v28[1] + 8) = v25;
          *((void *)&v28[2] + 1) = v26;
        }
        else
        {
          *(long long *)((char *)&v28[1] + 8) = v25;
          *((void *)&v28[2] + 1) = v26;
          LOBYTE(v29) = 1;
        }
      }
      char v21 = a1[5];
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v25) = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I fetching subscription account info", (uint8_t *)&v25, 2u);
      }
      uint64_t v22 = a1[13];
      sub_10019ED6C(v24, v28);
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 0x40000000;
      v23[2] = sub_100CB648C;
      v23[3] = &unk_101A4E230;
      v23[4] = a1;
      (*(void (**)(uint64_t, uint64_t, char *, uint64_t, void *))(*(void *)v22 + 16))(v22, 1, v24, 1, v23);
      sub_100CB68DC((uint64_t)v24);
      sub_1002E4140((uint64_t)__str);
      sub_100CB68DC((uint64_t)v28);
      goto LABEL_68;
    }
    uint64_t v16 = a1[5];
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v28[0]) = 0;
      uint64_t v17 = "#I No updating SubscriptionAccountInfo, too early";
      goto LABEL_53;
    }
  }
LABEL_68:
  sub_1000C584C((uint64_t)buf);
LABEL_44:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100CB5F64(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x247]) < 0) {
    operator delete((void *)STACK[0x230]);
  }
  _Unwind_Resume(a1);
}

void *sub_100CB5FE4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (*(_DWORD *)(a1 + 788) >= 2u
    || (uint64_t v4 = *(unsigned __int8 ***)(a1 + 792), v5 = (unsigned __int8 **)(a1 + 800), v4 == (unsigned __int8 **)(a1 + 800)))
  {
LABEL_10:
    return sub_100058DB0(a2, "");
  }
  else
  {
    while (1)
    {
      uint64_t result = (void *)sub_100CBFD40(v4 + 4, *(void *)(a1 + 160), *(void *)(a1 + 168));
      if (result) {
        break;
      }
      uint64_t v7 = v4[1];
      if (v7)
      {
        do
        {
          std::string::size_type v8 = (unsigned __int8 **)v7;
          uint64_t v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          std::string::size_type v8 = (unsigned __int8 **)v4[2];
          BOOL v9 = *v8 == (unsigned __int8 *)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
      if (v8 == v5) {
        goto LABEL_10;
      }
    }
    if (*((char *)v4 + 55) < 0)
    {
      std::string::size_type v11 = v4[4];
      unint64_t v12 = (unint64_t)v4[5];
      return sub_10004FC84(a2, v11, v12);
    }
    else
    {
      long long v10 = *((_OWORD *)v4 + 2);
      a2[2] = v4[6];
      *(_OWORD *)a2 = v10;
    }
  }
  return result;
}

uint64_t sub_100CB60FC@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)(result + 136);
  uint64_t v5 = *(void *)(result + 144);
  if (v4 == v5)
  {
LABEL_23:
    *(_OWORD *)(a3 + 76) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 144) = 0u;
    *(_OWORD *)(a3 + 160) = 0u;
    *(_OWORD *)(a3 + 176) = 0u;
    *(_OWORD *)(a3 + 192) = 0u;
    *(void *)(a3 + 208) = 0;
    return result;
  }
  while (1)
  {
    if (*(unsigned char *)(v4 + 80))
    {
      uint64_t v7 = *(void *)(v4 + 56);
      uint64_t v8 = *(void *)(v4 + 64);
      if (v7 != v8) {
        break;
      }
    }
LABEL_22:
    v4 += 88;
    if (v4 == v5) {
      goto LABEL_23;
    }
  }
  int v9 = *(char *)(a2 + 23);
  if (v9 >= 0) {
    uint64_t v10 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v10 = *(void *)(a2 + 8);
  }
  while (1)
  {
    uint64_t v11 = *(unsigned __int8 *)(v7 + 39);
    if ((v11 & 0x80u) == 0) {
      uint64_t v12 = *(unsigned __int8 *)(v7 + 39);
    }
    else {
      uint64_t v12 = *(void *)(v7 + 24);
    }
    if (v12 != v10) {
      goto LABEL_21;
    }
    uint64_t v13 = v9 >= 0 ? (unsigned __int8 *)a2 : *(unsigned __int8 **)a2;
    if ((v11 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v7 + 39)) {
      goto LABEL_24;
    }
    uint64_t v14 = 0;
    while (*(unsigned __int8 *)(v7 + v14 + 16) == v13[v14])
    {
      if (v11 == ++v14) {
        goto LABEL_24;
      }
    }
LABEL_21:
    v7 += 216;
    if (v7 == v8) {
      goto LABEL_22;
    }
  }
  uint64_t result = memcmp(*(const void **)(v7 + 16), v13, *(void *)(v7 + 24));
  if (result) {
    goto LABEL_21;
  }
LABEL_24:

  return sub_1000C5AB4(a3, v7);
}

char *sub_100CB6240(char *__dst, std::string *__str)
{
  if (__dst[64])
  {
    std::string::operator=((std::string *)__dst, __str);
    uint64_t v4 = *(std::string::size_type *)((char *)__str[1].__r_.__value_.__r.__words + 5);
    *((void *)__dst + 3) = __str[1].__r_.__value_.__l.__data_;
    *(void *)(__dst + 29) = v4;
    std::string::operator=((std::string *)(__dst + 40), (std::string *)((char *)__str + 40));
  }
  else
  {
    sub_100CC27B8(__dst, (long long *)__str);
    __dst[64] = 1;
  }
  return __dst;
}

void sub_100CB62B0(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a2 + 23))
    {
      uint64_t v4 = (void *)(a1 + 144);
      uint64_t v5 = *(void *)(a1 + 144);
      uint64_t v6 = *(void *)(a1 + 136);
      *(_OWORD *)int64x2_t v18 = *(_OWORD *)a2;
      uint64_t v19 = *(void *)(a2 + 16);
      goto LABEL_6;
    }
LABEL_41:
    char v17 = 0;
    *a3 = 0;
    goto LABEL_42;
  }
  unint64_t v7 = *(void *)(a2 + 8);
  if (!v7) {
    goto LABEL_41;
  }
  uint64_t v4 = (void *)(a1 + 144);
  uint64_t v5 = *(void *)(a1 + 144);
  uint64_t v6 = *(void *)(a1 + 136);
  sub_10004FC84(v18, *(void **)a2, v7);
LABEL_6:
  if (v6 != v5)
  {
    while (1)
    {
      if (*(unsigned char *)(v6 + 80))
      {
        uint64_t v8 = *(void *)(v6 + 56);
        uint64_t v9 = *(void *)(v6 + 64);
        if (SHIBYTE(v19) < 0)
        {
          sub_10004FC84(__p, v18[0], (unint64_t)v18[1]);
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)v18;
          uint64_t v21 = v19;
        }
        char v10 = HIBYTE(v21);
        if (v8 != v9)
        {
          if (v21 >= 0) {
            uint64_t v11 = (void *)HIBYTE(v21);
          }
          else {
            uint64_t v11 = __p[1];
          }
          if (v21 >= 0) {
            uint64_t v12 = __p;
          }
          else {
            uint64_t v12 = (void **)__p[0];
          }
          do
          {
            uint64_t v13 = *(unsigned __int8 *)(v8 + 39);
            if ((v13 & 0x80u) == 0) {
              uint64_t v14 = (void *)*(unsigned __int8 *)(v8 + 39);
            }
            else {
              uint64_t v14 = *(void **)(v8 + 24);
            }
            if (v14 == v11)
            {
              if ((v13 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v8 + 16), v12, *(void *)(v8 + 24))) {
                  goto LABEL_31;
                }
              }
              else
              {
                if (!*(unsigned char *)(v8 + 39)) {
                  goto LABEL_31;
                }
                uint64_t v15 = 0;
                while (*(unsigned __int8 *)(v8 + v15 + 16) == *((unsigned __int8 *)v12 + v15))
                {
                  if (v13 == ++v15) {
                    goto LABEL_31;
                  }
                }
              }
            }
            v8 += 216;
          }
          while (v8 != v9);
          uint64_t v8 = v9;
        }
LABEL_31:
        uint64_t v16 = *(void *)(v6 + 64);
        if (v10 < 0) {
          operator delete(__p[0]);
        }
        if (v8 != v16) {
          break;
        }
      }
      v6 += 88;
      if (v6 == v5) {
        goto LABEL_37;
      }
    }
    uint64_t v5 = v6;
  }
LABEL_37:
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[0]);
  }
  if (v5 == *v4) {
    goto LABEL_41;
  }
  *(_OWORD *)a3 = *(_OWORD *)(v5 + 16);
  char v17 = 1;
LABEL_42:
  a3[16] = v17;
}

void sub_100CB6470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CB648C(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (!a3 || (uint64_t v4 = *a2) == 0)
  {
    uint64_t v24 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    long long v25 = "Not successful / No response failure";
    goto LABEL_51;
  }
  if (*(_DWORD *)v4 != 6000) {
    return;
  }
  uint64_t v5 = *(void *)(v4 + 8);
  if (!v5 || !*(unsigned char *)(v5 + 120))
  {
    uint64_t v24 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    long long v25 = "Missing content or subscription";
LABEL_51:
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v25, buf, 2u);
    return;
  }
  unint64_t v29 = 0;
  unint64_t v30 = 0;
  uint64_t v28 = 0;
  uint64_t v6 = *(void *)(v4 + 8);
  uint64_t v7 = *(void *)(v6 + 96);
  for (uint64_t i = *(void *)(v6 + 104); v7 != i; v7 += 264)
  {
    if (*(unsigned char *)(v7 + 88))
    {
      unint64_t v9 = v29;
      if (v29 >= v30)
      {
        unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v29 - v28) >> 6);
        unint64_t v13 = v12 + 1;
        if (v12 + 1 > 0x155555555555555) {
          sub_10006A748();
        }
        if (0x5555555555555556 * ((uint64_t)(v30 - v28) >> 6) > v13) {
          unint64_t v13 = 0x5555555555555556 * ((uint64_t)(v30 - v28) >> 6);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - v28) >> 6) >= 0xAAAAAAAAAAAAAALL) {
          unint64_t v14 = 0x155555555555555;
        }
        else {
          unint64_t v14 = v13;
        }
        long long v34 = &v30;
        uint64_t v15 = (char *)sub_10034036C((uint64_t)&v30, v14);
        uint64_t v16 = &v15[192 * v12];
        *(void *)long long buf = v15;
        *(void *)&uint8_t buf[8] = v16;
        long long v33 = &v15[192 * v17];
        *(_OWORD *)uint64_t v16 = 0u;
        *((_OWORD *)v16 + 1) = 0u;
        *((_OWORD *)v16 + 2) = 0u;
        *((_OWORD *)v16 + 3) = 0u;
        *((_OWORD *)v16 + 4) = 0u;
        *((_OWORD *)v16 + 5) = 0u;
        *((_OWORD *)v16 + 6) = 0u;
        *((_OWORD *)v16 + 7) = 0u;
        *((_OWORD *)v16 + 8) = 0u;
        *((_OWORD *)v16 + 9) = 0u;
        *((_OWORD *)v16 + 10) = 0u;
        *((_OWORD *)v16 + 11) = 0u;
        v16[185] = 1;
        uint64_t v32 = v16 + 192;
        sub_1003DBD8C(&v28, buf);
        unint64_t v10 = v29;
        sub_1003DBEF8((uint64_t)buf);
      }
      else
      {
        *(_OWORD *)(v29 + 160) = 0u;
        *(_OWORD *)(v9 + 176) = 0u;
        *(_OWORD *)(v9 + 128) = 0u;
        *(_OWORD *)(v9 + 144) = 0u;
        *(_OWORD *)(v9 + 96) = 0u;
        *(_OWORD *)(v9 + 112) = 0u;
        *(_OWORD *)(v9 + 64) = 0u;
        *(_OWORD *)(v9 + 80) = 0u;
        *(_OWORD *)(v9 + 32) = 0u;
        *(_OWORD *)(v9 + 48) = 0u;
        *(_OWORD *)unint64_t v9 = 0u;
        *(_OWORD *)(v9 + 16) = 0u;
        unint64_t v10 = v9 + 192;
        *(unsigned char *)(v9 + 185) = 1;
      }
      unint64_t v29 = v10;
      ctu::hex((uint64_t *)buf, (ctu *)(*(void *)(v3 + 136) + 16), (const void *)0x10, a3);
      int64x2_t v18 = (void **)(v10 - 184);
      if (*(char *)(v10 - 161) < 0) {
        operator delete(*v18);
      }
      long long v19 = *(_OWORD *)buf;
      *(void *)(v10 - 168) = v32;
      *(_OWORD *)int64x2_t v18 = v19;
      *(CFAbsoluteTime *)(v10 - 192) = CFAbsoluteTimeGetCurrent() + 300.0;
      if (!*(unsigned char *)(v7 + 88)) {
        sub_10016C840();
      }
      std::string::operator=((std::string *)(v10 - 160), (const std::string *)(v7 + 64));
      if (*(unsigned char *)(v7 + 132))
      {
        if (*(_DWORD *)(v7 + 128) == 1) {
          char v20 = 1;
        }
        else {
          char v20 = 2;
        }
        *(unsigned char *)(v10 - 135) = v20;
      }
      if (*(unsigned char *)(v7 + 120))
      {
        if (*(char *)(v7 + 119) < 0)
        {
          sub_10004FC84(__p, *(void **)(v7 + 96), *(void *)(v7 + 104));
        }
        else
        {
          long long v21 = *(_OWORD *)(v7 + 96);
          uint64_t v27 = *(void *)(v7 + 112);
          *(_OWORD *)std::string __p = v21;
        }
        *(unsigned char *)(v10 - 136) = sub_10109A710((unsigned __int16 *)__p);
        if (SHIBYTE(v27) < 0) {
          operator delete(__p[0]);
        }
      }
      if (*(unsigned char *)(v7 + 224))
      {
        std::string::operator=((std::string *)(v10 - 56), (const std::string *)(v7 + 200));
        if (*(unsigned char *)(v7 + 256)) {
          std::string::operator=((std::string *)(v10 - 32), (const std::string *)(v7 + 232));
        }
      }
      if (*(unsigned char *)(v7 + 160)) {
        std::string::operator=((std::string *)(v10 - 128), (const std::string *)(v7 + 136));
      }
      if (*(unsigned char *)(v7 + 132))
      {
        if (*(_DWORD *)(v7 + 128) == 1) {
          char v22 = 1;
        }
        else {
          char v22 = 2;
        }
        *(unsigned char *)(v10 - 135) = v22;
      }
      *(void *)long long buf = v7 + 64;
      uint64_t v23 = sub_100CC3268((uint64_t **)(v3 + 264), (void **)(v7 + 64), (long long **)buf);
      sub_100CAE99C((uint64_t)(v23 + 400), v10 - 192);
    }
    else
    {
      uint64_t v11 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "No iccid, skipping", buf, 2u);
      }
    }
  }
  sub_100CA5980(v3);
  (*(void (**)(void, uint64_t *))(**(void **)(v3 + 120) + 56))(*(void *)(v3 + 120), &v28);
  *(void *)long long buf = &v28;
  sub_10023FDC8((void ***)buf);
}

void sub_100CB688C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char *a23)
{
  a23 = &a15;
  sub_10023FDC8((void ***)&a23);
  _Unwind_Resume(a1);
}

uint64_t sub_100CB68DC(uint64_t a1)
{
  sub_10019EFB4(a1 + 104);
  uint64_t v3 = (void **)(a1 + 80);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100CB6958(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = a1;
  v293 = 0;
  v294 = 0;
  unint64_t v295 = 0;
  uint64_t v290 = 0;
  v291 = 0;
  unint64_t v292 = 0;
  sub_100CB0970(a1, 0, &v290);
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 80);
  if (v3 && (uint64_t v4 = std::__shared_weak_count::lock(v3)) != 0)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)(v2 + 72);
    if (v6) {
      char v262 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 96))(v6);
    }
    else {
      char v262 = 1;
    }
    sub_10004D2C8(v5);
  }
  else
  {
    char v262 = 1;
  }
  uint64_t v8 = *(void *)(v2 + 160);
  uint64_t v7 = *(void *)(v2 + 168);
  uint64_t v286 = v2;
  if (v8 != v7)
  {
    v276 = (const void **)(v2 + 1136);
    v275 = (const void **)(v2 + 872);
    v274 = (const void **)(v2 + 840);
    v273 = (std::string *)(v2 + 816);
    uint64_t v269 = v2 + 760;
    v278 = (void **)(v2 + 272);
    v280 = (std::string *)(v2 + 264);
    uint64_t v277 = *(void *)(v2 + 168);
    do
    {
      if ((subscriber::isEsimCapable() & 1) == 0)
      {
        if (*(char *)(v8 + 95) < 0)
        {
          if (*(void *)(v8 + 80))
          {
LABEL_15:
            unint64_t v9 = v294;
            if ((unint64_t)v294 >= v295)
            {
              unint64_t v10 = (std::string *)sub_1003DC28C((uint64_t *)&v293);
            }
            else
            {
              bzero(v294, 0x338uLL);
              sub_1003DC3A8((uint64_t)v9);
              unint64_t v10 = (std::string *)((char *)v9 + 824);
            }
            v294 = v10;
            uint64_t v11 = &v10[-35].__r_.__value_.__s.__data_[16];
            v11[561] = subscriber::isSimLocked();
            v11[560] = 1;
            *(void *)&long long v329 = 0;
            long long __p = 0u;
            long long v326 = 0u;
            memset(v327, 0, sizeof(v327));
            memset(__str, 0, sizeof(__str));
            if (v10[-35].__r_.__value_.__s.__data_[16])
            {
              sub_100CC2FC8((uint64_t)&v10[-35].__r_.__value_.__r.__words[2], (long long *)__str);
              if (SBYTE7(v329) < 0) {
                operator delete((void *)__p);
              }
            }
            else
            {
              v10[-34].__r_.__value_.__r.__words[0] = 0;
              v10[-34].__r_.__value_.__l.__size_ = 0;
              v10[-34].__r_.__value_.__r.__words[2] = 0;
              memset(__str, 0, 24);
              v10[-33] = __str[1];
              memset(&__str[1], 0, sizeof(std::string));
              *(_OWORD *)&v10[-32].__r_.__value_.__l.__data_ = v326;
              v10[-32].__r_.__value_.__r.__words[2] = *(void *)&v327[0];
              long long v326 = 0uLL;
              *(void *)&v327[0] = 0;
              long long v12 = *(_OWORD *)((char *)v327 + 8);
              v10[-31].__r_.__value_.__r.__words[2] = *((void *)&v327[1] + 1);
              *(_OWORD *)&v10[-31].__r_.__value_.__l.__data_ = v12;
              memset((char *)v327 + 8, 0, 24);
              long long v13 = __p;
              v10[-30].__r_.__value_.__r.__words[2] = v329;
              *(_OWORD *)&v10[-30].__r_.__value_.__l.__data_ = v13;
              std::string::value_type *v11 = 1;
            }
            if (SHIBYTE(v327[1]) < 0) {
              operator delete(*((void **)&v327[0] + 1));
            }
            if (SBYTE7(v327[0]) < 0) {
              operator delete((void *)v326);
            }
            if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str[1].__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str[0].__r_.__value_.__l.__data_);
            }
            if (!*v11) {
              __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
            }
            unint64_t v14 = (const void **)(v8 + 72);
            std::string::operator=(v10 - 34, (const std::string *)(v8 + 72));
            LODWORD(v10[-7].__r_.__value_.__l.__data_) = 0;
            if (*(_DWORD *)(v286 + 788) == 1)
            {
LABEL_32:
              uint64_t v15 = &v10[-11].__r_.__value_.__s.__data_[3];
              goto LABEL_33;
            }
            uint64_t v16 = *(unsigned __int8 *)(v286 + 839);
            if (*(char *)(v286 + 839) < 0)
            {
              if (!*(void *)(v286 + 824)) {
                goto LABEL_56;
              }
LABEL_36:
              if ((v16 & 0x80u) == 0) {
                uint64_t v17 = *(unsigned __int8 *)(v286 + 839);
              }
              else {
                uint64_t v17 = *(void *)(v286 + 824);
              }
              uint64_t v18 = *(unsigned __int8 *)(v8 + 95);
              int v19 = (char)v18;
              if ((v18 & 0x80u) != 0) {
                uint64_t v18 = *(void *)(v8 + 80);
              }
              if (v17 == v18)
              {
                if (v19 >= 0) {
                  char v20 = (unsigned __int8 *)(v8 + 72);
                }
                else {
                  char v20 = (unsigned __int8 *)*v14;
                }
                if ((v16 & 0x80) != 0)
                {
                  BOOL v29 = memcmp(v273->__r_.__value_.__l.__data_, v20, *(void *)(v286 + 824)) == 0;
                }
                else if (*(unsigned char *)(v286 + 839))
                {
                  uint64_t v21 = v16 - 1;
                  char v22 = v273;
                  do
                  {
                    int v24 = v22->__r_.__value_.__s.__data_[0];
                    char v22 = (std::string *)((char *)v22 + 1);
                    int v23 = v24;
                    int v26 = *v20++;
                    int v25 = v26;
                    BOOL v27 = v21-- != 0;
                    char v28 = v27;
                    BOOL v29 = v23 == v25;
                  }
                  while (v29 && (v28 & 1) != 0);
                }
                else
                {
                  BOOL v29 = 1;
                }
              }
              else
              {
                BOOL v29 = 0;
              }
              v10[-11].__r_.__value_.__s.__data_[3] = v29;
            }
            else
            {
              if (*(unsigned char *)(v286 + 839)) {
                goto LABEL_36;
              }
LABEL_56:
              for (uint64_t i = *(void *)(v286 + 136); i != *(void *)(v286 + 144); i += 88)
              {
                if (*(unsigned char *)(i + 80)) {
                  BOOL v31 = *(_DWORD *)(i + 12) == 3;
                }
                else {
                  BOOL v31 = 0;
                }
                if (v31)
                {
                  for (uint64_t j = *(void *)(i + 56); j != *(void *)(i + 64); j += 216)
                  {
                    if (!*(unsigned char *)(j + 88)) {
                      goto LABEL_32;
                    }
                  }
                }
              }
              uint64_t v15 = &v10[-11].__r_.__value_.__s.__data_[3];
              if (v292 > 1) {
LABEL_33:
              }
                std::string::value_type *v15 = 1;
              else {
                std::string::value_type *v15 = 0;
              }
            }
            v10[-11].__r_.__value_.__s.__data_[2] = sub_10010E128((uint64_t)&v290, (void **)(v8 + 72)) != 0;
            uint64_t v33 = *(unsigned __int8 *)(v286 + 1159);
            if ((v33 & 0x80u) == 0) {
              uint64_t v34 = *(unsigned __int8 *)(v286 + 1159);
            }
            else {
              uint64_t v34 = *(void *)(v286 + 1144);
            }
            uint64_t v35 = *(unsigned __int8 *)(v8 + 95);
            int v36 = (char)v35;
            if ((v35 & 0x80u) != 0) {
              uint64_t v35 = *(void *)(v8 + 80);
            }
            if (v34 == v35)
            {
              if (v36 >= 0) {
                char v37 = (unsigned __int8 *)(v8 + 72);
              }
              else {
                char v37 = (unsigned __int8 *)*v14;
              }
              if ((v33 & 0x80) != 0)
              {
                if (memcmp(*v276, v37, *(void *)(v286 + 1144))) {
                  goto LABEL_89;
                }
              }
              else if (*(unsigned char *)(v286 + 1159))
              {
                long long v38 = v276;
                while (*(unsigned __int8 *)v38 == *v37)
                {
                  long long v38 = (const void **)((char *)v38 + 1);
                  ++v37;
                  if (!--v33) {
                    goto LABEL_90;
                  }
                }
                goto LABEL_89;
              }
LABEL_90:
              int v39 = 14;
            }
            else
            {
LABEL_89:
              int v39 = 0;
            }
            HIDWORD(v10[-1].__r_.__value_.__r.__words[2]) = v39;
            uint64_t v40 = *(unsigned __int8 *)(v286 + 895);
            if ((v40 & 0x80u) == 0) {
              uint64_t v41 = *(unsigned __int8 *)(v286 + 895);
            }
            else {
              uint64_t v41 = *(void *)(v286 + 880);
            }
            uint64_t v42 = *(unsigned __int8 *)(v8 + 95);
            int v43 = (char)v42;
            if ((v42 & 0x80u) != 0) {
              uint64_t v42 = *(void *)(v8 + 80);
            }
            if (v41 == v42)
            {
              if (v43 >= 0) {
                long long v44 = (unsigned __int8 *)(v8 + 72);
              }
              else {
                long long v44 = (unsigned __int8 *)*v14;
              }
              if ((v40 & 0x80) != 0)
              {
                BOOL v52 = memcmp(*v275, v44, *(void *)(v286 + 880)) == 0;
              }
              else if (*(unsigned char *)(v286 + 895))
              {
                uint64_t v45 = v40 - 1;
                uint64_t v46 = v275;
                do
                {
                  int v48 = *(unsigned __int8 *)v46;
                  uint64_t v46 = (const void **)((char *)v46 + 1);
                  int v47 = v48;
                  int v50 = *v44++;
                  int v49 = v50;
                  BOOL v27 = v45-- != 0;
                  char v51 = v27;
                  BOOL v52 = v47 == v49;
                }
                while (v52 && (v51 & 1) != 0);
              }
              else
              {
                BOOL v52 = 1;
              }
            }
            else
            {
              BOOL v52 = 0;
            }
            v10[-11].__r_.__value_.__s.__data_[5] = v52;
            uint64_t v53 = *(unsigned __int8 *)(v286 + 863);
            if ((v53 & 0x80u) == 0) {
              uint64_t v54 = *(unsigned __int8 *)(v286 + 863);
            }
            else {
              uint64_t v54 = *(void *)(v286 + 848);
            }
            uint64_t v55 = *(unsigned __int8 *)(v8 + 95);
            int v56 = (char)v55;
            if ((v55 & 0x80u) != 0) {
              uint64_t v55 = *(void *)(v8 + 80);
            }
            if (v54 == v55)
            {
              if (v56 >= 0) {
                int v57 = (unsigned __int8 *)(v8 + 72);
              }
              else {
                int v57 = (unsigned __int8 *)*v14;
              }
              if ((v53 & 0x80) != 0)
              {
                BOOL v65 = memcmp(*v274, v57, *(void *)(v286 + 848)) == 0;
              }
              else if (*(unsigned char *)(v286 + 863))
              {
                uint64_t v58 = v53 - 1;
                char v59 = v274;
                do
                {
                  int v61 = *(unsigned __int8 *)v59;
                  char v59 = (const void **)((char *)v59 + 1);
                  int v60 = v61;
                  int v63 = *v57++;
                  int v62 = v63;
                  BOOL v27 = v58-- != 0;
                  char v64 = v27;
                  BOOL v65 = v60 == v62;
                }
                while (v65 && (v64 & 1) != 0);
              }
              else
              {
                BOOL v65 = 1;
              }
            }
            else
            {
              BOOL v65 = 0;
            }
            v10[-11].__r_.__value_.__s.__data_[6] = v65;
            long long v66 = *(std::__shared_weak_count **)(v286 + 80);
            if (v66)
            {
              long long v67 = std::__shared_weak_count::lock(v66);
              if (v67)
              {
                long long v68 = v67;
                uint64_t v69 = *(void *)(v286 + 72);
                if (v69)
                {
                  long long v326 = 0u;
                  memset(__str, 0, sizeof(__str));
                  (*(void (**)(std::string *__return_ptr))(*(void *)v69 + 120))(__str);
                  if (BYTE8(v326))
                  {
                    v10[-11].__r_.__value_.__s.__data_[20] = v326;
                    std::string::operator=(v10 - 10, __str);
                  }
                  sub_100CC2860((uint64_t)__str);
                }
                sub_10004D2C8(v68);
              }
            }
            long long v298 = 0u;
            memset(__dst, 0, sizeof(__dst));
            sub_100E63EA4((uint64_t)__dst);
            (***(void (****)(std::string *__return_ptr))(v286 + 56))(__str);
            ServiceMap = (std::mutex *)Registry::getServiceMap(v70, (Registry *)__str[0].__r_.__value_.__l.__data_);
            uint64_t v72 = ServiceMap;
            if (v73 < 0)
            {
              long long v74 = (unsigned __int8 *)(v73 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v75 = 5381;
              do
              {
                uint64_t v73 = v75;
                unsigned int v76 = *v74++;
                uint64_t v75 = (33 * v75) ^ v76;
              }
              while (v76);
            }
            std::mutex::lock(ServiceMap);
            *(void *)long long buf = v73;
            long long v77 = sub_10004D37C(&v72[1].__m_.__sig, (unint64_t *)buf);
            if (v77)
            {
              uint64_t v78 = v77[3];
              long long v79 = (std::__shared_weak_count *)v77[4];
              if (v79)
              {
                atomic_fetch_add_explicit(&v79->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v72);
                atomic_fetch_add_explicit(&v79->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v79);
                char v80 = 0;
                goto LABEL_150;
              }
            }
            else
            {
              uint64_t v78 = 0;
            }
            std::mutex::unlock(v72);
            long long v79 = 0;
            char v80 = 1;
LABEL_150:
            if (__str[0].__r_.__value_.__l.__size_) {
              sub_10004D2C8((std::__shared_weak_count *)__str[0].__r_.__value_.__l.__size_);
            }
            int v81 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v78 + 304))(v78, v8 + 72);
            char v82 = v81;
            char v283 = v80;
            if (v81)
            {
              char v83 = *(std::__shared_weak_count **)(v286 + 80);
              if (v83)
              {
                uint64_t v84 = std::__shared_weak_count::lock(v83);
                if (v84)
                {
                  long long v85 = v84;
                  uint64_t v86 = *(void *)(v286 + 72);
                  if (v86)
                  {
                    bzero(__str, 0x4E8uLL);
                    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v86 + 104))(__str, v86, v8 + 72);
                    if (v351)
                    {
                      std::string::operator=((std::string *)((char *)v10 - 112), (const std::string *)v331);
                      std::string::operator=((std::string *)((char *)v10 - 88), (const std::string *)&v331[24]);
                      if (!__str[0].__r_.__value_.__s.__data_[4]) {
                        goto LABEL_196;
                      }
                      uint64_t v87 = *(unsigned __int8 *)(v8 + 95);
                      if ((v87 & 0x80u) == 0) {
                        uint64_t v88 = *(unsigned __int8 *)(v8 + 95);
                      }
                      else {
                        uint64_t v88 = *(void *)(v8 + 80);
                      }
                      uint64_t v89 = v350;
                      if ((v350 & 0x80u) != 0) {
                        uint64_t v89 = v349;
                      }
                      if (v88 != v89) {
                        goto LABEL_196;
                      }
                      if ((v350 & 0x80u) == 0) {
                        uint64_t v90 = &v348;
                      }
                      else {
                        uint64_t v90 = v348;
                      }
                      if ((v87 & 0x80) != 0)
                      {
                        if (memcmp(*v14, v90, *(void *)(v8 + 80))) {
                          goto LABEL_196;
                        }
                        goto LABEL_197;
                      }
                      if (!*(unsigned char *)(v8 + 95)) {
                        goto LABEL_197;
                      }
                      uint64_t v91 = 0;
                      while (*(unsigned __int8 *)(v8 + v91 + 72) == *((unsigned __int8 *)v90 + v91))
                      {
                        if (v87 == ++v91) {
                          goto LABEL_197;
                        }
                      }
LABEL_196:
                      if (sub_10010E128(v269, (void **)(v8 + 72))) {
LABEL_197:
                      }
                        v10[-11].__r_.__value_.__s.__data_[20] = 4;
                      std::string::operator=((std::string *)((char *)v10 - 32), (const std::string *)((char *)&v336 + 8));
                      uint64_t v97 = __dst[23];
                      if (__dst[23] < 0) {
                        uint64_t v97 = *(void *)&__dst[8];
                      }
                      if (!v97) {
                        std::string::operator=((std::string *)__dst, &__str[1]);
                      }
                    }
                    else
                    {
                      char v92 = *(NSObject **)(v286 + 40);
                      if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I cannot apply previous label. PendingTranferItem is gone", buf, 2u);
                      }
                      v287 = 0;
                      v288 = 0;
                      uint64_t v289 = 0;
                      (*(void (**)(uint64_t, Registry **))(*(void *)v78 + 160))(v78, &v287);
                      if (v287 != v288)
                      {
                        memset(buf, 0, 24);
                        ctu::cf::assign();
                        std::string::size_type v93 = *(void *)buf;
                        v324[0] = *(void *)&buf[8];
                        *(void *)((char *)v324 + 7) = *(void *)&buf[15];
                        uint8_t v94 = buf[23];
                        if (v10[-3].__r_.__value_.__s.__data_[7] < 0) {
                          operator delete((void *)v10[-4].__r_.__value_.__l.__size_);
                        }
                        v10[-4].__r_.__value_.__l.__size_ = v93;
                        v10[-4].__r_.__value_.__r.__words[2] = v324[0];
                        *(std::string::size_type *)((char *)&v10[-4].__r_.__value_.__r.__words[2] + 7) = *(void *)((char *)v324 + 7);
                        v10[-3].__r_.__value_.__s.__data_[7] = v94;
                        memset(buf, 0, 24);
                        ctu::cf::assign();
                        std::string::size_type v95 = *(void *)buf;
                        v324[0] = *(void *)&buf[8];
                        *(void *)((char *)v324 + 7) = *(void *)&buf[15];
                        uint8_t v96 = buf[23];
                        if (v10[-4].__r_.__value_.__s.__data_[7] < 0) {
                          operator delete((void *)v10[-5].__r_.__value_.__l.__size_);
                        }
                        v10[-5].__r_.__value_.__l.__size_ = v95;
                        v10[-5].__r_.__value_.__r.__words[2] = v324[0];
                        *(std::string::size_type *)((char *)&v10[-5].__r_.__value_.__r.__words[2] + 7) = *(void *)((char *)v324 + 7);
                        v10[-4].__r_.__value_.__s.__data_[7] = v96;
                      }
                      *(void *)long long buf = &v287;
                      sub_100CC28AC((void ***)buf);
                    }
                    if (v351) {
                      sub_10030D10C((uint64_t)__str);
                    }
                  }
                  sub_10004D2C8(v85);
                }
              }
            }
            else
            {
              if (*(char *)(v8 + 95) < 0)
              {
                sub_10004FC84(buf, *(void **)(v8 + 72), *(void *)(v8 + 80));
              }
              else
              {
                *(_OWORD *)long long buf = *(_OWORD *)v14;
                *(void *)&uint8_t buf[16] = *(void *)(v8 + 88);
              }
              (*(void (**)(std::string *__return_ptr, uint64_t, uint8_t *))(*(void *)v78 + 168))(__str, v78, buf);
              std::string::operator=((std::string *)((char *)v10 - 112), __str);
              std::string::operator=((std::string *)((char *)v10 - 88), &__str[1]);
              std::string::operator=((std::string *)((char *)v10 - 64), (const std::string *)&v326);
              v10[-2].__r_.__value_.__s.__data_[8] = BYTE8(v327[0]);
              std::string::operator=((std::string *)((char *)v10 - 32), (const std::string *)&v327[1]);
              if (SBYTE7(__p) < 0) {
                operator delete(*(void **)&v327[1]);
              }
              if (SBYTE7(v327[0]) < 0) {
                operator delete((void *)v326);
              }
              if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str[1].__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str[0].__r_.__value_.__l.__data_);
              }
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
            }
            (***(void (****)(std::string *__return_ptr))(v286 + 56))(__str);
            unsigned int v99 = (std::mutex *)Registry::getServiceMap(v98, (Registry *)__str[0].__r_.__value_.__l.__data_);
            unint64_t v100 = v99;
            if (v101 < 0)
            {
              uint64_t v102 = (unsigned __int8 *)(v101 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v103 = 5381;
              do
              {
                uint64_t v101 = v103;
                unsigned int v104 = *v102++;
                uint64_t v103 = (33 * v103) ^ v104;
              }
              while (v104);
            }
            std::mutex::lock(v99);
            *(void *)long long buf = v101;
            long long v105 = sub_10004D37C(&v100[1].__m_.__sig, (unint64_t *)buf);
            if (v105)
            {
              uint64_t v106 = v105[3];
              long long v107 = (std::__shared_weak_count *)v105[4];
              if (v107)
              {
                atomic_fetch_add_explicit(&v107->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v100);
                atomic_fetch_add_explicit(&v107->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v107);
                char v108 = 0;
                goto LABEL_213;
              }
            }
            else
            {
              uint64_t v106 = 0;
            }
            std::mutex::unlock(v100);
            long long v107 = 0;
            char v108 = 1;
LABEL_213:
            if (__str[0].__r_.__value_.__l.__size_) {
              sub_10004D2C8((std::__shared_weak_count *)__str[0].__r_.__value_.__l.__size_);
            }
            if (v106)
            {
              (*(void (**)(std::string *__return_ptr, uint64_t, unsigned char *))(*(void *)v106 + 24))(__str, v106, __dst);
              p_size_t size = (void **)&v10[-6].__r_.__value_.__l.__size_;
              if (v10[-5].__r_.__value_.__s.__data_[7] < 0) {
                operator delete(*p_size);
              }
              long long v110 = *(_OWORD *)&__str[0].__r_.__value_.__l.__data_;
              v10[-5].__r_.__value_.__r.__words[0] = __str[0].__r_.__value_.__r.__words[2];
              *(_OWORD *)p_size_t size = v110;
              if (v10[-1].__r_.__value_.__s.__data_[15] < 0)
              {
                if (!v10[-1].__r_.__value_.__r.__words[0]) {
                  goto LABEL_249;
                }
LABEL_220:
                sub_100CD6B88((const void **)&v10[-2].__r_.__value_.__r.__words[2], (uint64_t)&v10[-6].__r_.__value_.__l.__size_, (uint64_t)__str);
                long long v111 = (void **)&v10[-7].__r_.__value_.__l.__size_;
                if (v10[-6].__r_.__value_.__s.__data_[7] < 0) {
                  operator delete(*v111);
                }
                long long v112 = *(_OWORD *)&__str[0].__r_.__value_.__l.__data_;
                v10[-6].__r_.__value_.__r.__words[0] = __str[0].__r_.__value_.__r.__words[2];
                *(_OWORD *)long long v111 = v112;
                if (v108)
                {
LABEL_227:
                  char v114 = sub_100046F68((uint64_t)v280, (void **)(v8 + 72));
                  if (v278 != v114)
                  {
                    if (!*v11) {
                      __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
                    }
                    long long v115 = v114;
                    uint64_t v116 = (uint64_t)(v114 + 7);
                    std::string::operator=(v10 - 33, (const std::string *)(v114 + 7));
                    if (*(_DWORD *)v8 == 2) {
                      unsigned int v117 = *((_DWORD *)v115 + 44) | 0x80000000;
                    }
                    else {
                      unsigned int v117 = *((_DWORD *)v115 + 44);
                    }
                    LODWORD(v10[-1].__r_.__value_.__r.__words[2]) = v117;
                    int v118 = sub_100CB9424(v286, v116, v82);
                    HIDWORD(v10[-11].__r_.__value_.__r.__words[1]) = v118;
                    v10[-11].__r_.__value_.__s.__data_[8] = v118 & 1;
                    long long v119 = *(std::__shared_weak_count **)(v286 + 80);
                    if (v119)
                    {
                      long long v120 = std::__shared_weak_count::lock(v119);
                      if (v120)
                      {
                        long long v121 = v120;
                        uint64_t v122 = *(void *)(v286 + 72);
                        if (v122)
                        {
                          memset(__str, 0, 32);
                          sub_100CB94C4(__str, (uint64_t)&v10[-35].__r_.__value_.__r.__words[2]);
                          if (__str[0].__r_.__value_.__s.__data_[0])
                          {
                            long long v123 = sub_100CB9540(__str);
                            LODWORD(v10[-11].__r_.__value_.__r.__words[2]) = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v122 + 200))(v122, v123);
                            if (__str[0].__r_.__value_.__s.__data_[0])
                            {
                              if (__str[1].__r_.__value_.__s.__data_[7] < 0) {
                                operator delete((void *)__str[0].__r_.__value_.__l.__size_);
                              }
                            }
                          }
                        }
                        sub_10004D2C8(v121);
                      }
                    }
                  }
                  if ((v283 & 1) == 0) {
                    sub_10004D2C8(v79);
                  }
                  uint64_t v2 = v286;
                  uint64_t v7 = v277;
                  if (SHIBYTE(v298) < 0) {
                    operator delete(*(void **)&__dst[24]);
                  }
                  if ((__dst[23] & 0x80000000) != 0) {
                    operator delete(*(void **)__dst);
                  }
                  goto LABEL_246;
                }
              }
              else
              {
                if (v10[-1].__r_.__value_.__s.__data_[15]) {
                  goto LABEL_220;
                }
LABEL_249:
                memset(v327, 0, sizeof(v327));
                long long v326 = 0u;
                memset(__str, 0, sizeof(__str));
                sub_100CA6DF4((char *)__str, v286, *(_DWORD *)v8);
                if (BYTE8(v327[1]))
                {
                  sub_100CD6B88((const void **)&__str[1].__r_.__value_.__l.__data_, (uint64_t)&v10[-6].__r_.__value_.__l.__size_, (uint64_t)buf);
                  std::string::size_type v124 = (void **)&v10[-7].__r_.__value_.__l.__size_;
                  if (v10[-6].__r_.__value_.__s.__data_[7] < 0) {
                    operator delete(*v124);
                  }
                  long long v125 = *(_OWORD *)buf;
                  v10[-6].__r_.__value_.__r.__words[0] = *(void *)&buf[16];
                  *(_OWORD *)std::string::size_type v124 = v125;
                }
                sub_100CC2224((uint64_t)__str);
                if (v108) {
                  goto LABEL_227;
                }
              }
            }
            else
            {
              long long v113 = *(NSObject **)(v286 + 40);
              if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR))
              {
                uint64_t v126 = (const void *)(v8 + 72);
                if (*(char *)(v8 + 95) < 0) {
                  uint64_t v126 = *v14;
                }
                LODWORD(__str[0].__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)__str[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v126;
                _os_log_error_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_ERROR, "IsoMccCacheInterface does not exist, plan %s can't get formatted phone number", (uint8_t *)__str, 0xCu);
              }
              std::string::operator=((std::string *)((char *)v10 - 160), (std::string *)((char *)v10 - 32));
              if (v108) {
                goto LABEL_227;
              }
            }
            sub_10004D2C8(v107);
            goto LABEL_227;
          }
        }
        else if (*(unsigned char *)(v8 + 95))
        {
          goto LABEL_15;
        }
      }
LABEL_246:
      v8 += 168;
    }
    while (v8 != v7);
  }
  uint64_t v127 = *(void *)(v2 + 136);
  uint64_t v270 = *(void *)(v2 + 144);
  if (v127 != v270)
  {
    v263 = (const void **)(v2 + 440);
    long long v261 = (const void **)(v2 + 384);
    v266 = (const void **)(v2 + 872);
    uint64_t v264 = v2 + 368;
    char v265 = (const void **)(v2 + 840);
    v271 = (std::string *)(v2 + 272);
    v272 = (std::string *)(v2 + 264);
    v267 = (std::string *)(v2 + 328);
    v268 = (const void **)(v2 + 1136);
    while (1)
    {
      if (*(unsigned char *)(v127 + 80))
      {
        uint64_t v129 = *(void *)(v127 + 56);
        uint64_t v128 = *(void *)(v127 + 64);
        if (v129 != v128) {
          break;
        }
      }
LABEL_490:
      v127 += 88;
      if (v127 == v270) {
        goto LABEL_491;
      }
    }
    uint64_t v284 = v127;
    uint64_t v279 = *(void *)(v127 + 64);
    while (1)
    {
      if (*(unsigned char *)(v129 + 88)) {
        goto LABEL_483;
      }
      long long v130 = (const void **)(v129 + 16);
      if (sub_100CA6CF8(v2, (unsigned __int8 **)(v129 + 16))) {
        goto LABEL_483;
      }
      if (*(unsigned char *)(v2 + 752))
      {
        uint64_t v131 = *(unsigned __int8 *)(v2 + 463);
        if ((v131 & 0x80u) == 0) {
          uint64_t v132 = *(unsigned __int8 *)(v2 + 463);
        }
        else {
          uint64_t v132 = *(void *)(v2 + 448);
        }
        uint64_t v133 = *(unsigned __int8 *)(v129 + 39);
        int v134 = (char)v133;
        if ((v133 & 0x80u) != 0) {
          uint64_t v133 = *(void *)(v129 + 24);
        }
        if (v132 == v133)
        {
          if (v134 >= 0) {
            uint32_t v135 = (unsigned __int8 *)(v129 + 16);
          }
          else {
            uint32_t v135 = (unsigned __int8 *)*v130;
          }
          if ((v131 & 0x80) != 0)
          {
            if (!memcmp(*v263, v135, *(void *)(v2 + 448))) {
              goto LABEL_483;
            }
          }
          else
          {
            if (!*(unsigned char *)(v2 + 463)) {
              goto LABEL_483;
            }
            char v136 = v263;
            while (*(unsigned __int8 *)v136 == *v135)
            {
              char v136 = (const void **)((char *)v136 + 1);
              ++v135;
              if (!--v131) {
                goto LABEL_483;
              }
            }
          }
        }
      }
      uint64_t v137 = v294;
      if ((unint64_t)v294 >= v295)
      {
        uint64_t v138 = (std::string *)sub_1003DC28C((uint64_t *)&v293);
      }
      else
      {
        bzero(v294, 0x338uLL);
        sub_1003DC3A8((uint64_t)v137);
        uint64_t v138 = (std::string *)((char *)v137 + 824);
      }
      v294 = v138;
      v332 = 0;
      uint64_t v333 = 0;
      char v335 = 0;
      uint64_t v334 = 0;
      long long v336 = 0u;
      long long v337 = 0u;
      uint64_t v338 = 0;
      memset(__str, 0, sizeof(__str));
      long long v326 = 0u;
      memset(v327, 0, 28);
      long long __p = 0u;
      long long v329 = 0u;
      long long v330 = 0u;
      memset(v331, 0, sizeof(v331));
      char v339 = 2;
      uint64_t v341 = 0;
      uint64_t v342 = 0;
      int v343 = 0;
      v340 = 0;
      uint64_t v139 = v138 - 29;
      long long v344 = 0u;
      long long v345 = 0u;
      memset(v346, 0, sizeof(v346));
      char v347 = 0;
      sub_1003DD760(&v138[-29], (uint64_t)__str);
      *(void *)std::string __dst = (char *)&v346[1] + 8;
      sub_10030FEEC((void ***)__dst);
      *(void *)std::string __dst = v346;
      sub_100047F64((void ***)__dst);
      if (SBYTE7(v345) < 0) {
        operator delete((void *)v344);
      }
      if (SHIBYTE(v342) < 0) {
        operator delete(v340);
      }
      if (SHIBYTE(v338) < 0) {
        operator delete((void *)v337);
      }
      if (SHIBYTE(v334) < 0) {
        operator delete(v332);
      }
      sub_1000C584C((uint64_t)__str);
      if (!v139->__r_.__value_.__s.__data_[0]) {
        goto LABEL_524;
      }
      *(_OWORD *)&v138[-29].__r_.__value_.__r.__words[1] = *(_OWORD *)v129;
      std::string::operator=(v138 - 28, (const std::string *)(v129 + 16));
      std::string::operator=(v138 - 27, (const std::string *)(v129 + 40));
      std::string::operator=(v138 - 26, (const std::string *)(v129 + 64));
      LODWORD(v138[-25].__r_.__value_.__l.__data_) = *(_DWORD *)(v129 + 88);
      std::string::operator=((std::string *)((char *)v138 - 592), (const std::string *)(v129 + 96));
      std::string::operator=((std::string *)((char *)v138 - 568), (const std::string *)(v129 + 120));
      std::string::operator=((std::string *)((char *)v138 - 544), (const std::string *)(v129 + 144));
      std::string::operator=((std::string *)((char *)v138 - 520), (const std::string *)(v129 + 168));
      std::string::operator=((std::string *)((char *)v138 - 496), (const std::string *)(v129 + 192));
      if (!v139->__r_.__value_.__s.__data_[0]) {
LABEL_524:
      }
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      v282 = (std::string *)((char *)v138 - 464);
      std::string::operator=((std::string *)((char *)v138 - 464), (const std::string *)(v129 + 16));
      (***(void (****)(uint8_t *__return_ptr))(v2 + 56))(buf);
      uint64_t v141 = (std::mutex *)Registry::getServiceMap(v140, *(Registry **)buf);
      int v142 = v141;
      if (v143 < 0)
      {
        char v144 = (unsigned __int8 *)(v143 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v145 = 5381;
        do
        {
          uint64_t v143 = v145;
          unsigned int v146 = *v144++;
          uint64_t v145 = (33 * v145) ^ v146;
        }
        while (v146);
      }
      std::mutex::lock(v141);
      *(void *)std::string __dst = v143;
      uint64_t v147 = sub_10004D37C(&v142[1].__m_.__sig, (unint64_t *)__dst);
      if (v147)
      {
        uint64_t v149 = v147[3];
        int v148 = (std::__shared_weak_count *)v147[4];
        if (v148)
        {
          atomic_fetch_add_explicit(&v148->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v142);
          atomic_fetch_add_explicit(&v148->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v148);
          char v150 = 0;
          goto LABEL_303;
        }
      }
      else
      {
        uint64_t v149 = 0;
      }
      std::mutex::unlock(v142);
      int v148 = 0;
      char v150 = 1;
LABEL_303:
      if (*(char *)(v129 + 39) < 0)
      {
        sub_10004FC84(__dst, *(void **)(v129 + 16), *(void *)(v129 + 24));
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)v130;
        *(void *)&__dst[16] = *(void *)(v129 + 32);
      }
      (*(void (**)(std::string *__return_ptr, uint64_t, unsigned char *))(*(void *)v149 + 168))(__str, v149, __dst);
      std::string::operator=((std::string *)((char *)v138 - 112), __str);
      std::string::operator=((std::string *)((char *)v138 - 88), &__str[1]);
      std::string::operator=((std::string *)((char *)v138 - 64), (const std::string *)&v326);
      v138[-2].__r_.__value_.__s.__data_[8] = BYTE8(v327[0]);
      std::string::operator=((std::string *)((char *)v138 - 32), (const std::string *)&v327[1]);
      if (SBYTE7(__p) < 0) {
        operator delete(*(void **)&v327[1]);
      }
      if (SBYTE7(v327[0]) < 0) {
        operator delete((void *)v326);
      }
      if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str[1].__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str[0].__r_.__value_.__l.__data_);
      }
      if ((__dst[23] & 0x80000000) == 0)
      {
        if (v150) {
          goto LABEL_317;
        }
LABEL_316:
        sub_10004D2C8(v148);
        goto LABEL_317;
      }
      operator delete(*(void **)__dst);
      if ((v150 & 1) == 0) {
        goto LABEL_316;
      }
LABEL_317:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      v138[-11].__r_.__value_.__s.__data_[3] = 1;
      uint64_t v151 = *(unsigned __int8 *)(v286 + 1159);
      if ((v151 & 0x80u) == 0) {
        uint64_t v152 = *(unsigned __int8 *)(v286 + 1159);
      }
      else {
        uint64_t v152 = *(void *)(v286 + 1144);
      }
      uint64_t v153 = *(unsigned __int8 *)(v129 + 39);
      int v154 = (char)v153;
      if ((v153 & 0x80u) != 0) {
        uint64_t v153 = *(void *)(v129 + 24);
      }
      if (v152 == v153)
      {
        if (v154 >= 0) {
          v155 = (unsigned __int8 *)(v129 + 16);
        }
        else {
          v155 = (unsigned __int8 *)*v130;
        }
        if ((v151 & 0x80) != 0)
        {
          if (!memcmp(*v268, v155, *(void *)(v286 + 1144)))
          {
LABEL_338:
            int v157 = 14;
            goto LABEL_339;
          }
        }
        else
        {
          if (!*(unsigned char *)(v286 + 1159)) {
            goto LABEL_338;
          }
          uint64_t v156 = v268;
          while (*(unsigned __int8 *)v156 == *v155)
          {
            uint64_t v156 = (const void **)((char *)v156 + 1);
            ++v155;
            if (!--v151) {
              goto LABEL_338;
            }
          }
        }
      }
      int v157 = 0;
LABEL_339:
      HIDWORD(v138[-1].__r_.__value_.__r.__words[2]) = v157;
      int v158 = *(_DWORD *)(v284 + 4);
      if (v158 != 1)
      {
        int v158 = *(_DWORD *)v284;
        if (*(_DWORD *)v284 == 1) {
          goto LABEL_344;
        }
        if (v158 != 2)
        {
          uint64_t v159 = *(NSObject **)(v286 + 40);
          if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__str[0].__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I No type in info - defaulting to legacy Vinyl", (uint8_t *)__str, 2u);
          }
LABEL_344:
          int v158 = 3;
        }
      }
      LODWORD(v138[-7].__r_.__value_.__l.__data_) = v158;
      v138[-11].__r_.__value_.__s.__data_[4] = 1;
      if (*(unsigned char *)(v286 + 416)
        && (*(unsigned int (**)(void))(**(void **)(v286 + 56) + 80))(*(void *)(v286 + 56)) == *(_DWORD *)(v284 + 4))
      {
        sub_1002EF958((uint64_t)__str);
        if (sub_1003D5918(v264, (uint64_t)__str))
        {
          if (__str[1].__r_.__value_.__s.__data_[15] < 0) {
            operator delete((void *)__str[0].__r_.__value_.__r.__words[2]);
          }
LABEL_373:
          HIDWORD(v138[-1].__r_.__value_.__r.__words[2]) = 8;
          goto LABEL_374;
        }
        uint64_t v160 = *(unsigned __int8 *)(v286 + 407);
        if ((v160 & 0x80u) == 0) {
          uint64_t v161 = *(unsigned __int8 *)(v286 + 407);
        }
        else {
          uint64_t v161 = *(void *)(v286 + 392);
        }
        uint64_t v162 = *(unsigned __int8 *)(v129 + 39);
        int v163 = (char)v162;
        if ((v162 & 0x80u) != 0) {
          uint64_t v162 = *(void *)(v129 + 24);
        }
        if (v161 == v162)
        {
          if (v163 >= 0) {
            uint64_t v164 = (unsigned __int8 *)(v129 + 16);
          }
          else {
            uint64_t v164 = (unsigned __int8 *)*v130;
          }
          if ((v160 & 0x80) != 0)
          {
            BOOL v172 = memcmp(*v261, v164, *(void *)(v286 + 392)) == 0;
          }
          else if (*(unsigned char *)(v286 + 407))
          {
            uint64_t v165 = v160 - 1;
            unint64_t v166 = v261;
            do
            {
              int v168 = *(unsigned __int8 *)v166;
              unint64_t v166 = (const void **)((char *)v166 + 1);
              int v167 = v168;
              int v170 = *v164++;
              int v169 = v170;
              BOOL v27 = v165-- != 0;
              char v171 = v27;
              BOOL v172 = v167 == v169;
            }
            while (v167 == v169 && (v171 & 1) != 0);
          }
          else
          {
            BOOL v172 = 1;
          }
        }
        else
        {
          BOOL v172 = 0;
        }
        if ((__str[1].__r_.__value_.__s.__data_[15] & 0x80000000) == 0)
        {
          if (!v172) {
            goto LABEL_374;
          }
          goto LABEL_373;
        }
        operator delete((void *)__str[0].__r_.__value_.__r.__words[2]);
        if (v172) {
          goto LABEL_373;
        }
      }
LABEL_374:
      uint64_t v173 = sub_10010E128((uint64_t)&v290, (void **)(v129 + 16));
      v138[-11].__r_.__value_.__s.__data_[2] = v173 != 0;
      if (!v173) {
        goto LABEL_409;
      }
      size_t v174 = *(unsigned __int8 *)(v129 + 39);
      size_t v175 = *(void *)(v129 + 24);
      if ((v174 & 0x80u) == 0) {
        uint64_t v176 = *(unsigned __int8 *)(v129 + 39);
      }
      else {
        uint64_t v176 = *(void *)(v129 + 24);
      }
      uint64_t v177 = *(unsigned __int8 *)(v286 + 895);
      int v178 = (char)v177;
      if ((v177 & 0x80u) != 0) {
        uint64_t v177 = *(void *)(v286 + 880);
      }
      if (v176 == v177)
      {
        if (v178 >= 0) {
          uint64_t v179 = (unsigned __int8 *)v266;
        }
        else {
          uint64_t v179 = (unsigned __int8 *)*v266;
        }
        if ((v174 & 0x80) != 0)
        {
          if (memcmp(*v130, v179, *(void *)(v129 + 24))) {
            goto LABEL_392;
          }
LABEL_391:
          v138[-11].__r_.__value_.__s.__data_[5] = 1;
          size_t v174 = *(unsigned __int8 *)(v129 + 39);
          size_t v175 = *(void *)(v129 + 24);
          goto LABEL_392;
        }
        if (!*(unsigned char *)(v129 + 39)) {
          goto LABEL_391;
        }
        uint64_t v180 = 0;
        while (*(unsigned __int8 *)(v129 + v180 + 16) == v179[v180])
        {
          if (v174 == ++v180) {
            goto LABEL_391;
          }
        }
      }
LABEL_392:
      if ((v174 & 0x80u) == 0) {
        size_t v181 = v174;
      }
      else {
        size_t v181 = v175;
      }
      uint64_t v182 = *(unsigned __int8 *)(v286 + 863);
      int v183 = (char)v182;
      if ((v182 & 0x80u) != 0) {
        uint64_t v182 = *(void *)(v286 + 848);
      }
      if (v181 == v182)
      {
        if (v183 >= 0) {
          int v184 = (unsigned __int8 *)v265;
        }
        else {
          int v184 = (unsigned __int8 *)*v265;
        }
        if ((v174 & 0x80) != 0)
        {
          if (memcmp(*v130, v184, v175)) {
            goto LABEL_409;
          }
LABEL_408:
          v138[-11].__r_.__value_.__s.__data_[6] = 1;
          goto LABEL_409;
        }
        if (!v174) {
          goto LABEL_408;
        }
        uint64_t v185 = 0;
        while (*(unsigned __int8 *)(v129 + v185 + 16) == v184[v185])
        {
          if (v174 == ++v185) {
            goto LABEL_408;
          }
        }
      }
LABEL_409:
      (***(void (****)(std::string *__return_ptr))(v286 + 56))(__str);
      v187 = (std::mutex *)Registry::getServiceMap(v186, (Registry *)__str[0].__r_.__value_.__l.__data_);
      CFTypeID v188 = v187;
      if (v189 < 0)
      {
        uint64_t v190 = (unsigned __int8 *)(v189 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v191 = 5381;
        do
        {
          uint64_t v189 = v191;
          unsigned int v192 = *v190++;
          uint64_t v191 = (33 * v191) ^ v192;
        }
        while (v192);
      }
      std::mutex::lock(v187);
      *(void *)std::string __dst = v189;
      size_t v193 = sub_10004D37C(&v188[1].__m_.__sig, (unint64_t *)__dst);
      if (!v193)
      {
        uint64_t v195 = 0;
LABEL_416:
        std::mutex::unlock(v188);
        size_t v194 = 0;
        char v196 = 1;
        goto LABEL_417;
      }
      uint64_t v195 = v193[3];
      size_t v194 = (std::__shared_weak_count *)v193[4];
      if (!v194) {
        goto LABEL_416;
      }
      atomic_fetch_add_explicit(&v194->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v188);
      atomic_fetch_add_explicit(&v194->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v194);
      char v196 = 0;
LABEL_417:
      if (__str[0].__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)__str[0].__r_.__value_.__l.__size_);
      }
      if (v195)
      {
        (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v195 + 24))(__str, v195, v129 + 96);
        v197 = (void **)&v138[-6].__r_.__value_.__l.__size_;
        if (v138[-5].__r_.__value_.__s.__data_[7] < 0) {
          operator delete(*v197);
        }
        long long v198 = *(_OWORD *)&__str[0].__r_.__value_.__l.__data_;
        v138[-5].__r_.__value_.__r.__words[0] = __str[0].__r_.__value_.__r.__words[2];
        *(_OWORD *)v197 = v198;
        sub_100CD6B88((const void **)&v138[-2].__r_.__value_.__r.__words[2], (uint64_t)&v138[-6].__r_.__value_.__l.__size_, (uint64_t)__str);
        uint64_t v199 = (void **)&v138[-7].__r_.__value_.__l.__size_;
        if (v138[-6].__r_.__value_.__s.__data_[7] < 0) {
          operator delete(*v199);
        }
        long long v200 = *(_OWORD *)&__str[0].__r_.__value_.__l.__data_;
        v138[-6].__r_.__value_.__r.__words[0] = __str[0].__r_.__value_.__r.__words[2];
        *(_OWORD *)uint64_t v199 = v200;
      }
      else
      {
        int v201 = *(NSObject **)(v286 + 40);
        if (os_log_type_enabled(v201, OS_LOG_TYPE_ERROR))
        {
          uint64_t v217 = (const void *)(v129 + 16);
          if (*(char *)(v129 + 39) < 0) {
            uint64_t v217 = *v130;
          }
          LODWORD(__str[0].__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)__str[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v217;
          _os_log_error_impl((void *)&_mh_execute_header, v201, OS_LOG_TYPE_ERROR, "IsoMccCacheInterface does not exist, plan %s can't get formatted phone number", (uint8_t *)__str, 0xCu);
        }
        std::string::operator=((std::string *)((char *)v138 - 160), (std::string *)((char *)v138 - 32));
      }
      if ((v196 & 1) == 0) {
        sub_10004D2C8(v194);
      }
      uint64_t v127 = v284;
      uint64_t v2 = v286;
      unint64_t v202 = *(std::__shared_weak_count **)(v286 + 80);
      uint64_t v128 = v279;
      if (v202)
      {
        v203 = std::__shared_weak_count::lock(v202);
        if (v203)
        {
          v204 = v203;
          uint64_t v205 = *(void *)(v286 + 72);
          if (v205)
          {
            long long v326 = 0u;
            memset(__str, 0, sizeof(__str));
            (*(void (**)(std::string *__return_ptr))(*(void *)v205 + 120))(__str);
            if (BYTE8(v326))
            {
              v138[-11].__r_.__value_.__s.__data_[20] = v326;
              std::string::operator=(v138 - 10, __str);
            }
            sub_100CC2860((uint64_t)__str);
          }
          sub_10004D2C8(v204);
        }
      }
      unsigned int v206 = *(unsigned __int8 *)(v284 + 16) - 89;
      if (v206 <= 8 && ((1 << v206) & 0x181) != 0 || (v262 & 1) == 0)
      {
        if (!v139->__r_.__value_.__s.__data_[0]) {
          goto LABEL_524;
        }
        v138[-25].__r_.__value_.__s.__data_[2] = 1;
      }
      v207 = sub_100046F68((uint64_t)v272, (void **)(v129 + 16));
      if (v271 != (std::string *)v207)
      {
        uint64_t v208 = v207;
        if (*((unsigned char *)v207 + 392))
        {
          if (!v139->__r_.__value_.__s.__data_[0]) {
            goto LABEL_529;
          }
          LODWORD(v138[-20].__r_.__value_.__r.__words[1]) = *((_DWORD *)v207 + 48);
          std::string::operator=(v282, (const std::string *)(v207 + 25));
          long long v209 = *((_OWORD *)v208 + 14);
          v138[-18].__r_.__value_.__l.__size_ = (std::string::size_type)v208[30];
          *(_OWORD *)&v138[-19].__r_.__value_.__r.__words[2] = v209;
          std::string::operator=((std::string *)((char *)v138 - 416), (const std::string *)(v208 + 31));
          v138[-17].__r_.__value_.__s.__data_[16] = *((unsigned char *)v208 + 272);
          std::string::operator=(v138 - 16, (const std::string *)(v208 + 35));
          LODWORD(v138[-15].__r_.__value_.__l.__data_) = *((_DWORD *)v208 + 76);
          std::string::operator=((std::string *)((char *)v138 - 352), (const std::string *)v208 + 13);
          v138[-14].__r_.__value_.__l.__size_ = (std::string::size_type)v208[42];
          if (&v138[-20].__r_.__value_.__r.__words[1] != (std::string::size_type *)(v208 + 24))
          {
            sub_10005CA3C((uint64_t)&v138[-14].__r_.__value_.__r.__words[2], (std::string *)v208[43], (long long *)v208[44], 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)v208[44] - (unsigned char *)v208[43]) >> 3));
            sub_100CC2900((uint64_t *)&v138[-13].__r_.__value_.__r.__words[2], (long long *)v208[46], (long long *)v208[47], 0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)v208[47] - (unsigned char *)v208[46]) >> 3));
          }
        }
        else
        {
          if (!v139->__r_.__value_.__s.__data_[0]
            || (std::string::operator=(v282, (const std::string *)(v129 + 16)), !v139->__r_.__value_.__s.__data_[0]))
          {
LABEL_529:
            __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
          }
          std::string::operator=((std::string *)((char *)v138 - 416), (const std::string *)(v208 + 7));
        }
        if (!v139->__r_.__value_.__s.__data_[0]) {
LABEL_525:
        }
          __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
        int v210 = v138[-15].__r_.__value_.__s.__data_[0];
        if (v210 == 4 || v210 == 2) {
          HIDWORD(v138[-1].__r_.__value_.__r.__words[2]) = 1;
        }
        if (*((unsigned char *)v208 + 592))
        {
          if (*((char *)v208 + 559) < 0)
          {
            if (v208[68]) {
              goto LABEL_462;
            }
          }
          else
          {
            if (!*((unsigned char *)v208 + 559)) {
              goto LABEL_463;
            }
LABEL_462:
            std::string::operator=((std::string *)((char *)v138 - 352), (const std::string *)(v208 + 67));
          }
LABEL_463:
          if (*((unsigned char *)v208 + 456) == 4) {
            HIDWORD(v138[-1].__r_.__value_.__r.__words[2]) = 1;
          }
        }
        if (*(_DWORD *)(v284 + 4) == 2) {
          unsigned int v211 = *((_DWORD *)v208 + 44) | 0x80000000;
        }
        else {
          unsigned int v211 = *((_DWORD *)v208 + 44);
        }
        LODWORD(v138[-1].__r_.__value_.__r.__words[2]) = v211;
        if (v138[-2].__r_.__value_.__s.__data_[7] < 0)
        {
          if (v138[-3].__r_.__value_.__r.__words[2])
          {
LABEL_475:
            HIDWORD(v138[-11].__r_.__value_.__r.__words[1]) = sub_100CB9424(v286, (uint64_t)(v208 + 7), 0);
            std::string::size_type v212 = *(std::__shared_weak_count **)(v286 + 80);
            if (v212)
            {
              char v213 = std::__shared_weak_count::lock(v212);
              if (v213)
              {
                v214 = v213;
                uint64_t v215 = *(void *)(v286 + 72);
                if (v215)
                {
                  memset(__str, 0, 32);
                  sub_100CB94C4(__str, (uint64_t)&v138[-35].__r_.__value_.__r.__words[2]);
                  if (__str[0].__r_.__value_.__s.__data_[0])
                  {
                    uint64_t v216 = sub_100CB9540(__str);
                    LODWORD(v138[-11].__r_.__value_.__r.__words[2]) = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v215 + 200))(v215, v216);
                    if (__str[0].__r_.__value_.__s.__data_[0])
                    {
                      if (__str[1].__r_.__value_.__s.__data_[7] < 0) {
                        operator delete((void *)__str[0].__r_.__value_.__l.__size_);
                      }
                    }
                  }
                }
                sub_10004D2C8(v214);
              }
            }
            goto LABEL_483;
          }
        }
        else if (v138[-2].__r_.__value_.__s.__data_[7])
        {
          goto LABEL_475;
        }
        if (!*(unsigned char *)(v129 + 89))
        {
          if (!v139->__r_.__value_.__s.__data_[0]) {
            goto LABEL_525;
          }
          std::string::operator=((std::string *)((char *)v138 - 112), (std::string *)((char *)v138 - 416));
        }
        goto LABEL_475;
      }
      if (!v139->__r_.__value_.__s.__data_[0]) {
        goto LABEL_525;
      }
      std::string::operator=(v282, (const std::string *)(v129 + 16));
      if (!v139->__r_.__value_.__s.__data_[0]) {
        goto LABEL_525;
      }
      std::string::operator=((std::string *)((char *)v138 - 416), v267);
LABEL_483:
      v129 += 216;
      if (v129 == v128) {
        goto LABEL_490;
      }
    }
  }
LABEL_491:
  uint64_t v219 = (uint64_t)v293;
  std::string::size_type v218 = v294;
  if (v293 == v294)
  {
    int v220 = v293;
  }
  else
  {
    do
    {
      int v220 = (std::string *)(v219 + 824);
      if (*(unsigned char *)(v219 + 580) == 4 && v220 != v218)
      {
        sub_100CC2AD8(v219, v219 + 824);
        uint64_t v222 = v219 + 1648;
        if ((std::string *)(v219 + 1648) != v218)
        {
          uint64_t v223 = v219 + 824;
          do
          {
            sub_100CC2AD8(v222 - 824, v222);
            if (v222 - 824 == v223) {
              uint64_t v223 = v222;
            }
            v222 += 824;
          }
          while ((std::string *)v222 != v218);
          uint64_t v224 = v222 - 824;
          if (v224 != v223)
          {
            uint64_t v225 = v223;
            do
            {
              while (1)
              {
                sub_100CC2AD8(v224, v223);
                v224 += 824;
                v223 += 824;
                if ((std::string *)v223 == v218) {
                  break;
                }
                if (v224 == v225) {
                  uint64_t v225 = v223;
                }
              }
              uint64_t v223 = v225;
            }
            while (v224 != v225);
          }
        }
        std::string::size_type v218 = v294;
      }
      uint64_t v219 = (uint64_t)v220;
    }
    while (v220 != v218);
  }
  if (*(unsigned char *)(v2 + 752) && !*(unsigned char *)(v2 + 208))
  {
    bzero(__str, 0x4E8uLL);
    uint64_t v226 = *(std::__shared_weak_count **)(v2 + 80);
    if (v226)
    {
      v227 = std::__shared_weak_count::lock(v226);
      if (v227)
      {
        uint64_t v285 = *(void *)(v2 + 72);
        if (v285)
        {
          if (*(char *)(v2 + 663) < 0)
          {
            if (*(void *)(v2 + 648)) {
              goto LABEL_532;
            }
          }
          else if (*(unsigned char *)(v2 + 663))
          {
            goto LABEL_532;
          }
          if (*(char *)(v2 + 463) < 0) {
            uint64_t v229 = *(void *)(v2 + 448);
          }
          else {
            uint64_t v229 = *(unsigned __int8 *)(v2 + 463);
          }
          if (!v229)
          {
LABEL_534:
            int v228 = 1;
            goto LABEL_535;
          }
LABEL_532:
          (*(void (**)(unsigned char *__return_ptr))(*(void *)v285 + 104))(__dst);
          sub_100310928((uint64_t)__str, (uint64_t)__dst);
          if (v323) {
            sub_10030D10C((uint64_t)__dst);
          }
          goto LABEL_534;
        }
      }
      int v228 = 0;
    }
    else
    {
      int v228 = 0;
      v227 = 0;
    }
    uint64_t v285 = 0;
LABEL_535:
    uint64_t v230 = v294;
    if ((unint64_t)v294 >= v295)
    {
      v231 = (std::string *)sub_1003DC28C((uint64_t *)&v293);
    }
    else
    {
      bzero(v294, 0x338uLL);
      sub_1003DC3A8((uint64_t)v230);
      v231 = (std::string *)((char *)v230 + 824);
    }
    v294 = v231;
    uint64_t v308 = 0;
    v307 = 0;
    char v310 = 0;
    uint64_t v309 = 0;
    long long v311 = 0u;
    long long v312 = 0u;
    uint64_t v313 = 0;
    memset(__dst, 0, sizeof(__dst));
    long long v298 = 0u;
    memset(v299, 0, 44);
    long long v300 = 0u;
    long long v301 = 0u;
    long long v302 = 0u;
    long long v303 = 0u;
    long long v304 = 0u;
    long long v305 = 0u;
    memset(v306, 0, sizeof(v306));
    char v314 = 2;
    uint64_t v317 = 0;
    int v318 = 0;
    v315 = 0;
    uint64_t v316 = 0;
    uint64_t v232 = v231 - 29;
    long long v319 = 0u;
    long long v320 = 0u;
    memset(v321, 0, sizeof(v321));
    char v322 = 0;
    sub_1003DD760(&v231[-29], (uint64_t)__dst);
    *(void *)long long buf = (char *)&v321[1] + 8;
    sub_10030FEEC((void ***)buf);
    *(void *)long long buf = v321;
    sub_100047F64((void ***)buf);
    if (SBYTE7(v320) < 0) {
      operator delete((void *)v319);
    }
    if (SHIBYTE(v317) < 0) {
      operator delete(v315);
    }
    if (SHIBYTE(v313) < 0) {
      operator delete((void *)v312);
    }
    if (SHIBYTE(v309) < 0) {
      operator delete(v307);
    }
    sub_1000C584C((uint64_t)__dst);
    if (!v232->__r_.__value_.__s.__data_[0]) {
      goto LABEL_628;
    }
    *(_OWORD *)&v231[-29].__r_.__value_.__r.__words[1] = *(_OWORD *)(v286 + 424);
    std::string::operator=(v231 - 28, (const std::string *)(v286 + 440));
    std::string::operator=(v231 - 27, (const std::string *)(v286 + 464));
    std::string::operator=(v231 - 26, (const std::string *)(v286 + 488));
    LODWORD(v231[-25].__r_.__value_.__l.__data_) = *(_DWORD *)(v286 + 512);
    std::string::operator=((std::string *)((char *)v231 - 592), (const std::string *)(v286 + 520));
    std::string::operator=((std::string *)((char *)v231 - 568), (const std::string *)(v286 + 544));
    std::string::operator=((std::string *)((char *)v231 - 544), (const std::string *)(v286 + 568));
    std::string::operator=((std::string *)((char *)v231 - 520), (const std::string *)(v286 + 592));
    std::string::operator=((std::string *)((char *)v231 - 496), (const std::string *)(v286 + 616));
    if (!v232->__r_.__value_.__s.__data_[0]
      || (int v233 = (void **)&v231[-20].__r_.__value_.__r.__words[2],
          std::string::operator=((std::string *)((char *)v231 - 464), (const std::string *)(v286 + 440)),
          !v232->__r_.__value_.__s.__data_[0]))
    {
LABEL_628:
      __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
    }
    std::string::operator=((std::string *)((char *)v231 - 416), (const std::string *)(v286 + 488));
    uint64_t v234 = v286;
    if (v351)
    {
      uint64_t v235 = v350;
      if ((v350 & 0x80u) != 0) {
        uint64_t v235 = v349;
      }
      if (v235)
      {
        sub_100CD6B88((const void **)&v336 + 1, (uint64_t)&v338, (uint64_t)__dst);
        long long v236 = (void **)&v231[-7].__r_.__value_.__l.__size_;
        if (v231[-6].__r_.__value_.__s.__data_[7] < 0) {
          operator delete(*v236);
        }
        long long v237 = *(_OWORD *)__dst;
        v231[-6].__r_.__value_.__r.__words[0] = *(void *)&__dst[16];
        *(_OWORD *)long long v236 = v237;
      }
    }
    uint64_t v238 = *(void *)(v286 + 144);
    do
    {
      if (v238 == *(void *)(v286 + 136))
      {
        v242 = *(NSObject **)(v286 + 40);
        if (os_log_type_enabled(v242, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string __dst = 0;
          _os_log_impl((void *)&_mh_execute_header, v242, OS_LOG_TYPE_DEFAULT, "#I Could not find vinyl info, defaulting to embedded type", __dst, 2u);
        }
        goto LABEL_564;
      }
      int v240 = *(_DWORD *)(v238 - 88);
      v238 -= 88;
      int v239 = v240;
    }
    while (!v240);
    int v241 = *(_DWORD *)(v238 + 4);
    if (v241 == 1) {
      goto LABEL_565;
    }
    if (v239 != 2)
    {
      int v241 = 3;
      goto LABEL_565;
    }
LABEL_564:
    int v241 = 2;
LABEL_565:
    LODWORD(v231[-7].__r_.__value_.__l.__data_) = v241;
    v231[-11].__r_.__value_.__s.__data_[3] = 1;
    if (!v232->__r_.__value_.__s.__data_[0]) {
      goto LABEL_629;
    }
    if (v231[-19].__r_.__value_.__s.__data_[15] < 0)
    {
      if (!v231[-19].__r_.__value_.__r.__words[0]) {
        goto LABEL_577;
      }
    }
    else if (!v231[-19].__r_.__value_.__s.__data_[15])
    {
LABEL_577:
      if (v351)
      {
        uint64_t v254 = v350;
        if ((v350 & 0x80u) != 0) {
          uint64_t v254 = v349;
        }
        if (v254)
        {
          std::string::operator=((std::string *)((char *)v231 - 112), (const std::string *)v331);
          std::string::operator=((std::string *)((char *)v231 - 88), (const std::string *)&v331[24]);
        }
      }
      goto LABEL_602;
    }
    if (*(_DWORD *)(v286 + 788) < 2u) {
      goto LABEL_577;
    }
    v281 = (std::string *)v227;
    (***(void (****)(Registry **__return_ptr))(v286 + 56))(&v287);
    int v244 = (std::mutex *)Registry::getServiceMap(v243, v287);
    std::string v245 = v244;
    if (v246 < 0)
    {
      v247 = (unsigned __int8 *)(v246 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v248 = 5381;
      do
      {
        uint64_t v246 = v248;
        unsigned int v249 = *v247++;
        uint64_t v248 = (33 * v248) ^ v249;
      }
      while (v249);
    }
    std::mutex::lock(v244);
    *(void *)long long buf = v246;
    long long v250 = sub_10004D37C(&v245[1].__m_.__sig, (unint64_t *)buf);
    if (v250)
    {
      uint64_t v252 = v250[3];
      long long v251 = (std::__shared_weak_count *)v250[4];
      if (v251)
      {
        atomic_fetch_add_explicit(&v251->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v245);
        atomic_fetch_add_explicit(&v251->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v234 = v286;
        sub_10004D2C8(v251);
        char v253 = 0;
LABEL_584:
        if (!v232->__r_.__value_.__s.__data_[0]) {
          __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
        }
        if (v231[-19].__r_.__value_.__s.__data_[15] < 0)
        {
          sub_10004FC84(buf, *v233, v231[-19].__r_.__value_.__r.__words[0]);
        }
        else
        {
          long long v255 = *(_OWORD *)v233;
          *(void *)&uint8_t buf[16] = v231[-19].__r_.__value_.__l.__size_;
          *(_OWORD *)long long buf = v255;
        }
        (*(void (**)(unsigned char *__return_ptr, uint64_t, uint8_t *))(*(void *)v252 + 168))(__dst, v252, buf);
        v227 = (std::__shared_weak_count *)v281;
        std::string::operator=((std::string *)((char *)v231 - 112), (const std::string *)__dst);
        std::string::operator=((std::string *)((char *)v231 - 88), (const std::string *)&__dst[24]);
        std::string::operator=((std::string *)((char *)v231 - 64), v299);
        v231[-2].__r_.__value_.__s.__data_[8] = v299[1].__r_.__value_.__s.__data_[0];
        std::string::operator=((std::string *)((char *)v231 - 32), (const std::string *)&v299[1].__r_.__value_.__r.__words[1]);
        if (SBYTE7(v300) < 0) {
          operator delete((void *)v299[1].__r_.__value_.__l.__size_);
        }
        if (SHIBYTE(v299[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v299[0].__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v298) < 0) {
          operator delete(*(void **)&__dst[24]);
        }
        if ((__dst[23] & 0x80000000) != 0) {
          operator delete(*(void **)__dst);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        if ((v253 & 1) == 0) {
          sub_10004D2C8(v251);
        }
        if (v288) {
          sub_10004D2C8((std::__shared_weak_count *)v288);
        }
LABEL_602:
        int v256 = (*(uint64_t (**)(void))(**(void **)(v234 + 56) + 96))(*(void *)(v234 + 56));
        int v257 = *(_DWORD *)(v234 + 664);
        if (v256 == 2) {
          v257 |= 0x80000000;
        }
        LODWORD(v231[-1].__r_.__value_.__r.__words[2]) = v257;
        if (!v228) {
          goto LABEL_617;
        }
        int v258 = (*(uint64_t (**)(uint64_t))(*(void *)v285 + 24))(v285);
        if (v258 == 2)
        {
          HIDWORD(v231[-1].__r_.__value_.__r.__words[2]) = 2;
          if (v232->__r_.__value_.__s.__data_[0])
          {
            v231[-11].__r_.__value_.__s.__data_[2] = sub_10010E128((uint64_t)&v290, (void **)&v231[-28].__r_.__value_.__l.__data_) != 0;
            goto LABEL_613;
          }
        }
        else
        {
          if (v258 != 1)
          {
            if (!v258)
            {
              HIDWORD(v231[-1].__r_.__value_.__r.__words[2]) = 6;
              v231[-11].__r_.__value_.__s.__data_[2] = 1;
            }
            goto LABEL_613;
          }
          HIDWORD(v231[-1].__r_.__value_.__r.__words[2]) = 7;
          if (v232->__r_.__value_.__s.__data_[0])
          {
            v231[-12].__r_.__value_.__s.__data_[16] = 1;
            v231[-11].__r_.__value_.__s.__data_[2] = 1;
LABEL_613:
            memset(__dst, 0, sizeof(__dst));
            sub_100CB94C4((std::string *)__dst, (uint64_t)&v231[-35].__r_.__value_.__r.__words[2]);
            if (__dst[0])
            {
              long long v259 = sub_100CB9540(__dst);
              LODWORD(v231[-11].__r_.__value_.__r.__words[2]) = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v285 + 200))(v285, v259);
              if (__dst[0])
              {
                if ((__dst[31] & 0x80000000) != 0) {
                  operator delete(*(void **)&__dst[8]);
                }
              }
            }
LABEL_617:
            if (v227) {
              sub_10004D2C8(v227);
            }
            if (v351) {
              sub_10030D10C((uint64_t)__str);
            }
            int v220 = v294;
            goto LABEL_622;
          }
        }
LABEL_629:
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
    }
    else
    {
      uint64_t v252 = 0;
    }
    std::mutex::unlock(v245);
    long long v251 = 0;
    char v253 = 1;
    goto LABEL_584;
  }
LABEL_622:
  if (v293 == v220) {
    *a2 = 0;
  }
  else {
    sub_100CCE0B0((uint64_t *)&v293, a2);
  }
  sub_10005CD2C((uint64_t)&v290, v291);
  __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v293;
  sub_1003DCCE8((void ***)__str);
}

void sub_100CB903C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,char *a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,uint64_t a51,uint64_t a52,void *a53)
{
  if (LOBYTE(STACK[0x640])) {
    sub_10030D10C((uint64_t)&a53);
  }
  sub_10004D2C8(v53);
  if (LOBYTE(STACK[0xB40])) {
    sub_10030D10C((uint64_t)&STACK[0x660]);
  }
  sub_10005CD2C((uint64_t)&a43, a44);
  STACK[0x660] = (unint64_t)&a46;
  sub_1003DCCE8((void ***)&STACK[0x660]);
  _Unwind_Resume(a1);
}

uint64_t sub_100CB9424(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t result = 0;
  if ((a3 & 1) == 0 && *(_DWORD *)(a2 + 128) == 2)
  {
    if (*(unsigned char *)(a1 + 340))
    {
      if (_os_feature_enabled_impl()) {
        uint64_t result = 2;
      }
      else {
        uint64_t result = 0;
      }
      if (*(_DWORD *)(a2 + 124) == 2)
      {
        for (uint64_t i = *(int **)(a1 + 136); i != *(int **)(a1 + 144); i += 22)
        {
          int v7 = *i;
          if (i[1] == 3)
          {
            if (!v7) {
              return result;
            }
            return result | 1;
          }
          if (v7) {
            return result | 1;
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

std::string *sub_100CB94C4(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  *(_OWORD *)&result->__r_.__value_.__l.__data_ = 0u;
  *(_OWORD *)&result->__r_.__value_.__r.__words[2] = 0u;
  if (*(unsigned char *)a2) {
    uint64_t result = sub_10032AFC0(result, (const std::string *)(a2 + 8));
  }
  if (*(unsigned char *)(a2 + 128)) {
    return sub_10032AFC0(v3, (const std::string *)(a2 + 152));
  }
  return result;
}

void sub_100CB9518(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)v1)
  {
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    *(unsigned char *)uint64_t v1 = 0;
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100CB9540(unsigned char *a1)
{
  if (!*a1)
  {
    std::logic_error::logic_error(&v2, "Attempted to access the value of an uninitialized optional object.");
    v2.__vftable = (std::logic_error_vtbl *)&off_1019F8AE8;
    sub_10069F65C(&v2);
  }
  return a1 + 8;
}

void sub_100CB95AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::logic_error a9)
{
}

BOOL sub_100CB95C0(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 48)) {
    goto LABEL_28;
  }
  int v4 = *(unsigned __int8 *)(a1 + 416);
  uint64_t v5 = *(NSObject **)(a1 + 40);
  BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (!v4)
  {
    if (result)
    {
      uint64_t v8 = (void *)(a2 + 16);
      if (*(char *)(a2 + 39) < 0) {
        uint64_t v8 = (void *)*v8;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Deleting %s", buf, 0xCu);
    }
    if (!*(void *)(a1 + 88)) {
      goto LABEL_28;
    }
    uint64_t v9 = *(unsigned __int8 *)(a1 + 1159);
    if ((v9 & 0x80u) == 0) {
      uint64_t v10 = *(unsigned __int8 *)(a1 + 1159);
    }
    else {
      uint64_t v10 = *(void *)(a1 + 1144);
    }
    uint64_t v11 = *(unsigned __int8 *)(a2 + 39);
    int v12 = (char)v11;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a2 + 24);
    }
    if (v10 != v11) {
      goto LABEL_28;
    }
    long long v13 = (const void **)(a1 + 1136);
    if (v12 >= 0) {
      unint64_t v14 = (unsigned __int8 *)(a2 + 16);
    }
    else {
      unint64_t v14 = *(unsigned __int8 **)(a2 + 16);
    }
    if ((v9 & 0x80) != 0)
    {
      if (memcmp(*v13, v14, *(void *)(a1 + 1144))) {
        goto LABEL_28;
      }
    }
    else if (*(unsigned char *)(a1 + 1159))
    {
      while (*(unsigned __int8 *)v13 == *v14)
      {
        long long v13 = (const void **)((char *)v13 + 1);
        ++v14;
        if (!--v9) {
          goto LABEL_27;
        }
      }
LABEL_28:
      sub_1002EF958((uint64_t)buf);
      uint64_t v15 = (_OWORD *)(a1 + 368);
      if (*(unsigned char *)(a1 + 416)) {
        int v16 = sub_1003D5918(a1 + 368, (uint64_t)buf);
      }
      else {
        int v16 = 0;
      }
      if (SBYTE7(v32) < 0)
      {
        operator delete(__p[0]);
        if (v16)
        {
LABEL_33:
          BOOL v29 = (_OWORD *)(a1 + 368);
          int v17 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 80))(*(void *)(a1 + 56));
          int v18 = VinylSlotIdFromInt(v17);
          uint64_t v19 = *(void *)(a1 + 136);
          uint64_t v20 = *(void *)(a1 + 144);
          if (v19 != v20)
          {
            int v21 = v18;
            do
            {
              uint64_t v48 = 0;
              long long v46 = 0u;
              long long v47 = 0u;
              long long v45 = 0u;
              memset(v44, 0, sizeof(v44));
              sub_1000C5DA8((uint64_t)v44, v19);
              int v22 = v48;
              if (DWORD1(v44[0]) == v21 && v48 != 0)
              {
                uint64_t v25 = *((void *)&v46 + 1);
                uint64_t v24 = v47;
                while (v25 != v24)
                {
                  uint64_t v43 = 0;
                  long long v41 = 0u;
                  long long v42 = 0u;
                  long long v39 = 0u;
                  long long v40 = 0u;
                  long long v37 = 0u;
                  long long v38 = 0u;
                  long long v35 = 0u;
                  long long v36 = 0u;
                  long long v33 = 0u;
                  long long v34 = 0u;
                  *(_OWORD *)long long __p = 0u;
                  long long v32 = 0u;
                  *(_OWORD *)long long buf = 0u;
                  sub_1000C5AB4((uint64_t)buf, v25);
                  if (!BYTE8(v35)) {
                    sub_100CC470C((void ***)(a1 + 264), __p);
                  }
                  sub_1000C584C((uint64_t)buf);
                  v25 += 216;
                }
                sub_100CA4DAC(a1);
                int v22 = v48;
              }
              if (v22)
              {
                *(void *)long long buf = (char *)&v46 + 8;
                sub_1000C57C8((void ***)buf);
              }
              if (SBYTE7(v46) < 0) {
                operator delete((void *)v45);
              }
              v19 += 88;
            }
            while (v19 != v20);
          }
          goto LABEL_56;
        }
      }
      else if (v16)
      {
        goto LABEL_33;
      }
      int v26 = *(unsigned __int8 *)(a1 + 416);
      if (!*(unsigned char *)(a1 + 416)) {
        goto LABEL_57;
      }
      if (*(unsigned char *)(a2 + 48))
      {
        int v26 = 1;
        goto LABEL_57;
      }
      BOOL v29 = (_OWORD *)(a1 + 368);
      sub_100CC470C((void ***)(a1 + 264), (void **)(a1 + 384));
      sub_100CA4DAC(a1);
LABEL_56:
      int v26 = *(unsigned __int8 *)(a1 + 416);
      uint64_t v15 = v29;
LABEL_57:
      if (v26 == *(unsigned __int8 *)(a2 + 48))
      {
        if (v26)
        {
          _OWORD *v15 = *(_OWORD *)a2;
          std::string::operator=((std::string *)(a1 + 384), (const std::string *)(a2 + 16));
          *(unsigned char *)(a1 + 408) = *(unsigned char *)(a2 + 40);
        }
      }
      else
      {
        if (!v26)
        {
          _OWORD *v15 = *(_OWORD *)a2;
          BOOL v27 = (unsigned char *)(a1 + 384);
          if (*(char *)(a2 + 39) < 0)
          {
            sub_10004FC84(v27, *(void **)(a2 + 16), *(void *)(a2 + 24));
          }
          else
          {
            long long v28 = *(_OWORD *)(a2 + 16);
            *(void *)(a1 + 400) = *(void *)(a2 + 32);
            *(_OWORD *)BOOL v27 = v28;
          }
          *(unsigned char *)(a1 + 408) = *(unsigned char *)(a2 + 40);
          BOOL result = 1;
          *(unsigned char *)(a1 + 416) = 1;
          return result;
        }
        if (*(char *)(a1 + 407) < 0) {
          operator delete(*(void **)(a1 + 384));
        }
        *(unsigned char *)(a1 + 416) = 0;
      }
      return 1;
    }
LABEL_27:
    sub_100CB99E8(a1);
    goto LABEL_28;
  }
  if (result)
  {
    int v7 = (void *)(a1 + 384);
    if (*(char *)(a1 + 407) < 0) {
      int v7 = (void *)*v7;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Profile already deleting: (%s)", buf, 0xCu);
    return 0;
  }
  return result;
}

void sub_100CB99B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CB99E8(uint64_t a1)
{
  (***(void (****)(void **__return_ptr))(a1 + 56))(__p);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, (Registry *)__p[0]);
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v21);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  if (v11) {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v11 + 24))(v11, 256, 0);
  }
  uint64_t v13 = *(void *)(a1 + 120);
  sub_100058DB0(__p, "");
  (*(void (**)(uint64_t, void **, void))(*(void *)v13 + 280))(v13, __p, 0);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v20 = 0;
  if ((*(char *)(a1 + 1159) & 0x80000000) == 0)
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 1136);
    uint64_t v20 = *(void *)(a1 + 1152);
LABEL_18:
    *(unsigned char *)(a1 + 1136) = 0;
    *(unsigned char *)(a1 + 1159) = 0;
    goto LABEL_19;
  }
  sub_10004FC84(__p, *(void **)(a1 + 1136), *(void *)(a1 + 1144));
  if ((*(char *)(a1 + 1159) & 0x80000000) == 0) {
    goto LABEL_18;
  }
  **(unsigned char **)(a1 + 1136) = 0;
  *(void *)(a1 + 1144) = 0;
LABEL_19:
  unint64_t v14 = *(std::__shared_weak_count **)(a1 + 96);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  if (v14) {
    sub_10004D2C8(v14);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 80);
  if (v15)
  {
    int v16 = std::__shared_weak_count::lock(v15);
    if (v16)
    {
      int v17 = v16;
      uint64_t v18 = *(void *)(a1 + 72);
      if (v18) {
        (*(void (**)(uint64_t, void **, void))(*(void *)v18 + 144))(v18, __p, 0);
      }
      sub_10004D2C8(v17);
    }
  }
  if ((SHIBYTE(v20) & 0x80000000) == 0)
  {
    if (v12) {
      return;
    }
    goto LABEL_28;
  }
  operator delete(__p[0]);
  if ((v12 & 1) == 0) {
LABEL_28:
  }
    sub_10004D2C8(v10);
}

void sub_100CB9C5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_10004D2C8(v15);
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(a1);
}

void sub_100CB9CB8(uint64_t *a1, uint64_t a2, uint64_t a3, void **a4)
{
  uint64_t v9 = (void **)(a3 + 8);
  unsigned int v8 = *(void ***)a3;
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1000C6C34(a1, v8, (void **)(a3 + 8));
  memset(&v102, 0, sizeof(v102));
  uint64_t v10 = *(void ***)a3;
  if (*(void ***)a3 == v9) {
    return;
  }
  do
  {
    if (sub_100CB1134(a2, (uint64_t)(v10 + 4)))
    {
      std::string::size_type size = HIBYTE(v102.__r_.__value_.__r.__words[2]);
      int v12 = SHIBYTE(v102.__r_.__value_.__r.__words[2]);
      if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = v102.__r_.__value_.__l.__size_;
      }
      if (size) {
        goto LABEL_202;
      }
      std::string::operator=(&v102, (const std::string *)(v10 + 4));
    }
    uint64_t v13 = (void **)v10[1];
    if (v13)
    {
      do
      {
        unint64_t v14 = v13;
        uint64_t v13 = (void **)*v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        unint64_t v14 = (void **)v10[2];
        BOOL v15 = *v14 == v10;
        uint64_t v10 = v14;
      }
      while (!v15);
    }
    uint64_t v10 = v14;
  }
  while (v14 != v9);
  if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!v102.__r_.__value_.__l.__size_) {
      goto LABEL_203;
    }
    memset(&__dst, 0, sizeof(__dst));
    sub_10004FC84(&__dst, v102.__r_.__value_.__l.__data_, v102.__r_.__value_.__l.__size_);
  }
  else
  {
    if (!*((unsigned char *)&v102.__r_.__value_.__s + 23)) {
      return;
    }
    std::string __dst = v102;
  }
  char v16 = sub_100046F68(a2 + 344, (void **)&__dst.__r_.__value_.__l.__data_);
  if ((void **)(a2 + 352) == v16)
  {
    uint64_t v58 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
      goto LABEL_199;
    }
    *(_WORD *)long long buf = 0;
    char v59 = "Personality not found";
LABEL_143:
    _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, v59, buf, 2u);
    goto LABEL_199;
  }
  if (!*((unsigned char *)v16 + 60))
  {
    uint64_t v58 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
      goto LABEL_199;
    }
    *(_WORD *)long long buf = 0;
    char v59 = "Entitlement authentication response code is not set.";
    goto LABEL_143;
  }
  __int32 v17 = *((_DWORD *)v16 + 14);
  *(_OWORD *)unsigned int v99 = 0u;
  long long v100 = 0u;
  *(_OWORD *)uint64_t v98 = 0u;
  memset(&v97, 0, sizeof(v97));
  memset(&v96, 0, sizeof(v96));
  uint64_t v18 = *(void *)(a2 + 160);
  uint64_t v19 = *(void *)(a2 + 168);
  if (v18 != v19)
  {
    while (1)
    {
      uint64_t v20 = *(unsigned __int8 *)(v18 + 95);
      if ((v20 & 0x80u) == 0) {
        uint64_t v21 = *(unsigned __int8 *)(v18 + 95);
      }
      else {
        uint64_t v21 = *(void *)(v18 + 80);
      }
      std::string::size_type v22 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
      if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v22 = v102.__r_.__value_.__l.__size_;
      }
      if (v21 != v22) {
        goto LABEL_42;
      }
      int v23 = (v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &v102
          : (std::string *)v102.__r_.__value_.__r.__words[0];
      if ((v20 & 0x80) == 0) {
        break;
      }
      if (!memcmp(*(const void **)(v18 + 72), v23, *(void *)(v18 + 80))) {
        goto LABEL_37;
      }
LABEL_42:
      v18 += 168;
      if (v18 == v19) {
        goto LABEL_43;
      }
    }
    if (*(unsigned char *)(v18 + 95))
    {
      uint64_t v24 = 0;
      while (*(unsigned __int8 *)(v18 + v24 + 72) == v23->__r_.__value_.__s.__data_[v24])
      {
        if (v20 == ++v24) {
          goto LABEL_37;
        }
      }
      goto LABEL_42;
    }
LABEL_37:
    sub_100E63EA4((uint64_t)buf);
    sub_10071F624((uint64_t)v98, (long long *)buf);
    if (SHIBYTE(v106) < 0) {
      operator delete(*((void **)&v105 + 1));
    }
    if (SBYTE7(v105) < 0) {
      operator delete(*(void **)buf);
    }
    std::string::operator=(&v97, (const std::string *)(v18 + 120));
    std::string::operator=(&v96, (const std::string *)(v18 + 144));
    goto LABEL_42;
  }
LABEL_43:
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v112 = 0u;
  long long v113 = 0u;
  long long v110 = 0u;
  long long v111 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v105 = 0u;
  sGetProfileDetails();
  if (!BYTE8(v117)) {
    goto LABEL_191;
  }
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a2 + 56) + 328))(&v92);
  uint64_t v25 = v95;
  int v26 = wmemchr((__int32 *)v94, v17, ((char *)v95 - (unsigned char *)v94) >> 2);
  if (v26) {
    BOOL v27 = v26;
  }
  else {
    BOOL v27 = v25;
  }
  if (v27 == v95) {
    goto LABEL_187;
  }
  uint64_t v29 = v92;
  uint64_t v28 = v93;
  if (v92 == v93) {
    goto LABEL_187;
  }
  if (SHIBYTE(v99[0]) >= 0) {
    unint64_t v30 = (void *)HIBYTE(v99[0]);
  }
  else {
    unint64_t v30 = v98[1];
  }
  if (SHIBYTE(v99[0]) >= 0) {
    BOOL v31 = v98;
  }
  else {
    BOOL v31 = (void **)v98[0];
  }
  uint64_t v32 = HIBYTE(v100);
  if (v100 < 0) {
    uint64_t v32 = v100;
  }
  uint64_t v86 = v32;
  uint64_t v87 = v30;
  if (v100 >= 0) {
    long long v33 = &v99[1];
  }
  else {
    long long v33 = (void **)v99[1];
  }
  if ((v97.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v97.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v97.__r_.__value_.__l.__size_;
  }
  if ((v97.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v35 = &v97;
  }
  else {
    long long v35 = (std::string *)v97.__r_.__value_.__r.__words[0];
  }
  if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v36 = HIBYTE(v96.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v36 = v96.__r_.__value_.__l.__size_;
  }
  if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v37 = &v96;
  }
  else {
    long long v37 = (std::string *)v96.__r_.__value_.__r.__words[0];
  }
  uint64_t v88 = v93;
  __s2 = v33;
  while (1)
  {
    uint64_t v38 = *(unsigned __int8 *)(v29 + 47);
    if ((v38 & 0x80u) == 0) {
      long long v39 = (void *)*(unsigned __int8 *)(v29 + 47);
    }
    else {
      long long v39 = *(void **)(v29 + 32);
    }
    if (v39 != v30) {
      goto LABEL_105;
    }
    if ((v38 & 0x80) != 0)
    {
      int v41 = memcmp(*(const void **)(v29 + 24), v31, *(void *)(v29 + 32));
      uint64_t v28 = v88;
      long long v33 = __s2;
      unint64_t v30 = v87;
      if (v41) {
        goto LABEL_105;
      }
    }
    else if (*(unsigned char *)(v29 + 47))
    {
      uint64_t v40 = 0;
      while (*(unsigned __int8 *)(v29 + v40 + 24) == *((unsigned __int8 *)v31 + v40))
      {
        if (v38 == ++v40) {
          goto LABEL_84;
        }
      }
      goto LABEL_105;
    }
LABEL_84:
    uint64_t v42 = *(unsigned __int8 *)(v29 + 71);
    if ((v42 & 0x80u) == 0) {
      uint64_t v43 = *(unsigned __int8 *)(v29 + 71);
    }
    else {
      uint64_t v43 = *(void *)(v29 + 56);
    }
    if (v43 != v86) {
      goto LABEL_105;
    }
    if ((v42 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v29 + 71)) {
      goto LABEL_95;
    }
    uint64_t v44 = 0;
    while (*(unsigned __int8 *)(v29 + v44 + 48) == *((unsigned __int8 *)v33 + v44))
    {
      if (v42 == ++v44) {
        goto LABEL_95;
      }
    }
LABEL_105:
    uint64_t v48 = *(unsigned __int8 *)(v29 + 95);
    if ((v48 & 0x80u) == 0) {
      uint64_t v49 = *(unsigned __int8 *)(v29 + 95);
    }
    else {
      uint64_t v49 = *(void *)(v29 + 80);
    }
    if (v49 != v34) {
      goto LABEL_126;
    }
    if ((v48 & 0x80) != 0)
    {
      int v51 = memcmp(*(const void **)(v29 + 72), v35, *(void *)(v29 + 80));
      uint64_t v28 = v88;
      long long v33 = __s2;
      unint64_t v30 = v87;
      if (v51) {
        goto LABEL_126;
      }
    }
    else if (*(unsigned char *)(v29 + 95))
    {
      uint64_t v50 = 0;
      while (*(unsigned __int8 *)(v29 + v50 + 72) == v35->__r_.__value_.__s.__data_[v50])
      {
        if (v48 == ++v50) {
          goto LABEL_116;
        }
      }
      goto LABEL_126;
    }
LABEL_116:
    if (!v36) {
      goto LABEL_144;
    }
    if (!(*(char *)(v29 + 119) < 0 ? *(void *)(v29 + 104) : *(unsigned __int8 *)(v29 + 119))) {
      goto LABEL_144;
    }
    uint64_t v53 = 0;
    while (v37->__r_.__value_.__s.__data_[v53] == 102)
    {
      if (v36 == ++v53) {
        goto LABEL_144;
      }
    }
    if (v53 == -1) {
      goto LABEL_144;
    }
LABEL_126:
    uint64_t v54 = *(unsigned __int8 *)(v29 + 119);
    if ((v54 & 0x80u) == 0) {
      uint64_t v55 = *(unsigned __int8 *)(v29 + 119);
    }
    else {
      uint64_t v55 = *(void *)(v29 + 104);
    }
    if (v55 == v36)
    {
      if ((v54 & 0x80) != 0)
      {
        int v57 = memcmp(*(const void **)(v29 + 96), v37, *(void *)(v29 + 104));
        uint64_t v28 = v88;
        long long v33 = __s2;
        unint64_t v30 = v87;
        if (!v57) {
          goto LABEL_144;
        }
      }
      else
      {
        if (!*(unsigned char *)(v29 + 119)) {
          goto LABEL_144;
        }
        uint64_t v56 = 0;
        while (*(unsigned __int8 *)(v29 + v56 + 96) == v37->__r_.__value_.__s.__data_[v56])
        {
          if (v54 == ++v56) {
            goto LABEL_144;
          }
        }
      }
    }
    v29 += 120;
    if (v29 == v28) {
      goto LABEL_187;
    }
  }
  int v45 = memcmp(*(const void **)(v29 + 48), __s2, *(void *)(v29 + 56));
  uint64_t v28 = v88;
  long long v33 = __s2;
  unint64_t v30 = v87;
  if (v45) {
    goto LABEL_105;
  }
LABEL_95:
  if (v34)
  {
    if (*(char *)(v29 + 95) < 0 ? *(void *)(v29 + 80) : *(unsigned __int8 *)(v29 + 95))
    {
      uint64_t v47 = 0;
      while (v35->__r_.__value_.__s.__data_[v47] == 102)
      {
        if (v34 == ++v47) {
          goto LABEL_144;
        }
      }
      if (v47 != -1) {
        goto LABEL_105;
      }
    }
  }
LABEL_144:
  int v60 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v103.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I Disable blocked physical SIM!", (uint8_t *)&v103, 2u);
  }
  sub_1000E9358((uint64_t **)a1, (void **)&v102.__r_.__value_.__l.__data_);
  int v61 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
  {
    int v62 = &v102;
    if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v62 = (std::string *)v102.__r_.__value_.__r.__words[0];
    }
    if (*((char *)a4 + 23) >= 0) {
      int v63 = a4;
    }
    else {
      int v63 = *a4;
    }
    LODWORD(v103.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)v103.__r_.__value_.__r.__words + 4) = (std::string::size_type)v62;
    WORD2(v103.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v103.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v63;
    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I Mark both [%s] and [%s] - as setup", (uint8_t *)&v103, 0x16u);
  }
  (***(void (****)(Registry **__return_ptr))(a2 + 56))(&v90);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v64, v90);
  long long v66 = ServiceMap;
  std::string::size_type v68 = v67;
  if ((v67 & 0x8000000000000000) != 0)
  {
    uint64_t v69 = (unsigned __int8 *)(v67 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v70 = 5381;
    do
    {
      std::string::size_type v68 = v70;
      unsigned int v71 = *v69++;
      uint64_t v70 = (33 * v70) ^ v71;
    }
    while (v71);
  }
  std::mutex::lock(ServiceMap);
  v103.__r_.__value_.__r.__words[0] = v68;
  uint64_t v72 = sub_10004D37C(&v66[1].__m_.__sig, (unint64_t *)&v103);
  if (v72)
  {
    uint64_t v74 = v72[3];
    uint64_t v73 = (std::__shared_weak_count *)v72[4];
    if (v73)
    {
      atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v66);
      atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v73);
      char v75 = 0;
      goto LABEL_161;
    }
  }
  else
  {
    uint64_t v74 = 0;
  }
  std::mutex::unlock(v66);
  uint64_t v73 = 0;
  char v75 = 1;
LABEL_161:
  if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v103, v102.__r_.__value_.__l.__data_, v102.__r_.__value_.__l.__size_);
  }
  else {
    std::string v103 = v102;
  }
  (*(void (**)(uint64_t, std::string *, uint64_t))(*(void *)v74 + 232))(v74, &v103, 1);
  if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v103.__r_.__value_.__l.__data_);
  }
  if ((v75 & 1) == 0) {
    sub_10004D2C8(v73);
  }
  if (v91) {
    sub_10004D2C8(v91);
  }
  (***(void (****)(Registry **__return_ptr))(a2 + 56))(&v90);
  long long v77 = (std::mutex *)Registry::getServiceMap(v76, v90);
  uint64_t v78 = v77;
  if ((v67 & 0x8000000000000000) != 0)
  {
    long long v79 = (unsigned __int8 *)(v67 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v80 = 5381;
    do
    {
      std::string::size_type v67 = v80;
      unsigned int v81 = *v79++;
      uint64_t v80 = (33 * v80) ^ v81;
    }
    while (v81);
  }
  std::mutex::lock(v77);
  v103.__r_.__value_.__r.__words[0] = v67;
  char v82 = sub_10004D37C(&v78[1].__m_.__sig, (unint64_t *)&v103);
  if (v82)
  {
    uint64_t v84 = v82[3];
    char v83 = (std::__shared_weak_count *)v82[4];
    if (v83)
    {
      atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v78);
      atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v83);
      char v85 = 0;
      goto LABEL_178;
    }
  }
  else
  {
    uint64_t v84 = 0;
  }
  std::mutex::unlock(v78);
  char v83 = 0;
  char v85 = 1;
LABEL_178:
  if (*((char *)a4 + 23) < 0) {
    sub_10004FC84(&v103, *a4, (unint64_t)a4[1]);
  }
  else {
    std::string v103 = *(std::string *)a4;
  }
  (*(void (**)(uint64_t, std::string *, uint64_t))(*(void *)v84 + 232))(v84, &v103, 1);
  if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v103.__r_.__value_.__l.__data_);
  }
  if ((v85 & 1) == 0) {
    sub_10004D2C8(v83);
  }
  if (v91) {
    sub_10004D2C8(v91);
  }
LABEL_187:
  if (v94)
  {
    std::string::size_type v95 = (__int32 *)v94;
    operator delete(v94);
  }
  v103.__r_.__value_.__r.__words[0] = (std::string::size_type)&v92;
  sub_1004485E0((void ***)&v103);
  if (BYTE8(v117)) {
    sub_1000C584C((uint64_t)buf);
  }
LABEL_191:
  if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v96.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v97.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v100) < 0) {
    operator delete(v99[1]);
  }
  if (SHIBYTE(v99[0]) < 0) {
    operator delete(v98[0]);
  }
LABEL_199:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  int v12 = SHIBYTE(v102.__r_.__value_.__r.__words[2]);
LABEL_202:
  if (v12 < 0) {
LABEL_203:
  }
    operator delete(v102.__r_.__value_.__l.__data_);
}

void sub_100CBA6D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if ((v74 & 1) == 0) {
    sub_10004D2C8(v73);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_100443A44((uint64_t)&a15);
  if (a72) {
    sub_1000C584C((uint64_t)&a55);
  }
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  sub_1001085D8((uint64_t)&a33);
  if (a44 < 0) {
    operator delete(a39);
  }
  if (a50 < 0) {
    operator delete(a45);
  }
  sub_10005CD2C(v72, *(char **)(v72 + 8));
  _Unwind_Resume(a1);
}

void sub_100CBA80C(void (***a1)(Registry **__return_ptr), uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, unsigned int a6)
{
  (**a1)(&v38);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v11, v38);
  uint64_t v13 = ServiceMap;
  if (v14 < 0)
  {
    BOOL v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v40 = (xpc_object_t)v14;
  uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&v40);
  if (v18)
  {
    uint64_t v20 = v18[3];
    uint64_t v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      char v21 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  std::mutex::unlock(v13);
  uint64_t v19 = 0;
  char v21 = 1;
LABEL_9:
  if (v39) {
    sub_10004D2C8(v39);
  }
  if (v20)
  {
    xpc_object_t v40 = 0;
    xpc_object_t v22 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v23 = v22;
    if (v22)
    {
      xpc_object_t v40 = v22;
    }
    else
    {
      xpc_object_t v23 = xpc_null_create();
      xpc_object_t v40 = v23;
      if (!v23)
      {
        xpc_object_t v24 = xpc_null_create();
        xpc_object_t v23 = 0;
        goto LABEL_19;
      }
    }
    if (xpc_get_type(v23) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v23);
LABEL_20:
      xpc_release(v23);
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v25 = (const char *)a2;
      }
      else {
        uint64_t v25 = *(const char **)a2;
      }
      xpc_object_t v36 = xpc_string_create(v25);
      if (!v36) {
        xpc_object_t v36 = xpc_null_create();
      }
      uint64_t v38 = (Registry *)&v40;
      long long v39 = (std::__shared_weak_count *)"source_carrier_name";
      sub_100035E70((uint64_t)&v38, &v36, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v36);
      xpc_object_t v36 = 0;
      if (*(char *)(a4 + 23) >= 0) {
        int v26 = (const char *)a4;
      }
      else {
        int v26 = *(const char **)a4;
      }
      xpc_object_t v34 = xpc_string_create(v26);
      if (!v34) {
        xpc_object_t v34 = xpc_null_create();
      }
      uint64_t v38 = (Registry *)&v40;
      long long v39 = (std::__shared_weak_count *)"target_carrier_name";
      sub_100035E70((uint64_t)&v38, &v34, &v35);
      xpc_release(v35);
      xpc_object_t v35 = 0;
      xpc_release(v34);
      xpc_object_t v34 = 0;
      xpc_object_t v32 = xpc_int64_create(a3);
      if (!v32) {
        xpc_object_t v32 = xpc_null_create();
      }
      uint64_t v38 = (Registry *)&v40;
      long long v39 = (std::__shared_weak_count *)"source_phone_number_length";
      sub_100035E70((uint64_t)&v38, &v32, &v33);
      xpc_release(v33);
      xpc_object_t v33 = 0;
      xpc_release(v32);
      xpc_object_t v32 = 0;
      xpc_object_t v30 = xpc_int64_create(a5);
      if (!v30) {
        xpc_object_t v30 = xpc_null_create();
      }
      uint64_t v38 = (Registry *)&v40;
      long long v39 = (std::__shared_weak_count *)"target_phone_number_length";
      sub_100035E70((uint64_t)&v38, &v30, &v31);
      xpc_release(v31);
      xpc_object_t v31 = 0;
      xpc_release(v30);
      xpc_object_t v30 = 0;
      xpc_object_t v28 = xpc_int64_create(a6);
      if (!v28) {
        xpc_object_t v28 = xpc_null_create();
      }
      uint64_t v38 = (Registry *)&v40;
      long long v39 = (std::__shared_weak_count *)"abandon_type";
      sub_100035E70((uint64_t)&v38, &v28, &v29);
      xpc_release(v29);
      xpc_object_t v29 = 0;
      xpc_release(v28);
      xpc_object_t v27 = v40;
      xpc_object_t v28 = 0;
      if (v40) {
        xpc_retain(v40);
      }
      else {
        xpc_object_t v27 = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v20 + 16))(v20, "commCenterCellularPlanAbandonOperationDetails", &v27);
      xpc_release(v27);
      xpc_object_t v27 = 0;
      xpc_release(v40);
      goto LABEL_40;
    }
    xpc_object_t v24 = xpc_null_create();
LABEL_19:
    xpc_object_t v40 = v24;
    goto LABEL_20;
  }
LABEL_40:
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
}

void sub_100CBABDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v23 - 88));
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(a1);
}

void **sub_100CBAC70(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL result = sub_100046F68(a2 + 264, (void **)a3);
  if ((void **)(a2 + 272) == result)
  {
    unsigned int v8 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a3 + 23) >= 0) {
        uint64_t v9 = (void *)a3;
      }
      else {
        uint64_t v9 = *(void **)a3;
      }
      int v12 = 136315138;
      uint64_t v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Missing carrier name for %s", (uint8_t *)&v12, 0xCu);
    }
    return (void **)sub_100058DB0(a1, "");
  }
  else if (*((char *)result + 79) < 0)
  {
    uint64_t v10 = result[7];
    unint64_t v11 = (unint64_t)result[8];
    return (void **)sub_10004FC84(a1, v10, v11);
  }
  else
  {
    long long v7 = *(_OWORD *)(result + 7);
    a1[2] = result[9];
    *(_OWORD *)a1 = v7;
  }
  return result;
}

uint64_t sub_100CBADB8(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(int **)(a1 + 136); i != *(int **)(a1 + 144); i += 22)
  {
    int v5 = *i;
    if (i[1] == 3)
    {
      if (v5) {
        goto LABEL_8;
      }
      break;
    }
    if (v5) {
      goto LABEL_8;
    }
  }
  sub_100CC30DC(a2);
LABEL_8:
  memset(&v178, 0, sizeof(v178));
  memset(v177, 0, sizeof(v177));
  long long v175 = 0u;
  memset(v176, 0, sizeof(v176));
  long long v174 = 0u;
  memset(v173, 0, sizeof(v173));
  long long v172 = 0u;
  if (*(unsigned char *)(a2 + 240))
  {
    long long v172 = *(_OWORD *)a2;
    std::string::operator=(v173, (const std::string *)(a2 + 16));
    std::string::operator=(&v173[1], (const std::string *)(a2 + 40));
    std::string::operator=((std::string *)&v174, (const std::string *)(a2 + 64));
    DWORD2(v175) = *(_DWORD *)(a2 + 88);
    std::string::operator=(v176, (const std::string *)(a2 + 96));
    std::string::operator=(&v176[1], (const std::string *)(a2 + 120));
    std::string::operator=(v177, (const std::string *)(a2 + 144));
    std::string __str = (std::string *)(a2 + 168);
    std::string::operator=(&v177[1], (const std::string *)(a2 + 168));
    uint64_t v147 = (std::string *)(a2 + 192);
    std::string::operator=(&v178, (const std::string *)(a2 + 192));
    sGetProfileDetails();
    if (LOBYTE(v188[1]))
    {
      sub_1000C584C((uint64_t)buf);
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        long long v7 = v173;
        if ((v173[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          long long v7 = (std::string *)v173[0].__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I profile %s already exists, reset placeholder info", buf, 0xCu);
      }
      sub_100CC30DC(a2);
    }
    if (*(unsigned char *)(a2 + 240))
    {
      unsigned int v8 = (void *)(a1 + 424);
      if (!*(unsigned char *)(a1 + 752))
      {
        memset(v188, 0, sizeof(v188));
        memset(v186, 0, sizeof(v186));
        long long v185 = 0u;
        memset(v184, 0, sizeof(v184));
        long long v182 = 0u;
        memset(v180, 0, 24);
        uint64_t v189 = &v190;
        *(void *)(a1 + 456) = 0;
        *(void *)(a1 + 480) = 0;
        *(void *)(a1 + 504) = v182;
        uint64_t v9 = *((void *)&v184[1] + 1);
        *(void *)(a1 + 536) = *(void *)&v184[0];
        *(void *)(a1 + 560) = v9;
        uint64_t v10 = *((void *)&v186[1] + 1);
        *(void *)(a1 + 584) = *(void *)&v186[0];
        *(void *)(a1 + 608) = v10;
        unint64_t v11 = v188[3];
        *(void **)(a1 + 632) = v188[0];
        long long v192 = 0u;
        long long v190 = 0u;
        long long v187 = 0u;
        long long v183 = 0u;
        long long v181 = 0u;
        memset(buf, 0, sizeof(buf));
        BYTE8(v192) = 0;
        void *v8 = 0;
        *(void *)(a1 + 432) = 0;
        *(_OWORD *)(a1 + 440) = *(_OWORD *)&buf[16];
        *(_OWORD *)&uint8_t buf[16] = 0uLL;
        *(_OWORD *)(a1 + 464) = *(_OWORD *)((char *)v180 + 8);
        memset(v180, 0, sizeof(v180));
        *(_OWORD *)(a1 + 488) = v181;
        long long v181 = 0uLL;
        *(void *)&long long v182 = 0;
        *(_DWORD *)(a1 + 512) = 0;
        *(_OWORD *)(a1 + 520) = v183;
        long long v183 = 0uLL;
        *(_OWORD *)(a1 + 544) = *(_OWORD *)((char *)v184 + 8);
        memset(v184, 0, sizeof(v184));
        *(_OWORD *)(a1 + 568) = v185;
        long long v185 = 0uLL;
        *(_OWORD *)(a1 + 592) = *(_OWORD *)((char *)v186 + 8);
        memset(v186, 0, sizeof(v186));
        *(_OWORD *)(a1 + 616) = v187;
        long long v187 = 0uLL;
        long long v12 = *(_OWORD *)&v188[1];
        *(void *)(a1 + 656) = v11;
        *(_OWORD *)(a1 + 640) = v12;
        memset(v188, 0, 32);
        *(_DWORD *)(a1 + 664) = 0;
        *(void *)(a1 + 688) = 0;
        *(void *)(a1 + 680) = 0;
        *(void *)(a1 + 672) = a1 + 680;
        *(void *)(a1 + 704) = 0;
        *(void *)(a1 + 696) = 0;
        *(void *)(a1 + 712) = 0;
        __p[1] = 0;
        __p[0] = 0;
        *(void *)&long long v192 = 0;
        *(unsigned char *)(a1 + 720) = 0;
        *(void *)(a1 + 736) = 0;
        *(void *)(a1 + 728) = 0;
        *(void *)(a1 + 744) = 0;
        memset(v193, 0, 24);
        *(unsigned char *)(a1 + 752) = 1;
        *(void *)uint64_t v152 = v193;
        sub_100047F64((void ***)v152);
        if (SBYTE7(v192) < 0) {
          operator delete(__p[0]);
        }
        sub_10005CD2C((uint64_t)&v189, (char *)v190);
        if (SHIBYTE(v188[3]) < 0) {
          operator delete(v188[1]);
        }
        sub_1000C584C((uint64_t)buf);
        int v13 = dword_101B0B230++;
        *(_DWORD *)(a1 + 664) = v13;
      }
      std::string::size_type size = HIBYTE(v173[0].__r_.__value_.__r.__words[2]);
      if ((v173[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = v173[0].__r_.__value_.__l.__size_;
      }
      if (size)
      {
        if (*(unsigned char *)(a2 + 240))
        {
          *(_OWORD *)unsigned int v8 = *(_OWORD *)a2;
          std::string::operator=((std::string *)(a1 + 440), (const std::string *)(a2 + 16));
          std::string::operator=((std::string *)(a1 + 464), (const std::string *)(a2 + 40));
          std::string::operator=((std::string *)(a1 + 488), (const std::string *)(a2 + 64));
          *(_DWORD *)(a1 + 512) = *(_DWORD *)(a2 + 88);
          std::string::operator=((std::string *)(a1 + 520), (const std::string *)(a2 + 96));
          std::string::operator=((std::string *)(a1 + 544), (const std::string *)(a2 + 120));
          std::string::operator=((std::string *)(a1 + 568), (const std::string *)(a2 + 144));
          std::string::operator=((std::string *)(a1 + 592), __str);
          std::string::operator=((std::string *)(a1 + 616), v147);
          BOOL v15 = (const void **)(a1 + 640);
          std::string::operator=((std::string *)(a1 + 640), (const std::string *)(a2 + 216));
          uint64_t v16 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v17 = v173;
            if ((v173[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              unsigned int v17 = (std::string *)v173[0].__r_.__value_.__r.__words[0];
            }
            uint64_t v18 = (const void *)(a1 + 640);
            if (*(char *)(a1 + 663) < 0) {
              uint64_t v18 = *v15;
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v17;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v18;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I updated provisioning placeholder with iccid: (%s), source iccid %s", buf, 0x16u);
          }
          uint64_t v19 = BYTE7(v175);
          if (SBYTE7(v175) < 0) {
            uint64_t v19 = *((void *)&v174 + 1);
          }
          if (!v19
            || ((*(uint64_t (**)(void, std::string *, std::string *, std::string *, std::string *, std::string *))(**(void **)(a1 + 56) + 168))(*(void *)(a1 + 56), v176, &v176[1], v177, &v177[1], v173) & 1) == 0)
          {
            memset(buf, 0, 24);
            (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 56) + 160))(buf);
            uint64_t v20 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              char v21 = buf;
              if (buf[23] < 0) {
                char v21 = *(unsigned char **)buf;
              }
              *(_DWORD *)uint64_t v152 = 136315138;
              *(void *)&v152[4] = v21;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Metadata carrier name empty or not preferCarrierNameFromMetadata, using from CB: [%s]", v152, 0xCu);
            }
            uint64_t v22 = buf[23];
            char v23 = buf[23];
            if (buf[23] < 0) {
              uint64_t v22 = *(void *)&buf[8];
            }
            if (v22)
            {
              std::string::operator=((std::string *)(a1 + 488), (const std::string *)buf);
              char v23 = buf[23];
            }
            if (v23 < 0) {
              operator delete(*(void **)buf);
            }
          }
          sub_1000E9358((uint64_t **)(a1 + 672), (void **)(a1 + 640));
          if (*(void *)(a1 + 688) < (unint64_t)*(unsigned int *)(a1 + 788))
          {
            sub_1000F29CC((uint64_t **)(a1 + 672), (void **)&v173[0].__r_.__value_.__l.__data_, (uint64_t)v173);
            sub_100CA8010((uint64_t *)buf, a1);
            sub_100CBCA80(a1, (void **)buf, 0);
            sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
          }
          uint64_t v24 = *(unsigned __int8 *)(a1 + 663);
          size_t v25 = *(void *)(a1 + 648);
          if ((v24 & 0x80u) == 0) {
            uint64_t v26 = *(unsigned __int8 *)(a1 + 663);
          }
          else {
            uint64_t v26 = *(void *)(a1 + 648);
          }
          uint64_t v27 = *(unsigned __int8 *)(a1 + 863);
          int v28 = (char)v27;
          if ((v27 & 0x80u) != 0) {
            uint64_t v27 = *(void *)(a1 + 848);
          }
          if (v26 == v27)
          {
            if (v28 >= 0) {
              xpc_object_t v29 = (unsigned __int8 *)(a1 + 840);
            }
            else {
              xpc_object_t v29 = *(unsigned __int8 **)(a1 + 840);
            }
            if ((v24 & 0x80) != 0)
            {
              BOOL v38 = memcmp(*v15, v29, *(void *)(a1 + 648)) == 0;
            }
            else if (*(unsigned char *)(a1 + 663))
            {
              uint64_t v30 = v24 - 1;
              xpc_object_t v31 = (unsigned __int8 *)(a1 + 640);
              do
              {
                int v33 = *v31++;
                int v32 = v33;
                int v35 = *v29++;
                int v34 = v35;
                BOOL v37 = v30-- != 0;
                BOOL v38 = v32 == v34;
              }
              while (v38 && v37);
            }
            else
            {
              BOOL v38 = 1;
            }
          }
          else
          {
            BOOL v38 = 0;
          }
          *(unsigned char *)(a1 + 720) = v38;
          uint64_t v49 = *(unsigned __int8 *)(a1 + 895);
          int v50 = (char)v49;
          if ((v49 & 0x80u) != 0) {
            uint64_t v49 = *(void *)(a1 + 880);
          }
          if (v26 != v49) {
            goto LABEL_119;
          }
          if (v50 >= 0) {
            int v51 = (unsigned __int8 *)(a1 + 872);
          }
          else {
            int v51 = *(unsigned __int8 **)(a1 + 872);
          }
          if ((v24 & 0x80) != 0)
          {
            if (memcmp(*v15, v51, v25)) {
              goto LABEL_119;
            }
          }
          else if (v24)
          {
            while (*(unsigned __int8 *)v15 == *v51)
            {
              BOOL v15 = (const void **)((char *)v15 + 1);
              ++v51;
              if (!--v24) {
                goto LABEL_118;
              }
            }
LABEL_119:
            BOOL v52 = *(std::__shared_weak_count **)(a1 + 80);
            if (!v52 || (uint64_t v53 = std::__shared_weak_count::lock(v52)) == 0)
            {
LABEL_145:
              sub_100CBCF58(a1, (long long *)(a1 + 440), 2);
              uint64_t v70 = *(std::__shared_weak_count **)(a1 + 80);
              if (v70)
              {
                unsigned int v71 = std::__shared_weak_count::lock(v70);
                if (v71)
                {
                  uint64_t v72 = *(void *)(a1 + 72);
                  if (v72)
                  {
                    (*(void (**)(unsigned char *__return_ptr))(*(void *)v72 + 104))(buf);
                    if (v197)
                    {
                      uint64_t v73 = v196;
                      if ((v196 & 0x80u) != 0) {
                        uint64_t v73 = v195;
                      }
                      if (!v73)
                      {
                        uint64_t v78 = *(NSObject **)(a1 + 40);
                        if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_176;
                        }
                        *(_WORD *)uint64_t v152 = 0;
                        long long v77 = "#I no known source iccid, let user configure new plan from UI";
                        long long v79 = v78;
                        uint32_t v80 = 2;
LABEL_175:
                        _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, v77, v152, v80);
LABEL_176:
                        if (v197) {
                          sub_10030D10C((uint64_t)buf);
                        }
                        goto LABEL_161;
                      }
                      if (sub_100CB1074(a1) && !buf[4] && buf[3])
                      {
                        if (v197) {
                          sub_10030D10C((uint64_t)buf);
                        }
                        sub_10004D2C8(v71);
                        sub_100CB1888(a1, *(void *)(a1 + 160), *(void *)(a1 + 168), a1 + 440);
                        return sub_1000C584C((uint64_t)&v172);
                      }
                      char v75 = *(NSObject **)(a1 + 40);
                      if (!os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_176;
                      }
                      if (*(char *)(a1 + 463) >= 0) {
                        uint64_t v81 = a1 + 440;
                      }
                      else {
                        uint64_t v81 = *(void *)(a1 + 440);
                      }
                      *(_DWORD *)uint64_t v152 = 136315138;
                      *(void *)&v152[4] = v81;
                      long long v77 = "#I User selection alert is not allowed for (%s)";
LABEL_174:
                      long long v79 = v75;
                      uint32_t v80 = 12;
                      goto LABEL_175;
                    }
                    char v75 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
                    {
                      if (*(char *)(a1 + 463) >= 0) {
                        uint64_t v76 = a1 + 440;
                      }
                      else {
                        uint64_t v76 = *(void *)(a1 + 440);
                      }
                      *(_DWORD *)uint64_t v152 = 136315138;
                      *(void *)&v152[4] = v76;
                      long long v77 = "#I Source plan does not exist for (%s)";
                      goto LABEL_174;
                    }
LABEL_161:
                    sub_10004D2C8(v71);
                    return sub_1000C584C((uint64_t)&v172);
                  }
                }
              }
              else
              {
                unsigned int v71 = 0;
              }
              char v74 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_ERROR, "delegate is not available", buf, 2u);
                if (!v71) {
                  return sub_1000C584C((uint64_t)&v172);
                }
              }
              else if (!v71)
              {
                return sub_1000C584C((uint64_t)&v172);
              }
              goto LABEL_161;
            }
            uint64_t v54 = v53;
            uint64_t v55 = *(void *)(a1 + 72);
            if (!v55 || ((*(void (**)(unsigned char *__return_ptr))(*(void *)v55 + 104))(buf), !v197))
            {
LABEL_144:
              sub_10004D2C8(v54);
              goto LABEL_145;
            }
            if (!buf[4])
            {
LABEL_143:
              sub_10030D10C((uint64_t)buf);
              goto LABEL_144;
            }
            uint64_t v56 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              int v57 = (void **)&v194;
              if ((v196 & 0x80u) != 0) {
                int v57 = v194;
              }
              *(_DWORD *)uint64_t v152 = 136315138;
              *(void *)&v152[4] = v57;
              _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I mark %s as abandoned", v152, 0xCu);
            }
            (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(v152);
            ServiceMap = (std::mutex *)Registry::getServiceMap(v58, *(Registry **)v152);
            int v60 = ServiceMap;
            if ((v61 & 0x8000000000000000) != 0)
            {
              int v62 = (unsigned __int8 *)(v61 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v63 = 5381;
              do
              {
                std::string::size_type v61 = v63;
                unsigned int v64 = *v62++;
                uint64_t v63 = (33 * v63) ^ v64;
              }
              while (v64);
            }
            std::mutex::lock(ServiceMap);
            v198.__r_.__value_.__r.__words[0] = v61;
            BOOL v65 = sub_10004D37C(&v60[1].__m_.__sig, (unint64_t *)&v198);
            if (v65)
            {
              uint64_t v67 = v65[3];
              long long v66 = (std::__shared_weak_count *)v65[4];
              if (v66)
              {
                atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v60);
                atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v66);
                char v68 = 0;
                goto LABEL_138;
              }
            }
            else
            {
              uint64_t v67 = 0;
            }
            std::mutex::unlock(v60);
            long long v66 = 0;
            char v68 = 1;
LABEL_138:
            (*(void (**)(uint64_t, void ***))(*(void *)v67 + 288))(v67, &v194);
            if ((v68 & 1) == 0) {
              sub_10004D2C8(v66);
            }
            if (*(void *)&v152[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v152[8]);
            }
            sub_100CB0388(a1, (uint64_t)&v194, (uint64_t)v173, 1);
            if (!v197) {
              goto LABEL_144;
            }
            goto LABEL_143;
          }
LABEL_118:
          std::string::operator=((std::string *)(a1 + 696), v173);
          goto LABEL_119;
        }
      }
      else
      {
        if (*(char *)(a1 + 463) < 0)
        {
          if (*(void *)(a1 + 448)) {
            return sub_1000C584C((uint64_t)&v172);
          }
        }
        else if (*(unsigned char *)(a1 + 463))
        {
          return sub_1000C584C((uint64_t)&v172);
        }
        if (*(unsigned char *)(a2 + 240))
        {
          *(_OWORD *)unsigned int v8 = *(_OWORD *)a2;
          std::string::operator=((std::string *)(a1 + 440), (const std::string *)(a2 + 16));
          std::string::operator=((std::string *)(a1 + 464), (const std::string *)(a2 + 40));
          std::string::operator=((std::string *)(a1 + 488), (const std::string *)(a2 + 64));
          *(_DWORD *)(a1 + 512) = *(_DWORD *)(a2 + 88);
          std::string::operator=((std::string *)(a1 + 520), (const std::string *)(a2 + 96));
          std::string::operator=((std::string *)(a1 + 544), (const std::string *)(a2 + 120));
          std::string::operator=((std::string *)(a1 + 568), (const std::string *)(a2 + 144));
          std::string::operator=((std::string *)(a1 + 592), __str);
          std::string::operator=((std::string *)(a1 + 616), v147);
          std::string::operator=((std::string *)(a1 + 640), (const std::string *)(a2 + 216));
          return sub_1000C584C((uint64_t)&v172);
        }
      }
      sub_10016C840();
    }
  }
  if (!*(unsigned char *)(a1 + 752)) {
    return sub_1000C584C((uint64_t)&v172);
  }
  uint64_t v171 = 0;
  long long v169 = 0u;
  long long v170 = 0u;
  long long v167 = 0u;
  *(_OWORD *)int v168 = 0u;
  long long v166 = 0u;
  long long v164 = 0u;
  memset(v165, 0, sizeof(v165));
  long long v162 = 0u;
  long long v163 = 0u;
  long long v160 = 0u;
  long long v161 = 0u;
  long long v158 = 0u;
  long long v159 = 0u;
  long long v156 = 0u;
  long long v157 = 0u;
  long long v154 = 0u;
  long long v155 = 0u;
  *(_OWORD *)uint64_t v152 = 0u;
  long long v153 = 0u;
  sub_1000C5AB4((uint64_t)v152, a1 + 424);
  long long v39 = (void **)(a1 + 640);
  if (*(char *)(a1 + 663) < 0)
  {
    sub_10004FC84(&v165[1], *(void **)(a1 + 640), *(void *)(a1 + 648));
  }
  else
  {
    *(_OWORD *)&v165[1] = *(_OWORD *)v39;
    v165[3] = *(void **)(a1 + 656);
  }
  LODWORD(v166) = *(_DWORD *)(a1 + 664);
  sub_1000C6BDC((uint64_t *)&v166 + 1, a1 + 672);
  xpc_object_t v40 = (void **)(a1 + 696);
  if (*(char *)(a1 + 719) < 0)
  {
    sub_10004FC84(v168, *(void **)(a1 + 696), *(void *)(a1 + 704));
  }
  else
  {
    *(_OWORD *)int v168 = *(_OWORD *)v40;
    *(void *)&long long v169 = *(void *)(a1 + 712);
  }
  BYTE8(v169) = *(unsigned char *)(a1 + 720);
  uint64_t v171 = 0;
  long long v170 = 0uLL;
  sub_1000302C0((char *)&v170, *(long long **)(a1 + 728), *(long long **)(a1 + 736), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 736) - *(void *)(a1 + 728)) >> 3));
  if (*(unsigned char *)(a1 + 752))
  {
    *(void *)long long buf = a1 + 728;
    sub_100047F64((void ***)buf);
    if (*(char *)(a1 + 719) < 0) {
      operator delete(*v40);
    }
    sub_10005CD2C(a1 + 672, *(char **)(a1 + 680));
    if (*(char *)(a1 + 663) < 0) {
      operator delete(*v39);
    }
    sub_1000C584C(a1 + 424);
    *(unsigned char *)(a1 + 752) = 0;
  }
  int v41 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I cleared provisioning placeholder", buf, 2u);
  }
  uint64_t v42 = BYTE7(v154);
  if (SBYTE7(v154) < 0) {
    uint64_t v42 = *((void *)&v153 + 1);
  }
  if (!v42)
  {
    uint64_t v48 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I provisioning iccid is empty. abort", buf, 2u);
    }
    goto LABEL_326;
  }
  uint64_t v43 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v43) {
    goto LABEL_326;
  }
  uint64_t v44 = std::__shared_weak_count::lock(v43);
  if (!v44) {
    goto LABEL_326;
  }
  int v45 = v44;
  uint64_t v46 = *(void *)(a1 + 72);
  if (!v46) {
    goto LABEL_325;
  }
  uint64_t v149 = v45;
  if (!*((void *)&v167 + 1))
  {
    (*(void (**)(unsigned char *__return_ptr))(*(void *)v46 + 104))(buf);
    if (!v197) {
      goto LABEL_134;
    }
    uint64_t v47 = v196;
    if ((v196 & 0x80u) != 0) {
      uint64_t v47 = v195;
    }
    if (v47)
    {
      if (!(buf[4] | buf[3]))
      {
        sub_10030D10C((uint64_t)buf);
        goto LABEL_325;
      }
      sub_100CB1424((std::string **)&v198, a1, (void **)&v194, (uint64_t)&v153);
      sub_1006347E0((uint64_t)&v166 + 8, &v198);
      sub_10005CD2C((uint64_t)&v198, (char *)v198.__r_.__value_.__l.__size_);
    }
    else
    {
LABEL_134:
      sub_100058DB0(&v150, "");
      sub_100CB1424((std::string **)&v198, a1, (void **)&v150, (uint64_t)&v153);
      sub_10005CD2C((uint64_t)&v166 + 8, (char *)v167);
      uint64_t v69 = (char *)v198.__r_.__value_.__l.__size_;
      *((void *)&v166 + 1) = v198.__r_.__value_.__r.__words[0];
      long long v167 = *(_OWORD *)&v198.__r_.__value_.__r.__words[1];
      if (v198.__r_.__value_.__r.__words[2])
      {
        *(void *)(v198.__r_.__value_.__l.__size_ + 16) = &v167;
        v198.__r_.__value_.__r.__words[0] = (std::string::size_type)&v198.__r_.__value_.__l.__size_;
        *(_OWORD *)&v198.__r_.__value_.__r.__words[1] = 0uLL;
        uint64_t v69 = 0;
      }
      else
      {
        *((void *)&v166 + 1) = &v167;
      }
      sub_10005CD2C((uint64_t)&v198, v69);
      if (v151 < 0) {
        operator delete((void *)v150);
      }
    }
    if (v197) {
      sub_10030D10C((uint64_t)buf);
    }
  }
  uint64_t v82 = *((void *)&v166 + 1);
  if (*((long long **)&v166 + 1) == &v167) {
    goto LABEL_239;
  }
  while (1)
  {
    char v83 = (void *)(v82 + 32);
    if (sub_100CBFD40((unsigned __int8 **)(v82 + 32), *(void *)(a1 + 160), *(void *)(a1 + 168)))
    {
      uint64_t v84 = *(uint64_t **)(v82 + 8);
      if (v84)
      {
        do
        {
          char v85 = v84;
          uint64_t v84 = (uint64_t *)*v84;
        }
        while (v84);
      }
      else
      {
        do
        {
          char v85 = *(uint64_t **)(v82 + 16);
          BOOL v86 = *v85 == v82;
          uint64_t v82 = (uint64_t)v85;
        }
        while (!v86);
      }
      goto LABEL_216;
    }
    char v87 = *(unsigned char *)(v82 + 55);
    if (v87 >= 0) {
      uint64_t v88 = *(unsigned __int8 *)(v82 + 55);
    }
    else {
      uint64_t v88 = *(void *)(v82 + 40);
    }
    uint64_t v89 = BYTE7(v154);
    if (SBYTE7(v154) < 0) {
      uint64_t v89 = *((void *)&v153 + 1);
    }
    if (v88 == v89) {
      break;
    }
LABEL_209:
    uint8_t v94 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    {
      if (v87 < 0) {
        char v83 = (void *)*v83;
      }
LABEL_214:
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v83;
      _os_log_error_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "ICCID (%s) is removed during eSIM installation!", buf, 0xCu);
    }
LABEL_215:
    char v85 = sub_1000E1C44((uint64_t **)&v166 + 1, v82);
LABEL_216:
    uint64_t v82 = (uint64_t)v85;
    if (v85 == (uint64_t *)&v167) {
      goto LABEL_239;
    }
  }
  if ((SBYTE7(v154) & 0x80u) == 0) {
    uint64_t v90 = (unsigned __int8 *)&v153;
  }
  else {
    uint64_t v90 = (unsigned __int8 *)v153;
  }
  if ((*(unsigned char *)(v82 + 55) & 0x80) == 0)
  {
    if (!*(unsigned char *)(v82 + 55)) {
      goto LABEL_218;
    }
    uint64_t v91 = v90;
    uint64_t v92 = (unsigned __int8 *)(v82 + 32);
    uint64_t v93 = *(unsigned __int8 *)(v82 + 55);
    while (*v92 == *v91)
    {
      ++v92;
      ++v91;
      if (!--v93) {
        goto LABEL_218;
      }
    }
    goto LABEL_209;
  }
  char v83 = (void *)*v83;
  if (memcmp(v83, v90, *(void *)(v82 + 40)))
  {
    uint8_t v94 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR)) {
      goto LABEL_214;
    }
    goto LABEL_215;
  }
LABEL_218:
  std::string::size_type v95 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v90;
    _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "#I Provisioning ICCID (%s) was not installed", buf, 0xCu);
  }
  sub_1000E1C44((uint64_t **)&v166 + 1, v82);
  memset(buf, 0, 24);
  sub_100CA8010((uint64_t *)buf, a1);
  if (!*((void *)&v167 + 1))
  {
    sub_1000EA390((uint64_t **)&v166 + 1, *(void **)buf, &buf[8]);
    sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
    goto LABEL_325;
  }
  std::string v96 = (void **)*((void *)&v166 + 1);
  if (*((long long **)&v166 + 1) != &v167)
  {
    do
    {
      if (!sub_10010E128((uint64_t)buf, v96 + 4)) {
        sub_100046BAC((uint64_t **)buf, v96 + 4, (uint64_t)(v96 + 4));
      }
      std::string v97 = (void **)v96[1];
      if (v97)
      {
        do
        {
          uint64_t v98 = v97;
          std::string v97 = (void **)*v97;
        }
        while (v97);
      }
      else
      {
        do
        {
          uint64_t v98 = (void **)v96[2];
          BOOL v86 = *v98 == v96;
          std::string v96 = v98;
        }
        while (!v86);
      }
      std::string v96 = v98;
    }
    while (v98 != (void **)&v167);
  }
  if (*(void *)&buf[16] <= (unint64_t)*(unsigned int *)(a1 + 788)) {
    sub_1000EA390((uint64_t **)&v166 + 1, *(void **)buf, &buf[8]);
  }
  unsigned int v99 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000E8F34(*((std::string **)&v166 + 1), (std::string *)&v167, ",", 1uLL, &v198);
    long long v100 = (v198.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &v198
         : (std::string *)v198.__r_.__value_.__r.__words[0];
    LODWORD(v150) = 136315138;
    *(void *)((char *)&v150 + 4) = v100;
    _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "#I after restoring enabled ICCIDs (%s)", (uint8_t *)&v150, 0xCu);
    if (SHIBYTE(v198.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v198.__r_.__value_.__l.__data_);
    }
  }
  sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
LABEL_239:
  sub_100CA8010((uint64_t *)buf, a1);
  if (*((void *)&v167 + 1) != *(void *)&buf[16])
  {
LABEL_256:
    sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
    long long v108 = (void *)BYTE7(v169);
    int v109 = SBYTE7(v169);
    if (SBYTE7(v169) < 0) {
      long long v108 = v168[1];
    }
    if (v108)
    {
      long long v110 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
      {
        long long v111 = (void **)v168[0];
        if (v109 >= 0) {
          long long v111 = v168;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v111;
        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "#I Applying placeholder active user data iccid: [%s]", buf, 0xCu);
      }
      std::string::operator=((std::string *)(a1 + 872), (const std::string *)v168);
    }
    if (BYTE8(v169))
    {
      long long v112 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
      {
        long long v113 = &v153;
        if (SBYTE7(v154) < 0) {
          long long v113 = (long long *)v153;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v113;
        _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "#I Applying placeholder default voice iccid: [%s]", buf, 0xCu);
      }
      std::string::operator=((std::string *)(a1 + 840), (const std::string *)&v153);
    }
    if (*((void *)&v167 + 1) >= 2uLL)
    {
      sub_100CB9CB8((uint64_t *)buf, a1, (uint64_t)&v166 + 8, (void **)&v153);
      sub_1006347E0((uint64_t)&v166 + 8, buf);
      sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
    }
    sub_100CB089C((uint64_t *)buf, (void *)&v166 + 1, 0);
    sub_100CA9968((uint64_t *)a1, buf, 0, 0);
    sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
    sub_100CB3DD4(a1);
    memset(buf, 0, 24);
    if (SBYTE7(v154) < 0)
    {
      sub_10004FC84(buf, (void *)v153, *((unint64_t *)&v153 + 1));
    }
    else
    {
      *(_OWORD *)long long buf = v153;
      *(void *)&uint8_t buf[16] = v154;
    }
    uint64_t v114 = buf[23];
    if (buf[23] < 0) {
      uint64_t v114 = *(void *)&buf[8];
    }
    if (!v114)
    {
      uint64_t v131 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v198.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_ERROR, "Empty iccid in placeholder profile details", (uint8_t *)&v198, 2u);
      }
      goto LABEL_321;
    }
    if (sub_100CBFD40((unsigned __int8 **)buf, *(void *)(a1 + 160), *(void *)(a1 + 168)))
    {
      uint64_t v116 = *((void *)&v170 + 1);
      std::string::size_type v115 = v170;
      if ((void)v170 != *((void *)&v170 + 1))
      {
        while (1)
        {
          long long v117 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v118 = v115;
            if (*(char *)(v115 + 23) < 0) {
              std::string::size_type v118 = *(void *)v115;
            }
            long long v119 = buf;
            if (buf[23] < 0) {
              long long v119 = *(unsigned char **)buf;
            }
            LODWORD(v198.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)v198.__r_.__value_.__r.__words + 4) = v118;
            WORD2(v198.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v198.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v119;
            _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#I Applying Remap from: [%s] to: [%s]", (uint8_t *)&v198, 0x16u);
          }
          (***(void (****)(std::string *__return_ptr))(a1 + 56))(&v198);
          long long v121 = (std::mutex *)Registry::getServiceMap(v120, (Registry *)v198.__r_.__value_.__l.__data_);
          uint64_t v122 = v121;
          if (v123 < 0)
          {
            std::string::size_type v124 = (unsigned __int8 *)(v123 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v125 = 5381;
            do
            {
              uint64_t v123 = v125;
              unsigned int v126 = *v124++;
              uint64_t v125 = (33 * v125) ^ v126;
            }
            while (v126);
          }
          std::mutex::lock(v121);
          *(void *)&long long v150 = v123;
          uint64_t v127 = sub_10004D37C(&v122[1].__m_.__sig, (unint64_t *)&v150);
          if (!v127) {
            break;
          }
          uint64_t v129 = v127[3];
          uint64_t v128 = (std::__shared_weak_count *)v127[4];
          if (!v128) {
            goto LABEL_293;
          }
          atomic_fetch_add_explicit(&v128->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v122);
          atomic_fetch_add_explicit(&v128->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v128);
          char v130 = 0;
LABEL_294:
          (*(void (**)(uint64_t, std::string::size_type, unsigned char *))(*(void *)v129 + 264))(v129, v115, buf);
          if ((v130 & 1) == 0) {
            sub_10004D2C8(v128);
          }
          if (v198.__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)v198.__r_.__value_.__l.__size_);
          }
          v115 += 24;
          if (v115 == v116) {
            goto LABEL_321;
          }
        }
        uint64_t v129 = 0;
LABEL_293:
        std::mutex::unlock(v122);
        uint64_t v128 = 0;
        char v130 = 1;
        goto LABEL_294;
      }
LABEL_321:
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v145 = sub_100046F68(a1 + 264, (void **)&v153);
      int v45 = v149;
      if ((void **)(a1 + 272) != v145) {
        *((_DWORD *)v145 + 44) = v166;
      }
      goto LABEL_325;
    }
    uint64_t v132 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v133 = buf;
      if (buf[23] < 0) {
        uint64_t v133 = *(unsigned char **)buf;
      }
      LODWORD(v198.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v198.__r_.__value_.__r.__words + 4) = (std::string::size_type)v133;
      _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, "#I Drop placeholder iccid: [%s]", (uint8_t *)&v198, 0xCu);
    }
    (***(void (****)(long long *__return_ptr))(a1 + 56))(&v150);
    uint32_t v135 = (std::mutex *)Registry::getServiceMap(v134, (Registry *)v150);
    char v136 = v135;
    if ((v137 & 0x8000000000000000) != 0)
    {
      uint64_t v138 = (unsigned __int8 *)(v137 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v139 = 5381;
      do
      {
        std::string::size_type v137 = v139;
        unsigned int v140 = *v138++;
        uint64_t v139 = (33 * v139) ^ v140;
      }
      while (v140);
    }
    std::mutex::lock(v135);
    v198.__r_.__value_.__r.__words[0] = v137;
    uint64_t v141 = sub_10004D37C(&v136[1].__m_.__sig, (unint64_t *)&v198);
    if (v141)
    {
      uint64_t v143 = v141[3];
      int v142 = (std::__shared_weak_count *)v141[4];
      if (v142)
      {
        atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v136);
        atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v142);
        char v144 = 0;
LABEL_315:
        sub_100058DB0(&v198, "");
        (*(void (**)(uint64_t, unsigned char *, std::string *))(*(void *)v143 + 264))(v143, buf, &v198);
        if (SHIBYTE(v198.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v198.__r_.__value_.__l.__data_);
        }
        if ((v144 & 1) == 0) {
          sub_10004D2C8(v142);
        }
        if (*((void *)&v150 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v150 + 1));
        }
        goto LABEL_321;
      }
    }
    else
    {
      uint64_t v143 = 0;
    }
    std::mutex::unlock(v136);
    int v142 = 0;
    char v144 = 1;
    goto LABEL_315;
  }
  uint64_t v101 = (unsigned __int8 *)*((void *)&v166 + 1);
  if (*((long long **)&v166 + 1) != &v167)
  {
    std::string v102 = *(unsigned __int8 **)buf;
    while ((sub_1000609C0((uint64_t)&v198, v101 + 32, v102 + 32) & 1) != 0)
    {
      std::string v103 = (unsigned __int8 *)*((void *)v101 + 1);
      unsigned int v104 = v101;
      if (v103)
      {
        do
        {
          uint64_t v101 = v103;
          std::string v103 = *(unsigned __int8 **)v103;
        }
        while (v103);
      }
      else
      {
        do
        {
          uint64_t v101 = (unsigned __int8 *)*((void *)v104 + 2);
          BOOL v86 = *(void *)v101 == (void)v104;
          unsigned int v104 = v101;
        }
        while (!v86);
      }
      long long v105 = (unsigned __int8 *)*((void *)v102 + 1);
      if (v105)
      {
        do
        {
          long long v106 = v105;
          long long v105 = *(unsigned __int8 **)v105;
        }
        while (v105);
      }
      else
      {
        do
        {
          long long v106 = (unsigned __int8 *)*((void *)v102 + 2);
          BOOL v86 = *(void *)v106 == (void)v102;
          std::string v102 = v106;
        }
        while (!v86);
      }
      std::string v102 = v106;
      if (v101 == (unsigned __int8 *)&v167) {
        goto LABEL_254;
      }
    }
    goto LABEL_256;
  }
LABEL_254:
  sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
  long long v107 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "#I Placeholder ICCIDs matches user enabled ICCIDs - skipping", buf, 2u);
  }
LABEL_325:
  sub_10004D2C8(v45);
LABEL_326:
  *(void *)long long buf = &v170;
  sub_100047F64((void ***)buf);
  if (SBYTE7(v169) < 0) {
    operator delete(v168[0]);
  }
  sub_10005CD2C((uint64_t)&v166 + 8, (char *)v167);
  if (SHIBYTE(v165[3]) < 0) {
    operator delete(v165[1]);
  }
  sub_1000C584C((uint64_t)v152);
  return sub_1000C584C((uint64_t)&v172);
}

void sub_100CBC794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  if (LOBYTE(STACK[0x770])) {
    sub_10030D10C((uint64_t)&STACK[0x290]);
  }
  sub_10004D2C8(a15);
  sub_100CBCA14((uint64_t)&a21);
  sub_1000C584C((uint64_t)&a63);
  _Unwind_Resume(a1);
}

BOOL sub_100CBC9C4(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 136);
  uint64_t v2 = *(void *)(a1 + 144);
  if (v3 == v2) {
    return 0;
  }
  uint64_t v4 = v3 + 88;
  do
  {
    int v5 = *(_DWORD *)(v4 - 88);
    BOOL result = v5 != 0;
    if (*(_DWORD *)(v4 - 84) == a2) {
      break;
    }
    BOOL v7 = a2 != 3 || v5 == 0;
    BOOL result = !v7;
    if (!v7) {
      break;
    }
    BOOL v7 = v4 == v2;
    v4 += 88;
  }
  while (!v7);
  return result;
}

uint64_t sub_100CBCA14(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 304);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 295) < 0) {
    operator delete(*(void **)(a1 + 272));
  }
  sub_10005CD2C(a1 + 248, *(char **)(a1 + 256));
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  return sub_1000C584C(a1);
}

void sub_100CBCA80(uint64_t a1, void **a2, int a3)
{
  if (!*(unsigned char *)(a1 + 752)) {
    return;
  }
  if (a3)
  {
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      sub_1000E8F34((std::string *)*a2, (std::string *)(a2 + 1), ",", 1uLL, __p);
      if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v6 = __p;
      }
      else {
        uint64_t v6 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
      }
      LODWORD(v29[0]) = 136315138;
      *(void **)((char *)v29 + 4) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I apply user selected enabled iccids [%s] to placeholder.", (uint8_t *)v29, 0xCu);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
    }
    if ((void **)(a1 + 672) != a2) {
      sub_1000EA390((uint64_t **)(a1 + 672), *a2, a2 + 1);
    }
    return;
  }
  memset(v29, 0, 32);
  memset(&v33, 0, sizeof(v33));
  if (*(char *)(a1 + 463) < 0)
  {
    if (!*(void *)(a1 + 448))
    {
LABEL_24:
      char v12 = 0;
      char v13 = 1;
      goto LABEL_25;
    }
  }
  else if (!*(unsigned char *)(a1 + 463))
  {
    goto LABEL_24;
  }
  BOOL v7 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v7) {
    goto LABEL_24;
  }
  unsigned int v8 = std::__shared_weak_count::lock(v7);
  if (!v8) {
    goto LABEL_24;
  }
  uint64_t v9 = v8;
  uint64_t v10 = *(void *)(a1 + 72);
  if (!v10 || ((*(void (**)(std::string *__return_ptr))(*(void *)v10 + 104))(__p), !v32))
  {
    char v13 = 1;
    goto LABEL_40;
  }
  std::string::size_type size = HIBYTE(v31.__r_.__value_.__r.__words[2]);
  if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v31.__r_.__value_.__l.__size_;
  }
  if (!size) {
    goto LABEL_37;
  }
  if (__p[0].__r_.__value_.__s.__data_[4])
  {
    std::string::operator=(&v33, &v31);
LABEL_37:
    char v13 = 1;
    goto LABEL_38;
  }
  if (__p[0].__r_.__value_.__s.__data_[3]) {
    goto LABEL_37;
  }
  std::string::operator=(&v33, (const std::string *)(a1 + 440));
  char v13 = 0;
LABEL_38:
  if (v32) {
    sub_10030D10C((uint64_t)__p);
  }
LABEL_40:
  sub_10004D2C8(v9);
  char v12 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
  std::string::size_type v18 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v18 = v33.__r_.__value_.__l.__size_;
  }
  if (!v18)
  {
LABEL_25:
    uint64_t v14 = (std::string *)*a2;
    if (*a2 != a2 + 1)
    {
      while (!sub_100CA6CF8(a1, (unsigned __int8 **)&v14[1].__r_.__value_.__l.__size_))
      {
        BOOL v15 = (std::string *)v14->__r_.__value_.__l.__size_;
        if (v15)
        {
          do
          {
            uint64_t v16 = (std::string **)v15;
            BOOL v15 = (std::string *)v15->__r_.__value_.__r.__words[0];
          }
          while (v15);
        }
        else
        {
          do
          {
            uint64_t v16 = (std::string **)v14->__r_.__value_.__r.__words[2];
            BOOL v17 = *v16 == v14;
            uint64_t v14 = (std::string *)v16;
          }
          while (!v17);
        }
        uint64_t v14 = (std::string *)v16;
        if (v16 == (std::string **)(a2 + 1)) {
          goto LABEL_43;
        }
      }
      std::string::operator=(&v33, (std::string *)((char *)v14 + 32));
      char v12 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
    }
  }
LABEL_43:
  LOBYTE(v29[0]) = v13;
  if (v12 < 0)
  {
    sub_10004FC84(&v29[1], v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v33.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    *(std::string *)&v29[1] = v33;
  }
  uint64_t v19 = (capabilities::ct *)sub_100CB1074(a1);
  if (v19)
  {
    sub_1000C6C34((uint64_t *)(a1 + 672), (void **)*a2, (void **)a2 + 1);
  }
  else if (capabilities::ct::supportsGemini(v19))
  {
    sub_10005CD2C(a1 + 672, *(char **)(a1 + 680));
    *(void *)(a1 + 672) = a1 + 680;
    *(void *)(a1 + 688) = 0;
    *(void *)(a1 + 680) = 0;
    uint64_t v22 = (std::string *)*a2;
    uint64_t v20 = (std::string *)(a2 + 1);
    char v21 = v22;
    if (v22 != v20)
    {
      do
      {
        char v23 = sub_100CB1134(a1, (uint64_t)&v21[1].__r_.__value_.__l.__size_);
        if (LOBYTE(v29[0])) {
          char v24 = v23;
        }
        else {
          char v24 = 1;
        }
        if (v24) {
          sub_100046BAC((uint64_t **)(a1 + 672), (void **)&v21[1].__r_.__value_.__l.__size_, (uint64_t)&v21[1].__r_.__value_.__l.__size_);
        }
        size_t v25 = (std::string *)v21->__r_.__value_.__l.__size_;
        if (v25)
        {
          do
          {
            uint64_t v26 = v25;
            size_t v25 = (std::string *)v25->__r_.__value_.__r.__words[0];
          }
          while (v25);
        }
        else
        {
          do
          {
            uint64_t v26 = (std::string *)v21->__r_.__value_.__r.__words[2];
            BOOL v17 = v26->__r_.__value_.__r.__words[0] == (void)v21;
            char v21 = v26;
          }
          while (!v17);
        }
        char v21 = v26;
      }
      while (v26 != v20);
    }
    if (LOBYTE(v29[0])) {
      sub_100046BAC((uint64_t **)(a1 + 672), (void **)(a1 + 440), a1 + 440);
    }
  }
  sub_1000E9358((uint64_t **)(a1 + 672), &v29[1]);
  uint64_t v27 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000E8F34(*(std::string **)(a1 + 672), (std::string *)(a1 + 680), ",", 1uLL, __p);
    int v28 = (__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? __p
        : (std::string *)__p[0].__r_.__value_.__r.__words[0];
    LODWORD(v33.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v33.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I placeholder iccids to enable [%s]", (uint8_t *)&v33, 0xCu);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
  }
  if (SHIBYTE(v29[3]) < 0) {
    operator delete(v29[1]);
  }
}

void sub_100CBCEEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  if (LOBYTE(STACK[0x508])) {
    sub_10030D10C((uint64_t)va);
  }
  sub_10004D2C8(v6);
  if (*(char *)(v7 - 89) < 0) {
    operator delete(*(void **)(v7 - 112));
  }
  _Unwind_Resume(a1);
}

void sub_100CBCF58(uint64_t a1, long long *a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 336) >= 2u)
  {
    uint64_t v4 = *((unsigned __int8 *)a2 + 23);
    if ((v4 & 0x80u) != 0) {
      uint64_t v4 = *((void *)a2 + 1);
    }
    if (v4)
    {
      (***(void (****)(long long *__return_ptr))(a1 + 56))(&v61);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v7, (Registry *)v61);
      uint64_t v9 = ServiceMap;
      if (v10 < 0)
      {
        unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          uint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      v46[0] = (void *)v10;
      uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)v46);
      if (v14)
      {
        uint64_t v16 = v14[3];
        BOOL v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
          goto LABEL_13;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      BOOL v15 = 0;
      char v17 = 1;
LABEL_13:
      if (*((void *)&v61 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v61 + 1));
      }
      long long __dst = 0uLL;
      uint64_t v54 = 0;
      if (*((char *)a2 + 23) < 0)
      {
        sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
      }
      else
      {
        long long __dst = *a2;
        uint64_t v54 = *((void *)a2 + 2);
      }
      uint64_t v52 = 0;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      *(_OWORD *)uint64_t v46 = 0u;
      *(_OWORD *)uint64_t v47 = 0u;
      (*(void (**)(void **__return_ptr, uint64_t, long long *))(*(void *)v16 + 176))(v46, v16, &__dst);
      if (BYTE8(v50)) {
        goto LABEL_85;
      }
      uint64_t v18 = BYTE7(v50);
      if (SBYTE7(v50) < 0) {
        uint64_t v18 = *((void *)&v49 + 1);
      }
      if (!v18)
      {
        int v35 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)a2 + 23) >= 0) {
            xpc_object_t v36 = a2;
          }
          else {
            xpc_object_t v36 = *(long long **)a2;
          }
          LODWORD(v61) = 136315138;
          *(void *)((char *)&v61 + 4) = v36;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I create new sim label for plan [%s]", (uint8_t *)&v61, 0xCu);
        }
        uint64_t v67 = 0;
        long long v65 = 0u;
        long long __p = 0u;
        long long v63 = 0u;
        long long v64 = 0u;
        long long v61 = 0u;
        long long v62 = 0u;
        (*(void (**)(long long *__return_ptr, uint64_t, long long *, uint64_t))(*(void *)v16 + 208))(&v61, v16, &__dst, a3);
        uint64_t v37 = BYTE7(v65);
        char v38 = BYTE7(v65);
        if (SBYTE7(v65) < 0) {
          uint64_t v37 = *((void *)&v64 + 1);
        }
        if (!v37)
        {
          xpc_object_t v40 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
          {
            if (*((char *)a2 + 23) >= 0) {
              uint64_t v43 = a2;
            }
            else {
              uint64_t v43 = *(long long **)a2;
            }
            *(_DWORD *)long long buf = 136315138;
            uint64_t v56 = v43;
            _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "failed to create a valid sim label for plan [%s]", buf, 0xCu);
          }
          if (SHIBYTE(v67) < 0) {
            operator delete((void *)__p);
          }
          if (SBYTE7(v65) < 0) {
            operator delete((void *)v64);
          }
          if (SHIBYTE(v63) < 0) {
            operator delete(*((void **)&v62 + 1));
          }
          if (SBYTE7(v62) < 0) {
            operator delete((void *)v61);
          }
          goto LABEL_85;
        }
        if (SHIBYTE(v67) < 0)
        {
          operator delete((void *)__p);
          char v38 = BYTE7(v65);
        }
        if (v38 < 0) {
          operator delete((void *)v64);
        }
        if (SHIBYTE(v63) < 0) {
          operator delete(*((void **)&v62 + 1));
        }
        if (SBYTE7(v62) < 0) {
          operator delete((void *)v61);
        }
      }
      if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56)) & 1) == 0)
      {
        uint64_t v19 = *(std::__shared_weak_count **)(a1 + 80);
        if (v19)
        {
          uint64_t v20 = std::__shared_weak_count::lock(v19);
          if (v20)
          {
            uint64_t v21 = *(void *)(a1 + 72);
            if (v21)
            {
              (*(void (**)(long long *__return_ptr))(*(void *)v21 + 104))(&v61);
              if (v74)
              {
                int v22 = (char)v73;
                if ((v73 & 0x80u) == 0) {
                  uint64_t v23 = v73;
                }
                else {
                  uint64_t v23 = v72[1];
                }
                char v24 = *(NSObject **)(a1 + 40);
                BOOL v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
                if (v23)
                {
                  if (v25)
                  {
                    uint64_t v26 = (long long *)v72[0];
                    if (v22 >= 0) {
                      uint64_t v26 = (long long *)v72;
                    }
                    if (*((char *)a2 + 23) >= 0) {
                      uint64_t v27 = a2;
                    }
                    else {
                      uint64_t v27 = *(long long **)a2;
                    }
                    *(_DWORD *)long long buf = 136315394;
                    uint64_t v56 = v26;
                    __int16 v57 = 2080;
                    uint64_t v58 = v27;
                    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I attempt transfering sim label from source (%s) to new iccid (%s)", buf, 0x16u);
                  }
                  if ((*(uint64_t (**)(uint64_t, void *, long long *))(*(void *)v16 + 272))(v16, v72, a2))goto LABEL_101; {
                  uint64_t v28 = v71;
                  }
                  int v29 = (char)v71;
                  if ((v71 & 0x80u) != 0) {
                    uint64_t v28 = v70[1];
                  }
                  if (v28) {
                    goto LABEL_45;
                  }
                  uint64_t v30 = v69;
                  if ((v69 & 0x80u) != 0) {
                    uint64_t v30 = v68[1];
                  }
                  if (v30)
                  {
LABEL_45:
                    std::string v31 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                    {
                      char v32 = (long long *)v70[0];
                      if (v29 >= 0) {
                        char v32 = (long long *)v70;
                      }
                      if ((v69 & 0x80u) == 0) {
                        std::string v33 = (long long *)v68;
                      }
                      else {
                        std::string v33 = (long long *)v68[0];
                      }
                      if (*((char *)a2 + 23) >= 0) {
                        int v34 = a2;
                      }
                      else {
                        int v34 = *(long long **)a2;
                      }
                      *(_DWORD *)long long buf = 136315650;
                      uint64_t v56 = v32;
                      __int16 v57 = 2080;
                      uint64_t v58 = v33;
                      __int16 v59 = 2080;
                      int v60 = v34;
                      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I renaming to existing label (%s, %s) corresponding to the new iccid (%s)", buf, 0x20u);
                    }
                    (*(void (**)(void **__return_ptr, uint64_t, long long *, void *, void *, void))(*(void *)v16 + 216))(v45, v16, &__dst, v68, v70, 0);
                    sub_1001A7138((uint64_t)v45);
                    goto LABEL_101;
                  }
                  uint64_t v44 = *(NSObject **)(a1 + 40);
                  if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_101:
                    if (v74) {
                      sub_10030D10C((uint64_t)&v61);
                    }
                    goto LABEL_75;
                  }
                  *(_WORD *)long long buf = 0;
                  int v41 = "#I no known label from source plan, let user configure new plan from UI";
                  uint64_t v42 = v44;
                }
                else
                {
                  if (!v25) {
                    goto LABEL_101;
                  }
                  *(_WORD *)long long buf = 0;
                  int v41 = "#I no known source iccid, let user configure new plan from UI";
                  uint64_t v42 = v24;
                }
                _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, v41, buf, 2u);
                goto LABEL_101;
              }
LABEL_75:
              sub_10004D2C8(v20);
              goto LABEL_85;
            }
          }
        }
        else
        {
          uint64_t v20 = 0;
        }
        long long v39 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v61) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "delegate is not available", (uint8_t *)&v61, 2u);
          if (!v20) {
            goto LABEL_85;
          }
          goto LABEL_75;
        }
        if (v20) {
          goto LABEL_75;
        }
      }
LABEL_85:
      if (SHIBYTE(v52) < 0) {
        operator delete((void *)v51);
      }
      if (SBYTE7(v50) < 0) {
        operator delete((void *)v49);
      }
      if (SHIBYTE(v48) < 0) {
        operator delete(v47[1]);
      }
      if (SHIBYTE(v47[0]) < 0) {
        operator delete(v46[0]);
      }
      if (SHIBYTE(v54) < 0) {
        operator delete((void *)__dst);
      }
      if ((v17 & 1) == 0) {
        sub_10004D2C8(v15);
      }
    }
  }
}

void sub_100CBD674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  if (LOBYTE(STACK[0x600])) {
    sub_10030D10C((uint64_t)&a48);
  }
  sub_10004D2C8(v49);
  sub_1001A7138((uint64_t)&a23);
  if (a42 < 0) {
    operator delete(__p);
  }
  if ((v50 & 1) == 0) {
    sub_10004D2C8(v48);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CBD70C(uint64_t a1)
{
  if (capabilities::ct::getProvisioningProfileSupport((capabilities::ct *)a1))
  {
    uint64_t v3 = *(void *)(a1 + 136);
    uint64_t v4 = *(void *)(a1 + 144);
    while (v3 != v4)
    {
      uint64_t v16 = 0;
      long long v14 = 0u;
      long long v15 = 0u;
      long long v13 = 0u;
      memset(v12, 0, sizeof(v12));
      sub_1000C5DA8((uint64_t)v12, v3);
      if (!(_BYTE)v16)
      {
        int v6 = 3;
        goto LABEL_24;
      }
      if ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56))) {
        goto LABEL_5;
      }
      if (*(char *)(a1 + 927) < 0)
      {
        sub_10004FC84(__p, *(void **)(a1 + 904), *(void *)(a1 + 912));
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)(a1 + 904);
        uint64_t v9 = *(void *)(a1 + 920);
      }
      sub_100CB60FC(a1, (uint64_t)__p, (uint64_t)v10);
      if (SHIBYTE(v9) < 0) {
        operator delete(__p[0]);
      }
      if (v11 && *(unsigned char *)(a1 + 752))
      {
        char v1 = 1;
      }
      else
      {
        if (!*(void *)(a1 + 808) && (*(_DWORD *)(a1 + 336) < 2u || (int)sub_100CBD964(a1, SDWORD1(v12[0]), 0) <= 0))
        {
          sub_1000C584C((uint64_t)v10);
LABEL_5:
          uint64_t v5 = *((void *)&v14 + 1);
          if (*((void *)&v14 + 1) != (void)v15)
          {
            while (!*(unsigned char *)(v5 + 88))
            {
              v5 += 216;
              if (v5 == (void)v15)
              {
                uint64_t v5 = v15;
                break;
              }
            }
          }
          int v6 = v5 != (void)v15;
          v1 |= v6;
          goto LABEL_22;
        }
        char v1 = 0;
      }
      sub_1000C584C((uint64_t)v10);
      int v6 = 1;
LABEL_22:
      if ((_BYTE)v16)
      {
        v10[0] = (void **)&v14 + 1;
        sub_1000C57C8(v10);
      }
LABEL_24:
      if (SBYTE7(v14) < 0) {
        operator delete((void *)v13);
      }
      if (v6 != 3 && v6) {
        return v1 & 1;
      }
      v3 += 88;
    }
  }
  char v1 = 0;
  return v1 & 1;
}

void sub_100CBD91C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  sub_1000C584C((uint64_t)&a15);
  sub_10015A318(v15 - 160);
  _Unwind_Resume(a1);
}

uint64_t sub_100CBD964(uint64_t a1, int a2, char a3)
{
  uint64_t v10 = 0;
  v11[0] = 0;
  v11[1] = 0;
  sub_100CBFAC0(a1, a2, a3, (uint64_t **)&v10);
  uint64_t v3 = (uint64_t *)v10;
  if (v10 == v11)
  {
    uint64_t v4 = 0;
  }
  else
  {
    LODWORD(v4) = 0;
    do
    {
      uint64_t v5 = (char *)v3[1];
      int v6 = (char *)v3;
      if (v5)
      {
        do
        {
          uint64_t v7 = (char **)v5;
          uint64_t v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v7 = (char **)*((void *)v6 + 2);
          BOOL v8 = *v7 == v6;
          int v6 = (char *)v7;
        }
        while (!v8);
      }
      uint64_t v4 = v4 - 1431655765 * ((unint64_t)(v3[7] - v3[6]) >> 3);
      uint64_t v3 = (uint64_t *)v7;
    }
    while (v7 != v11);
  }
  sub_100347268((uint64_t)&v10, v11[0]);
  return v4;
}

uint64_t sub_100CBDA1C(uint64_t a1, int a2)
{
  memset(&__s1, 0, sizeof(__s1));
  uint64_t v4 = *(void *)(a1 + 136);
  uint64_t v5 = *(void *)(a1 + 144);
  if (v4 != v5)
  {
    while (1)
    {
      uint64_t v33 = 0;
      long long v31 = 0u;
      long long v32 = 0u;
      *(_OWORD *)long long __p = 0u;
      memset(v29, 0, sizeof(v29));
      sub_1000C5DA8((uint64_t)v29, v4);
      if (!(_BYTE)v33)
      {
        int v14 = 3;
        goto LABEL_28;
      }
      uint64_t v6 = *((void *)&v31 + 1);
      uint64_t v7 = v32;
      while (1)
      {
        if (v6 == v7)
        {
          int v14 = 0;
          goto LABEL_26;
        }
        if (!*(unsigned char *)(v6 + 88)) {
          goto LABEL_22;
        }
        std::string::operator=(&__s1, (const std::string *)(v6 + 16));
        uint64_t v8 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
        if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = __s1.__r_.__value_.__l.__size_;
        }
        uint64_t v10 = *(unsigned __int8 *)(a1 + 927);
        int v11 = (char)v10;
        if ((v10 & 0x80u) != 0) {
          uint64_t v10 = *(void *)(a1 + 912);
        }
        if (size != v10) {
          goto LABEL_22;
        }
        uint64_t v12 = v11 >= 0 ? (unsigned __int8 *)(a1 + 904) : *(unsigned __int8 **)(a1 + 904);
        if ((*((unsigned char *)&__s1.__r_.__value_.__s + 23) & 0x80) != 0) {
          break;
        }
        if (!*((unsigned char *)&__s1.__r_.__value_.__s + 23)) {
          goto LABEL_25;
        }
        p_s1 = &__s1;
        while (p_s1->__r_.__value_.__s.__data_[0] == *v12)
        {
          p_s1 = (std::string *)((char *)p_s1 + 1);
          ++v12;
          if (!--v8) {
            goto LABEL_25;
          }
        }
LABEL_22:
        v6 += 216;
      }
      if (memcmp(__s1.__r_.__value_.__l.__data_, v12, __s1.__r_.__value_.__l.__size_)) {
        goto LABEL_22;
      }
LABEL_25:
      int v14 = 1;
LABEL_26:
      if ((_BYTE)v33)
      {
        uint64_t v28 = (void **)&v31 + 1;
        sub_1000C57C8(&v28);
      }
LABEL_28:
      if (SBYTE7(v31) < 0) {
        operator delete(__p[0]);
      }
      if (v14 != 3 && v14)
      {
        uint64_t v25 = 1;
        if ((*((unsigned char *)&__s1.__r_.__value_.__s + 23) & 0x80) != 0) {
          goto LABEL_61;
        }
        return v25;
      }
      v4 += 88;
      if (v4 == v5)
      {
        unsigned int v15 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
        std::string::size_type v16 = __s1.__r_.__value_.__l.__size_;
        goto LABEL_35;
      }
    }
  }
  std::string::size_type v16 = 0;
  unsigned int v15 = 0;
LABEL_35:
  if ((v15 & 0x80u) == 0) {
    std::string::size_type v17 = v15;
  }
  else {
    std::string::size_type v17 = v16;
  }
  if (v17) {
    BOOL v18 = a2 == 0;
  }
  else {
    BOOL v18 = 1;
  }
  if (v18 || (uint64_t v19 = *(void *)(a1 + 160), v20 = *(void *)(a1 + 168), v19 == v20))
  {
LABEL_58:
    uint64_t v25 = 0;
    if ((v15 & 0x80) != 0) {
      goto LABEL_61;
    }
    return v25;
  }
  if ((v15 & 0x80u) == 0) {
    uint64_t v21 = &__s1;
  }
  else {
    uint64_t v21 = (std::string *)__s1.__r_.__value_.__r.__words[0];
  }
  while (1)
  {
    uint64_t v22 = *(unsigned __int8 *)(v19 + 95);
    if ((v22 & 0x80u) == 0) {
      uint64_t v23 = *(unsigned __int8 *)(v19 + 95);
    }
    else {
      uint64_t v23 = *(void *)(v19 + 80);
    }
    if (v23 != v17) {
      goto LABEL_57;
    }
    if ((v22 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v19 + 95)) {
      goto LABEL_63;
    }
    uint64_t v24 = 0;
    while (*(unsigned __int8 *)(v19 + v24 + 72) == v21->__r_.__value_.__s.__data_[v24])
    {
      if (v22 == ++v24) {
        goto LABEL_63;
      }
    }
LABEL_57:
    v19 += 168;
    if (v19 == v20) {
      goto LABEL_58;
    }
  }
  if (memcmp(*(const void **)(v19 + 72), v21, *(void *)(v19 + 80))) {
    goto LABEL_57;
  }
LABEL_63:
  uint64_t v25 = 1;
  if ((v15 & 0x80) != 0) {
LABEL_61:
  }
    operator delete(__s1.__r_.__value_.__l.__data_);
  return v25;
}

void sub_100CBDCA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CBDCD4(void *a1, int a2)
{
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v15 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v13 = 0u;
  sGetProfileDetails();
  memset(&v10, 0, sizeof(v10));
  if (sub_100CBD70C((uint64_t)a1))
  {
    if (a2)
    {
      uint64_t v4 = a1[17];
      for (uint64_t i = a1[18]; v4 != i; v4 += 88)
      {
        *(void *)&long long v17 = 0;
        long long v15 = 0u;
        long long v16 = 0u;
        long long v13 = 0u;
        *(_OWORD *)long long __p = 0u;
        *(_OWORD *)long long buf = 0u;
        sub_1000C5DA8((uint64_t)buf, v4);
        if ((_BYTE)v17)
        {
          uint64_t v6 = *((void *)&v15 + 1);
          uint64_t v7 = v16;
          if (*((void *)&v15 + 1) == (void)v16) {
            goto LABEL_15;
          }
          do
          {
            while (!*(unsigned char *)(v6 + 88))
            {
              v6 += 216;
              if (v6 == v7) {
                goto LABEL_14;
              }
            }
            std::string::operator=(&v10, (const std::string *)(v6 + 16));
            v6 += 216;
          }
          while (*(_DWORD *)&buf[4] != 2 && v6 != v7);
LABEL_14:
          if ((_BYTE)v17)
          {
LABEL_15:
            int v11 = (void **)&v15 + 1;
            sub_1000C57C8(&v11);
          }
        }
        if (SBYTE7(v15) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  else
  {
    uint64_t v9 = a1[5];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E Bootstrap unavailable", buf, 2u);
    }
  }
  sub_100CB44AC((uint64_t)a1, &v10, &v10);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_100CBDEC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

void *sub_100CBDEFC@<X0>(void *result@<X0>, int a2@<W1>, void *a3@<X8>)
{
  for (uint64_t i = result[17]; i != result[18]; i += 88)
  {
    if (*(_DWORD *)(i + 4) == a2)
    {
      if (!*(unsigned char *)(i + 80)) {
        return sub_100058DB0(a3, "");
      }
      for (uint64_t j = *(void *)(i + 56); j != *(void *)(i + 64); j += 216)
      {
        if (*(unsigned char *)(j + 88))
        {
          if (*(char *)(j + 39) < 0) {
            return sub_10004FC84(a3, *(void **)(j + 16), *(void *)(j + 24));
          }
          long long v5 = *(_OWORD *)(j + 16);
          a3[2] = *(void *)(j + 32);
          *(_OWORD *)a3 = v5;
          return result;
        }
      }
    }
  }
  return sub_100058DB0(a3, "");
}

uint64_t sub_100CBDF7C(uint64_t a1)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(a1 + 784));
  return v1 & 1;
}

void *sub_100CBDF8C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = a1 + 872;
  BOOL result = (void *)sub_100CBFD40((unsigned __int8 **)(a1 + 872), *(void *)(a1 + 160), *(void *)(a1 + 168));
  if (result)
  {
    if (*(char *)(a1 + 895) < 0)
    {
      uint64_t v6 = *(void **)(a1 + 872);
      unint64_t v7 = *(void *)(a1 + 880);
      return sub_10004FC84((unsigned char *)a2, v6, v7);
    }
    else
    {
      *(_OWORD *)a2 = *(_OWORD *)v4;
      *(void *)(a2 + 16) = *(void *)(v4 + 16);
    }
  }
  else
  {
    return sub_100058DB0((void *)a2, "");
  }
  return result;
}

unint64_t sub_100CBE040(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  uint64_t v3 = *(void *)(a1 + 144);
  long long v9 = *a2;
  if (v2 != v3)
  {
    while (*(void *)(v2 + 16) != (void)v9 || *(void *)(v2 + 24) != *((void *)&v9 + 1))
    {
      v2 += 88;
      if (v2 == v3) {
        goto LABEL_10;
      }
    }
  }
  if (v2 == v3)
  {
LABEL_10:
    int v6 = 0;
    unint64_t v7 = 0;
    unsigned int v5 = 0;
  }
  else
  {
    int v6 = *(_DWORD *)(v2 + 4);
    unsigned int v5 = v6 & 0xFFFFFF00;
    int v6 = v6;
    unint64_t v7 = &_mh_execute_header;
  }
  return (unint64_t)v7 | v5 | v6;
}

unint64_t sub_100CBE0F0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int **)(a1 + 160);
  uint64_t v4 = *(unsigned int **)(a1 + 168);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
  }
  char v5 = HIBYTE(v13);
  if (v3 != v4)
  {
    if (v13 >= 0) {
      int v6 = (void *)HIBYTE(v13);
    }
    else {
      int v6 = __p[1];
    }
    if (v13 >= 0) {
      unint64_t v7 = __p;
    }
    else {
      unint64_t v7 = (void **)__p[0];
    }
    while (1)
    {
      uint64_t v8 = *((unsigned __int8 *)v3 + 95);
      if ((v8 & 0x80u) == 0) {
        long long v9 = (void *)*((unsigned __int8 *)v3 + 95);
      }
      else {
        long long v9 = (void *)*((void *)v3 + 10);
      }
      if (v9 == v6)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*((const void **)v3 + 9), v7, *((void *)v3 + 10)))
          {
LABEL_22:
            if (v3[16] == 1) {
              break;
            }
          }
        }
        else
        {
          if (!*((unsigned char *)v3 + 95)) {
            goto LABEL_22;
          }
          uint64_t v10 = 0;
          while (*((unsigned __int8 *)v3 + v10 + 72) == *((unsigned __int8 *)v7 + v10))
          {
            if (v8 == ++v10) {
              goto LABEL_22;
            }
          }
        }
      }
      v3 += 42;
      if (v3 == v4)
      {
        uint64_t v3 = v4;
        break;
      }
    }
  }
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  if (v3 == *(unsigned int **)(a1 + 168)) {
    return 0;
  }
  else {
    return *v3 | (unint64_t)&_mh_execute_header;
  }
}

uint64_t sub_100CBE22C@<X0>(uint64_t result@<X0>, int a2@<W1>, unsigned char *a3@<X8>)
{
  uint64_t v3 = *(void *)(result + 136);
  uint64_t v4 = *(void *)(result + 144);
  if (v3 != v4)
  {
    while (*(_DWORD *)(v3 + 4) != a2)
    {
      v3 += 88;
      if (v3 == v4) {
        goto LABEL_8;
      }
    }
  }
  if (v3 == v4 || *(_DWORD *)(v3 + 12) != 3)
  {
LABEL_8:
    char v5 = 0;
    *a3 = 0;
  }
  else
  {
    *(_OWORD *)a3 = *(_OWORD *)(v3 + 16);
    char v5 = 1;
  }
  a3[16] = v5;
  return result;
}

void *sub_100CBE288@<X0>(void *result@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v3 = result[17];
  uint64_t v4 = result[18];
  if (v3 != v4)
  {
    while (*(_DWORD *)(v3 + 4) != a2)
    {
      v3 += 88;
      if (v3 == v4) {
        return sub_100058DB0(a3, "");
      }
    }
  }
  if (v3 == v4) {
    return sub_100058DB0(a3, "");
  }
  if (*(char *)(v3 + 55) < 0) {
    return sub_10004FC84(a3, *(void **)(v3 + 32), *(void *)(v3 + 40));
  }
  long long v5 = *(_OWORD *)(v3 + 32);
  a3[2] = *(void *)(v3 + 48);
  *(_OWORD *)a3 = v5;
  return result;
}

BOOL sub_100CBE2F0(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  uint64_t v3 = *(void *)(a1 + 144);
  if (v2 != v3)
  {
    while (*(_DWORD *)(v2 + 4) != a2)
    {
      v2 += 88;
      if (v2 == v3) {
        return 0;
      }
    }
  }
  if (v2 == v3 || !*(unsigned char *)(v2 + 80)) {
    return 0;
  }
  uint64_t v5 = *(void *)(v2 + 56);
  uint64_t v4 = *(void *)(v2 + 64);
  if (v5 != v4)
  {
    while (!*(unsigned char *)(v5 + 91))
    {
      v5 += 216;
      if (v5 == v4)
      {
        uint64_t v5 = v4;
        return v5 != v4;
      }
    }
  }
  return v5 != v4;
}

uint64_t sub_100CBE360@<X0>(uint64_t a1@<X0>, void **a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = (uint64_t)sub_100046F68(a1 + 264, a2);
  if (a1 + 272 != result)
  {
    long long v19 = 0u;
    long long v18 = 0u;
    long long v17 = 0u;
    long long v16 = 0u;
    long long v15 = 0u;
    long long v14 = 0u;
    long long v13 = 0u;
    long long v12 = 0u;
    long long v11 = 0u;
    long long v10 = 0u;
    long long v9 = 0u;
    long long v8 = 0u;
    long long v7 = 0u;
    long long v6 = 0u;
    uint64_t result = sGetProfileDetails();
  }
  *a3 = 0;
  a3[784] = 0;
  return result;
}

void sub_100CBE678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  sub_10030525C((uint64_t)&a55);
  sub_10030AF48(v55);
  if (LOBYTE(STACK[0x558])) {
    sub_1000C584C((uint64_t)&STACK[0x480]);
  }
  _Unwind_Resume(a1);
}

char *sub_100CBE6E4(char *__dst, std::string *__str)
{
  if (__dst[784])
  {
    std::string::operator=((std::string *)__dst, __str);
    std::string::value_type v4 = __str[1].__r_.__value_.__s.__data_[2];
    *((_WORD *)__dst + 12) = __str[1].__r_.__value_.__l.__data_;
    __dst[26] = v4;
    std::string::operator=((std::string *)(__dst + 32), (std::string *)((char *)__str + 32));
    sub_100827168(__dst + 56, (uint64_t)&__str[2].__r_.__value_.__l.__size_);
    sub_1008272B4((uint64_t)(__dst + 400), (uint64_t)&__str[16].__r_.__value_.__r.__words[2]);
    sub_100179AF8((std::string *)(__dst + 752), (std::string *)((char *)__str + 752));
  }
  else
  {
    sub_100827714(__dst, (long long *)__str);
    __dst[784] = 1;
  }
  return __dst;
}

void sub_100CBE778(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 64))(*(void *)(a1 + 56)) & 1) == 0)
  {
    std::string::value_type v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v5 = "#N User select plans not supported";
      goto LABEL_7;
    }
LABEL_8:
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
    return;
  }
  if (*(_DWORD *)(a1 + 788) >= 2u)
  {
    std::string::value_type v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v5 = "#N Multiple profiles could be enabled";
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 2u);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v13 = 0;
  sub_100CB5FE4(a1, buf);
  if ((SHIBYTE(v13) & 0x80000000) == 0)
  {
    if (HIBYTE(v13))
    {
      *(_OWORD *)long long __p = *(_OWORD *)buf;
      uint64_t v11 = v13;
      goto LABEL_15;
    }
LABEL_20:
    long long v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I No user selection to get phone number", (uint8_t *)__p, 2u);
    }
    goto LABEL_22;
  }
  if (!*(void *)&buf[8]) {
    goto LABEL_20;
  }
  sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
LABEL_15:
  long long v6 = sub_100046F68(a1 + 312, __p);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  if ((void **)(a1 + 320) != v6)
  {
    if (*((char *)v6 + 159) < 0)
    {
      sub_10004FC84((unsigned char *)a2, v6[17], (unint64_t)v6[18]);
    }
    else
    {
      long long v7 = *(_OWORD *)(v6 + 17);
      *(void *)(a2 + 16) = v6[19];
      *(_OWORD *)a2 = v7;
    }
    char v9 = 1;
    goto LABEL_25;
  }
LABEL_22:
  char v9 = 0;
  *(unsigned char *)a2 = 0;
LABEL_25:
  *(unsigned char *)(a2 + 24) = v9;
  if (SHIBYTE(v13) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100CBE958(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CBE990(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 64))(*(void *)(a1 + 56)) & 1) == 0)
  {
    std::string::value_type v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v5 = "#N User select plans not supported";
      goto LABEL_7;
    }
LABEL_8:
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
    return;
  }
  if (*(_DWORD *)(a1 + 788) >= 2u)
  {
    std::string::value_type v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v5 = "#N Multiple profiles could be enabled";
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 2u);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
  *(void *)long long buf = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_100CB5FE4(a1, buf);
  uint64_t v6 = HIBYTE(v12);
  if (v12 < 0) {
    uint64_t v6 = v11;
  }
  if (v6)
  {
    sub_100CBAC70(&v8, a1, (uint64_t)buf);
    *(_OWORD *)a2 = v8;
    *(void *)(a2 + 16) = v9;
    *(unsigned char *)(a2 + 24) = 1;
  }
  else
  {
    long long v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I No user selection to get phone number", (uint8_t *)&v8, 2u);
    }
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100CBEB14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100CBEB30@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[752])
  {
    if (result[463] < 0)
    {
      return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 55), *((void *)result + 56));
    }
    else
    {
      *(_OWORD *)a2 = *(_OWORD *)(result + 440);
      *(void *)(a2 + 16) = *((void *)result + 57);
    }
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  return result;
}

char *sub_100CBEB70@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[752])
  {
    if (result[663] < 0)
    {
      return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 80), *((void *)result + 81));
    }
    else
    {
      *(_OWORD *)a2 = *((_OWORD *)result + 40);
      *(void *)(a2 + 16) = *((void *)result + 82);
    }
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  return result;
}

void *sub_100CBEBB4@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (!*((unsigned char *)result + 752)) {
    return sub_100058DB0(a2, "");
  }
  if (*((char *)result + 511) < 0) {
    return sub_10004FC84(a2, (void *)result[61], result[62]);
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 61);
  a2[2] = result[63];
  return result;
}

void sub_100CBEBF8(void *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  uint64_t v2 = a1[20];
  uint64_t v3 = a1[21];
  if (v2 != v3)
  {
    uint64_t v4 = (uint64_t)(a1 + 33);
    uint64_t v5 = (void **)(a1 + 34);
    uint64_t v6 = v2 + 64;
    do
    {
      if ((subscriber::isEsimCapable() & 1) == 0)
      {
        if (*(char *)(v6 + 31) < 0)
        {
          if (!*(void *)(v6 + 16)) {
            goto LABEL_4;
          }
        }
        else if (!*(unsigned char *)(v6 + 31))
        {
          goto LABEL_4;
        }
        long long v8 = sub_100046F68(v4, (void **)(v6 + 8));
        if (v5 != v8)
        {
          uint64_t v9 = v8;
          if (*((char *)v8 + 79) < 0)
          {
            if (v8[8])
            {
LABEL_15:
              sub_100058DB0(&v35, "");
              char v37 = 1;
              if (*((char *)v9 + 103) < 0)
              {
                sub_10004FC84(&v38, v9[10], (unint64_t)v9[11]);
              }
              else
              {
                long long v38 = *((_OWORD *)v9 + 5);
                uint64_t v39 = (uint64_t)v9[12];
              }
              if (*((char *)v9 + 127) < 0)
              {
                sub_10004FC84(&v40, v9[13], (unint64_t)v9[14]);
              }
              else
              {
                long long v40 = *(_OWORD *)(v9 + 13);
                uint64_t v41 = (uint64_t)v9[15];
              }
              if (*((char *)v9 + 151) < 0)
              {
                sub_10004FC84(&__p, v9[16], (unint64_t)v9[17]);
              }
              else
              {
                long long __p = *((_OWORD *)v9 + 8);
                uint64_t v43 = (uint64_t)v9[18];
              }
              if (*((char *)v9 + 175) < 0)
              {
                sub_10004FC84(&v44, v9[19], (unint64_t)v9[20]);
              }
              else
              {
                long long v44 = *(_OWORD *)(v9 + 19);
                uint64_t v45 = (uint64_t)v9[21];
              }
              v46[0] = (long long *)(v9 + 7);
              long long v10 = sub_10086299C((uint64_t **)a2, v9 + 7, (uint64_t)&unk_10144E20E, v46);
              uint64_t v11 = v5;
              sub_100179CB0((uint64_t)(v10 + 7), &v35);
              uint64_t v12 = (void **)(v10 + 11);
              if (*((char *)v10 + 111) < 0) {
                operator delete(*v12);
              }
              v10[13] = v39;
              *(_OWORD *)uint64_t v12 = v38;
              HIBYTE(v39) = 0;
              LOBYTE(v38) = 0;
              uint64_t v13 = (void **)(v10 + 14);
              if (*((char *)v10 + 135) < 0) {
                operator delete(*v13);
              }
              v10[16] = v41;
              *(_OWORD *)uint64_t v13 = v40;
              HIBYTE(v41) = 0;
              LOBYTE(v40) = 0;
              long long v14 = (void **)(v10 + 17);
              if (*((char *)v10 + 159) < 0) {
                operator delete(*v14);
              }
              v10[19] = v43;
              *(_OWORD *)long long v14 = __p;
              HIBYTE(v43) = 0;
              LOBYTE(__p) = 0;
              long long v15 = (void **)(v10 + 20);
              if (*((char *)v10 + 183) < 0)
              {
                operator delete(*v15);
                int v16 = SHIBYTE(v43);
                *(_OWORD *)long long v15 = v44;
                v10[22] = v45;
                HIBYTE(v45) = 0;
                LOBYTE(v44) = 0;
                if (v16 < 0) {
                  operator delete((void *)__p);
                }
              }
              else
              {
                *(_OWORD *)long long v15 = v44;
                v10[22] = v45;
                HIBYTE(v45) = 0;
                LOBYTE(v44) = 0;
              }
              uint64_t v5 = v11;
              if (SHIBYTE(v41) < 0) {
                operator delete((void *)v40);
              }
              if (SHIBYTE(v39) < 0) {
                operator delete((void *)v38);
              }
              if (v37 && v36 < 0) {
                operator delete((void *)v35.n128_u64[0]);
              }
            }
          }
          else if (*((unsigned char *)v8 + 79))
          {
            goto LABEL_15;
          }
        }
      }
LABEL_4:
      uint64_t v7 = v6 + 104;
      v6 += 168;
    }
    while (v7 != v3);
  }
  uint64_t v17 = a1[17];
  uint64_t v32 = a1[18];
  if (v17 != v32)
  {
    long long v18 = (void **)(a1 + 34);
    while (*(_DWORD *)(v17 + 12) != 3 || !*(unsigned char *)(v17 + 80))
    {
LABEL_93:
      v17 += 88;
      if (v17 == v32) {
        return;
      }
    }
    uint64_t v20 = *(void *)(v17 + 56);
    uint64_t v19 = *(void *)(v17 + 64);
    while (1)
    {
      if (v20 == v19) {
        goto LABEL_93;
      }
      if (*(char *)(v20 + 39) < 0) {
        uint64_t v21 = *(void *)(v20 + 24);
      }
      else {
        uint64_t v21 = *(unsigned __int8 *)(v20 + 39);
      }
      if (v21) {
        BOOL v22 = *(unsigned char *)(v20 + 88) == 0;
      }
      else {
        BOOL v22 = 0;
      }
      if (v22)
      {
        long long v23 = sub_100046F68((uint64_t)(a1 + 33), (void **)(v20 + 16));
        if (v18 != v23)
        {
          long long v24 = v23;
          if (*((char *)v23 + 79) < 0)
          {
            if (!v23[8]) {
              goto LABEL_92;
            }
          }
          else if (!*((unsigned char *)v23 + 79))
          {
            goto LABEL_92;
          }
          sub_100058DB0(&v35, "");
          char v37 = 1;
          if (*((char *)v24 + 103) < 0)
          {
            sub_10004FC84(&v38, v24[10], (unint64_t)v24[11]);
          }
          else
          {
            long long v38 = *((_OWORD *)v24 + 5);
            uint64_t v39 = (uint64_t)v24[12];
          }
          if (*((char *)v24 + 127) < 0)
          {
            sub_10004FC84(&v40, v24[13], (unint64_t)v24[14]);
          }
          else
          {
            long long v40 = *(_OWORD *)(v24 + 13);
            uint64_t v41 = (uint64_t)v24[15];
          }
          if (*((char *)v24 + 151) < 0)
          {
            sub_10004FC84(&__p, v24[16], (unint64_t)v24[17]);
          }
          else
          {
            long long __p = *((_OWORD *)v24 + 8);
            uint64_t v43 = (uint64_t)v24[18];
          }
          if (*((char *)v24 + 175) < 0)
          {
            sub_10004FC84(&v44, v24[19], (unint64_t)v24[20]);
          }
          else
          {
            long long v44 = *(_OWORD *)(v24 + 19);
            uint64_t v45 = (uint64_t)v24[21];
          }
          v46[0] = (long long *)(v24 + 7);
          long long v25 = sub_10086299C((uint64_t **)a2, v24 + 7, (uint64_t)&unk_10144E20E, v46);
          uint64_t v26 = v18;
          sub_100179CB0((uint64_t)(v25 + 7), &v35);
          uint64_t v27 = (void **)(v25 + 11);
          if (*((char *)v25 + 111) < 0) {
            operator delete(*v27);
          }
          v25[13] = v39;
          *(_OWORD *)uint64_t v27 = v38;
          HIBYTE(v39) = 0;
          LOBYTE(v38) = 0;
          uint64_t v28 = (void **)(v25 + 14);
          if (*((char *)v25 + 135) < 0) {
            operator delete(*v28);
          }
          v25[16] = v41;
          *(_OWORD *)uint64_t v28 = v40;
          HIBYTE(v41) = 0;
          LOBYTE(v40) = 0;
          int v29 = (void **)(v25 + 17);
          if (*((char *)v25 + 159) < 0) {
            operator delete(*v29);
          }
          v25[19] = v43;
          *(_OWORD *)int v29 = __p;
          HIBYTE(v43) = 0;
          LOBYTE(__p) = 0;
          uint64_t v30 = (void **)(v25 + 20);
          if (*((char *)v25 + 183) < 0)
          {
            operator delete(*v30);
            int v31 = SHIBYTE(v43);
            *(_OWORD *)uint64_t v30 = v44;
            v25[22] = v45;
            HIBYTE(v45) = 0;
            LOBYTE(v44) = 0;
            if (v31 < 0) {
              operator delete((void *)__p);
            }
          }
          else
          {
            *(_OWORD *)uint64_t v30 = v44;
            v25[22] = v45;
            HIBYTE(v45) = 0;
            LOBYTE(v44) = 0;
          }
          long long v18 = v26;
          if (SHIBYTE(v41) < 0) {
            operator delete((void *)v40);
          }
          if (SHIBYTE(v39) < 0) {
            operator delete((void *)v38);
          }
          if (v37)
          {
            if (v36 < 0) {
              operator delete((void *)v35.n128_u64[0]);
            }
          }
        }
      }
LABEL_92:
      v20 += 216;
    }
  }
}

void sub_100CBF1E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  if (a18)
  {
    if (a17 < 0) {
      operator delete(a12);
    }
  }
  sub_10010E37C(a10, *(void **)(a10 + 8));
  _Unwind_Resume(a1);
}

void sub_100CBF29C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 136);
  uint64_t v21 = *(void *)(a1 + 144);
  if (v3 != v21)
  {
    while (1)
    {
      uint64_t v22 = v3;
      if (*(_DWORD *)(v3 + 12) == 3)
      {
        if (*(unsigned char *)(v3 + 80)) {
          break;
        }
      }
LABEL_41:
      uint64_t v3 = v22 + 88;
      if (v22 + 88 == v21) {
        goto LABEL_42;
      }
    }
    uint64_t v6 = *(void *)(v3 + 56);
    uint64_t v5 = *(void *)(v3 + 64);
    for (uint64_t i = *(void *)(v22 + 64); ; v5 = i)
    {
      if (v6 == v5) {
        goto LABEL_41;
      }
      if (*(char *)(v6 + 39) < 0)
      {
        if (!*(void *)(v6 + 24)) {
          goto LABEL_40;
        }
      }
      else if (!*(unsigned char *)(v6 + 39))
      {
        goto LABEL_40;
      }
      sub_100CD7084(v6 + 16, (uint64_t)__p);
      std::locale::locale(&v24);
      std::locale::locale(&v27, &v24);
      if ((v26 & 0x80u) == 0) {
        uint64_t v7 = __p;
      }
      else {
        uint64_t v7 = (void **)__p[0];
      }
      if ((v26 & 0x80u) == 0) {
        unint64_t v8 = v26;
      }
      else {
        unint64_t v8 = (unint64_t)__p[1];
      }
      int v9 = *(char *)(a2 + 23);
      if (v9 >= 0) {
        long long v10 = (char *)a2;
      }
      else {
        long long v10 = *(char **)a2;
      }
      if (v9 >= 0) {
        uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        uint64_t v11 = *(void *)(a2 + 8);
      }
      if (v8 && v11)
      {
        uint64_t v12 = v11 - 1;
        uint64_t v13 = (char *)(v8 - 1);
        long long v14 = v10;
        long long v15 = (char *)v7;
        while (sub_100326220(&v27, v15, v14))
        {
          ++v15;
          ++v14;
          if (v13)
          {
            uint64_t v16 = v12--;
            --v13;
            if (v16) {
              continue;
            }
          }
          goto LABEL_30;
        }
        BOOL v18 = 0;
      }
      else
      {
        long long v15 = (char *)v7;
        long long v14 = v10;
LABEL_30:
        BOOL v18 = v15 == (char *)v7 + v8 && v14 == &v10[v11];
      }
      std::locale::~locale(&v27);
      std::locale::~locale(&v24);
      if ((char)v26 < 0) {
        operator delete(__p[0]);
      }
      if (v18)
      {
        if (*(char *)(v6 + 39) < 0)
        {
          sub_10004FC84((unsigned char *)a3, *(void **)(v6 + 16), *(void *)(v6 + 24));
        }
        else
        {
          long long v19 = *(_OWORD *)(v6 + 16);
          *(void *)(a3 + 16) = *(void *)(v6 + 32);
          *(_OWORD *)a3 = v19;
        }
        return;
      }
LABEL_40:
      v6 += 216;
    }
  }
LABEL_42:
  sub_100058DB0((void *)a3, "");
}

void sub_100CBF494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::locale a21)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CBF4C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 136);
  uint64_t v2 = *(void *)(a1 + 144);
  uint64_t v32 = v2;
  while (v3 != v2)
  {
    if (*(_DWORD *)(v3 + 12) == 3 && *(unsigned char *)(v3 + 80))
    {
      uint64_t v5 = *(void *)(v3 + 56);
      uint64_t v4 = *(void *)(v3 + 64);
      for (uint64_t i = v4; v5 != v4; v4 = i)
      {
        if (*(char *)(v5 + 39) < 0)
        {
          if (!*(void *)(v5 + 24)) {
            goto LABEL_41;
          }
        }
        else if (!*(unsigned char *)(v5 + 39))
        {
          goto LABEL_41;
        }
        sub_100CD7084(v5 + 16, (uint64_t)&__p);
        std::locale::locale(&v35);
        std::locale::locale(&v39, &v35);
        if ((v38 & 0x80u) == 0) {
          p_p = (char *)&__p;
        }
        else {
          p_p = (char *)__p;
        }
        if ((v38 & 0x80u) == 0) {
          uint64_t v7 = v38;
        }
        else {
          uint64_t v7 = v37;
        }
        int v8 = *(char *)(a2 + 23);
        if (v8 >= 0) {
          int v9 = (char *)a2;
        }
        else {
          int v9 = *(char **)a2;
        }
        if (v8 >= 0) {
          uint64_t v10 = *(unsigned __int8 *)(a2 + 23);
        }
        else {
          uint64_t v10 = *(void *)(a2 + 8);
        }
        if (v7 && v10)
        {
          uint64_t v11 = v10 - 1;
          uint64_t v12 = v7 - 1;
          uint64_t v13 = v9;
          long long v14 = p_p;
          while (sub_100326220(&v39, v14, v13))
          {
            ++v14;
            ++v13;
            if (v12)
            {
              uint64_t v15 = v11--;
              --v12;
              if (v15) {
                continue;
              }
            }
            goto LABEL_31;
          }
          BOOL v17 = 0;
        }
        else
        {
          long long v14 = p_p;
          uint64_t v13 = v9;
LABEL_31:
          BOOL v17 = v14 == &p_p[v7] && v13 == &v9[v10];
        }
        std::locale::~locale(&v39);
        std::locale::~locale(&v35);
        if ((char)v38 < 0) {
          operator delete(__p);
        }
        if (v17) {
          return 1;
        }
LABEL_41:
        v5 += 216;
      }
    }
    v3 += 88;
    uint64_t v2 = v32;
  }
  if (!*(unsigned char *)(a1 + 752)) {
    return 0;
  }
  sub_100CD7084(a1 + 440, (uint64_t)&__p);
  std::locale::locale(&v35);
  std::locale::locale(&v39, &v35);
  if ((v38 & 0x80u) == 0) {
    BOOL v18 = (char *)&__p;
  }
  else {
    BOOL v18 = (char *)__p;
  }
  if ((v38 & 0x80u) == 0) {
    uint64_t v19 = v38;
  }
  else {
    uint64_t v19 = v37;
  }
  int v20 = *(char *)(a2 + 23);
  if (v20 >= 0) {
    uint64_t v21 = (char *)a2;
  }
  else {
    uint64_t v21 = *(char **)a2;
  }
  if (v20 >= 0) {
    uint64_t v22 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v22 = *(void *)(a2 + 8);
  }
  if (v19 && v22)
  {
    uint64_t v23 = v22 - 1;
    uint64_t v24 = v19 - 1;
    long long v25 = v21;
    unsigned __int8 v26 = v18;
    while (sub_100326220(&v39, v26, v25))
    {
      ++v26;
      ++v25;
      if (v24)
      {
        uint64_t v27 = v23--;
        --v24;
        if (v27) {
          continue;
        }
      }
      goto LABEL_66;
    }
    BOOL v28 = 0;
  }
  else
  {
    unsigned __int8 v26 = v18;
    long long v25 = v21;
LABEL_66:
    BOOL v28 = v26 == &v18[v19] && v25 == &v21[v22];
  }
  std::locale::~locale(&v39);
  std::locale::~locale(&v35);
  if ((char)v38 < 0) {
    operator delete(__p);
  }
  return v28;
}

void sub_100CBF764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::locale a21)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100CBF794(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (v2)
  {
    uint64_t v11 = (long long *)a2;
    uint64_t v4 = sub_100CC3268((uint64_t **)(a1 + 264), (void **)a2, &v11);
    if (v4[189])
    {
      if (v4[188] && v4[592])
      {
        v4[456] = 4;
        uint64_t v11 = 0;
        unint64_t v12 = 0;
        unint64_t v13 = 0;
        uint64_t v5 = *(void **)(a1 + 264);
        if (v5 != (void *)(a1 + 272))
        {
          unint64_t v6 = 0;
          do
          {
            if (*((unsigned char *)v5 + 592))
            {
              uint64_t v7 = (uint64_t)(v5 + 50);
              if (v6 >= v13)
              {
                unint64_t v6 = sub_1003DD108((uint64_t *)&v11, v7);
              }
              else
              {
                sub_10023FB90(v6, v7);
                v6 += 192;
              }
              unint64_t v12 = v6;
            }
            int v8 = (void *)v5[1];
            if (v8)
            {
              do
              {
                int v9 = v8;
                int v8 = (void *)*v8;
              }
              while (v8);
            }
            else
            {
              do
              {
                int v9 = (void *)v5[2];
                BOOL v10 = *v9 == (void)v5;
                uint64_t v5 = v9;
              }
              while (!v10);
            }
            uint64_t v5 = v9;
          }
          while (v9 != (void *)(a1 + 272));
        }
        (*(void (**)(void, long long **))(**(void **)(a1 + 120) + 56))(*(void *)(a1 + 120), &v11);
        long long v14 = &v11;
        sub_10023FDC8((void ***)&v14);
      }
    }
  }
}

void sub_100CBF8D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10023FDC8(&a12);
  _Unwind_Resume(a1);
}

char *sub_100CBF900@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[1159] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 142), *((void *)result + 143));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 71);
  *(void *)(a2 + 16) = *((void *)result + 144);
  return result;
}

BOOL sub_100CBF930(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a2[23];
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *((void *)a2 + 1);
  }
  if (v3)
  {
    uint64_t v3 = a3[23];
    if ((v3 & 0x80u) != 0) {
      uint64_t v3 = *((void *)a3 + 1);
    }
    if (v3)
    {
      uint64_t v6 = a1 + 216;
      if (sub_10010E128(a1 + 216, (void **)a2))
      {
        uint64_t v7 = (unsigned __int8 *)sub_10005DDEC(v6, (void **)a2);
        uint64_t v8 = v7[23];
        size_t v9 = *((void *)v7 + 1);
        if ((v8 & 0x80u) == 0) {
          uint64_t v10 = v7[23];
        }
        else {
          uint64_t v10 = *((void *)v7 + 1);
        }
        uint64_t v11 = a3[23];
        int v12 = (char)v11;
        if ((v11 & 0x80u) != 0) {
          uint64_t v11 = *((void *)a3 + 1);
        }
        if (v10 == v11)
        {
          if (v12 >= 0) {
            unint64_t v13 = a3;
          }
          else {
            unint64_t v13 = *(unsigned __int8 **)a3;
          }
          if ((v8 & 0x80) == 0)
          {
            if (v7[23])
            {
              uint64_t v14 = v8 - 1;
              do
              {
                int v16 = *v7++;
                int v15 = v16;
                int v18 = *v13++;
                int v17 = v18;
                BOOL v19 = v14-- != 0;
                char v20 = v19;
                BOOL v21 = v15 == v17;
                uint64_t v3 = v15 == v17;
              }
              while (v21 && (v20 & 1) != 0);
              return v3;
            }
            return 1;
          }
          return memcmp(*(const void **)v7, v13, v9) == 0;
        }
        return 0;
      }
      if (!sub_10010E128(v6, (void **)a3)) {
        return 0;
      }
      uint64_t v7 = (unsigned __int8 *)sub_10005DDEC(v6, (void **)a3);
      uint64_t v22 = v7[23];
      size_t v9 = *((void *)v7 + 1);
      if ((v22 & 0x80u) == 0) {
        uint64_t v23 = v7[23];
      }
      else {
        uint64_t v23 = *((void *)v7 + 1);
      }
      uint64_t v24 = a2[23];
      int v25 = (char)v24;
      if ((v24 & 0x80u) != 0) {
        uint64_t v24 = *((void *)a2 + 1);
      }
      if (v23 != v24) {
        return 0;
      }
      if (v25 >= 0) {
        unint64_t v13 = a2;
      }
      else {
        unint64_t v13 = *(unsigned __int8 **)a2;
      }
      if ((v22 & 0x80) != 0) {
        return memcmp(*(const void **)v7, v13, v9) == 0;
      }
      if (!v7[23]) {
        return 1;
      }
      uint64_t v26 = v22 - 1;
      do
      {
        int v28 = *v7++;
        int v27 = v28;
        int v30 = *v13++;
        int v29 = v30;
        BOOL v19 = v26-- != 0;
        char v31 = v19;
        BOOL v21 = v27 == v29;
        uint64_t v3 = v27 == v29;
      }
      while (v21 && (v31 & 1) != 0);
    }
  }
  return v3;
}

void sub_100CBFAC0(uint64_t a1@<X0>, int a2@<W1>, char a3@<W2>, uint64_t **a4@<X8>)
{
  a4[1] = 0;
  uint64_t v4 = a4 + 1;
  a4[2] = 0;
  *a4 = (uint64_t *)(a4 + 1);
  uint64_t v5 = *(void *)(a1 + 136);
  for (uint64_t i = *(void *)(a1 + 144); v5 != i; v5 += 88)
  {
    BOOL v11 = *(_DWORD *)(v5 + 4) != a2 && a2 != 3 || *(_DWORD *)v5 == 0;
    if (!v11 && *(unsigned char *)(v5 + 80))
    {
      char v31 = 0;
      uint64_t v32 = 0;
      unint64_t v33 = 0;
      uint64_t v12 = *(void *)(v5 + 56);
      uint64_t v13 = *(void *)(v5 + 64);
      if (v12 != v13)
      {
        uint64_t v14 = 0;
        do
        {
          if ((a3 & 1) != 0 || !*(unsigned char *)(v12 + 88))
          {
            int v15 = (long long *)(v12 + 16);
            if ((unint64_t)v14 >= v33)
            {
              uint64_t v14 = (std::string *)sub_10030E9EC((uint64_t *)&v31, v15);
            }
            else
            {
              if (*(char *)(v12 + 39) < 0)
              {
                sub_10004FC84(v14, *(void **)(v12 + 16), *(void *)(v12 + 24));
              }
              else
              {
                long long v16 = *v15;
                v14->__r_.__value_.__r.__words[2] = *(void *)(v12 + 32);
                *(_OWORD *)&v14->__r_.__value_.__l.__data_ = v16;
              }
              ++v14;
            }
            uint64_t v32 = (long long *)v14;
          }
          v12 += 216;
        }
        while (v12 != v13);
        if (v14 != v31)
        {
          int v17 = *v4;
          int v18 = v4;
          BOOL v19 = v4;
          if (!*v4) {
            goto LABEL_44;
          }
          int v18 = v4;
          while (1)
          {
            while (1)
            {
              uint64_t v20 = 0;
              BOOL v19 = (uint64_t **)v17;
              do
              {
                unsigned int v21 = *(unsigned __int8 *)(v5 + v20 + 16);
                unsigned int v22 = *((unsigned __int8 *)v19 + v20 + 32);
              }
              while (v21 == v22 && v20++ != 15);
              if (v21 >= v22) {
                break;
              }
              int v17 = *v19;
              int v18 = v19;
              if (!*v19) {
                goto LABEL_44;
              }
            }
            uint64_t v24 = 0;
            do
            {
              unsigned int v25 = *((unsigned __int8 *)v19 + v24 + 32);
              unsigned int v26 = *(unsigned __int8 *)(v5 + v24 + 16);
            }
            while (v25 == v26 && v24++ != 15);
            if (v25 >= v26) {
              break;
            }
            int v18 = v19 + 1;
            int v17 = v19[1];
            if (!v17) {
              goto LABEL_44;
            }
          }
          if (!v19)
          {
LABEL_44:
            int v28 = operator new(0x48uLL);
            _OWORD v28[2] = *(_OWORD *)(v5 + 16);
            *((void *)v28 + 7) = 0;
            *((void *)v28 + 8) = 0;
            *((void *)v28 + 6) = 0;
            *(void *)int v28 = 0;
            *((void *)v28 + 1) = 0;
            *((void *)v28 + 2) = v19;
            char *v18 = (uint64_t *)v28;
            int v29 = (uint64_t *)**a4;
            int v30 = (uint64_t *)v28;
            if (v29)
            {
              *a4 = v29;
              int v30 = *v18;
            }
            sub_100046C90(a4[1], v30);
            a4[2] = (uint64_t *)((char *)a4[2] + 1);
            BOOL v19 = (uint64_t **)v28;
          }
          if (v19 + 6 != (uint64_t **)&v31) {
            sub_10005CA3C((uint64_t)(v19 + 6), v31, v32, 0xAAAAAAAAAAAAAAABLL * (((char *)v32 - (char *)v31) >> 3));
          }
        }
      }
      int v34 = &v31;
      sub_100047F64((void ***)&v34);
    }
  }
}

void sub_100CBFD08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_100047F64(&a12);
  sub_100347268(v12, *(char **)(v12 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100CBFD40(unsigned __int8 **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (unsigned __int8 *)*((unsigned __int8 *)a1 + 23);
  if ((char)v3 < 0) {
    uint64_t v3 = a1[1];
  }
  if (!v3) {
    return 1;
  }
  while (a2 != a3)
  {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 95);
    if ((v7 & 0x80u) == 0) {
      uint64_t v8 = (unsigned __int8 *)*(unsigned __int8 *)(a2 + 95);
    }
    else {
      uint64_t v8 = *(unsigned __int8 **)(a2 + 80);
    }
    size_t v9 = (unsigned __int8 *)*((unsigned __int8 *)a1 + 23);
    int v10 = (char)v9;
    if ((char)v9 < 0) {
      size_t v9 = a1[1];
    }
    if (v8 != v9) {
      goto LABEL_22;
    }
    if (v10 >= 0) {
      BOOL v11 = (unsigned __int8 *)a1;
    }
    else {
      BOOL v11 = *a1;
    }
    if ((v7 & 0x80) != 0)
    {
      if (memcmp(*(const void **)(a2 + 72), v11, *(void *)(a2 + 80))) {
        goto LABEL_22;
      }
    }
    else if (*(unsigned char *)(a2 + 95))
    {
      uint64_t v12 = 0;
      while (*(unsigned __int8 *)(a2 + v12 + 72) == v11[v12])
      {
        if (v7 == ++v12) {
          goto LABEL_21;
        }
      }
      goto LABEL_22;
    }
LABEL_21:
    if (!subscriber::isEsimCapable()) {
      return 1;
    }
LABEL_22:
    a2 += 168;
  }
  sGetProfileDetails();
  BOOL v13 = v16 != 0;
  if (v16) {
    sub_1000C584C((uint64_t)v15);
  }
  return v13;
}

uint64_t sub_100CBFE90(void *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = (unsigned int *)a1[20];
  uint64_t v5 = (unsigned int *)a1[21];
  if ((char)a2[23] < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v30 = *((void *)a2 + 2);
  }
  char v6 = HIBYTE(v30);
  if (v4 != v5)
  {
    if (v30 >= 0) {
      uint64_t v7 = (void *)HIBYTE(v30);
    }
    else {
      uint64_t v7 = __p[1];
    }
    if (v30 >= 0) {
      uint64_t v8 = __p;
    }
    else {
      uint64_t v8 = (void **)__p[0];
    }
    do
    {
      uint64_t v9 = *((unsigned __int8 *)v4 + 95);
      if ((v9 & 0x80u) == 0) {
        int v10 = (void *)*((unsigned __int8 *)v4 + 95);
      }
      else {
        int v10 = (void *)*((void *)v4 + 10);
      }
      if (v10 == v7)
      {
        if ((v9 & 0x80) != 0)
        {
          if (!memcmp(*((const void **)v4 + 9), v8, *((void *)v4 + 10))) {
            goto LABEL_24;
          }
        }
        else
        {
          if (!*((unsigned char *)v4 + 95)) {
            goto LABEL_24;
          }
          uint64_t v11 = 0;
          while (*((unsigned __int8 *)v4 + v11 + 72) == *((unsigned __int8 *)v8 + v11))
          {
            if (v9 == ++v11) {
              goto LABEL_24;
            }
          }
        }
      }
      v4 += 42;
    }
    while (v4 != v5);
    uint64_t v4 = v5;
  }
LABEL_24:
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v4 == (unsigned int *)a1[21] || (uint64_t v12 = *v4, !v12))
  {
    uint64_t v16 = a1[17];
    uint64_t v17 = a1[18];
    if (v16 != v17)
    {
      signed __int8 v18 = v2[23];
      if (v18 >= 0) {
        uint64_t v19 = v2[23];
      }
      else {
        uint64_t v19 = *((void *)v2 + 1);
      }
      if (v18 >= 0) {
        uint64_t v20 = v2;
      }
      else {
        uint64_t v20 = *(unsigned __int8 **)v2;
      }
      do
      {
        if (*(unsigned char *)(v16 + 80)) {
          BOOL v21 = *(_DWORD *)(v16 + 12) == 3;
        }
        else {
          BOOL v21 = 0;
        }
        if (v21)
        {
          uint64_t v22 = *(void *)(v16 + 56);
          uint64_t v23 = *(void *)(v16 + 64);
          while (v22 != v23)
          {
            uint64_t v24 = *(unsigned __int8 *)(v22 + 39);
            if ((v24 & 0x80u) == 0) {
              uint64_t v25 = *(unsigned __int8 *)(v22 + 39);
            }
            else {
              uint64_t v25 = *(void *)(v22 + 24);
            }
            if (v25 == v19)
            {
              if ((v24 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v22 + 16), v20, *(void *)(v22 + 24)))
                {
LABEL_58:
                  uint64_t v12 = *(unsigned int *)(v16 + 4);
                  if (v12) {
                    goto LABEL_61;
                  }
                  break;
                }
              }
              else
              {
                if (!*(unsigned char *)(v22 + 39)) {
                  goto LABEL_58;
                }
                uint64_t v26 = 0;
                while (*(unsigned __int8 *)(v22 + v26 + 16) == v20[v26])
                {
                  if (v24 == ++v26) {
                    goto LABEL_58;
                  }
                }
              }
            }
            v22 += 216;
          }
        }
        v16 += 88;
      }
      while (v16 != v17);
    }
    uint64_t v12 = 0;
LABEL_61:
    BOOL v13 = a1[5];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if ((v2[23] & 0x80u) != 0) {
        uint64_t v2 = *(unsigned __int8 **)v2;
      }
      uint64_t v27 = subscriber::asString();
      *(_DWORD *)long long buf = 136315394;
      uint64_t v32 = v2;
      __int16 v33 = 2080;
      uint64_t v34 = v27;
      int v15 = "#I vinyl info slot for ICCID [%s] : %s";
      goto LABEL_65;
    }
  }
  else
  {
    BOOL v13 = a1[5];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if ((v2[23] & 0x80u) != 0) {
        uint64_t v2 = *(unsigned __int8 **)v2;
      }
      uint64_t v14 = subscriber::asString();
      *(_DWORD *)long long buf = 136315394;
      uint64_t v32 = v2;
      __int16 v33 = 2080;
      uint64_t v34 = v14;
      int v15 = "#I sim info slot for ICCID [%s] : %s";
LABEL_65:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v15, buf, 0x16u);
    }
  }
  return v12;
}

void sub_100CC016C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    log = v2;
    sub_100CA8010(&v40, a1);
    uint64_t v3 = v40;
    memset(&v42, 0, sizeof(v42));
    if ((char **)v40 != v41)
    {
      int v4 = *(unsigned __int8 *)sub_10005DDEC(a1 + 792, (void **)(v40 + 32));
      if (*(char *)(v3 + 55) >= 0) {
        size_t v5 = *(unsigned __int8 *)(v3 + 55);
      }
      else {
        size_t v5 = *(void *)(v3 + 40);
      }
      if (v4) {
        size_t v6 = 6;
      }
      else {
        size_t v6 = 7;
      }
      memset(&__s, 0, sizeof(__s));
      p_s = &__s;
      sub_1000C140C((uint64_t)&__s, v5 + v6);
      if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
      }
      if (v5)
      {
        if (*(char *)(v3 + 55) >= 0) {
          uint64_t v8 = (const void *)(v3 + 32);
        }
        else {
          uint64_t v8 = *(const void **)(v3 + 32);
        }
        memmove(p_s, v8, v5);
      }
      if (v4) {
        uint64_t v9 = "(true)";
      }
      else {
        uint64_t v9 = "(false)";
      }
      memcpy((char *)p_s + v5, v9, v6);
      p_s->__r_.__value_.__s.__data_[v5 + v6] = 0;
      int v10 = *(char **)(v3 + 8);
      std::string v42 = __s;
      if (v10)
      {
        do
        {
          uint64_t v11 = (char **)v10;
          int v10 = *(char **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = *(char ***)(v3 + 16);
          BOOL v12 = *v11 == (char *)v3;
          uint64_t v3 = (uint64_t)v11;
        }
        while (!v12);
      }
      if (v11 != v41)
      {
        do
        {
          *((unsigned char *)&__s.__r_.__value_.__s + 23) = 1;
          strcpy((char *)&__s, ",");
          std::string::append(&v42, (const std::string::value_type *)&__s, 1uLL);
          if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__s.__r_.__value_.__l.__data_);
          }
          int v13 = *(unsigned __int8 *)sub_10005DDEC(a1 + 792, (void **)v11 + 4);
          if (*((char *)v11 + 55) >= 0) {
            size_t v14 = *((unsigned __int8 *)v11 + 55);
          }
          else {
            size_t v14 = (size_t)v11[5];
          }
          if (v13) {
            size_t v15 = 6;
          }
          else {
            size_t v15 = 7;
          }
          memset(&__s, 0, sizeof(__s));
          sub_1000C140C((uint64_t)&__s, v14 + v15);
          if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v16 = &__s;
          }
          else {
            uint64_t v16 = (std::string *)__s.__r_.__value_.__r.__words[0];
          }
          if (v14)
          {
            if (*((char *)v11 + 55) >= 0) {
              uint64_t v17 = (char *)(v11 + 4);
            }
            else {
              uint64_t v17 = v11[4];
            }
            memmove(v16, v17, v14);
          }
          if (v13) {
            signed __int8 v18 = "(true)";
          }
          else {
            signed __int8 v18 = "(false)";
          }
          memcpy((char *)v16 + v14, v18, v15);
          v16->__r_.__value_.__s.__data_[v14 + v15] = 0;
          if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v19 = &__s;
          }
          else {
            uint64_t v19 = (std::string *)__s.__r_.__value_.__r.__words[0];
          }
          if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(__s.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = __s.__r_.__value_.__l.__size_;
          }
          std::string::append(&v42, (const std::string::value_type *)v19, size);
          if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__s.__r_.__value_.__l.__data_);
          }
          BOOL v21 = v11[1];
          if (v21)
          {
            do
            {
              uint64_t v22 = (char **)v21;
              BOOL v21 = *(char **)v21;
            }
            while (v21);
          }
          else
          {
            do
            {
              uint64_t v22 = (char **)v11[2];
              BOOL v12 = *v22 == (char *)v11;
              uint64_t v11 = v22;
            }
            while (!v12);
          }
          uint64_t v11 = v22;
        }
        while (v22 != v41);
      }
    }
    uint64_t v23 = (std::string *)v42.__r_.__value_.__r.__words[0];
    if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v23 = &v42;
    }
    uint64_t v24 = (void *)(a1 + 872);
    if (*(char *)(a1 + 895) < 0) {
      uint64_t v24 = (void *)*v24;
    }
    uint64_t v25 = (void *)(a1 + 840);
    if (*(char *)(a1 + 863) < 0) {
      uint64_t v25 = (void *)*v25;
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v23;
    __int16 v44 = 2080;
    uint64_t v45 = v24;
    __int16 v46 = 2080;
    uint64_t v47 = v25;
    _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I User Selections: Profles %s, User Data [%s], Default Voice [%s]", buf, 0x20u);
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v42.__r_.__value_.__l.__data_);
    }
    sub_10005CD2C((uint64_t)&v40, v41[0]);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = (void *)(a1 + 904);
    if (*(char *)(a1 + 927) < 0) {
      uint64_t v26 = (void *)*v26;
    }
    uint64_t v27 = (void *)(a1 + 928);
    if (*(char *)(a1 + 951) < 0) {
      uint64_t v27 = (void *)*v27;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v26;
    __int16 v44 = 2080;
    uint64_t v45 = v27;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I System Selections: Profile [%s], User Data [%s]", buf, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = *(void *)(a1 + 280);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v28;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Cellular plan Map size: %lu", buf, 0xCu);
  }
  int v29 = *(void **)(a1 + 264);
  if (v29 != (void *)(a1 + 272))
  {
    do
    {
      uint64_t v30 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        char v31 = v29 + 4;
        if (*((char *)v29 + 55) < 0) {
          char v31 = (void *)*v31;
        }
        uint64_t v32 = v29 + 7;
        if (*((char *)v29 + 79) < 0) {
          uint64_t v32 = (void *)*v32;
        }
        int v33 = *((_DWORD *)v29 + 44);
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v31;
        __int16 v44 = 2080;
        uint64_t v45 = v32;
        __int16 v46 = 1024;
        LODWORD(v47) = v33;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I  iccid: [%s]: carrier: [%s], uuid: [%u]", buf, 0x1Cu);
      }
      uint64_t v34 = (void *)v29[1];
      if (v34)
      {
        do
        {
          std::locale v35 = v34;
          uint64_t v34 = (void *)*v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          std::locale v35 = (void *)v29[2];
          BOOL v12 = *v35 == (void)v29;
          int v29 = v35;
        }
        while (!v12);
      }
      int v29 = v35;
    }
    while (v35 != (void *)(a1 + 272));
  }
  char v36 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = (void *)(a1 + 816);
    if (*(char *)(a1 + 839) < 0) {
      uint64_t v37 = (void *)*v37;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v37;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I User disabled physical SIM [%s]", buf, 0xCu);
    char v36 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    sub_1008A2650(a1 + 976, buf);
    if (v46 >= 0) {
      unsigned __int8 v38 = buf;
    }
    else {
      unsigned __int8 v38 = *(unsigned char **)buf;
    }
    LODWORD(__s.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__s.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Source device user preferences: %s", (uint8_t *)&__s, 0xCu);
    if (SHIBYTE(v46) < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_100CC075C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char *a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_10005CD2C((uint64_t)&a12, a13);
  _Unwind_Resume(a1);
}

void sub_100CC07AC(char **a1, uint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v3 = (void **)(a3 + 1);
  int v4 = (void **)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    size_t v5 = a1;
    uint64_t v6 = a2 + 264;
    uint64_t v7 = (void **)(a2 + 272);
    while (1)
    {
      memset(&v51, 0, sizeof(v51));
      uint64_t v8 = sub_100046F68(v6, v4 + 4);
      if (v7 != v8) {
        std::string::operator=(&v51, (const std::string *)(v8 + 7));
      }
      sGetProfileDetails();
      if (v54)
      {
        char isEsimCapable = 1;
        char v10 = v53[88];
        goto LABEL_40;
      }
      uint64_t v12 = *(void *)(a2 + 160);
      uint64_t v11 = *(void *)(a2 + 168);
      if (v12 != v11) {
        break;
      }
      char isEsimCapable = 0;
LABEL_39:
      char v10 = 0;
      size_t v5 = a1;
LABEL_40:
      if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
      {
        sub_10004FC84(__dst, v51.__r_.__value_.__l.__data_, v51.__r_.__value_.__l.__size_);
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)&v51.__r_.__value_.__l.__data_;
        v42[0] = (void *)v51.__r_.__value_.__r.__words[2];
      }
      LOBYTE(v42[1]) = v10;
      BYTE1(v42[1]) = isEsimCapable;
      uint64_t v20 = (void **)v5[1];
      unint64_t v19 = (unint64_t)v5[2];
      if ((unint64_t)v20 >= v19)
      {
        uint64_t v23 = *v5;
        uint64_t v24 = ((char *)v20 - v23) >> 5;
        unint64_t v25 = v24 + 1;
        if ((unint64_t)(v24 + 1) >> 59) {
          sub_10006A748();
        }
        uint64_t v26 = v7;
        uint64_t v27 = v6;
        uint64_t v28 = v3;
        uint64_t v29 = v19 - (void)v23;
        if (v29 >> 4 > v25) {
          unint64_t v25 = v29 >> 4;
        }
        if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v30 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v30 = v25;
        }
        if (v30)
        {
          if (v30 >> 59) {
            sub_10006A7CC();
          }
          char v31 = (char *)operator new(32 * v30);
        }
        else
        {
          char v31 = 0;
        }
        uint64_t v32 = &v31[32 * v24];
        *(_OWORD *)uint64_t v32 = *(_OWORD *)__dst;
        *((void **)v32 + 2) = v42[0];
        int v33 = &v31[32 * v30];
        __dst[1] = 0;
        v42[0] = 0;
        __dst[0] = 0;
        v32[24] = v10;
        v32[25] = isEsimCapable;
        uint64_t v22 = v32 + 32;
        if (v20 == (void **)v23)
        {
          size_t v5 = a1;
          *a1 = v32;
          a1[1] = v22;
          a1[2] = v33;
          uint64_t v3 = v28;
        }
        else
        {
          do
          {
            long long v34 = *((_OWORD *)v20 - 2);
            *((void *)v32 - 2) = *(v20 - 2);
            *((_OWORD *)v32 - 2) = v34;
            *(v20 - 3) = 0;
            *(v20 - 2) = 0;
            *(v20 - 4) = 0;
            *(v32 - 8) = *((unsigned char *)v20 - 8);
            *(v32 - 7) = *((unsigned char *)v20 - 7);
            v32 -= 32;
            v20 -= 4;
          }
          while (v20 != (void **)v23);
          size_t v5 = a1;
          uint64_t v20 = (void **)*a1;
          std::locale v35 = (void **)a1[1];
          *a1 = v32;
          a1[1] = v22;
          a1[2] = v33;
          uint64_t v3 = v28;
          if (v35 != v20)
          {
            uint64_t v6 = v27;
            uint64_t v7 = v26;
            do
            {
              if (*((char *)v35 - 9) < 0) {
                operator delete(*(v35 - 4));
              }
              v35 -= 4;
            }
            while (v35 != v20);
            goto LABEL_65;
          }
        }
        uint64_t v6 = v27;
        uint64_t v7 = v26;
LABEL_65:
        if (v20) {
          operator delete(v20);
        }
        goto LABEL_67;
      }
      long long v21 = *(_OWORD *)__dst;
      v20[2] = v42[0];
      *(_OWORD *)uint64_t v20 = v21;
      __dst[1] = 0;
      v42[0] = 0;
      __dst[0] = 0;
      *((_WORD *)v20 + 12) = v42[1];
      uint64_t v22 = (char *)(v20 + 4);
LABEL_67:
      v5[1] = v22;
      if (SHIBYTE(v42[0]) < 0) {
        operator delete(__dst[0]);
      }
      if (v54) {
        sub_1000C584C((uint64_t)v53);
      }
      if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v51.__r_.__value_.__l.__data_);
      }
      char v36 = (void **)v4[1];
      if (v36)
      {
        do
        {
          uint64_t v37 = v36;
          char v36 = (void **)*v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          uint64_t v37 = (void **)v4[2];
          BOOL v38 = *v37 == v4;
          int v4 = v37;
        }
        while (!v38);
      }
      int v4 = v37;
      if (v37 == v3) {
        return;
      }
    }
    char isEsimCapable = 0;
    while (1)
    {
      uint64_t v50 = 0;
      long long v48 = 0u;
      *(_OWORD *)long long __p = 0u;
      *(_OWORD *)__int16 v46 = 0u;
      *(_OWORD *)uint64_t v47 = 0u;
      *(_OWORD *)std::string __s1 = 0u;
      *(_OWORD *)size_t __n = 0u;
      memset(v43, 0, sizeof(v43));
      *(_OWORD *)long long __dst = 0u;
      *(_OWORD *)std::string v42 = 0u;
      sub_10002E664((uint64_t)__dst, v12);
      uint64_t v13 = HIBYTE(__n[1]);
      if ((__n[1] & 0x8000000000000000) == 0) {
        size_t v14 = HIBYTE(__n[1]);
      }
      else {
        size_t v14 = __n[0];
      }
      size_t v15 = (void *)*((unsigned __int8 *)v4 + 55);
      int v16 = (char)v15;
      if ((char)v15 < 0) {
        size_t v15 = v4[5];
      }
      if ((void *)v14 != v15) {
        goto LABEL_26;
      }
      uint64_t v17 = v16 >= 0 ? v4 + 4 : (void **)v4[4];
      if ((__n[1] & 0x8000000000000000) == 0) {
        break;
      }
      if (!memcmp(__s1[1], v17, __n[0])) {
        goto LABEL_25;
      }
LABEL_26:
      if (SHIBYTE(v50) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v48) < 0) {
        operator delete(v47[1]);
      }
      if (SHIBYTE(v47[0]) < 0) {
        operator delete(v46[0]);
      }
      if (SHIBYTE(__n[1]) < 0) {
        operator delete(__s1[1]);
      }
      uint64_t v52 = (void **)v43 + 1;
      sub_10002E39C(&v52);
      if (v42[0])
      {
        v42[1] = v42[0];
        operator delete(v42[0]);
      }
      v12 += 168;
      if (v12 == v11) {
        goto LABEL_39;
      }
    }
    if (HIBYTE(__n[1]))
    {
      signed __int8 v18 = &__s1[1];
      while (*(unsigned __int8 *)v18 == *(unsigned __int8 *)v17)
      {
        signed __int8 v18 = (void **)((char *)v18 + 1);
        uint64_t v17 = (void **)((char *)v17 + 1);
        if (!--v13) {
          goto LABEL_25;
        }
      }
      goto LABEL_26;
    }
LABEL_25:
    char isEsimCapable = subscriber::isEsimCapable();
    goto LABEL_26;
  }
}

void sub_100CC0C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a72) {
    sub_1000C584C((uint64_t)&a47);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  long long __p = a12;
  sub_1003DDDFC((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_100CC0C98(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v7 = a1;
  long long v8 = *a4;
  if (*((char *)a4 + 39) < 0)
  {
    sub_10004FC84(__p, *((void **)a4 + 2), *((void *)a4 + 3));
  }
  else
  {
    *(_OWORD *)long long __p = a4[1];
    __p[2] = *((void **)a4 + 4);
  }
  char v10 = *((unsigned char *)a4 + 40);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100CC0E34(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100CC0E44(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
}

void sub_100CC0E4C(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v7 = a1;
  long long v8 = *a4;
  if (*((char *)a4 + 39) < 0)
  {
    sub_10004FC84(__p, *((void **)a4 + 2), *((void *)a4 + 3));
  }
  else
  {
    *(_OWORD *)long long __p = a4[1];
    __p[2] = *((void **)a4 + 4);
  }
  char v10 = *((unsigned char *)a4 + 40);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100CC0FE8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100CC0FF8(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
}

void sub_100CC1000(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100CC1174(uint64_t a1, unsigned __int16 a2, uint64_t a3)
{
}

void sub_100CC1180(uint64_t a1)
{
  unsigned __int8 v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100CC1260(uint64_t a1)
{
}

uint64_t sub_100CC1268(uint64_t a1)
{
  for (uint64_t i = 0; i != -96; i -= 48)
  {
    uint64_t v3 = a1 + i;
    if (*(char *)(a1 + i + 95) < 0) {
      operator delete(*(void **)(v3 + 72));
    }
    if (*(char *)(v3 + 71) < 0) {
      operator delete(*(void **)(v3 + 48));
    }
  }
  return a1;
}

void sub_100CC12C8(std::string *a1, uint64_t a2, void ***a3, void *a4)
{
  uint64_t v37 = 0;
  BOOL v38 = 0;
  v39[0] = 0;
  sub_100CC3120(&v37, a4[2]);
  long long v8 = (void *)*a4;
  uint64_t v9 = a4 + 1;
  char v10 = v37;
  if ((void *)*a4 != a4 + 1)
  {
    uint64_t v11 = *a3;
    while (1)
    {
      if (v11 == (void **)(a3 + 1)) {
        goto LABEL_30;
      }
      if ((sub_100046FE8(v8 + 4, v11 + 4) & 0x80) != 0) {
        break;
      }
      if ((sub_100046FE8(v11 + 4, (void **)v8 + 4) & 0x80) != 0)
      {
        signed __int8 v18 = (void **)v11[1];
        if (v18)
        {
          do
          {
            uint64_t v11 = v18;
            signed __int8 v18 = (void **)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            unint64_t v19 = v11;
            uint64_t v11 = (void **)v11[2];
          }
          while (*v11 != v19);
        }
      }
      else
      {
        uint64_t v12 = (void *)v8[1];
        if (v12)
        {
          do
          {
            uint64_t v13 = v12;
            uint64_t v12 = (void *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            uint64_t v13 = (void *)v8[2];
            BOOL v14 = *v13 == (void)v8;
            long long v8 = v13;
          }
          while (!v14);
        }
        size_t v15 = (void **)v11[1];
        if (v15)
        {
          do
          {
            uint64_t v11 = v15;
            size_t v15 = (void **)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            int v16 = v11;
            uint64_t v11 = (void **)v11[2];
          }
          while (*v11 != v16);
        }
LABEL_22:
        long long v8 = v13;
        if (v13 == v9)
        {
          long long v8 = a4 + 1;
          goto LABEL_30;
        }
      }
    }
    std::string::operator=(v10, (const std::string *)(v8 + 4));
    uint64_t v17 = (void *)v8[1];
    if (v17)
    {
      do
      {
        uint64_t v13 = v17;
        uint64_t v17 = (void *)*v17;
      }
      while (v17);
    }
    else
    {
      do
      {
        uint64_t v13 = (void *)v8[2];
        BOOL v14 = *v13 == (void)v8;
        long long v8 = v13;
      }
      while (!v14);
    }
    ++v10;
    goto LABEL_22;
  }
  uint64_t v9 = (void *)*a4;
LABEL_30:
  sub_10086123C((int)v40, v8, v9, v10);
  long long v21 = v38;
  uint64_t v22 = v20 - (void)v37;
  unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v20 - (uint64_t)v37) >> 3);
  int64_t v24 = (char *)v38 - (char *)v37;
  unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * (((char *)v38 - (char *)v37) >> 3);
  if (v23 <= v25)
  {
    if (v23 >= v25)
    {
      char v31 = (std::string::value_type *)v38;
      goto LABEL_48;
    }
    char v31 = &v37->__r_.__value_.__s.__data_[8 * ((v20 - (uint64_t)v37) >> 3)];
    while (v21 != (void **)v31)
    {
      if (*((char *)v21 - 1) < 0) {
        operator delete(*(v21 - 3));
      }
      v21 -= 3;
    }
LABEL_46:
    BOOL v38 = (void **)v31;
    goto LABEL_48;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39[0] - (void)v38) >> 3) >= v23 - v25)
  {
    size_t v32 = 24 * ((v22 - v24 - 24) / 0x18uLL) + 24;
    bzero(v38, v32);
    char v31 = (char *)v21 + v32;
    goto LABEL_46;
  }
  if (v23 > 0xAAAAAAAAAAAAAAALL) {
    sub_1000D8578();
  }
  if (0x5555555555555556 * ((uint64_t)(v39[0] - (void)v37) >> 3) > v23) {
    unint64_t v23 = 0x5555555555555556 * ((uint64_t)(v39[0] - (void)v37) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39[0] - (void)v37) >> 3) >= 0x555555555555555) {
    unint64_t v26 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v26 = v23;
  }
  v40[4] = (void **)v39;
  uint64_t v27 = (void **)sub_10004812C((uint64_t)v39, v26);
  uint64_t v28 = &v27[3 * v25];
  v40[0] = v27;
  v40[1] = v28;
  v40[3] = &v27[3 * v29];
  size_t v30 = 24 * ((v22 - v24 - 24) / 0x18uLL) + 24;
  bzero(v28, v30);
  v40[2] = (void **)((char *)v28 + v30);
  sub_100048204((uint64_t *)&v37, v40);
  sub_100048174((uint64_t)v40);
  char v31 = (std::string::value_type *)v38;
LABEL_48:
  if (v31 - (std::string::value_type *)v37 == 24)
  {
    if (SHIBYTE(v37->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(a1, v37->__r_.__value_.__l.__data_, v37->__r_.__value_.__l.__size_);
    }
    else
    {
      long long v33 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
      a1->__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
      *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v33;
    }
  }
  else
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    uint64_t v34 = *(void *)(a2 + 160);
    uint64_t v35 = *(void *)(a2 + 168);
    if (v34 != v35)
    {
      int v36 = 0;
      do
      {
        if (sub_10010E128((uint64_t)a4, (void **)(v34 + 72))
          && (*(_DWORD *)(a2 + 336) != 1 || subscriber::isSimReady())
          && (!v36 || v36 > *(_DWORD *)(v34 + 4)))
        {
          std::string::operator=(a1, (const std::string *)(v34 + 72));
          int v36 = *(_DWORD *)(v34 + 4);
        }
        v34 += 168;
      }
      while (v34 != v35);
    }
  }
  v40[0] = (void **)&v37;
  sub_100047F64(v40);
}

void sub_100CC1698(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void **);
  sub_100048174((uint64_t)va2);
  va_copy((va_list)v7, va);
  sub_100047F64((void ***)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100CC16E4(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  if (!a3[2])
  {
    if (*(char *)(a1 + 895) < 0)
    {
      if (*(void *)(a1 + 880))
      {
        **(unsigned char **)(a1 + 872) = 0;
        *(void *)(a1 + 880) = 0;
        if (*(char *)(a1 + 895) >= 1)
        {
          int v10 = 0;
          int v9 = 0;
          if (*(char *)(a1 + 863) < 0)
          {
            **(unsigned char **)(a1 + 840) = 0;
            *(void *)(a1 + 848) = 0;
          }
          else
          {
            *(unsigned char *)(a1 + 840) = 0;
            *(unsigned char *)(a1 + 863) = 0;
          }
          return v10 & v9 ^ 1u;
        }
        int v9 = 0;
        goto LABEL_7;
      }
    }
    else if (*(unsigned char *)(a1 + 895))
    {
      int v9 = 0;
      *(unsigned char *)(a1 + 872) = 0;
      *(unsigned char *)(a1 + 895) = 0;
LABEL_7:
      int v10 = 1;
      return v10 & v9 ^ 1u;
    }
    int v10 = 1;
    int v9 = 1;
    return v10 & v9 ^ 1u;
  }
  uint64_t v6 = (void **)(a1 + 872);
  uint64_t v7 = sub_10010E128((uint64_t)a3, (void **)(a1 + 872));
  if (v7)
  {
    uint64_t v8 = 0;
    goto LABEL_30;
  }
  memset(&__p, 0, sizeof(__p));
  if (*(char *)(a1 + 895) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 872), *(void *)(a1 + 880));
  }
  else
  {
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)v6;
    __p.__r_.__value_.__r.__words[2] = *(void *)(a1 + 888);
  }
  sub_100CC12C8(&v34, a1, (void ***)a2, a3);
  if (*(char *)(a1 + 895) < 0) {
    operator delete(*v6);
  }
  *(_OWORD *)uint64_t v6 = *(_OWORD *)&v34.__r_.__value_.__l.__data_;
  *(void *)(a1 + 888) = *((void *)&v34.__r_.__value_.__l + 2);
  uint64_t v12 = *(NSObject **)(a1 + 40);
  uint64_t v7 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    uint64_t v13 = (void *)(a1 + 872);
    if (*(char *)(a1 + 895) < 0) {
      uint64_t v13 = *v6;
    }
    LODWORD(v34.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v34.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Applying new default data selection (%s)", (uint8_t *)&v34, 0xCu);
  }
  if (*(char *)(a1 + 895) < 0)
  {
    if (*(void *)(a1 + 880)) {
      goto LABEL_25;
    }
  }
  else if (*(unsigned char *)(a1 + 895))
  {
LABEL_25:
    uint64_t v7 = sub_100CBF930(a1, (unsigned __int8 *)&__p, (unsigned __int8 *)(a1 + 872));
    uint64_t v8 = v7 ^ 1;
    goto LABEL_28;
  }
  uint64_t v8 = 0;
LABEL_28:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_30:
  if (!capabilities::ct::supportsVoiceCall((capabilities::ct *)v7)) {
    goto LABEL_32;
  }
  BOOL v14 = (void **)(a1 + 840);
  if (sub_10010E128((uint64_t)a3, (void **)(a1 + 840))) {
    goto LABEL_32;
  }
  sub_100CC12C8(&__p, a1, (void ***)a2, a3);
  if (*(char *)(a1 + 863) < 0) {
    operator delete(*v14);
  }
  *(_OWORD *)BOOL v14 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *(void *)(a1 + 856) = *((void *)&__p.__r_.__value_.__l + 2);
  size_t v32 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 863) < 0) {
      BOOL v14 = (void **)*v14;
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#N Applying new default voice selection (%s)", (uint8_t *)&__p, 0xCu);
  }
  if (*(char *)(a1 + 895) < 0)
  {
    if (!*(void *)(a1 + 880))
    {
LABEL_32:
      uint64_t v15 = 0;
      goto LABEL_33;
    }
  }
  else if (!*(unsigned char *)(a1 + 895))
  {
    goto LABEL_32;
  }
  *(_DWORD *)(a1 + 864) = 0;
  uint64_t v15 = 1;
LABEL_33:
  if (a3[2] == (unsigned __int8 *)1 && *(void *)(a2 + 16) == 1 && (int v16 = *(void ***)a2, *(void *)a2 != a2 + 8))
  {
    uint64_t v17 = *a3;
    while (sub_1000609C0((uint64_t)&__p, (unsigned __int8 *)v16 + 32, v17 + 32))
    {
      signed __int8 v18 = (void **)v16[1];
      unint64_t v19 = (void ***)v16;
      if (v18)
      {
        do
        {
          int v16 = v18;
          signed __int8 v18 = (void **)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          int v16 = v19[2];
          BOOL v20 = *v16 == v19;
          unint64_t v19 = (void ***)v16;
        }
        while (!v20);
      }
      long long v21 = (unsigned __int8 *)*((void *)v17 + 1);
      if (v21)
      {
        do
        {
          uint64_t v22 = v21;
          long long v21 = *(unsigned __int8 **)v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          uint64_t v22 = (unsigned __int8 *)*((void *)v17 + 2);
          BOOL v20 = *(void *)v22 == (void)v17;
          uint64_t v17 = v22;
        }
        while (!v20);
      }
      uint64_t v17 = v22;
      if (v16 == (void **)(a2 + 8)) {
        goto LABEL_49;
      }
    }
    long long v33 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Single SIM -> Single SIM case : no pop up required", (uint8_t *)&__p, 2u);
    }
  }
  else
  {
LABEL_49:
    if (*(void *)(a1 + 1160)) {
      goto LABEL_85;
    }
    if (!sub_100CB1074(a1)) {
      goto LABEL_85;
    }
    uint64_t v23 = *(void *)(a1 + 160);
    uint64_t v24 = *(void *)(a1 + 168);
    if (v23 == v24) {
      goto LABEL_85;
    }
    uint64_t v25 = v23 + 168;
    do
    {
      char isEsimCapable = subscriber::isEsimCapable();
      if (*(_DWORD *)(v25 - 104) == 5) {
        char v27 = 0;
      }
      else {
        char v27 = isEsimCapable;
      }
      if (v27) {
        break;
      }
      BOOL v20 = v25 == v24;
      v25 += 168;
    }
    while (!v20);
    if ((v27 & 1) == 0)
    {
LABEL_85:
      if (*(void *)(a2 + 16))
      {
        if (v8 | v15)
        {
          uint64_t v28 = *(std::__shared_weak_count **)(a1 + 80);
          if (v28)
          {
            uint64_t v29 = std::__shared_weak_count::lock(v28);
            if (v29)
            {
              size_t v30 = v29;
              uint64_t v31 = *(void *)(a1 + 72);
              if (v31) {
                (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v31 + 72))(v31, v8, v15);
              }
              sub_10004D2C8(v30);
            }
          }
        }
      }
    }
  }
  return v8 | v15;
}

void sub_100CC1B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  sub_10004D2C8(v18);
  _Unwind_Resume(a1);
}

void sub_100CC1BB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v18);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, v18);
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v20);
  if (v13)
  {
    uint64_t v15 = v13[3];
    BOOL v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  BOOL v14 = 0;
  char v16 = 1;
LABEL_9:
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v15)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 440))(v15, a2, a3);
    goto LABEL_14;
  }
  uint64_t v17 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
  {
LABEL_14:
    if (v16) {
      return;
    }
    goto LABEL_15;
  }
  LOWORD(v18) = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "invalid settings controller", (uint8_t *)&v18, 2u);
  if (v16) {
    return;
  }
LABEL_15:
  sub_10004D2C8(v14);
}

void sub_100CC1D60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CC1D8C(uint64_t a1, void **a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a3 + 23);
  int v4 = (char)v3;
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a3 + 8);
  }
  if (v3)
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        unint64_t v9 = a2;
      }
      else {
        unint64_t v9 = *a2;
      }
      int v10 = *(void **)a3;
      if (v4 >= 0) {
        int v10 = (void *)a3;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Mark both [%s] and [%s] - as setup", buf, 0x16u);
    }
    (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v33);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, v33);
    uint64_t v13 = ServiceMap;
    uint64_t v15 = v14;
    if (v14 < 0)
    {
      char v16 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v15;
    unint64_t v19 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
    if (v19)
    {
      uint64_t v21 = v19[3];
      unint64_t v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v13);
    unint64_t v20 = 0;
    char v22 = 1;
LABEL_19:
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(buf, *a2, (unint64_t)a2[1]);
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)a2;
      *(void *)&uint8_t buf[16] = a2[2];
    }
    (*(void (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v21 + 232))(v21, buf, 1);
    if ((buf[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)buf);
      if (v22)
      {
LABEL_25:
        if (v34) {
          sub_10004D2C8(v34);
        }
        (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v33);
        uint64_t v24 = (std::mutex *)Registry::getServiceMap(v23, v33);
        uint64_t v25 = v24;
        if (v14 < 0)
        {
          unint64_t v26 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v27 = 5381;
          do
          {
            uint64_t v14 = v27;
            unsigned int v28 = *v26++;
            uint64_t v27 = (33 * v27) ^ v28;
          }
          while (v28);
        }
        std::mutex::lock(v24);
        *(void *)long long buf = v14;
        uint64_t v29 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
        if (v29)
        {
          uint64_t v31 = v29[3];
          size_t v30 = (std::__shared_weak_count *)v29[4];
          if (v30)
          {
            atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v25);
            atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v30);
            char v32 = 0;
            goto LABEL_37;
          }
        }
        else
        {
          uint64_t v31 = 0;
        }
        std::mutex::unlock(v25);
        size_t v30 = 0;
        char v32 = 1;
LABEL_37:
        if (*(char *)(a3 + 23) < 0)
        {
          sub_10004FC84(buf, *(void **)a3, *(void *)(a3 + 8));
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)a3;
          *(void *)&uint8_t buf[16] = *(void *)(a3 + 16);
        }
        (*(void (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v31 + 232))(v31, buf, 1);
        if ((buf[23] & 0x80000000) != 0)
        {
          operator delete(*(void **)buf);
          if (v32)
          {
LABEL_43:
            if (v34) {
              sub_10004D2C8(v34);
            }
            return;
          }
        }
        else if (v32)
        {
          goto LABEL_43;
        }
        sub_10004D2C8(v30);
        goto LABEL_43;
      }
    }
    else if (v22)
    {
      goto LABEL_25;
    }
    sub_10004D2C8(v20);
    goto LABEL_25;
  }
}

void sub_100CC2120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC21AC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 328))
  {
    uint64_t v3 = (void **)(a1 + 304);
    sub_100047F64(&v3);
    if (*(char *)(a1 + 295) < 0) {
      operator delete(*(void **)(a1 + 272));
    }
    sub_10005CD2C(a1 + 248, *(char **)(a1 + 256));
    if (*(char *)(a1 + 239) < 0) {
      operator delete(*(void **)(a1 + 216));
    }
    sub_1000C584C(a1);
  }
  return a1;
}

uint64_t sub_100CC2224(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88))
  {
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_100CC2280(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4)) {
    return 0;
  }
  int v3 = *(unsigned __int8 *)(a1 + 80);
  int v4 = *(unsigned __int8 *)(a2 + 80);
  uint64_t result = (v4 | v3) == 0;
  if (v3) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    return result;
  }
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a2 + 56);
  uint64_t v10 = *(void *)(a2 + 64);
  if (v8 - v7 != v10 - v9) {
    return 0;
  }
  while (v7 != v8 && v9 != v10)
  {
    uint64_t v11 = *(unsigned __int8 *)(v7 + 39);
    if ((v11 & 0x80u) == 0) {
      uint64_t v12 = *(unsigned __int8 *)(v7 + 39);
    }
    else {
      uint64_t v12 = *(void *)(v7 + 24);
    }
    uint64_t v13 = *(unsigned __int8 *)(v9 + 39);
    int v14 = (char)v13;
    if ((v13 & 0x80u) != 0) {
      uint64_t v13 = *(void *)(v9 + 24);
    }
    if (v12 != v13) {
      goto LABEL_27;
    }
    if (v14 >= 0) {
      uint64_t v15 = (unsigned __int8 *)(v9 + 16);
    }
    else {
      uint64_t v15 = *(unsigned __int8 **)(v9 + 16);
    }
    if ((v11 & 0x80) != 0)
    {
      uint64_t result = memcmp(*(const void **)(v7 + 16), v15, *(void *)(v7 + 24));
      if (result) {
        goto LABEL_27;
      }
    }
    else if (*(unsigned char *)(v7 + 39))
    {
      uint64_t v16 = 0;
      while (*(unsigned __int8 *)(v7 + v16 + 16) == v15[v16])
      {
        if (v11 == ++v16) {
          goto LABEL_25;
        }
      }
      goto LABEL_27;
    }
LABEL_25:
    uint64_t result = capabilities::ct::defaultVinylCardTypeToGSMA((capabilities::ct *)result);
    if ((result & 1) == 0 && *(unsigned __int8 *)(v7 + 89) != *(unsigned __int8 *)(v9 + 89)) {
      break;
    }
LABEL_27:
    v7 += 216;
    v9 += 216;
  }
  uint64_t result = v9 == v10 && v7 == v8;
  if (v7 != v8 && v9 != v10)
  {
    if (v8 - v7 == v10 - v9)
    {
      uint64_t v17 = v7;
LABEL_35:
      uint64_t v18 = v7;
      if (v17 != v7)
      {
        uint64_t v18 = v7;
        while (1)
        {
          uint64_t v19 = *(unsigned __int8 *)(v18 + 39);
          if ((v19 & 0x80u) == 0) {
            uint64_t v20 = *(unsigned __int8 *)(v18 + 39);
          }
          else {
            uint64_t v20 = *(void *)(v18 + 24);
          }
          uint64_t v21 = *(unsigned __int8 *)(v17 + 39);
          int v22 = (char)v21;
          if ((v21 & 0x80u) != 0) {
            uint64_t v21 = *(void *)(v17 + 24);
          }
          if (v20 != v21) {
            break;
          }
          if (v22 >= 0) {
            uint64_t v23 = (unsigned __int8 *)(v17 + 16);
          }
          else {
            uint64_t v23 = *(unsigned __int8 **)(v17 + 16);
          }
          if ((v19 & 0x80) != 0)
          {
            uint64_t result = memcmp(*(const void **)(v18 + 16), v23, *(void *)(v18 + 24));
            if (result) {
              break;
            }
          }
          else if (*(unsigned char *)(v18 + 39))
          {
            uint64_t v24 = 0;
            while (*(unsigned __int8 *)(v18 + v24 + 16) == v23[v24])
            {
              if (v19 == ++v24) {
                goto LABEL_53;
              }
            }
            break;
          }
LABEL_53:
          uint64_t result = capabilities::ct::defaultVinylCardTypeToGSMA((capabilities::ct *)result);
          if ((result & 1) != 0 || *(unsigned __int8 *)(v18 + 89) == *(unsigned __int8 *)(v17 + 89)) {
            break;
          }
          v18 += 216;
          if (v18 == v17) {
            goto LABEL_58;
          }
        }
      }
      if (v18 != v17) {
        goto LABEL_103;
      }
LABEL_58:
      uint64_t v25 = 0;
      uint64_t v26 = v9;
      while (1)
      {
        uint64_t v27 = *(unsigned __int8 *)(v17 + 39);
        if ((v27 & 0x80u) == 0) {
          uint64_t v28 = *(unsigned __int8 *)(v17 + 39);
        }
        else {
          uint64_t v28 = *(void *)(v17 + 24);
        }
        uint64_t v29 = *(unsigned __int8 *)(v26 + 39);
        int v30 = (char)v29;
        if ((v29 & 0x80u) != 0) {
          uint64_t v29 = *(void *)(v26 + 24);
        }
        if (v28 == v29)
        {
          if (v30 >= 0) {
            uint64_t v31 = (unsigned __int8 *)(v26 + 16);
          }
          else {
            uint64_t v31 = *(unsigned __int8 **)(v26 + 16);
          }
          if ((v27 & 0x80) != 0)
          {
            uint64_t result = memcmp(*(const void **)(v17 + 16), v31, *(void *)(v17 + 24));
            if (!result)
            {
LABEL_75:
              uint64_t result = capabilities::ct::defaultVinylCardTypeToGSMA((capabilities::ct *)result);
              if ((result & 1) == 0 && *(unsigned __int8 *)(v17 + 89) != *(unsigned __int8 *)(v26 + 89)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            if (!*(unsigned char *)(v17 + 39)) {
              goto LABEL_75;
            }
            uint64_t v32 = 0;
            while (*(unsigned __int8 *)(v17 + v32 + 16) == v31[v32])
            {
              if (v27 == ++v32) {
                goto LABEL_75;
              }
            }
          }
        }
        ++v25;
LABEL_78:
        v26 += 216;
        if (v26 == v10)
        {
          if (!v25) {
            return 0;
          }
          uint64_t v33 = v17 + 216;
          uint64_t v34 = 1;
          if (v17 + 216 != v8)
          {
            uint64_t v35 = v17;
            do
            {
              uint64_t v36 = v33;
              uint64_t v37 = *(unsigned __int8 *)(v17 + 39);
              if ((v37 & 0x80u) == 0) {
                uint64_t v38 = *(unsigned __int8 *)(v17 + 39);
              }
              else {
                uint64_t v38 = *(void *)(v17 + 24);
              }
              uint64_t v39 = *(unsigned __int8 *)(v35 + 255);
              int v40 = (char)v39;
              if ((v39 & 0x80u) != 0) {
                uint64_t v39 = *(void *)(v35 + 240);
              }
              if (v38 == v39)
              {
                if (v40 >= 0) {
                  uint64_t v41 = (unsigned __int8 *)(v35 + 232);
                }
                else {
                  uint64_t v41 = *(unsigned __int8 **)(v35 + 232);
                }
                if ((v37 & 0x80) != 0)
                {
                  uint64_t result = memcmp(*(const void **)(v17 + 16), v41, *(void *)(v17 + 24));
                  if (!result)
                  {
LABEL_98:
                    uint64_t result = capabilities::ct::defaultVinylCardTypeToGSMA((capabilities::ct *)result);
                    if ((result & 1) == 0 && *(unsigned __int8 *)(v17 + 89) != *(unsigned __int8 *)(v35 + 305)) {
                      goto LABEL_101;
                    }
                  }
                }
                else
                {
                  if (!*(unsigned char *)(v17 + 39)) {
                    goto LABEL_98;
                  }
                  uint64_t v42 = 0;
                  while (*(unsigned __int8 *)(v17 + v42 + 16) == v41[v42])
                  {
                    if (v37 == ++v42) {
                      goto LABEL_98;
                    }
                  }
                }
              }
              ++v34;
LABEL_101:
              uint64_t v33 = v36 + 216;
              uint64_t v35 = v36;
            }
            while (v36 + 216 != v8);
          }
          if (v34 != v25) {
            return 0;
          }
LABEL_103:
          v17 += 216;
          uint64_t result = 1;
          if (v17 == v8) {
            return result;
          }
          goto LABEL_35;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_100CC2638(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 200))
  {
    int v3 = (void **)(a1 + 176);
    sub_10030FEEC(&v3);
    int v3 = (void **)(a1 + 152);
    sub_100047F64(&v3);
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    if (*(char *)(a1 + 111) < 0) {
      operator delete(*(void **)(a1 + 88));
    }
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

unsigned char *sub_100CC26CC(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[192] = 0;
  if (*(unsigned char *)(a2 + 192))
  {
    sub_10023FB90((uint64_t)a1, a2);
    a1[192] = 1;
  }
  return a1;
}

void sub_100CC2710(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 192)) {
    sub_1000C62D8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC272C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 536)) {
    sub_1000C62D8(a1 + 344);
  }
  sub_100CC2638(a1 + 136);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_100CC27B8(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  uint64_t v5 = *((void *)a2 + 3);
  *(void *)(__dst + 29) = *(void *)((char *)a2 + 29);
  *((void *)__dst + 3) = v5;
  BOOL v6 = __dst + 40;
  if (*((char *)a2 + 63) < 0)
  {
    sub_10004FC84(v6, *((void **)a2 + 5), *((void *)a2 + 6));
  }
  else
  {
    long long v7 = *(long long *)((char *)a2 + 40);
    *((void *)__dst + 7) = *((void *)a2 + 7);
    *(_OWORD *)BOOL v6 = v7;
  }
  return __dst;
}

void sub_100CC2844(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC2860(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

void sub_100CC28AC(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100C31CD0((const void **)v2, (const void **)*v2);
    int v3 = **a1;
    operator delete(v3);
  }
}

void sub_100CC2900(uint64_t *a1, long long *a2, long long *a3, unint64_t a4)
{
  uint64_t v8 = (uint64_t)(a1 + 2);
  uint64_t v9 = *a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) < a4)
  {
    sub_1003DDAE8(a1);
    if (a4 > 0x666666666666666) {
      sub_10006A748();
    }
    unint64_t v10 = 0x999999999999999ALL * ((a1[2] - *a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) >= 0x333333333333333) {
      unint64_t v11 = 0x666666666666666;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_10005CC94(a1, v11);
    uint64_t v12 = sub_10030FDA0(v8, a2, a3, a1[1]);
    goto LABEL_11;
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[1] - v9) >> 3) < a4)
  {
    uint64_t v13 = (long long *)((char *)a2 + 8 * ((a1[1] - v9) >> 3));
    sub_100CC2A78((uint64_t)a2, (uint64_t)v13, v9);
    uint64_t v12 = sub_10030FDA0(v8, v13, a3, a1[1]);
LABEL_11:
    a1[1] = v12;
    return;
  }
  uint64_t v14 = sub_100CC2A78((uint64_t)a2, (uint64_t)a3, v9);
  for (uint64_t i = a1[1]; i != v14; i -= 40)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v14;
}

void sub_100CC2A68(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100CC2A70(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100CC2A78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(_OWORD *)a3 = *(_OWORD *)v5;
      std::string::operator=((std::string *)(a3 + 16), (const std::string *)(v5 + 16));
      a3 += 40;
      v5 += 40;
    }
    while (v5 != a2);
  }
  return a3;
}

unsigned char *sub_100CC2AD8(uint64_t a1, uint64_t a2)
{
  bzero(v11, 0x338uLL);
  if (*(unsigned char *)a1)
  {
    long long v12 = *(_OWORD *)(a1 + 8);
    uint64_t v13 = *(void *)(a1 + 24);
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    long long v4 = *(_OWORD *)(a1 + 32);
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    long long v14 = v4;
    uint64_t v15 = *(void *)(a1 + 48);
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    uint64_t v17 = *(void *)(a1 + 72);
    long long v16 = *(_OWORD *)(a1 + 56);
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    long long v5 = *(_OWORD *)(a1 + 80);
    uint64_t v19 = *(void *)(a1 + 96);
    long long v18 = v5;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
    long long v6 = *(_OWORD *)(a1 + 104);
    uint64_t v21 = *(void *)(a1 + 120);
    long long v20 = v6;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 120) = 0;
    v11[0] = 1;
  }
  v22[0] = 0;
  if (*(unsigned char *)(a1 + 128)) {
    sub_1003DD7D0((uint64_t)v22, a1 + 136);
  }
  *(void *)((char *)&v23[1] + 5) = *(void *)(a1 + 573);
  *(_OWORD *)uint64_t v23 = *(_OWORD *)(a1 + 560);
  *(_OWORD *)&v23[3] = *(_OWORD *)(a1 + 584);
  void v23[5] = *(void *)(a1 + 600);
  *(void *)(a1 + 584) = 0;
  long long v24 = *(_OWORD *)(a1 + 608);
  uint64_t v25 = *(void *)(a1 + 624);
  *(void *)(a1 + 624) = 0;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  uint64_t v7 = *(void *)(a1 + 648);
  long long v26 = *(_OWORD *)(a1 + 632);
  uint64_t v27 = v7;
  *(void *)(a1 + 648) = 0;
  *(_OWORD *)(a1 + 632) = 0u;
  int v28 = *(_DWORD *)(a1 + 656);
  uint64_t v8 = *(void *)(a1 + 680);
  long long v29 = *(_OWORD *)(a1 + 664);
  uint64_t v30 = v8;
  *(void *)(a1 + 680) = 0;
  *(_OWORD *)(a1 + 664) = 0u;
  long long v9 = *(_OWORD *)(a1 + 688);
  uint64_t v32 = *(void *)(a1 + 704);
  long long v31 = v9;
  *(void *)(a1 + 704) = 0;
  *(_OWORD *)(a1 + 688) = 0u;
  sub_10023C008((uint64_t)v33, a1 + 712);
  v33[13] = *(void *)(a1 + 816);
  sub_100CC2D48(a1, a2);
  sub_100CC2D48(a2, (uint64_t)v11);
  return sub_1003DCBCC((uint64_t)v11);
}

void sub_100CC2CCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (SLOBYTE(STACK[0x2C7]) < 0) {
    operator delete((void *)STACK[0x2B0]);
  }
  if (SLOBYTE(STACK[0x2AF]) < 0) {
    operator delete((void *)STACK[0x298]);
  }
  if (SLOBYTE(STACK[0x28F]) < 0) {
    operator delete((void *)STACK[0x278]);
  }
  if (SLOBYTE(STACK[0x277]) < 0) {
    operator delete((void *)STACK[0x260]);
  }
  if (SLOBYTE(STACK[0x25F]) < 0) {
    operator delete((void *)STACK[0x248]);
  }
  sub_1003DC4C4(v9);
  sub_1003DC590(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100CC2D48(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a1)
  {
    if (*(unsigned char *)a2) {
      sub_100CC2FC8(a1, (long long *)(a2 + 8));
    }
    else {
      sub_1003DC5C8(a1);
    }
  }
  else if (*(unsigned char *)a2)
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 32) = 0;
    long long v6 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v6;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 56) = 0;
    long long v7 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)(a1 + 80) = v7;
    *(void *)(a2 + 80) = 0;
    *(void *)(a2 + 88) = 0;
    *(void *)(a2 + 96) = 0;
    long long v8 = *(_OWORD *)(a2 + 104);
    *(void *)(a1 + 120) = *(void *)(a2 + 120);
    *(_OWORD *)(a1 + 104) = v8;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 120) = 0;
    *(unsigned char *)a1 = 1;
  }
  uint64_t v9 = a1 + 128;
  if (*(unsigned char *)(a1 + 128))
  {
    if (*(unsigned char *)(a2 + 128))
    {
      sub_10032FC84(a1 + 136, a2 + 136);
      sub_1003DD98C(a1 + 352, a2 + 352);
      *(unsigned char *)(a1 + 552) = *(unsigned char *)(a2 + 552);
    }
    else
    {
      sub_1003DC4FC(v9);
    }
  }
  else if (*(unsigned char *)(a2 + 128))
  {
    sub_1003DD7D0(v9, a2 + 136);
  }
  long long v10 = *(_OWORD *)(a2 + 560);
  *(void *)(a1 + 573) = *(void *)(a2 + 573);
  *(_OWORD *)(a1 + 560) = v10;
  unint64_t v11 = (void **)(a1 + 584);
  if (*(char *)(a1 + 607) < 0) {
    operator delete(*v11);
  }
  long long v12 = *(_OWORD *)(a2 + 584);
  *(void *)(a1 + 600) = *(void *)(a2 + 600);
  *(_OWORD *)unint64_t v11 = v12;
  *(unsigned char *)(a2 + 607) = 0;
  *(unsigned char *)(a2 + 584) = 0;
  uint64_t v13 = (void **)(a1 + 608);
  if (*(char *)(a1 + 631) < 0) {
    operator delete(*v13);
  }
  long long v14 = *(_OWORD *)(a2 + 608);
  *(void *)(a1 + 624) = *(void *)(a2 + 624);
  *(_OWORD *)uint64_t v13 = v14;
  *(unsigned char *)(a2 + 631) = 0;
  *(unsigned char *)(a2 + 608) = 0;
  uint64_t v15 = (void **)(a1 + 632);
  if (*(char *)(a1 + 655) < 0) {
    operator delete(*v15);
  }
  long long v16 = *(_OWORD *)(a2 + 632);
  *(void *)(a1 + 648) = *(void *)(a2 + 648);
  *(_OWORD *)uint64_t v15 = v16;
  *(unsigned char *)(a2 + 655) = 0;
  *(unsigned char *)(a2 + 632) = 0;
  *(_DWORD *)(a1 + 656) = *(_DWORD *)(a2 + 656);
  uint64_t v17 = (void **)(a1 + 664);
  if (*(char *)(a1 + 687) < 0) {
    operator delete(*v17);
  }
  long long v18 = *(_OWORD *)(a2 + 664);
  *(void *)(a1 + 680) = *(void *)(a2 + 680);
  *(_OWORD *)uint64_t v17 = v18;
  *(unsigned char *)(a2 + 687) = 0;
  *(unsigned char *)(a2 + 664) = 0;
  uint64_t v19 = (void **)(a1 + 688);
  if (*(char *)(a1 + 711) < 0) {
    operator delete(*v19);
  }
  long long v20 = *(_OWORD *)(a2 + 688);
  *(void *)(a1 + 704) = *(void *)(a2 + 704);
  *(_OWORD *)uint64_t v19 = v20;
  *(unsigned char *)(a2 + 711) = 0;
  *(unsigned char *)(a2 + 688) = 0;
  std::string::operator=((std::string *)(a1 + 712), (const std::string *)(a2 + 712));
  std::string::operator=((std::string *)(a1 + 736), (const std::string *)(a2 + 736));
  std::string::operator=((std::string *)(a1 + 760), (const std::string *)(a2 + 760));
  *(unsigned char *)(a1 + 784) = *(unsigned char *)(a2 + 784);
  std::string::operator=((std::string *)(a1 + 792), (const std::string *)(a2 + 792));
  *(void *)(a1 + 816) = *(void *)(a2 + 816);
  return a1;
}

__n128 sub_100CC2FC8(uint64_t a1, long long *a2)
{
  uint64_t v4 = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)v4);
  }
  long long v5 = *a2;
  *(void *)(v4 + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v4 = v5;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  long long v6 = (void **)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*v6);
  }
  long long v7 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 48) = *((void *)a2 + 5);
  *(_OWORD *)long long v6 = v7;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  long long v8 = (void **)(a1 + 56);
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*v8);
  }
  long long v9 = a2[3];
  *(void *)(a1 + 72) = *((void *)a2 + 8);
  *(_OWORD *)long long v8 = v9;
  *((unsigned char *)a2 + 71) = 0;
  *((unsigned char *)a2 + 48) = 0;
  long long v10 = (void **)(a1 + 80);
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*v10);
  }
  long long v11 = *(long long *)((char *)a2 + 72);
  *(void *)(a1 + 96) = *((void *)a2 + 11);
  *(_OWORD *)long long v10 = v11;
  *((unsigned char *)a2 + 95) = 0;
  *((unsigned char *)a2 + 72) = 0;
  long long v12 = (void **)(a1 + 104);
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*v12);
  }
  __n128 result = (__n128)a2[6];
  *(void *)(a1 + 120) = *((void *)a2 + 14);
  *(__n128 *)long long v12 = result;
  *((unsigned char *)a2 + 119) = 0;
  *((unsigned char *)a2 + 96) = 0;
  return result;
}

uint64_t sub_100CC30DC(uint64_t result)
{
  if (*(unsigned char *)(result + 240))
  {
    uint64_t v1 = result;
    if (*(char *)(result + 239) < 0) {
      operator delete(*(void **)(result + 216));
    }
    __n128 result = sub_1000C584C(v1);
    *(unsigned char *)(v1 + 240) = 0;
  }
  return result;
}

void *sub_100CC3120(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1000D89C4(a1, a2);
    uint64_t v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_100CC31B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_100CC31C4(void *a1)
{
  if (a1)
  {
    sub_100CC31C4(*a1);
    sub_100CC31C4(a1[1]);
    sub_100CC3218((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_100CC3218(uint64_t a1)
{
  sub_100CC272C(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

char *sub_100CC3268(uint64_t **a1, void **a2, long long **a3)
{
  long long v6 = a1 + 1;
  size_t v5 = (char *)a1[1];
  long long v7 = (char **)(a1 + 1);
  long long v8 = (char **)(a1 + 1);
  if (!v5) {
    goto LABEL_10;
  }
  long long v7 = (char **)(a1 + 1);
  while (1)
  {
    while (1)
    {
      long long v8 = (char **)v5;
      long long v10 = v5 + 32;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      size_t v5 = *v8;
      long long v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    long long v7 = v8 + 1;
    size_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  long long v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    long long v12 = *a3;
    uint64_t v19 = 0;
    uint64_t v13 = (char *)operator new(0x258uLL);
    v18[0] = v13;
    v18[1] = v6;
    long long v14 = v13 + 32;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      *((void *)v13 + 6) = *((void *)v12 + 2);
      *(_OWORD *)long long v14 = v15;
    }
    bzero(v13 + 56, 0x220uLL);
    *((_DWORD *)v13 + 46) = 3;
    LOBYTE(v19) = 1;
    *(void *)uint64_t v13 = 0;
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = v8;
    *long long v7 = v13;
    long long v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      uint64_t v13 = *v7;
    }
    sub_100046C90(a1[1], (uint64_t *)v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    long long v11 = (char *)v18[0];
    v18[0] = 0;
    sub_100CC33D8((uint64_t)v18);
  }
  return v11;
}

void sub_100CC33C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100CC33D8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100CC33D8(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100CC3218((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void sub_100CC3434()
{
}

void *sub_100CC3448(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A4E318;
  result[1] = v3;
  return result;
}

uint64_t sub_100CC3490(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A4E318;
  a2[1] = v2;
  return result;
}

void sub_100CC34BC(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  char v6 = 0;
  if (*(unsigned char *)(a2 + 144))
  {
    sub_100CC3C34((uint64_t)v5, a2);
    char v6 = 1;
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v7 = v3;
    v8[0] = 0;
    char v9 = 0;
    sub_100860AEC((uint64_t)v8, (uint64_t)v5);
    char v9 = 1;
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v7 = v3;
    v8[0] = 0;
    char v9 = 0;
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100CC3634(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1008613CC(v2);
  sub_1008613CC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100CC3658(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100CC3698()
{
}

uint64_t *sub_100CC36A4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v28 = a1;
  uint64_t v29 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 152);
  uint64_t v4 = *(NSObject **)(*(void *)v1 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      LOWORD(v31.__r_.__value_.__r.__words[2]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Loading user data", (uint8_t *)&v31.__r_.__value_.__s.__data_[16], 2u);
    }
    v31.__r_.__value_.__r.__words[2] = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    sub_1000C6BDC((uint64_t *)&v31.__r_.__value_.__r.__words[2], v1 + 8);
    sub_100CB089C((uint64_t *)&v36, &v31.__r_.__value_.__r.__words[2], 1);
    uint64_t v6 = v2 + 800;
    sub_10005CD2C(v2 + 792, *(char **)(v2 + 800));
    std::string::size_type size = v36.__r_.__value_.__l.__size_;
    *(void *)(v2 + 792) = v36.__r_.__value_.__r.__words[0];
    *(void *)(v2 + 800) = size;
    std::string::size_type v8 = v36.__r_.__value_.__r.__words[2];
    *(void *)(v2 + 808) = *((void *)&v36.__r_.__value_.__l + 2);
    if (v8)
    {
      *(void *)(size + 16) = v6;
      v36.__r_.__value_.__r.__words[0] = (std::string::size_type)&v36.__r_.__value_.__l.__size_;
      *(_OWORD *)&v36.__r_.__value_.__r.__words[1] = 0uLL;
      std::string::size_type size = 0;
    }
    else
    {
      *(void *)(v2 + 792) = v6;
    }
    sub_10005CD2C((uint64_t)&v36, (char *)size);
    if (*(char *)(v1 + 55) < 0)
    {
      if (*(void *)(v1 + 40)) {
        goto LABEL_11;
      }
    }
    else if (*(unsigned char *)(v1 + 55))
    {
LABEL_11:
      char v9 = std::string::operator=((std::string *)(v2 + 872), (const std::string *)(v1 + 32));
      goto LABEL_18;
    }
    BOOL v10 = *(_DWORD *)(v2 + 788) != 1 || v33 == 0;
    if (!v10) {
      char v9 = std::string::operator=((std::string *)(v2 + 872), (const std::string *)(v31.__r_.__value_.__r.__words[2] + 32));
    }
LABEL_18:
    if (capabilities::ct::supportsVoiceCall((capabilities::ct *)v9)) {
      std::string::operator=((std::string *)(v2 + 840), (const std::string *)(v1 + 56));
    }
    long long v11 = *(void **)(v1 + 80);
    if (v11 != (void *)(v1 + 88))
    {
      do
      {
        v36.__r_.__value_.__r.__words[0] = (std::string::size_type)(v11 + 4);
        long long v12 = sub_100CC3268((uint64_t **)(v2 + 264), (void **)v11 + 4, (long long **)&v36);
        std::string::operator=((std::string *)(v12 + 56), (const std::string *)(v11 + 7));
        uint64_t v13 = (void *)v11[1];
        if (v13)
        {
          do
          {
            long long v14 = v13;
            uint64_t v13 = (void *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            long long v14 = (void *)v11[2];
            BOOL v10 = *v14 == (void)v11;
            long long v11 = v14;
          }
          while (!v10);
        }
        long long v11 = v14;
      }
      while (v14 != (void *)(v1 + 88));
    }
    long long v15 = *(void **)(v1 + 104);
    if (v15 != (void *)(v1 + 112))
    {
      do
      {
        v36.__r_.__value_.__r.__words[0] = (std::string::size_type)(v15 + 4);
        long long v16 = sub_100CC3268((uint64_t **)(v2 + 264), (void **)v15 + 4, (long long **)&v36);
        std::string::operator=((std::string *)(v16 + 80), (const std::string *)(v15 + 11));
        v36.__r_.__value_.__r.__words[0] = (std::string::size_type)(v15 + 4);
        uint64_t v17 = sub_100CC3268((uint64_t **)(v2 + 264), (void **)v15 + 4, (long long **)&v36);
        std::string::operator=((std::string *)(v17 + 104), (const std::string *)(v15 + 14));
        v36.__r_.__value_.__r.__words[0] = (std::string::size_type)(v15 + 4);
        long long v18 = sub_100CC3268((uint64_t **)(v2 + 264), (void **)v15 + 4, (long long **)&v36);
        std::string::operator=((std::string *)(v18 + 128), (const std::string *)(v15 + 17));
        v36.__r_.__value_.__r.__words[0] = (std::string::size_type)(v15 + 4);
        uint64_t v19 = sub_100CC3268((uint64_t **)(v2 + 264), (void **)v15 + 4, (long long **)&v36);
        std::string::operator=((std::string *)(v19 + 152), (const std::string *)(v15 + 20));
        long long v20 = (void *)v15[1];
        if (v20)
        {
          do
          {
            uint64_t v21 = v20;
            long long v20 = (void *)*v20;
          }
          while (v20);
        }
        else
        {
          do
          {
            uint64_t v21 = (void *)v15[2];
            BOOL v10 = *v21 == (void)v15;
            long long v15 = v21;
          }
          while (!v10);
        }
        long long v15 = v21;
      }
      while (v21 != (void *)(v1 + 112));
    }
    if (*(char *)(v1 + 151) < 0)
    {
      if (!*(void *)(v1 + 136))
      {
LABEL_39:
        int v22 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          sub_100CA8010((uint64_t *)&v30, v2);
          sub_1000E8F34(v30, &v31, ",", 1uLL, &v36);
          if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v23 = &v36;
          }
          else {
            uint64_t v23 = (std::string *)v36.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)uint64_t v34 = 136315138;
          uint64_t v35 = v23;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Last known user enabled sims (%s)", v34, 0xCu);
          if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v36.__r_.__value_.__l.__data_);
          }
          sub_10005CD2C((uint64_t)&v30, v31.__r_.__value_.__l.__data_);
          int v22 = *(NSObject **)(v2 + 40);
        }
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          long long v24 = (void *)(v2 + 872);
          if (*(char *)(v2 + 895) < 0) {
            long long v24 = (void *)*v24;
          }
          LODWORD(v36.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v36.__r_.__value_.__r.__words + 4) = (std::string::size_type)v24;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Last known user data sim (%s)", (uint8_t *)&v36, 0xCu);
          int v22 = *(NSObject **)(v2 + 40);
        }
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = (void *)(v2 + 840);
          if (*(char *)(v2 + 863) < 0) {
            uint64_t v25 = (void *)*v25;
          }
          LODWORD(v36.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v36.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Last known user voice sim (%s)", (uint8_t *)&v36, 0xCu);
          int v22 = *(NSObject **)(v2 + 40);
        }
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          long long v26 = (void *)(v2 + 816);
          if (*(char *)(v2 + 839) < 0) {
            long long v26 = (void *)*v26;
          }
          LODWORD(v36.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v36.__r_.__value_.__r.__words + 4) = (std::string::size_type)v26;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Last known disabled physical sim (%s)", (uint8_t *)&v36, 0xCu);
        }
        sub_10005CD2C((uint64_t)&v31.__r_.__value_.__r.__words[2], v32);
        goto LABEL_59;
      }
    }
    else if (!*(unsigned char *)(v1 + 151))
    {
      goto LABEL_39;
    }
    std::string::operator=((std::string *)(v2 + 816), (const std::string *)(v1 + 128));
    goto LABEL_39;
  }
  if (v5)
  {
    LOWORD(v31.__r_.__value_.__r.__words[2]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I No user data found", (uint8_t *)&v31.__r_.__value_.__s.__data_[16], 2u);
  }
LABEL_59:
  sub_100CC3BE4(&v29);
  return sub_100046B58((uint64_t *)&v28);
}

void sub_100CC3B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, char *a16)
{
}

uint64_t *sub_100CC3BE4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_1008613CC(v1 + 8);
    operator delete();
  }
  return result;
}

__n128 sub_100CC3C34(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v2 = (void *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)(a1 + 8) = v3;
  uint64_t v4 = a1 + 8;
  uint64_t v5 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    *(void *)a2 = v2;
    void *v2 = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = v4;
  }
  long long v6 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v6;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 24) = 0;
  long long v7 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v7;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  std::string::size_type v8 = (void *)(a2 + 80);
  uint64_t v9 = *(void *)(a2 + 80);
  *(void *)(a1 + 80) = v9;
  uint64_t v10 = a1 + 80;
  uint64_t v11 = *(void *)(a2 + 88);
  *(void *)(a1 + 88) = v11;
  if (v11)
  {
    *(void *)(v9 + 16) = v10;
    *(void *)(a2 + 72) = v8;
    void *v8 = 0;
    *(void *)(a2 + 88) = 0;
  }
  else
  {
    *(void *)(a1 + 72) = v10;
  }
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  long long v12 = (void *)(a2 + 104);
  uint64_t v13 = *(void *)(a2 + 104);
  *(void *)(a1 + 104) = v13;
  uint64_t v14 = a1 + 104;
  uint64_t v15 = *(void *)(a2 + 112);
  *(void *)(a1 + 112) = v15;
  if (v15)
  {
    *(void *)(v13 + 16) = v14;
    *(void *)(a2 + 96) = v12;
    void *v12 = 0;
    *(void *)(a2 + 112) = 0;
  }
  else
  {
    *(void *)(a1 + 96) = v14;
  }
  __n128 result = *(__n128 *)(a2 + 120);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(__n128 *)(a1 + 120) = result;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 120) = 0;
  return result;
}

void sub_100CC3D2C()
{
}

void *sub_100CC3D40(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A4E3A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100CC3D88(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A4E3A8;
  a2[1] = v2;
  return result;
}

void sub_100CC3DB4(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void *)a2;
  uint64_t v2 = v6;
  long long v7 = *(_OWORD *)(a2 + 8);
  uint64_t v3 = v7;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  unint64_t v4 = *(void *)(a1 + 8);
  v8[0] = v4;
  v8[1] = 0uLL;
  sub_1005E6A50((void *)v8 + 1, v2, v3, 0xAAAAAAAAAAAAAAABLL * ((v3 - v2) >> 6));
  uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100CC3F10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  *(void *)(v10 - 56) = &a10;
  sub_10023FDC8((void ***)(v10 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_100CC3F30(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100CC3F70()
{
}

uint64_t *sub_100CC3F7C(void **a1)
{
  uint64_t v1 = *a1;
  std::string::size_type v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = v1[1];
  uint64_t v3 = v1[2];
  if (v2 != v3)
  {
    unint64_t v4 = (uint64_t **)(*v1 + 264);
    do
    {
      uint64_t v10 = (long long *)(v2 + 32);
      uint64_t v5 = (std::string *)sub_100CC3268(v4, (void **)(v2 + 32), &v10);
      uint64_t v6 = v5;
      if (v5[24].__r_.__value_.__s.__data_[16])
      {
        v5[16].__r_.__value_.__r.__words[2] = *(void *)v2;
        std::string::operator=(v5 + 17, (const std::string *)(v2 + 8));
        std::string::operator=(v6 + 18, (const std::string *)(v2 + 32));
        LOWORD(v6[19].__r_.__value_.__l.__data_) = *(_WORD *)(v2 + 56);
        std::string::operator=((std::string *)((char *)v6 + 464), (const std::string *)(v2 + 64));
        std::string::operator=((std::string *)((char *)v6 + 488), (const std::string *)(v2 + 88));
        std::string::operator=((std::string *)((char *)v6 + 512), (const std::string *)(v2 + 112));
        std::string::operator=((std::string *)((char *)v6 + 536), (const std::string *)(v2 + 136));
        std::string::operator=((std::string *)((char *)v6 + 560), (const std::string *)(v2 + 160));
        LOWORD(v6[24].__r_.__value_.__r.__words[1]) = *(_WORD *)(v2 + 184);
      }
      else
      {
        sub_10023FB90((uint64_t)&v5[16].__r_.__value_.__r.__words[2], v2);
        v6[24].__r_.__value_.__s.__data_[16] = 1;
      }
      v2 += 192;
    }
    while (v2 != v3);
  }
  sub_10086E244((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100CC4090(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_10086E244((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100CC40B0()
{
}

void *sub_100CC40C4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A4E438;
  result[1] = v3;
  return result;
}

uint64_t sub_100CC410C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A4E438;
  a2[1] = v2;
  return result;
}

void sub_100CC4138(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 32))
  {
    uint64_t v3 = *(void **)a2;
    uint64_t v2 = *(void **)(a2 + 8);
    *(_DWORD *)std::string::size_type v8 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)&void v8[3] = *(_DWORD *)(a2 + 19);
    int v4 = *(char *)(a2 + 23);
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)a2 = 0;
    char v5 = *(unsigned char *)(a2 + 24);
    uint64_t v6 = *(void *)(a1 + 8);
    LOBYTE(__p[0]) = 0;
    char v13 = 0;
    if (v4 < 0)
    {
      sub_10004FC84(__p, v3, (unint64_t)v2);
    }
    else
    {
      __p[0] = v3;
      __p[1] = v2;
      *(_DWORD *)uint64_t v10 = *(_DWORD *)v8;
      *(_DWORD *)&v10[3] = *(_DWORD *)&v8[3];
      char v11 = v4;
    }
    char v12 = v5;
    char v13 = 1;
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 8);
    LOBYTE(__p[0]) = 0;
    char v13 = 0;
  }
  long long v7 = *(std::__shared_weak_count **)(v6 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100CC4320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19)
{
  if (a19)
  {
    if (a17 < 0) {
      operator delete(__p);
    }
  }
  operator delete(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100CC4354(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100CC4394()
{
}

uint64_t *sub_100CC43A0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v14 = a1;
  uint64_t v15 = v1;
  if (!*(unsigned char *)(v1 + 40)) {
    goto LABEL_27;
  }
  uint64_t v2 = *(void *)v1;
  *(_OWORD *)long long __dst = 0u;
  long long v18 = 0u;
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v3 = *(_OWORD *)(v1 + 8);
    *(void *)&long long v18 = *(void *)(v1 + 24);
    *(_OWORD *)long long __dst = v3;
  }
  int v4 = *(unsigned __int8 *)(v1 + 32);
  BYTE8(v18) = *(unsigned char *)(v1 + 32);
  int v5 = SBYTE7(v18);
  if ((SBYTE7(v18) & 0x80u) == 0) {
    uint64_t v6 = (void *)BYTE7(v18);
  }
  else {
    uint64_t v6 = __dst[1];
  }
  long long v7 = *(NSObject **)(v2 + 40);
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v8)
    {
      uint64_t v9 = (void **)__dst[0];
      if (v5 >= 0) {
        uint64_t v9 = __dst;
      }
      uint64_t v10 = "without";
      if (v4) {
        uint64_t v10 = "with";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v9;
      __int16 v20 = 2080;
      *(void *)std::string __p = v10;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Resume monitor mode for iccid (%s) %s entitlement support", buf, 0x16u);
      LOBYTE(v5) = BYTE7(v18);
    }
    long long v24 = 0uLL;
    if ((v5 & 0x80) != 0)
    {
      sub_10004FC84(&__p[2], __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)&__p[2] = *(_OWORD *)__dst;
      uint64_t v22 = v18;
    }
    char v23 = 1;
    char v16 = 1;
    sub_100CB1258(v2, &v24, (long long *)buf, &v16, SBYTE8(v18));
    if ((SHIBYTE(v22) & 0x80000000) == 0) {
      goto LABEL_25;
    }
    char v12 = *(void **)&__p[2];
  }
  else
  {
    if (v8)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Clear invalid monitor mode information", buf, 2u);
    }
    uint64_t v11 = *(void *)(v2 + 120);
    sub_100058DB0(buf, "");
    (*(void (**)(uint64_t, unsigned char *, void))(*(void *)v11 + 280))(v11, buf, BYTE8(v18));
    if ((__p[9] & 0x80000000) == 0) {
      goto LABEL_25;
    }
    char v12 = *(void **)buf;
  }
  operator delete(v12);
LABEL_25:
  if (SBYTE7(v18) < 0) {
    operator delete(__dst[0]);
  }
LABEL_27:
  sub_100CC4654(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_100CC45F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100CC4654(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100CC4654(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 40))
    {
      if (*(char *)(v1 + 31) < 0) {
        operator delete(*(void **)(v1 + 8));
      }
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100CC46B4(uint64_t a1)
{
  sub_100087ED0(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    long long v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        long long v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_100087ED0(*(void *)a1, v2);
  }
  return a1;
}

void sub_100CC470C(void ***a1, void **a2)
{
  long long v3 = sub_100046F68((uint64_t)a1, a2);
  if (a1 + 1 != (void ***)v3)
  {
    int v4 = (uint64_t *)v3;
    int v5 = (void **)v3[1];
    if (v5)
    {
      do
      {
        uint64_t v6 = v5;
        int v5 = (void **)*v5;
      }
      while (v5);
    }
    else
    {
      long long v7 = v3;
      do
      {
        uint64_t v6 = (void **)v7[2];
        BOOL v8 = *v6 == v7;
        long long v7 = v6;
      }
      while (!v8);
    }
    if (*a1 == v3) {
      *a1 = v6;
    }
    uint64_t v9 = (uint64_t *)a1[1];
    a1[2] = (void **)((char *)a1[2] - 1);
    sub_10005EE6C(v9, v4);
    sub_100CC3218((uint64_t)(v4 + 4));
    operator delete(v4);
  }
}

uint64_t *sub_100CC47BC(void *a1)
{
  uint64_t v1 = (void *)*a1;
  long long v3 = a1;
  int v4 = v1;
  sub_100CAF704(*v1, 1, v1 + 3, 0);
  sub_100CC4824((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100CC4808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100CC4824(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100CC487C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  long long v3 = a1;
  int v4 = v1;
  sub_100CAF704(*v1, 0, (uint64_t)(v1 + 3), 0);
  sub_100CC4824((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100CC48C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100CC48E4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v21 = a1;
  uint64_t v22 = v1;
  uint64_t v2 = *(void *)v1;
  long long v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 8)) {
      int v4 = "Success";
    }
    else {
      int v4 = "Fail";
    }
    *(_DWORD *)long long buf = 136315138;
    std::string v31 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Monitor mode operation status %s", buf, 0xCu);
  }
  int v5 = *(std::__shared_weak_count **)(v2 + 80);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      long long v7 = v6;
      uint64_t v8 = *(void *)(v2 + 72);
      if (v8)
      {
        if ((*(unsigned int (**)(void, uint64_t))(*(void *)v8 + 176))(*(void *)(v2 + 72), v1 + 16))
        {
          if (*(unsigned char *)(v1 + 8))
          {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 184))(v8, v1 + 16);
          }
          else
          {
            long long v18 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v19 = v1 + 16;
              if (*(char *)(v1 + 39) < 0) {
                uint64_t v19 = *(void *)(v1 + 16);
              }
              *(_DWORD *)long long buf = 136315138;
              std::string v31 = (const char *)v19;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Disable SIM with iccid [%s] again.", buf, 0xCu);
            }
            sub_100CAF704(v2, 0, v1 + 16, 0);
          }
        }
        else
        {
          (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v8 + 104))(buf, v8, v2 + 1136);
          int v9 = sub_100CBFE90((void *)v2, (unsigned __int8 *)(v2 + 1136));
          if (*(unsigned char *)(v1 + 8))
          {
            if ((*(unsigned int (**)(void))(**(void **)(v2 + 56) + 112))(*(void *)(v2 + 56)))
            {
              unint64_t v10 = sub_100CAF3EC((void *)v2, *(void *)(v2 + 200));
              __p[0] = 0;
              __p[1] = 0;
              *(void *)&v26[0] = 0;
              sub_100CA6EAC(__p, (void *)v2, (void **)(v2 + 1136), v9);
              uint64_t v11 = (void *)BYTE7(v26[0]);
              int v12 = SBYTE7(v26[0]);
              if (SBYTE7(v26[0]) < 0) {
                uint64_t v11 = __p[1];
              }
              if (v11 && HIDWORD(v10))
              {
                char v13 = *(NSObject **)(v2 + 40);
                if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v14 = (void **)__p[0];
                  if (v12 >= 0) {
                    uint64_t v14 = __p;
                  }
                  LODWORD(v28) = 136315138;
                  *(void *)((char *)&v28 + 4) = v14;
                  _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Disable SIM with iccid [%s] after completing monitor mode.", (uint8_t *)&v28, 0xCu);
                }
                sub_100CAF704(v2, 0, (uint64_t)__p, 0);
                sub_100CB0388(v2, (uint64_t)__p, v2 + 1136, 0);
                LOBYTE(v12) = BYTE7(v26[0]);
              }
              if ((v12 & 0x80) != 0) {
                operator delete(__p[0]);
              }
            }
            if (v36)
            {
              uint64_t v15 = v33;
              if ((v33 & 0x80u) != 0) {
                uint64_t v15 = v32[1];
              }
              if (v15)
              {
                sub_100058DB0(__p, "MonitorModeComplete");
                *((void *)&v26[0] + 1) = sub_100B6D7B0;
                *(void *)&v26[1] = 1;
                uint64_t v29 = 0;
                long long v28 = 0uLL;
                __dst[0] = &v28;
                __dst[1] = 0;
                *(void *)&long long v28 = operator new(0x38uLL);
                *((void *)&v28 + 1) = v28;
                uint64_t v29 = v28 + 56;
                *((void *)&v28 + 1) = sub_100333B38((uint64_t)&v29, (uint64_t)__p, (uint64_t)&v26[2] + 8, v28);
                (*(void (**)(uint64_t, void *, long long *))(*(void *)v8 + 112))(v8, v32, &v28);
                __dst[0] = &v28;
                sub_100333C9C((void ***)__dst);
                sub_100146540((uint64_t (**)(void, void, void, void, void))v26 + 1);
                if (SBYTE7(v26[0]) < 0) {
                  operator delete(__p[0]);
                }
              }
            }
          }
          long long v28 = 0uLL;
          uint64_t v29 = 0;
          sub_100CBAC70(&v28, v2, v2 + 1136);
          unint64_t v16 = 0;
          if (v36 && v35) {
            unint64_t v16 = (unint64_t)(CFAbsoluteTimeGetCurrent() - v34);
          }
          long long v27 = 0u;
          *(_OWORD *)std::string __p = 0u;
          memset(v26, 0, sizeof(v26));
          sub_100CA6DF4((char *)__p, v2, v9);
          int v17 = *(unsigned __int8 *)(v1 + 8);
          if (BYTE8(v27))
          {
            if (SHIBYTE(v26[1]) < 0)
            {
              sub_10004FC84(__dst, *((void **)&v26[0] + 1), *(unint64_t *)&v26[1]);
            }
            else
            {
              *(_OWORD *)long long __dst = *(_OWORD *)((char *)v26 + 8);
              uint64_t v24 = *((void *)&v26[1] + 1);
            }
          }
          else
          {
            sub_100058DB0(__dst, "");
          }
          (*(void (**)(uint64_t, BOOL, long long *, void **))(*(void *)v8 + 128))(v8, v17 != 0, &v28, __dst);
          if (SHIBYTE(v24) < 0) {
            operator delete(__dst[0]);
          }
          (*(void (**)(uint64_t, long long *, void, unint64_t, uint64_t))(*(void *)v8 + 136))(v8, &v28, *(unsigned __int8 *)(v1 + 8), v16, v2 + 1136);
          sub_100CC2224((uint64_t)__p);
          if (SHIBYTE(v29) < 0) {
            operator delete((void *)v28);
          }
          if (v36) {
            sub_10030D10C((uint64_t)buf);
          }
        }
        sub_100CB99E8(v2);
        sub_100CA5980(v2);
        (*(void (**)(uint64_t))(*(void *)v8 + 64))(v8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10033CAD4(&v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_100CC4EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  sub_100333C9C((void ***)&a11);
  sub_100146540(v35);
  if (a20 < 0) {
    operator delete(__p);
  }
  if (LOBYTE(STACK[0x590])) {
    sub_10030D10C((uint64_t)&a34);
  }
  sub_10004D2C8(v34);
  sub_10033CAD4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100CC4F80(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 80);
  if (v2)
  {
    long long v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(v1 + 72);
      if (v5) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 168))(v5, v1 + 1136);
      }
      sub_10004D2C8(v4);
    }
  }
  operator delete();
}

void sub_100CC5024()
{
  sub_10004D2C8(v0);
  operator delete();
}

uint64_t sub_100CC5058(uint64_t a1)
{
  *(void *)a1 = off_101A4E4C8;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100CC50A8(uint64_t a1)
{
  *(void *)a1 = off_101A4E4C8;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100CC5118(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_101A4E4C8;
  v2[1] = v3;
  int v4 = v2 + 2;
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)int v4 = *(_OWORD *)(a1 + 16);
    v2[4] = *(void *)(a1 + 32);
  }
  return v2;
}

void sub_100CC5190(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_100CC51A4(char *result, void *a2)
{
  uint64_t v2 = *((void *)result + 1);
  *a2 = off_101A4E4C8;
  a2[1] = v2;
  uint64_t v3 = a2 + 2;
  if (result[39] < 0) {
    return (char *)sub_10004FC84(v3, *((void **)result + 2), *((void *)result + 3));
  }
  long long v4 = *((_OWORD *)result + 1);
  a2[4] = *((void *)result + 4);
  *(_OWORD *)uint64_t v3 = v4;
  return result;
}

void sub_100CC51F4(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
}

void sub_100CC5208(void **__p)
{
  if (*((char *)__p + 39) < 0) {
    operator delete(__p[2]);
  }

  operator delete(__p);
}

void sub_100CC524C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!sub_10010E128((uint64_t)a2, (void **)(a1 + 16))) {
    sub_100CB99E8(v3);
  }
  sub_100CB089C(v5, a2, 1);
  sub_100CA9968((uint64_t *)v3, v5, 0, 1);
  sub_10005CD2C((uint64_t)v5, (char *)v5[1]);
  long long v4 = *(std::__shared_weak_count **)(v3 + 1168);
  *(_OWORD *)(v3 + 1160) = 0u;
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100CC52D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100CC52F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CC5330()
{
}

uint64_t *sub_100CC533C(void *a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = *a1;
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  return sub_1000E3958((uint64_t *)&v3);
}

void sub_100CC5398(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E3958((uint64_t *)va);
  _Unwind_Resume(a1);
}

double sub_100CC53AC(std::string *a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v3 = a3;
  memset(&v12, 0, sizeof(v12));
  LODWORD(v6) = a3[23];
  if ((v6 & 0x80) != 0)
  {
    sub_10004FC84(&v12, *(void **)a3, *((void *)a3 + 1));
    LODWORD(v6) = v3[23];
  }
  else
  {
    std::string v12 = *(std::string *)a3;
  }
  uint64_t v6 = v6;
  if ((v6 & 0x80u) == 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = *((void *)v3 + 1);
  }
  uint64_t v8 = *(unsigned __int8 *)(a2 + 895);
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a2 + 880);
  }
  if (v7 != v8) {
    goto LABEL_20;
  }
  if (v9 >= 0) {
    unint64_t v10 = (unsigned __int8 *)(a2 + 872);
  }
  else {
    unint64_t v10 = *(unsigned __int8 **)(a2 + 872);
  }
  if ((v6 & 0x80) != 0)
  {
    if (memcmp(*(const void **)v3, v10, *((void *)v3 + 1))) {
      goto LABEL_20;
    }
LABEL_19:
    std::string::append(&v12, "*", 1uLL);
    goto LABEL_20;
  }
  if (!v6) {
    goto LABEL_19;
  }
  while (*v3 == *v10)
  {
    ++v3;
    ++v10;
    if (!--v6) {
      goto LABEL_19;
    }
  }
LABEL_20:
  double result = *(double *)&v12.__r_.__value_.__l.__data_;
  *a1 = v12;
  return result;
}

void sub_100CC54B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC54D0(uint64_t a1)
{
  *(void *)a1 = off_101A4E548;
  long long v4 = (void **)(a1 + 48);
  sub_10016A9A4(&v4);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100CC5548(uint64_t a1)
{
  sub_100CC54D0(a1);

  operator delete();
}

void *sub_100CC5580(void *a1, uint64_t *a2, long long *a3)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  *a1 = off_101A4E548;
  a1[1] = v5;
  a1[2] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = a1 + 3;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(v6, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v7 = *a3;
    a1[5] = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v6 = v7;
  }
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  return a1;
}

void sub_100CC5608(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC5620(void *a1, std::string **a2)
{
  uint64_t i = a1;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v5 = (char *)v4 - (char *)*a2;
  if (v5 >= 1)
  {
    uint64_t v7 = a1[6];
    unint64_t v8 = a1[7];
    uint64_t v6 = (std::string **)(a1 + 6);
    uint64_t v9 = v5 / 96;
    uint64_t v10 = (uint64_t)(v8 - v7) / 96;
    uint64_t v11 = (uint64_t)(a1 + 8);
    uint64_t v12 = i[8];
    char v13 = (std::string *)(v7 + 96 * v10);
    if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - v8) >> 5)) >= v9)
    {
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - (void)v13) >> 5)) >= v9)
      {
        long long v18 = &v3[4 * v9];
        __int16 v20 = (std::string *)i[7];
      }
      else
      {
        long long v18 = (std::string *)((char *)v3 + 32 * ((uint64_t)(v8 - (void)v13) >> 5));
        if (v18 == v4)
        {
          __int16 v20 = (std::string *)i[7];
        }
        else
        {
          uint64_t v19 = 0;
          do
          {
            sub_100CC682C((char *)(v8 + v19 * 24), (long long *)&v18[v19]);
            v19 += 4;
          }
          while (&v18[v19] != v4);
          __int16 v20 = (std::string *)(v8 + v19 * 24);
          uint64_t v10 = (uint64_t)(v8 - v7) / 96;
        }
        i[7] = v20;
        if ((uint64_t)(v8 - (void)v13) < 1) {
          goto LABEL_47;
        }
      }
      uint64_t v39 = &v13[4 * v9];
      int v40 = &v20[-4 * v9];
      uint64_t v41 = v20;
      if ((unint64_t)v40 < v8)
      {
        uint64_t v41 = v20;
        do
        {
          long long v42 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
          v41->__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v41->__r_.__value_.__l.__data_ = v42;
          v40->__r_.__value_.__l.__size_ = 0;
          v40->__r_.__value_.__r.__words[2] = 0;
          v40->__r_.__value_.__r.__words[0] = 0;
          long long v43 = *(_OWORD *)&v40[1].__r_.__value_.__l.__data_;
          v41[1].__r_.__value_.__r.__words[2] = v40[1].__r_.__value_.__r.__words[2];
          *(_OWORD *)&v41[1].__r_.__value_.__l.__data_ = v43;
          v40[1].__r_.__value_.__l.__size_ = 0;
          v40[1].__r_.__value_.__r.__words[2] = 0;
          v40[1].__r_.__value_.__r.__words[0] = 0;
          long long v44 = *(_OWORD *)&v40[2].__r_.__value_.__l.__data_;
          v41[2].__r_.__value_.__r.__words[2] = v40[2].__r_.__value_.__r.__words[2];
          *(_OWORD *)&v41[2].__r_.__value_.__l.__data_ = v44;
          v40[2].__r_.__value_.__l.__size_ = 0;
          v40[2].__r_.__value_.__r.__words[2] = 0;
          v40[2].__r_.__value_.__r.__words[0] = 0;
          long long v45 = *(_OWORD *)&v40[3].__r_.__value_.__l.__data_;
          v41[3].__r_.__value_.__r.__words[2] = v40[3].__r_.__value_.__r.__words[2];
          *(_OWORD *)&v41[3].__r_.__value_.__l.__data_ = v45;
          v40[3].__r_.__value_.__r.__words[0] = 0;
          v40[3].__r_.__value_.__l.__size_ = 0;
          v40[3].__r_.__value_.__r.__words[2] = 0;
          v41 += 4;
          v40 += 4;
        }
        while ((unint64_t)v40 < v8);
      }
      long long v66 = i;
      i[7] = v41;
      if (v20 != v39)
      {
        unint64_t v46 = 0;
        unint64_t v47 = 0xAAAAAAAAAAAAAAABLL * (((char *)v20 - (char *)v39) >> 5);
        uint64_t v48 = -96 * v47;
        uint64_t v49 = v7 + 96 * v47 + 96 * v10;
        do
        {
          uint64_t v50 = &v20[v46 / 0x18];
          p_data = (void **)&v20[v46 / 0x18 - 4].__r_.__value_.__l.__data_;
          if (*((char *)&v20[v46 / 0x18 - 3] - 1) < 0) {
            operator delete(*p_data);
          }
          uint64_t v52 = v49 + v46;
          uint64_t v53 = (long long *)(v49 + v46 - 96);
          long long v54 = *v53;
          *((void *)&v20[v46 / 0x18 - 3] - 1) = *(void *)(v49 + v46 - 80);
          *(_OWORD *)p_data = v54;
          *(unsigned char *)(v49 + v46 - 73) = 0;
          *(unsigned char *)uint64_t v53 = 0;
          uint64_t v55 = v50 - 3;
          if (SHIBYTE(v50[-3].__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v55->__r_.__value_.__l.__data_);
          }
          uint64_t v56 = v49 + v46;
          long long v57 = *(_OWORD *)(v52 - 72);
          v55->__r_.__value_.__r.__words[2] = *(void *)(v52 - 56);
          *(_OWORD *)&v55->__r_.__value_.__l.__data_ = v57;
          *(unsigned char *)(v49 + v46 - 49) = 0;
          *(unsigned char *)(v52 - 72) = 0;
          uint64_t v58 = &v20[v46 / 0x18];
          __int16 v59 = (void **)&v20[v46 / 0x18 - 2].__r_.__value_.__l.__data_;
          if (*((char *)&v20[v46 / 0x18 - 1] - 1) < 0) {
            operator delete(*v59);
          }
          long long v60 = *(_OWORD *)(v56 - 48);
          *((void *)&v20[v46 / 0x18 - 1] - 1) = *(void *)(v56 - 32);
          *(_OWORD *)__int16 v59 = v60;
          *(unsigned char *)(v56 - 25) = 0;
          *(unsigned char *)(v56 - 48) = 0;
          long long v61 = (void **)&v58[-1].__r_.__value_.__l.__data_;
          if (SHIBYTE(v58[-1].__r_.__value_.__r.__words[2]) < 0) {
            operator delete(*v61);
          }
          uint64_t v62 = v49 + v46;
          long long v63 = *(_OWORD *)(v49 + v46 - 24);
          v58[-1].__r_.__value_.__r.__words[2] = *(void *)(v49 + v46 - 8);
          *(_OWORD *)long long v61 = v63;
          *(unsigned char *)(v62 - 1) = 0;
          *(unsigned char *)(v62 - 24) = 0;
          v46 -= 96;
        }
        while (v48 != v46);
      }
      for (uint64_t i = v66; v3 != v18; v13 += 4)
      {
        std::string::operator=(v13, v3);
        std::string::operator=(v13 + 1, v3 + 1);
        std::string::operator=(v13 + 2, v3 + 2);
        std::string::operator=(v13 + 3, v3 + 3);
        v3 += 4;
      }
    }
    else
    {
      unint64_t v14 = v10 + v9;
      if ((unint64_t)(v10 + v9) > 0x2AAAAAAAAAAAAAALL) {
        sub_10006A748();
      }
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v7) >> 5);
      if (2 * v15 > v14) {
        unint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x155555555555555) {
        unint64_t v16 = 0x2AAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v16 = v14;
      }
      unsigned __int8 v71 = i + 8;
      if (v16) {
        int v17 = (char *)sub_100157260(v11, v16);
      }
      else {
        int v17 = 0;
      }
      uint64_t v21 = &v17[96 * v10];
      uint64_t v67 = v17;
      char v68 = v21;
      unsigned __int8 v69 = (std::string *)v21;
      uint64_t v70 = &v17[96 * v16];
      uint64_t v22 = &v21[96 * v9];
      uint64_t v23 = 96 * v9;
      do
      {
        sub_100CC682C(v21, (long long *)v3);
        v21 += 96;
        v3 += 4;
        v23 -= 96;
      }
      while (v23);
      uint64_t v24 = v68;
      uint64_t v25 = *v6;
      if (*v6 == v13)
      {
        long long v27 = v68;
      }
      else
      {
        long long v26 = v13;
        do
        {
          long long v27 = v24 - 96;
          long long v28 = *(_OWORD *)&v26[-4].__r_.__value_.__l.__data_;
          *((void *)v24 - 10) = *((void *)&v26[-4].__r_.__value_.__l + 2);
          *((_OWORD *)v24 - 6) = v28;
          v26[-4].__r_.__value_.__l.__size_ = 0;
          v26[-4].__r_.__value_.__r.__words[2] = 0;
          v26[-4].__r_.__value_.__r.__words[0] = 0;
          long long v29 = *(_OWORD *)&v26[-3].__r_.__value_.__l.__data_;
          *((void *)v24 - 7) = *((void *)&v26[-3].__r_.__value_.__l + 2);
          *(_OWORD *)(v24 - 72) = v29;
          v26[-3].__r_.__value_.__l.__size_ = 0;
          v26[-3].__r_.__value_.__r.__words[2] = 0;
          v26[-3].__r_.__value_.__r.__words[0] = 0;
          long long v30 = *(_OWORD *)&v26[-2].__r_.__value_.__l.__data_;
          *((void *)v24 - 4) = *((void *)&v26[-2].__r_.__value_.__l + 2);
          *((_OWORD *)v24 - 3) = v30;
          v26[-2].__r_.__value_.__l.__size_ = 0;
          v26[-2].__r_.__value_.__r.__words[2] = 0;
          v26[-2].__r_.__value_.__r.__words[0] = 0;
          long long v31 = *(_OWORD *)&v26[-1].__r_.__value_.__l.__data_;
          *((void *)v24 - 1) = *((void *)&v26[-1].__r_.__value_.__l + 2);
          *(_OWORD *)(v24 - 24) = v31;
          v26[-1].__r_.__value_.__r.__words[0] = 0;
          v26[-1].__r_.__value_.__l.__size_ = 0;
          v26[-1].__r_.__value_.__r.__words[2] = 0;
          v26 -= 4;
          v24 -= 96;
        }
        while (v26 != v25);
      }
      uint64_t v32 = (std::string *)i[7];
      if (v32 != v13)
      {
        do
        {
          long long v33 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
          *((void *)v22 + 2) = *((void *)&v13->__r_.__value_.__l + 2);
          *(_OWORD *)uint64_t v22 = v33;
          v13->__r_.__value_.__l.__size_ = 0;
          v13->__r_.__value_.__r.__words[2] = 0;
          v13->__r_.__value_.__r.__words[0] = 0;
          long long v34 = *(_OWORD *)&v13[1].__r_.__value_.__l.__data_;
          *((void *)v22 + 5) = *((void *)&v13[1].__r_.__value_.__l + 2);
          *(_OWORD *)(v22 + 24) = v34;
          v13[1].__r_.__value_.__l.__size_ = 0;
          v13[1].__r_.__value_.__r.__words[2] = 0;
          v13[1].__r_.__value_.__r.__words[0] = 0;
          long long v35 = *(_OWORD *)&v13[2].__r_.__value_.__l.__data_;
          *((void *)v22 + 8) = *((void *)&v13[2].__r_.__value_.__l + 2);
          *((_OWORD *)v22 + 3) = v35;
          v13[2].__r_.__value_.__l.__size_ = 0;
          v13[2].__r_.__value_.__r.__words[2] = 0;
          v13[2].__r_.__value_.__r.__words[0] = 0;
          long long v36 = *(_OWORD *)&v13[3].__r_.__value_.__l.__data_;
          *((void *)v22 + 11) = *((void *)&v13[3].__r_.__value_.__l + 2);
          *(_OWORD *)(v22 + 72) = v36;
          v13[3].__r_.__value_.__r.__words[0] = 0;
          v13[3].__r_.__value_.__l.__size_ = 0;
          v13[3].__r_.__value_.__r.__words[2] = 0;
          v22 += 96;
          v13 += 4;
        }
        while (v13 != v32);
        char v13 = (std::string *)i[7];
      }
      uint64_t v37 = (char *)i[6];
      i[6] = v27;
      i[7] = v22;
      uint64_t v38 = (char *)i[8];
      i[8] = v70;
      unsigned __int8 v69 = v13;
      uint64_t v70 = v38;
      uint64_t v67 = v37;
      char v68 = v37;
      sub_10016A954((uint64_t)&v67);
    }
  }
LABEL_47:
  long long v64 = *(uint64_t (**)(void *))(*i + 40);

  return v64(i);
}

void sub_100CC5B88(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 48);
  for (uint64_t i = *(void *)(a1 + 56); i != v3; sub_10016A8DC(i))
    i -= 96;
  *(void *)(a1 + 56) = v3;
}

uint64_t sub_100CC5BD0@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(long long **)(result + 48);
  if (*(long long **)(result + 56) == v3)
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 96) = 0;
  }
  else
  {
    uint64_t v4 = (void *)result;
    memset(v15, 0, sizeof(v15));
    long long v14 = 0u;
    memset(v13, 0, sizeof(v13));
    sub_100CC682C((char *)v13, v3);
    uint64_t v5 = v4[6];
    uint64_t v6 = v4[7];
    uint64_t v7 = v5 + 96;
    if (v5 + 96 != v6)
    {
      do
      {
        if (*(char *)(v5 + 23) < 0) {
          operator delete(*(void **)v5);
        }
        *(_OWORD *)uint64_t v5 = *(_OWORD *)(v5 + 96);
        *(void *)(v5 + 16) = *(void *)(v5 + 112);
        *(unsigned char *)(v5 + 119) = 0;
        *(unsigned char *)(v5 + 96) = 0;
        unint64_t v8 = (void **)(v5 + 24);
        if (*(char *)(v5 + 47) < 0) {
          operator delete(*v8);
        }
        *(_OWORD *)unint64_t v8 = *(_OWORD *)(v5 + 120);
        *(void *)(v5 + 40) = *(void *)(v5 + 136);
        *(unsigned char *)(v5 + 143) = 0;
        *(unsigned char *)(v5 + 120) = 0;
        uint64_t v9 = (void **)(v5 + 48);
        if (*(char *)(v5 + 71) < 0) {
          operator delete(*v9);
        }
        *(_OWORD *)uint64_t v9 = *(_OWORD *)(v5 + 144);
        *(void *)(v5 + 64) = *(void *)(v5 + 160);
        *(unsigned char *)(v5 + 167) = 0;
        *(unsigned char *)(v5 + 144) = 0;
        uint64_t v10 = (void **)(v5 + 72);
        if (*(char *)(v5 + 95) < 0) {
          operator delete(*v10);
        }
        *(_OWORD *)uint64_t v10 = *(_OWORD *)(v5 + 168);
        *(void *)(v5 + 88) = *(void *)(v5 + 184);
        *(unsigned char *)(v5 + 191) = 0;
        *(unsigned char *)(v5 + 168) = 0;
        uint64_t v11 = v5 + 96;
        uint64_t v12 = v5 + 192;
        v5 += 96;
      }
      while (v12 != v6);
      uint64_t v7 = v4[7];
      uint64_t v5 = v11;
    }
    while (v7 != v5)
    {
      v7 -= 96;
      sub_10016A8DC(v7);
    }
    v4[7] = v5;
    double result = (*(uint64_t (**)(void *))(*v4 + 40))(v4);
    *(_OWORD *)a2 = v13[0];
    *(void *)(a2 + 16) = *(void *)&v13[1];
    *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)&v13[1] + 8);
    *(void *)(a2 + 40) = *((void *)&v13[2] + 1);
    *(_OWORD *)(a2 + 48) = v14;
    *(void *)(a2 + 64) = *(void *)&v15[0];
    *(void *)(a2 + 88) = *((void *)&v15[1] + 1);
    *(_OWORD *)(a2 + 72) = *(_OWORD *)((char *)v15 + 8);
    *(unsigned char *)(a2 + 96) = 1;
  }
  return result;
}

void sub_100CC5DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100CC5DC0(void *a1)
{
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  long long v33 = (Registry *)a1[1];
  long long v34 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100B89BE4(&v33, (uint64_t)(a1 + 3), @"Token", &v35);
  if (v34) {
    sub_10004D2C8(v34);
  }
  uint64_t v3 = v35;
  uint64_t v4 = v36;
  if (v35 != v36)
  {
    do
    {
      memset(&__dst, 0, sizeof(__dst));
      if (*(char *)(v3 + 23) < 0)
      {
        sub_10004FC84(&__dst, *(void **)v3, *(void *)(v3 + 8));
      }
      else
      {
        long long v5 = *(_OWORD *)v3;
        __dst.__r_.__value_.__r.__words[2] = *(void *)(v3 + 16);
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v5;
      }
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      *(_OWORD *)uint64_t v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v43 = 0u;
      sub_1003C09B4((void (__cdecl ***)(std::istringstream *__hidden))&v43, &__dst, 8);
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v42 = 0;
      uint64_t v38 = 0;
      uint64_t v39 = 0;
      unint64_t v40 = 0;
      while (1)
      {
        uint64_t v6 = (void *)sub_10013EA34((uint64_t)&v43);
        uint64_t v7 = v39;
        if ((*((unsigned char *)v6 + *(void *)(*v6 - 24) + 32) & 5) != 0) {
          break;
        }
        if ((unint64_t)v39 >= v40)
        {
          uint64_t v9 = (void *)sub_100048008((uint64_t *)&v38, (long long *)__p);
        }
        else
        {
          if (SHIBYTE(v42) < 0)
          {
            sub_10004FC84(v39, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            long long v8 = *(_OWORD *)__p;
            *((void *)v39 + 2) = v42;
            *uint64_t v7 = v8;
          }
          uint64_t v9 = (char *)v7 + 24;
        }
        uint64_t v39 = v9;
      }
      uint64_t v10 = (uint64_t)v38;
      if ((unsigned char *)v39 - (unsigned char *)v38 == 96)
      {
        if (*((char *)v38 + 23) < 0)
        {
          sub_10004FC84(v24, *(void **)v38, *((void *)v38 + 1));
          uint64_t v10 = (uint64_t)v38;
        }
        else
        {
          long long v11 = *v38;
          uint64_t v25 = *((void *)v38 + 2);
          *(_OWORD *)uint64_t v24 = v11;
        }
        if (*(char *)(v10 + 47) < 0)
        {
          sub_10004FC84(&v26, *(void **)(v10 + 24), *(void *)(v10 + 32));
          uint64_t v10 = (uint64_t)v38;
        }
        else
        {
          long long v12 = *(_OWORD *)(v10 + 24);
          uint64_t v27 = *(void *)(v10 + 40);
          long long v26 = v12;
        }
        if (*(char *)(v10 + 71) < 0)
        {
          sub_10004FC84(&v28, *(void **)(v10 + 48), *(void *)(v10 + 56));
          uint64_t v10 = (uint64_t)v38;
        }
        else
        {
          long long v13 = *(_OWORD *)(v10 + 48);
          uint64_t v29 = *(void *)(v10 + 64);
          long long v28 = v13;
        }
        if (*(char *)(v10 + 95) < 0)
        {
          sub_10004FC84(&v30, *(void **)(v10 + 72), *(void *)(v10 + 80));
        }
        else
        {
          long long v14 = *(_OWORD *)(v10 + 72);
          uint64_t v31 = *(void *)(v10 + 88);
          long long v30 = v14;
        }
      }
      else
      {
        sub_100058DB0(v24, "");
        sub_100058DB0(&v26, "");
        sub_100058DB0(&v28, "");
        sub_100058DB0(&v30, "");
      }
      long long v60 = &v38;
      sub_100047F64((void ***)&v60);
      if (SHIBYTE(v42) < 0) {
        operator delete(__p[0]);
      }
      *(void *)&long long v43 = v23;
      *(void *)((char *)&v43 + *(void *)(v23 - 24)) = v22;
      if (SBYTE7(v49) < 0) {
        operator delete(v48[0]);
      }
      std::streambuf::~streambuf();
      std::istream::~istream();
      std::ios::~ios();
      unint64_t v15 = a1[7];
      if (v15 >= a1[8])
      {
        uint64_t v20 = sub_10016A6B8(a1 + 6, (long long *)v24);
        int v21 = SHIBYTE(v31);
        a1[7] = v20;
        if (v21 < 0) {
          operator delete((void *)v30);
        }
      }
      else
      {
        long long v16 = *(_OWORD *)v24;
        *(void *)(v15 + 16) = v25;
        *(_OWORD *)unint64_t v15 = v16;
        v24[1] = 0;
        uint64_t v25 = 0;
        v24[0] = 0;
        uint64_t v17 = v27;
        *(_OWORD *)(v15 + 24) = v26;
        *(void *)(v15 + 40) = v17;
        uint64_t v27 = 0;
        long long v26 = 0uLL;
        long long v18 = v28;
        *(void *)(v15 + 64) = v29;
        *(_OWORD *)(v15 + 48) = v18;
        uint64_t v29 = 0;
        long long v28 = 0uLL;
        long long v19 = v30;
        *(void *)(v15 + 88) = v31;
        *(_OWORD *)(v15 + 72) = v19;
        long long v30 = 0uLL;
        uint64_t v31 = 0;
        a1[7] = v15 + 96;
      }
      if (SHIBYTE(v29) < 0) {
        operator delete((void *)v28);
      }
      if (SHIBYTE(v27) < 0) {
        operator delete((void *)v26);
      }
      if (SHIBYTE(v25) < 0) {
        operator delete(v24[0]);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      v3 += 24;
    }
    while (v3 != v4);
  }
  *(void *)&long long v43 = &v35;
  sub_100047F64((void ***)&v43);
}

void sub_100CC6280(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,std::__shared_weak_count *a41,char a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53,char a54)
{
  if (a41) {
    sub_10004D2C8(a41);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CC636C(void *a1)
{
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  unint64_t v43 = 0;
  uint64_t v1 = (long long *)a1[6];
  uint64_t v2 = (long long *)a1[7];
  if (v1 != v2)
  {
    long long v5 = 0uLL;
    do
    {
      *(_OWORD *)uint64_t v39 = v5;
      long long v40 = v5;
      long long v37 = v5;
      *(_OWORD *)uint64_t v38 = v5;
      *(_OWORD *)std::string __dst = v5;
      *(_OWORD *)uint64_t v36 = v5;
      sub_100CC682C((char *)__dst, v1);
      uint64_t v60 = 0;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      sub_10004DE24((uint64_t)&v44);
      if (SHIBYTE(v36[0]) >= 0) {
        uint64_t v6 = __dst;
      }
      else {
        uint64_t v6 = (void **)__dst[0];
      }
      if (SHIBYTE(v36[0]) >= 0) {
        uint64_t v7 = HIBYTE(v36[0]);
      }
      else {
        uint64_t v7 = (uint64_t)__dst[1];
      }
      long long v8 = sub_10004B96C(&v44, (uint64_t)v6, v7);
      uint64_t v9 = sub_10004B96C(v8, (uint64_t)"|", 1);
      if (v37 >= 0) {
        uint64_t v10 = &v36[1];
      }
      else {
        uint64_t v10 = (void **)v36[1];
      }
      if (v37 >= 0) {
        uint64_t v11 = HIBYTE(v37);
      }
      else {
        uint64_t v11 = v37;
      }
      long long v12 = sub_10004B96C(v9, (uint64_t)v10, v11);
      long long v13 = sub_10004B96C(v12, (uint64_t)"|", 1);
      if (SHIBYTE(v39[0]) >= 0) {
        long long v14 = v38;
      }
      else {
        long long v14 = (void **)v38[0];
      }
      if (SHIBYTE(v39[0]) >= 0) {
        uint64_t v15 = HIBYTE(v39[0]);
      }
      else {
        uint64_t v15 = (uint64_t)v38[1];
      }
      long long v16 = sub_10004B96C(v13, (uint64_t)v14, v15);
      uint64_t v17 = sub_10004B96C(v16, (uint64_t)"|", 1);
      if (v40 >= 0) {
        long long v18 = &v39[1];
      }
      else {
        long long v18 = (void **)v39[1];
      }
      if (v40 >= 0) {
        uint64_t v19 = HIBYTE(v40);
      }
      else {
        uint64_t v19 = v40;
      }
      sub_10004B96C(v17, (uint64_t)v18, v19);
      sub_10004BC98((uint64_t)&v44 + 8, v33);
      *(void *)&long long v44 = v3;
      *(void *)((char *)&v44 + *(void *)(v3 - 24)) = v4;
      if (SHIBYTE(v49) < 0) {
        operator delete(*((void **)&v48 + 1));
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      uint64_t v20 = v42;
      if ((unint64_t)v42 >= v43)
      {
        unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((v42 - v41) >> 3);
        unint64_t v23 = v22 + 1;
        if (v22 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v43 - (void)v41) >> 3) > v23) {
          unint64_t v23 = 0x5555555555555556 * ((uint64_t)(v43 - (void)v41) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v43 - (void)v41) >> 3) >= 0x555555555555555) {
          unint64_t v24 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v24 = v23;
        }
        *(void *)&long long v46 = &v43;
        if (v24) {
          uint64_t v25 = (char *)sub_10004812C((uint64_t)&v43, v24);
        }
        else {
          uint64_t v25 = 0;
        }
        long long v26 = &v25[24 * v22];
        *(void *)&long long v44 = v25;
        *((void *)&v44 + 1) = v26;
        *((void *)&v45 + 1) = &v25[24 * v24];
        long long v27 = *(_OWORD *)v33;
        *((void *)v26 + 2) = v34;
        *(_OWORD *)long long v26 = v27;
        v33[1] = 0;
        uint64_t v34 = 0;
        v33[0] = 0;
        *(void *)&long long v45 = v26 + 24;
        sub_100048204((uint64_t *)&v41, &v44);
        long long v28 = v42;
        sub_100048174((uint64_t)&v44);
        uint64_t v42 = v28;
        if (SHIBYTE(v34) < 0) {
          operator delete(v33[0]);
        }
      }
      else
      {
        long long v21 = *(_OWORD *)v33;
        *((void *)v42 + 2) = v34;
        _OWORD *v20 = v21;
        uint64_t v42 = (char *)v20 + 24;
      }
      if (SHIBYTE(v40) < 0) {
        operator delete(v39[1]);
      }
      if (SHIBYTE(v39[0]) < 0) {
        operator delete(v38[0]);
      }
      if (SHIBYTE(v37) < 0) {
        operator delete(v36[1]);
      }
      if (SHIBYTE(v36[0]) < 0) {
        operator delete(__dst[0]);
      }
      v1 += 6;
      long long v5 = 0uLL;
    }
    while (v1 != v2);
  }
  add_explicit = (std::__shared_weak_count *)a1[2];
  uint64_t v31 = (Registry *)a1[1];
  uint64_t v32 = add_explicit;
  if (add_explicit) {
    add_explicit = (std::__shared_weak_count *)atomic_fetch_add_explicit(&add_explicit->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100B89F38(&v31, (uint64_t)(a1 + 3), @"Token", (long long **)&v41, (uint64_t *)add_explicit);
  if (v32) {
    sub_10004D2C8(v32);
  }
  *(void *)&long long v44 = &v41;
  sub_100047F64((void ***)&v44);
}

void sub_100CC6784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,char a38)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  a22 = &a35;
  sub_100047F64((void ***)&a22);
  _Unwind_Resume(a1);
}

uint64_t sub_100CC6800(uint64_t a1)
{
  return -1431655765 * ((*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 5);
}

BOOL sub_100CC681C(uint64_t a1)
{
  return *(void *)(a1 + 56) != *(void *)(a1 + 48);
}

char *sub_100CC682C(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(__dst + 48, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *((_OWORD *)__dst + 3) = v6;
  }
  uint64_t v7 = __dst + 72;
  if (*((char *)a2 + 95) < 0)
  {
    sub_10004FC84(v7, *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v8 = *(long long *)((char *)a2 + 72);
    *((void *)__dst + 11) = *((void *)a2 + 11);
    *(_OWORD *)uint64_t v7 = v8;
  }
  return __dst;
}

void sub_100CC6910(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CC695C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  long long v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  time_t v6 = (uint64_t)((double)std::chrono::system_clock::now().__d_.__rep_ / 1000000.0);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v76 = 0;
  std::string::size_type v77 = 0;
  uint64_t v78 = 0;
  sub_10055FDE4(v6, &v76);
  unsigned __int8 v73 = 0;
  std::string::size_type v74 = 0;
  uint64_t v75 = 0;
  sub_10055FDE4(v6 + 1800, &v73);
  long long v71 = 0uLL;
  int64_t v72 = 0;
  std::operator+<char>();
  uint64_t v7 = std::string::append(&v61, "\">\n<rcspushlocation id=\"", 0x18uLL);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v62.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v62.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  int v9 = *(char *)(a2 + 23);
  if (v9 >= 0) {
    uint64_t v10 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v10 = *(const std::string::value_type **)a2;
  }
  if (v9 >= 0) {
    std::string::size_type v11 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v11 = *(void *)(a2 + 8);
  }
  long long v12 = std::string::append(&v62, v10, v11);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v63.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v63.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  long long v14 = std::string::append(&v63, "\" label=\"\">\n<gp:geopriv>\n<gp:location-info>\n<gml:Point srsName=\"urn:ogc:def:crs:EPSG::4326\">\n<gml:pos>", 0x66uLL);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v64.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v64.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v60, *(double *)(a2 + 48));
  if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v16 = &v60;
  }
  else {
    long long v16 = (std::string *)v60.__r_.__value_.__r.__words[0];
  }
  if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v60.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v60.__r_.__value_.__l.__size_;
  }
  long long v18 = std::string::append(&v64, (const std::string::value_type *)v16, size);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v65.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v65.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  uint64_t v20 = std::string::append(&v65, " ", 1uLL);
  long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  v66.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v66.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v59, *(double *)(a2 + 56));
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v22 = &v59;
  }
  else {
    unint64_t v22 = (std::string *)v59.__r_.__value_.__r.__words[0];
  }
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v23 = HIBYTE(v59.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v23 = v59.__r_.__value_.__l.__size_;
  }
  unint64_t v24 = std::string::append(&v66, (const std::string::value_type *)v22, v23);
  long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  v67.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v67.__r_.__value_.__l.__data_ = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  long long v26 = std::string::append(&v67, "</gml:pos>\n</gml:Point>\n</gp:location-info>\n<gp:usage-rules>\n<gp:retention-expiry>", 0x52uLL);
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  v68.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v68.__r_.__value_.__l.__data_ = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if (v75 >= 0) {
    long long v28 = (const std::string::value_type *)&v73;
  }
  else {
    long long v28 = v73;
  }
  if (v75 >= 0) {
    std::string::size_type v29 = HIBYTE(v75);
  }
  else {
    std::string::size_type v29 = v74;
  }
  long long v30 = std::string::append(&v68, v28, v29);
  long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  v69.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v69.__r_.__value_.__l.__data_ = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  uint64_t v32 = std::string::append(&v69, "</gp:retention-expiry>\n</gp:usage-rules>\n</gp:geopriv>\n<timestamp>", 0x42uLL);
  long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v70.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v70.__r_.__value_.__l.__data_ = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  if (v78 >= 0) {
    uint64_t v34 = (const std::string::value_type *)&v76;
  }
  else {
    uint64_t v34 = v76;
  }
  if (v78 >= 0) {
    std::string::size_type v35 = HIBYTE(v78);
  }
  else {
    std::string::size_type v35 = v77;
  }
  uint64_t v36 = std::string::append(&v70, v34, v35);
  long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
  *(void *)&v45[0] = *((void *)&v36->__r_.__value_.__l + 2);
  *(_OWORD *)std::string __p = v37;
  v36->__r_.__value_.__l.__size_ = 0;
  v36->__r_.__value_.__r.__words[2] = 0;
  v36->__r_.__value_.__r.__words[0] = 0;
  uint64_t v38 = std::string::append((std::string *)__p, "</timestamp>\n</rcspushlocation>\n</rcsenvelope>", 0x2EuLL);
  long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  int64_t v72 = v38->__r_.__value_.__r.__words[2];
  long long v71 = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  if (SBYTE7(v45[0]) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v70.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v69.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v68.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v67.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v59.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v66.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v65.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v60.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v64.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v63.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v62.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v61.__r_.__value_.__l.__data_);
  }
  uint64_t v58 = 0;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  *(_OWORD *)long long v46 = 0u;
  long long v47 = 0u;
  memset(v45, 0, sizeof(v45));
  *(_OWORD *)std::string __p = 0u;
  sub_10004BD84((uint64_t)__p);
  sub_1000BE8E8((uint64_t)__p, "Content-Type", off_101A8C270);
  int v40 = SHIBYTE(v72);
  if (v72 >= 0) {
    unint64_t v41 = HIBYTE(v72);
  }
  else {
    unint64_t v41 = *((void *)&v71 + 1);
  }
  std::to_string(&v70, v41);
  sub_1000BE9C4((uint64_t)__p, "Content-Length", &v70);
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v70.__r_.__value_.__l.__data_);
  }
  sub_10004B96C(v45, (uint64_t)"\r\n", 2);
  if (v40 >= 0) {
    uint64_t v42 = &v71;
  }
  else {
    uint64_t v42 = (long long *)v71;
  }
  sub_10004B96C(v45, (uint64_t)v42, v41);
  sub_10004BC98((uint64_t)v45 + 8, &v70);
  sub_100CC8650(a3, (uint64_t)&v70);
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v70.__r_.__value_.__l.__data_);
  }
  *(void **)((char *)__p
  *(void *)&v45[0] = v43;
  if (SHIBYTE(v47) < 0) {
    operator delete(v46[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if (SHIBYTE(v72) < 0) {
    operator delete((void *)v71);
  }
  if (SHIBYTE(v75) < 0) {
    operator delete(v73);
  }
  if (SHIBYTE(v78) < 0) {
    operator delete(v76);
  }
}

void sub_100CC6F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p)
{
  if (*(char *)(v9 - 137) < 0) {
    operator delete(*(void **)(v9 - 160));
  }
  sub_10008248C((uint64_t)&__p);
  if (*(char *)(v9 - 105) < 0) {
    operator delete(*(void **)(v9 - 128));
  }
  if (*(char *)(v9 - 73) < 0) {
    operator delete(*(void **)(v9 - 96));
  }
  if (*(char *)(v9 - 49) < 0) {
    operator delete(*(void **)(v9 - 72));
  }
  _Unwind_Resume(a1);
}

void *sub_100CC7114(void *__dst, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v5 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v5) < 0)
  {
    sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
    if (SHIBYTE(v5) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)__p;
    __dst[2] = v5;
  }
  return __dst;
}

void sub_100CC71A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CC71C0()
{
  long long v2 = 0u;
  long long v3 = 0u;
  *(_OWORD *)&v0[0].__locale_ = 0u;
  long long v1 = 0u;
  sub_10056D028(v0, "<*(sip:)(\\+*\\d+).*?(@.*?)(?:;.*|\\?.*|>)?$", 0);
}

void sub_100CC776C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *__p,uint64_t a43)
{
  operator delete(v43);
  _Unwind_Resume(a1);
}

void sub_100CC786C()
{
  long long v2 = 0u;
  long long v3 = 0u;
  *(_OWORD *)&v0[0].__locale_ = 0u;
  long long v1 = 0u;
  sub_10056D028(v0, "<*(.*?)>*", 0);
}

void sub_100CC79AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100155138((std::locale *)(v17 - 80));
  _Unwind_Resume(a1);
}

void sub_100CC79E8()
{
  v0[0] = 0;
  v0[1] = 0;
  uint64_t v1 = 0;
  sub_100CC71C0();
}

void sub_100CC7B54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CC7BB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    JUMPOUT(0x100CC7BA4);
  }
  JUMPOUT(0x100CC7BA8);
}

void sub_100CC7BC4()
{
  long long v2 = 0u;
  long long v3 = 0u;
  *(_OWORD *)&v0[0].__locale_ = 0u;
  long long v1 = 0u;
  sub_10056D028(v0, "(\\+*\\d+)", 0);
}

void sub_100CC7D24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::locale a23)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100155138(&a23);
  _Unwind_Resume(a1);
}

void sub_100CC7D60()
{
}

void sub_100CC7E78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC7E94(void *a1)
{
  if (!sub_100CC7F88(a1) && !sub_100CC801C(a1))
  {
    long long v5 = 0u;
    long long v6 = 0u;
    *(_OWORD *)&v3[0].__locale_ = 0u;
    long long v4 = 0u;
    sub_10056D028(v3, "^[\\w\\.\\-]+@[\\w\\.\\-]+$", 0);
  }
  return 0;
}

void sub_100CC7F64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100155138((std::locale *)(v10 - 80));
  _Unwind_Resume(a1);
}

BOOL sub_100CC7F88(void *__s)
{
  long long v1 = __s;
  if (*((char *)__s + 23) < 0)
  {
    long long v1 = (void *)*__s;
    uint64_t v2 = __s[1];
  }
  else
  {
    uint64_t v2 = *((unsigned __int8 *)__s + 23);
  }
  long long v3 = (char *)v1 + v2;
  if (v2 >= 4)
  {
    long long v4 = v1;
    do
    {
      long long v5 = (char *)memchr(v4, 115, v2 - 3);
      if (!v5) {
        break;
      }
      if (*(_DWORD *)v5 == 980445555) {
        return v5 != v3 && v5 - (char *)v1 != -1;
      }
      long long v4 = v5 + 1;
      uint64_t v2 = v3 - (unsigned char *)v4;
    }
    while (v3 - (unsigned char *)v4 > 3);
  }
  long long v5 = v3;
  return v5 != v3 && v5 - (char *)v1 != -1;
}

BOOL sub_100CC801C(void *__s)
{
  long long v1 = __s;
  if (*((char *)__s + 23) < 0)
  {
    long long v1 = (void *)*__s;
    uint64_t v2 = __s[1];
  }
  else
  {
    uint64_t v2 = *((unsigned __int8 *)__s + 23);
  }
  long long v3 = (char *)v1 + v2;
  if (v2 >= 4)
  {
    long long v4 = v1;
    do
    {
      long long v5 = (char *)memchr(v4, 116, v2 - 3);
      if (!v5) {
        break;
      }
      if (*(_DWORD *)v5 == 980182388) {
        return v5 != v3 && v5 - (char *)v1 != -1;
      }
      long long v4 = v5 + 1;
      uint64_t v2 = v3 - (unsigned char *)v4;
    }
    while (v3 - (unsigned char *)v4 > 3);
  }
  long long v5 = v3;
  return v5 != v3 && v5 - (char *)v1 != -1;
}

void sub_100CC80B0()
{
  memset(v0, 0, sizeof(v0));
  sub_10056D028((std::locale *)v0, "(@botplatform|\\+g.gsma.rcs.isbot|\\-bot@)", 0);
}

void sub_100CC8164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100155138((std::locale *)&a9);
  _Unwind_Resume(a1);
}

void sub_100CC8188()
{
  memset(v0, 0, sizeof(v0));
  sub_10056D028((std::locale *)v0, "(conference=)", 0);
}

void sub_100CC823C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100155138((std::locale *)&a9);
  _Unwind_Resume(a1);
}

void sub_100CC8260()
{
  long long v2 = 0u;
  long long v3 = 0u;
  *(_OWORD *)&v0[0].__locale_ = 0u;
  long long v1 = 0u;
  sub_10056D028(v0, "^\\+*\\d+.*", 0);
}

void sub_100CC8314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100155138((std::locale *)(v10 - 80));
  _Unwind_Resume(a1);
}

void sub_100CC8338()
{
  long long v2 = 0u;
  long long v3 = 0u;
  *(_OWORD *)&v0[0].__locale_ = 0u;
  long long v1 = 0u;
  sub_10056D028(v0, "sip:(\\+*\\d+)@.*", 0);
}

void sub_100CC8494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::locale a23)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100155138(&a23);
  _Unwind_Resume(a1);
}

void sub_100CC84D0()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  sub_100CC7BC4();
}

void *sub_100CC85C0(void *__dst, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v5 = *(void *)(a2 + 16);
  }
  sub_100CC7114(__dst, (uint64_t)__p);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
  return __dst;
}

void sub_100CC8634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100CC8650(void *__dst, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v6) < 0)
  {
    sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
    int v3 = SHIBYTE(v6);
    __dst[3] = 0;
    *((_DWORD *)__dst + 8) = 0;
    if (v3 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)__p;
    __dst[2] = v6;
    __dst[3] = 0;
    *((_DWORD *)__dst + 8) = 0;
  }
  return __dst;
}

void sub_100CC86EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

xpc_object_t sub_100CC8708@<X0>(const void **a1@<X0>, void *a2@<X8>)
{
  if (*((char *)a1 + 23) < 0)
  {
    long long v4 = a1;
    a1 = (const void **)*a1;
    size_t v3 = (size_t)v4[1];
  }
  else
  {
    size_t v3 = *((unsigned __int8 *)a1 + 23);
  }
  xpc_object_t result = xpc_data_create(a1, v3);
  *a2 = result;
  if (!result)
  {
    xpc_object_t result = xpc_null_create();
    *a2 = result;
  }
  return result;
}

BOOL sub_100CC8758(uint64_t a1, char *a2)
{
  memset(&__p, 0, sizeof(__p));
  std::locale::locale((std::locale *)&v26);
  int v4 = *(char *)(a1 + 23);
  BOOL v5 = v4 < 0;
  if (v4 >= 0) {
    uint64_t v6 = (char *)a1;
  }
  else {
    uint64_t v6 = *(char **)a1;
  }
  uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  if (v5) {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  sub_100CC9460(&__p, v6, (std::locale *)&v26, &v6[v7]);
  std::locale::~locale((std::locale *)&v26);
  memset(&v26, 0, sizeof(v26));
  std::locale::locale(&v25);
  int v8 = a2[23];
  BOOL v9 = v8 < 0;
  if (v8 >= 0) {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v10 = *(char **)a2;
  }
  uint64_t v11 = a2[23];
  if (v9) {
    uint64_t v11 = *((void *)a2 + 1);
  }
  sub_100CC9460(&v26, v10, &v25, &v10[v11]);
  std::locale::~locale(&v25);
  int64_t size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  char v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  int64_t v15 = *((void *)a2 + 1);
  if (a2[23] >= 0)
  {
    int64_t v16 = a2[23];
  }
  else
  {
    a2 = *(char **)a2;
    int64_t v16 = v15;
  }
  if (v16)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int64_t size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v17 = (char *)p_p + size;
    if (size >= v16)
    {
      int v21 = *a2;
      unint64_t v22 = p_p;
      do
      {
        int64_t v23 = size - v16;
        if (v23 == -1) {
          break;
        }
        unint64_t v24 = (char *)memchr(v22, v21, v23 + 1);
        if (!v24) {
          break;
        }
        long long v18 = v24;
        if (!memcmp(v24, a2, v16)) {
          goto LABEL_22;
        }
        unint64_t v22 = (std::string *)(v18 + 1);
        int64_t size = v17 - (v18 + 1);
      }
      while (size >= v16);
    }
    long long v18 = v17;
LABEL_22:
    if (v18 == v17) {
      uint64_t v19 = -1;
    }
    else {
      uint64_t v19 = v18 - (char *)p_p;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v26.__r_.__value_.__l.__data_);
    if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) == 0) {
      return v19 != -1;
    }
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    return v19 != -1;
  }
  if (v13 < 0) {
    goto LABEL_30;
  }
  return v19 != -1;
}

void sub_100CC8900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, std::locale a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_100CC8934(void *__dst, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v6) < 0)
  {
    sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
    int v3 = SHIBYTE(v6);
    __dst[3] = 0;
    *((_DWORD *)__dst + 8) = 0;
    if (v3 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)__p;
    __dst[2] = v6;
    __dst[3] = 0;
    *((_DWORD *)__dst + 8) = 0;
  }
  return __dst;
}

void sub_100CC89D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100CC89EC(void *__dst, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v6 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v6) < 0)
  {
    sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
    int v3 = SHIBYTE(v6);
    __dst[3] = 0;
    *((_DWORD *)__dst + 8) = 0;
    if (v3 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)__p;
    __dst[2] = v6;
    __dst[3] = 0;
    *((_DWORD *)__dst + 8) = 0;
  }
  return __dst;
}

void sub_100CC8A88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC8AA4(uint64_t a1, long long *a2, long long *a3, long long *a4, char a5)
{
  *(void *)a1 = off_101A4E5B8;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v9 = *a2;
    *(void *)(a1 + 24) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 8) = v9;
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v10 = *a3;
    *(void *)(a1 + 48) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 32) = v10;
  }
  uint64_t v11 = (unsigned char *)(a1 + 56);
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(v11, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v12 = *a4;
    *(void *)(a1 + 72) = *((void *)a4 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }
  uint64_t v13 = *((void *)a4 + 3);
  *(_DWORD *)(a1 + 88) = *((_DWORD *)a4 + 8);
  *(void *)(a1 + 80) = v13;
  *(unsigned char *)(a1 + 96) = a5;
  *(unsigned char *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  return a1;
}

void sub_100CC8BA8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC8BDC(uint64_t a1)
{
  *(void *)a1 = off_101A4E5B8;
  if (*(unsigned char *)(a1 + 160) && *(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(unsigned char *)(a1 + 128) && *(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100CC8C80(uint64_t a1)
{
  sub_100CC8BDC(a1);

  operator delete();
}

void *sub_100CC8CB8(void *a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5, char a6)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a2;
    uint64_t v21 = *(void *)(a2 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(v18, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long v18 = *(_OWORD *)a4;
    uint64_t v19 = *(void *)(a4 + 16);
  }
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a5;
    uint64_t v15 = *(void *)(a5 + 16);
  }
  uint64_t v16 = *(void *)(a5 + 24);
  int v17 = *(_DWORD *)(a5 + 32);
  sub_100CC8AA4((uint64_t)a1, (long long *)__dst, (long long *)v18, (long long *)__p, a6);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[0]);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(__dst[0]);
  }
  *a1 = off_101A4E5D8;
  uint64_t v11 = a1 + 21;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(v11, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v12 = *a3;
    a1[23] = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }
  return a1;
}

void sub_100CC8E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  sub_100CC8BDC(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_100CC8E78(uint64_t a1)
{
  *(void *)a1 = off_101A4E5D8;
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }

  return sub_100CC8BDC(a1);
}

void sub_100CC8EDC(uint64_t a1)
{
  sub_100CC8E78(a1);

  operator delete();
}

void *sub_100CC8F14(void *a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a4;
    uint64_t v21 = *(void *)(a4 + 16);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v18, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long v18 = *(_OWORD *)a3;
    uint64_t v19 = *(void *)(a3 + 16);
  }
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a5;
    uint64_t v15 = *(void *)(a5 + 16);
  }
  uint64_t v16 = *(void *)(a5 + 24);
  int v17 = *(_DWORD *)(a5 + 32);
  sub_100CC8AA4((uint64_t)a1, (long long *)__dst, (long long *)v18, (long long *)__p, a6);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[0]);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(__dst[0]);
  }
  *a1 = off_101A4E5F8;
  uint64_t v11 = a1 + 21;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(v11, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v12 = *a2;
    a1[23] = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }
  return a1;
}

void sub_100CC9074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  sub_100CC8BDC(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_100CC90D0(uint64_t a1)
{
  *(void *)a1 = off_101A4E5F8;
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }

  return sub_100CC8BDC(a1);
}

void sub_100CC9134(uint64_t a1)
{
  sub_100CC90D0(a1);

  operator delete();
}

void *sub_100CC916C@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (!*((unsigned char *)result + 128)) {
    return sub_100058DB0(a2, (char *)&unk_10164D7A3);
  }
  if (*((char *)result + 127) < 0) {
    return sub_10004FC84(a2, (void *)result[13], result[14]);
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 13);
  a2[2] = result[15];
  return result;
}

uint64_t sub_100CC91B0(uint64_t a1, uint64_t a2, long long *a3, long long **a4, uint64_t a5, uint64_t a6, char a7)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a2;
    uint64_t v22 = *(void *)(a2 + 16);
  }
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(v19, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v19 = *(_OWORD *)a5;
    uint64_t v20 = *(void *)(a5 + 16);
  }
  if (*(char *)(a6 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a6, *(void *)(a6 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a6;
    uint64_t v16 = *(void *)(a6 + 16);
  }
  uint64_t v17 = *(void *)(a6 + 24);
  int v18 = *(_DWORD *)(a6 + 32);
  sub_100CC8AA4(a1, (long long *)__dst, (long long *)v19, (long long *)__p, a7);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
  if (SHIBYTE(v22) < 0) {
    operator delete(__dst[0]);
  }
  *(void *)a1 = off_101A4E618;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 168), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v13 = *a3;
    *(void *)(a1 + 184) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 168) = v13;
  }
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  sub_100938284((char *)(a1 + 192), *a4, a4[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a4[1] - (char *)*a4) >> 3));
  return a1;
}

void sub_100CC9344(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  sub_100CC8BDC(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_100CC93B8(uint64_t a1)
{
  *(void *)a1 = off_101A4E618;
  int v3 = (void **)(a1 + 192);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  return sub_100CC8BDC(a1);
}

void sub_100CC9428(uint64_t a1)
{
  sub_100CC93B8(a1);

  operator delete();
}

void sub_100CC9460(std::string *a1, char *a2, std::locale *this, char *a4)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a4)
  {
    uint64_t v6 = a2;
    do
    {
      char v8 = *v6;
      long long v9 = std::locale::use_facet(this, &std::ctype<char>::id);
      std::string::value_type v10 = ((uint64_t (*)(const std::locale::facet *, void))v9->__vftable[1].__on_zero_shared)(v9, v8);
      std::string::push_back(a1, v10);
      ++v6;
    }
    while (v6 != a4);
  }
}

void sub_100CC9504(void *a1)
{
  __cxa_begin_catch(a1);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  __cxa_rethrow();
}

void sub_100CC9520(_Unwind_Exception *a1)
{
}

uint64_t sub_100CC9534(uint64_t a1, int a2)
{
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  int v3 = (char *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_100215304((void **)(a1 + 8), 0);
  sub_10008A534(v3, 0, 0, 0);
  return a1;
}

void sub_100CC9590(_Unwind_Exception *exception_object)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC95AC(uint64_t a1, int a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  int v4 = (char *)(a1 + 8);
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  BOOL v5 = *(char **)a3;
  uint64_t v6 = *(void *)(a3 + 8) - *(void *)a3;
  if (v6)
  {
    unint64_t v7 = v6 >> 2;
    sub_100215304((void **)(a1 + 8), v6 >> 2);
    uint64_t v8 = (uint64_t)&v5[4 * v7];
  }
  else
  {
    sub_100215304((void **)(a1 + 8), 0);
    BOOL v5 = 0;
    uint64_t v8 = 0;
    unint64_t v7 = 0;
  }
  sub_10008A534(v4, v5, v8, v7);
  return a1;
}

void sub_100CC9634(_Unwind_Exception *exception_object)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC9650(uint64_t a1, int a2, int a3)
{
  int __src = a3;
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  int v4 = (char *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_100215304((void **)(a1 + 8), 1uLL);
  sub_10008A534(v4, (char *)&__src, (uint64_t)&v7, 1uLL);
  return a1;
}

void sub_100CC96BC(_Unwind_Exception *exception_object)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC96D8(uint64_t a1, int a2, int a3, int a4)
{
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  BOOL v5 = (char *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  v7[0] = a3;
  v7[1] = a4;
  sub_100215304((void **)(a1 + 8), 2uLL);
  sub_10008A534(v5, (char *)v7, (uint64_t)&v8, 2uLL);
  return a1;
}

void sub_100CC9770(_Unwind_Exception *exception_object)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC978C(uint64_t a1, int a2, char *a3, unint64_t a4)
{
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v7 = (char *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_100215304((void **)(a1 + 8), a4);
  sub_10008A534(v7, a3, (uint64_t)&a3[4 * a4], a4);
  return a1;
}

void sub_100CC97F0(_Unwind_Exception *exception_object)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CC980C()
{
  if (!qword_101B13EF8) {
    operator new();
  }
  return qword_101B13EF8;
}

void sub_100CC98C4()
{
}

uint64_t sub_100CC9918(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_101A4E690;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 1065353216;
  sub_100CC999C(a1, a2);
  return a1;
}

void sub_100CC9978(_Unwind_Exception *a1)
{
  sub_1004DD39C(v1 + 32);
  int v3 = *(void **)(v1 + 8);
  if (v3)
  {
    *(void *)(v1 + 16) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(a1);
}

void sub_100CC999C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (*(void *)(a2 + 16) != v2)
  {
    unint64_t v5 = 0;
    unsigned int v6 = 1;
    do
    {
      uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(v2 + 8 * v5) + 80))(*(void *)(v2 + 8 * v5));
      sub_100CC9AE4(a1, v7, 1);
      unint64_t v5 = v6;
      uint64_t v2 = *(void *)(a2 + 8);
      ++v6;
    }
    while (v5 < (*(void *)(a2 + 16) - v2) >> 3);
  }
}

void *sub_100CC9A2C(void *a1)
{
  *a1 = off_101A4E690;
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 != v3)
  {
    unint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      uint64_t v6 = *(void *)(v3 + 8 * v4);
      if (v6)
      {
        (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        uint64_t v3 = a1[1];
        uint64_t v2 = a1[2];
      }
      unint64_t v4 = v5++;
    }
    while (v4 < (v2 - v3) >> 3);
  }
  sub_1004DD39C((uint64_t)(a1 + 4));
  uint64_t v7 = (void *)a1[1];
  if (v7)
  {
    a1[2] = v7;
    operator delete(v7);
  }
  return a1;
}

void sub_100CC9AE4(uint64_t a1, uint64_t a2, char a3)
{
  if (a3) {
    goto LABEL_11;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  if (*(void *)(a1 + 16) == v5) {
    goto LABEL_11;
  }
  unint64_t v6 = 0;
  unsigned int v7 = 1;
  while (1)
  {
    uint64_t v8 = (const char *)(*(uint64_t (**)(void))(**(void **)(v5 + 8 * v6) + 64))(*(void *)(v5 + 8 * v6));
    long long v9 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
    if (!strcmp(v8, v9)) {
      break;
    }
    unint64_t v6 = v7;
    uint64_t v5 = *(void *)(a1 + 8);
    ++v7;
    if (v6 >= (*(void *)(a1 + 16) - v5) >> 3) {
      goto LABEL_11;
    }
  }
  if (!v7)
  {
LABEL_11:
    unint64_t v13 = *(void *)(a1 + 24);
    long long v14 = *(void **)(a1 + 16);
    if ((unint64_t)v14 >= v13)
    {
      uint64_t v16 = *(void *)(a1 + 8);
      uint64_t v17 = ((uint64_t)v14 - v16) >> 3;
      if ((unint64_t)(v17 + 1) >> 61) {
        sub_10006A748();
      }
      uint64_t v18 = v13 - v16;
      uint64_t v19 = v18 >> 2;
      if (v18 >> 2 <= (unint64_t)(v17 + 1)) {
        uint64_t v19 = v17 + 1;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v19;
      }
      if (v20) {
        uint64_t v21 = (char *)sub_10004EF74(a1 + 24, v20);
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v22 = &v21[8 * v17];
      int64_t v23 = &v21[8 * v20];
      *(void *)uint64_t v22 = a2;
      uint64_t v15 = v22 + 8;
      std::locale v25 = *(char **)(a1 + 8);
      unint64_t v24 = *(char **)(a1 + 16);
      if (v24 != v25)
      {
        do
        {
          uint64_t v26 = *((void *)v24 - 1);
          v24 -= 8;
          *((void *)v22 - 1) = v26;
          v22 -= 8;
        }
        while (v24 != v25);
        unint64_t v24 = *(char **)(a1 + 8);
      }
      *(void *)(a1 + 8) = v22;
      *(void *)(a1 + 16) = v15;
      *(void *)(a1 + 24) = v23;
      if (v24) {
        operator delete(v24);
      }
    }
    else
    {
      void *v14 = a2;
      uint64_t v15 = v14 + 1;
    }
    *(void *)(a1 + 16) = v15;
  }
  else
  {
    uint64_t v10 = v7 - 1;
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = *(void *)(v11 + 8 * v10);
    if (v12)
    {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
      uint64_t v11 = *(void *)(a1 + 8);
    }
    *(void *)(v11 + 8 * v10) = a2;
  }
  long long v27 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
  sub_100058DB0(__p, v27);
  unint64_t v28 = sub_100206390(a1 + 56, (uint64_t)__p);
  unint64_t v29 = v28;
  unint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v30);
    v31.i16[0] = vaddlv_u8(v31);
    unint64_t v32 = v31.u32[0];
    if (v31.u32[0] > 1uLL)
    {
      unint64_t v33 = v28;
      if (v28 >= v30) {
        unint64_t v33 = v28 % v30;
      }
    }
    else
    {
      unint64_t v33 = (v30 - 1) & v28;
    }
    uint64_t v34 = *(void ***)(*(void *)(a1 + 32) + 8 * v33);
    if (v34)
    {
      for (uint64_t i = *v34; i; uint64_t i = *(void **)i)
      {
        unint64_t v36 = *((void *)i + 1);
        if (v36 == v29)
        {
          if (sub_1000609C0(a1 + 64, (unsigned __int8 *)i + 16, (unsigned __int8 *)__p)) {
            goto LABEL_101;
          }
        }
        else
        {
          if (v32 > 1)
          {
            if (v36 >= v30) {
              v36 %= v30;
            }
          }
          else
          {
            v36 &= v30 - 1;
          }
          if (v36 != v33) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v33 = 0;
  }
  uint64_t v64 = 1;
  uint64_t i = operator new(0x30uLL);
  long long v37 = (void *)(a1 + 48);
  uint64_t v63 = a1 + 48;
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v29;
  *((_OWORD *)i + 1) = *(_OWORD *)__p;
  uint64_t v38 = v62;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v62 = 0;
  *((void *)i + 4) = v38;
  *((void *)i + 5) = 0;
  float v39 = (float)(unint64_t)(*(void *)(a1 + 56) + 1);
  float v40 = *(float *)(a1 + 64);
  if (!v30 || (float)(v40 * (float)v30) < v39)
  {
    BOOL v41 = 1;
    if (v30 >= 3) {
      BOOL v41 = (v30 & (v30 - 1)) != 0;
    }
    unint64_t v42 = v41 | (2 * v30);
    unint64_t v43 = vcvtps_u32_f32(v39 / v40);
    if (v42 <= v43) {
      int8x8_t prime = (int8x8_t)v43;
    }
    else {
      int8x8_t prime = (int8x8_t)v42;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v30 = *(void *)(a1 + 40);
    if (*(void *)&prime > v30) {
      goto LABEL_57;
    }
    if (*(void *)&prime < v30)
    {
      unint64_t v51 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 56) / *(float *)(a1 + 64));
      if (v30 < 3 || (uint8x8_t v52 = (uint8x8_t)vcnt_s8((int8x8_t)v30), v52.i16[0] = vaddlv_u8(v52), v52.u32[0] > 1uLL))
      {
        unint64_t v51 = std::__next_prime(v51);
      }
      else
      {
        uint64_t v53 = 1 << -(char)__clz(v51 - 1);
        if (v51 >= 2) {
          unint64_t v51 = v53;
        }
      }
      if (*(void *)&prime <= v51) {
        int8x8_t prime = (int8x8_t)v51;
      }
      if (*(void *)&prime >= v30)
      {
        unint64_t v30 = *(void *)(a1 + 40);
      }
      else
      {
        if (prime)
        {
LABEL_57:
          if (*(void *)&prime >> 61) {
            sub_10006A7CC();
          }
          long long v45 = operator new(8 * *(void *)&prime);
          long long v46 = *(void **)(a1 + 32);
          *(void *)(a1 + 32) = v45;
          if (v46) {
            operator delete(v46);
          }
          uint64_t v47 = 0;
          *(int8x8_t *)(a1 + 40) = prime;
          do
            *(void *)(*(void *)(a1 + 32) + 8 * v47++) = 0;
          while (*(void *)&prime != v47);
          long long v48 = (void *)*v37;
          if (*v37)
          {
            unint64_t v49 = v48[1];
            uint8x8_t v50 = (uint8x8_t)vcnt_s8(prime);
            v50.i16[0] = vaddlv_u8(v50);
            if (v50.u32[0] > 1uLL)
            {
              if (v49 >= *(void *)&prime) {
                v49 %= *(void *)&prime;
              }
            }
            else
            {
              v49 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)(a1 + 32) + 8 * v49) = v37;
            long long v54 = (void *)*v48;
            if (*v48)
            {
              do
              {
                unint64_t v55 = v54[1];
                if (v50.u32[0] > 1uLL)
                {
                  if (v55 >= *(void *)&prime) {
                    v55 %= *(void *)&prime;
                  }
                }
                else
                {
                  v55 &= *(void *)&prime - 1;
                }
                if (v55 != v49)
                {
                  uint64_t v56 = *(void *)(a1 + 32);
                  if (!*(void *)(v56 + 8 * v55))
                  {
                    *(void *)(v56 + 8 * v55) = v48;
                    goto LABEL_82;
                  }
                  *long long v48 = *v54;
                  *long long v54 = **(void **)(*(void *)(a1 + 32) + 8 * v55);
                  **(void **)(*(void *)(a1 + 32) + 8 * v55) = v54;
                  long long v54 = v48;
                }
                unint64_t v55 = v49;
LABEL_82:
                long long v48 = v54;
                long long v54 = (void *)*v54;
                unint64_t v49 = v55;
              }
              while (v54);
            }
          }
          unint64_t v30 = (unint64_t)prime;
          goto LABEL_86;
        }
        std::string v60 = *(void **)(a1 + 32);
        *(void *)(a1 + 32) = 0;
        if (v60) {
          operator delete(v60);
        }
        unint64_t v30 = 0;
        *(void *)(a1 + 40) = 0;
      }
    }
LABEL_86:
    if ((v30 & (v30 - 1)) != 0)
    {
      if (v29 >= v30) {
        unint64_t v33 = v29 % v30;
      }
      else {
        unint64_t v33 = v29;
      }
    }
    else
    {
      unint64_t v33 = (v30 - 1) & v29;
    }
  }
  uint64_t v57 = *(void *)(a1 + 32);
  uint64_t v58 = *(void **)(v57 + 8 * v33);
  if (v58)
  {
    *(void *)uint64_t i = *v58;
LABEL_99:
    *uint64_t v58 = i;
    goto LABEL_100;
  }
  *(void *)uint64_t i = *v37;
  *long long v37 = i;
  *(void *)(v57 + 8 * v33) = v37;
  if (*(void *)i)
  {
    unint64_t v59 = *(void *)(*(void *)i + 8);
    if ((v30 & (v30 - 1)) != 0)
    {
      if (v59 >= v30) {
        v59 %= v30;
      }
    }
    else
    {
      v59 &= v30 - 1;
    }
    uint64_t v58 = (void *)(*(void *)(a1 + 32) + 8 * v59);
    goto LABEL_99;
  }
LABEL_100:
  ++*(void *)(a1 + 56);
LABEL_101:
  *((void *)i + 5) = a2;
  if (SHIBYTE(v62) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100CCA0E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  sub_1009A3EB0(v16, v15);
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CCA11C(uint64_t a1, char *a2, uint64_t a3, char a4)
{
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v9 = sub_101306428(v8, a2);
  uint64_t v10 = v9;
  if (v9)
  {
    if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 16))(v9, a3))
    {
      sub_100CC9AE4(a1, v10, a4);
    }
    else
    {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      return 0;
    }
  }
  return v10;
}

void sub_100CCA1F8(void *a1, char *a2)
{
  uint64_t v2 = a1[1];
  if (v2 != a1[2])
  {
    for (uint64_t i = -v2; ; i -= 8)
    {
      unint64_t v6 = (const char *)(*(uint64_t (**)(void))(**(void **)v2 + 64))();
      int v7 = strcmp(v6, a2);
      uint64_t v8 = (void *)a1[2];
      if (!v7) {
        break;
      }
      v2 += 8;
      if ((void *)v2 == v8) {
        return;
      }
    }
    if ((void *)v2 != v8)
    {
      if (*(void *)v2)
      {
        (*(void (**)(void))(**(void **)v2 + 8))(*(void *)v2);
        uint64_t v8 = (void *)a1[2];
      }
      uint64_t v9 = -i;
      uint64_t v10 = (const void *)(8 - i);
      size_t v11 = (size_t)v8 - (8 - i);
      if (v11) {
        memmove((void *)v9, v10, v11);
      }
      a1[2] = v9 + v11;
      sub_100058DB0(__p, a2);
      sub_100CCA8E4(a1 + 4, (unsigned __int8 *)__p);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_100CCA314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CCA330(uint64_t a1, char *a2)
{
  uint64_t v2 = (void *)(a1 + 32);
  sub_100058DB0(__p, a2);
  uint64_t v3 = sub_1003DDE88(v2, (unsigned __int8 *)__p);
  unint64_t v4 = v3;
  if (v7 < 0)
  {
    operator delete(__p[0]);
    if (v4) {
      return *((void *)v4 + 5);
    }
  }
  else if (v3)
  {
    return *((void *)v4 + 5);
  }
  return 0;
}

void sub_100CCA394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CCA3B0(uint64_t a1, char *a2)
{
  uint64_t v2 = (void *)(a1 + 32);
  sub_100058DB0(__p, a2);
  uint64_t v3 = sub_1003DF000(v2, (unsigned __int8 *)__p);
  unint64_t v4 = v3;
  if (v7 < 0)
  {
    operator delete(__p[0]);
    if (v4) {
      return *((void *)v4 + 5);
    }
  }
  else if (v3)
  {
    return *((void *)v4 + 5);
  }
  return 0;
}

void sub_100CCA414(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CCA430(uint64_t a1, const char *a2, char **a3)
{
  a3[1] = *a3;
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(void *)(a1 + 16) != v3)
  {
    uint64_t v7 = 0;
    unsigned int v8 = 0;
    uint64_t v9 = (uint64_t)(a3 + 2);
    do
    {
      uint64_t v10 = (const char *)(*(uint64_t (**)(void))(**(void **)(v3 + 8 * v7) + 64))(*(void *)(v3 + 8 * v7));
      if (!strcmp(v10, a2))
      {
        uint64_t v11 = *(void *)(a1 + 8);
        char v13 = a3[1];
        unint64_t v12 = (unint64_t)a3[2];
        if ((unint64_t)v13 >= v12)
        {
          uint64_t v15 = (v13 - *a3) >> 3;
          if ((unint64_t)(v15 + 1) >> 61) {
            sub_10006A748();
          }
          uint64_t v16 = v12 - (void)*a3;
          uint64_t v17 = v16 >> 2;
          if (v16 >> 2 <= (unint64_t)(v15 + 1)) {
            uint64_t v17 = v15 + 1;
          }
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v18 = v17;
          }
          if (v18) {
            uint64_t v19 = (char *)sub_10004EF74(v9, v18);
          }
          else {
            uint64_t v19 = 0;
          }
          unint64_t v20 = &v19[8 * v15];
          *(void *)unint64_t v20 = *(void *)(v11 + 8 * v7);
          long long v14 = v20 + 8;
          uint64_t v22 = *a3;
          uint64_t v21 = a3[1];
          if (v21 != *a3)
          {
            do
            {
              uint64_t v23 = *((void *)v21 - 1);
              v21 -= 8;
              *((void *)v20 - 1) = v23;
              v20 -= 8;
            }
            while (v21 != v22);
            uint64_t v21 = *a3;
          }
          *a3 = v20;
          a3[1] = v14;
          a3[2] = &v19[8 * v18];
          if (v21) {
            operator delete(v21);
          }
        }
        else
        {
          *(void *)char v13 = *(void *)(v11 + 8 * v7);
          long long v14 = v13 + 8;
        }
        a3[1] = v14;
      }
      uint64_t v3 = *(void *)(a1 + 8);
      uint64_t v7 = ++v8;
    }
    while (v8 < (unint64_t)((*(void *)(a1 + 16) - v3) >> 3));
  }
}

void sub_100CCA5A0(uint64_t a1, char *a2)
{
  uint64_t v2 = 0;
  sub_10035F2D0(a2, &v2);
}

void sub_100CCA61C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CCA658(uint64_t a1, void *a2)
{
  if (*a2) {
    operator new();
  }
  return 0;
}

void sub_100CCA6F0()
{
}

uint64_t sub_100CCA714(uint64_t a1, char *a2)
{
  uint64_t result = sub_100CCA3B0(a1, a2);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 72);
    return v3();
  }
  return result;
}

std::string *sub_100CCA77C@<X0>(std::string *result@<X0>, int a2@<W1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  a4->__r_.__value_.__r.__words[0] = 0;
  a4->__r_.__value_.__l.__size_ = 0;
  a4->__r_.__value_.__r.__words[2] = 0;
  std::string::size_type size = result->__r_.__value_.__l.__size_;
  if (result->__r_.__value_.__r.__words[2] != size)
  {
    unsigned int v8 = result;
    unint64_t v9 = 0;
    unsigned int v10 = 1;
    do
    {
      uint64_t v11 = *(void *)(size + 8 * v9);
      uint64_t result = (std::string *)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 56))(v11);
      if (result == a2)
      {
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v11 + 48))(__p, v11, a3);
        if ((v15 & 0x80u) == 0) {
          unint64_t v12 = __p;
        }
        else {
          unint64_t v12 = (void **)__p[0];
        }
        if ((v15 & 0x80u) == 0) {
          std::string::size_type v13 = v15;
        }
        else {
          std::string::size_type v13 = (std::string::size_type)__p[1];
        }
        std::string::append(a4, (const std::string::value_type *)v12, v13);
        if ((char)v15 < 0) {
          operator delete(__p[0]);
        }
        uint64_t result = std::string::append(a4, "\n", 1uLL);
      }
      unint64_t v9 = v10;
      std::string::size_type size = v8->__r_.__value_.__l.__size_;
      ++v10;
    }
    while (v9 < (uint64_t)(v8->__r_.__value_.__r.__words[2] - size) >> 3);
  }
  return result;
}

void sub_100CCA8AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100CCA8E4(void *a1, unsigned __int8 *a2)
{
  uint64_t result = (uint64_t *)sub_1003DDE88(a1, a2);
  if (result)
  {
    sub_100CCA91C(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t sub_100CCA91C(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  sub_100136DD0(a1, a2, (uint64_t)&__p);
  uint64_t v3 = (void **)__p;
  std::string __p = 0;
  if (v3) {
    sub_1009A3EB0((uint64_t)&v6, v3);
  }
  return v2;
}

void *sub_100CCA968(void *a1, void *a2)
{
  sub_100058DB0(__p, "SilenceAssertion");
  sub_100DD14AC((uint64_t)a1, a2, (long long *)__p, "reg", 0);
  *a1 = off_101A4E738;
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101A4E6C8;
  return a1;
}

void sub_100CCAA0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CCAA28()
{
}

void sub_100CCAA94()
{
}

uint64_t sub_100CCAAB8()
{
  return 0;
}

void sub_100CCAAC0(uint64_t a1, void **a2, uint64_t *a3)
{
  char v6 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      unsigned int v8 = a3;
    }
    else {
      unsigned int v8 = (uint64_t *)*a3;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s is releasing its Silence assertion", buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 40));
  unsigned int v10 = ServiceMap;
  if (v11 < 0)
  {
    unint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v16 = 0;
  char v18 = 1;
LABEL_14:
  uint64_t v19 = *a2;
  xpc_object_t object = v19;
  if (v19) {
    xpc_retain(v19);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v17 + 32))(v17, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
}

void sub_100CCAC7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CCACC4(uint64_t a1, void **a2, void **a3, uint64_t *a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 40));
  unint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v10;
  unsigned int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_9:
  char v18 = *(NSObject **)(a1 + 32);
  BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  if (v16)
  {
    if (v19)
    {
      if (*((char *)a3 + 23) >= 0) {
        unint64_t v20 = a3;
      }
      else {
        unint64_t v20 = *a3;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s is taking its Silence assertion", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v21 = *a2;
    xpc_object_t v48 = v21;
    if (v21) {
      xpc_retain(v21);
    }
    else {
      xpc_object_t v48 = xpc_null_create();
    }
    std::string::size_type v35 = (std::__shared_weak_count *)a4[1];
    uint64_t v46 = *a4;
    uint64_t v47 = v35;
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*((char *)a3 + 23) < 0)
    {
      sub_10004FC84(__p, *a3, (unint64_t)a3[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a3;
      long long v45 = a3[2];
    }
    (*(void (**)(uint64_t, xpc_object_t *, uint64_t *, void **))(*(void *)v16 + 24))(v16, &v48, &v46, __p);
    if (SHIBYTE(v45) < 0) {
      operator delete(__p[0]);
    }
    if (v47) {
      sub_10004D2C8(v47);
    }
    xpc_release(v48);
    xpc_object_t v48 = 0;
    goto LABEL_57;
  }
  if (v19)
  {
    if (*((char *)a3 + 23) >= 0) {
      uint64_t v22 = a3;
    }
    else {
      uint64_t v22 = *a3;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v22;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s is taking its Silence assertion. Unable to get handle to controller", (uint8_t *)&buf, 0xCu);
  }
  xpc_object_t v42 = xpc_int64_create(45);
  if (!v42) {
    xpc_object_t v42 = xpc_null_create();
  }
  *(void *)&long long buf = *a4;
  *((void *)&buf + 1) = "kPosixError";
  sub_100035E70((uint64_t)&buf, &v42, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v42);
  xpc_object_t v42 = 0;
  unint64_t v24 = (std::mutex *)Registry::getServiceMap(v23, *(Registry **)(a1 + 40));
  std::locale v25 = v24;
  uint64_t v26 = "11CCXpcServer";
  if (((unint64_t)"11CCXpcServer" & 0x8000000000000000) != 0)
  {
    long long v27 = (unsigned __int8 *)((unint64_t)"11CCXpcServer" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v28 = 5381;
    do
    {
      uint64_t v26 = (const char *)v28;
      unsigned int v29 = *v27++;
      uint64_t v28 = (33 * v28) ^ v29;
    }
    while (v29);
  }
  std::mutex::lock(v24);
  *(void *)&long long buf = v26;
  unint64_t v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)&buf);
  if (v30)
  {
    uint64_t v32 = v30[3];
    uint8x8_t v31 = (std::__shared_weak_count *)v30[4];
    if (v31)
    {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v25);
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v31);
      char v33 = 0;
      if (!v32) {
        goto LABEL_30;
      }
LABEL_45:
      sub_100058DB0(v40, "SilenceAssertion");
      unint64_t v36 = *a2;
      xpc_object_t v39 = v36;
      if (v36) {
        xpc_retain(v36);
      }
      else {
        xpc_object_t v39 = xpc_null_create();
      }
      if (*((char *)a3 + 23) < 0)
      {
        sub_10004FC84(v37, *a3, (unint64_t)a3[1]);
      }
      else
      {
        *(_OWORD *)long long v37 = *(_OWORD *)a3;
        uint64_t v38 = a3[2];
      }
      sub_100C64FD0((long long *)v40, &v39, (long long *)v37, 0);
      if (SHIBYTE(v38) < 0) {
        operator delete(v37[0]);
      }
      xpc_release(v39);
      xpc_object_t v39 = 0;
      if (v41 < 0) {
        operator delete(v40[0]);
      }
      goto LABEL_55;
    }
  }
  else
  {
    uint64_t v32 = 0;
  }
  std::mutex::unlock(v25);
  uint8x8_t v31 = 0;
  char v33 = 1;
  if (v32) {
    goto LABEL_45;
  }
LABEL_30:
  uint64_t v34 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Silence Assertion response: cannot locate XPC server from reg. Not notifying assertion addition status", (uint8_t *)&buf, 2u);
  }
LABEL_55:
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v31);
  }
LABEL_57:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_100CCB114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, xpc_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,xpc_object_t a33)
{
  xpc_release(object);
  if (a22 < 0)
  {
    operator delete(__p);
    if (v35)
    {
LABEL_3:
      if (v36) {
LABEL_8:
      }
        _Unwind_Resume(a1);
LABEL_7:
      sub_10004D2C8(v33);
      goto LABEL_8;
    }
  }
  else if (v35)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v34);
  if (v36) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

void sub_100CCB210(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_100CCB24C(uint64_t a1)
{
  sub_100DD1644(a1);

  operator delete();
}

void sub_100CCB284(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100CCB304(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CCB340(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100CCB378(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100CCB3A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100CCB3EC()
{
}

void sub_100CCB7AC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, dispatch_object_t object, dispatch_object_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  if (v25) {
    dispatch_release(v25);
  }
  sub_100087F94(v24, *(void **)(v21 + 112));
  sub_100119D90(*(void **)(v21 + 88));
  uint64_t v26 = *(std::__shared_weak_count **)(v21 + 72);
  if (v26) {
    sub_10004D2C8(v26);
  }
  long long v27 = *(std::__shared_weak_count **)(v21 + 56);
  if (v27) {
    sub_10004D2C8(v27);
  }
  ctu::OsLogLogger::~OsLogLogger(v23);
  sub_100087E88(v22);
  NAISelectorMgrInterface::~NAISelectorMgrInterface((NAISelectorMgrInterface *)v21);
  operator delete();
}

void sub_100CCB94C(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_100CCBA4C@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = *(uint64_t **)(a1 + 88);
  uint64_t result = (uint64_t *)(a1 + 88);
  unint64_t v4 = v5;
  if (!v5) {
    goto LABEL_11;
  }
  char v6 = result;
  uint64_t v7 = v4;
  do
  {
    int v8 = *((_DWORD *)v7 + 8);
    BOOL v9 = v8 < a2;
    if (v8 >= a2) {
      uint64_t v10 = (uint64_t **)v7;
    }
    else {
      uint64_t v10 = (uint64_t **)(v7 + 1);
    }
    if (!v9) {
      char v6 = v7;
    }
    uint64_t v7 = *v10;
  }
  while (*v10);
  if (v6 != result && *((_DWORD *)v6 + 8) <= a2)
  {
    while (1)
    {
      while (1)
      {
        int v11 = *((_DWORD *)v4 + 8);
        if (v11 <= a2) {
          break;
        }
        unint64_t v4 = (uint64_t *)*v4;
        if (!v4) {
          goto LABEL_18;
        }
      }
      if (v11 >= a2) {
        break;
      }
      unint64_t v4 = (uint64_t *)v4[1];
      if (!v4) {
LABEL_18:
      }
        sub_1000C14F0("map::at:  key not found");
    }
    uint64_t v13 = v4[5];
    uint64_t v12 = v4[6];
    *a3 = v13;
    a3[1] = v12;
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

void sub_100CCBAF0(uint64_t a1, uint64_t a2)
{
  if ((rest::operator==() & 1) == 0)
  {
    unint64_t v4 = *(void **)(a1 + 104);
    if (v4 != (void *)(a1 + 112))
    {
      uint64_t v5 = (uint64_t *)(a2 + 8);
      while (1)
      {
        uint64_t v16 = 0;
        char v17 = 0;
        sub_100CCBA4C(a1, *((_DWORD *)v4 + 8), &v16);
        uint64_t v6 = v16;
        if (v16)
        {
          uint64_t v7 = *v5;
          if (!*v5) {
            goto LABEL_17;
          }
          int v8 = *((_DWORD *)v4 + 8);
          uint64_t v9 = a2 + 8;
          do
          {
            int v10 = *(_DWORD *)(v7 + 32);
            BOOL v11 = v10 < v8;
            if (v10 >= v8) {
              uint64_t v12 = (uint64_t *)v7;
            }
            else {
              uint64_t v12 = (uint64_t *)(v7 + 8);
            }
            if (!v11) {
              uint64_t v9 = v7;
            }
            uint64_t v7 = *v12;
          }
          while (*v12);
          if ((uint64_t *)v9 == v5 || v8 < *(_DWORD *)(v9 + 32)) {
            goto LABEL_17;
          }
          if ((rest::operator==() & 1) == 0) {
            break;
          }
        }
LABEL_18:
        if (v17) {
          sub_10004D2C8(v17);
        }
        uint64_t v13 = (void *)v4[1];
        if (v13)
        {
          do
          {
            unsigned int v14 = v13;
            uint64_t v13 = (void *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            unsigned int v14 = (void *)v4[2];
            BOOL v15 = *v14 == (void)v4;
            unint64_t v4 = v14;
          }
          while (!v15);
        }
        unint64_t v4 = v14;
        if (v14 == (void *)(a1 + 112)) {
          return;
        }
      }
      uint64_t v6 = v16;
LABEL_17:
      (*(void (**)(uint64_t, void *))(*(void *)v6 + 112))(v6, v4 + 5);
      goto LABEL_18;
    }
  }
}

void sub_100CCBC30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CCBC4C(void *a1)
{
  uint64_t v2 = (void *)a1[13];
  uint64_t v3 = a1 + 14;
  if (v2 != a1 + 14)
  {
    do
    {
      unint64_t v4 = a1[5];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = subscriber::asString();
        uint64_t v6 = asString();
        *(_DWORD *)long long buf = 136315394;
        uint64_t v15 = v5;
        __int16 v16 = 2080;
        uint64_t v17 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sim %s: Bundle technology type: %s", buf, 0x16u);
      }
      uint64_t v7 = (void *)v2[1];
      if (v7)
      {
        do
        {
          int v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (void *)v2[2];
          BOOL v9 = *v8 == (void)v2;
          uint64_t v2 = v8;
        }
        while (!v9);
      }
      uint64_t v2 = v8;
    }
    while (v8 != v3);
  }
  int v10 = (void *)a1[10];
  BOOL v11 = a1 + 11;
  if (v10 != v11)
  {
    do
    {
      (*(void (**)(void))(*(void *)v10[5] + 120))(v10[5]);
      uint64_t v12 = (void *)v10[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v10[2];
          BOOL v9 = *v13 == (void)v10;
          int v10 = v13;
        }
        while (!v9);
      }
      int v10 = v13;
    }
    while (v13 != v11);
  }
}

void sub_100CCBDE8(uint64_t a1)
{
  *(void *)a1 = off_101A4E7F0;
  sub_100087F94(a1 + 104, *(void **)(a1 + 112));
  sub_100119D90(*(void **)(a1 + 88));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  NAISelectorMgrInterface::~NAISelectorMgrInterface((NAISelectorMgrInterface *)a1);
}

void sub_100CCBE74(uint64_t a1)
{
  *(void *)a1 = off_101A4E7F0;
  sub_100087F94(a1 + 104, *(void **)(a1 + 112));
  sub_100119D90(*(void **)(a1 + 88));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  NAISelectorMgrInterface::~NAISelectorMgrInterface((NAISelectorMgrInterface *)a1);

  operator delete();
}

void sub_100CCBF18(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100CCBF50(uint64_t a1)
{
}

uint64_t sub_100CCBF6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100CCBFB0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100CCBFDC(ServiceManager::Service *this)
{
  *(void *)this = off_101A4E920;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100CCC038(ServiceManager::Service *this)
{
  *(void *)this = off_101A4E920;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100CCC0A8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "NAISelectorMgr");
}

unsigned char *sub_100CCC0B8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100CCC0F8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100CCB94C(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100CCB94C(v4, 0);
}

uint64_t sub_100CCC17C()
{
  return 0;
}

uint64_t sub_100CCC184()
{
  return 1;
}

uint64_t sub_100CCC18C()
{
  return 0;
}

void sub_100CCC19C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_100CCC2B0(uint64_t *result, int a2, int a3, uint64_t a4)
{
  uint64_t v6 = result;
  int v8 = (uint64_t **)(result + 1);
  uint64_t v7 = result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        BOOL v9 = (void *)v7;
        int v10 = *(_DWORD *)(v7 + 32);
        if (v10 <= a2) {
          break;
        }
        uint64_t v7 = *v9;
        int v8 = (uint64_t **)v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        int v8 = (uint64_t **)(v9 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v9 = result + 1;
LABEL_9:
    BOOL v11 = (char *)operator new(0x38uLL);
    *((_DWORD *)v11 + 8) = a3;
    *(_OWORD *)(v11 + 40) = *(_OWORD *)a4;
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)BOOL v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v9;
    void *v8 = (uint64_t *)v11;
    uint64_t v12 = *(void *)*v6;
    if (v12)
    {
      *uint64_t v6 = v12;
      uint64_t v13 = *v8;
    }
    else
    {
      uint64_t v13 = (uint64_t *)v11;
    }
    uint64_t result = sub_100046C90((uint64_t *)v6[1], v13);
    ++v6[2];
  }
  return result;
}

uint64_t *sub_100CCC380(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection(&v8, *(Registry **)(*(void *)v1 + 48));
  ctu::RestModule::connect();
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  uint64_t v3 = operator new(0x28uLL);
  void *v3 = off_101A4E9A0;
  v3[1] = v2 + 104;
  std::locale v3[2] = v2;
  v3[3] = sub_100CCBAF0;
  v3[4] = 0;
  uint64_t v13 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v12);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = off_101A4EA20;
  v4[1] = v2;
  v4[2] = sub_100CCBC4C;
  v4[3] = 0;
  uint64_t v13 = v4;
  ctu::RestModule::observeEvent();
  sub_10003F600(v12);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  sub_100088C88(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100CCC504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100CCC568()
{
}

__n128 sub_100CCC57C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4E9A0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CCC5D0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4E9A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100CCC608(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  BOOL v9 = (void **)*v3;
  int v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    std::locale v3[2] = 0;
  }
  else
  {
    BOOL v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100CCC6C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100CCC6E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CCC720()
{
}

void sub_100CCC730()
{
}

__n128 sub_100CCC744(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A4EA20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100CCC798(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4EA20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CCC7D0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100CCC818(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CCC858()
{
}

uint64_t *sub_100CCC864(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 64));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100CCC8AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100CCC8C8(uint64_t *a1@<X0>, void *a2@<X8>)
{
  id v9 = +[NSMutableArray arrayWithCapacity:a1[1] - *a1];
  uint64_t v4 = *a1;
  if (a1[1] != *a1)
  {
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = +[NSNumber numberWithChar:*(char *)(v4 + v5)];
      [v9 insertObject:v6 atIndex:v5];

      ++v5;
      uint64_t v4 = *a1;
    }
    while (v5 < a1[1] - *a1);
  }
  uint64_t v7 = +[NSString stringWithUTF8String:"CellularPlanHelper"];
  uint64_t v8 = +[NSDictionary dictionaryWithObject:v9 forKey:v7];

  sub_10004EFAC(a2, v8);
}

void sub_100CCC9D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100CCCA04(id *a1@<X0>, void *a2@<X8>)
{
  if (*a1) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    id v9 = *a1;
    uint64_t v4 = +[NSString stringWithUTF8String:"CellularPlanHelper"];
    unint64_t v5 = [v9 objectForKey:v4];

    if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      id v6 = v5;
      a2[1] = 0;
      a2[2] = 0;
      *a2 = 0;
      sub_10008E4E8(a2, (size_t)[v6 count]);
      for (unint64_t i = 0; i < (unint64_t)[v6 count]; ++i)
      {
        uint64_t v8 = [v6 objectAtIndexedSubscript:i];
        *(unsigned char *)(*a2 + i) = [v8 charValue];
      }
    }
    else
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
}

void sub_100CCCB60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100CCCBBC(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  id v19 = +[NSMutableArray arrayWithCapacity:0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 3)];
  if (a1[1] != *a1)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      int v10 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
      [v19 insertObject:v10 atIndex:v9];

      ++v9;
      v8 += 24;
    }
    while (v9 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 3));
  }
  id v11 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v12 = +[NSString stringWithUTF8String:"CellularPlanHelper"];
  [v11 setObject:v19 forKeyedSubscript:v12];

  if (*((char *)a2 + 23) >= 0) {
    uint64_t v13 = a2;
  }
  else {
    uint64_t v13 = (uint64_t *)*a2;
  }
  unsigned int v14 = +[NSString stringWithUTF8String:v13];
  uint64_t v15 = +[NSString stringWithUTF8String:"kEid"];
  [v11 setObject:v14 forKeyedSubscript:v15];

  if (*((char *)a3 + 23) >= 0) {
    __int16 v16 = a3;
  }
  else {
    __int16 v16 = (uint64_t *)*a3;
  }
  uint64_t v17 = +[NSString stringWithUTF8String:v16];
  char v18 = +[NSString stringWithUTF8String:"kIMEI"];
  [v11 setObject:v17 forKeyedSubscript:v18];

  sub_10004EFAC(a4, v11);
}

void sub_100CCCDA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100CCCE14(id *a1@<X0>, uint64_t a2@<X8>)
{
  if (*a1) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    id v4 = *a1;
    unint64_t v5 = +[NSString stringWithUTF8String:"CellularPlanHelper"];
    id v6 = [v4 objectForKey:v5];

    if (v6 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      id v7 = v6;
      id v19 = 0;
      unint64_t v20 = 0;
      uint64_t v21 = 0;
      sub_100CC3120(&v19, (unint64_t)[v7 count]);
      uint64_t v8 = 0;
      for (unint64_t i = 0; i < (unint64_t)[v7 count]; ++i)
      {
        id v10 = [v7 objectAtIndexedSubscript:i];
        id v11 = (char *)[v10 UTF8String];
        sub_10003ED78((std::string *)((char *)v19 + v8), v11);

        v8 += 24;
      }
      uint64_t v12 = +[NSString stringWithUTF8String:"kEid"];
      id v6 = [v4 objectForKey:v12];

      if (v6 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        v17[0] = 0;
        v17[1] = 0;
        uint64_t v18 = 0;
        id v13 = v6;
        sub_100058DB0(v17, (char *)[v13 UTF8String]);
        memset(&__p, 0, sizeof(__p));
        unsigned int v14 = +[NSString stringWithUTF8String:"kIMEI"];
        id v6 = [v4 objectForKey:v14];

        if (v6)
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass()) {
            sub_10003ED78(&__p, (char *)[v6 UTF8String]);
          }
        }
        *(void *)a2 = 0;
        *(void *)(a2 + 8) = 0;
        *(void *)(a2 + 16) = 0;
        sub_1000302C0((char *)a2, v19, v20, 0xAAAAAAAAAAAAAAABLL * (((char *)v20 - (char *)v19) >> 3));
        if (SHIBYTE(v18) < 0)
        {
          sub_10004FC84((unsigned char *)(a2 + 24), v17[0], (unint64_t)v17[1]);
        }
        else
        {
          *(_OWORD *)(a2 + 24) = *(_OWORD *)v17;
          *(void *)(a2 + 40) = v18;
        }
        uint64_t v15 = (unsigned char *)(a2 + 48);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84(v15, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          *(_OWORD *)uint64_t v15 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(void *)(a2 + 64) = *((void *)&__p.__r_.__value_.__l + 2);
        }
        if (SHIBYTE(v18) < 0) {
          operator delete(v17[0]);
        }
      }
      else
      {
        *(void *)a2 = 0;
        *(void *)(a2 + 8) = 0;
        *(void *)(a2 + 16) = 0;
        sub_1000302C0((char *)a2, v19, v20, 0xAAAAAAAAAAAAAAABLL * (((char *)v20 - (char *)v19) >> 3));
        *(_OWORD *)(a2 + 56) = 0u;
        *(_OWORD *)(a2 + 40) = 0u;
        *(_OWORD *)(a2 + 24) = 0u;
      }
      v17[0] = &v19;
      sub_100047F64((void ***)v17);
    }
    else
    {
      *(void *)(a2 + 64) = 0;
      *(_OWORD *)(a2 + 32) = 0u;
      *(_OWORD *)(a2 + 48) = 0u;
      *(_OWORD *)a2 = 0u;
      *(_OWORD *)(a2 + 16) = 0u;
    }
  }
  else
  {
    *(void *)(a2 + 64) = 0;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
}

void sub_100CCD158(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  if (*(char *)(v26 + 47) < 0) {
    operator delete(*v28);
  }
  a24 = v26;
  sub_100047F64((void ***)&a24);
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  a15 = &a21;
  sub_100047F64((void ***)&a15);

  _Unwind_Resume(a1);
}

uint64_t sub_100CCD240(CFDataRef *a1)
{
  *(void *)buffer = 0;
  uint64_t v6 = 0;
  CFDataRef v2 = *a1;
  if (v2) {
    uint64_t v3 = sub_10008324C;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!v3 || CFDataGetLength(v2) != 16) {
    return 0;
  }
  v7.location = 0;
  v7.length = 16;
  CFDataGetBytes(*a1, v7, buffer);
  return *(void *)buffer;
}

uint64_t sub_100CCD2E8()
{
  return 0;
}

uint64_t sub_100CCD35C()
{
  return 0;
}

void sub_100CCD44C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100CCD468@<X0>(void *result@<X0>, char *a2@<X8>)
{
  CFDataRef v2 = a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  if (*((char *)result + 23) < 0)
  {
    __n128 result = sub_10004FC84(a2, *(void **)result, *((void *)result + 1));
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)result;
    *((void *)a2 + 2) = *((void *)result + 2);
  }
  uint64_t v3 = v2[23];
  if ((v3 & 0x80u) == 0) {
    id v4 = &v2[v3];
  }
  else {
    id v4 = (char *)(*(void *)v2 + *((void *)v2 + 1));
  }
  if ((v3 & 0x80u) == 0) {
    unint64_t v5 = v2;
  }
  else {
    unint64_t v5 = *(char **)v2;
  }
  if (v5 != v4)
  {
    do
    {
      __n128 result = (void *)__tolower(*v5);
      *v5++ = (char)result;
    }
    while (v5 != v4);
    LODWORD(v3) = v2[23];
  }
  if ((v3 & 0x80) != 0)
  {
    unint64_t v6 = *((void *)v2 + 1);
    if (v6 > 0x13)
    {
      CFRange v7 = *(char **)v2;
      if (*(unsigned char *)(*(void *)v2 + v6 - 1) == 102)
      {
        *((void *)v2 + 1) = 19;
        CFDataRef v2 = v7;
        goto LABEL_20;
      }
    }
  }
  else if (v3 > 0x13 && v2[v3 - 1] == 102)
  {
    v2[23] = 19;
LABEL_20:
    v2[19] = 0;
  }
  return result;
}

void sub_100CCD558(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CCD574(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 23);
  if ((v1 & 0x80u) != 0) {
    uint64_t v1 = *(void *)(a1 + 8);
  }
  if (v1)
  {
    long long v5 = 0u;
    long long v6 = 0u;
    *(_OWORD *)&v3[0].__locale_ = 0u;
    long long v4 = 0u;
    sub_10056D028(v3, "^v:1_t:[0-9]_s:[0-9]", 0);
  }
  return 0;
}

void sub_100CCD8A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::locale a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::locale a31)
{
  if (__p) {
    operator delete(__p);
  }
  sub_100155138(&a23);
  sub_100155138(&a31);
  _Unwind_Resume(a1);
}

uint64_t sub_100CCD910@<X0>(uint64_t result@<X0>, _DWORD **a2@<X1>, char *a3@<X8>)
{
  for (unint64_t i = *a2; ; i += 42)
  {
    if (i == a2[1])
    {
      char v6 = 0;
      goto LABEL_7;
    }
    if (*i == result) {
      break;
    }
  }
  *a3 = 0;
  __n128 result = sub_10002E664((uint64_t)(a3 + 8), (uint64_t)i);
  char v6 = 1;
LABEL_7:
  *a3 = v6;
  return result;
}

unint64_t sub_100CCD974(unsigned __int8 **a1, uint64_t *a2)
{
  int v2 = *((char *)a1 + 23);
  if (v2 >= 0) {
    uint64_t v3 = (unsigned __int8 *)*((unsigned __int8 *)a1 + 23);
  }
  else {
    uint64_t v3 = a1[1];
  }
  if (!v3) {
    goto LABEL_24;
  }
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    if (v2 >= 0) {
      char v6 = (unsigned __int8 *)a1;
    }
    else {
      char v6 = *a1;
    }
    do
    {
      uint64_t v7 = *(unsigned __int8 *)(v4 + 95);
      if ((v7 & 0x80u) == 0) {
        uint64_t v8 = (unsigned __int8 *)*(unsigned __int8 *)(v4 + 95);
      }
      else {
        uint64_t v8 = *(unsigned __int8 **)(v4 + 80);
      }
      if (v8 == v3)
      {
        if ((v7 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v4 + 72), v6, *(void *)(v4 + 80))) {
            goto LABEL_22;
          }
        }
        else
        {
          if (!*(unsigned char *)(v4 + 95)) {
            goto LABEL_22;
          }
          uint64_t v9 = 0;
          while (*(unsigned __int8 *)(v4 + v9 + 72) == v6[v9])
          {
            if (v7 == ++v9) {
              goto LABEL_22;
            }
          }
        }
      }
      v4 += 168;
    }
    while (v4 != v5);
    goto LABEL_24;
  }
LABEL_22:
  if (v4 == v5)
  {
LABEL_24:
    int v11 = 0;
    uint64_t v12 = 0;
    unsigned int v10 = 0;
    return (unint64_t)v12 | v10 | v11;
  }
  unsigned int v10 = *(_DWORD *)v4 & 0xFFFFFF00;
  int v11 = *(_DWORD *)v4;
  uint64_t v12 = &_mh_execute_header;
  return (unint64_t)v12 | v10 | v11;
}

void sub_100CCDA64(ctu *this@<X0>, const std::string *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  memset(&__str, 0, sizeof(__str));
  if (*(_OWORD *)this != 0)
  {
    ctu::hex((uint64_t *)v20, this, (const void *)0x10, a3);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    std::string __str = *(std::string *)v20;
    goto LABEL_16;
  }
  if (*((unsigned char *)this + 16))
  {
    uint64_t v10 = *((unsigned __int8 *)this + 47);
    if ((v10 & 0x80u) != 0) {
      uint64_t v10 = *((void *)this + 4);
    }
    if (v10)
    {
      int v11 = (const std::string *)((char *)this + 24);
LABEL_15:
      std::string::operator=(&__str, v11);
      goto LABEL_16;
    }
  }
  if (*((unsigned char *)this + 48))
  {
    uint64_t v12 = *((unsigned __int8 *)this + 79);
    if ((v12 & 0x80u) != 0) {
      uint64_t v12 = *((void *)this + 8);
    }
    if (v12)
    {
      int v11 = (const std::string *)((char *)this + 56);
      goto LABEL_15;
    }
  }
LABEL_16:
  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  char v14 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    long long v25 = 0u;
    long long v26 = 0u;
    memset(v24, 0, sizeof(v24));
    memset(v23, 0, sizeof(v23));
    long long v21 = 0u;
    long long v22 = 0u;
    memset(v20, 0, sizeof(v20));
    BYTE9(v26) = 1;
    *(void *)unint64_t v20 = CFAbsoluteTimeGetCurrent();
    std::string::operator=((std::string *)&v20[8], &__str);
    std::string::operator=((std::string *)&v21, (const std::string *)((char *)this + 80));
    std::string::operator=(v23, a2);
    BYTE9(v22) = 1;
    BYTE8(v22) = *((unsigned char *)this + 104);
    if (*((unsigned char *)this + 112)) {
      std::string::operator=(v24, (const std::string *)this + 5);
    }
    if (*(unsigned char *)a3) {
      std::string::operator=(&v24[1], (const std::string *)(a3 + 8));
    }
    if (*(unsigned char *)a4) {
      std::string::operator=((std::string *)&v25, (const std::string *)(a4 + 8));
    }
    *(void *)a5 = *(void *)v20;
    *(_OWORD *)(a5 + 8) = *(_OWORD *)&v20[8];
    *(void *)(a5 + 24) = *(void *)&v20[24];
    memset(&v20[8], 0, 24);
    *(_OWORD *)(a5 + 32) = v21;
    *(void *)(a5 + 48) = v22;
    long long v21 = 0uLL;
    *(void *)&long long v22 = 0;
    *(_WORD *)(a5 + 56) = WORD4(v22);
    long long v15 = *(_OWORD *)&v23[0].__r_.__value_.__l.__data_;
    *(void *)(a5 + 80) = *((void *)&v23[0].__r_.__value_.__l + 2);
    *(_OWORD *)(a5 + 64) = v15;
    memset(v23, 0, 24);
    long long v16 = *(_OWORD *)&v23[1].__r_.__value_.__l.__data_;
    *(void *)(a5 + 104) = *((void *)&v23[1].__r_.__value_.__l + 2);
    *(_OWORD *)(a5 + 88) = v16;
    *(_OWORD *)&v23[1].__r_.__value_.__l.__data_ = 0uLL;
    long long v17 = *(_OWORD *)&v24[0].__r_.__value_.__l.__data_;
    *(void *)(a5 + 128) = *((void *)&v24[0].__r_.__value_.__l + 2);
    *(_OWORD *)(a5 + 112) = v17;
    v23[1].__r_.__value_.__r.__words[2] = 0;
    memset(v24, 0, 24);
    long long v18 = *(_OWORD *)&v24[1].__r_.__value_.__l.__data_;
    *(void *)(a5 + 152) = *((void *)&v24[1].__r_.__value_.__l + 2);
    *(_OWORD *)(a5 + 136) = v18;
    *(_OWORD *)&v24[1].__r_.__value_.__l.__data_ = 0uLL;
    long long v19 = v25;
    *(void *)(a5 + 176) = v26;
    *(_OWORD *)(a5 + 160) = v19;
    v24[1].__r_.__value_.__r.__words[2] = 0;
    long long v25 = 0uLL;
    *(void *)&long long v26 = 0;
    *(_WORD *)(a5 + 184) = WORD4(v26);
    *(unsigned char *)(a5 + 192) = 1;
    if ((*((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x80) != 0) {
      goto LABEL_26;
    }
  }
  else
  {
    *(unsigned char *)a5 = 0;
    *(unsigned char *)(a5 + 192) = 0;
    if (v14 < 0) {
LABEL_26:
    }
      operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_100CCDD38(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 105) < 0) {
    operator delete(*(void **)(v1 - 128));
  }
  _Unwind_Resume(exception_object);
}

void sub_100CCDD68(ctu *this@<X0>, const std::string *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  memset(&__str, 0, sizeof(__str));
  if (*(_OWORD *)this == 0)
  {
    uint64_t v10 = *((unsigned __int8 *)this + 39);
    if ((v10 & 0x80u) != 0) {
      uint64_t v10 = *((void *)this + 3);
    }
    if (v10) {
      std::string::operator=(&__str, (const std::string *)((char *)this + 16));
    }
  }
  else
  {
    ctu::hex((uint64_t *)v21, this, (const void *)0x10, a3);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    std::string __str = *(std::string *)v21;
  }
  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  char v12 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    long long v26 = 0u;
    long long v27 = 0u;
    memset(v25, 0, sizeof(v25));
    memset(v24, 0, sizeof(v24));
    long long v22 = 0u;
    long long v23 = 0u;
    memset(v21, 0, sizeof(v21));
    BYTE9(v27) = 1;
    *(void *)long long v21 = CFAbsoluteTimeGetCurrent();
    std::string::operator=((std::string *)&v21[8], &__str);
    std::string::operator=((std::string *)&v22, (const std::string *)((char *)this + 40));
    std::string::operator=(v24, (const std::string *)this + 3);
    std::string::size_type v13 = HIBYTE(v24[0].__r_.__value_.__r.__words[2]);
    if ((v24[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v13 = v24[0].__r_.__value_.__l.__size_;
    }
    if (!v13 && a2[1].__r_.__value_.__s.__data_[0]) {
      std::string::operator=(v24, a2);
    }
    WORD4(v23) = *((_WORD *)this + 32);
    std::string::operator=(v25, (const std::string *)this + 4);
    std::string::operator=(&v25[1], (const std::string *)this + 5);
    std::string::size_type v14 = HIBYTE(v25[1].__r_.__value_.__r.__words[2]);
    if ((v25[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v14 = v25[1].__r_.__value_.__l.__size_;
    }
    if (!v14 && *(unsigned char *)a3) {
      std::string::operator=(&v25[1], (const std::string *)(a3 + 8));
    }
    std::string::operator=((std::string *)&v26, (const std::string *)this + 6);
    uint64_t v15 = BYTE7(v27);
    if (SBYTE7(v27) < 0) {
      uint64_t v15 = *((void *)&v26 + 1);
    }
    if (!v15)
    {
      if (*(unsigned char *)a4) {
        std::string::operator=((std::string *)&v26, (const std::string *)(a4 + 8));
      }
    }
    *(void *)a5 = *(void *)v21;
    *(_OWORD *)(a5 + 8) = *(_OWORD *)&v21[8];
    *(void *)(a5 + 24) = *(void *)&v21[24];
    memset(&v21[8], 0, 24);
    *(_OWORD *)(a5 + 32) = v22;
    *(void *)(a5 + 48) = v23;
    long long v22 = 0uLL;
    *(void *)&long long v23 = 0;
    *(_WORD *)(a5 + 56) = WORD4(v23);
    long long v16 = *(_OWORD *)&v24[0].__r_.__value_.__l.__data_;
    *(void *)(a5 + 80) = *((void *)&v24[0].__r_.__value_.__l + 2);
    *(_OWORD *)(a5 + 64) = v16;
    memset(v24, 0, 24);
    long long v17 = *(_OWORD *)&v24[1].__r_.__value_.__l.__data_;
    *(void *)(a5 + 104) = *((void *)&v24[1].__r_.__value_.__l + 2);
    *(_OWORD *)(a5 + 88) = v17;
    memset(&v24[1], 0, sizeof(std::string));
    long long v18 = *(_OWORD *)&v25[0].__r_.__value_.__l.__data_;
    *(void *)(a5 + 128) = *((void *)&v25[0].__r_.__value_.__l + 2);
    *(_OWORD *)(a5 + 112) = v18;
    memset(v25, 0, 24);
    long long v19 = *(_OWORD *)&v25[1].__r_.__value_.__l.__data_;
    *(void *)(a5 + 152) = *((void *)&v25[1].__r_.__value_.__l + 2);
    *(_OWORD *)(a5 + 136) = v19;
    memset(&v25[1], 0, sizeof(std::string));
    long long v20 = v26;
    *(void *)(a5 + 176) = v27;
    *(_OWORD *)(a5 + 160) = v20;
    long long v26 = 0uLL;
    *(void *)&long long v27 = 0;
    *(_WORD *)(a5 + 184) = WORD4(v27);
    *(unsigned char *)(a5 + 192) = 1;
    if ((*((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x80) != 0) {
      goto LABEL_28;
    }
  }
  else
  {
    *(unsigned char *)a5 = 0;
    *(unsigned char *)(a5 + 192) = 0;
    if (v12 < 0) {
LABEL_28:
    }
      operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_100CCE080(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 105) < 0) {
    operator delete(*(void **)(v1 - 128));
  }
  _Unwind_Resume(exception_object);
}

void sub_100CCE0B0(uint64_t *a1@<X0>, void *a2@<X8>)
{
  id v3 = objc_alloc_init((Class)NSMutableArray);
  uint64_t v4 = *a1;
  id cf = v3;
  uint64_t v60 = a1[1];
  if (*a1 != v60)
  {
    do
    {
      if (*(char *)(v4 + 687) < 0)
      {
        if (!*(void *)(v4 + 672))
        {
LABEL_10:
          std::string v61 = 0;
          goto LABEL_11;
        }
      }
      else if (!*(unsigned char *)(v4 + 687))
      {
        goto LABEL_10;
      }
      sub_100CD6B88((const void **)(v4 + 664), v4 + 688, (uint64_t)__p);
      if ((SBYTE7(v63) & 0x80u) == 0) {
        uint64_t v5 = __p;
      }
      else {
        uint64_t v5 = (void **)__p[0];
      }
      std::string v61 = +[NSString stringWithUTF8String:v5];
      if (SBYTE7(v63) < 0) {
        operator delete(__p[0]);
      }
LABEL_11:
      id v6 = objc_alloc((Class)CTUserLabel);
      uint64_t v7 = (void *)(v4 + 736);
      if (*(char *)(v4 + 759) < 0) {
        uint64_t v7 = (void *)*v7;
      }
      uint64_t v8 = +[NSString stringWithUTF8String:v7];
      uint64_t v9 = (void *)(v4 + 712);
      if (*(char *)(v4 + 735) < 0) {
        uint64_t v9 = (void *)*v9;
      }
      uint64_t v10 = +[NSString stringWithUTF8String:v9];
      int v11 = (void *)(v4 + 760);
      if (*(char *)(v4 + 783) < 0) {
        int v11 = (void *)*v11;
      }
      char v12 = +[NSString stringWithUTF8String:v11];
      id v13 = [v6 initWithKey:v8 label:v10 labelId:v12];

      std::string::size_type v14 = +[NSString stringWithFormat:@"%u", *(unsigned int *)(v4 + 816)];
      uint64_t v15 = (void *)(v4 + 584);
      if (*(char *)(v4 + 607) < 0) {
        uint64_t v15 = (void *)*v15;
      }
      long long v16 = +[NSString stringWithUTF8String:v15];
      if (*(unsigned char *)v4)
      {
        long long v17 = (void *)(v4 + 32);
        if (*(char *)(v4 + 55) < 0)
        {
          if (!*(void *)(v4 + 40)) {
            goto LABEL_43;
          }
          long long v17 = (void *)*v17;
        }
        else if (!*(unsigned char *)(v4 + 55))
        {
LABEL_43:
          long long v37 = 0;
          goto LABEL_44;
        }
        long long v37 = +[NSString stringWithUTF8String:v17];
LABEL_44:
        id v38 = objc_alloc((Class)CTCellularPlanItem);
        if (!*(unsigned char *)v4) {
          __assert_rtn("operator->", "optional.hpp", 1221, "this->is_initialized()");
        }
        xpc_object_t v39 = v38;
        float v40 = (void *)(v4 + 8);
        if (*(char *)(v4 + 31) < 0) {
          float v40 = (void *)*v40;
        }
        char v41 = +[NSString stringWithUTF8String:v40];
        if (*(unsigned __int8 *)(v4 + 580) - 1 < 5) {
          uint64_t v42 = (*(unsigned char *)(v4 + 580) - 1) + 1;
        }
        else {
          uint64_t v42 = 0;
        }
        int v43 = *(_DWORD *)(v4 + 576);
        BOOL v44 = v43 == 1;
        BOOL v32 = v43 == 2;
        uint64_t v45 = 2;
        if (!v32) {
          uint64_t v45 = v44;
        }
        LOBYTE(v56) = *(unsigned char *)(v4 + 569);
        id v35 = [v39 initWithIccid:v41 uuid:v14 name:v37 phoneNumber:v61 label:v13 isLocalTransferToeSIMSupported:*(unsigned __int8 *)(v4 + 568) isTransferred:v56 transferredStatus:v42 transferredToDeviceDisplayName:v16 supportedTransferOption:*(unsigned int *)(v4 + 572) settingsMode:v45];

        goto LABEL_57;
      }
      if (*(unsigned char *)(v4 + 128))
      {
        uint64_t v75 = 0;
        long long v73 = 0u;
        long long v74 = 0u;
        long long v71 = 0u;
        long long v72 = 0u;
        long long v69 = 0u;
        long long v70 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v63 = 0u;
        long long v64 = 0u;
        *(_OWORD *)std::string __p = 0u;
        sub_1000C5AB4((uint64_t)__p, v4 + 136);
        if (!*(unsigned char *)(v4 + 128)) {
          __assert_rtn("operator->", "optional.hpp", 1221, "this->is_initialized()");
        }
        long long v18 = sub_100CCE930((int *)(v4 + 352));
        if (!*(unsigned char *)(v4 + 128)) {
          __assert_rtn("operator->", "optional.hpp", 1221, "this->is_initialized()");
        }
        int v19 = *(unsigned __int8 *)(v4 + 552);
        id v20 = objc_alloc((Class)CTCellularPlanProfile);
        long long v21 = +[NSData dataWithBytes:__p length:16];
        if ((SBYTE7(v64) & 0x80u) == 0) {
          long long v22 = &v63;
        }
        else {
          long long v22 = (long long *)v63;
        }
        long long v23 = +[NSString stringWithUTF8String:v22];
        LOBYTE(v56) = v19 != 0;
        id v24 = [v20 initWithProfileId:v21 iccid:v23 selected:BYTE9(v67) bootstrap:BYTE8(v67) disableNotAllowed:BYTE11(v67) deleteNotAllowed:BYTE10(v67) requiresUserConsent:v56];

        id v25 = [objc_alloc((Class)CTCellularPlan) initWithProfile:v24 subscription:v18];
        id v26 = objc_alloc((Class)CTCellularPlanItem);
        uint64_t v27 = (*(_DWORD *)(v4 + 656) - 1);
        if (v27 < 3) {
          uint64_t v28 = v27 + 1;
        }
        else {
          uint64_t v28 = 0;
        }
        if (*(unsigned __int8 *)(v4 + 580) - 1 < 5) {
          uint64_t v29 = (*(unsigned char *)(v4 + 580) - 1) + 1;
        }
        else {
          uint64_t v29 = 0;
        }
        int v30 = *(_DWORD *)(v4 + 576);
        BOOL v31 = v30 == 1;
        BOOL v32 = v30 == 2;
        uint64_t v33 = 2;
        if (!v32) {
          uint64_t v33 = v31;
        }
        id v34 = [v26 initWithCellularPlan:v25 uuid:v14 type:v28 phoneNumber:v61 label:v13 transferredStatus:v29 transferredToDeviceDisplayName:v16 supportedTransferOption:*(unsigned int *)(v4 + 572) settingsMode:v33];
        id v35 = v34;
        int v36 = *(_DWORD *)(v4 + 820);
        if (*(unsigned char *)(v4 + 562) && v36 == 1)
        {
          [v34 setShouldAppearDisabled:1];
        }
        else if (v36 == 12)
        {
          [v34 setShouldDisplay:0];
        }

        sub_1000C584C((uint64_t)__p);
      }
      else
      {
        id v35 = 0;
      }
LABEL_57:
      [v35 setStatus:*(unsigned int *)(v4 + 820)];
      if (v35)
      {
        if (*(unsigned char *)(v4 + 560))
        {
          if (*(unsigned char *)(v4 + 561)) {
            uint64_t v46 = 1;
          }
          else {
            uint64_t v46 = 2;
          }
        }
        else
        {
          uint64_t v46 = 0;
        }
        [v35 setLockState:v46];
        if (*(unsigned char *)(v4 + 562)) {
          uint64_t v47 = &__kCFBooleanTrue;
        }
        else {
          uint64_t v47 = &__kCFBooleanFalse;
        }
        [v35 setIsSelectedOverride:v47];
        xpc_object_t v48 = [v35 plan];
        unint64_t v49 = +[NSNumber numberWithInteger:*(unsigned int *)(v4 + 820)];
        [v48 setSubscriptionStatusOverride:v49];

        if (*(unsigned char *)(v4 + 564)) {
          [v35 setShouldDisplayType:1];
        }
        if (*(unsigned char *)(v4 + 565)) {
          [v35 setIsActiveDataPlan:1];
        }
        if (*(unsigned char *)(v4 + 566)) {
          [v35 setIsDefaultVoice:1];
        }
        if (*(unsigned char *)(v4 + 567)) {
          [v35 setShouldDisplayExtendedConsentInfo:1];
        }
        [v35 setIsSelectable:*(unsigned __int8 *)(v4 + 563)];
        if (*(char *)(v4 + 631) < 0)
        {
          if (!*(void *)(v4 + 616)) {
            goto LABEL_81;
          }
        }
        else if (!*(unsigned char *)(v4 + 631))
        {
          goto LABEL_81;
        }
        id v50 = objc_alloc((Class)NSUUID);
        unint64_t v51 = (void *)(v4 + 608);
        if (*(char *)(v4 + 631) < 0) {
          unint64_t v51 = (void *)*v51;
        }
        uint8x8_t v52 = +[NSString stringWithUTF8String:v51];
        id v53 = [v50 initWithUUIDString:v52];
        [v35 setCompanionSlotUuid:v53];

LABEL_81:
        long long v54 = (void *)(v4 + 632);
        if (*(char *)(v4 + 655) < 0)
        {
          if (*(void *)(v4 + 640))
          {
            long long v54 = (void *)*v54;
            goto LABEL_86;
          }
        }
        else
        {
          if (!*(unsigned char *)(v4 + 655)) {
            goto LABEL_87;
          }
LABEL_86:
          unint64_t v55 = +[NSString stringWithUTF8String:v54];
          [v35 setCompanionSimLabelId:v55];
        }
LABEL_87:
        [cf addObject:v35];
      }

      v4 += 824;
    }
    while (v4 != v60);
  }
  sub_100044D34(a2, cf);
}

void sub_100CCE7B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  sub_1000C584C((uint64_t)&__p);
  _Unwind_Resume(a1);
}

id sub_100CCE930(int *a1)
{
  if (*((void *)a1 + 20) == *((void *)a1 + 19))
  {
    id v7 = 0;
  }
  else
  {
    id v2 = [objc_alloc((Class)NSMutableArray) initWithCapacity:0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a1 + 20) - *((void *)a1 + 19)) >> 3)];
    id v3 = (uint64_t *)*((void *)a1 + 19);
    for (unint64_t i = (uint64_t *)*((void *)a1 + 20); v3 != i; v3 += 3)
    {
      uint64_t v5 = v3;
      if (*((char *)v3 + 23) < 0) {
        uint64_t v5 = (uint64_t *)*v3;
      }
      id v6 = +[NSString stringWithUTF8String:v5];
      [v2 addObject:v6];
    }
    id v7 = v2;
  }
  long long v37 = v7;
  if (*((void *)a1 + 23) == *((void *)a1 + 22))
  {
    id v8 = 0;
  }
  else
  {
    id v8 = [objc_alloc((Class)NSMutableArray) initWithCapacity:0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a1 + 23) - *((void *)a1 + 22)) >> 3)];
    uint64_t v9 = *((void *)a1 + 22);
    for (uint64_t j = *((void *)a1 + 23); v9 != j; v9 += 40)
    {
      int v11 = (void *)(v9 + 16);
      if (*(char *)(v9 + 39) < 0)
      {
        if (!*(void *)(v9 + 24))
        {
LABEL_16:
          char v12 = 0;
          goto LABEL_17;
        }
        int v11 = (void *)*v11;
      }
      else if (!*(unsigned char *)(v9 + 39))
      {
        goto LABEL_16;
      }
      char v12 = +[NSString stringWithUTF8String:v11];
LABEL_17:
      id v13 = [objc_alloc((Class)CTCellularPlanSubscriptionDataUsage) initWithCategory:v12 andDataUsed:*(double *)v9 andDataCapacity:*(double *)(v9 + 8)];
      [v8 addObject:v13];
    }
  }
  id v14 = objc_alloc((Class)CTCellularPlanSubscription);
  if (*((char *)a1 + 31) >= 0) {
    uint64_t v15 = (uint64_t)(a1 + 2);
  }
  else {
    uint64_t v15 = *((void *)a1 + 1);
  }
  uint64_t v16 = +[NSString stringWithUTF8String:v15];
  unsigned int v17 = *a1;
  int v18 = *((unsigned __int8 *)a1 + 32);
  double v19 = *((double *)a1 + 5);
  double v20 = *((double *)a1 + 6);
  if (*((char *)a1 + 79) >= 0) {
    uint64_t v21 = (uint64_t)(a1 + 14);
  }
  else {
    uint64_t v21 = *((void *)a1 + 7);
  }
  int v36 = (void *)v16;
  id v35 = +[NSString stringWithUTF8String:v21];
  unsigned int v34 = v17;
  uint64_t v22 = *((unsigned __int8 *)a1 + 80);
  if (*((char *)a1 + 111) >= 0) {
    uint64_t v23 = (uint64_t)(a1 + 22);
  }
  else {
    uint64_t v23 = *((void *)a1 + 11);
  }
  id v24 = +[NSString stringWithUTF8String:v23];
  unsigned int v25 = a1[28];
  id v26 = a1 + 30;
  if ((*((char *)a1 + 143) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)a1 + 143)) {
      goto LABEL_35;
    }
LABEL_34:
    uint64_t v27 = +[NSString stringWithUTF8String:v26];
    char v28 = 0;
    goto LABEL_36;
  }
  if (*((void *)a1 + 16))
  {
    id v26 = (void *)*v26;
    goto LABEL_34;
  }
LABEL_35:
  uint64_t v27 = 0;
  char v28 = 1;
LABEL_36:
  double v29 = *((double *)a1 + 18);
  id v30 = [v37 copy];
  id v31 = [v8 copy];
  id v32 = objc_msgSend(v14, "initWithIccid:subscriptionResult:autoRenew:billingStartDate:billingEndDate:carrierName:planType:planDescription:planStatus:accountStatus:accountURL:timestamp:homeCountryList:dataUsage:", v36, v34, v18 != 0, v35, v22, v24, v19, v20, v29, v25, v27, v30, v31);

  if ((v28 & 1) == 0) {

  }
  return v32;
}

void sub_100CCEC5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_100CCED0C(int **a1@<X0>, void *a2@<X8>)
{
  uint64_t v5 = objc_opt_new();
  id v6 = *a1;
  id v7 = a1[1];
  while (v6 != v7)
  {
    id v8 = sub_100CCE930(v6);
    [v5 addObject:v8];

    v6 += 50;
  }
  if ([v5 count])
  {
    sub_100044D34(a2, v5);
  }
  else
  {

    *a2 = 0;
  }
}

void sub_100CCEDE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100CCEE00(const std::string **a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  std::string::size_type v77 = a4;
  uint64_t v5 = objc_opt_new();
  id v6 = *a1;
  uint64_t v78 = a1[1];
  id cf = (void *)v5;
  if (*a1 != v78)
  {
    while (1)
    {
      char v83 = v6;
      id v7 = objc_opt_new();
      memset(v120, 0, 17);
      long long v118 = 0u;
      long long v119 = 0u;
      long long v116 = 0u;
      long long v117 = 0u;
      uint64_t v91 = v7;
      uint64_t v88 = objc_opt_new();
      char v87 = objc_opt_new();
      if (v83[10].__r_.__value_.__s.__data_[0])
      {
        sub_1003DC1E4((uint64_t)&v118, (uint64_t)&v83[2].__r_.__value_.__l.__size_);
        uint64_t size = v83[8].__r_.__value_.__l.__size_;
        uint32_t v80 = (int *)v83[8].__r_.__value_.__r.__words[2];
        if ((int *)size != v80) {
          break;
        }
      }
      unsigned int v95 = 0;
LABEL_113:
      [v7 setIsMultiESimEnabled:v95 > 1];
      [v7 setRemotePlans:v88];
      [v7 setRemoteDisplayPlans:v87];
      if (LOBYTE(v120[0]))
      {
        ctu::hex((uint64_t *)v104, (ctu *)((char *)v120 + 1), (const void *)0x10, v62);
        if (SHIBYTE(v104[2]) >= 0) {
          long long v63 = v104;
        }
        else {
          long long v63 = (void **)v104[0];
        }
        long long v64 = +[NSString stringWithUTF8String:v63];
        if (SHIBYTE(v104[2]) < 0) {
          operator delete(v104[0]);
        }
      }
      else
      {
        long long v64 = 0;
      }
      if ((_BYTE)v118)
      {
        if (v119 >= 0) {
          long long v65 = (char *)&v118 + 8;
        }
        else {
          long long v65 = (char *)*((void *)&v118 + 1);
        }
        long long v66 = +[NSString stringWithUTF8String:v65];
      }
      else
      {
        long long v66 = 0;
      }
      if ((_BYTE)v116)
      {
        if (v117 >= 0) {
          long long v67 = (char *)&v116 + 8;
        }
        else {
          long long v67 = (char *)*((void *)&v116 + 1);
        }
        long long v68 = +[NSString stringWithUTF8String:v67];
      }
      else
      {
        long long v68 = 0;
      }
      id v69 = [objc_alloc((Class)CTDeviceIdentifier) initWithDeviceType:2 EID:v64 IMEI:v66 idsDeviceId:v68];
      [v91 setDeviceID:v69];

      p_uint64_t size = &v83[10].__r_.__value_.__l.__size_;
      if (v83[11].__r_.__value_.__s.__data_[7] < 0) {
        p_uint64_t size = (std::string::size_type *)*p_size;
      }
      long long v71 = +[NSString stringWithUTF8String:p_size];
      long long v72 = [v91 deviceID];
      [v72 setDeviceName:v71];

      long long v73 = &v83[14].__r_.__value_.__l.__size_;
      if (v83[15].__r_.__value_.__s.__data_[7] < 0) {
        long long v73 = (std::string::size_type *)*v73;
      }
      long long v74 = +[NSString stringWithUTF8String:v73];
      uint64_t v75 = [v91 deviceID];
      [v75 setModelName:v74];

      [cf addObject:v91];
      if ((_BYTE)v116 && SHIBYTE(v117) < 0) {
        operator delete(*((void **)&v116 + 1));
      }
      if ((_BYTE)v118 && SHIBYTE(v119) < 0) {
        operator delete(*((void **)&v118 + 1));
      }

      id v6 = (const std::string *)((char *)v83 + 400);
      if (&v83[16].__r_.__value_.__r.__words[2] == (std::string::size_type *)v78) {
        goto LABEL_143;
      }
    }
    unsigned int v95 = 0;
    while (1)
    {
      sub_10032AFC0(&v116, v83 + 7);
      uint64_t v106 = 0;
      long long v108 = 0u;
      *(_OWORD *)long long v105 = 0u;
      memset(v104, 0, sizeof(v104));
      long long v107 = &v108;
      uint64_t v9 = (_DWORD *)v83[15].__r_.__value_.__l.__size_;
      uint64_t v10 = (_DWORD *)v83[15].__r_.__value_.__r.__words[2];
      sub_1000C5DA8((uint64_t)v111, size);
      if (v9 != v10)
      {
        while (v112 != *v9)
        {
          v9 += 20;
          if (v9 == v10)
          {
            uint64_t v9 = v10;
            break;
          }
        }
      }
      if (v115[24])
      {
        v109[0] = v115;
        sub_1000C57C8((void ***)v109);
      }
      if (v114 < 0) {
        operator delete(__p);
      }
      if (v9 != (_DWORD *)v83[15].__r_.__value_.__r.__words[2]) {
        sub_1003083C8((uint64_t)v104, (uint64_t)v9);
      }
      *(_OWORD *)((char *)v120 + 1) = *(_OWORD *)(size + 16);
      if (!LOBYTE(v120[0])) {
        LOBYTE(v120[0]) = 1;
      }
      uint8_t v94 = (int *)size;
      if (*(unsigned char *)(size + 80)) {
        break;
      }
LABEL_106:
      sub_1000C5440((uint64_t)&v107, (void *)v108);
      if (SHIBYTE(v106) < 0) {
        operator delete(v105[0]);
      }
      if (SHIBYTE(v104[3]) < 0) {
        operator delete(v104[1]);
      }
      uint64_t size = (uint64_t)(v94 + 22);
      if (v94 + 22 == v80) {
        goto LABEL_113;
      }
    }
    uint64_t v12 = *(void *)(size + 56);
    uint64_t v11 = *(void *)(size + 64);
    for (uint64_t i = v11; ; v11 = i)
    {
      if (v12 == v11) {
        goto LABEL_106;
      }
      uint64_t v13 = *(char *)(v12 + 39) < 0 ? *(void *)(v12 + 24) : *(unsigned __int8 *)(v12 + 39);
      if (v13 && *(unsigned char *)(v12 + 88) == 0) {
        break;
      }
LABEL_105:
      v12 += 216;
    }
    if (*v94) {
      BOOL v15 = *(unsigned char *)(v12 + 89) == 0;
    }
    else {
      BOOL v15 = 1;
    }
    unsigned int v16 = v95;
    if (!v15) {
      unsigned int v16 = v95 + 1;
    }
    uint64_t v17 = sub_10010E128(a3, (void **)(v12 + 16));
    if (SHIBYTE(v104[3]) < 0)
    {
      sub_10004FC84(&v98, v104[1], (unint64_t)v104[2]);
    }
    else
    {
      long long v98 = *(_OWORD *)&v104[1];
      unsigned int v99 = v104[3];
    }
    if (SHIBYTE(v106) < 0)
    {
      sub_10004FC84(&v100, v105[0], (unint64_t)v105[1]);
    }
    else
    {
      long long v100 = *(_OWORD *)v105;
      uint64_t v101 = v106;
    }
    sub_100312438(&v102, (uint64_t)&v107);
    unsigned int v95 = v16;
    uint64_t v19 = *a2;
    int v18 = (std::__shared_weak_count *)a2[1];
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(char *)(v12 + 39) < 0)
    {
      unint64_t v20 = *(void *)(v12 + 24);
      if (!v20) {
        goto LABEL_49;
      }
    }
    else
    {
      unint64_t v20 = *(unsigned __int8 *)(v12 + 39);
      if (!*(unsigned char *)(v12 + 39)) {
        goto LABEL_49;
      }
    }
    if (v20 >= 2)
    {
      uint64_t v21 = sub_100046F68((uint64_t)&v102, (void **)(v12 + 16));
      uint64_t v22 = v21;
      uint64_t v86 = v19;
      if (&v103 == (void **)v21)
      {
        id v24 = 0;
        std::string v97 = 0;
        uint64_t v92 = 0;
        uint64_t v93 = 0;
      }
      else
      {
        if (*((unsigned char *)v21 + 225)) {
          int v23 = *((unsigned __int8 *)v21 + 224);
        }
        else {
          int v23 = 0;
        }
        v109[0] = 0;
        v109[1] = 0;
        unsigned int v25 = v21 + 19;
        uint64_t v110 = 0;
        sub_100CD6B88((const void **)v21 + 7, (uint64_t)(v21 + 19), (uint64_t)v109);
        int v82 = v23;
        uint64_t v81 = v17;
        if (v110 >= 0) {
          id v26 = v109;
        }
        else {
          id v26 = (void **)v109[0];
        }
        std::string v97 = +[NSString stringWithUTF8String:v26];
        uint64_t v27 = v22 + 16;
        if (*((char *)v22 + 151) < 0) {
          uint64_t v27 = (void *)*v27;
        }
        uint64_t v93 = +[NSString stringWithUTF8String:v27];
        if (*((char *)v22 + 175) < 0) {
          unsigned int v25 = (void *)*v25;
        }
        uint64_t v92 = +[NSString stringWithUTF8String:v25];
        id v24 = objc_opt_new();
        id v28 = objc_alloc((Class)CTRemotePlanIdentifier);
        if (*(char *)(v12 + 39) >= 0) {
          uint64_t v29 = v12 + 16;
        }
        else {
          uint64_t v29 = *(void *)(v12 + 16);
        }
        uint64_t v84 = +[NSString stringWithUTF8String:v29];
        id v30 = v22 + 10;
        if (*((char *)v22 + 103) < 0) {
          id v30 = (void *)*v30;
        }
        char v85 = +[NSString stringWithUTF8String:v30];
        if (*(char *)(v12 + 119) >= 0) {
          uint64_t v31 = v12 + 96;
        }
        else {
          uint64_t v31 = *(void *)(v12 + 96);
        }
        id v32 = +[NSString stringWithUTF8String:v31];
        if (*(char *)(v12 + 143) >= 0) {
          uint64_t v33 = v12 + 120;
        }
        else {
          uint64_t v33 = *(void *)(v12 + 120);
        }
        unsigned int v34 = +[NSString stringWithUTF8String:v33];
        if (*(char *)(v12 + 167) >= 0) {
          uint64_t v35 = v12 + 144;
        }
        else {
          uint64_t v35 = *(void *)(v12 + 144);
        }
        int v36 = +[NSString stringWithUTF8String:v35];
        if (*(char *)(v12 + 191) >= 0) {
          uint64_t v37 = v12 + 168;
        }
        else {
          uint64_t v37 = *(void *)(v12 + 168);
        }
        id v38 = +[NSString stringWithUTF8String:v37];
        id v39 = objc_msgSend(v28, "initWithIccid:carrierName:phoneNumber:countryCode:label:mcc:mnc:gid1:gid2:", v84, v93, v97, v92, v85, v32, v34, v36, v38, context, v77);
        [v24 setPlanID:v39];

        id v40 = objc_alloc((Class)CTPlanTransferAttributes);
        uint64_t v41 = sub_100CDD5F0(v82);
        uint64_t v42 = v22 + 22;
        if (*((char *)v22 + 199) < 0) {
          uint64_t v42 = (void *)*v42;
        }
        int v43 = +[NSString stringWithUTF8String:v42];
        id v44 = [v40 initWithTransferCapability:v41 transferStatus:0 isSecuredFlow:v81 != 0 transferEndpoint:v43];
        [v24 setTransferAttributes:v44];

        int v45 = *((unsigned __int8 *)v22 + 392);
        if (v45 == 2) {
          uint64_t v46 = 2;
        }
        else {
          uint64_t v46 = v45 == 1;
        }
        [v24 setAddOnPurchaseType:v46];
        if (*((unsigned char *)v22 + 449))
        {
          uint64_t v47 = +[NSNumber numberWithBool:*((unsigned __int8 *)v22 + 448)];
          [v24 setPrimaryAccount:v47];
        }
        if (SHIBYTE(v110) < 0) {
          operator delete(v109[0]);
        }
      }
      if (v86)
      {
        xpc_object_t v48 = sub_100046F68(v86, (void **)(v12 + 16));
        unint64_t v49 = v48;
        if ((void **)(v86 + 8) != v48 && *((unsigned char *)v48 + 304) && *((unsigned char *)v48 + 336))
        {
          id v50 = objc_alloc((Class)CTPlanSignUpDetails);
          unint64_t v51 = v49 + 35;
          if (*((char *)v49 + 303) < 0) {
            unint64_t v51 = (void *)*v51;
          }
          uint8x8_t v52 = +[NSString stringWithUTF8String:v51];
          id v53 = v49 + 39;
          if (*((char *)v49 + 335) < 0) {
            id v53 = (void *)*v53;
          }
          long long v54 = +[NSString stringWithUTF8String:v53];
          id v55 = [v50 initWithSignUpUrl:v52 signUpUrlType:v54];
          [v24 setSignUpDetails:v55];
        }
      }

LABEL_95:
      if (v18) {
        sub_10004D2C8(v18);
      }
      sub_1000C5440((uint64_t)&v102, v103);
      if (SHIBYTE(v101) < 0) {
        operator delete((void *)v100);
      }
      if (SHIBYTE(v99) < 0)
      {
        operator delete((void *)v98);
        if (!v24)
        {
LABEL_104:

          id v7 = v91;
          goto LABEL_105;
        }
      }
      else if (!v24)
      {
        goto LABEL_104;
      }
      [v88 addObject:v24];
      id v56 = objc_alloc((Class)CTDisplayPlan);
      int v57 = *v94;
      uint64_t v58 = [v24 carrierName];
      unint64_t v59 = [v24 phoneNumber];
      uint64_t v60 = [v24 label];
      id v61 = [v56 initWithPlan:v24 status:11 attributes:8 isPhysical:v57 == 0 carrierName:v58 phoneNumber:v59 label:v60];

      [v87 addObject:v61];
      goto LABEL_104;
    }
LABEL_49:
    id v24 = 0;
    goto LABEL_95;
  }
LABEL_143:
  sub_100044D34(v77, cf);
}

void sub_100CCF944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38)
{
  if (*(unsigned char *)(v39 - 192) && *(char *)(v39 - 161) < 0) {
    operator delete(*(void **)(v39 - 184));
  }
  if (*(unsigned char *)(v39 - 160))
  {
    if (*(char *)(v39 - 129) < 0) {
      operator delete(*(void **)(v39 - 152));
    }
  }

  _Unwind_Resume(a1);
}

void sub_100CCFBF8(os_log_t *a1@<X0>, uint64_t *a2@<X1>, unsigned __int8 **a3@<X2>, void *a4@<X8>)
{
  if (*a2 == a2[1])
  {
    *a4 = 0;
  }
  else
  {
    id v44 = +[NSMutableArray array];
    uint64_t v8 = *a2;
    uint64_t v7 = a2[1];
    if (*a2 != v7)
    {
      while (1)
      {
        uint64_t v9 = 2;
        switch(*(unsigned char *)(v8 + 2))
        {
          case 0:
          case 3:
          case 0xA:
            os_log_t v10 = *a1;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v11 = (const void **)(v8 + 432);
              if (*(char *)(v8 + 455) < 0) {
                uint64_t v11 = (const void **)*v11;
              }
              uint64_t v12 = sub_1008A2228(*(unsigned __int8 *)(v8 + 1));
              *(_DWORD *)long long buf = 136315394;
              uint64_t v46 = v11;
              __int16 v47 = 2080;
              xpc_object_t v48 = v12;
              uint64_t v13 = v10;
              id v14 = "#I excluding plan [%s] with state: %s";
              uint32_t v15 = 22;
              goto LABEL_87;
            }
            goto LABEL_88;
          case 2:
            if (*(unsigned char *)(v8 + 4)) {
              uint64_t v9 = 2;
            }
            else {
              uint64_t v9 = 3;
            }
            goto LABEL_12;
          case 4:
            goto LABEL_12;
          default:
            uint64_t v9 = 1;
LABEL_12:
            int v16 = *((char *)a3 + 23);
            if (v16 >= 0) {
              uint64_t v17 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
            }
            else {
              uint64_t v17 = a3[1];
            }
            if (!v17) {
              goto LABEL_45;
            }
            int v18 = (const void **)(v8 + 432);
            uint64_t v19 = *(unsigned __int8 *)(v8 + 455);
            if ((v19 & 0x80u) == 0) {
              unint64_t v20 = (unsigned __int8 *)*(unsigned __int8 *)(v8 + 455);
            }
            else {
              unint64_t v20 = *(unsigned __int8 **)(v8 + 440);
            }
            if (v20 != v17) {
              goto LABEL_31;
            }
            if (v16 >= 0) {
              uint64_t v21 = (unsigned __int8 *)a3;
            }
            else {
              uint64_t v21 = *a3;
            }
            if ((v19 & 0x80) != 0)
            {
              id v24 = (const void **)*v18;
              if (!memcmp(*v18, v21, *(void *)(v8 + 440)))
              {
                os_log_t v23 = *a1;
                if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
                {
                  int v18 = v24;
LABEL_85:
                  *(_DWORD *)long long buf = 136315138;
                  uint64_t v46 = v18;
                  uint64_t v13 = v23;
                  id v14 = "#I excluding plan [%s] with source iccid matching 'exclude' iccid";
                  goto LABEL_86;
                }
              }
              else
              {
LABEL_31:
                uint64_t v25 = *(unsigned __int8 *)(v8 + 479);
                if ((v25 & 0x80u) == 0) {
                  id v26 = (unsigned __int8 *)*(unsigned __int8 *)(v8 + 479);
                }
                else {
                  id v26 = *(unsigned __int8 **)(v8 + 464);
                }
                if (v26 != v17) {
                  goto LABEL_45;
                }
                if (v16 >= 0) {
                  uint64_t v27 = (unsigned __int8 *)a3;
                }
                else {
                  uint64_t v27 = *a3;
                }
                if ((v25 & 0x80) != 0)
                {
                  if (memcmp(*(const void **)(v8 + 456), v27, *(void *)(v8 + 464))) {
                    goto LABEL_45;
                  }
                }
                else if (*(unsigned char *)(v8 + 479))
                {
                  uint64_t v28 = 0;
                  while (*(unsigned __int8 *)(v8 + v28 + 456) == v27[v28])
                  {
                    if (v25 == ++v28) {
                      goto LABEL_77;
                    }
                  }
LABEL_45:
                  uint64_t v29 = objc_opt_new();
                  id v30 = (void *)(v8 + 432);
                  if (*(char *)(v8 + 455) < 0)
                  {
                    if (!*(void *)(v8 + 440)) {
                      goto LABEL_51;
                    }
                    id v30 = (void *)*v30;
                  }
                  else if (!*(unsigned char *)(v8 + 455))
                  {
LABEL_51:
                    id v32 = (void *)(v8 + 240);
                    if (*(char *)(v8 + 263) < 0)
                    {
                      if (!*(void *)(v8 + 248)) {
                        goto LABEL_57;
                      }
                      id v32 = (void *)*v32;
                    }
                    else if (!*(unsigned char *)(v8 + 263))
                    {
LABEL_57:
                      unsigned int v34 = (void *)(v8 + 120);
                      if (*(char *)(v8 + 143) < 0)
                      {
                        if (!*(void *)(v8 + 128)) {
                          goto LABEL_63;
                        }
                        unsigned int v34 = (void *)*v34;
                      }
                      else if (!*(unsigned char *)(v8 + 143))
                      {
LABEL_63:
                        if (*(char *)(v8 + 167) < 0)
                        {
                          if (!*(void *)(v8 + 152)) {
                            goto LABEL_70;
                          }
                        }
                        else if (!*(unsigned char *)(v8 + 167))
                        {
                          goto LABEL_70;
                        }
                        id v36 = objc_alloc((Class)CTUserLabel);
                        uint64_t v37 = (void *)(v8 + 144);
                        if (*(char *)(v8 + 167) < 0) {
                          uint64_t v37 = (void *)*v37;
                        }
                        id v38 = +[NSString stringWithUTF8String:v37];
                        id v39 = [v36 initWithLabel:v38];
                        [v29 setPlanLabel:v39];

LABEL_70:
                        id v40 = (void *)(v8 + 264);
                        if (*(char *)(v8 + 287) < 0)
                        {
                          if (*(void *)(v8 + 272))
                          {
                            id v40 = (void *)*v40;
                            goto LABEL_75;
                          }
                        }
                        else
                        {
                          if (!*(unsigned char *)(v8 + 287)) {
                            goto LABEL_76;
                          }
LABEL_75:
                          uint64_t v41 = +[NSString stringWithUTF8String:v40];
                          [v29 setPhoneNumber:v41];
                        }
LABEL_76:
                        [v29 setStatus:v9];
                        [v44 addObject:v29];

                        goto LABEL_88;
                      }
                      uint64_t v35 = +[NSString stringWithUTF8String:v34];
                      [v29 setDeviceName:v35];

                      goto LABEL_63;
                    }
                    uint64_t v33 = +[NSString stringWithUTF8String:v32];
                    [v29 setCarrierName:v33];

                    goto LABEL_57;
                  }
                  uint64_t v31 = +[NSString stringWithUTF8String:v30];
                  [v29 setSourceIccid:v31];

                  goto LABEL_51;
                }
LABEL_77:
                os_log_t v42 = *a1;
                if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
                {
                  if ((v19 & 0x80) != 0) {
                    int v18 = (const void **)*v18;
                  }
                  *(_DWORD *)long long buf = 136315138;
                  uint64_t v46 = v18;
                  uint64_t v13 = v42;
                  id v14 = "#I excluding plan [%s] with target iccid matching 'exclude' iccid";
LABEL_86:
                  uint32_t v15 = 12;
LABEL_87:
                  _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, buf, v15);
                }
              }
            }
            else
            {
              if (*(unsigned char *)(v8 + 455))
              {
                uint64_t v22 = 0;
                do
                {
                  if (*(unsigned __int8 *)(v8 + v22 + 432) != v21[v22]) {
                    goto LABEL_31;
                  }
                  ++v22;
                }
                while (v19 != v22);
                os_log_t v23 = *a1;
                if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_88;
                }
                goto LABEL_85;
              }
              os_log_t v23 = *a1;
              if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_85;
              }
            }
LABEL_88:
            v8 += 1248;
            if (v8 == v7) {
              goto LABEL_89;
            }
            break;
        }
      }
    }
LABEL_89:
    if ([v44 count]) {
      sub_100044D34(a4, v44);
    }
    else {
      *a4 = 0;
    }
  }
}

void sub_100CD00F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_100CD0194(CFArrayRef *a1@<X0>, void *a2@<X8>)
{
  if (*a1) {
    id v3 = sub_100083F10;
  }
  else {
    id v3 = 0;
  }
  if (v3)
  {
    id v9 = (id)objc_opt_new();
    CFIndex Count = CFArrayGetCount(*a1);
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        uint64_t v7 = CFArrayGetValueAtIndex(*a1, i);
        uint64_t v8 = [v7 remoteDisplayPlans];
        [v9 addObjectsFromArray:v8];
      }
    }
    sub_100044D34(a2, v9);
  }
  else
  {
    *a2 = 0;
  }
}

void sub_100CD0294(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100CD02C4(id *a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  id v2 = *a1;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  obuint64_t j = v2;
  id v3 = [obj countByEnumeratingWithState:&v87 objects:v98 count:16];
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v73 = (uint64_t)(a2 + 2);
    uint64_t v74 = *(void *)v88;
    for (uint64_t i = *(void *)v88; ; uint64_t i = *(void *)v88)
    {
      if (i != v74) {
        objc_enumerationMutation(obj);
      }
      uint64_t v77 = v4;
      unint64_t v78 = (unint64_t)v3;
      id v6 = *(void **)(*((void *)&v87 + 1) + 8 * v4);
      uint64_t v7 = a2;
      unint64_t v8 = a2[1];
      unint64_t v9 = a2[2];
      if (v8 >= v9)
      {
        unint64_t v11 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v8 - *a2) >> 3);
        unint64_t v12 = v11 + 1;
        if (v11 + 1 > 0x147AE147AE147AELL) {
          sub_10006A748();
        }
        unint64_t v13 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v9 - *a2) >> 3);
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0xA3D70A3D70A3D7) {
          unint64_t v14 = 0x147AE147AE147AELL;
        }
        else {
          unint64_t v14 = v12;
        }
        uint64_t v95 = v73;
        if (v14) {
          uint32_t v15 = (char *)sub_10030FA44(v73, v14);
        }
        else {
          uint32_t v15 = 0;
        }
        int v16 = &v15[200 * v11];
        uint64_t v91 = v15;
        uint64_t v92 = v16;
        uint8_t v94 = &v15[200 * v14];
        *(_DWORD *)int v16 = 0;
        *((void *)v16 + 2) = 0;
        *((void *)v16 + 3) = 0;
        *((void *)v16 + 1) = 0;
        v16[32] = 0;
        *(_OWORD *)(v16 + 40) = 0u;
        *(_OWORD *)(v16 + 56) = 0u;
        *((void *)v16 + 9) = 0;
        v16[80] = 2;
        *((_DWORD *)v16 + 28) = 0;
        *((void *)v16 + 12) = 0;
        *((void *)v16 + 13) = 0;
        *((void *)v16 + 11) = 0;
        *(_OWORD *)(v16 + 120) = 0u;
        *(_OWORD *)(v16 + 136) = 0u;
        *(_OWORD *)(v16 + 152) = 0u;
        *(_OWORD *)(v16 + 168) = 0u;
        *(_OWORD *)(v16 + 184) = 0u;
        uint64_t v93 = v16 + 200;
        uint64_t v7 = a2;
        sub_100AA0E24(a2, &v91);
        uint64_t v10 = a2[1];
        sub_100AA0F8C((uint64_t)&v91);
      }
      else
      {
        *(_DWORD *)unint64_t v8 = 0;
        *(void *)(v8 + 16) = 0;
        *(void *)(v8 + 24) = 0;
        *(void *)(v8 + 8) = 0;
        *(unsigned char *)(v8 + 32) = 0;
        *(_OWORD *)(v8 + 40) = 0u;
        *(_OWORD *)(v8 + 56) = 0u;
        *(void *)(v8 + 72) = 0;
        *(unsigned char *)(v8 + 80) = 2;
        *(void *)(v8 + 96) = 0;
        *(void *)(v8 + 104) = 0;
        *(void *)(v8 + 88) = 0;
        *(_DWORD *)(v8 + 112) = 0;
        *(_OWORD *)(v8 + 120) = 0u;
        *(_OWORD *)(v8 + 136) = 0u;
        *(_OWORD *)(v8 + 152) = 0u;
        *(_OWORD *)(v8 + 168) = 0u;
        *(_OWORD *)(v8 + 184) = 0u;
        uint64_t v10 = v8 + 200;
      }
      v7[1] = v10;
      uint64_t v17 = objc_msgSend(v6, "accountURL", v73);
      BOOL v18 = v17 == 0;

      if (!v18)
      {
        id v19 = [v6 accountURL];
        sub_10003ED78((std::string *)(v10 - 80), (char *)[v19 UTF8String]);
      }
      unint64_t v20 = [v6 carrierName];
      BOOL v21 = v20 == 0;

      if (!v21)
      {
        id v22 = [v6 carrierName];
        sub_10003ED78((std::string *)(v10 - 144), (char *)[v22 UTF8String]);
      }
      os_log_t v23 = [v6 iccid];
      BOOL v24 = v23 == 0;

      if (!v24)
      {
        id v25 = [v6 iccid];
        sub_10003ED78((std::string *)(v10 - 192), (char *)[v25 UTF8String]);
      }
      id v26 = [v6 planDescription];
      BOOL v27 = v26 == 0;

      if (!v27)
      {
        id v28 = [v6 planDescription];
        sub_10003ED78((std::string *)(v10 - 112), (char *)[v28 UTF8String]);
      }
      *(unsigned char *)(v10 - 168) = [v6 autoRenew];
      [v6 billingStartDate];
      *(void *)(v10 - 160) = v29;
      [v6 billingEndDate];
      *(void *)(v10 - 152) = v30;
      [v6 timestamp];
      *(void *)(v10 - 56) = v31;
      *(_DWORD *)(v10 - 200) = [v6 subscriptionResult];
      *(_DWORD *)(v10 - 88) = [v6 planStatus];
      unsigned int v32 = [v6 planType];
      if (v32 == 1) {
        char v33 = 1;
      }
      else {
        char v33 = 2;
      }
      if (!v32) {
        char v33 = 0;
      }
      *(unsigned char *)(v10 - 120) = v33;
      unsigned int v34 = [v6 homeCountryList];
      BOOL v35 = v34 == 0;

      if (!v35)
      {
        long long v85 = 0u;
        long long v86 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        id v36 = [v6 homeCountryList];
        id v37 = [v36 countByEnumeratingWithState:&v83 objects:v97 count:16];
        if (v37)
        {
          uint64_t v38 = 0;
          uint64_t v39 = *(void *)v84;
          id v40 = (void *)(v10 - 48);
          for (uint64_t j = *(void *)v84; ; uint64_t j = *(void *)v84)
          {
            if (j != v39) {
              objc_enumerationMutation(v36);
            }
            os_log_t v42 = *(void **)(*((void *)&v83 + 1) + 8 * v38);
            id v44 = *(std::string **)(v10 - 40);
            unint64_t v43 = *(void *)(v10 - 32);
            if ((unint64_t)v44 >= v43)
            {
              unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v44 - *v40) >> 3);
              unint64_t v47 = v46 + 1;
              if (v46 + 1 > 0xAAAAAAAAAAAAAAALL) {
                sub_1000D8578();
              }
              unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v43 - *v40) >> 3);
              if (2 * v48 > v47) {
                unint64_t v47 = 2 * v48;
              }
              if (v48 >= 0x555555555555555) {
                unint64_t v49 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v49 = v47;
              }
              uint64_t v95 = v10 - 32;
              if (v49) {
                id v50 = (char *)sub_10004812C(v10 - 32, v49);
              }
              else {
                id v50 = 0;
              }
              unint64_t v51 = &v50[24 * v46];
              uint64_t v91 = v50;
              uint64_t v92 = v51;
              uint8_t v94 = &v50[24 * v49];
              *(void *)unint64_t v51 = 0;
              *((void *)v51 + 1) = 0;
              *((void *)v51 + 2) = 0;
              uint64_t v93 = v51 + 24;
              sub_100048204((uint64_t *)(v10 - 48), &v91);
              int v45 = *(std::string **)(v10 - 40);
              sub_100048174((uint64_t)&v91);
            }
            else
            {
              v44->__r_.__value_.__r.__words[0] = 0;
              v44->__r_.__value_.__l.__size_ = 0;
              v44->__r_.__value_.__r.__words[2] = 0;
              int v45 = v44 + 1;
              *(void *)(v10 - 40) = v44 + 1;
            }
            *(void *)(v10 - 40) = v45;
            sub_10003ED78(v45 - 1, (char *)[v42 UTF8String]);
            if (++v38 >= (unint64_t)v37)
            {
              id v37 = [v36 countByEnumeratingWithState:&v83 objects:v97 count:16];
              if (!v37) {
                break;
              }
              uint64_t v38 = 0;
            }
          }
        }
      }
      uint8x8_t v52 = [v6 dataUsage];
      BOOL v53 = v52 == 0;

      if (!v53)
      {
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v54 = [v6 dataUsage];
        id v55 = [v54 countByEnumeratingWithState:&v79 objects:v96 count:16];
        if (v55)
        {
          uint64_t v56 = 0;
          uint64_t v57 = *(void *)v80;
          uint64_t v58 = (void *)(v10 - 24);
          for (uint64_t k = *(void *)v80; ; uint64_t k = *(void *)v80)
          {
            if (k != v57) {
              objc_enumerationMutation(v54);
            }
            uint64_t v60 = *(void **)(*((void *)&v79 + 1) + 8 * v56);
            unint64_t v62 = *(void *)(v10 - 16);
            unint64_t v61 = *(void *)(v10 - 8);
            if (v62 >= v61)
            {
              unint64_t v64 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v62 - *v58) >> 3);
              unint64_t v65 = v64 + 1;
              if (v64 + 1 > 0x666666666666666) {
                sub_10006A748();
              }
              unint64_t v66 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v61 - *v58) >> 3);
              if (2 * v66 > v65) {
                unint64_t v65 = 2 * v66;
              }
              if (v66 >= 0x333333333333333) {
                unint64_t v67 = 0x666666666666666;
              }
              else {
                unint64_t v67 = v65;
              }
              uint64_t v95 = v10 - 8;
              if (v67) {
                long long v68 = (char *)sub_10005ED10(v10 - 8, v67);
              }
              else {
                long long v68 = 0;
              }
              id v69 = &v68[40 * v64];
              uint64_t v91 = v68;
              uint64_t v92 = v69;
              uint8_t v94 = &v68[40 * v67];
              *((void *)v69 + 4) = 0;
              *(_OWORD *)id v69 = 0u;
              *((_OWORD *)v69 + 1) = 0u;
              uint64_t v93 = v69 + 40;
              sub_100AA0BF4((uint64_t *)(v10 - 24), &v91);
              unint64_t v63 = *(void *)(v10 - 16);
              sub_100AA0D94((uint64_t)&v91);
            }
            else
            {
              *(void *)(v62 + 32) = 0;
              *(_OWORD *)unint64_t v62 = 0u;
              *(_OWORD *)(v62 + 16) = 0u;
              unint64_t v63 = v62 + 40;
              *(void *)(v10 - 16) = v62 + 40;
            }
            *(void *)(v10 - 16) = v63;
            id v70 = [v60 dataCategory];
            sub_10003ED78((std::string *)(v63 - 24), (char *)[v70 UTF8String]);

            [v60 dataCapacity];
            *(void *)(v63 - 32) = v71;
            [v60 dataUsed];
            *(void *)(v63 - 40) = v72;
            if (++v56 >= (unint64_t)v55)
            {
              id v55 = [v54 countByEnumeratingWithState:&v79 objects:v96 count:16];
              if (!v55) {
                break;
              }
              uint64_t v56 = 0;
            }
          }
        }
      }
      id v3 = (id)v78;
      uint64_t v4 = v77 + 1;
      if (v77 + 1 >= v78)
      {
        id v3 = [obj countByEnumeratingWithState:&v87 objects:v98 count:16];
        if (!v3) {
          break;
        }
        uint64_t v4 = 0;
      }
    }
  }
}

void sub_100CD0A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void **a39)
{
  a39 = a12;
  sub_100310018(&a39);
  _Unwind_Resume(a1);
}

uint64_t sub_100CD0B54(uint64_t a1, char *a2, uint64_t *a3)
{
  v66[0] = 0;
  v66[1] = 0;
  if (a2[23] < 0) {
    a2 = *(char **)a2;
  }
  sub_1000493DC(v66, a2);
  unint64_t v63 = 0;
  unint64_t v64 = 0;
  uint64_t v65 = 0;
  ctu::llvm::StringRef::split();
  std::string __p = 0;
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  if (MEMORY[0])
  {
    sub_1000D95C8(&__p, MEMORY[0], *((void *)v63 + 1));
    unsigned int v4 = HIBYTE(v62);
    uint64_t v5 = (void **)__p;
    uint64_t v6 = v61;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    unsigned int v4 = 0;
  }
  int v7 = (char)v4;
  unint64_t v8 = (void **)((char *)v5 + v6);
  unint64_t v9 = (void **)((char *)&__p + v4);
  if (v7 >= 0) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = v8;
  }
  if (v7 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = v5;
  }
  while (p_p != v10)
  {
    *(unsigned char *)p_p = __tolower(*(char *)p_p);
    p_p = (void **)((char *)p_p + 1);
  }
  unint64_t v12 = v63;
  unint64_t v13 = *(uint64_t **)v63;
  uint64_t v14 = *((void *)v63 + 1);
  if (v14 == 5 && (*(_DWORD *)v13 == 977358924 ? (BOOL v15 = *((unsigned char *)v13 + 4) == 49) : (BOOL v15 = 0), v15))
  {
    int v35 = 1;
    unint64_t v36 = 3;
    unint64_t v37 = 4;
  }
  else
  {
    uint64_t v16 = HIBYTE(v62);
    if (v62 < 0) {
      uint64_t v16 = v61;
    }
    if (v16 != 10) {
      goto LABEL_32;
    }
    uint64_t v17 = (unsigned __int16 *)__p;
    if (v62 >= 0) {
      uint64_t v17 = (unsigned __int16 *)&__p;
    }
    uint64_t v18 = *(void *)v17;
    int v19 = v17[4];
    if (v18 != 0x2F3A6D6973652D78 || v19 != 12591)
    {
LABEL_32:
      if (v14 != 14
        || ((v21 = *v13, uint64_t v22 = *(uint64_t *)((char *)v13 + 6), v21 == 0x2F3A6D6973652D78)
          ? (BOOL v23 = v22 == 0x313A41504C2F2F3ALL)
          : (BOOL v23 = 0),
            !v23))
      {
        if (v16 != 9) {
          goto LABEL_53;
        }
        BOOL v24 = (unsigned __int8 *)__p;
        if (v62 >= 0) {
          BOOL v24 = (unsigned __int8 *)&__p;
        }
        uint64_t v25 = *(void *)v24;
        int v26 = v24[8];
        BOOL v27 = v25 == 0x2F3A6D6973652D78 && v26 == 47;
        if (!v27 || (unint64_t)(v64 - (unsigned char *)v63) < 0x70) {
          goto LABEL_53;
        }
        size_t v28 = *((void *)v63 + 5);
        if (v28)
        {
          uint64_t v29 = (const void *)*((void *)v63 + 4);
          CodingUtility::SHA1();
          uint64_t v30 = HIBYTE(v59);
          int v31 = SHIBYTE(v59);
          unsigned int v32 = (void *)__dst;
          if (v59 < 0) {
            uint64_t v30 = *((void *)&__dst + 1);
          }
          if (v28 == v30)
          {
            if (v59 >= 0) {
              p_dst = &__dst;
            }
            else {
              p_dst = (long long *)__dst;
            }
            BOOL v34 = memcmp(v29, p_dst, v28) != 0;
          }
          else
          {
            BOOL v34 = 1;
          }
          if (v31 < 0) {
            operator delete(v32);
          }
          if (v34) {
            goto LABEL_53;
          }
          int v35 = 0;
          unint64_t v36 = 0;
          unint64_t v12 = v63;
        }
        else
        {
          int v35 = 0;
          unint64_t v36 = 0;
        }
        uint64_t v39 = 5;
        uint64_t v40 = 6;
        unint64_t v37 = 7;
        goto LABEL_55;
      }
    }
    int v35 = 0;
    unint64_t v36 = 0;
    unint64_t v37 = 3;
  }
  if ((unint64_t)(v64 - (unsigned char *)v63) < 0x30) {
    goto LABEL_53;
  }
  uint64_t v39 = 1;
  uint64_t v40 = 2;
LABEL_55:
  uint64_t v41 = (void *)v12[2 * v39];
  if (v41)
  {
    sub_1000D95C8(&__dst, v41, v12[2 * v39 + 1]);
  }
  else
  {
    long long __dst = 0uLL;
    uint64_t v59 = 0;
  }
  uint64_t v42 = *a3;
  if (*(char *)(*a3 + 23) < 0) {
    operator delete(*(void **)v42);
  }
  long long v43 = __dst;
  *(void *)(v42 + 16) = v59;
  *(_OWORD *)uint64_t v42 = v43;
  id v44 = (void *)*((void *)v63 + 2 * v40);
  if (v44)
  {
    sub_1000D95C8(&__dst, v44, *((void *)v63 + 2 * v40 + 1));
  }
  else
  {
    long long __dst = 0uLL;
    uint64_t v59 = 0;
  }
  uint64_t v45 = *a3 + 48;
  if (*(char *)(*a3 + 71) < 0) {
    operator delete(*(void **)v45);
  }
  *(_OWORD *)uint64_t v45 = __dst;
  *(void *)(v45 + 16) = v59;
  uint64_t v46 = *a3;
  unint64_t v47 = (void *)(*a3 + 48);
  if (*(char *)(*a3 + 71) < 0)
  {
    uint64_t v48 = *(void *)(v46 + 56);
    if (!v48) {
      goto LABEL_75;
    }
    unint64_t v47 = (void *)*v47;
    goto LABEL_70;
  }
  uint64_t v48 = *(unsigned __int8 *)(*a3 + 71);
  if (*(unsigned char *)(*a3 + 71))
  {
LABEL_70:
    uint64_t v49 = 0;
    while (memchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-", *((char *)v47 + v49), 0x3FuLL))
    {
      if (v48 == ++v49) {
        goto LABEL_75;
      }
    }
    if (v49 == -1) {
      goto LABEL_75;
    }
LABEL_53:
    uint64_t v38 = 0;
    goto LABEL_98;
  }
LABEL_75:
  id v50 = (char *)v63;
  unint64_t v51 = v64;
  if (v35)
  {
    if (v36 < (v64 - (unsigned char *)v63) >> 4)
    {
      size_t v52 = *((void *)v63 + 2 * v36 + 1);
      if (v52)
      {
        BOOL v53 = (void *)*((void *)v63 + 2 * v36);
        if (v53)
        {
          sub_1000D95C8(&__dst, v53, v52);
          uint64_t v46 = *a3;
        }
        else
        {
          long long __dst = 0uLL;
          uint64_t v59 = 0;
        }
        long long v54 = (void **)(v46 + 24);
        if (*(char *)(v46 + 47) < 0) {
          operator delete(*v54);
        }
        *(_OWORD *)long long v54 = __dst;
        *(void *)(v46 + 40) = v59;
        id v50 = (char *)v63;
        unint64_t v51 = v64;
      }
    }
  }
  if (v37 >= (v51 - v50) >> 4)
  {
    *(unsigned char *)(*a3 + 120) = 0;
  }
  else
  {
    id v55 = &v50[16 * v37];
    BOOL v56 = *((void *)v55 + 1) == 1 && **(unsigned char **)v55 == 49;
    *(unsigned char *)(*a3 + 120) = v56;
  }
  uint64_t v38 = 1;
LABEL_98:
  if (SHIBYTE(v62) < 0) {
    operator delete(__p);
  }
  if (v63)
  {
    unint64_t v64 = v63;
    operator delete(v63);
  }
  return v38;
}

void sub_100CD0FEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CD1034(int **a1, char *a2)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  uint64_t v6 = *a1;
  int v7 = a1[1];
  if (*a1 != v7)
  {
    BOOL v27 = a1[1];
    xpc_object_t v28 = v5;
    do
    {
      if (!*v6) {
        goto LABEL_81;
      }
      v63[0] = 0;
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        v63[0] = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        v63[0] = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_17;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_17:
        v63[0] = v10;
        goto LABEL_18;
      }
      xpc_retain(v9);
LABEL_18:
      xpc_release(v9);
      uint64_t v60 = 0;
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      ctu::hex((uint64_t *)&v60, (ctu *)(v6 + 4), (const void *)0x10, v11);
      if (v62 >= 0) {
        unint64_t v12 = (const char *)&v60;
      }
      else {
        unint64_t v12 = v60;
      }
      xpc_object_t v58 = xpc_string_create(v12);
      if (!v58) {
        xpc_object_t v58 = xpc_null_create();
      }
      BOOL v56 = v63;
      uint64_t v57 = "kCTCellularPlanSlotCsnKey";
      sub_100035E70((uint64_t)&v56, &v58, &v59);
      xpc_release(v59);
      xpc_object_t v59 = 0;
      xpc_release(v58);
      xpc_object_t v58 = 0;
      xpc_object_t v54 = xpc_int64_create(v6[1]);
      if (!v54) {
        xpc_object_t v54 = xpc_null_create();
      }
      BOOL v56 = v63;
      uint64_t v57 = "kCTCellularPlanSlotIdKey";
      sub_100035E70((uint64_t)&v56, &v54, &v55);
      xpc_release(v55);
      xpc_object_t v55 = 0;
      xpc_release(v54);
      xpc_object_t v54 = 0;
      xpc_object_t v52 = xpc_int64_create(*v6);
      if (!v52) {
        xpc_object_t v52 = xpc_null_create();
      }
      BOOL v56 = v63;
      uint64_t v57 = "kCTCellularPlanSlotCardType";
      sub_100035E70((uint64_t)&v56, &v52, &v53);
      xpc_release(v53);
      xpc_object_t v53 = 0;
      xpc_release(v52);
      xpc_object_t v52 = 0;
      if (*((unsigned char *)v6 + 80))
      {
        xpc_object_t v13 = xpc_array_create(0, 0);
        if (v13 || (xpc_object_t v13 = xpc_null_create()) != 0)
        {
          if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_array)
          {
            xpc_retain(v13);
            xpc_object_t v14 = v13;
          }
          else
          {
            xpc_object_t v14 = xpc_null_create();
          }
        }
        else
        {
          xpc_object_t v14 = xpc_null_create();
          xpc_object_t v13 = 0;
        }
        xpc_release(v13);
        if (!*((unsigned char *)v6 + 80)) {
          sub_10016C840();
        }
        uint64_t v15 = *((void *)v6 + 7);
        uint64_t v16 = *((void *)v6 + 8);
        while (2)
        {
          if (v15 == v16)
          {
            xpc_object_t v31 = v14;
            if (v14)
            {
              xpc_retain(v14);
              int v7 = v27;
              xpc_object_t v5 = v28;
            }
            else
            {
              int v7 = v27;
              xpc_object_t v5 = v28;
              xpc_object_t v31 = xpc_null_create();
            }
            BOOL v56 = v63;
            uint64_t v57 = "kCTCellularPlanSlotProfileListKey";
            sub_10017AC14((uint64_t)&v56, &v31, &v32);
            xpc_release(v32);
            xpc_object_t v32 = 0;
            xpc_release(v31);
            xpc_object_t v31 = 0;
            xpc_release(v14);
            break;
          }
          xpc_object_t v51 = 0;
          xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v18 = v17;
          if (v17)
          {
            xpc_object_t v51 = v17;
            goto LABEL_40;
          }
          xpc_object_t v18 = xpc_null_create();
          xpc_object_t v51 = v18;
          if (v18)
          {
LABEL_40:
            if (xpc_get_type(v18) != (xpc_type_t)&_xpc_type_dictionary)
            {
              xpc_object_t v19 = xpc_null_create();
              goto LABEL_44;
            }
            xpc_retain(v18);
          }
          else
          {
            xpc_object_t v19 = xpc_null_create();
            xpc_object_t v18 = 0;
LABEL_44:
            xpc_object_t v51 = v19;
          }
          xpc_release(v18);
          unint64_t v20 = (const char *)(v15 + 16);
          if (*(char *)(v15 + 39) < 0) {
            unint64_t v20 = *(const char **)v20;
          }
          xpc_object_t v49 = xpc_string_create(v20);
          if (!v49) {
            xpc_object_t v49 = xpc_null_create();
          }
          BOOL v56 = &v51;
          uint64_t v57 = "kCTCellularPlanProfileIccidKey";
          sub_100035E70((uint64_t)&v56, &v49, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          xpc_release(v49);
          xpc_object_t v49 = 0;
          uint64_t v21 = (const char *)(v15 + 96);
          if (*(char *)(v15 + 119) < 0) {
            uint64_t v21 = *(const char **)v21;
          }
          xpc_object_t v47 = xpc_string_create(v21);
          if (!v47) {
            xpc_object_t v47 = xpc_null_create();
          }
          BOOL v56 = &v51;
          uint64_t v57 = "kCTCellularPlanProfileMccKey";
          sub_100035E70((uint64_t)&v56, &v47, &v48);
          xpc_release(v48);
          xpc_object_t v48 = 0;
          xpc_release(v47);
          xpc_object_t v47 = 0;
          uint64_t v22 = (const char *)(v15 + 120);
          if (*(char *)(v15 + 143) < 0) {
            uint64_t v22 = *(const char **)v22;
          }
          xpc_object_t v45 = xpc_string_create(v22);
          if (!v45) {
            xpc_object_t v45 = xpc_null_create();
          }
          BOOL v56 = &v51;
          uint64_t v57 = "kCTCellularPlanProfileMncKey";
          sub_100035E70((uint64_t)&v56, &v45, &v46);
          xpc_release(v46);
          xpc_object_t v46 = 0;
          xpc_release(v45);
          xpc_object_t v45 = 0;
          BOOL v23 = (const char *)(v15 + 144);
          if (*(char *)(v15 + 167) < 0) {
            BOOL v23 = *(const char **)v23;
          }
          xpc_object_t v43 = xpc_string_create(v23);
          if (!v43) {
            xpc_object_t v43 = xpc_null_create();
          }
          BOOL v56 = &v51;
          uint64_t v57 = "kCTCellularPlanProfileGid1Key";
          sub_100035E70((uint64_t)&v56, &v43, &v44);
          xpc_release(v44);
          xpc_object_t v44 = 0;
          xpc_release(v43);
          xpc_object_t v43 = 0;
          BOOL v24 = (const char *)(v15 + 168);
          if (*(char *)(v15 + 191) < 0) {
            BOOL v24 = *(const char **)v24;
          }
          xpc_object_t v41 = xpc_string_create(v24);
          if (!v41) {
            xpc_object_t v41 = xpc_null_create();
          }
          BOOL v56 = &v51;
          uint64_t v57 = "kCTCellularPlanProfileGid2Key";
          sub_100035E70((uint64_t)&v56, &v41, &v42);
          xpc_release(v42);
          xpc_object_t v42 = 0;
          xpc_release(v41);
          xpc_object_t v41 = 0;
          xpc_object_t v39 = xpc_BOOL_create(*(unsigned char *)(v15 + 91));
          if (!v39) {
            xpc_object_t v39 = xpc_null_create();
          }
          BOOL v56 = &v51;
          uint64_t v57 = "kCTCellularPlanProfileIsDisableNotAllowed";
          sub_100035E70((uint64_t)&v56, &v39, &v40);
          xpc_release(v40);
          xpc_object_t v40 = 0;
          xpc_release(v39);
          xpc_object_t v39 = 0;
          xpc_object_t v37 = xpc_BOOL_create(*(unsigned char *)(v15 + 90));
          if (!v37) {
            xpc_object_t v37 = xpc_null_create();
          }
          BOOL v56 = &v51;
          uint64_t v57 = "kCTCellularPlanProfileIsDeleteNotAllowed";
          sub_100035E70((uint64_t)&v56, &v37, &v38);
          xpc_release(v38);
          xpc_object_t v38 = 0;
          xpc_release(v37);
          xpc_object_t v37 = 0;
          xpc_object_t v35 = xpc_BOOL_create(*(unsigned char *)(v15 + 88));
          if (!v35) {
            xpc_object_t v35 = xpc_null_create();
          }
          BOOL v56 = &v51;
          uint64_t v57 = "kCTCellularPlanProfileIsBootstrapKey";
          sub_100035E70((uint64_t)&v56, &v35, &v36);
          xpc_release(v36);
          xpc_object_t v36 = 0;
          xpc_release(v35);
          xpc_object_t v35 = 0;
          xpc_object_t v33 = xpc_BOOL_create(*(unsigned char *)(v15 + 89));
          if (!v33) {
            xpc_object_t v33 = xpc_null_create();
          }
          BOOL v56 = &v51;
          uint64_t v57 = "kCTCellularPlanProfileIsActiveKey";
          sub_100035E70((uint64_t)&v56, &v33, &v34);
          xpc_release(v34);
          xpc_object_t v34 = 0;
          xpc_release(v33);
          xpc_object_t v33 = 0;
          xpc_array_append_value(v14, v51);
          xpc_release(v51);
          v15 += 216;
          continue;
        }
      }
      xpc_array_append_value(v5, v63[0]);
      if (SHIBYTE(v62) < 0) {
        operator delete(v60);
      }
      xpc_release(v63[0]);
LABEL_81:
      v6 += 22;
    }
    while (v6 != v7);
  }
  xpc_object_t v29 = v5;
  if (v5)
  {
    xpc_retain(v5);
    uint64_t v25 = a2;
  }
  else
  {
    xpc_object_t v26 = xpc_null_create();
    uint64_t v25 = a2;
    xpc_object_t v29 = v26;
  }
  uint64_t v60 = v25;
  uint64_t v61 = "kCTCellularPlanSlotVinylSlotInfoListKey";
  sub_10017AC14((uint64_t)&v60, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v5);
}

void sub_100CD17E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  xpc_release(v12);
  if (*(char *)(v13 - 97) < 0) {
    operator delete(*(void **)(v13 - 120));
  }
  xpc_release(*(xpc_object_t *)(v13 - 96));
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_100CD1928(const char *a1)
{
  uint64_t v1 = a1;
  uint64_t v4 = 0;
  unsigned int v3 = 0;
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  if (sscanf(a1, "%u.%u.%u", (char *)&v4 + 4, &v4, &v3) == 3) {
    return (v4 << 8) | (HIDWORD(v4) << 16) | v3;
  }
  if (v1[23] < 0) {
    uint64_t v1 = *(const char **)v1;
  }
  if (sscanf(v1, "%u.%u", (char *)&v4 + 4, &v4) == 2) {
    return ((v4 << 8) | (HIDWORD(v4) << 16));
  }
  else {
    return 0;
  }
}

void sub_100CD19E8(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  uint64_t v6 = operator new(0x20uLL);
  std::string v6[3] = 0;
  int v7 = (void **)(v6 + 3);
  v6[1] = 0;
  v6[2] = 0;
  *uint64_t v6 = off_101A4EAA0;
  *a3 = v6 + 3;
  a3[1] = v6;
  uint64_t v8 = sub_100CD1A98(a1, a2);
  xpc_object_t v9 = *v7;
  *int v7 = (void *)v8;
}

void sub_100CD1A84(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

id sub_100CD1A98(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_opt_new();
  id v5 = objc_alloc((Class)CTDeviceIdentifier);
  if (*(char *)(a1 + 47) >= 0) {
    uint64_t v6 = a1 + 24;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 24);
  }
  int v7 = +[NSString stringWithUTF8String:v6];
  id v8 = [v5 initWithDeviceType:1 EID:v7 IMEI:0 idsDeviceId:0];
  [v4 setDeviceID:v8];

  if (*(void *)(a1 + 48) == *(void *)(a1 + 56))
  {
    xpc_object_t v9 = 0;
  }
  else
  {
    xpc_object_t v9 = +[NSMutableArray array];
    xpc_object_t v10 = *(uint64_t **)(a1 + 48);
    unint64_t v11 = *(uint64_t **)(a1 + 56);
    if (v10 != v11)
    {
      unint64_t v12 = (void **)(a2 + 8);
      do
      {
        uint64_t v13 = objc_opt_new();
        id v14 = objc_alloc((Class)CTRemotePlanIdentifier);
        uint64_t v15 = v10;
        if (*((char *)v10 + 23) < 0) {
          uint64_t v15 = (uint64_t *)*v10;
        }
        uint64_t v16 = +[NSString stringWithUTF8String:v15];
        xpc_object_t v17 = v10 + 3;
        if (*((char *)v10 + 47) < 0) {
          xpc_object_t v17 = (void *)*v17;
        }
        xpc_object_t v18 = +[NSString stringWithUTF8String:v17];
        id v19 = [v14 initWithIccid:v16 carrierName:v18 phoneNumber:0 countryCode:0 label:0 mcc:0 mnc:0 gid1:0 gid2:0];
        [v13 setPlanID:v19];

        unint64_t v20 = *v12;
        if (!*v12) {
          goto LABEL_22;
        }
        uint64_t v21 = v12;
        do
        {
          char v22 = sub_100046FE8(v20 + 4, (void **)v10 + 9);
          if (v22 >= 0) {
            BOOL v23 = v20;
          }
          else {
            BOOL v23 = v20 + 1;
          }
          if (v22 >= 0) {
            uint64_t v21 = (void **)v20;
          }
          unint64_t v20 = (void *)*v23;
        }
        while (*v23);
        if (v21 == v12 || (sub_100046FE8(v10 + 9, v21 + 4) & 0x80) != 0) {
LABEL_22:
        }
          int v24 = 0;
        else {
          int v24 = *((unsigned __int8 *)v21 + 56);
        }
        id v25 = [objc_alloc((Class)CTPlanTransferAttributes) initWithTransferCapability:sub_100CDD5F0(v24) transferStatus:0 isSecuredFlow:0 transferEndpoint:0];
        [v13 setTransferAttributes:v25];

        [v9 addObject:v13];
        v10 += 12;
      }
      while (v10 != v11);
    }
  }
  [v4 setRemotePlans:v9];

  return v4;
}

void sub_100CD1D20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100CD1D9C(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  if (*a1 != a1[1])
  {
    uint64_t v6 = operator new(0x20uLL);
    v6[1] = 0;
    v6[2] = 0;
    std::string v6[3] = 0;
    int v7 = (void **)(v6 + 3);
    *uint64_t v6 = off_101A4EAF0;
    *a3 = v6 + 3;
    a3[1] = v6;
    id v13 = +[NSMutableArray array];
    uint64_t v8 = *a1;
    uint64_t v9 = a1[1];
    while (v8 != v9)
    {
      xpc_object_t v10 = sub_100CD1A98(v8, a2);
      [v13 addObject:v10];

      v8 += 72;
    }
    unint64_t v11 = objc_opt_new();
    [v11 setDevices:v13];
    unint64_t v12 = *v7;
    *int v7 = v11;
  }
}

void sub_100CD1EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_100CD1EF8(std::string *__str@<X6>, void *a2@<X0>, os_log_t *a3@<X1>, uint64_t *a4@<X2>, uint64_t *a5@<X3>, uint64_t a6@<X4>, uint64_t a7@<X5>, uint64_t a8@<X7>, uint64_t a9@<X8>, const std::string **a10, uint64_t a11, uint64_t a12)
{
  long long v178 = 0u;
  long long v177 = 0u;
  long long v176 = 0u;
  long long v175 = 0u;
  *(_OWORD *)long long v174 = 0u;
  long long v173 = 0u;
  *(_OWORD *)long long v172 = 0u;
  long long v171 = 0u;
  *(_OWORD *)long long v170 = 0u;
  long long v169 = 0u;
  *(_OWORD *)int v168 = 0u;
  long long v167 = 0u;
  *(_OWORD *)long long v166 = 0u;
  long long v165 = 0u;
  *(_OWORD *)long long v164 = 0u;
  long long v133 = 0u;
  long long v132 = 0u;
  *(_OWORD *)uint64_t v131 = 0u;
  long long v130 = 0u;
  *(_OWORD *)uint64_t v129 = 0u;
  *(_OWORD *)uint64_t v128 = 0u;
  long long v127 = 0u;
  memset(v126, 0, sizeof(v126));
  std::string::operator=((std::string *)&v174[1], __str);
  id v14 = *a10;
  if (*a10)
  {
    if (SHIBYTE(v14[1].__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(__p, v14[1].__r_.__value_.__l.__data_, v14[1].__r_.__value_.__l.__size_);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)&v14[1].__r_.__value_.__l.__data_;
      std::string::size_type v125 = v14[1].__r_.__value_.__r.__words[2];
    }
    DWORD2(v178) = sub_100CD1928((const char *)__p);
    if (SHIBYTE(v125) < 0) {
      operator delete(__p[0]);
    }
    std::string::operator=((std::string *)v126, *a10);
    std::string::operator=((std::string *)&v126[24], *a10 + 2);
    std::string::operator=((std::string *)v128, *a10 + 4);
    std::string::operator=((std::string *)&v129[1], *a10 + 6);
    std::string::operator=((std::string *)v131, *a10 + 7);
  }
  long long v123 = 0u;
  memset(&v121, 0, sizeof(v121));
  memset(__src, 0, sizeof(__src));
  uint64_t v122 = &v123;
  long long v119 = 0u;
  memset(&v117, 0, sizeof(v117));
  memset(v116, 0, sizeof(v116));
  long long v118 = &v119;
  LODWORD(__src[0]) = 1;
  LODWORD(v116[0]) = 2;
  uint64_t v17 = *(void *)(a6 + 8);
  uint64_t v16 = (void *)(a6 + 8);
  uint64_t v15 = v17;
  if (v17)
  {
    xpc_object_t v18 = v16;
    uint64_t v19 = v15;
    do
    {
      int v20 = *(_DWORD *)(v19 + 32);
      BOOL v21 = v20 < 1;
      if (v20 >= 1) {
        char v22 = (uint64_t *)v19;
      }
      else {
        char v22 = (uint64_t *)(v19 + 8);
      }
      if (!v21) {
        xpc_object_t v18 = (void *)v19;
      }
      uint64_t v19 = *v22;
    }
    while (*v22);
    if (v18 != v16 && *((int *)v18 + 8) <= 1)
    {
      std::string::operator=((std::string *)&__src[1], (const std::string *)(v18 + 5));
      sub_10032AFC0((unsigned char *)&v167 + 8, (const std::string *)&__src[1]);
      uint64_t v15 = *v16;
    }
    if (v15)
    {
      BOOL v23 = v16;
      do
      {
        int v24 = *(_DWORD *)(v15 + 32);
        BOOL v25 = v24 < 2;
        if (v24 >= 2) {
          xpc_object_t v26 = (uint64_t *)v15;
        }
        else {
          xpc_object_t v26 = (uint64_t *)(v15 + 8);
        }
        if (!v25) {
          BOOL v23 = (void *)v15;
        }
        uint64_t v15 = *v26;
      }
      while (*v26);
      if (v23 != v16 && *((int *)v23 + 8) <= 2) {
        std::string::operator=((std::string *)&v116[1], (const std::string *)(v23 + 5));
      }
    }
  }
  uint64_t v27 = *(unsigned __int8 *)(a7 + 23);
  if ((v27 & 0x80u) != 0) {
    uint64_t v27 = *(void *)(a7 + 8);
  }
  if (v27)
  {
    std::string::operator=(&v121, (const std::string *)a7);
    std::string::operator=(&v117, (const std::string *)a7);
  }
  v115[1] = 0;
  v115[0] = 0;
  char v114 = (std::string *)v115;
  uint64_t v28 = *a5;
  uint64_t v29 = a5[1];
  if (*a5 != v29)
  {
    do
    {
      if (subscriber::isEsimCapable())
      {
        if (subscriber::isSimReady())
        {
          (**(void (***)(void **__return_ptr))*a2)(v153);
          *(_OWORD *)long long __dst = *(_OWORD *)v153;
          v153[1] = 0;
          v153[0] = 0;
          int isValidSimSlot = subscriber::isValidSimSlot();
          if (*(void *)&__dst[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&__dst[8]);
          }
          if (v153[1]) {
            sub_10004D2C8((std::__shared_weak_count *)v153[1]);
          }
          if (isValidSimSlot) {
            sub_100046BAC((uint64_t **)&v114, (void **)(v28 + 72), v28 + 72);
          }
        }
      }
      else if (!sub_10010E128(a11, (void **)(v28 + 72)))
      {
        uint64_t v163 = 0;
        memset(v162, 0, sizeof(v162));
        long long v161 = 0u;
        long long v160 = 0u;
        long long v159 = 0u;
        *(_OWORD *)long long v158 = 0u;
        long long v157 = 0u;
        *(_OWORD *)long long v156 = 0u;
        long long v155 = 0u;
        *(_OWORD *)long long v154 = 0u;
        *(_OWORD *)long long v153 = 0u;
        std::string::operator=((std::string *)v154, (const std::string *)(v28 + 72));
        long long v113 = 0u;
        memset(__stra, 0, sizeof(__stra));
        sub_100E63EA4((uint64_t)__stra);
        std::string::operator=((std::string *)&v159, (const std::string *)__stra);
        std::string::operator=((std::string *)((char *)&v160 + 8), (const std::string *)&__stra[24]);
        std::string::operator=((std::string *)v162, (const std::string *)(v28 + 120));
        std::string::operator=((std::string *)&v162[24], (const std::string *)(v28 + 144));
        uint64_t v31 = BYTE7(v160);
        if (SBYTE7(v160) < 0) {
          uint64_t v31 = *((void *)&v159 + 1);
        }
        if (!v31) {
          goto LABEL_264;
        }
        uint64_t v32 = HIBYTE(v161);
        if (v161 < 0) {
          uint64_t v32 = v161;
        }
        if (!v32)
        {
LABEL_264:
          if (sub_10010E194(*(void ***)(a12 + 8), v154))
          {
            uint64_t v33 = sub_10005DDEC(a12, v154);
            std::string::operator=((std::string *)&v159, (const std::string *)(v33 + 32));
            std::string::operator=((std::string *)((char *)&v160 + 8), (const std::string *)(v33 + 56));
            std::string::operator=((std::string *)v162, (const std::string *)(v33 + 80));
            std::string::operator=((std::string *)&v162[24], (const std::string *)(v33 + 104));
          }
        }
        if (subscriber::isSimReady())
        {
          (**(void (***)(void **__return_ptr))*a2)(v105);
          *(_OWORD *)long long __dst = *(_OWORD *)v105;
          v105[1] = 0;
          v105[0] = 0;
          BYTE1(v158[1]) = subscriber::isValidSimSlot();
          if (*(void *)&__dst[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&__dst[8]);
          }
          if (v105[1]) {
            sub_10004D2C8((std::__shared_weak_count *)v105[1]);
          }
        }
        else
        {
          BYTE1(v158[1]) = 0;
        }
        uint64_t v152 = 0;
        memset(v151, 0, sizeof(v151));
        *(_OWORD *)long long v150 = 0u;
        memset(buf, 0, sizeof(buf));
        if ((*(_DWORD *)(v28 + 4) & 0xFFFFFFFE) == 2) {
          int v34 = 2;
        }
        else {
          int v34 = 1;
        }
        *(_DWORD *)&uint8_t buf[4] = v34;
        sub_1000C5AB4((uint64_t)__dst, (uint64_t)v153);
        v105[1] = 0;
        v105[0] = 0;
        v106[0] = 0;
        int v134 = (Registry *)v105;
        uint32_t v135 = 0;
        v105[0] = operator new(0xD8uLL);
        v105[1] = v105[0];
        v106[0] = (char *)v105[0] + 216;
        v105[1] = (void *)sub_10099279C((uint64_t)v106, (uint64_t)__dst, (uint64_t)&v147 + 8, (uint64_t)v105[0]);
        sub_1008793A4((uint64_t)v151 + 8, (uint64_t)v105);
        int v134 = (Registry *)v105;
        sub_1000C57C8((void ***)&v134);
        sub_1000C584C((uint64_t)__dst);
        uint64_t v35 = v177;
        if ((unint64_t)v177 >= *((void *)&v177 + 1))
        {
          uint64_t v36 = sub_1006D3270((uint64_t *)&v176 + 1, (uint64_t)buf);
        }
        else
        {
          sub_1000C5DA8(v177, (uint64_t)buf);
          uint64_t v36 = v35 + 88;
        }
        *(void *)&long long v177 = v36;
        uint64_t v111 = 0;
        long long v109 = 0u;
        *(_OWORD *)uint64_t v110 = 0u;
        long long v107 = 0u;
        *(_OWORD *)long long v108 = 0u;
        *(_OWORD *)long long v105 = 0u;
        *(_OWORD *)uint64_t v106 = 0u;
        (**(void (***)(Registry **__return_ptr))*a2)(&v134);
        ServiceMap = (std::mutex *)Registry::getServiceMap(v134);
        xpc_object_t v38 = ServiceMap;
        if (v39 < 0)
        {
          xpc_object_t v40 = (unsigned __int8 *)(v39 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v41 = 5381;
          do
          {
            uint64_t v39 = v41;
            unsigned int v42 = *v40++;
            uint64_t v41 = (33 * v41) ^ v42;
          }
          while (v42);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long __dst = v39;
        xpc_object_t v43 = sub_10004D37C(&v38[1].__m_.__sig, (unint64_t *)__dst);
        if (v43)
        {
          uint64_t v45 = v43[3];
          xpc_object_t v44 = (std::__shared_weak_count *)v43[4];
          if (v44)
          {
            atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v38);
            atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v44);
            char v46 = 0;
            goto LABEL_72;
          }
        }
        else
        {
          uint64_t v45 = 0;
        }
        std::mutex::unlock(v38);
        xpc_object_t v44 = 0;
        char v46 = 1;
LABEL_72:
        if (*(char *)(v28 + 95) < 0)
        {
          sub_10004FC84(__dst, *(void **)(v28 + 72), *(void *)(v28 + 80));
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)(v28 + 72);
          *(void *)&__dst[16] = *(void *)(v28 + 88);
        }
        (*(void (**)(void **__return_ptr, uint64_t, unsigned char *))(*(void *)v45 + 168))(v105, v45, __dst);
        if ((__dst[23] & 0x80000000) != 0)
        {
          operator delete(*(void **)__dst);
          if ((v46 & 1) == 0) {
LABEL_77:
          }
            sub_10004D2C8(v44);
        }
        else if ((v46 & 1) == 0)
        {
          goto LABEL_77;
        }
        if (v135) {
          sub_10004D2C8(v135);
        }
        memset(v148, 0, sizeof(v148));
        long long v147 = 0u;
        long long v146 = 0u;
        long long v145 = 0u;
        long long v144 = 0u;
        long long v143 = 0u;
        long long v142 = 0u;
        long long v141 = 0u;
        memset(v140, 0, sizeof(v140));
        long long v139 = 0u;
        long long v138 = 0u;
        *(_OWORD *)std::string::size_type v137 = 0u;
        memset(__dst, 0, sizeof(__dst));
        xpc_object_t v47 = sub_100046F68(a8, v154);
        if ((void **)(a8 + 8) != v47)
        {
          xpc_object_t v48 = v47;
          std::string::operator=((std::string *)__dst, (const std::string *)(v47 + 7));
          *(_WORD *)&__dst[24] = *((_WORD *)v48 + 40);
          sub_100179AF8((std::string *)v137, (const std::string *)(v48 + 11));
          sub_100179AF8((std::string *)&v139, (const std::string *)v48 + 5);
          sub_100179AF8((std::string *)&v140[1], (const std::string *)(v48 + 19));
          sub_100179AF8((std::string *)&v142, (const std::string *)(v48 + 23));
          LOWORD(v144) = *((_WORD *)v48 + 108);
          std::string::operator=((std::string *)((char *)&v144 + 8), (const std::string *)(v48 + 28));
          LOWORD(v146) = *((_WORD *)v48 + 124);
          BYTE2(v146) = *((unsigned char *)v48 + 250);
          sub_100179AF8((std::string *)((char *)&v146 + 8), (const std::string *)(v48 + 32));
          *(_OWORD *)((char *)v148 + 8) = *((_OWORD *)v48 + 18);
          WORD4(v148[1]) = *((_WORD *)v48 + 152);
        }
        int v49 = *(_DWORD *)(v28 + 4);
        if (v49 == 2)
        {
          id v50 = (std::__shared_weak_count *)a2[1];
          v103[0] = *a2;
          v103[1] = v50;
          if (v50) {
            atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_100CD3710((uint64_t)v116, (uint64_t)v105, v28, (uint64_t)v103, (uint64_t)__dst, a12, (uint64_t)a4, a3);
LABEL_92:
          if (v50) {
            sub_10004D2C8(v50);
          }
        }
        else if (v49 == 1)
        {
          id v50 = (std::__shared_weak_count *)a2[1];
          v104[0] = *a2;
          v104[1] = v50;
          if (v50) {
            atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_100CD3710((uint64_t)__src, (uint64_t)v105, v28, (uint64_t)v104, (uint64_t)__dst, a12, (uint64_t)a4, a3);
          goto LABEL_92;
        }
        sub_1000C5578((uint64_t)__dst);
        if (SHIBYTE(v111) < 0) {
          operator delete(v110[0]);
        }
        if (SBYTE7(v109) < 0) {
          operator delete(v108[0]);
        }
        if (SHIBYTE(v107) < 0) {
          operator delete(v106[1]);
        }
        if (SHIBYTE(v106[0]) < 0) {
          operator delete(v105[0]);
        }
        if ((_BYTE)v152)
        {
          *(void *)long long __dst = (char *)v151 + 8;
          sub_1000C57C8((void ***)__dst);
        }
        if (SBYTE7(v151[0]) < 0) {
          operator delete(v150[0]);
        }
        if (SHIBYTE(v113) < 0) {
          operator delete(*(void **)&__stra[24]);
        }
        if ((__stra[23] & 0x80000000) != 0) {
          operator delete(*(void **)__stra);
        }
        sub_1000C584C((uint64_t)v153);
      }
      v28 += 168;
    }
    while (v28 != v29);
  }
  uint64_t v51 = *((void *)&v176 + 1);
  if (*((void *)&v176 + 1) == (void)v177)
  {
    *(void *)&v140[0] = 0;
    long long v139 = 0u;
    long long v138 = 0u;
    *(_OWORD *)std::string::size_type v137 = 0u;
    memset(__dst, 0, sizeof(__dst));
    *(_DWORD *)&__dst[4] = 1;
    if (*((void *)&v176 + 1) >= *((void *)&v177 + 1))
    {
      uint64_t v52 = sub_100992820((uint64_t *)&v176 + 1, (uint64_t)__dst);
    }
    else
    {
      sub_1000C5DA8(*((uint64_t *)&v176 + 1), (uint64_t)__dst);
      uint64_t v52 = v51 + 88;
    }
    *(void *)&long long v177 = v52;
    if (LOBYTE(v140[0]))
    {
      v153[0] = (char *)&v138 + 8;
      sub_1000C57C8((void ***)v153);
    }
    if (SBYTE7(v138) < 0) {
      operator delete(v137[0]);
    }
  }
  uint64_t v53 = *a4;
  uint64_t v54 = a4[1];
  if (*a4 != v54)
  {
    do
    {
      if (*(_DWORD *)v53 == 2)
      {
        uint64_t v55 = v177;
        if ((unint64_t)v177 >= *((void *)&v177 + 1))
        {
          uint64_t v56 = sub_1006D3270((uint64_t *)&v176 + 1, v53);
        }
        else
        {
          sub_1000C5DA8(v177, v53);
          uint64_t v56 = v55 + 88;
        }
        *(void *)&long long v177 = v56;
        if (*(unsigned char *)(v53 + 80))
        {
          uint64_t v57 = *(void *)(v56 - 32);
LABEL_127:
          for (uint64_t i = *(void *)(v56 - 24); v57 != i; *(void *)(v56 - 24) = i)
          {
            if (*(unsigned char *)(v57 + 88))
            {
              sub_10032FC24(v57 + 216, i, v57);
              uint64_t i = v59;
              for (uint64_t j = *(void *)(v56 - 24); j != i; uint64_t j = sub_1000C584C(j - 216))
                ;
            }
            else
            {
              uint64_t v61 = (_OWORD *)(v57 + 16);
              if (!sub_10010E128(a11, (void **)(v57 + 16)))
              {
                memset(v148, 0, sizeof(v148));
                long long v147 = 0u;
                long long v146 = 0u;
                long long v145 = 0u;
                long long v144 = 0u;
                long long v143 = 0u;
                long long v142 = 0u;
                long long v141 = 0u;
                memset(v140, 0, sizeof(v140));
                long long v139 = 0u;
                long long v138 = 0u;
                *(_OWORD *)std::string::size_type v137 = 0u;
                memset(__dst, 0, sizeof(__dst));
                unint64_t v64 = sub_100046F68(a8, (void **)(v57 + 16));
                if ((void **)(a8 + 8) != v64)
                {
                  uint64_t v65 = v64;
                  std::string::operator=((std::string *)__dst, (const std::string *)(v64 + 7));
                  *(_WORD *)&__dst[24] = *((_WORD *)v65 + 40);
                  sub_100179AF8((std::string *)v137, (const std::string *)(v65 + 11));
                  sub_100179AF8((std::string *)&v139, (const std::string *)v65 + 5);
                  sub_100179AF8((std::string *)&v140[1], (const std::string *)(v65 + 19));
                  sub_100179AF8((std::string *)&v142, (const std::string *)(v65 + 23));
                  LOWORD(v144) = *((_WORD *)v65 + 108);
                  std::string::operator=((std::string *)((char *)&v144 + 8), (const std::string *)(v65 + 28));
                  LOWORD(v146) = *((_WORD *)v65 + 124);
                  BYTE2(v146) = *((unsigned char *)v65 + 250);
                  sub_100179AF8((std::string *)((char *)&v146 + 8), (const std::string *)(v65 + 32));
                  *(_OWORD *)((char *)v148 + 8) = *((_OWORD *)v65 + 18);
                  WORD4(v148[1]) = *((_WORD *)v65 + 152);
                }
                *(void *)&long long v159 = 0;
                *(_OWORD *)long long v158 = 0u;
                long long v157 = 0u;
                *(_OWORD *)long long v156 = 0u;
                long long v155 = 0u;
                *(_OWORD *)long long v154 = 0u;
                *(_OWORD *)long long v153 = 0u;
                (**(void (***)(uint8_t *__return_ptr))*a2)(buf);
                unint64_t v66 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
                unint64_t v67 = v66;
                if (v68 < 0)
                {
                  id v69 = (unsigned __int8 *)(v68 & 0x7FFFFFFFFFFFFFFFLL);
                  uint64_t v70 = 5381;
                  do
                  {
                    uint64_t v68 = v70;
                    unsigned int v71 = *v69++;
                    uint64_t v70 = (33 * v70) ^ v71;
                  }
                  while (v71);
                }
                std::mutex::lock(v66);
                v105[0] = (void *)v68;
                uint64_t v72 = sub_10004D37C(&v67[1].__m_.__sig, (unint64_t *)v105);
                if (v72)
                {
                  uint64_t v74 = v72[3];
                  uint64_t v73 = (std::__shared_weak_count *)v72[4];
                  if (v73)
                  {
                    atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
                    std::mutex::unlock(v67);
                    atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v73);
                    char v75 = 0;
                    goto LABEL_148;
                  }
                }
                else
                {
                  uint64_t v74 = 0;
                }
                std::mutex::unlock(v67);
                uint64_t v73 = 0;
                char v75 = 1;
LABEL_148:
                if (*(char *)(v57 + 39) < 0)
                {
                  sub_10004FC84(v105, *(void **)(v57 + 16), *(void *)(v57 + 24));
                }
                else
                {
                  *(_OWORD *)long long v105 = *v61;
                  v106[0] = *(void **)(v57 + 32);
                }
                (*(void (**)(void **__return_ptr, uint64_t, void **))(*(void *)v74 + 168))(v153, v74, v105);
                if (SHIBYTE(v106[0]) < 0)
                {
                  operator delete(v105[0]);
                  if ((v75 & 1) == 0) {
LABEL_153:
                  }
                    sub_10004D2C8(v73);
                }
                else if ((v75 & 1) == 0)
                {
                  goto LABEL_153;
                }
                if (*(void *)&buf[8]) {
                  sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
                }
                if ((*(unsigned int (**)(void))(*(void *)*a2 + 40))()
                  && *(unsigned char *)(v57 + 89)
                  && !sub_10010E128((uint64_t)&v114, (void **)(v57 + 16)))
                {
                  uint64_t v76 = *a3;
                  if (os_log_type_enabled(*a3, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_1000E8F34(v114, (std::string *)v115, ",", 1uLL, (std::string *)v105);
                    uint64_t v77 = v105;
                    if (SHIBYTE(v106[0]) < 0) {
                      uint64_t v77 = (void **)v105[0];
                    }
                    if (*(char *)(v57 + 39) < 0) {
                      uint64_t v61 = *(_OWORD **)v61;
                    }
                    *(_DWORD *)long long buf = 136315394;
                    *(void *)&uint8_t buf[4] = v77;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = v61;
                    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I Enable plans [%s] do NOT contain active eSIM plan [%s]. reset isActive state to false", buf, 0x16u);
                    if (SHIBYTE(v106[0]) < 0) {
                      operator delete(v105[0]);
                    }
                  }
                  *(unsigned char *)(v57 + 89) = 0;
                }
                int v78 = *(_DWORD *)(v53 + 4);
                if (v78 == 2)
                {
                  long long v79 = (std::__shared_weak_count *)a2[1];
                  v100[0] = *a2;
                  v100[1] = v79;
                  if (v79) {
                    atomic_fetch_add_explicit(&v79->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  sub_10030DA1C(v99, (long long *)__dst);
                  sub_100CD3D58((uint64_t)v116, (uint64_t)v153, a5, v57, (uint64_t)v100, (uint64_t)v99, a12, (uint64_t)a4, a3);
                  long long v80 = v99;
LABEL_177:
                  sub_1000C5578((uint64_t)v80);
                  if (v79) {
                    sub_10004D2C8(v79);
                  }
                }
                else if (v78 == 1)
                {
                  long long v79 = (std::__shared_weak_count *)a2[1];
                  v102[0] = *a2;
                  v102[1] = v79;
                  if (v79) {
                    atomic_fetch_add_explicit(&v79->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  sub_10030DA1C(v101, (long long *)__dst);
                  sub_100CD3D58((uint64_t)__src, (uint64_t)v153, a5, v57, (uint64_t)v102, (uint64_t)v101, a12, (uint64_t)a4, a3);
                  long long v80 = v101;
                  goto LABEL_177;
                }
                if (SBYTE7(v159) < 0) {
                  operator delete(v158[0]);
                }
                if (SBYTE7(v157) < 0) {
                  operator delete(v156[0]);
                }
                if (SHIBYTE(v155) < 0) {
                  operator delete(v154[1]);
                }
                if (SHIBYTE(v154[0]) < 0) {
                  operator delete(v153[0]);
                }
                v57 += 216;
                sub_1000C5578((uint64_t)__dst);
                goto LABEL_127;
              }
              sub_10032FC24(v57 + 216, *(void *)(v56 - 24), v57);
              uint64_t i = v62;
              for (uint64_t k = *(void *)(v56 - 24); k != i; uint64_t k = sub_1000C584C(k - 216))
                ;
            }
          }
        }
      }
      v53 += 88;
    }
    while (v53 != v54);
  }
  *(_DWORD *)long long __dst = __src[0];
  if (SHIBYTE(__src[3]) < 0)
  {
    sub_10004FC84(&__dst[8], __src[1], (unint64_t)__src[2]);
  }
  else
  {
    *(_OWORD *)&__dst[8] = *(_OWORD *)&__src[1];
    *(void **)&__dst[24] = __src[3];
  }
  if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(v137, v121.__r_.__value_.__l.__data_, v121.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)std::string::size_type v137 = *(_OWORD *)&v121.__r_.__value_.__l.__data_;
    *(void *)&long long v138 = *((void *)&v121.__r_.__value_.__l + 2);
  }
  sub_100312438((uint64_t *)&v138 + 1, (uint64_t)&v122);
  LODWORD(v140[0]) = v116[0];
  if (SHIBYTE(v116[3]) < 0)
  {
    sub_10004FC84((unsigned char *)v140 + 8, v116[1], (unint64_t)v116[2]);
  }
  else
  {
    *(_OWORD *)((char *)v140 + 8) = *(_OWORD *)&v116[1];
    *((void **)&v140[1] + 1) = v116[3];
  }
  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(&v141, v117.__r_.__value_.__l.__data_, v117.__r_.__value_.__l.__size_);
  }
  else
  {
    long long v141 = *(_OWORD *)&v117.__r_.__value_.__l.__data_;
    *(void *)&long long v142 = *((void *)&v117.__r_.__value_.__l + 2);
  }
  sub_100312438((uint64_t *)&v142 + 1, (uint64_t)&v118);
  uint64_t v81 = *((void *)&v132 + 1);
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v133 + 1) - *((void *)&v132 + 1)) >> 4) >= 2)
  {
    unint64_t v85 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v133 - *((void *)&v132 + 1)) >> 4);
    if (v85 >= 2)
    {
      for (uint64_t m = 0; m != 160; m += 80)
        sub_1003083C8(v81 + m, (uint64_t)&__dst[m]);
      uint64_t v89 = v81 + 160;
      for (uint64_t n = v133; v89 != n; sub_1000C53DC(n))
        n -= 80;
      *(void *)&long long v133 = v89;
      goto LABEL_221;
    }
    if ((void)v133 != *((void *)&v132 + 1))
    {
      uint64_t v86 = 16 * ((uint64_t)(v133 - *((void *)&v132 + 1)) >> 4);
      long long v87 = __dst;
      do
      {
        sub_1003083C8(v81, (uint64_t)v87);
        v87 += 80;
        v81 += 80;
        v86 -= 80;
      }
      while (v86);
      uint64_t v81 = v133;
    }
    uint64_t v84 = sub_100CDD72C((uint64_t)&__dst[80 * v85], (uint64_t)&v144, v81);
  }
  else
  {
    sub_10099214C((void **)&v132 + 1);
    unint64_t v82 = 0x999999999999999ALL * ((uint64_t)(*((void *)&v133 + 1) - *((void *)&v132 + 1)) >> 4);
    if (v82 <= 2) {
      unint64_t v82 = 2;
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v133 + 1) - *((void *)&v132 + 1)) >> 4) >= 0x199999999999999) {
      unint64_t v83 = 0x333333333333333;
    }
    else {
      unint64_t v83 = v82;
    }
    sub_100312288((void *)&v132 + 1, v83);
    uint64_t v84 = sub_100CDD72C((uint64_t)__dst, (uint64_t)&v144, v133);
  }
  *(void *)&long long v133 = v84;
LABEL_221:
  for (iuint64_t i = 0; ii != -160; ii -= 80)
  {
    uint64_t v92 = (void **)&__dst[ii];
    sub_1000C5440((uint64_t)&v142 + ii + 8, *(void **)((char *)&v143 + ii));
    if (*((char *)&v142 + ii + 7) < 0) {
      operator delete(v92[14]);
    }
    if (*((char *)v92 + 111) < 0) {
      operator delete(*((void **)&v140[ii / 0x10] + 1));
    }
  }
  sub_100311D64(a9, (uint64_t)v164);
  sub_10031203C((char *)(a9 + 240), (long long *)v126);
  sub_10005CD2C((uint64_t)&v114, v115[0]);
  sub_1000C5440((uint64_t)&v118, (void *)v119);
  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v117.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v116[3]) < 0) {
    operator delete(v116[1]);
  }
  sub_1000C5440((uint64_t)&v122, (void *)v123);
  if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v121.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__src[3]) < 0) {
    operator delete(__src[1]);
  }
  *(void *)long long __dst = (char *)&v132 + 8;
  sub_1000C5358((void ***)__dst);
  if (SBYTE7(v132) < 0) {
    operator delete(v131[0]);
  }
  if (SHIBYTE(v130) < 0) {
    operator delete(v129[1]);
  }
  if (SHIBYTE(v129[0]) < 0) {
    operator delete(v128[0]);
  }
  if (SHIBYTE(v127) < 0) {
    operator delete(*(void **)&v126[24]);
  }
  if ((v126[23] & 0x80000000) != 0) {
    operator delete(*(void **)v126);
  }
  *(void *)long long __dst = (char *)&v176 + 8;
  sub_1000C56F4((void ***)__dst);
  if (SHIBYTE(v175) < 0) {
    operator delete(v174[1]);
  }
  if (SBYTE7(v173) < 0) {
    operator delete(v172[0]);
  }
  if (BYTE8(v169))
  {
    if (SBYTE7(v171) < 0) {
      operator delete(v170[0]);
    }
    BYTE8(v169) = 0;
  }
  if (BYTE8(v167))
  {
    if (SBYTE7(v169) < 0) {
      operator delete(v168[0]);
    }
    BYTE8(v167) = 0;
  }
  if (SBYTE7(v167) < 0) {
    operator delete(v166[0]);
  }
  if (LOBYTE(v164[0]) && SHIBYTE(v165) < 0) {
    operator delete(v164[1]);
  }
}

void sub_100CD33E0(_Unwind_Exception *a1)
{
}

void sub_100CD3710(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, os_log_t *a8)
{
  id v13 = (uint64_t **)(a1 + 56);
  id v14 = (void **)(a3 + 72);
  *(void *)&long long v52 = a3 + 72;
  uint64_t v15 = sub_100879CE8((uint64_t **)(a1 + 56), (void **)(a3 + 72), (uint64_t)&unk_10144E20E, (long long **)&v52);
  std::string::operator=((std::string *)(v15 + 25), (const std::string *)a5);
  *((_WORD *)v15 + 112) = *(_WORD *)(a5 + 24);
  sub_100179AF8((std::string *)(v15 + 29), (const std::string *)(a5 + 32));
  sub_100179AF8((std::string *)v15 + 11, (const std::string *)(a5 + 64));
  sub_100179AF8((std::string *)(v15 + 37), (const std::string *)(a5 + 96));
  sub_100179AF8((std::string *)(v15 + 41), (const std::string *)(a5 + 128));
  *((_WORD *)v15 + 180) = *(_WORD *)(a5 + 160);
  std::string::operator=((std::string *)(v15 + 46), (const std::string *)(a5 + 168));
  __int16 v16 = *(_WORD *)(a5 + 192);
  *((unsigned char *)v15 + 394) = *(unsigned char *)(a5 + 194);
  *((_WORD *)v15 + 196) = v16;
  sub_100179AF8((std::string *)(v15 + 50), (const std::string *)(a5 + 200));
  uint64_t v36 = a6;
  long long v17 = *(_OWORD *)(a5 + 232);
  *((_WORD *)v15 + 224) = *(_WORD *)(a5 + 248);
  *((_OWORD *)v15 + 27) = v17;
  memset(&__p, 0, sizeof(__p));
  (***(void (****)(long long *__return_ptr))a4)(&v52);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)v52);
  uint64_t v19 = ServiceMap;
  if (v20 < 0)
  {
    BOOL v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v41 = v20;
  int v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)&v41);
  if (v24)
  {
    uint64_t v26 = v24[3];
    BOOL v25 = (std::__shared_weak_count *)v24[4];
    if (v25)
    {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v25);
      char v27 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  std::mutex::unlock(v19);
  BOOL v25 = 0;
  char v27 = 1;
LABEL_9:
  if (*((void *)&v52 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v52 + 1));
  }
  if (!v26) {
    goto LABEL_17;
  }
  long long v53 = 0u;
  long long v54 = 0u;
  long long v52 = 0u;
  sub_100E63EA4((uint64_t)&v52);
  (*(void (**)(long long *__return_ptr, uint64_t, long long *))(*(void *)v26 + 24))(&v41, v26, &v52);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v41;
  __p.__r_.__value_.__r.__words[2] = v42;
  if (SHIBYTE(v54) < 0) {
    operator delete(*((void **)&v53 + 1));
  }
  if ((SBYTE7(v53) & 0x80000000) == 0)
  {
LABEL_17:
    if (v27) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  operator delete((void *)v52);
  if ((v27 & 1) == 0) {
LABEL_18:
  }
    sub_10004D2C8(v25);
LABEL_19:
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    *(void *)&long long v52 = v14;
    uint64_t v29 = sub_100879CE8(v13, v14, (uint64_t)&unk_10144E20E, (long long **)&v52);
    std::string::operator=((std::string *)(v29 + 19), &__p);
  }
  *(void *)&long long v52 = v14;
  xpc_object_t v30 = sub_100879CE8(v13, v14, (uint64_t)&unk_10144E20E, (long long **)&v52);
  std::string::operator=((std::string *)(v30 + 7), (const std::string *)(a2 + 80));
  *(void *)&long long v52 = v14;
  uint64_t v31 = sub_100879CE8(v13, v14, (uint64_t)&unk_10144E20E, (long long **)&v52);
  std::string::operator=((std::string *)(v31 + 10), (const std::string *)a2);
  std::string::operator=((std::string *)(v31 + 13), (const std::string *)(a2 + 24));
  if (*(_DWORD *)(a3 + 8) == 5)
  {
    *(void *)&long long v52 = v14;
    uint64_t v32 = sub_100879CE8(v13, v14, (uint64_t)&unk_10144E20E, (long long **)&v52);
    sub_100093B44((std::string *)(v32 + 41), (const std::string *)(a3 + 96));
  }
  if (*(void *)a4)
  {
    uint64_t v49 = 0;
    long long v48 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v41 = 0u;
    sub_10002E664((uint64_t)&v52, a3);
    xpc_object_t v38 = 0;
    uint64_t v39 = 0;
    xpc_object_t v40 = 0;
    v51[0] = (void **)&v38;
    v51[1] = 0;
    xpc_object_t v38 = (long long *)operator new(0xA8uLL);
    uint64_t v39 = v38;
    uint64_t v33 = (long long *)((char *)v38 + 168);
    xpc_object_t v40 = (char *)v38 + 168;
    sub_10002E664((uint64_t)v38, (uint64_t)&v52);
    uint64_t v39 = v33;
    sub_100CDB320(a8, (uint64_t)v14, (uint64_t *)&v38, v36, (uint64_t)&v41);
    v51[0] = (void **)&v38;
    sub_10008A88C(v51);
    if (v62 < 0) {
      operator delete(v61);
    }
    if (v60 < 0) {
      operator delete(v59);
    }
    if (v58 < 0) {
      operator delete(v57);
    }
    if (v56 < 0) {
      operator delete(v55);
    }
    v51[0] = (void **)&v54 + 1;
    sub_10002E39C(v51);
    if ((void)v53)
    {
      *((void *)&v53 + 1) = v53;
      operator delete((void *)v53);
    }
    if ((_BYTE)v49)
    {
      (*(void (**)(long long *__return_ptr))(**(void **)a4 + 160))(&v52);
      xpc_object_t v38 = (long long *)v14;
      int v34 = sub_100879CE8(v13, v14, (uint64_t)&unk_10144E20E, &v38);
      uint64_t v35 = v34 + 16;
      if (*((char *)v34 + 151) < 0) {
        operator delete((void *)*v35);
      }
      *(_OWORD *)uint64_t v35 = v52;
      _OWORD v35[2] = v53;
    }
    sub_10010B788((uint64_t)&v41);
  }
  *(void *)&long long v52 = v14;
  sub_100879CE8(v13, v14, (uint64_t)&unk_10144E20E, (long long **)&v52);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100CD3C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a47 < 0) {
    operator delete(__p);
  }
  sub_10010B788((uint64_t)&a15);
  if (a38 < 0) {
    operator delete(a33);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CD3D58(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_log_t *a9)
{
  id v14 = (uint64_t **)(a1 + 56);
  uint64_t v15 = (void **)(a4 + 16);
  *(void *)&v36[0] = a4 + 16;
  __int16 v16 = sub_100879CE8((uint64_t **)(a1 + 56), (void **)(a4 + 16), (uint64_t)&unk_10144E20E, (long long **)v36);
  std::string::operator=((std::string *)(v16 + 25), (const std::string *)a6);
  *((_WORD *)v16 + 112) = *(_WORD *)(a6 + 24);
  sub_100179AF8((std::string *)(v16 + 29), (const std::string *)(a6 + 32));
  sub_100179AF8((std::string *)v16 + 11, (const std::string *)(a6 + 64));
  sub_100179AF8((std::string *)(v16 + 37), (const std::string *)(a6 + 96));
  sub_100179AF8((std::string *)(v16 + 41), (const std::string *)(a6 + 128));
  *((_WORD *)v16 + 180) = *(_WORD *)(a6 + 160);
  std::string::operator=((std::string *)(v16 + 46), (const std::string *)(a6 + 168));
  char v17 = *(unsigned char *)(a6 + 194);
  *((_WORD *)v16 + 196) = *(_WORD *)(a6 + 192);
  *((unsigned char *)v16 + 394) = v17;
  sub_100179AF8((std::string *)(v16 + 50), (const std::string *)(a6 + 200));
  long long v18 = *(_OWORD *)(a6 + 232);
  *((_WORD *)v16 + 224) = *(_WORD *)(a6 + 248);
  *((_OWORD *)v16 + 27) = v18;
  *(void *)&v36[0] = v15;
  uint64_t v19 = sub_100879CE8(v14, v15, (uint64_t)&unk_10144E20E, (long long **)v36);
  std::string::operator=((std::string *)(v19 + 7), (const std::string *)(a2 + 80));
  *(void *)&v36[0] = v15;
  uint64_t v20 = sub_100879CE8(v14, v15, (uint64_t)&unk_10144E20E, (long long **)v36);
  std::string::operator=((std::string *)(v20 + 10), (const std::string *)a2);
  uint64_t result = (uint64_t)std::string::operator=((std::string *)(v20 + 13), (const std::string *)(a2 + 24));
  if (*(void *)a5)
  {
    uint64_t v37 = 0;
    memset(v36, 0, sizeof(v36));
    sub_100CDB320(a9, (uint64_t)v15, a3, a7, (uint64_t)v36);
    if ((_BYTE)v37)
    {
      (*(void (**)(long long *__return_ptr))(**(void **)a5 + 160))(&v34);
      xpc_object_t v38 = v15;
      uint64_t v22 = sub_100879CE8(v14, v15, (uint64_t)&unk_10144E20E, (long long **)&v38);
      unsigned int v23 = v22 + 16;
      if (*((char *)v22 + 151) < 0) {
        operator delete((void *)*v23);
      }
      *(_OWORD *)unsigned int v23 = v34;
      std::string v23[2] = v35;
    }
    uint64_t result = sub_10010B788((uint64_t)v36);
  }
  uint64_t v24 = *a3;
  uint64_t v25 = a3[1];
  if (*a3 != v25)
  {
    while (1)
    {
      uint64_t v26 = *(unsigned __int8 *)(v24 + 95);
      if ((v26 & 0x80u) == 0) {
        uint64_t v27 = *(unsigned __int8 *)(v24 + 95);
      }
      else {
        uint64_t v27 = *(void *)(v24 + 80);
      }
      uint64_t v28 = *(unsigned __int8 *)(a4 + 39);
      int v29 = (char)v28;
      if ((v28 & 0x80u) != 0) {
        uint64_t v28 = *(void *)(a4 + 24);
      }
      if (v27 != v28) {
        goto LABEL_25;
      }
      xpc_object_t v30 = v29 >= 0 ? v15 : (void **)*v15;
      if ((v26 & 0x80) == 0) {
        break;
      }
      uint64_t result = memcmp(*(const void **)(v24 + 72), v30, *(void *)(v24 + 80));
      if (!result) {
        goto LABEL_24;
      }
LABEL_25:
      v24 += 168;
      if (v24 == v25) {
        return result;
      }
    }
    if (*(unsigned char *)(v24 + 95))
    {
      uint64_t v31 = 0;
      while (*(unsigned __int8 *)(v24 + v31 + 72) == *((unsigned __int8 *)v30 + v31))
      {
        if (v26 == ++v31) {
          goto LABEL_24;
        }
      }
      goto LABEL_25;
    }
LABEL_24:
    *(void *)&v36[0] = v15;
    uint64_t v32 = sub_100879CE8(v14, v15, (uint64_t)&unk_10144E20E, (long long **)v36);
    sub_100093B44((std::string *)(v32 + 41), (const std::string *)(v24 + 96));
    *(void *)&v36[0] = v15;
    uint64_t result = (uint64_t)sub_100879CE8(v14, v15, (uint64_t)&unk_10144E20E, (long long **)v36);
    goto LABEL_25;
  }
  return result;
}

void sub_100CD4088(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10010B788((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_100CD40B4(uint64_t a1@<X0>, void *a2@<X1>, os_log_t *a3@<X2>, const std::string **a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  memset(&v34, 0, sizeof(v34));
  if (*(unsigned char *)(a1 + 96))
  {
    uint64_t v14 = *(unsigned __int8 *)(a1 + 95);
    if ((v14 & 0x80u) != 0) {
      uint64_t v14 = *(void *)(a1 + 80);
    }
    if (v14) {
      std::string::operator=(&v34, (const std::string *)(a1 + 72));
    }
  }
  memset(v73, 0, 32);
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v66 = 0u;
  memset(v65, 0, sizeof(v65));
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  sub_100CD1EF8((std::string *)(a1 + 104), a2, a3, (uint64_t *)a1, (uint64_t *)(a1 + 24), a1 + 48, (uint64_t)&v34, a1 + 128, (uint64_t)&v53, a4, a5, a6);
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  PB::Writer::Writer((PB::Writer *)&v31);
  memset(&v30[1], 0, 32);
  uint64_t v29 = 0;
  v30[0] = &off_101A17F50;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  sub_10031203C((char *)buf, &v66);
  buf[144] = 1;
  int v15 = sub_1006D10BC((uint64_t)&v53, (uint64_t)buf, (uint64_t)v30);
  sub_10023F804((uint64_t)buf);
  if (v15)
  {
    sub_1008E2D1C((uint64_t)v30, (PB::Writer *)&v31);
    sub_10006E4A8(&v27, v32, v31, v31 - v32);
    sub_100058DB0(__p, "Source_TransferData_");
    sub_1008E268C((uint64_t)buf, (uint64_t)v30);
    uint64_t v22 = 0;
    unsigned int v23 = 0;
    uint64_t v24 = 0;
    v35[0] = (void **)&v22;
    v35[1] = 0;
    uint64_t v22 = (void **)operator new(0x28uLL);
    unsigned int v23 = v22;
    __int16 v16 = v22 + 5;
    uint64_t v24 = v22 + 5;
    sub_1008E268C((uint64_t)v22, (uint64_t)buf);
    unsigned int v23 = v16;
    sub_100CD467C(a3, (uint64_t **)__p, (uint64_t *)&v22);
    v35[0] = (void **)&v22;
    sub_100B61728(v35);
    sub_1008E25A0((PB::Base *)buf);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    char v17 = *a3;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Unable to serialize device info", buf, 2u);
    }
  }
  memset(buf, 0, 56);
  sub_100311D64((uint64_t)&v36, (uint64_t)&v53);
  char v51 = 1;
  sub_1006D1D84(&v36, (uint64_t)buf);
  if (v51)
  {
    uint64_t v22 = (void **)&v50;
    sub_1000C56F4(&v22);
    if (v49 < 0) {
      operator delete(v48);
    }
    if (v47 < 0) {
      operator delete(v46);
    }
    if (v43)
    {
      if (v45 < 0) {
        operator delete(v44);
      }
      char v43 = 0;
    }
    if (v40)
    {
      if (v42 < 0) {
        operator delete(v41);
      }
      char v40 = 0;
    }
    if (v39 < 0) {
      operator delete(v38);
    }
    if (v36.__r_.__value_.__s.__data_[0])
    {
      if (v37 < 0) {
        operator delete((void *)v36.__r_.__value_.__l.__size_);
      }
      v36.__r_.__value_.__s.__data_[0] = 0;
    }
  }
  *(void *)a7 = 0;
  *(void *)(a7 + 8) = 0;
  *(void *)(a7 + 16) = 0;
  sub_10005C928((void *)a7, v27, (uint64_t)v28, v28 - (unsigned char *)v27);
  long long v18 = (unsigned char *)(a7 + 24);
  if ((char)buf[23] < 0)
  {
    sub_10004FC84(v18, *(void **)buf, *(unint64_t *)&buf[8]);
    int v20 = (char)buf[23];
    long long v21 = *(_OWORD *)&buf[40];
    *(_OWORD *)(a7 + 48) = *(_OWORD *)&buf[24];
    *(_OWORD *)(a7 + 64) = v21;
    if (v20 < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    *(_OWORD *)long long v18 = *(_OWORD *)buf;
    *(void *)(a7 + 40) = *(void *)&buf[16];
    long long v19 = *(_OWORD *)&buf[40];
    *(_OWORD *)(a7 + 48) = *(_OWORD *)&buf[24];
    *(_OWORD *)(a7 + 64) = v19;
  }
  if (v27)
  {
    uint64_t v28 = v27;
    operator delete(v27);
  }
  sub_1008E25A0((PB::Base *)v30);
  PB::Writer::~Writer((PB::Writer *)&v31);
  *(void *)long long buf = &v73[8];
  sub_1000C5358((void ***)buf);
  if ((v73[7] & 0x80000000) != 0) {
    operator delete((void *)v72);
  }
  if (SHIBYTE(v71) < 0) {
    operator delete(*((void **)&v70 + 1));
  }
  if (SBYTE7(v70) < 0) {
    operator delete((void *)v69);
  }
  if (SHIBYTE(v68) < 0) {
    operator delete(*((void **)&v67 + 1));
  }
  if (SBYTE7(v67) < 0) {
    operator delete((void *)v66);
  }
  *(void *)long long buf = &v65[8];
  sub_1000C56F4((void ***)buf);
  if (SHIBYTE(v64) < 0) {
    operator delete(*((void **)&v63 + 1));
  }
  if (SBYTE7(v62) < 0) {
    operator delete((void *)v61);
  }
  if (BYTE8(v58))
  {
    if (SBYTE7(v60) < 0) {
      operator delete((void *)v59);
    }
    BYTE8(v58) = 0;
  }
  if (BYTE8(v56))
  {
    if (SBYTE7(v58) < 0) {
      operator delete((void *)v57);
    }
    BYTE8(v56) = 0;
  }
  if (SBYTE7(v56) < 0) {
    operator delete((void *)v55);
  }
  if ((_BYTE)v53 && SHIBYTE(v54) < 0) {
    operator delete(*((void **)&v53 + 1));
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
}

void sub_100CD4594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t v74 = *(void **)v72;
  if (*(void *)v72)
  {
    *(void *)(v72 + 8) = v74;
    operator delete(v74);
  }
  if (a72 < 0) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  sub_1008E25A0((PB::Base *)&a21);
  PB::Writer::~Writer((PB::Writer *)&a26);
  sub_100B42B20((uint64_t)&STACK[0x260]);
  if (a34 < 0) {
    operator delete(a29);
  }
  _Unwind_Resume(a1);
}

void sub_100CD467C(os_log_t *a1, uint64_t **a2, uint64_t *a3)
{
  uint64_t v6 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) < 0) {
      a2 = (uint64_t **)*a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %sDeviceInfo: ", buf, 0xCu);
  }
  uint64_t v7 = *a3;
  uint64_t v90 = a3[1];
  if (*a3 != v90)
  {
    while (1)
    {
      uint64_t v100 = 0;
      memset(v99, 0, sizeof(v99));
      uint64_t v91 = v7;
      sub_1008E268C((uint64_t)v99, v7);
      uint64_t v8 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I deviceInfo {", buf, 2u);
      }
      uint64_t v9 = *((void *)&v99[0] + 1);
      if (*((void *)&v99[0] + 1)) {
        break;
      }
LABEL_216:
      uint64_t v89 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "#I }", buf, 2u);
      }
      sub_1008E25A0((PB::Base *)v99);
      uint64_t v7 = v91 + 40;
      if (v91 + 40 == v90) {
        return;
      }
    }
    xpc_object_t v10 = *(uint64_t ***)(*((void *)&v99[0] + 1) + 8);
    if (v10)
    {
      unint64_t v11 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v10 + 23) < 0) {
          xpc_object_t v10 = (uint64_t **)*v10;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I deviceId: %s", buf, 0xCu);
      }
    }
    unint64_t v12 = *(uint64_t ***)(v9 + 32);
    if (v12)
    {
      id v13 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v12 + 23) < 0) {
          unint64_t v12 = (uint64_t **)*v12;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I imei: %{public}s", buf, 0xCu);
      }
    }
    uint64_t v14 = *(uint64_t ***)(v9 + 40);
    if (v14)
    {
      int v15 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v14 + 23) < 0) {
          uint64_t v14 = (uint64_t **)*v14;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I meid: %{public}s", buf, 0xCu);
      }
    }
    if (*(unsigned char *)(v9 + 128))
    {
      __int16 v16 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        int v17 = *(_DWORD *)(v9 + 112);
        *(_DWORD *)long long buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I osVersion: %{public}d", buf, 8u);
      }
    }
    long long v18 = *(uint64_t ***)(v9 + 16);
    if (v18)
    {
      long long v19 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v18 + 23) < 0) {
          long long v18 = (uint64_t **)*v18;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I deviceType: %{public}s", buf, 0xCu);
      }
    }
    int v20 = *(uint64_t ***)(v9 + 24);
    if (v20)
    {
      long long v21 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v20 + 23) < 0) {
          int v20 = (uint64_t **)*v20;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v20;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I displayName: %{public}s", buf, 0xCu);
      }
    }
    uint64_t v22 = *(uint64_t ***)(v9 + 56);
    if (v22)
    {
      unsigned int v23 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v22 + 23) < 0) {
          uint64_t v22 = (uint64_t **)*v22;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v22;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I modelName: %{public}s", buf, 0xCu);
      }
    }
    uint64_t v24 = *(uint64_t ***)(v9 + 64);
    if (v24)
    {
      uint64_t v25 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v24 + 23) < 0) {
          uint64_t v24 = (uint64_t **)*v24;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v24;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I productClass: %{public}s", buf, 0xCu);
      }
    }
    char v26 = *(uint64_t ***)(v9 + 80);
    if (v26)
    {
      uint64_t v27 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v26 + 23) < 0) {
          char v26 = (uint64_t **)*v26;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v26;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I serialNumber: %{public}s", buf, 0xCu);
      }
    }
    uint64_t v29 = *(uint64_t **)(*((void *)&v99[0] + 1) + 88);
    uint64_t v28 = *(uint64_t **)(*((void *)&v99[0] + 1) + 96);
    uint64_t v92 = v28;
LABEL_53:
    if (v29 == v28) {
      goto LABEL_216;
    }
    long long v97 = 0u;
    long long v98 = 0u;
    long long v95 = 0u;
    long long v96 = 0u;
    long long v93 = 0u;
    long long v94 = 0u;
    sub_1005EA1E4((uint64_t)&v93, *v29);
    xpc_object_t v30 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I vinylInfo {", buf, 2u);
    }
    char v31 = BYTE8(v98);
    if ((BYTE8(v98) & 0x20) != 0)
    {
      uint64_t v32 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = BYTE4(v98);
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I available: %{public}d", buf, 8u);
        char v31 = BYTE8(v98);
      }
    }
    if ((v31 & 8) != 0)
    {
      uint64_t v33 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = HIDWORD(v97);
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I slot: %{public}d", buf, 8u);
      }
    }
    long long v110 = 0uLL;
    if (*((void *)&v93 + 1))
    {
      if (*(void *)(*((void *)&v93 + 1) + 8) == 16)
      {
        long long v110 = *(_OWORD *)**((void **)&v93 + 1);
        std::string v34 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
          sCardSerialNumberAsString();
          uint64_t v35 = buf;
          if (SBYTE7(v102) < 0) {
            uint64_t v35 = *(uint8_t **)buf;
          }
          *(_DWORD *)uint64_t v111 = 136446210;
          int v112 = v35;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I csn: %{public}s", v111, 0xCu);
          if (SBYTE7(v102) < 0) {
            operator delete(*(void **)buf);
          }
        }
      }
    }
    if ((BYTE8(v98) & 0x10) != 0)
    {
      std::string v36 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v98;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I type: %d", buf, 8u);
      }
    }
    char v37 = (uint64_t **)*((void *)&v95 + 1);
    if (*((void *)&v95 + 1))
    {
      xpc_object_t v38 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v37 + 23) < 0) {
          char v37 = (uint64_t **)*v37;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v37;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I imei: %{public}s", buf, 0xCu);
      }
    }
    char v39 = (uint64_t **)v96;
    if ((void)v96)
    {
      char v40 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v39 + 23) < 0) {
          char v39 = (uint64_t **)*v39;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v39;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I meid: %{public}s", buf, 0xCu);
      }
    }
    long long v41 = (uint64_t *)*((void *)&v94 + 1);
    char v42 = (uint64_t *)v94;
    if (*((void *)&v94 + 1) == (void)v94)
    {
      long long v88 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_214;
      }
      goto LABEL_215;
    }
    while (1)
    {
      uint64_t v109 = 0;
      long long v107 = 0u;
      long long v108 = 0u;
      long long v105 = 0u;
      long long v106 = 0u;
      long long v103 = 0u;
      long long v104 = 0u;
      *(_OWORD *)long long buf = 0u;
      long long v102 = 0u;
      sub_1007BA86C((uint64_t)buf, *v42);
      char v43 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v111 = 0;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I details {", v111, 2u);
        char v43 = *a1;
      }
      long long v44 = (uint8_t *)v102;
      if ((void)v102 && os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v44[23] < 0) {
          long long v44 = *(uint8_t **)v44;
        }
        *(_DWORD *)uint64_t v111 = 136446210;
        int v112 = v44;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I gid1: %{public}s", v111, 0xCu);
        char v43 = *a1;
      }
      char v45 = (uint8_t *)*((void *)&v102 + 1);
      if (*((void *)&v102 + 1) && os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v45[23] < 0) {
          char v45 = *(uint8_t **)v45;
        }
        *(_DWORD *)uint64_t v111 = 136446210;
        int v112 = v45;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I gid2: %{public}s", v111, 0xCu);
        char v43 = *a1;
      }
      long long v46 = (uint8_t *)*((void *)&v104 + 1);
      if (*((void *)&v104 + 1) && os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v46[23] < 0) {
          long long v46 = *(uint8_t **)v46;
        }
        *(_DWORD *)uint64_t v111 = 136446210;
        int v112 = v46;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I mcc: %{public}s", v111, 0xCu);
        char v43 = *a1;
      }
      char v47 = (uint8_t *)v105;
      if ((void)v105 && os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v47[23] < 0) {
          char v47 = *(uint8_t **)v47;
        }
        *(_DWORD *)uint64_t v111 = 136446210;
        int v112 = v47;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I mnc: %{public}s", v111, 0xCu);
        char v43 = *a1;
      }
      long long v48 = (uint8_t *)v103;
      if ((void)v103 && os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v48[23] < 0) {
          long long v48 = *(uint8_t **)v48;
        }
        *(_DWORD *)uint64_t v111 = 136315138;
        int v112 = v48;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I iccid: %s", v111, 0xCu);
        char v43 = *a1;
      }
      int v49 = BYTE11(v108);
      BOOL v50 = os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
      if (v49)
      {
        if (!v50) {
          goto LABEL_116;
        }
        *(_DWORD *)uint64_t v111 = 67240192;
        LODWORD(v112) = 1;
        char v51 = v43;
        long long v52 = "#I isActive: %{public}d";
        uint32_t v53 = 8;
      }
      else
      {
        if (!v50) {
          goto LABEL_116;
        }
        *(_WORD *)uint64_t v111 = 0;
        char v51 = v43;
        long long v52 = "#I isActive: 0";
        uint32_t v53 = 2;
      }
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, v52, v111, v53);
LABEL_116:
      int v54 = BYTE12(v108);
      os_log_t v55 = *a1;
      BOOL v56 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
      if (v54)
      {
        if (v56)
        {
          *(_DWORD *)uint64_t v111 = 67240192;
          LODWORD(v112) = 1;
          long long v57 = v55;
          long long v58 = "#I isBootstrap: %{public}d";
          uint32_t v59 = 8;
LABEL_121:
          _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, v58, v111, v59);
        }
      }
      else if (v56)
      {
        *(_WORD *)uint64_t v111 = 0;
        long long v57 = v55;
        long long v58 = "#I isBootstrap: 0";
        uint32_t v59 = 2;
        goto LABEL_121;
      }
      long long v60 = (uint8_t *)*((void *)&v106 + 1);
      long long v61 = *a1;
      if (*((void *)&v106 + 1) && os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v60[23] < 0) {
          long long v60 = *(uint8_t **)v60;
        }
        *(_DWORD *)uint64_t v111 = 136315138;
        int v112 = v60;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I profileStatus: %s", v111, 0xCu);
        long long v61 = *a1;
      }
      long long v62 = (uint8_t *)v107;
      if ((void)v107 && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v62[23] < 0) {
          long long v62 = *(uint8_t **)v62;
        }
        *(_DWORD *)uint64_t v111 = 136446210;
        int v112 = v62;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I serviceProviderName: %{public}s", v111, 0xCu);
        long long v61 = *a1;
      }
      long long v63 = *(uint8_t **)&buf[8];
      if (*(void *)&buf[8] && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v63[23] < 0) {
          long long v63 = *(uint8_t **)v63;
        }
        *(_DWORD *)uint64_t v111 = 136446210;
        int v112 = v63;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I carrier: %{public}s", v111, 0xCu);
        long long v61 = *a1;
      }
      long long v64 = (uint8_t *)v104;
      if ((void)v104 && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v64[23] < 0) {
          long long v64 = *(uint8_t **)v64;
        }
        *(_DWORD *)uint64_t v111 = 136315138;
        int v112 = v64;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I labelText: %s", v111, 0xCu);
        long long v61 = *a1;
      }
      uint64_t v65 = (uint8_t *)*((void *)&v103 + 1);
      if (*((void *)&v103 + 1) && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v65[23] < 0) {
          uint64_t v65 = *(uint8_t **)v65;
        }
        *(_DWORD *)uint64_t v111 = 136315138;
        int v112 = v65;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I labelTag: %s", v111, 0xCu);
        long long v61 = *a1;
      }
      long long v66 = (uint8_t *)*((void *)&v105 + 1);
      if (*((void *)&v105 + 1) && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v66[23] < 0) {
          long long v66 = *(uint8_t **)v66;
        }
        *(_DWORD *)uint64_t v111 = 136315138;
        int v112 = v66;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I phoneNumber: %s", v111, 0xCu);
        long long v61 = *a1;
      }
      uint64_t v67 = v108;
      if (!(void)v108) {
        goto LABEL_208;
      }
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v111 = 0;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I transferDetails {", v111, 2u);
        long long v61 = *a1;
      }
      if ((*(unsigned char *)(v67 + 88) & 2) != 0 && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        int v68 = *(_DWORD *)(v67 + 72);
        *(_DWORD *)uint64_t v111 = 67240192;
        LODWORD(v112) = v68;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I addOnFlowTyp: %{public}d", v111, 8u);
        long long v61 = *a1;
      }
      int v69 = *(_DWORD *)(v67 + 76);
      BOOL v70 = os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT);
      if (v69)
      {
        if (!v70) {
          goto LABEL_164;
        }
        *(_DWORD *)uint64_t v111 = 67240192;
        LODWORD(v112) = v69;
        long long v71 = v61;
        uint64_t v72 = "#I sourceTransferError: %{public}d";
        uint32_t v73 = 8;
      }
      else
      {
        if (!v70) {
          goto LABEL_164;
        }
        *(_WORD *)uint64_t v111 = 0;
        long long v71 = v61;
        uint64_t v72 = "#I sourceTransferError: 0";
        uint32_t v73 = 2;
      }
      _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, v72, v111, v73);
LABEL_164:
      int v74 = *(unsigned __int8 *)(v67 + 84);
      os_log_t v75 = *a1;
      BOOL v76 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
      if (v74)
      {
        if (!v76) {
          goto LABEL_170;
        }
        *(_DWORD *)uint64_t v111 = 67240192;
        LODWORD(v112) = 1;
        uint64_t v77 = v75;
        int v78 = "#I isDataActive: %{public}d";
        uint32_t v79 = 8;
      }
      else
      {
        if (!v76) {
          goto LABEL_170;
        }
        *(_WORD *)uint64_t v111 = 0;
        uint64_t v77 = v75;
        int v78 = "#I isDataActive: 0";
        uint32_t v79 = 2;
      }
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, v78, v111, v79);
LABEL_170:
      long long v80 = *(uint8_t **)(v67 + 32);
      long long v61 = *a1;
      if (v80 && os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v80[23] < 0) {
          long long v80 = *(uint8_t **)v80;
        }
        *(_DWORD *)uint64_t v111 = 136315138;
        int v112 = v80;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I carrierTransferData: %s", v111, 0xCu);
        long long v61 = *a1;
      }
      uint64_t v81 = *(uint8_t **)(v67 + 40);
      if (v81 && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v81[23] < 0) {
          uint64_t v81 = *(uint8_t **)v81;
        }
        *(_DWORD *)uint64_t v111 = 136315138;
        int v112 = v81;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I expirationTime: %s", v111, 0xCu);
        long long v61 = *a1;
      }
      unint64_t v82 = *(uint8_t **)(v67 + 56);
      if (v82 && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v82[23] < 0) {
          unint64_t v82 = *(uint8_t **)v82;
        }
        *(_DWORD *)uint64_t v111 = 136315138;
        int v112 = v82;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I imsi: %s", v111, 0xCu);
        long long v61 = *a1;
      }
      unint64_t v83 = *(uint8_t **)(v67 + 64);
      if (v83 && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v83[23] < 0) {
          unint64_t v83 = *(uint8_t **)v83;
        }
        *(_DWORD *)uint64_t v111 = 136315138;
        int v112 = v83;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I transferToken: %s", v111, 0xCu);
        long long v61 = *a1;
      }
      if ((*(unsigned char *)(v67 + 88) & 8) != 0 && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        int v84 = *(_DWORD *)(v67 + 80);
        *(_DWORD *)uint64_t v111 = 67240192;
        LODWORD(v112) = v84;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I transferType: %{public}d", v111, 8u);
        long long v61 = *a1;
      }
      unint64_t v85 = *(uint8_t **)(v67 + 16);
      if (v85 && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v85[23] < 0) {
          unint64_t v85 = *(uint8_t **)v85;
        }
        *(_DWORD *)uint64_t v111 = 136446210;
        int v112 = v85;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I carrierErrorCode: %{public}s", v111, 0xCu);
        long long v61 = *a1;
      }
      uint64_t v86 = *(uint8_t **)(v67 + 24);
      if (v86 && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v86[23] < 0) {
          uint64_t v86 = *(uint8_t **)v86;
        }
        *(_DWORD *)uint64_t v111 = 136446210;
        int v112 = v86;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I carrierErrorCodeUrl: %{public}s", v111, 0xCu);
        long long v61 = *a1;
      }
      if ((*(unsigned char *)(v67 + 88) & 1) != 0 && os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        long long v87 = *(uint8_t **)(v67 + 8);
        *(_DWORD *)uint64_t v111 = 134349056;
        int v112 = v87;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I additionalTransferInfo: %{public}llu", v111, 0xCu);
        long long v61 = *a1;
      }
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v111 = 0;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I }", v111, 2u);
        long long v61 = *a1;
      }
LABEL_208:
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v111 = 0;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I }", v111, 2u);
      }
      sub_1007BA698((uint64_t)buf);
      if (++v42 == v41)
      {
        long long v88 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
LABEL_214:
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I }", buf, 2u);
        }
LABEL_215:
        sub_1005EA108((uint64_t)&v93);
        ++v29;
        uint64_t v28 = v92;
        goto LABEL_53;
      }
    }
  }
}

void sub_100CD57A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

void sub_100CD57C4(os_log_t *a1, std::string::size_type a2, uint64_t a3)
{
  uint64_t v4 = *(const unsigned __int8 **)a3;
  unint64_t v5 = *(void *)(a3 + 8) - *(void *)a3;
  if (v5)
  {
    memset(v19, 0, sizeof(v19));
    PB::Reader::Reader((PB::Reader *)v19, v4, v5);
    memset(&v18[1], 0, 32);
    v18[0] = &off_101A17F50;
    sub_1008E296C((uint64_t)v18, (PB::Reader *)v19);
    memset(v17, 0, sizeof(v17));
    PB::Base::formattedText((uint64_t *)&buf, (PB::Base *)v18);
    ctu::split_any_copy();
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    uint64_t v6 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) < 0) {
        a2 = *(void *)a2;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %sDeviceInfo: ", (uint8_t *)&buf, 0xCu);
    }
    ctu::hex();
    uint64_t v7 = std::string::append(&v20, "\n\n", 2uLL);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    buf.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    PB::Base::formattedText((uint64_t *)__p, (PB::Base *)v18);
    if ((v16 & 0x80u) == 0) {
      uint64_t v9 = __p;
    }
    else {
      uint64_t v9 = (void **)__p[0];
    }
    if ((v16 & 0x80u) == 0) {
      std::string::size_type v10 = v16;
    }
    else {
      std::string::size_type v10 = (std::string::size_type)__p[1];
    }
    unint64_t v11 = std::string::append(&buf, (const std::string::value_type *)v9, v10);
    unint64_t v12 = (void *)v11->__r_.__value_.__r.__words[0];
    int v13 = SHIBYTE(v11->__r_.__value_.__r.__words[2]);
    v11->__r_.__value_.__r.__words[0] = 0;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    if ((char)v16 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v20.__r_.__value_.__l.__data_);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)qword_101B12AC8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(qword_101B12AC8))
    {
      __cxa_guard_release(qword_101B12AC8);
    }
    if (v13 < 0) {
      operator delete(v12);
    }
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
    sub_100047F64((void ***)&buf);
    sub_1008E25A0((PB::Base *)v18);
  }
}

void sub_100CD5CD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25)
{
  *(void *)(v25 - 128) = &a22;
  sub_100047F64((void ***)(v25 - 128));
  sub_1008E25A0((PB::Base *)&a25);
  _Unwind_Resume(a1);
}

void sub_100CD5D70()
{
}

uint64_t sub_100CD5D78(os_log_t *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a4;
    uint64_t v25 = *(void *)(a4 + 16);
  }
  char v8 = sub_10098EC38(a3, __p, (uint64_t)&v26);
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v9 = *a1;
  std::string::size_type v10 = *a1;
  if (v8)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      if (a2[23] < 0) {
        a2 = *(const char **)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      long long v52 = a2;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %sTransferDeviceInfo: ", buf, 0xCu);
      uint64_t v9 = *a1;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a4 + 23) >= 0) {
        unint64_t v11 = (const char *)a4;
      }
      else {
        unint64_t v11 = *(const char **)a4;
      }
      *(_DWORD *)std::string buf = 136315138;
      long long v52 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I iccid: %s", buf, 0xCu);
      uint64_t v9 = *a1;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v12 = (const char *)&v26;
      if (SBYTE7(v27) < 0) {
        unint64_t v12 = (const char *)v26;
      }
      *(_DWORD *)std::string buf = 136315138;
      long long v52 = v12;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I phoneNumber: %s", buf, 0xCu);
      uint64_t v9 = *a1;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = (char *)&v30 + 8;
      if (v31 < 0) {
        int v13 = (const char *)*((void *)&v30 + 1);
      }
      *(_DWORD *)std::string buf = 136315138;
      long long v52 = v13;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I carrier: %s", buf, 0xCu);
    }
    if (BYTE9(v36))
    {
      uint64_t v14 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = sub_1008A1E44(BYTE8(v36));
        *(_DWORD *)std::string buf = 136315138;
        long long v52 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I     transferType: \"%s\"", buf, 0xCu);
      }
    }
    if (BYTE8(v38))
    {
      unsigned __int8 v16 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        int v17 = (const char *)&v37;
        if (SBYTE7(v38) < 0) {
          int v17 = (const char *)v37;
        }
        *(_DWORD *)std::string buf = 136315138;
        long long v52 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I     transferToken: \"%s\"", buf, 0xCu);
      }
    }
    if (BYTE8(v40))
    {
      long long v18 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        long long v19 = (const char *)&v39;
        if (SBYTE7(v40) < 0) {
          long long v19 = (const char *)v39;
        }
        *(_DWORD *)std::string buf = 136315138;
        long long v52 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I     expirationTime: \"%s\"", buf, 0xCu);
      }
    }
    if (BYTE8(v44))
    {
      std::string v20 = *a1;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        long long v21 = (const char *)&v43;
        if (SBYTE7(v44) < 0) {
          long long v21 = (const char *)v43;
        }
        *(_DWORD *)std::string buf = 136315138;
        long long v52 = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I     imsi: \"%s\"", buf, 0xCu);
      }
    }
  }
  else if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a4 + 23) >= 0) {
      unsigned int v23 = (const char *)a4;
    }
    else {
      unsigned int v23 = *(const char **)a4;
    }
    *(_DWORD *)std::string buf = 136315138;
    long long v52 = v23;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "failed to get additonal profile info for source iccid: %s", buf, 0xCu);
  }
  return sub_1000C54EC((uint64_t)&v26);
}

void sub_100CD61CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

void sub_100CD61F8(os_log_t *a1, uint64_t **a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) >= 0) {
    uint64_t v4 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v4 = *(void *)(a3 + 8);
  }
  if (v4)
  {
    memset(v8, 0, sizeof(v8));
    ctu::split_any_copy();
    unint64_t v5 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) < 0) {
        a2 = (uint64_t **)*a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %sDeviceInfo: ", buf, 0xCu);
    }
    memset(v7, 0, sizeof(v7));
    *(void *)std::string buf = v8;
    sub_100047F64((void ***)buf);
  }
}

void sub_100CD685C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  if (v26 < 0) {
    operator delete(__p);
  }
  *(void *)(v27 - 128) = &a26;
  sub_100047F64((void ***)(v27 - 128));
  _Unwind_Resume(a1);
}

void sub_100CD689C(os_log_t *a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
  }
  sub_100CD61F8(a1, (uint64_t **)__p, a3);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13F08, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13F08))
  {
    qword_101B13F00 = 0;
    __cxa_guard_release(&qword_101B13F08);
  }
  uint64_t v5 = qword_101B13F00;
  if (qword_101B13F00)
  {
    int v6 = *(char *)(a3 + 23);
    if (v6 >= 0) {
      uint64_t v7 = (char *)a3;
    }
    else {
      uint64_t v7 = *(char **)a3;
    }
    if (v6 >= 0) {
      size_t v8 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      size_t v8 = *(void *)(a3 + 8);
    }
    std::string::size_type v10 = 0;
    uint64_t v11 = 0;
    uint64_t v9 = 0;
    sub_10012C7D0((char *)&v9, v7, &v7[v8], v8);
    sub_100EE8BC8(v5, (const char *)&unk_10164DC46);
    if (v9)
    {
      std::string::size_type v10 = v9;
      operator delete(v9);
    }
  }
}

void sub_100CD69B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CD69E4(Registry **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v20 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  size_t v8 = ServiceMap;
  if (v9 < 0)
  {
    std::string::size_type v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v17 = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v17);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15) {
    goto LABEL_13;
  }
LABEL_10:
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v15 + 24))(&v17, v15, a3);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  *(_OWORD *)std::string __p = v17;
  uint64_t v20 = v18;
LABEL_13:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  sub_100CD6B88(a2, (uint64_t)__p, a4);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100CD6B50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100CD6B88@<X0>(const void **result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = result;
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if (v5)
  {
    uint64_t v22 = 0;
    if (*((char *)result + 23) < 0)
    {
      sub_10004FC84(__dst, (void *)*result, (unint64_t)result[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)result;
      uint64_t v20 = result[2];
    }
    if (SHIBYTE(v20) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      uint64_t v25 = v20;
    }
    unsigned int v23 = 0;
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(&v28, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v28 = *(_OWORD *)__p;
      long long v29 = v25;
    }
    char v26 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v7 = v23;
      unsigned int v23 = v26;
      uint64_t v27 = v7;
      sub_1000558F4(&v27);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete((void *)v28);
    }
    long long v21 = v23;
    unsigned int v23 = 0;
    sub_1000558F4(&v23);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v16, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)char v16 = *(_OWORD *)a2;
      long long v17 = *(const void **)(a2 + 16);
    }
    if (SHIBYTE(v17) < 0)
    {
      sub_10004FC84(__p, v16[0], (unint64_t)v16[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v16;
      uint64_t v25 = v17;
    }
    unsigned int v23 = 0;
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(&v28, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long v28 = *(_OWORD *)__p;
      long long v29 = v25;
    }
    char v26 = 0;
    if (ctu::cf::convert_copy())
    {
      size_t v8 = v23;
      unsigned int v23 = v26;
      uint64_t v27 = v8;
      sub_1000558F4(&v27);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete((void *)v28);
    }
    char v18 = v23;
    unsigned int v23 = 0;
    sub_1000558F4(&v23);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v9 = (const void *)CFPhoneNumberCreate();
    uint64_t v22 = v9;
    sub_1000558F4(&v18);
    if (SHIBYTE(v17) < 0) {
      operator delete(v16[0]);
    }
    sub_1000558F4(&v21);
    if (SHIBYTE(v20) < 0) {
      operator delete(__dst[0]);
    }
    *(_DWORD *)((char *)&v27 + 3) = 0;
    LODWORD(v27) = 0;
    uint64_t v15 = v9;
    if (v9)
    {
      CFRetain(v9);
      __p[0] = (void *)CFPhoneNumberCreateString();
      if (__p[0])
      {
        long long v28 = 0uLL;
        long long v29 = 0;
        ctu::cf::assign();
        uint64_t v11 = *((void *)&v28 + 1);
        std::string::size_type v10 = (void *)v28;
        LODWORD(v27) = v29;
        *(_DWORD *)((char *)&v27 + 3) = *(_DWORD *)((char *)&v29 + 3);
        int v12 = SHIBYTE(v29);
        sub_1000558F4((const void **)__p);
        sub_100CDD7B0(&v15);
        if (v12 < 0)
        {
          if (!v11)
          {
LABEL_44:
            if (*((char *)v3 + 23) < 0)
            {
              sub_10004FC84((unsigned char *)a3, (void *)*v3, (unint64_t)v3[1]);
            }
            else
            {
              *(_OWORD *)a3 = *(_OWORD *)v3;
              *(void *)(a3 + 16) = v3[2];
            }
            if (v12 < 0) {
              operator delete(v10);
            }
            return sub_100CDD7B0(&v22);
          }
LABEL_52:
          *(void *)a3 = v10;
          *(void *)(a3 + 8) = v11;
          *(_DWORD *)(a3 + 16) = v27;
          *(_DWORD *)(a3 + 19) = *(_DWORD *)((char *)&v27 + 3);
          *(unsigned char *)(a3 + 23) = v12;
          return sub_100CDD7B0(&v22);
        }
LABEL_51:
        if (!(_BYTE)v12) {
          goto LABEL_44;
        }
        goto LABEL_52;
      }
      sub_1000558F4((const void **)__p);
    }
    *(_DWORD *)((char *)&v27 + 3) = 0;
    LODWORD(v27) = 0;
    sub_100CDD7B0(&v15);
    int v12 = 0;
    uint64_t v11 = 0;
    std::string::size_type v10 = 0;
    goto LABEL_51;
  }
  if (*((char *)result + 23) < 0)
  {
    uint64_t v13 = (void *)*result;
    unint64_t v14 = (unint64_t)result[1];
    return (const void **)sub_10004FC84((unsigned char *)a3, v13, v14);
  }
  else
  {
    *(_OWORD *)a3 = *(_OWORD *)result;
    *(void *)(a3 + 16) = result[2];
  }
  return result;
}

void sub_100CD6F70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,int a25,const void *a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (v36) {
    operator delete(v35);
  }
  sub_100CDD7B0(&a26);
  _Unwind_Resume(a1);
}

void sub_100CD7054(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, const void *a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (*(char *)(v26 - 73) < 0) {
    operator delete(*(void **)(v26 - 96));
  }
  sub_1000558F4(&a20);
  if (a26 < 0) {
    operator delete(a21);
  }
  JUMPOUT(0x100CD703CLL);
}

void sub_100CD7084(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = a2;
  memset(&__dst, 0, sizeof(__dst));
  LODWORD(a2) = *(char *)(a1 + 23);
  if ((a2 & 0x80000000) == 0)
  {
    std::string __dst = *(std::string *)a1;
LABEL_4:
    a2 = a2;
    goto LABEL_5;
  }
  sub_10004FC84(&__dst, *(void **)a1, *(void *)(a1 + 8));
  LODWORD(a2) = *(char *)(a1 + 23);
  if ((a2 & 0x80000000) == 0) {
    goto LABEL_4;
  }
  a2 = *(void *)(a1 + 8);
LABEL_5:
  if (a2 == 19) {
    std::string::append(&__dst, "F", 1uLL);
  }
  md = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  sub_10008E4E8(&md, 0x20uLL);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    CC_LONG v5 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    CC_LONG v5 = __dst.__r_.__value_.__r.__words[1];
  }
  int v6 = CC_SHA256(p_dst, v5, md);
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  if (v6)
  {
    ctu::hex();
    uint64_t v7 = *(unsigned __int8 *)(v3 + 23);
    int v8 = (char)v7;
    uint64_t v9 = (unsigned char *)(v3 + v7);
    if (v8 >= 0) {
      std::string::size_type v10 = v9;
    }
    else {
      std::string::size_type v10 = (unsigned char *)(*(void *)v3 + *(void *)(v3 + 8));
    }
    if (v8 >= 0) {
      uint64_t v11 = (unsigned char *)v3;
    }
    else {
      uint64_t v11 = *(unsigned char **)v3;
    }
    while (v11 != v10)
    {
      unsigned char *v11 = __tolower((char)*v11);
      ++v11;
    }
  }
  if (md)
  {
    uint64_t v13 = md;
    operator delete(md);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_100CD71C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CD7214(void **a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v6 = a1;
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (*((char *)a1 + 23) < 0)
  {
    sub_10004FC84(__p, *a1, (unint64_t)a1[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a1;
    long long v31 = a1[2];
  }
  char v10 = HIBYTE(v31);
  if (v8 != v9)
  {
    if (SHIBYTE(v31) >= 0) {
      uint64_t v11 = (void *)HIBYTE(v31);
    }
    else {
      uint64_t v11 = __p[1];
    }
    if (SHIBYTE(v31) >= 0) {
      int v12 = __p;
    }
    else {
      int v12 = (void **)__p[0];
    }
    do
    {
      uint64_t v13 = *(unsigned __int8 *)(v8 + 95);
      if ((v13 & 0x80u) == 0) {
        uint64_t v14 = (void *)*(unsigned __int8 *)(v8 + 95);
      }
      else {
        uint64_t v14 = *(void **)(v8 + 80);
      }
      if (v14 == v11)
      {
        if ((v13 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v8 + 72), v12, *(void *)(v8 + 80))) {
            goto LABEL_24;
          }
        }
        else
        {
          if (!*(unsigned char *)(v8 + 95)) {
            goto LABEL_24;
          }
          uint64_t v15 = 0;
          while (*(unsigned __int8 *)(v8 + v15 + 72) == *((unsigned __int8 *)v12 + v15))
          {
            if (v13 == ++v15) {
              goto LABEL_24;
            }
          }
        }
      }
      v8 += 168;
    }
    while (v8 != v9);
    uint64_t v8 = v9;
  }
LABEL_24:
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  if (v8 == a2[1])
  {
    uint64_t v18 = *a3;
    uint64_t v17 = a3[1];
    if (v18 != v17)
    {
      char v19 = *((unsigned char *)v6 + 23);
      if (v19 >= 0) {
        uint64_t v20 = (void *)*((unsigned __int8 *)v6 + 23);
      }
      else {
        uint64_t v20 = v6[1];
      }
      if (v19 < 0) {
        int v6 = (void **)*v6;
      }
      do
      {
        if (*(unsigned char *)(v18 + 80))
        {
          uint64_t v21 = *(void *)(v18 + 56);
          uint64_t v22 = *(void *)(v18 + 64);
          while (v21 != v22)
          {
            uint64_t v23 = *(unsigned __int8 *)(v21 + 39);
            if ((v23 & 0x80u) == 0) {
              uint64_t v24 = (void *)*(unsigned __int8 *)(v21 + 39);
            }
            else {
              uint64_t v24 = *(void **)(v21 + 24);
            }
            if (v24 == v20)
            {
              if ((v23 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v21 + 16), v6, *(void *)(v21 + 24)))
                {
LABEL_58:
                  if (*(char *)(v21 + 119) < 0)
                  {
                    sub_10004FC84((unsigned char *)a4, *(void **)(v21 + 96), *(void *)(v21 + 104));
                  }
                  else
                  {
                    long long v26 = *(_OWORD *)(v21 + 96);
                    *(void *)(a4 + 16) = *(void *)(v21 + 112);
                    *(_OWORD *)a4 = v26;
                  }
                  return;
                }
              }
              else
              {
                if (!*(unsigned char *)(v21 + 39)) {
                  goto LABEL_58;
                }
                uint64_t v25 = 0;
                while (*(unsigned __int8 *)(v21 + v25 + 16) == *((unsigned __int8 *)v6 + v25))
                {
                  if (v23 == ++v25) {
                    goto LABEL_58;
                  }
                }
              }
            }
            v21 += 216;
          }
        }
        v18 += 88;
      }
      while (v18 != v17);
    }
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    *(_OWORD *)long long v28 = 0u;
    long long v29 = 0u;
    *(_OWORD *)uint64_t v27 = 0u;
    sub_100E63EA4((uint64_t)v27);
    int v16 = SHIBYTE(v28[0]);
    if (SHIBYTE(v28[0]) < 0)
    {
      sub_10004FC84((unsigned char *)a4, v27[0], (unint64_t)v27[1]);
    }
    else
    {
      *(_OWORD *)a4 = *(_OWORD *)v27;
      *(void **)(a4 + 16) = v28[0];
    }
    if (SHIBYTE(v29) < 0)
    {
      operator delete(v28[1]);
      if ((v16 & 0x80000000) == 0) {
        return;
      }
    }
    else if ((v16 & 0x80000000) == 0)
    {
      return;
    }
    operator delete(v27[0]);
  }
}

void sub_100CD7484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100CD7498(void *a1, void *a2)
{
  if (a1[2] == a2[2])
  {
    id v2 = a1 + 1;
    uint64_t v3 = (void *)*a1;
    if ((void *)*a1 == a1 + 1) {
      return 1;
    }
    CC_LONG v5 = a2 + 1;
    while (1)
    {
      int v6 = (void *)*a2;
      BOOL v7 = *a2 != (void)v5;
      if ((void *)*a2 == v5) {
        break;
      }
      while (1)
      {
        uint64_t v28 = 0;
        long long v26 = 0u;
        long long v27 = 0u;
        *(_OWORD *)uint64_t v24 = 0u;
        *(_OWORD *)uint64_t v25 = 0u;
        long long v23 = 0u;
        memset(&v22, 0, sizeof(v22));
        CSIPhoneNumber::CSIPhoneNumber();
        uint64_t v21 = 0;
        long long v19 = 0u;
        long long v20 = 0u;
        *(_OWORD *)uint64_t v17 = 0u;
        *(_OWORD *)std::string __p = 0u;
        long long v16 = 0u;
        memset(&v15, 0, sizeof(v15));
        CSIPhoneNumber::CSIPhoneNumber();
        char isOriginalNumberSame = CSIPhoneNumber::isOriginalNumberSame(&v22, &v15);
        if (SHIBYTE(v19) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(__p[0]) < 0) {
          operator delete(v17[0]);
        }
        if (SBYTE7(v16) < 0) {
          operator delete(*(void **)&v15.var2.__r_.var0);
        }
        if (*((char *)&v15.var2.__r_.__value_.var0.var1 + 23) < 0) {
          operator delete(v15.var2.__r_.__value_.var0.var1.__data_);
        }
        if (SHIBYTE(v26) < 0) {
          operator delete(v25[1]);
        }
        if (SHIBYTE(v25[0]) < 0) {
          operator delete(v24[0]);
        }
        if (SBYTE7(v23) < 0) {
          operator delete(*(void **)&v22.var2.__r_.var0);
        }
        if (*((char *)&v22.var2.__r_.__value_.var0.var1 + 23) < 0) {
          operator delete(v22.var2.__r_.__value_.var0.var1.__data_);
        }
        if (isOriginalNumberSame) {
          break;
        }
        uint64_t v9 = (void *)v6[1];
        if (v9)
        {
          do
          {
            char v10 = v9;
            uint64_t v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            char v10 = (void *)v6[2];
            BOOL v11 = *v10 == (void)v6;
            int v6 = v10;
          }
          while (!v11);
        }
        int v6 = v10;
        if (v10 == v5) {
          return 0;
        }
      }
      int v12 = (void *)v3[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          int v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v3[2];
          BOOL v11 = *v13 == (void)v3;
          uint64_t v3 = v13;
        }
        while (!v11);
      }
      uint64_t v3 = v13;
      if (v13 == v2) {
        return v7;
      }
    }
  }
  return 0;
}

void sub_100CD7680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (a52 < 0) {
    operator delete(__p);
  }
  if (a46 < 0) {
    operator delete(a41);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CD7714(os_log_t *a1, const unsigned __int8 **a2, void *a3, uint64_t *a4, void *a5, uint64_t a6, uint64_t a7)
{
  v34[0] = 0;
  v34[1] = 0;
  long long v33 = v34;
  uint64_t v13 = (void **)(a3 + 1);
  uint64_t v14 = (void **)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    do
    {
      sub_100046BAC((uint64_t **)&v33, v14 + 5, (uint64_t)(v14 + 5));
      CSIPhoneNumber v15 = (void **)v14[1];
      if (v15)
      {
        do
        {
          long long v16 = v15;
          CSIPhoneNumber v15 = (void **)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          long long v16 = (void **)v14[2];
          BOOL v17 = *v16 == v14;
          uint64_t v14 = v16;
        }
        while (!v17);
      }
      uint64_t v14 = v16;
    }
    while (v16 != v13);
  }
  uint64_t v68 = 0;
  long long v66 = 0u;
  memset(v67, 0, sizeof(v67));
  long long v64 = 0u;
  *(_OWORD *)uint64_t v65 = 0u;
  long long v62 = 0u;
  *(_OWORD *)long long v63 = 0u;
  long long v60 = 0u;
  *(_OWORD *)long long v61 = 0u;
  long long v58 = 0u;
  *(_OWORD *)uint32_t v59 = 0u;
  long long v56 = 0u;
  *(_OWORD *)long long v57 = 0u;
  *(_OWORD *)os_log_t v55 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  *(_OWORD *)long long v30 = 0u;
  *(_OWORD *)long long v27 = 0u;
  *(_OWORD *)uint64_t v28 = 0u;
  *(_OWORD *)uint64_t v25 = 0u;
  long long v26 = 0u;
  *(_OWORD *)uint64_t v24 = 0u;
  BOOL v18 = sub_1006D2F20(a1, a2, (uint64_t)v55, (std::string *)v24);
  if ((_BYTE)v68) {
    BOOL v19 = v18;
  }
  else {
    BOOL v19 = 0;
  }
  if (v19)
  {
    uint64_t v20 = *((void *)&v31 + 1);
    uint64_t v21 = v32;
    while (v20 != v21)
    {
      if (sub_10010E128((uint64_t)&v33, (void **)(v20 + 8))) {
        goto LABEL_16;
      }
      v20 += 80;
    }
    sub_10098E0F8(a6, a1, (uint64_t)v55, (const std::string *)v24, a4, a5);
    sub_100311D04(&v36, (uint64_t)v55);
    sub_1006D1D84(&v36, (uint64_t)&v51);
    if (*(char *)(a7 + 23) < 0) {
      operator delete(*(void **)a7);
    }
    *(_OWORD *)a7 = v51;
    *(void *)(a7 + 16) = v52;
    HIBYTE(v52) = 0;
    LOBYTE(v51) = 0;
    *(_OWORD *)(a7 + 24) = v53;
    *(_OWORD *)(a7 + 40) = v54;
    if (v50[40])
    {
      long long v35 = (void **)v50;
      sub_1000C56F4(&v35);
      if (v49 < 0) {
        operator delete(__p);
      }
      if (v47 < 0) {
        operator delete(v46);
      }
      if (v43)
      {
        if (v45 < 0) {
          operator delete(v44);
        }
        char v43 = 0;
      }
      if (v40)
      {
        if (v42 < 0) {
          operator delete(v41);
        }
        char v40 = 0;
      }
      if (v39 < 0) {
        operator delete(v38);
      }
      if (v36.__r_.__value_.__s.__data_[0])
      {
        if (v37 < 0) {
          operator delete((void *)v36.__r_.__value_.__l.__size_);
        }
        v36.__r_.__value_.__s.__data_[0] = 0;
      }
    }
    uint64_t v22 = 1;
  }
  else
  {
LABEL_16:
    uint64_t v22 = 0;
  }
  *(void *)&long long v51 = (char *)&v31 + 8;
  sub_1000C5358((void ***)&v51);
  if (SBYTE7(v31) < 0) {
    operator delete(v30[0]);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[1]);
  }
  if (SHIBYTE(v28[0]) < 0) {
    operator delete(v27[0]);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[1]);
  }
  if (SHIBYTE(v25[0]) < 0) {
    operator delete(v24[0]);
  }
  if ((_BYTE)v68)
  {
    v24[0] = (char *)v67 + 8;
    sub_1000C56F4((void ***)v24);
    if (SHIBYTE(v66) < 0) {
      operator delete(v65[1]);
    }
    if (SBYTE7(v64) < 0) {
      operator delete(v63[0]);
    }
    if (BYTE8(v60))
    {
      if (SBYTE7(v62) < 0) {
        operator delete(v61[0]);
      }
      BYTE8(v60) = 0;
    }
    if (BYTE8(v58))
    {
      if (SBYTE7(v60) < 0) {
        operator delete(v59[0]);
      }
      BYTE8(v58) = 0;
    }
    if (SBYTE7(v58) < 0) {
      operator delete(v57[0]);
    }
    if (LOBYTE(v55[0]) && SHIBYTE(v56) < 0) {
      operator delete(v55[1]);
    }
  }
  sub_10005CD2C((uint64_t)&v33, v34[0]);
  return v22;
}

void sub_100CD7AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,char *a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  if (a61) {
    sub_1000C5634((uint64_t)&a31);
  }
  sub_10023DD58((uint64_t)&a9);
  if (LOBYTE(STACK[0x2D0])) {
    sub_1000C5634((uint64_t)&a69);
  }
  sub_10005CD2C((uint64_t)&a27, a28);
  _Unwind_Resume(a1);
}

uint64_t sub_100CD7B0C(os_log_t *a1, const unsigned __int8 **a2, void *a3, uint64_t *a4, long long **a5, uint64_t a6, uint64_t a7)
{
  memset(v15, 0, sizeof(v15));
  sub_1000302C0((char *)v15, *a5, a5[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a5[1] - (char *)*a5) >> 3));
  uint64_t v13 = sub_100CD7714(a1, a2, a3, a4, v15, a6, a7);
  long long v16 = (void **)v15;
  sub_100047F64(&v16);
  return v13;
}

void sub_100CD7BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100CD7BD8@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  a2[2] = 0;
  a2[1] = 0;
  *a2 = a2 + 1;
  uint64_t v3 = *(void *)(result + 8);
  if (*(void *)result != v3)
  {
    uint64_t v4 = *(void *)result + 64;
    do
    {
      if (*(char *)(v4 + 31) < 0)
      {
        if (*(void *)(v4 + 16))
        {
LABEL_7:
          uint64_t result = subscriber::isEsimCapable();
          if ((result & 1) == 0) {
            uint64_t result = (uint64_t)sub_100CDD8E4((uint64_t)a2, (int *)(v4 - 64), (_DWORD *)(v4 - 64), v4 + 8);
          }
        }
      }
      else if (*(unsigned char *)(v4 + 31))
      {
        goto LABEL_7;
      }
      uint64_t v5 = v4 + 104;
      v4 += 168;
    }
    while (v5 != v3);
  }
  return result;
}

void sub_100CD7C68(_Unwind_Exception *a1)
{
  sub_1000886C0(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100CD7C80(unsigned int *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *((unsigned __int8 *)a1 + 31);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a1 + 2);
  }
  if (!v4)
  {
    uint64_t v5 = *((unsigned __int8 *)a1 + 55);
    if ((v5 & 0x80u) != 0) {
      uint64_t v5 = *((void *)a1 + 5);
    }
    if (!v5)
    {
      *a2 = 0;
      return;
    }
  }
  int v6 = a1 + 2;
  id v17 = objc_alloc_init((Class)NSMutableDictionary);
  if (*((char *)a1 + 31) < 0)
  {
    if (!*((void *)a1 + 2)) {
      goto LABEL_13;
    }
    int v6 = (void *)*v6;
    goto LABEL_12;
  }
  if (*((unsigned char *)a1 + 31))
  {
LABEL_12:
    BOOL v7 = +[NSString stringWithUTF8String:v6];
    uint64_t v8 = +[NSString stringWithUTF8String:"kProductClass"];
    [v17 setObject:v7 forKeyedSubscript:v8];
  }
LABEL_13:
  uint64_t v9 = a1 + 8;
  if (*((char *)a1 + 55) < 0)
  {
    if (!*((void *)a1 + 5)) {
      goto LABEL_19;
    }
    uint64_t v9 = (void *)*v9;
    goto LABEL_18;
  }
  if (*((unsigned char *)a1 + 55))
  {
LABEL_18:
    char v10 = +[NSString stringWithUTF8String:v9];
    BOOL v11 = +[NSString stringWithUTF8String:"kEid"];
    [v17 setObject:v10 forKeyedSubscript:v11];
  }
LABEL_19:
  int v12 = +[NSNumber numberWithUnsignedInt:*a1];
  uint64_t v13 = +[NSString stringWithUTF8String:"kOsVersion"];
  [v17 setObject:v12 forKeyedSubscript:v13];

  uint64_t v14 = a1 + 14;
  if ((*((char *)a1 + 79) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)a1 + 79)) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (*((void *)a1 + 8))
  {
    uint64_t v14 = (void *)*v14;
LABEL_24:
    CSIPhoneNumber v15 = +[NSString stringWithUTF8String:v14];
    long long v16 = +[NSString stringWithUTF8String:"kIMEI"];
    [v17 setObject:v15 forKeyedSubscript:v16];
  }
LABEL_25:
  sub_10004EFAC(a2, v17);
}

void sub_100CD7EA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100CD7EFC(id *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  if (*a1) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    id v12 = *a1;
    uint64_t v4 = +[NSString stringWithUTF8String:"kProductClass"];
    uint64_t v5 = [v12 objectForKey:v4];

    if (v5)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        sub_10003ED78((std::string *)(a2 + 8), (char *)[v5 UTF8String]);
      }
    }
    int v6 = +[NSString stringWithUTF8String:"kEid"];
    BOOL v7 = [v12 objectForKey:v6];

    if (v7)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        sub_10003ED78((std::string *)(a2 + 32), (char *)[v7 UTF8String]);
      }
    }
    uint64_t v8 = +[NSString stringWithUTF8String:"kOsVersion"];
    uint64_t v9 = [v12 objectForKey:v8];

    if (v9)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        *(_DWORD *)a2 = [v9 unsignedIntValue];
      }
    }
    char v10 = +[NSString stringWithUTF8String:"kIMEI"];
    BOOL v11 = [v12 objectForKey:v10];

    if (v11)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        sub_10003ED78((std::string *)(a2 + 56), (char *)[v11 UTF8String]);
      }
    }
  }
}

void sub_100CD8160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  sub_10021BC80(v10);
  _Unwind_Resume(a1);
}

void sub_100CD81C4(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((unsigned __int8 *)a1 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = a1[1];
  }
  if (!v3) {
    goto LABEL_24;
  }
  uint64_t v5 = *((unsigned __int8 *)a1 + 47);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = a1[4];
  }
  if (!v5) {
    goto LABEL_24;
  }
  uint64_t v6 = *((unsigned __int8 *)a1 + 87);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = a1[9];
  }
  if (v6)
  {
    id v24 = objc_alloc_init((Class)NSMutableDictionary);
    if (*((char *)a1 + 23) >= 0) {
      BOOL v7 = a1;
    }
    else {
      BOOL v7 = (uint64_t *)*a1;
    }
    uint64_t v8 = +[NSString stringWithUTF8String:v7];
    uint64_t v9 = +[NSString stringWithUTF8String:"kUUID"];
    [v24 setObject:v8 forKeyedSubscript:v9];

    if (*((char *)a1 + 47) >= 0) {
      uint64_t v10 = (uint64_t)(a1 + 3);
    }
    else {
      uint64_t v10 = a1[3];
    }
    BOOL v11 = +[NSString stringWithUTF8String:v10];
    id v12 = +[NSString stringWithUTF8String:"kICCID"];
    [v24 setObject:v11 forKeyedSubscript:v12];

    if (*((char *)a1 + 87) >= 0) {
      uint64_t v13 = (uint64_t)(a1 + 8);
    }
    else {
      uint64_t v13 = a1[8];
    }
    uint64_t v14 = +[NSString stringWithUTF8String:v13];
    CSIPhoneNumber v15 = +[NSString stringWithUTF8String:"kType"];
    [v24 setObject:v14 forKeyedSubscript:v15];

    long long v16 = +[NSNumber numberWithInt:*((unsigned __int8 *)a1 + 112)];
    id v17 = +[NSString stringWithUTF8String:"kError"];
    [v24 setObject:v16 forKeyedSubscript:v17];

    uint64_t v18 = a1[11];
    uint64_t v19 = a1[12];
    if (v18 != v19)
    {
      uint64_t v20 = +[NSData dataWithBytes:v18 length:v19 - v18];
      uint64_t v21 = +[NSString stringWithUTF8String:"kPayload"];
      [v24 setObject:v20 forKeyedSubscript:v21];
    }
    uint64_t v22 = +[NSData dataWithBytes:a1 + 6 length:16];
    long long v23 = +[NSString stringWithUTF8String:"kEid"];
    [v24 setObject:v22 forKeyedSubscript:v23];

    sub_10004EFAC(a2, v24);
  }
  else
  {
LABEL_24:
    *a2 = 0;
  }
}

void sub_100CD8474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100CD84D8(id *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = 0u;
  uint64_t v3 = (std::string *)(a2 + 64);
  *(void *)(a2 + 112) = 0;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  if (*a1) {
    uint64_t v4 = sub_100080778;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    id v21 = *a1;
    uint64_t v5 = +[NSString stringWithUTF8String:"kUUID"];
    uint64_t v6 = [v21 objectForKey:v5];

    if (v6)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        sub_10003ED78((std::string *)a2, (char *)[v6 UTF8String]);
      }
    }
    BOOL v7 = +[NSString stringWithUTF8String:"kICCID"];
    uint64_t v8 = [v21 objectForKey:v7];

    if (v8)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        sub_10003ED78((std::string *)(a2 + 24), (char *)[v8 UTF8String]);
      }
    }
    uint64_t v9 = +[NSString stringWithUTF8String:"kType"];
    uint64_t v10 = [v21 objectForKey:v9];

    if (v10)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        sub_10003ED78(v3, (char *)[v10 UTF8String]);
      }
    }
    BOOL v11 = +[NSString stringWithUTF8String:"kError"];
    id v12 = [v21 objectForKey:v11];

    if (v12)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        *(unsigned char *)(a2 + 112) = [v12 unsignedIntValue];
      }
    }
    uint64_t v13 = +[NSString stringWithUTF8String:"kPayload"];
    uint64_t v14 = [v21 objectForKey:v13];

    if (v14)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v15 = v14;
        long long v16 = (char *)[v15 bytes];
        id v17 = (char *)[v15 length];
        sub_10006E4A8((void *)(a2 + 88), v16, &v17[(void)v16], (unint64_t)v17);
      }
    }
    uint64_t v18 = +[NSString stringWithUTF8String:"kEid"];
    uint64_t v19 = [v21 objectForKey:v18];

    if (v19)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v20 = v19;
        if ([v20 length] == (id)16) {
          *(_OWORD *)(a2 + 48) = *(_OWORD *)[v20 bytes];
        }
      }
    }
  }
}

void sub_100CD886C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  sub_10010A904(v10);
  _Unwind_Resume(a1);
}

void sub_100CD8904(unsigned int a1@<W0>, void *a2@<X8>)
{
  id v6 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v4 = +[NSNumber numberWithUnsignedInteger:a1];
  uint64_t v5 = +[NSString stringWithUTF8String:"kConsentState"];
  [v6 setObject:v4 forKeyedSubscript:v5];

  sub_10004EFAC(a2, v6);
}

void sub_100CD89B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100CD89E0(id *a1)
{
  if (*a1) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (v1)
  {
    id v2 = *a1;
    uint64_t v3 = +[NSString stringWithUTF8String:"kConsentState"];
    uint64_t v4 = [v2 objectForKey:v3];

    if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      unsigned __int8 v5 = [v4 unsignedIntegerValue];
    }
    else {
      unsigned __int8 v5 = 4;
    }
  }
  else
  {
    return 4;
  }
  return v5;
}

void sub_100CD8AA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100CD8AD8(uint64_t a1@<X0>, void *a2@<X8>)
{
  id v6 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v4 = +[NSNumber numberWithBool:a1];
  unsigned __int8 v5 = +[NSString stringWithUTF8String:"kShowProxCardOnSource"];
  [v6 setObject:v4 forKey:v5];

  sub_10004EFAC(a2, v6);
}

void sub_100CD8B88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id sub_100CD8BB4(id *a1)
{
  if (*a1) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    return 0;
  }
  id v2 = *a1;
  uint64_t v3 = +[NSString stringWithUTF8String:"kShowProxCardOnSource"];
  uint64_t v4 = [v2 objectForKey:v3];

  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    id v5 = [v4 BOOLValue];
  }
  else {
    id v5 = 0;
  }

  return v5;
}

void sub_100CD8C7C(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_100CD8CA8(uint64_t a1@<X0>, void *a2@<X8>)
{
  id v5 = (id)objc_opt_new();
  uint64_t v4 = +[NSNumber numberWithBool:a1];
  [v5 setObject:v4 forKey:@"UpdateProxCardVisibility"];

  sub_10004EFAC(a2, v5);
}

void sub_100CD8D34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100CD8D54(os_log_t *a1, void **a2)
{
  id v2 = *a2;
  if (*a2) {
    uint64_t v3 = sub_100083F10;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!v3) {
    return 1;
  }
  id v5 = v2;
  uint64_t v25 = v5;
  if (v2)
  {
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    id v6 = v5;
    id v22 = [v6 countByEnumeratingWithState:&v30 objects:v37 count:16];
    if (v22)
    {
      id v21 = a1;
      uint64_t v23 = *(void *)v31;
      obuint64_t j = v6;
      do
      {
        for (uint64_t i = 0; i != v22; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v31 != v23) {
            objc_enumerationMutation(obj);
          }
          uint64_t v8 = *(void **)(*((void *)&v30 + 1) + 8 * i);
          long long v26 = 0u;
          long long v27 = 0u;
          long long v28 = 0u;
          long long v29 = 0u;
          uint64_t v9 = [v8 remoteDisplayPlans];
          id v10 = [v9 countByEnumeratingWithState:&v26 objects:v36 count:16];
          if (v10)
          {
            uint64_t v11 = *(void *)v27;
            while (2)
            {
              for (uint64_t j = 0; j != v10; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v27 != v11) {
                  objc_enumerationMutation(v9);
                }
                uint64_t v13 = [*(id *)(*((void *)&v26 + 1) + 8 * (void)j) plan];
                uint64_t v14 = [v13 planID];
                id v15 = [v14 mcc];
                if (![v15 length])
                {

LABEL_27:
                  uint64_t v19 = *v21;
                  if (os_log_type_enabled(*v21, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)std::string buf = 138412290;
                    long long v35 = v14;
                    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Invalid add on plan identifiers: %@", buf, 0xCu);
                  }

                  uint64_t v18 = 0;
                  id v6 = obj;
                  goto LABEL_30;
                }
                long long v16 = [v14 mnc];
                BOOL v17 = [v16 length] == 0;

                if (v17) {
                  goto LABEL_27;
                }
              }
              id v10 = [v9 countByEnumeratingWithState:&v26 objects:v36 count:16];
              if (v10) {
                continue;
              }
              break;
            }
          }
        }
        id v6 = obj;
        uint64_t v18 = 1;
        id v22 = [obj countByEnumeratingWithState:&v30 objects:v37 count:16];
      }
      while (v22);
    }
    else
    {
      uint64_t v18 = 1;
    }
LABEL_30:
  }
  else
  {
    uint64_t v18 = 1;
  }

  return v18;
}

void sub_100CD9004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_100CD9080(void **a1@<X0>, const void **a2@<X1>, std::string *a3@<X8>)
{
  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  uint64_t v3 = *a1;
  if (*a1) {
    uint64_t v4 = sub_100083F10;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    id v6 = v3;
    if (v3)
    {
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      obuint64_t j = v6;
      id v7 = [obj countByEnumeratingWithState:&v37 objects:v42 count:16];
      if (!v7) {
        goto LABEL_32;
      }
      uint64_t v25 = *(void *)v38;
      long long v29 = a2;
      while (1)
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v38 != v25) {
            objc_enumerationMutation(obj);
          }
          uint64_t v8 = *(void **)(*((void *)&v37 + 1) + 8 * i);
          long long v33 = 0u;
          long long v34 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          uint64_t v9 = objc_msgSend(v8, "remoteDisplayPlans", v8);
          id v10 = [v9 countByEnumeratingWithState:&v33 objects:v41 count:16];
          if (v10)
          {
            long long v30 = v9;
            uint64_t v31 = *(void *)v34;
            do
            {
              for (uint64_t j = 0; j != v10; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v34 != v31) {
                  objc_enumerationMutation(v9);
                }
                id v12 = [*(id *)(*((void *)&v33 + 1) + 8 * (void)j) plan];
                long long v32 = [v12 planID];
                uint64_t v13 = [v32 iccid];
                if (![v13 length]) {
                  goto LABEL_27;
                }
                uint64_t v14 = [v12 planID];
                id v15 = [v14 iccid];
                long long v16 = (const char *)[v15 UTF8String];
                BOOL v17 = v16;
                int v18 = *((char *)v29 + 23);
                if (v18 >= 0) {
                  size_t v19 = *((unsigned __int8 *)v29 + 23);
                }
                else {
                  size_t v19 = (size_t)v29[1];
                }
                if (v19 != strlen(v16))
                {

                  uint64_t v9 = v30;
LABEL_27:

                  goto LABEL_28;
                }
                if (v18 >= 0) {
                  id v20 = v29;
                }
                else {
                  id v20 = *v29;
                }
                BOOL v21 = memcmp(v20, v17, v19) == 0;

                uint64_t v9 = v30;
                if (v21)
                {
                  id v22 = [v24 deviceID];
                  id v23 = [v22 IMEI];
                  sub_10003ED78(a3, (char *)[v23 UTF8String]);

                  goto LABEL_32;
                }
LABEL_28:
              }
              id v10 = [v9 countByEnumeratingWithState:&v33 objects:v41 count:16];
            }
            while (v10);
          }
        }
        id v7 = [obj countByEnumeratingWithState:&v37 objects:v42 count:16];
        if (!v7)
        {
LABEL_32:

          return;
        }
      }
    }
  }
}

void sub_100CD9394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  if (*(char *)(a12 + 23) < 0) {
    operator delete(*(void **)a12);
  }
  _Unwind_Resume(a1);
}

void sub_100CD9464(void **a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long v34 = (uint64_t **)(a2 + 8);
  *(void *)a2 = a2 + 8;
  id v2 = *a1;
  if (*a1) {
    uint64_t v3 = sub_100083F10;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!v3) {
    return;
  }
  id v4 = v2;
  id v5 = v4;
  if (!v2) {
    goto LABEL_35;
  }
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  obuint64_t j = v4;
  id v27 = [obj countByEnumeratingWithState:&v41 objects:v48 count:16];
  if (!v27) {
    goto LABEL_34;
  }
  uint64_t v26 = *(void *)v42;
  do
  {
    for (uint64_t i = 0; i != v27; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v42 != v26) {
        objc_enumerationMutation(obj);
      }
      id v6 = *(void **)(*((void *)&v41 + 1) + 8 * i);
      long long v37 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v33 = v6;
      id v7 = [v6 remoteDisplayPlans];
      id v8 = [v7 countByEnumeratingWithState:&v37 objects:v47 count:16];
      if (v8)
      {
        uint64_t v32 = *(void *)v38;
        long long v30 = v7;
        do
        {
          id v35 = v8;
          for (uint64_t j = 0; j != v35; uint64_t j = (char *)j + 1)
          {
            if (*(void *)v38 != v32) {
              objc_enumerationMutation(v7);
            }
            id v10 = [*(id *)(*((void *)&v37 + 1) + 8 * (void)j) plan];
            uint64_t v11 = [v10 planID];
            long long v36 = v10;
            id v12 = [v11 iccid];
            if ([v12 length])
            {
              uint64_t v13 = [v33 deviceID];
              uint64_t v14 = [v13 idsDeviceId];
              BOOL v15 = [v14 length] == 0;

              if (v15) {
                goto LABEL_30;
              }
              uint64_t v11 = [v36 planID];
              id v12 = [v11 iccid];
              long long v16 = (char *)[v12 UTF8String];
              BOOL v17 = [v33 deviceID];
              id v31 = [v17 idsDeviceId];
              int v18 = (char *)[v31 UTF8String];
              uint64_t v46 = 0;
              size_t v19 = operator new(0x50uLL);
              v45[0] = v19;
              v45[1] = v34;
              LOBYTE(v46) = 0;
              sub_100058DB0(v19 + 4, v16);
              sub_100058DB0(v19 + 7, v18);
              LOBYTE(v46) = 1;
              id v20 = (uint64_t *)v45[0];
              BOOL v21 = v34;
              id v22 = v34;
              id v23 = *v34;
              if (!*v34) {
                goto LABEL_27;
              }
              BOOL v21 = v34;
              while (1)
              {
                while (1)
                {
                  id v22 = (uint64_t **)v23;
                  id v24 = v23 + 4;
                  if ((sub_100046FE8(v20 + 4, (void **)v23 + 4) & 0x80) == 0) {
                    break;
                  }
                  id v23 = *v22;
                  BOOL v21 = v22;
                  if (!*v22) {
                    goto LABEL_27;
                  }
                }
                if ((sub_100046FE8(v24, (void **)v20 + 4) & 0x80) == 0) {
                  break;
                }
                BOOL v21 = v22 + 1;
                id v23 = v22[1];
                if (!v23) {
                  goto LABEL_27;
                }
              }
              if (!*v21)
              {
LABEL_27:
                sub_100046C38((uint64_t **)a2, (uint64_t)v22, v21, v20);
                v45[0] = 0;
              }
              sub_10010E764((uint64_t)v45, 0);

              id v7 = v30;
            }

LABEL_30:
          }
          id v8 = [v7 countByEnumeratingWithState:&v37 objects:v47 count:16];
        }
        while (v8);
      }
    }
    id v27 = [obj countByEnumeratingWithState:&v41 objects:v48 count:16];
  }
  while (v27);
LABEL_34:

LABEL_35:
}

void sub_100CD980C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  sub_10010C0E0(a13, *(void **)(a13 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100CD990C@<X0>(uint64_t *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  uint64_t v3 = result + 1;
  id v4 = (void *)*result;
  if ((uint64_t *)*result != result + 1)
  {
    while (*((char *)v4 + 63) < 0)
    {
      if (v4[6]) {
        goto LABEL_6;
      }
LABEL_7:
      id v5 = (uint64_t *)v4[1];
      if (v5)
      {
        do
        {
          id v6 = v5;
          id v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          id v6 = (uint64_t *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          id v4 = v6;
        }
        while (!v7);
      }
      id v4 = v6;
      if (v6 == v3) {
        return result;
      }
    }
    if (!*((unsigned char *)v4 + 63)) {
      goto LABEL_7;
    }
LABEL_6:
    uint64_t result = sub_100046BAC((uint64_t **)a2, (void **)v4 + 5, (uint64_t)(v4 + 5));
    goto LABEL_7;
  }
  return result;
}

void sub_100CD99B4(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100CD99CC(os_log_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2)
  {
    id v6 = +[NSBundle bundleWithPath:@"/System/Library/PrivateFrameworks/Settings/GeneralSettingsUI.framework"];
    BOOL v7 = v6;
    if (v6)
    {
      id v8 = [v6 localizedStringForKey:a2 value:0 table:@"ModelNames"];
      uint64_t v9 = v8;
      if (v8)
      {
        sub_100058DB0(a3, (char *)[v8 UTF8String]);
      }
      else
      {
        id v12 = *a1;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v13) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "localize model name failed", (uint8_t *)&v13, 2u);
        }
        long long v13 = 0uLL;
        uint64_t v14 = 0;
        ctu::cf::assign();
        *(_OWORD *)a3 = v13;
        a3[2] = v14;
      }
    }
    else
    {
      uint64_t v11 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v13) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "load bundle for GeneralSettingsUI failed", (uint8_t *)&v13, 2u);
      }
      long long v13 = 0uLL;
      uint64_t v14 = 0;
      ctu::cf::assign();
      *(_OWORD *)a3 = v13;
      a3[2] = v14;
    }
  }
  else
  {
    id v10 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v13) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "empty model name", (uint8_t *)&v13, 2u);
    }
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
}

void sub_100CD9B90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100CD9BDC(int a1@<W0>, int a2@<W1>, void *a3@<X2>, uint64_t *a4@<X3>, char *a5@<X4>, void *a6@<X8>)
{
  id v23 = (id)objc_opt_new();
  if (((a1 - 1) & 0xFC) != 0) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (a1 - 1) + 1;
  }
  long long v13 = +[NSNumber numberWithInteger:v12];
  [v23 setObject:v13 forKey:@"TransferState"];

  if (*a3) {
    uint64_t v14 = sub_100080778;
  }
  else {
    uint64_t v14 = 0;
  }
  if (v14) {
    objc_msgSend(v23, "setObject:forKey:");
  }
  BOOL v15 = sub_1003DF5C4(a2);
  long long v16 = v15;
  if (v15)
  {
    BOOL v17 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v15 code]);
    [v23 setObject:v17 forKey:@"TransferErrorCode"];
  }
  if (*((char *)a4 + 23) < 0)
  {
    if (!a4[1]) {
      goto LABEL_17;
    }
    a4 = (uint64_t *)*a4;
    goto LABEL_16;
  }
  if (*((unsigned char *)a4 + 23))
  {
LABEL_16:
    int v18 = +[NSString stringWithCString:a4 encoding:4];
    [v23 setObject:v18 forKey:@"CarrierName"];
  }
LABEL_17:
  unint64_t v19 = a5[23];
  int v20 = (char)v19;
  if ((v19 & 0x80u) != 0) {
    unint64_t v19 = *((void *)a5 + 1);
  }
  if (v19 <= 5 && sub_100CD9E24(a5))
  {
    if (v20 >= 0) {
      BOOL v21 = (uint64_t *)a5;
    }
    else {
      BOOL v21 = *(uint64_t **)a5;
    }
    id v22 = +[NSString stringWithCString:v21 encoding:4];
    [v23 setObject:v22 forKey:@"CarrierErrorCode"];
  }
  sub_10004EFAC(a6, v23);
}

void sub_100CD9DD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100CD9E24(char *a1)
{
  if (a1[23] < 0)
  {
    uint64_t v1 = *((void *)a1 + 1);
    if (v1)
    {
      a1 = *(char **)a1;
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v1 = a1[23];
    if (a1[23])
    {
LABEL_6:
      while ((*a1 & 0x80000000) == 0 && (_DefaultRuneLocale.__runetype[*a1] & 0x400) != 0)
      {
        ++a1;
        if (!--v1) {
          return 1;
        }
      }
    }
  }
  return 0;
}

void sub_100CD9E80(uint64_t *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  id v9 = (id)objc_opt_new();
  id v6 = +[NSNumber numberWithInteger:5];
  [v9 setObject:v6 forKey:@"TransferState"];

  if (*((char *)a1 + 23) < 0)
  {
    if (!a1[1]) {
      goto LABEL_7;
    }
    a1 = (uint64_t *)*a1;
    goto LABEL_6;
  }
  if (*((unsigned char *)a1 + 23))
  {
LABEL_6:
    BOOL v7 = +[NSString stringWithUTF8String:a1];
    [v9 setObject:v7 forKey:@"Iccid"];
  }
LABEL_7:
  if (*((char *)a2 + 23) < 0)
  {
    if (!a2[1]) {
      goto LABEL_13;
    }
    a2 = (uint64_t *)*a2;
    goto LABEL_12;
  }
  if (*((unsigned char *)a2 + 23))
  {
LABEL_12:
    id v8 = +[NSString stringWithUTF8String:a2];
    [v9 setObject:v8 forKey:@"TCMainTextKey"];
  }
LABEL_13:
  sub_10004EFAC(a3, v9);
}

void sub_100CD9FAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100CD9FE4(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  id v15 = (id)objc_opt_new();
  id v10 = +[NSNumber numberWithInteger:6];
  [v15 setObject:v10 forKey:@"TransferState"];

  if (*((char *)a1 + 23) < 0)
  {
    if (!a1[1]) {
      goto LABEL_7;
    }
    a1 = (uint64_t *)*a1;
    goto LABEL_6;
  }
  if (*((unsigned char *)a1 + 23))
  {
LABEL_6:
    uint64_t v11 = +[NSString stringWithUTF8String:a1];
    [v15 setObject:v11 forKey:@"Iccid"];
  }
LABEL_7:
  if (*((char *)a2 + 23) < 0)
  {
    if (!a2[1]) {
      goto LABEL_13;
    }
    a2 = (uint64_t *)*a2;
    goto LABEL_12;
  }
  if (*((unsigned char *)a2 + 23))
  {
LABEL_12:
    uint64_t v12 = +[NSString stringWithUTF8String:a2];
    [v15 setObject:v12 forKey:@"PhoneNumberKey"];
  }
LABEL_13:
  if (*((char *)a3 + 23) < 0)
  {
    if (!a3[1]) {
      goto LABEL_19;
    }
    a3 = (uint64_t *)*a3;
    goto LABEL_18;
  }
  if (*((unsigned char *)a3 + 23))
  {
LABEL_18:
    long long v13 = +[NSString stringWithUTF8String:a3];
    [v15 setObject:v13 forKey:@"CarrierName"];
  }
LABEL_19:
  uint64_t v14 = +[NSNumber numberWithBool:a4];
  [v15 setObject:v14 forKey:@"UsePinKey"];

  sub_10004EFAC(a5, v15);
}

void sub_100CDA19C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100CDA1EC(uint64_t a1@<X0>, void *a2@<X8>)
{
  id v6 = (id)objc_opt_new();
  id v4 = +[NSNumber numberWithInteger:7];
  [v6 setObject:v4 forKey:@"TransferState"];

  id v5 = +[NSNumber numberWithBool:a1];
  [v6 setObject:v5 forKey:@"OtpStateKey"];

  sub_10004EFAC(a2, v6);
}

void sub_100CDA2AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100CDA2D8(char **a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v6 = (uint64_t)(a1 + 2);
    do
    {
      uint64_t v27 = 0;
      long long v25 = 0u;
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)id v23 = 0u;
      *(_OWORD *)id v24 = 0u;
      *(_OWORD *)BOOL v21 = 0u;
      long long v22 = 0u;
      memset(v20, 0, sizeof(v20));
      long long v18 = 0u;
      *(_OWORD *)unint64_t v19 = 0u;
      sub_10002E664((uint64_t)&v18, v4);
      if (DWORD2(v18) == 5)
      {
        id v8 = a1[1];
        unint64_t v7 = (unint64_t)a1[2];
        if ((unint64_t)v8 >= v7)
        {
          id v10 = *a1;
          uint64_t v11 = (v8 - *a1) >> 2;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 62) {
            sub_10006A748();
          }
          uint64_t v13 = v7 - (void)v10;
          if (v13 >> 1 > v12) {
            unint64_t v12 = v13 >> 1;
          }
          if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v12;
          }
          if (v14)
          {
            id v15 = (char *)sub_10005ECD8(v6, v14);
            id v10 = *a1;
            id v8 = a1[1];
          }
          else
          {
            id v15 = 0;
          }
          long long v16 = &v15[4 * v11];
          *(_DWORD *)long long v16 = v18;
          id v9 = v16 + 4;
          while (v8 != v10)
          {
            int v17 = *((_DWORD *)v8 - 1);
            v8 -= 4;
            *((_DWORD *)v16 - 1) = v17;
            v16 -= 4;
          }
          *a1 = v16;
          a1[1] = v9;
          a1[2] = &v15[4 * v14];
          if (v10) {
            operator delete(v10);
          }
        }
        else
        {
          *(_DWORD *)id v8 = v18;
          id v9 = v8 + 4;
        }
        a1[1] = v9;
      }
      if (SHIBYTE(v27) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v25) < 0) {
        operator delete(v24[1]);
      }
      if (SHIBYTE(v24[0]) < 0) {
        operator delete(v23[0]);
      }
      if (SHIBYTE(v22) < 0) {
        operator delete(v21[1]);
      }
      long long v28 = (void **)v20 + 1;
      sub_10002E39C(&v28);
      if (v19[0])
      {
        v19[1] = v19[0];
        operator delete(v19[0]);
      }
      v4 += 168;
    }
    while (v4 != a3);
  }
}

void sub_100CDA498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100086B34((uint64_t)&a9);
  uint64_t v11 = *(void **)v9;
  if (*(void *)v9)
  {
    *(void *)(v9 + 8) = v11;
    operator delete(v11);
  }
  _Unwind_Resume(a1);
}

void sub_100CDA4C8(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, int a4@<W3>, char a5@<W4>, int a6@<W5>, std::string *a7@<X8>)
{
  uint64_t v104 = 0;
  long long v105 = 0;
  uint64_t v106 = 0;
  sub_10008CF3C(&v104, (uint64_t)a1);
  long long v102 = 0u;
  long long v103 = 0u;
  long long v101 = 0u;
  sub_10008CF3C((uint64_t *)&v101, (uint64_t)&v104);
  sub_10008CF3C((uint64_t *)&v102 + 1, (uint64_t)a1);
  if (!a4 || (a5 & 1) == 0)
  {
    a7->__r_.__value_.__r.__words[0] = 0;
    a7->__r_.__value_.__l.__size_ = 0;
    a7->__r_.__value_.__r.__words[2] = 0;
    long long v25 = (uint64_t *)v103;
    if ((void)v103)
    {
      uint64_t v26 = &v103;
      do
      {
        uint64_t v27 = (long long *)v25;
        long long v28 = v26;
        int v29 = *((_DWORD *)v25 + 8);
        if (v29 >= 2) {
          uint64_t v26 = (long long *)v25;
        }
        else {
          ++v25;
        }
        long long v25 = (uint64_t *)*v25;
      }
      while (v25);
      if (v26 != &v103)
      {
        long long v30 = (int *)(v29 >= 2 ? v27 : v28);
        if (v30[8] <= 2)
        {
          if (v29 >= 2) {
            id v31 = (const std::string *)((char *)v27 + 40);
          }
          else {
            id v31 = (const std::string *)((char *)v28 + 40);
          }
          int v32 = *((char *)v26 + 63);
          if (v32 < 0)
          {
            if (v29 < 2) {
              uint64_t v27 = v28;
            }
            if (*((void *)v27 + 6)) {
              goto LABEL_37;
            }
          }
          else if ((_BYTE)v32)
          {
LABEL_37:
            std::string::operator=(a7, v31);
            goto LABEL_205;
          }
        }
      }
    }
    memset(__dst, 0, 24);
    if (!(void)v102) {
      goto LABEL_141;
    }
    uint64_t v68 = (_OWORD *)v101;
    if ((long long *)v101 == (long long *)((char *)&v101 + 8)) {
      goto LABEL_141;
    }
    while (1)
    {
      if (*((char *)v68 + 63) < 0)
      {
        if (*((void *)v68 + 6))
        {
LABEL_140:
          std::string::operator=((std::string *)__dst, (const std::string *)((char *)v68 + 40));
LABEL_141:
          *(_OWORD *)&a7->__r_.__value_.__l.__data_ = *(_OWORD *)__dst;
          a7->__r_.__value_.__r.__words[2] = *(void *)&__dst[16];
          goto LABEL_205;
        }
      }
      else if (*((unsigned char *)v68 + 63))
      {
        goto LABEL_140;
      }
      int v69 = (void *)*((void *)v68 + 1);
      if (v69)
      {
        do
        {
          BOOL v70 = v69;
          int v69 = (void *)*v69;
        }
        while (v69);
      }
      else
      {
        do
        {
          BOOL v70 = (_OWORD *)*((void *)v68 + 2);
          BOOL v71 = *(void *)v70 == (void)v68;
          uint64_t v68 = v70;
        }
        while (!v71);
      }
      uint64_t v68 = v70;
      if (v70 == (long long *)((char *)&v101 + 8)) {
        goto LABEL_141;
      }
    }
  }
  if (a6)
  {
    unint64_t v14 = (int *)*a2;
    id v15 = (int *)a2[1];
    if ((int *)*a2 != v15)
    {
      while (v14[1] != 1)
      {
        v14 += 42;
        if (v14 == v15)
        {
          unint64_t v14 = (int *)a2[1];
          break;
        }
      }
    }
    uint64_t v18 = a1[1];
    int v17 = a1 + 1;
    uint64_t v16 = v18;
    if (!v18) {
      goto LABEL_18;
    }
    int v19 = *v14;
    int v20 = v17;
    do
    {
      int v21 = *(_DWORD *)(v16 + 32);
      BOOL v22 = v21 < v19;
      if (v21 >= v19) {
        id v23 = (uint64_t *)v16;
      }
      else {
        id v23 = (uint64_t *)(v16 + 8);
      }
      if (!v22) {
        int v20 = (void *)v16;
      }
      uint64_t v16 = *v23;
    }
    while (*v23);
    if (v20 == v17 || v19 < *((_DWORD *)v20 + 8)) {
LABEL_18:
    }
      int v20 = v17;
    if (*((char *)v20 + 63) < 0)
    {
      sub_10004FC84(a7, (void *)v20[5], v20[6]);
    }
    else
    {
      long long v24 = *(_OWORD *)(v20 + 5);
      a7->__r_.__value_.__r.__words[2] = v20[7];
      *(_OWORD *)&a7->__r_.__value_.__l.__data_ = v24;
    }
    goto LABEL_205;
  }
  long long v98 = 0;
  unsigned int v99 = 0;
  uint64_t v100 = 0;
  sub_100CDA2D8((char **)&v98, *a2, a2[1]);
  if (v99 == v98)
  {
    uint64_t v57 = a1[1];
    long long v56 = a1 + 1;
    uint64_t v55 = v57;
    if (!v57) {
      goto LABEL_117;
    }
    long long v58 = v56;
    do
    {
      int v59 = *(_DWORD *)(v55 + 32);
      BOOL v60 = v59 < 1;
      if (v59 >= 1) {
        long long v61 = (uint64_t *)v55;
      }
      else {
        long long v61 = (uint64_t *)(v55 + 8);
      }
      if (!v60) {
        long long v58 = (void *)v55;
      }
      uint64_t v55 = *v61;
    }
    while (*v61);
    if (v58 == v56 || *((int *)v58 + 8) >= 2) {
LABEL_117:
    }
      long long v58 = v56;
    if (*((char *)v58 + 63) < 0)
    {
      sub_10004FC84(a7, (void *)v58[5], v58[6]);
    }
    else
    {
      long long v62 = *(_OWORD *)(v58 + 5);
      a7->__r_.__value_.__r.__words[2] = v58[7];
      *(_OWORD *)&a7->__r_.__value_.__l.__data_ = v62;
    }
    goto LABEL_203;
  }
  *(_OWORD *)long long v96 = 0u;
  long long v97 = 0u;
  uint64_t v33 = *a3;
  uint64_t v34 = a3[1];
  *(_OWORD *)long long v107 = 0u;
  long long v108 = 0u;
  if (v33 == v34) {
    goto LABEL_99;
  }
  do
  {
    uint64_t v127 = 0;
    long long v125 = 0u;
    long long v126 = 0u;
    long long v123 = 0u;
    long long v124 = 0u;
    long long v122 = 0u;
    sub_1000C5DA8((uint64_t)&v122, v33);
    if ((_BYTE)v127)
    {
      uint64_t v35 = *((void *)&v125 + 1);
      uint64_t v36 = v126;
      while (v35 != v36)
      {
        uint64_t v121 = 0;
        long long v119 = 0u;
        long long v120 = 0u;
        *(_OWORD *)std::string __p = 0u;
        long long v118 = 0u;
        *(_OWORD *)std::string::size_type v115 = 0u;
        long long v116 = 0u;
        *(_OWORD *)size_t __n = 0u;
        *(_OWORD *)char v114 = 0u;
        long long v111 = 0u;
        *(_OWORD *)std::string __s1 = 0u;
        long long v110 = 0u;
        memset(__dst, 0, sizeof(__dst));
        sub_1000C5AB4((uint64_t)__dst, v35);
        if (LOBYTE(__n[1]) && BYTE1(__n[1]))
        {
          uint64_t v37 = BYTE7(v110);
          if (SBYTE7(v110) < 0) {
            uint64_t v37 = *(void *)&__dst[24];
          }
          if (v37)
          {
            sub_100093B44((std::string *)v107, (const std::string *)&__dst[16]);
            sub_1000C584C((uint64_t)__dst);
            break;
          }
        }
        sub_1000C584C((uint64_t)__dst);
        v35 += 216;
      }
      if ((_BYTE)v127)
      {
        *(void *)std::string __dst = (char *)&v125 + 8;
        sub_1000C57C8((void ***)__dst);
      }
    }
    if (SBYTE7(v125) < 0) {
      operator delete((void *)v124);
    }
    v33 += 88;
  }
  while (v33 != v34);
  if (!BYTE8(v108)) {
    goto LABEL_99;
  }
  uint64_t v38 = *a2;
  uint64_t v39 = a2[1];
  if (*a2 == v39) {
    goto LABEL_99;
  }
  int v40 = 0;
  do
  {
    *(void *)&long long v118 = 0;
    long long v116 = 0u;
    *(_OWORD *)std::string __p = 0u;
    *(_OWORD *)char v114 = 0u;
    *(_OWORD *)std::string::size_type v115 = 0u;
    *(_OWORD *)std::string __s1 = 0u;
    *(_OWORD *)size_t __n = 0u;
    long long v110 = 0u;
    long long v111 = 0u;
    memset(__dst, 0, sizeof(__dst));
    sub_10002E664((uint64_t)__dst, v38);
    if (*(_DWORD *)&__dst[8] == 5)
    {
      if (!BYTE8(v108)) {
        sub_10016C840();
      }
      uint64_t v41 = HIBYTE(__n[1]);
      if ((__n[1] & 0x8000000000000000) == 0) {
        size_t v42 = HIBYTE(__n[1]);
      }
      else {
        size_t v42 = __n[0];
      }
      long long v43 = (void *)BYTE7(v108);
      if (SBYTE7(v108) < 0) {
        long long v43 = v107[1];
      }
      if ((void *)v42 == v43)
      {
        if ((SBYTE7(v108) & 0x80u) == 0) {
          long long v44 = v107;
        }
        else {
          long long v44 = (void **)v107[0];
        }
        if ((__n[1] & 0x8000000000000000) != 0)
        {
          if (memcmp(__s1[1], v44, __n[0])) {
            goto LABEL_77;
          }
LABEL_76:
          int v40 = *(_DWORD *)__dst;
          goto LABEL_77;
        }
        if (!HIBYTE(__n[1])) {
          goto LABEL_76;
        }
        char v45 = &__s1[1];
        while (*(unsigned __int8 *)v45 == *(unsigned __int8 *)v44)
        {
          char v45 = (void **)((char *)v45 + 1);
          long long v44 = (void **)((char *)v44 + 1);
          if (!--v41) {
            goto LABEL_76;
          }
        }
      }
    }
LABEL_77:
    if (SBYTE7(v118) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v116) < 0) {
      operator delete(v115[1]);
    }
    if (SHIBYTE(v115[0]) < 0) {
      operator delete(v114[0]);
    }
    if (SHIBYTE(__n[1]) < 0) {
      operator delete(__s1[1]);
    }
    *(void *)&long long v122 = (char *)&v110 + 8;
    sub_10002E39C((void ***)&v122);
    if (*(void *)&__dst[16])
    {
      *(void *)&__dst[24] = *(void *)&__dst[16];
      operator delete(*(void **)&__dst[16]);
    }
    v38 += 168;
  }
  while (v38 != v39);
  if (!v40) {
    goto LABEL_99;
  }
  uint64_t v46 = a1 + 1;
  uint64_t v47 = a1[1];
  if (!v47) {
    goto LABEL_99;
  }
  long long v48 = a1 + 1;
  uint64_t v49 = a1[1];
  do
  {
    int v50 = *(_DWORD *)(v49 + 32);
    BOOL v51 = v50 < v40;
    if (v50 >= v40) {
      uint64_t v52 = (uint64_t *)v49;
    }
    else {
      uint64_t v52 = (uint64_t *)(v49 + 8);
    }
    if (!v51) {
      long long v48 = (void *)v49;
    }
    uint64_t v49 = *v52;
  }
  while (*v52);
  if (v48 != v46 && v40 >= *((_DWORD *)v48 + 8))
  {
    uint64_t v92 = a1 + 1;
    do
    {
      int v93 = *(_DWORD *)(v47 + 32);
      BOOL v94 = v93 < v40;
      if (v93 >= v40) {
        long long v95 = (uint64_t *)v47;
      }
      else {
        long long v95 = (uint64_t *)(v47 + 8);
      }
      if (!v94) {
        uint64_t v92 = (void *)v47;
      }
      uint64_t v47 = *v95;
    }
    while (*v95);
    if (v92 == v46 || v40 < *((_DWORD *)v92 + 8)) {
      uint64_t v92 = a1 + 1;
    }
    if (*((char *)v92 + 63) < 0)
    {
      sub_10004FC84(v96, (void *)v92[5], v92[6]);
    }
    else
    {
      *(_OWORD *)long long v96 = *(_OWORD *)(v92 + 5);
      *(void *)&long long v97 = v92[7];
    }
    int v53 = 1;
  }
  else
  {
LABEL_99:
    int v53 = 0;
    LOBYTE(v96[0]) = 0;
  }
  BYTE8(v97) = v53;
  if (BYTE8(v108) && SBYTE7(v108) < 0)
  {
    operator delete(v107[0]);
    int v53 = BYTE8(v97);
  }
  if (v53)
  {
    if ((SBYTE7(v97) & 0x80000000) == 0)
    {
      *(_OWORD *)&a7->__r_.__value_.__l.__data_ = *(_OWORD *)v96;
      std::string::size_type v54 = v97;
      goto LABEL_199;
    }
    sub_10004FC84(a7, v96[0], (unint64_t)v96[1]);
  }
  else if (v99 - (unsigned char *)v98 == 4)
  {
    uint64_t v63 = *a2;
    uint64_t v64 = a2[1];
    long long v122 = 0uLL;
    *(void *)&long long v123 = 0;
    sub_100CDA2D8((char **)&v122, v63, v64);
    long long v66 = (int *)*((void *)&v122 + 1);
    uint64_t v65 = (int *)v122;
    v107[1] = 0;
    *(void *)&long long v108 = 0;
    v107[0] = &v107[1];
    if ((void)v122 == *((void *)&v122 + 1))
    {
      uint64_t v67 = 0;
    }
    else
    {
      do
      {
        sub_100602B88((uint64_t **)v107, (uint64_t *)&v107[1], v65, v65);
        ++v65;
      }
      while (v65 != v66);
      uint64_t v67 = v108;
    }
    if (a1[2] == v67 || (unint64_t v82 = (void *)*a1, v81 = a1 + 1, v80 = v82, v82 == v81))
    {
LABEL_177:
      char v91 = 0;
      __dst[0] = 0;
    }
    else
    {
      if (v107[1])
      {
        while (1)
        {
          int v83 = *((_DWORD *)v80 + 8);
          int v84 = &v107[1];
          unint64_t v85 = (void **)v107[1];
          do
          {
            uint64_t v86 = v85;
            long long v87 = v84;
            int v88 = *((_DWORD *)v85 + 7);
            if (v88 >= v83) {
              int v84 = v85;
            }
            else {
              ++v85;
            }
            unint64_t v85 = (void **)*v85;
          }
          while (v85);
          if (v84 == &v107[1]) {
            break;
          }
          if (v88 < v83) {
            uint64_t v86 = v87;
          }
          if (v83 < *((_DWORD *)v86 + 7)) {
            break;
          }
          uint64_t v89 = (void *)v80[1];
          if (v89)
          {
            do
            {
              uint64_t v90 = v89;
              uint64_t v89 = (void *)*v89;
            }
            while (v89);
          }
          else
          {
            do
            {
              uint64_t v90 = (void *)v80[2];
              BOOL v71 = *v90 == (void)v80;
              long long v80 = v90;
            }
            while (!v71);
          }
          long long v80 = v90;
          if (v90 == v81) {
            goto LABEL_177;
          }
        }
      }
      if (*((char *)v80 + 63) < 0)
      {
        sub_10004FC84(__dst, (void *)v80[5], v80[6]);
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)(v80 + 5);
        *(void *)&__dst[16] = v80[7];
      }
      char v91 = 1;
    }
    __dst[24] = v91;
    sub_1000346F8((uint64_t)v107, (void *)v107[1]);
    if ((void)v122)
    {
      *((void *)&v122 + 1) = v122;
      operator delete((void *)v122);
    }
    if (!__dst[24]) {
      sub_10016C840();
    }
    if ((__dst[23] & 0x80000000) != 0)
    {
      sub_10004FC84(a7, *(void **)__dst, *(unint64_t *)&__dst[8]);
      if (__dst[24] && (__dst[23] & 0x80000000) != 0) {
        operator delete(*(void **)__dst);
      }
    }
    else
    {
      *(_OWORD *)&a7->__r_.__value_.__l.__data_ = *(_OWORD *)__dst;
      std::string::size_type v54 = *(void *)&__dst[16];
LABEL_199:
      a7->__r_.__value_.__r.__words[2] = v54;
    }
  }
  else
  {
    uint64_t v74 = a1[1];
    uint32_t v73 = a1 + 1;
    uint64_t v72 = v74;
    if (!v74) {
      goto LABEL_154;
    }
    os_log_t v75 = v73;
    do
    {
      int v76 = *(_DWORD *)(v72 + 32);
      BOOL v77 = v76 < 2;
      if (v76 >= 2) {
        int v78 = (uint64_t *)v72;
      }
      else {
        int v78 = (uint64_t *)(v72 + 8);
      }
      if (!v77) {
        os_log_t v75 = (void *)v72;
      }
      uint64_t v72 = *v78;
    }
    while (*v78);
    if (v75 == v73 || *((int *)v75 + 8) >= 3) {
LABEL_154:
    }
      os_log_t v75 = v73;
    if (*((char *)v75 + 63) < 0)
    {
      sub_10004FC84(a7, (void *)v75[5], v75[6]);
    }
    else
    {
      long long v79 = *(_OWORD *)(v75 + 5);
      a7->__r_.__value_.__r.__words[2] = v75[7];
      *(_OWORD *)&a7->__r_.__value_.__l.__data_ = v79;
    }
  }
  if (BYTE8(v97) && SBYTE7(v97) < 0) {
    operator delete(v96[0]);
  }
LABEL_203:
  if (v98)
  {
    unsigned int v99 = v98;
    operator delete(v98);
  }
LABEL_205:
  sub_1000886C0((uint64_t)&v102 + 8, (char *)v103);
  sub_1000886C0((uint64_t)&v101, *((char **)&v101 + 1));
  sub_1000886C0((uint64_t)&v104, v105);
}

void sub_100CDADC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,char *a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43)
{
  if (a36 && a35 < 0) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  sub_100CDAF10((uint64_t)&a20);
  sub_1000886C0((uint64_t)&a27, a28);
  _Unwind_Resume(a1);
}

uint64_t sub_100CDAF10(uint64_t a1)
{
  return a1;
}

uint64_t sub_100CDAF4C(unsigned __int8 *a1)
{
  int v2 = (char)a1[23];
  if (v2 >= 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  if (v3 == 13)
  {
    uint64_t v4 = 0;
    id v5 = *(unsigned __int8 **)a1;
    if (v2 >= 0) {
      id v5 = a1;
    }
    while (aBillingerrors[v4] == v5[v4])
    {
      if (++v4 == 13) {
        return 54;
      }
    }
  }
  uint64_t v7 = byte_101B12AEF;
  if (byte_101B12AEF >= 0) {
    uint64_t v8 = byte_101B12AEF;
  }
  else {
    uint64_t v8 = qword_101B12AE0;
  }
  if (v8 == v3)
  {
    if (v2 >= 0) {
      uint64_t v9 = a1;
    }
    else {
      uint64_t v9 = *(unsigned __int8 **)a1;
    }
    if (byte_101B12AEF < 0)
    {
      if (memcmp((const void *)qword_101B12AD8, v9, qword_101B12AE0)) {
        goto LABEL_24;
      }
    }
    else if (byte_101B12AEF)
    {
      for (uint64_t i = &qword_101B12AD8; *(unsigned __int8 *)i == *v9; uint64_t i = (uint64_t *)((char *)i + 1))
      {
        ++v9;
        if (!--v7) {
          return 37;
        }
      }
      goto LABEL_24;
    }
    return 37;
  }
LABEL_24:
  if (v3 == 20)
  {
    uint64_t v13 = 0;
    unint64_t v14 = *(unsigned __int8 **)a1;
    if (v2 >= 0) {
      unint64_t v14 = a1;
    }
    while (aBlockedaccount[v13] == v14[v13])
    {
      if (++v13 == 20) {
        return 55;
      }
    }
  }
  else if (v3 == 17)
  {
    uint64_t v11 = 0;
    unint64_t v12 = *(unsigned __int8 **)a1;
    if (v2 >= 0) {
      unint64_t v12 = a1;
    }
    while (aMaintenanceerr[v11] == v12[v11])
    {
      if (++v11 == 17) {
        return 53;
      }
    }
  }
  uint64_t v15 = byte_101B12B07;
  if (byte_101B12B07 >= 0) {
    uint64_t v16 = byte_101B12B07;
  }
  else {
    uint64_t v16 = qword_101B12AF8;
  }
  if (v16 != v3) {
    return 52;
  }
  if (v2 >= 0) {
    int v17 = a1;
  }
  else {
    int v17 = *(unsigned __int8 **)a1;
  }
  if (byte_101B12B07 < 0)
  {
    if (memcmp((const void *)qword_101B12AF0, v17, qword_101B12AF8)) {
      return 52;
    }
  }
  else if (byte_101B12B07)
  {
    for (uint64_t j = &qword_101B12AF0; *(unsigned __int8 *)j == *v17; uint64_t j = (uint64_t *)((char *)j + 1))
    {
      ++v17;
      if (!--v15) {
        return 57;
      }
    }
    return 52;
  }
  return 57;
}

uint64_t sub_100CDB150(void *a1, unsigned __int8 **a2)
{
  int v2 = a1 + 1;
  uint64_t v3 = (void *)*a1;
  if ((void *)*a1 == a1 + 1) {
    return 0;
  }
  char v4 = *((unsigned char *)a2 + 23);
  if (v4 >= 0) {
    id v5 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    id v5 = a2[1];
  }
  if (v4 >= 0) {
    uint64_t v6 = (unsigned __int8 *)a2;
  }
  else {
    uint64_t v6 = *a2;
  }
  while (1)
  {
    uint64_t v7 = *((unsigned __int8 *)v3 + 63);
    if ((v7 & 0x80u) == 0) {
      uint64_t v8 = (unsigned __int8 *)*((unsigned __int8 *)v3 + 63);
    }
    else {
      uint64_t v8 = (unsigned __int8 *)v3[6];
    }
    if (v8 != v5) {
      goto LABEL_19;
    }
    uint64_t v9 = (const void **)(v3 + 5);
    if ((v7 & 0x80) != 0) {
      break;
    }
    if (!*((unsigned char *)v3 + 63)) {
      return *((unsigned int *)v3 + 8);
    }
    for (uint64_t i = v6; *(unsigned __int8 *)v9 == *i; ++i)
    {
      uint64_t v9 = (const void **)((char *)v9 + 1);
      if (!--v7) {
        return *((unsigned int *)v3 + 8);
      }
    }
LABEL_19:
    uint64_t v11 = (void *)v3[1];
    if (v11)
    {
      do
      {
        unint64_t v12 = v11;
        uint64_t v11 = (void *)*v11;
      }
      while (v11);
    }
    else
    {
      do
      {
        unint64_t v12 = (void *)v3[2];
        BOOL v13 = *v12 == (void)v3;
        uint64_t v3 = v12;
      }
      while (!v13);
    }
    uint64_t v3 = v12;
    if (v12 == v2) {
      return 0;
    }
  }
  if (memcmp(*v9, v6, v3[6])) {
    goto LABEL_19;
  }
  return *((unsigned int *)v3 + 8);
}

uint64_t sub_100CDB240(uint64_t result)
{
  if (*(unsigned char *)(result + 25))
  {
    if (!*(unsigned char *)(result + 240)) {
      *(unsigned char *)(result + 240) = 1;
    }
    int v1 = *(unsigned __int8 *)(result + 24);
    switch(v1)
    {
      case 11:
        uint64_t v2 = 3;
        goto LABEL_9;
      case 10:
        *(void *)(result + 232) = 2;
        *(unsigned char *)(result + 24) = 1;
        break;
      case 9:
        uint64_t v2 = 1;
LABEL_9:
        *(void *)(result + 232) = v2;
        *(_WORD *)(result + 24) = 257;
        return result;
      default:
        *(void *)(result + 232) = 0;
        break;
    }
  }
  return result;
}

uint64_t sub_100CDB2AC(uint64_t result)
{
  if (*(unsigned char *)(result + 240))
  {
    if (*(unsigned char *)(result + 25) && *(unsigned char *)(result + 24) == 1)
    {
      uint64_t v2 = *(void *)(result + 232);
      if ((v2 & 3) == 3)
      {
        __int16 v3 = 267;
      }
      else
      {
        if (v2) {
          __int16 v3 = 265;
        }
        else {
          __int16 v3 = 266;
        }
        if ((*(void *)(result + 232) & 3) == 0) {
          return result;
        }
      }
      *(_WORD *)(result + 24) = v3;
    }
  }
  return result;
}

uint64_t sub_100CDB2F8(int a1)
{
  if ((a1 - 1) > 0xA) {
    return 0;
  }
  else {
    return byte_101563280[(char)(a1 - 1)];
  }
}

void sub_100CDB320(os_log_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a2 + 8);
  }
  if (!v6)
  {
    *(unsigned char *)a5 = 0;
    *(unsigned char *)(a5 + 128) = 0;
    return;
  }
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)uint64_t v38 = 0u;
  *(_OWORD *)uint64_t v36 = 0u;
  memset(v37, 0, sizeof(v37));
  *(_OWORD *)uint64_t v34 = 0u;
  long long v35 = 0u;
  long long v49 = 0u;
  memset(v48, 0, sizeof(v48));
  sGetProfileDetails();
  uint64_t v12 = *a3;
  uint64_t v11 = a3[1];
  uint64_t v29 = a4;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a2;
    uint64_t v33 = *(void *)(a2 + 16);
  }
  char v13 = HIBYTE(v33);
  if (v12 != v11)
  {
    if (v33 >= 0) {
      unint64_t v14 = (void *)HIBYTE(v33);
    }
    else {
      unint64_t v14 = __dst[1];
    }
    if (v33 >= 0) {
      uint64_t v15 = __dst;
    }
    else {
      uint64_t v15 = (void **)__dst[0];
    }
    do
    {
      uint64_t v16 = *(unsigned __int8 *)(v12 + 95);
      if ((v16 & 0x80u) == 0) {
        int v17 = (void *)*(unsigned __int8 *)(v12 + 95);
      }
      else {
        int v17 = *(void **)(v12 + 80);
      }
      if (v17 == v14)
      {
        if ((v16 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v12 + 72), v15, *(void *)(v12 + 80))) {
            goto LABEL_43;
          }
        }
        else
        {
          if (!*(unsigned char *)(v12 + 95)) {
            goto LABEL_43;
          }
          uint64_t v18 = 0;
          while (*(unsigned __int8 *)(v12 + v18 + 72) == *((unsigned __int8 *)v15 + v18))
          {
            if (v16 == ++v18) {
              goto LABEL_43;
            }
          }
        }
      }
      v12 += 168;
    }
    while (v12 != v11);
    uint64_t v12 = v11;
  }
LABEL_43:
  if (v13 < 0) {
    operator delete(__dst[0]);
  }
  if (v12 == a3[1])
  {
    long long v25 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v27 = (void *)a2;
      }
      else {
        uint64_t v27 = *(void **)a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v27;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "carrier identifiers not found for iccid: %s", buf, 0xCu);
    }
    *(unsigned char *)a5 = 0;
    *(unsigned char *)(a5 + 128) = 0;
    goto LABEL_5;
  }
  long long v31 = 0u;
  memset(__str, 0, sizeof(__str));
  sub_100E63EA4((uint64_t)__str);
  std::string::operator=((std::string *)v36, (const std::string *)__str);
  std::string::operator=((std::string *)&v37[1], (const std::string *)&__str[24]);
  std::string::operator=((std::string *)v38, (const std::string *)(v12 + 120));
  std::string::operator=((std::string *)&__p[1], (const std::string *)(v12 + 144));
  int v19 = (void *)HIBYTE(v37[0]);
  if (SHIBYTE(v37[0]) < 0) {
    int v19 = v36[1];
  }
  if (!v19) {
    goto LABEL_52;
  }
  int v20 = (void *)HIBYTE(v37[3]);
  if (SHIBYTE(v37[3]) < 0) {
    int v20 = v37[2];
  }
  if (!v20)
  {
LABEL_52:
    int v21 = (void **)(v12 + 72);
    if (!sub_10010E194(*(void ***)(v29 + 8), v21))
    {
      uint64_t v26 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) >= 0) {
          long long v28 = (void *)a2;
        }
        else {
          long long v28 = *(void **)a2;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v28;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "carrier identifiers not found in cache for iccid: %s", buf, 0xCu);
      }
      char v24 = 0;
      *(unsigned char *)a5 = 0;
      goto LABEL_71;
    }
    *(_OWORD *)uint64_t v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    *(_OWORD *)char v45 = 0u;
    *(_OWORD *)size_t v42 = 0u;
    *(_OWORD *)long long v43 = 0u;
    *(_OWORD *)std::string buf = 0u;
    long long v41 = 0u;
    uint64_t v22 = sub_10005DDEC(v29, v21);
    sub_10030B264((uint64_t)buf, v22);
    std::string::operator=((std::string *)v36, (const std::string *)v42);
    std::string::operator=((std::string *)&v37[1], (const std::string *)&v43[1]);
    std::string::operator=((std::string *)v38, (const std::string *)v45);
    std::string::operator=((std::string *)&__p[1], (const std::string *)&v46[1]);
    if (SHIBYTE(v47) < 0) {
      operator delete(v46[1]);
    }
    if (SHIBYTE(v46[0]) < 0) {
      operator delete(v45[0]);
    }
    if (SHIBYTE(v44) < 0) {
      operator delete(v43[1]);
    }
    if (SHIBYTE(v43[0]) < 0) {
      operator delete(v42[0]);
    }
    if (BYTE8(v41) && SBYTE7(v41) < 0) {
      operator delete(*(void **)buf);
    }
  }
  *(unsigned char *)a5 = 0;
  *(unsigned char *)(a5 + 24) = 0;
  if (BYTE8(v35))
  {
    *(_OWORD *)a5 = *(_OWORD *)v34;
    *(void *)(a5 + 16) = v35;
    v34[1] = 0;
    *(void *)&long long v35 = 0;
    v34[0] = 0;
    *(unsigned char *)(a5 + 24) = 1;
  }
  *(_OWORD *)(a5 + 32) = *(_OWORD *)v36;
  *(void **)(a5 + 48) = v37[0];
  v36[1] = 0;
  v37[0] = 0;
  v36[0] = 0;
  *(_OWORD *)(a5 + 56) = *(_OWORD *)&v37[1];
  *(void **)(a5 + 72) = v37[3];
  memset(&v37[1], 0, 24);
  *(void **)(a5 + 96) = __p[0];
  *(_OWORD *)(a5 + 80) = *(_OWORD *)v38;
  v38[1] = 0;
  __p[0] = 0;
  v38[0] = 0;
  long long v23 = *(_OWORD *)&__p[1];
  *(void **)(a5 + 120) = __p[3];
  *(_OWORD *)(a5 + 104) = v23;
  memset(&__p[1], 0, 24);
  char v24 = 1;
LABEL_71:
  *(unsigned char *)(a5 + 128) = v24;
  if (SHIBYTE(v31) < 0) {
    operator delete(*(void **)&__str[24]);
  }
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
LABEL_5:
  if (BYTE8(v49)) {
    sub_1000C584C((uint64_t)v48);
  }
  if (SHIBYTE(__p[3]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v38[0]);
  }
  if (SHIBYTE(v37[3]) < 0) {
    operator delete(v37[1]);
  }
  if (SHIBYTE(v37[0]) < 0) {
    operator delete(v36[0]);
  }
  if (BYTE8(v35))
  {
    if (SBYTE7(v35) < 0) {
      operator delete(v34[0]);
    }
  }
}

void sub_100CDB930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (LOBYTE(STACK[0x238])) {
    sub_1000C584C((uint64_t)&a53);
  }
  sub_1002DE420((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void *sub_100CDB988@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *((unsigned __int8 *)result + 23);
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = result[1];
  }
  if (v2 == 21)
  {
    char v4 = v3 >= 0 ? result : (uint64_t *)*result;
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    uint64_t v7 = *(uint64_t *)((char *)v4 + 13);
    BOOL v8 = v5 == *(void *)"kDeleteProfileRequest" && v6 == *(void *)"rofileRequest";
    if (v8 && v7 == *(void *)"eRequest") {
      return sub_100058DB0(a2, "kDeleteProfileResponse");
    }
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

void sub_100CDB9F4(uint64_t *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  if (a1[1] == *a1) {
    goto LABEL_53;
  }
  uint64_t v7 = *((unsigned __int8 *)a2 + 23);
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = a2[1];
  }
  if (!v7)
  {
LABEL_53:
    *a3 = 0;
  }
  else
  {
    uint64_t v29 = a2;
    uint64_t v27 = v6;
    id cf = objc_opt_new();
    uint64_t v8 = *a1;
    uint64_t v28 = a1[1];
    if (*a1 != v28)
    {
      do
      {
        uint64_t v9 = (void *)(v8 + 264);
        if (*(char *)(v8 + 287) < 0)
        {
          if (*(void *)(v8 + 272))
          {
            uint64_t v9 = (void *)*v9;
LABEL_11:
            long long v31 = +[NSString stringWithUTF8String:v9];
            goto LABEL_13;
          }
        }
        else if (*(unsigned char *)(v8 + 287))
        {
          goto LABEL_11;
        }
        long long v31 = 0;
LABEL_13:
        id v10 = (void *)(v8 + 240);
        if (*(char *)(v8 + 263) < 0)
        {
          if (*(void *)(v8 + 248))
          {
            id v10 = (void *)*v10;
LABEL_18:
            uint64_t v11 = +[NSString stringWithUTF8String:v10];
            goto LABEL_20;
          }
        }
        else if (*(unsigned char *)(v8 + 263))
        {
          goto LABEL_18;
        }
        uint64_t v11 = 0;
LABEL_20:
        uint64_t v12 = (void *)(v8 + 24);
        if (*(char *)(v8 + 47) < 0)
        {
          if (*(void *)(v8 + 32))
          {
            uint64_t v12 = (void *)*v12;
LABEL_25:
            char v13 = +[NSString stringWithUTF8String:v12];
            goto LABEL_27;
          }
        }
        else if (*(unsigned char *)(v8 + 47))
        {
          goto LABEL_25;
        }
        char v13 = 0;
LABEL_27:
        unint64_t v14 = (void *)(v8 + 48);
        if (*(char *)(v8 + 71) < 0)
        {
          if (*(void *)(v8 + 56))
          {
            unint64_t v14 = (void *)*v14;
LABEL_32:
            uint64_t v15 = +[NSString stringWithUTF8String:v14];
            goto LABEL_34;
          }
        }
        else if (*(unsigned char *)(v8 + 71))
        {
          goto LABEL_32;
        }
        uint64_t v15 = 0;
LABEL_34:
        uint64_t v16 = (void *)(v8 + 72);
        if (*(char *)(v8 + 95) < 0)
        {
          if (*(void *)(v8 + 80))
          {
            uint64_t v16 = (void *)*v16;
LABEL_39:
            int v17 = +[NSString stringWithUTF8String:v16];
            goto LABEL_41;
          }
        }
        else if (*(unsigned char *)(v8 + 95))
        {
          goto LABEL_39;
        }
        int v17 = 0;
LABEL_41:
        uint64_t v18 = (void *)(v8 + 96);
        if (*(char *)(v8 + 119) < 0)
        {
          if (!*(void *)(v8 + 104))
          {
LABEL_47:
            int v19 = 0;
            goto LABEL_48;
          }
          uint64_t v18 = (void *)*v18;
        }
        else if (!*(unsigned char *)(v8 + 119))
        {
          goto LABEL_47;
        }
        int v19 = +[NSString stringWithUTF8String:v18];
LABEL_48:
        id v20 = objc_alloc_init((Class)CTRemotePlan);
        id v21 = [objc_alloc((Class)CTRemotePlanIdentifier) initWithIccid:&stru_101AC1B28 carrierName:v11 phoneNumber:v31 countryCode:&stru_101AC1B28 label:&stru_101AC1B28 mcc:v13 mnc:v15 gid1:v17 gid2:v19];
        [v20 setPlanID:v21];

        id v22 = objc_alloc((Class)CTPlanTransferAttributes);
        if (*((char *)v29 + 23) >= 0) {
          long long v23 = v29;
        }
        else {
          long long v23 = (uint64_t *)*v29;
        }
        char v24 = +[NSString stringWithUTF8String:v23];
        id v25 = [v22 initWithTransferCapability:8 transferStatus:0 isSecuredFlow:0 transferEndpoint:v24];
        [v20 setTransferAttributes:v25];

        id v26 = [objc_alloc((Class)CTDisplayPlan) initWithPlan:v20 status:1 attributes:4 isPhysical:0 carrierName:v11 phoneNumber:v31 label:0];
        [cf addObject:v26];

        v8 += 1248;
      }
      while (v8 != v28);
    }
    sub_100044D34(a3, cf);

    uint64_t v6 = v27;
  }
}

void sub_100CDBD44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100CDBDD4(os_log_t *a1, const void **a2, int a3)
{
  sub_100062740((const void **)&v7, a2);
  uint64_t v5 = sub_100CDBE3C(a1, &v7, a3);
  sub_100044D00((const void **)&v7);
  return v5;
}

void sub_100CDBE28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100CDBE3C(os_log_t *a1, void **a2, int a3)
{
  char v4 = *a2;
  if (*a2) {
    uint64_t v5 = sub_100083F10;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    id v7 = v4;
    uint64_t v29 = v7;
    if (v4)
    {
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      obuint64_t j = v7;
      id v8 = [obj countByEnumeratingWithState:&v34 objects:v41 count:16];
      if (v8)
      {
        uint64_t v27 = *(void *)v35;
        do
        {
          for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v35 != v27) {
              objc_enumerationMutation(obj);
            }
            id v10 = *(id *)(*((void *)&v34 + 1) + 8 * i);
            long long v30 = 0u;
            long long v31 = 0u;
            long long v32 = 0u;
            long long v33 = 0u;
            uint64_t v11 = [v10 remoteDisplayPlans];
            id v12 = [v11 countByEnumeratingWithState:&v30 objects:v40 count:16];
            if (v12)
            {
              uint64_t v13 = *(void *)v31;
              while (2)
              {
                for (uint64_t j = 0; j != v12; uint64_t j = (char *)j + 1)
                {
                  if (*(void *)v31 != v13) {
                    objc_enumerationMutation(v11);
                  }
                  id v15 = *(id *)(*((void *)&v30 + 1) + 8 * (void)j);
                  if (([v15 isPhysical] & a3 & 1) != 0
                    || (([v15 isPhysical] | a3) & 1) == 0)
                  {
                    long long v23 = *a1;
                    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                    {
                      char v24 = "eSIM";
                      if (a3) {
                        char v24 = "4FF";
                      }
                      *(_DWORD *)std::string buf = 136315138;
                      uint64_t v39 = v24;
                      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s present in transfer list", buf, 0xCu);
                    }

                    uint64_t v17 = 1;
                    goto LABEL_36;
                  }
                }
                id v12 = [v11 countByEnumeratingWithState:&v30 objects:v40 count:16];
                if (v12) {
                  continue;
                }
                break;
              }
            }
          }
          id v8 = [obj countByEnumeratingWithState:&v34 objects:v41 count:16];
        }
        while (v8);
      }

      uint64_t v16 = *a1;
      uint64_t v17 = 0;
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
      uint64_t v18 = "eSIM";
      if (a3) {
        uint64_t v18 = "4FF";
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v39 = v18;
      int v19 = "#I No %s present in transfer list";
      id v20 = v16;
      uint32_t v21 = 12;
    }
    else
    {
      id v25 = *a1;
      uint64_t v17 = 0;
      if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
LABEL_36:

        return v17;
      }
      *(_WORD *)std::string buf = 0;
      int v19 = "#I No devices in transfer list";
      id v20 = v25;
      uint32_t v21 = 2;
    }
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
    uint64_t v17 = 0;
    goto LABEL_36;
  }
  id v22 = *a1;
  uint64_t v17 = 0;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Transfer plan list nil", buf, 2u);
    return 0;
  }
  return v17;
}

void sub_100CDC1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_100CDC204(os_log_t *a1@<X0>, uint64_t **a2@<X1>, char **a3@<X8>)
{
  int v3 = a3;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  char v4 = *a2;
  uint64_t v46 = a2[1];
  if (*a2 != v46)
  {
    uint64_t v5 = a1;
    uint64_t v47 = (uint64_t)(a3 + 2);
    do
    {
      sub_10098FAB8(v4, (uint64_t)&v50);
      uint64_t v6 = v50;
      long long v49 = v4;
      if (v50 != v51)
      {
        do
        {
          id v7 = v6 + 4;
          uint64_t v75 = 0;
          long long v74 = 0u;
          long long v72 = 0u;
          memset(v73, 0, sizeof(v73));
          memset(v71, 0, sizeof(v71));
          long long v69 = 0u;
          long long v70 = 0u;
          long long v67 = 0u;
          long long v68 = 0u;
          long long v65 = 0u;
          long long v66 = 0u;
          long long v64 = 0u;
          if (sub_10098E79C((uint64_t)v4, (unsigned __int8 **)v6 + 4, (uint64_t)&v64))
          {
            if (SBYTE7(v66) < 0)
            {
              sub_10004FC84(buf, (void *)v65, *((unint64_t *)&v65 + 1));
            }
            else
            {
              *(_OWORD *)std::string buf = v65;
              uint64_t v53 = v66;
            }
            if (SHIBYTE(v71[0]) < 0)
            {
              sub_10004FC84(&v54, (void *)v70, *((unint64_t *)&v70 + 1));
            }
            else
            {
              long long v54 = v70;
              uint64_t v55 = v71[0];
            }
            if (SHIBYTE(v71[3]) < 0)
            {
              sub_10004FC84(&v56, (void *)v71[1], v71[2]);
            }
            else
            {
              long long v56 = *(_OWORD *)&v71[1];
              uint64_t v57 = v71[3];
            }
            if (SHIBYTE(v73[0]) < 0)
            {
              sub_10004FC84(&v58, (void *)v72, *((unint64_t *)&v72 + 1));
            }
            else
            {
              long long v58 = v72;
              uint64_t v59 = v73[0];
            }
            if (SHIBYTE(v73[3]) < 0)
            {
              sub_10004FC84(&v60, (void *)v73[1], v73[2]);
            }
            else
            {
              long long v60 = *(_OWORD *)&v73[1];
              uint64_t v61 = v73[3];
            }
            sub_10098F438((uint64_t)v4, (void **)&v65, &__p);
            unint64_t v9 = (unint64_t)v3[1];
            unint64_t v10 = (unint64_t)v3[2];
            if (v9 >= v10)
            {
              uint64_t v17 = v3;
              uint64_t v18 = *v3;
              unint64_t v19 = 0x8E38E38E38E38E39 * ((uint64_t)(v9 - (void)*v3) >> 4);
              unint64_t v20 = v19 + 1;
              if (v19 + 1 > 0x1C71C71C71C71C7) {
                sub_10006A748();
              }
              unint64_t v21 = 0x8E38E38E38E38E39 * ((uint64_t)(v10 - (void)v18) >> 4);
              if (2 * v21 > v20) {
                unint64_t v20 = 2 * v21;
              }
              if (v21 >= 0xE38E38E38E38E3) {
                unint64_t v22 = 0x1C71C71C71C71C7;
              }
              else {
                unint64_t v22 = v20;
              }
              if (v22) {
                long long v23 = (char *)sub_100344704(v47, v22);
              }
              else {
                long long v23 = 0;
              }
              char v24 = &v23[144 * v19];
              long long v25 = *(_OWORD *)buf;
              *((void *)v24 + 2) = v53;
              *(_OWORD *)char v24 = v25;
              uint64_t v53 = 0;
              memset(buf, 0, sizeof(buf));
              long long v26 = v54;
              *((void *)v24 + 5) = v55;
              *(_OWORD *)(v24 + 24) = v26;
              uint64_t v55 = 0;
              long long v54 = 0uLL;
              long long v27 = v56;
              *((void *)v24 + 8) = v57;
              *((_OWORD *)v24 + 3) = v27;
              uint64_t v57 = 0;
              long long v56 = 0uLL;
              long long v28 = v58;
              *((void *)v24 + 11) = v59;
              *(_OWORD *)(v24 + 72) = v28;
              long long v58 = 0uLL;
              uint64_t v59 = 0;
              long long v29 = v60;
              *((void *)v24 + 14) = v61;
              *((_OWORD *)v24 + 6) = v29;
              long long v60 = 0uLL;
              uint64_t v61 = 0;
              long long v30 = __p;
              *((void *)v24 + 17) = v63;
              *(_OWORD *)(v24 + 120) = v30;
              long long __p = 0uLL;
              uint64_t v63 = 0;
              long long v31 = *v17;
              long long v32 = v17[1];
              if (v32 == *v17)
              {
                long long v41 = v24 + 144;
                *uint64_t v17 = v24;
                v17[1] = v24 + 144;
                v17[2] = &v23[144 * v22];
              }
              else
              {
                long long v33 = &v23[144 * v19];
                do
                {
                  long long v34 = *((_OWORD *)v32 - 9);
                  *((void *)v33 - 16) = *((void *)v32 - 16);
                  *((_OWORD *)v33 - 9) = v34;
                  *((void *)v32 - 17) = 0;
                  *((void *)v32 - 16) = 0;
                  *((void *)v32 - 18) = 0;
                  long long v35 = *(_OWORD *)(v32 - 120);
                  *((void *)v33 - 13) = *((void *)v32 - 13);
                  *(_OWORD *)(v33 - 120) = v35;
                  *((void *)v32 - 14) = 0;
                  *((void *)v32 - 13) = 0;
                  *((void *)v32 - 15) = 0;
                  long long v36 = *((_OWORD *)v32 - 6);
                  *((void *)v33 - 10) = *((void *)v32 - 10);
                  *((_OWORD *)v33 - 6) = v36;
                  *((void *)v32 - 11) = 0;
                  *((void *)v32 - 10) = 0;
                  *((void *)v32 - 12) = 0;
                  long long v37 = *(_OWORD *)(v32 - 72);
                  *((void *)v33 - 7) = *((void *)v32 - 7);
                  *(_OWORD *)(v33 - 72) = v37;
                  *((void *)v32 - 9) = 0;
                  *((void *)v32 - 8) = 0;
                  *((void *)v32 - 7) = 0;
                  long long v38 = *((_OWORD *)v32 - 3);
                  *((void *)v33 - 4) = *((void *)v32 - 4);
                  *((_OWORD *)v33 - 3) = v38;
                  *((void *)v32 - 6) = 0;
                  *((void *)v32 - 5) = 0;
                  *((void *)v32 - 4) = 0;
                  long long v39 = *(_OWORD *)(v32 - 24);
                  *((void *)v33 - 1) = *((void *)v32 - 1);
                  *(_OWORD *)(v33 - 24) = v39;
                  v33 -= 144;
                  *((void *)v32 - 3) = 0;
                  *((void *)v32 - 2) = 0;
                  *((void *)v32 - 1) = 0;
                  v32 -= 144;
                }
                while (v32 != v31);
                long long v32 = *v17;
                uint64_t v40 = (uint64_t)v17[1];
                long long v41 = v24 + 144;
                *uint64_t v17 = v33;
                v17[1] = v24 + 144;
                v17[2] = &v23[144 * v22];
                while ((char *)v40 != v32)
                {
                  v40 -= 144;
                  sub_100688128(v40);
                }
              }
              if (v32) {
                operator delete(v32);
              }
              int v42 = SHIBYTE(v63);
              v17[1] = v41;
              int v3 = v17;
              uint64_t v5 = a1;
              if (v42 < 0) {
                operator delete((void *)__p);
              }
            }
            else
            {
              long long v11 = *(_OWORD *)buf;
              *(void *)(v9 + 16) = v53;
              *(_OWORD *)unint64_t v9 = v11;
              uint64_t v53 = 0;
              memset(buf, 0, sizeof(buf));
              uint64_t v12 = v55;
              *(_OWORD *)(v9 + 24) = v54;
              *(void *)(v9 + 40) = v12;
              uint64_t v55 = 0;
              long long v54 = 0uLL;
              long long v13 = v56;
              *(void *)(v9 + 64) = v57;
              *(_OWORD *)(v9 + 48) = v13;
              uint64_t v57 = 0;
              long long v56 = 0uLL;
              long long v14 = v58;
              *(void *)(v9 + 88) = v59;
              *(_OWORD *)(v9 + 72) = v14;
              long long v58 = 0uLL;
              uint64_t v59 = 0;
              long long v15 = v60;
              *(void *)(v9 + 112) = v61;
              *(_OWORD *)(v9 + 96) = v15;
              long long v60 = 0uLL;
              uint64_t v61 = 0;
              long long v16 = __p;
              *(void *)(v9 + 136) = v63;
              *(_OWORD *)(v9 + 120) = v16;
              long long __p = 0uLL;
              uint64_t v63 = 0;
              v3[1] = (char *)(v9 + 144);
            }
            if (SHIBYTE(v61) < 0) {
              operator delete((void *)v60);
            }
            if (SHIBYTE(v59) < 0) {
              operator delete((void *)v58);
            }
            if (SHIBYTE(v57) < 0) {
              operator delete((void *)v56);
            }
            if (SHIBYTE(v55) < 0) {
              operator delete((void *)v54);
            }
            if (SHIBYTE(v53) < 0) {
              operator delete(*(void **)buf);
            }
          }
          else
          {
            id v8 = *v5;
            if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
            {
              if (*((char *)v6 + 55) < 0) {
                id v7 = (void *)*v7;
              }
              *(_DWORD *)std::string buf = 136315138;
              *(void *)&uint8_t buf[4] = v7;
              _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No vinyl details available for iccid: [%s]", buf, 0xCu);
            }
          }
          sub_1000C584C((uint64_t)&v64);
          long long v43 = v6[1];
          char v4 = v49;
          if (v43)
          {
            do
            {
              long long v44 = (char **)v43;
              long long v43 = *(char **)v43;
            }
            while (v43);
          }
          else
          {
            do
            {
              long long v44 = (char **)v6[2];
              BOOL v45 = *v44 == (char *)v6;
              uint64_t v6 = v44;
            }
            while (!v45);
          }
          uint64_t v6 = v44;
        }
        while (v44 != v51);
      }
      sub_10005CD2C((uint64_t)&v50, v51[0]);
      v4 += 50;
    }
    while (v4 != v46);
  }
}

void sub_100CDC850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58)
{
}

uint64_t sub_100CDC91C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v119 = 0;
  long long v117 = 0u;
  long long v118 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  *(_OWORD *)long long v107 = 0u;
  long long v108 = 0u;
  memset(v106, 0, sizeof(v106));
  long long v105 = 0u;
  sub_10004BD84((uint64_t)&v105);
  char v4 = sub_10004B96C(v106, (uint64_t)"LPA:1", 5);
  LOBYTE(__p[0]) = 36;
  uint64_t v5 = sub_10004B96C(v4, (uint64_t)__p, 1);
  uint64_t v6 = sub_10004B96C(v5, (uint64_t)"TR", 2);
  LOBYTE(__p[0]) = 36;
  id v7 = sub_10004B96C(v6, (uint64_t)__p, 1);
  id v8 = sub_10004B96C(v7, (uint64_t)"iccid:", 6);
  int v9 = *(char *)(a1 + 455);
  if (v9 >= 0) {
    uint64_t v10 = a1 + 432;
  }
  else {
    uint64_t v10 = *(void *)(a1 + 432);
  }
  if (v9 >= 0) {
    uint64_t v11 = *(unsigned __int8 *)(a1 + 455);
  }
  else {
    uint64_t v11 = *(void *)(a1 + 440);
  }
  uint64_t v12 = sub_10004B96C(v8, v10, v11);
  LOBYTE(__p[0]) = 36;
  long long v13 = sub_10004B96C(v12, (uint64_t)__p, 1);
  long long v14 = sub_10004B96C(v13, (uint64_t)"mcc:", 4);
  int v15 = *(char *)(a1 + 47);
  if (v15 >= 0) {
    uint64_t v16 = a1 + 24;
  }
  else {
    uint64_t v16 = *(void *)(a1 + 24);
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v17 = *(void *)(a1 + 32);
  }
  uint64_t v18 = sub_10004B96C(v14, v16, v17);
  LOBYTE(__p[0]) = 36;
  unint64_t v19 = sub_10004B96C(v18, (uint64_t)__p, 1);
  unint64_t v20 = sub_10004B96C(v19, (uint64_t)"mnc:", 4);
  int v21 = *(char *)(a1 + 71);
  if (v21 >= 0) {
    uint64_t v22 = a1 + 48;
  }
  else {
    uint64_t v22 = *(void *)(a1 + 48);
  }
  if (v21 >= 0) {
    uint64_t v23 = *(unsigned __int8 *)(a1 + 71);
  }
  else {
    uint64_t v23 = *(void *)(a1 + 56);
  }
  char v24 = sub_10004B96C(v20, v22, v23);
  LOBYTE(__p[0]) = 36;
  long long v25 = sub_10004B96C(v24, (uint64_t)__p, 1);
  long long v26 = sub_10004B96C(v25, (uint64_t)"gid1:", 5);
  int v27 = *(char *)(a1 + 95);
  if (v27 >= 0) {
    uint64_t v28 = a1 + 72;
  }
  else {
    uint64_t v28 = *(void *)(a1 + 72);
  }
  if (v27 >= 0) {
    uint64_t v29 = *(unsigned __int8 *)(a1 + 95);
  }
  else {
    uint64_t v29 = *(void *)(a1 + 80);
  }
  long long v30 = sub_10004B96C(v26, v28, v29);
  LOBYTE(__p[0]) = 36;
  long long v31 = sub_10004B96C(v30, (uint64_t)__p, 1);
  long long v32 = sub_10004B96C(v31, (uint64_t)"gid2:", 5);
  int v33 = *(char *)(a1 + 119);
  if (v33 >= 0) {
    uint64_t v34 = a1 + 96;
  }
  else {
    uint64_t v34 = *(void *)(a1 + 96);
  }
  if (v33 >= 0) {
    uint64_t v35 = *(unsigned __int8 *)(a1 + 119);
  }
  else {
    uint64_t v35 = *(void *)(a1 + 104);
  }
  long long v36 = sub_10004B96C(v32, v34, v35);
  LOBYTE(__p[0]) = 36;
  long long v37 = sub_10004B96C(v36, (uint64_t)__p, 1);
  long long v38 = sub_10004B96C(v37, (uint64_t)"imsi:", 5);
  int v39 = *(char *)(a1 + 407);
  if (v39 >= 0) {
    uint64_t v40 = a1 + 384;
  }
  else {
    uint64_t v40 = *(void *)(a1 + 384);
  }
  if (v39 >= 0) {
    uint64_t v41 = *(unsigned __int8 *)(a1 + 407);
  }
  else {
    uint64_t v41 = *(void *)(a1 + 392);
  }
  int v42 = sub_10004B96C(v38, v40, v41);
  LOBYTE(__p[0]) = 36;
  long long v43 = sub_10004B96C(v42, (uint64_t)__p, 1);
  long long v44 = sub_10004B96C(v43, (uint64_t)"token:", 6);
  int v45 = *(char *)(a1 + 335);
  if (v45 >= 0) {
    uint64_t v46 = a1 + 312;
  }
  else {
    uint64_t v46 = *(void *)(a1 + 312);
  }
  if (v45 >= 0) {
    uint64_t v47 = *(unsigned __int8 *)(a1 + 335);
  }
  else {
    uint64_t v47 = *(void *)(a1 + 320);
  }
  long long v48 = sub_10004B96C(v44, v46, v47);
  LOBYTE(__p[0]) = 36;
  long long v49 = sub_10004B96C(v48, (uint64_t)__p, 1);
  sub_10004B96C(v49, (uint64_t)"active:", 7);
  int v50 = (void *)std::ostream::operator<<();
  LOBYTE(__p[0]) = 36;
  BOOL v51 = sub_10004B96C(v50, (uint64_t)__p, 1);
  uint64_t v52 = sub_10004B96C(v51, (uint64_t)"imei:", 5);
  int v53 = *(char *)(a1 + 215);
  if (v53 >= 0) {
    uint64_t v54 = a1 + 192;
  }
  else {
    uint64_t v54 = *(void *)(a1 + 192);
  }
  if (v53 >= 0) {
    uint64_t v55 = *(unsigned __int8 *)(a1 + 215);
  }
  else {
    uint64_t v55 = *(void *)(a1 + 200);
  }
  long long v56 = sub_10004B96C(v52, v54, v55);
  LOBYTE(__p[0]) = 36;
  uint64_t v57 = sub_10004B96C(v56, (uint64_t)__p, 1);
  long long v58 = sub_10004B96C(v57, (uint64_t)"eid:", 4);
  ctu::hex((uint64_t *)__p, (ctu *)(a1 + 914), (const void *)0x10, v59);
  if ((v104 & 0x80u) == 0) {
    long long v60 = __p;
  }
  else {
    long long v60 = (void **)__p[0];
  }
  if ((v104 & 0x80u) == 0) {
    uint64_t v61 = v104;
  }
  else {
    uint64_t v61 = (uint64_t)__p[1];
  }
  long long v62 = sub_10004B96C(v58, (uint64_t)v60, v61);
  char v120 = 36;
  uint64_t v63 = sub_10004B96C(v62, (uint64_t)&v120, 1);
  long long v64 = sub_10004B96C(v63, (uint64_t)"ver:", 4);
  long long v65 = sub_10004B96C(v64, (uint64_t)"0", 1);
  char v120 = 36;
  long long v66 = sub_10004B96C(v65, (uint64_t)&v120, 1);
  long long v67 = sub_10004B96C(v66, (uint64_t)"sn:", 3);
  long long v68 = sub_10004B96C(v67, (uint64_t)"-", 1);
  char v120 = 36;
  long long v69 = sub_10004B96C(v68, (uint64_t)&v120, 1);
  long long v70 = sub_10004B96C(v69, (uint64_t)"clz:", 4);
  int v71 = *(char *)(a1 + 959);
  if (v71 >= 0) {
    uint64_t v72 = a1 + 936;
  }
  else {
    uint64_t v72 = *(void *)(a1 + 936);
  }
  if (v71 >= 0) {
    uint64_t v73 = *(unsigned __int8 *)(a1 + 959);
  }
  else {
    uint64_t v73 = *(void *)(a1 + 944);
  }
  long long v74 = sub_10004B96C(v70, v72, v73);
  char v120 = 36;
  uint64_t v75 = sub_10004B96C(v74, (uint64_t)&v120, 1);
  int v76 = sub_10004B96C(v75, (uint64_t)"name:", 5);
  int v77 = *(char *)(a1 + 983);
  if (v77 >= 0) {
    uint64_t v78 = a1 + 960;
  }
  else {
    uint64_t v78 = *(void *)(a1 + 960);
  }
  if (v77 >= 0) {
    uint64_t v79 = *(unsigned __int8 *)(a1 + 983);
  }
  else {
    uint64_t v79 = *(void *)(a1 + 968);
  }
  long long v80 = sub_10004B96C(v76, v78, v79);
  char v120 = 36;
  uint64_t v81 = sub_10004B96C(v80, (uint64_t)&v120, 1);
  unint64_t v82 = sub_10004B96C(v81, (uint64_t)"ids:", 4);
  int v83 = sub_10004B96C(v82, (uint64_t)"-", 1);
  char v120 = 36;
  int v84 = sub_10004B96C(v83, (uint64_t)&v120, 1);
  unint64_t v85 = sub_10004B96C(v84, (uint64_t)"lbl.txt:", 8);
  int v86 = *(char *)(a1 + 167);
  if (v86 >= 0) {
    uint64_t v87 = a1 + 144;
  }
  else {
    uint64_t v87 = *(void *)(a1 + 144);
  }
  if (v86 >= 0) {
    uint64_t v88 = *(unsigned __int8 *)(a1 + 167);
  }
  else {
    uint64_t v88 = *(void *)(a1 + 152);
  }
  uint64_t v89 = sub_10004B96C(v85, v87, v88);
  char v120 = 36;
  uint64_t v90 = sub_10004B96C(v89, (uint64_t)&v120, 1);
  char v91 = sub_10004B96C(v90, (uint64_t)"lbl.tag:", 8);
  int v92 = *(char *)(a1 + 191);
  if (v92 >= 0) {
    uint64_t v93 = a1 + 168;
  }
  else {
    uint64_t v93 = *(void *)(a1 + 168);
  }
  if (v92 >= 0) {
    uint64_t v94 = *(unsigned __int8 *)(a1 + 191);
  }
  else {
    uint64_t v94 = *(void *)(a1 + 176);
  }
  long long v95 = sub_10004B96C(v91, v93, v94);
  char v120 = 36;
  long long v96 = sub_10004B96C(v95, (uint64_t)&v120, 1);
  long long v97 = sub_10004B96C(v96, (uint64_t)"mdn:", 4);
  int v98 = *(char *)(a1 + 287);
  if (v98 >= 0) {
    uint64_t v99 = a1 + 264;
  }
  else {
    uint64_t v99 = *(void *)(a1 + 264);
  }
  if (v98 >= 0) {
    uint64_t v100 = *(unsigned __int8 *)(a1 + 287);
  }
  else {
    uint64_t v100 = *(void *)(a1 + 272);
  }
  sub_10004B96C(v97, v99, v100);
  if ((char)v104 < 0) {
    operator delete(__p[0]);
  }
  sub_10004BC98((uint64_t)v106 + 8, a2);
  *(void *)((char *)&v106[-1]
  *(void *)&v106[0] = v101;
  if (SHIBYTE(v108) < 0) {
    operator delete(v107[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100CDCFB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_100CDCFE8(uint64_t result, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  if (result > 0xB)
  {
LABEL_12:
    if (result != 130) {
      return result;
    }
    goto LABEL_13;
  }
  if (((1 << result) & 0xE0A) != 0)
  {
    if (a4 >= a3) {
      char v5 = 6;
    }
    else {
      char v5 = -127;
    }
    BOOL v6 = (a2 & 1) == 0;
    goto LABEL_14;
  }
  if (result)
  {
    if (result == 6)
    {
      if (((a3 < a5) & a2) != 0) {
        LOBYTE(result) = -126;
      }
      else {
        LOBYTE(result) = 6;
      }
      return result;
    }
    goto LABEL_12;
  }
LABEL_13:
  BOOL v6 = a2 == 0;
  char v5 = 6;
LABEL_14:
  if (v6) {
    LOBYTE(result) = v5;
  }
  return result;
}

uint64_t sub_100CDD060(NSObject **a1, uint64_t a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v16 = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v16 = *(void *)(a3 + 16);
  }
  char v5 = sub_100046F68(a2, __p);
  if ((void **)(a2 + 8) == v5) {
    goto LABEL_18;
  }
  BOOL v6 = (char *)v5[12];
  if (v6)
  {
    id v7 = v5 + 12;
    do
    {
      int v8 = *((_DWORD *)v6 + 8);
      BOOL v9 = v8 < 13;
      if (v8 >= 13) {
        uint64_t v10 = (void **)v6;
      }
      else {
        uint64_t v10 = (void **)(v6 + 8);
      }
      if (!v9) {
        id v7 = (void **)v6;
      }
      BOOL v6 = (char *)*v10;
    }
    while (*v10);
    if (v7 != v5 + 12 && *((int *)v7 + 8) < 14)
    {
      *(_DWORD *)std::string buf = 13;
      unsigned int v11 = *((unsigned __int16 *)sub_1000FD774((uint64_t)(v5 + 11), (int *)buf) + 20);
      unsigned int v12 = v11 >> 8;
      goto LABEL_19;
    }
  }
  long long v13 = *a1;
  LOBYTE(v11) = 0;
  unsigned int v12 = 0;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v18 = "iphone-plan-transfer";
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Entitlement details do not contain %s", buf, 0xCu);
LABEL_18:
    LOBYTE(v11) = 0;
    unsigned int v12 = 0;
  }
LABEL_19:
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  return v11 | (v12 << 8);
}

void sub_100CDD1E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CDD208(long long **a1@<X0>, void *a2@<X8>)
{
  if (a1[1] == *a1)
  {
    *a2 = 0;
  }
  else
  {
    id cf = objc_opt_new();
    int v3 = *a1;
    char v4 = a1[1];
    if (*a1 != v4)
    {
      char v5 = CTEnhancedLinkQualityMetric_ptr;
      do
      {
        uint64_t v41 = 0;
        *(_OWORD *)long long __p = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        *(_OWORD *)uint64_t v35 = 0u;
        *(_OWORD *)long long v36 = 0u;
        *(_OWORD *)int v33 = 0u;
        long long v34 = 0u;
        long long v31 = 0u;
        *(_OWORD *)long long v32 = 0u;
        *(_OWORD *)std::string __dst = 0u;
        *(_OWORD *)long long v30 = 0u;
        sub_10010DB3C((char *)__dst, v3);
        BOOL v6 = (void *)HIBYTE(v30[0]);
        if (SHIBYTE(v30[0]) < 0) {
          BOOL v6 = __dst[1];
        }
        if (v6)
        {
          uint64_t v7 = HIBYTE(v31);
          if (v31 < 0) {
            uint64_t v7 = v31;
          }
          if (v7) {
            goto LABEL_13;
          }
          int v8 = (void *)HIBYTE(v33[0]);
          if (SHIBYTE(v33[0]) < 0) {
            int v8 = v32[1];
          }
          if (v8)
          {
LABEL_13:
            uint64_t v9 = HIBYTE(v34);
            if (v34 < 0) {
              uint64_t v9 = v34;
            }
            if (v9)
            {
              uint64_t v10 = (void *)HIBYTE(v36[0]);
              if (SHIBYTE(v36[0]) < 0) {
                uint64_t v10 = v35[1];
              }
              if (v10) {
                goto LABEL_22;
              }
              uint64_t v11 = HIBYTE(v37);
              if (v37 < 0) {
                uint64_t v11 = v37;
              }
              if (v11)
              {
LABEL_22:
                if (SHIBYTE(v30[0]) >= 0) {
                  unsigned int v12 = __dst;
                }
                else {
                  unsigned int v12 = (void **)__dst[0];
                }
                uint64_t v28 = [v5[254] stringWithUTF8String:v12];
                if (v31 >= 0) {
                  long long v13 = &v30[1];
                }
                else {
                  long long v13 = (void **)v30[1];
                }
                long long v14 = [v5[254] stringWithUTF8String:v13];
                if (SHIBYTE(v33[0]) >= 0) {
                  int v15 = v32;
                }
                else {
                  int v15 = (void **)v32[0];
                }
                uint64_t v16 = [v5[254] stringWithUTF8String:v15];
                if (v34 >= 0) {
                  uint64_t v17 = &v33[1];
                }
                else {
                  uint64_t v17 = (void **)v33[1];
                }
                uint64_t v18 = [v5[254] stringWithUTF8String:v17];
                if (SHIBYTE(v36[0]) >= 0) {
                  unint64_t v19 = v35;
                }
                else {
                  unint64_t v19 = (void **)v35[0];
                }
                unint64_t v20 = [v5[254] stringWithUTF8String:v19];
                int v21 = v5;
                if (v37 >= 0) {
                  uint64_t v22 = &v36[1];
                }
                else {
                  uint64_t v22 = (void **)v36[1];
                }
                uint64_t v23 = [v5[254] stringWithUTF8String:v22];
                id v24 = [objc_alloc((Class)CTRemoteBlacklistPlan) initWithkey:v28 blacklistIMEI:v14 blacklistEID:v16 blacklistICCID:v18 uploaderIMEI:v20 uploaderEID:v23];
                id v25 = [objc_alloc((Class)CTDisplayPlan) initWithPlan:v24 status:10 attributes:4 isPhysical:0 carrierName:0 phoneNumber:0 label:0];
                [cf addObject:v25];

                char v5 = v21;
              }
            }
          }
        }
        if ((_BYTE)v41 && SBYTE7(v40) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v37) < 0) {
          operator delete(v36[1]);
        }
        if (SHIBYTE(v36[0]) < 0) {
          operator delete(v35[0]);
        }
        if (SHIBYTE(v34) < 0) {
          operator delete(v33[1]);
        }
        if (SHIBYTE(v33[0]) < 0) {
          operator delete(v32[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(v30[1]);
        }
        if (SHIBYTE(v30[0]) < 0) {
          operator delete(__dst[0]);
        }
        int v3 = (long long *)((char *)v3 + 200);
      }
      while (v3 != v4);
    }
    sub_100044D34(a2, cf);
  }
}

void sub_100CDD568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, ...)
{
  va_start(va, a11);

  sub_10010DDFC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100CDD5F0(int a1)
{
  uint64_t result = 0;
  if (a1 > 127)
  {
    uint64_t v3 = 13;
    uint64_t v4 = 14;
    if (a1 != 130) {
      uint64_t v4 = 0;
    }
    if (a1 != 129) {
      uint64_t v3 = v4;
    }
    if (a1 == 128) {
      return 12;
    }
    else {
      return v3;
    }
  }
  else
  {
    switch(a1)
    {
      case 1:
      case 9:
      case 10:
      case 11:
        uint64_t result = 2;
        break;
      case 2:
        uint64_t result = 3;
        break;
      case 3:
        uint64_t result = 4;
        break;
      case 4:
        uint64_t result = 5;
        break;
      case 5:
        uint64_t result = 6;
        break;
      case 6:
        uint64_t result = 1;
        break;
      case 7:
        uint64_t result = 7;
        break;
      case 8:
        uint64_t result = 8;
        break;
      case 16:
        uint64_t result = 9;
        break;
      case 17:
        uint64_t result = 11;
        break;
      case 32:
        uint64_t result = 10;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t sub_100CDD72C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      sub_1006D303C(a3 + v6, a1 + v6);
      v6 += 80;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_100CDD78C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 80;
    do
    {
      sub_1000C53DC(v4 + v2);
      v2 -= 80;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100CDD7B0(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_100CDD7E4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A4EAA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100CDD804(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A4EAA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100CDD858(uint64_t a1)
{
}

void sub_100CDD864(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A4EAF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100CDD884(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A4EAF0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100CDD8D8(uint64_t a1)
{
}

uint64_t *sub_100CDD8E4(uint64_t a1, int *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)(a1 + 8);
  char v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        char v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      char v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v8 = (uint64_t **)(a1 + 8);
LABEL_10:
    memset(v11, 0, sizeof(v11));
    sub_100CDD9A4(a1, a3, a4, v11);
    sub_100046C38((uint64_t **)a1, (uint64_t)v8, v6, v11[0]);
    return v11[0];
  }
  return (uint64_t *)v8;
}

void *sub_100CDD9A4@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = a1 + 8;
  *a4 = 0;
  a4[2] = 0;
  a4[1] = 0;
  int v8 = a4 + 1;
  int v9 = operator new(0x40uLL);
  *a4 = v9;
  void *v8 = v7;
  *((unsigned char *)a4 + 16) = 0;
  v9[8] = *a2;
  uint64_t result = v9 + 10;
  if (*(char *)(a3 + 23) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)a3;
    result[2] = *(void *)(a3 + 16);
  }
  *((unsigned char *)a4 + 16) = 1;
  return result;
}

void sub_100CDDA40(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_10008CD08(v2, v3);
  _Unwind_Resume(a1);
}

void sub_100CDDA5C()
{
  sub_100058DB0(&qword_101B12AD8, "IneligibleAccountErrors");
  __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B12AD8, (void *)&_mh_execute_header);
  sub_100058DB0(&qword_101B12AF0, "SuccessfulTransferWithDelayedActivationErrors");
  __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B12AF0, (void *)&_mh_execute_header);
}

void *sub_100CDDB00(uint64_t a1)
{
  sub_10005CD2C(a1 + 32, *(char **)(a1 + 40));

  return sub_100CE3448((void *)a1);
}

void sub_100CDDB40(uint64_t a1)
{
  *(void *)a1 = off_101A4EB40;
  *(void *)(a1 + 56) = off_101A4EBB0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 768);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 752);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 736);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10005CD2C(a1 + 688, *(char **)(a1 + 696));
  if (*(void *)(a1 + 664))
  {
    sub_10019E028((uint64_t *)(a1 + 664));
    operator delete(*(void **)(a1 + 664));
  }
  sub_1001FEC70(*(void **)(a1 + 648));
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 472));
  char v5 = *(std::__shared_weak_count **)(a1 + 464);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 448);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_1000346F8(a1 + 416, *(void **)(a1 + 424));
  sub_1000346F8(a1 + 384, *(void **)(a1 + 392));
  sub_1000346F8(a1 + 360, *(void **)(a1 + 368));
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 336));
  sub_1000346F8(a1 + 312, *(void **)(a1 + 320));
  sub_10005CD2C(a1 + 288, *(char **)(a1 + 296));
  sub_1000346F8(a1 + 248, *(void **)(a1 + 256));
  sub_1000346F8(a1 + 224, *(void **)(a1 + 232));
  int v8 = (void **)(a1 + 200);
  sub_1001F1FAC(&v8);
  sub_1000346F8(a1 + 176, *(void **)(a1 + 184));
  sub_10005CD2C(a1 + 152, *(char **)(a1 + 160));
  sub_10097E974((void *)(a1 + 120));
  sub_10005CD2C(a1 + 96, *(char **)(a1 + 104));
  sub_100CE3448((void *)(a1 + 64));
  uint64_t v7 = *(NSObject **)(a1 + 48);
  if (v7) {
    dispatch_release(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  TransportMasterInterface::~TransportMasterInterface((TransportMasterInterface *)a1);
}

void sub_100CDDCEC(uint64_t a1)
{
}

void sub_100CDDCF4(uint64_t a1)
{
  sub_100CDDB40(a1);

  operator delete();
}

void sub_100CDDD2C(uint64_t a1)
{
  sub_100CDDB40(a1 - 56);

  operator delete();
}

void TransportMasterController::create(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if ((capabilities::ct::supportsGemini(a1) & 1) == 0)
  {
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  uint64_t v4 = (char *)operator new(0x328uLL);
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = 0;
  *(void *)uint64_t v4 = off_101A4ECE0;
  TransportMasterInterface::TransportMasterInterface((TransportMasterInterface *)(v4 + 24));
  uint64_t v16 = v5;
  *((void *)v4 + 3) = off_101A4EB40;
  *((void *)v4 + 10) = off_101A4EBB0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "tm.ctr");
  uint64_t v6 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_DEFAULT, 0);
  uint64_t v7 = dispatch_queue_create("TransportMasterController", v6);
  *((void *)v4 + 4) = 0;
  *((void *)v4 + 5) = 0;
  *((void *)v4 + 6) = v7;
  if (v7)
  {
    int v8 = v7;
    dispatch_retain(v7);
    *((void *)v4 + 7) = 0;
    dispatch_release(v8);
  }
  else
  {
    *((void *)v4 + 7) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v17, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v4 + 64), (const ctu::OsLogLogger *)v17);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v17);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  *((void *)v4 + 3) = off_101A4EB40;
  *((void *)v4 + 10) = off_101A4EBB0;
  int v9 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UNSPECIFIED, 0);
  dispatch_queue_t v10 = dispatch_queue_create_with_target_V2("TransportMasterController", v9, *((dispatch_queue_t *)v4 + 6));
  *((void *)v4 + 23) = 0;
  *((void *)v4 + 9) = v10;
  *((void *)v4 + 3) = off_101A4EB40;
  *((void *)v4 + 10) = off_101A4EBB0;
  *((void *)v4 + 17) = 0;
  *((void *)v4 + 16) = 0;
  *((void *)v4 + 14) = 0;
  *((void *)v4 + 15) = v4 + 128;
  *((void *)v4 + 24) = 0;
  *((void *)v4 + 21) = 0;
  *((void *)v4 + 22) = v4 + 184;
  sub_10035D650((uint64_t *)v4 + 25, (uint64_t)&rest::kDefaultRegistrationStatuses);
  *((void *)v4 + 31) = v4 + 256;
  *((void *)v4 + 28) = 0;
  *((void *)v4 + 29) = 0;
  *((void *)v4 + 30) = 0;
  *((void *)v4 + 32) = 0;
  *((void *)v4 + 35) = 0;
  *((void *)v4 + 36) = 0;
  *((void *)v4 + 33) = 0;
  *((void *)v4 + 34) = v4 + 280;
  v4[296] = 0;
  *(void *)(v4 + 300) = 0;
  v4[308] = 0;
  *((void *)v4 + 39) = v4 + 320;
  *((void *)v4 + 40) = 0;
  *((void *)v4 + 41) = 0;
  *((void *)v4 + 42) = v4 + 344;
  *((void *)v4 + 43) = 0;
  *((void *)v4 + 44) = 0;
  EmergencyMode::EmergencyMode((EmergencyMode *)(v4 + 360));
  sub_10005DF14((uint64_t *)v4 + 48, (uint64_t)&rest::kDefaultEffectiveDataRoamingSettings);
  sub_10005DF14((uint64_t *)v4 + 51, (uint64_t)&rest::kDefaultDataAttachedStates);
  v4[432] = 0;
  *((_DWORD *)v4 + 109) = 0;
  *((void *)v4 + 55) = v4 + 448;
  *((void *)v4 + 56) = 0;
  unsigned int v12 = *(Registry **)a1;
  uint64_t v11 = *((void *)a1 + 1);
  *((void *)v4 + 57) = 0;
  *((void *)v4 + 58) = v12;
  *((void *)v4 + 59) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "TransportMasterController");
  long long v13 = *((void *)v4 + 6);
  dispatch_object_t v20 = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  long long v14 = *((void *)v4 + 7);
  dispatch_object_t object = v14;
  if (v14) {
    dispatch_retain(v14);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    dispatch_release(v20);
  }
  if (v22 < 0) {
    operator delete(__p.var0);
  }
  sub_100058DB0(v17, "TransportMasterController");
  PersonalitiesTracker::PersonalitiesTracker();
  if (v18 < 0) {
    operator delete(v17[0]);
  }
  *((_OWORD *)v4 + 42) = 0u;
  *((void *)v4 + 83) = v4 + 672;
  *((void *)v4 + 86) = 0;
  *(_OWORD *)(v4 + 696) = 0u;
  *((void *)v4 + 89) = v4 + 720;
  *((_OWORD *)v4 + 45) = 0u;
  *((_OWORD *)v4 + 46) = 0u;
  *((_OWORD *)v4 + 47) = 0u;
  *((_OWORD *)v4 + 48) = 0u;
  *((_OWORD *)v4 + 49) = 0u;
  v4[800] = 0;
  int v15 = (std::__shared_weak_count *)*((void *)v4 + 5);
  if (!v15)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 2, 1uLL, memory_order_relaxed);
    *((void *)v4 + 4) = v16;
    *((void *)v4 + 5) = v4;
    goto LABEL_24;
  }
  if (v15->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 2, 1uLL, memory_order_relaxed);
    *((void *)v4 + 4) = v16;
    *((void *)v4 + 5) = v4;
    std::__shared_weak_count::__release_weak(v15);
LABEL_24:
    sub_10004D2C8((std::__shared_weak_count *)v4);
  }
  __p.var0 = 0;
  __p.var1.fRef = 0;
  Registry::getServiceManager((uint64_t *)&__p, *(Registry **)a1);
  if (__p.var0)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 1, 1uLL, memory_order_relaxed);
    operator new();
  }
  if (__p.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)__p.var1.fRef);
  }
  *a2 = v16;
  a2[1] = v4;
}

void sub_100CDE1CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, EmergencyMode *a10, uint64_t a11, ctu::OsLogLogger *a12, uint64_t a13, TransportMasterInterface *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,dispatch_object_t object,dispatch_object_t a22,void *a23,std::__shared_weak_count *a24,int a25,__int16 a26,char a27,char a28)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8))(__p);
  }
  if (a24) {
    sub_10004D2C8(a24);
  }
  sub_10004D2C8(v28);
  _Unwind_Resume(a1);
}

void sub_100CDE3B8()
{
}

void sub_100CDE3C0(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 && !*(unsigned char *)(*a3 + 49))
  {
    uint64_t v6 = a1 + 640;
    uint64_t v7 = sub_100046F68(a1 + 640, (void **)a2);
    int v8 = (void **)(a1 + 648);
    if ((void **)(a1 + 648) == v7)
    {
      int v14 = 0;
      uint64_t v79 = 0;
      dispatch_queue_t v10 = 0;
    }
    else
    {
      dispatch_queue_t v10 = v7[7];
      int v9 = (std::__shared_weak_count *)v7[8];
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v79 = v9;
      if (v10)
      {
        uint64_t v12 = *a3;
        uint64_t v11 = a3[1];
        if (v11) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
        }
        long long v13 = (std::__shared_weak_count *)*((void *)v10 + 8);
        *((void *)v10 + 7) = v12;
        *((void *)v10 + 8) = v11;
        if (v13) {
          sub_10004D2C8(v13);
        }
        int v14 = 1;
      }
      else
      {
        int v14 = 0;
      }
    }
    switch(*(unsigned char *)(a2 + 24))
    {
      case 0:
        if (v8 == sub_100046F68(v6, (void **)(*a3 + 24)))
        {
          uint64_t v28 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v29 = (void *)(*a3 + 24);
            if (*(char *)(*a3 + 47) < 0) {
              uint64_t v29 = (void *)*v29;
            }
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v29;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Creating manager for personality: %s", buf, 0xCu);
          }
          sub_100EE7740(&v80);
        }
        goto LABEL_116;
      case 1:
        if (v14)
        {
          if ((*(unsigned int (**)(void))(**((void **)v10 + 10) + 16))(*((void *)v10 + 10)) == 1)
          {
            sub_10055AF5C(" enabled", (const void **)a2, buf);
            sub_100CE0E84(a1, (uint64_t *)buf);
            if (SBYTE7(v84) < 0)
            {
              long long v30 = *(uint64_t **)buf;
              goto LABEL_115;
            }
          }
        }
        goto LABEL_116;
      case 4:
        if (v14) {
          (*(void (**)(void))(**((void **)v10 + 10) + 64))(*((void *)v10 + 10));
        }
        goto LABEL_116;
      case 5:
        if (v14) {
          sub_10025B63C((uint64_t)v10 + 128, 1);
        }
        goto LABEL_116;
      case 6:
      case 7:
        if (v8 == sub_100046F68(v6, (void **)a2)) {
          goto LABEL_116;
        }
        int v15 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 23) >= 0) {
            uint64_t v16 = (void *)a2;
          }
          else {
            uint64_t v16 = *(void **)a2;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Removing manager for personality: %s", buf, 0xCu);
        }
        uint64_t v78 = (uint64_t **)v6;
        *(void *)std::string buf = 1;
        *(void *)&uint8_t buf[8] = a1 + 64;
        *((void *)&v84 + 1) = 0;
        uint64_t v85 = 0;
        *(void *)&long long v84 = (char *)&v84 + 8;
        uint64_t v17 = *(void ***)(a1 + 96);
        if (v17 != (void **)(a1 + 104))
        {
          char v18 = 0;
          unint64_t v19 = (long long *)((char *)&v84 + 8);
          while (1)
          {
            unint64_t v82 = 0;
            if (v19 == (long long *)((char *)&v84 + 8))
            {
              int v21 = (void *)&v84 + 1;
              if (v18) {
                goto LABEL_31;
              }
            }
            else
            {
              dispatch_object_t v20 = (char *)&v84 + 8;
              if (v18)
              {
                do
                {
                  int v21 = v18;
                  char v18 = (char *)*((void *)v18 + 1);
                }
                while (v18);
              }
              else
              {
                do
                {
                  int v21 = (void *)*((void *)v20 + 2);
                  BOOL v22 = *v21 == (void)v20;
                  dispatch_object_t v20 = (char *)v21;
                }
                while (v22);
              }
              if ((sub_100046FE8(v21 + 4, v17 + 4) & 0x80) == 0)
              {
                uint64_t v23 = (uint64_t **)sub_100046ED4((uint64_t)&v84, &v82, v17 + 4);
                goto LABEL_32;
              }
              if (*((void *)&v84 + 1))
              {
LABEL_31:
                unint64_t v82 = (char *)v21;
                uint64_t v23 = (uint64_t **)(v21 + 1);
LABEL_32:
                if (*v23) {
                  goto LABEL_39;
                }
                goto LABEL_36;
              }
            }
            unint64_t v82 = (char *)&v84 + 8;
            uint64_t v23 = (uint64_t **)&v84 + 1;
LABEL_36:
            long long v80 = 0uLL;
            uint64_t v81 = 0;
            sub_100CE7084(&v80, (uint64_t)&v84, (uint64_t)(v17 + 4));
            id v24 = v82;
            id v25 = (uint64_t *)v80;
            *(void *)long long v80 = 0;
            v25[1] = 0;
            std::string v25[2] = (uint64_t)v24;
            *uint64_t v23 = v25;
            if (*(void *)v84)
            {
              *(void *)&long long v84 = *(void *)v84;
              id v25 = *v23;
            }
            sub_100046C90(*((uint64_t **)&v84 + 1), v25);
            ++v85;
LABEL_39:
            long long v26 = (void **)v17[1];
            if (v26)
            {
              do
              {
                int v27 = v26;
                long long v26 = (void **)*v26;
              }
              while (v26);
            }
            else
            {
              do
              {
                int v27 = (void **)v17[2];
                BOOL v22 = *v27 == v17;
                uint64_t v17 = v27;
              }
              while (!v22);
            }
            char v18 = (char *)*((void *)&v84 + 1);
            if (v27 == (void **)(a1 + 104))
            {
              if (*((void *)&v84 + 1))
              {
                long long v31 = (uint64_t *)&v84 + 1;
                do
                {
                  long long v32 = v31;
                  int v33 = (void **)(v18 + 32);
                  int v34 = (char)sub_100046FE8((void *)v18 + 4, (void **)a2);
                  uint64_t v35 = (uint64_t **)(v18 + 8);
                  if (v34 >= 0) {
                    long long v36 = (char **)v18;
                  }
                  else {
                    long long v36 = (char **)(v18 + 8);
                  }
                  if (v34 >= 0) {
                    long long v31 = (uint64_t *)v18;
                  }
                  char v18 = *v36;
                }
                while (*v36);
                if (v31 != (uint64_t *)((char *)&v84 + 8))
                {
                  if (v34 < 0) {
                    int v33 = (void **)(v32 + 4);
                  }
                  if ((sub_100046FE8((void *)a2, v33) & 0x80) == 0)
                  {
                    long long v37 = (uint64_t **)(v32 + 1);
                    if (v34 >= 0) {
                      long long v37 = v35;
                    }
                    long long v38 = *v37;
                    if (*v37)
                    {
                      do
                      {
                        int v39 = v38;
                        long long v38 = (uint64_t *)*v38;
                      }
                      while (v38);
                    }
                    else
                    {
                      long long v40 = v31;
                      do
                      {
                        int v39 = (uint64_t *)v40[2];
                        BOOL v22 = *v39 == (void)v40;
                        long long v40 = v39;
                      }
                      while (!v22);
                    }
                    if ((uint64_t *)v84 == v31) {
                      *(void *)&long long v84 = v39;
                    }
                    --v85;
                    sub_10005EE6C(*((uint64_t **)&v84 + 1), v31);
                    if (*((char *)v31 + 55) < 0) {
                      operator delete(*v33);
                    }
                    operator delete(v31);
                  }
                }
              }
              break;
            }
            unint64_t v19 = (_OWORD *)v84;
            uint64_t v17 = v27;
          }
        }
        if (!buf[0]) {
          goto LABEL_105;
        }
        uint64_t v41 = *(uint64_t **)&buf[8];
        if (*(void *)(*(void *)&buf[8] + 48) != v85) {
          goto LABEL_104;
        }
        int v42 = *(unsigned __int8 **)(*(void *)&buf[8] + 32);
        uint64_t v43 = *(void *)&buf[8] + 40;
        if (v42 != (unsigned __int8 *)(*(void *)&buf[8] + 40))
        {
          long long v44 = (unsigned __int8 *)v84;
          while (sub_10001D294(v42 + 32, v44 + 32)
               && v42[56] == v44[56]
               && *((_DWORD *)v42 + 15) == *((_DWORD *)v44 + 15))
          {
            int v45 = (unsigned __int8 *)*((void *)v42 + 1);
            uint64_t v46 = v42;
            if (v45)
            {
              do
              {
                int v42 = v45;
                int v45 = *(unsigned __int8 **)v45;
              }
              while (v45);
            }
            else
            {
              do
              {
                int v42 = (unsigned __int8 *)*((void *)v46 + 2);
                BOOL v22 = *(void *)v42 == (void)v46;
                uint64_t v46 = v42;
              }
              while (!v22);
            }
            uint64_t v47 = (unsigned __int8 *)*((void *)v44 + 1);
            if (v47)
            {
              do
              {
                long long v48 = v47;
                uint64_t v47 = *(unsigned __int8 **)v47;
              }
              while (v47);
            }
            else
            {
              do
              {
                long long v48 = (unsigned __int8 *)*((void *)v44 + 2);
                BOOL v22 = *(void *)v48 == (void)v44;
                long long v44 = v48;
              }
              while (!v22);
            }
            long long v44 = v48;
            if (v42 == (unsigned __int8 *)v43) {
              goto LABEL_105;
            }
          }
LABEL_104:
          sub_100CE0CDC(v41, &v84);
        }
LABEL_105:
        sub_10005CD2C((uint64_t)&v84, *((char **)&v84 + 1));
        *(void *)std::string buf = 1;
        long long v84 = 0u;
        uint64_t v85 = 0;
        *(void *)&uint8_t buf[8] = a1 + 120;
        long long v49 = (uint64_t **)sub_100CE7138((uint64_t)&v84, (void *)(a1 + 152));
        int v8 = (void **)(a1 + 648);
        sub_1000E9358(v49, (void **)a2);
        sub_100CE7358((uint64_t)buf);
        int v50 = (uint64_t *)sub_100046F68((uint64_t)v78, (void **)a2);
        if ((uint64_t *)(a1 + 648) != v50)
        {
          BOOL v51 = v50;
          uint64_t v52 = (uint64_t *)v50[1];
          if (v52)
          {
            do
            {
              int v53 = v52;
              uint64_t v52 = (uint64_t *)*v52;
            }
            while (v52);
          }
          else
          {
            uint64_t v54 = v50;
            do
            {
              int v53 = (uint64_t *)v54[2];
              BOOL v22 = *v53 == (void)v54;
              uint64_t v54 = v53;
            }
            while (!v22);
          }
          if (*v78 == v50) {
            *uint64_t v78 = v53;
          }
          --*(void *)(a1 + 656);
          sub_10005EE6C(*(uint64_t **)(a1 + 648), v50);
          sub_1001FEC1C((uint64_t)(v51 + 4));
          long long v30 = v51;
LABEL_115:
          operator delete(v30);
        }
LABEL_116:
        uint64_t v55 = (void **)(a1 + 664);
        sub_10019E028((uint64_t *)(a1 + 664));
        long long v56 = *(void ***)(a1 + 640);
        if (v56 != v8)
        {
          do
          {
            uint64_t v57 = v56[7];
            uint64_t v59 = *((void *)v57 + 7);
            long long v58 = (std::__shared_weak_count *)*((void *)v57 + 8);
            if (v58)
            {
              atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
              int v60 = *(unsigned __int8 *)(v59 + 48);
              sub_10004D2C8(v58);
              if (v60)
              {
                uint64_t v57 = v56[7];
LABEL_121:
                uint64_t v61 = (atomic_ullong *)v56[8];
                long long v62 = *(char **)(a1 + 672);
                unint64_t v63 = *(void *)(a1 + 680);
                if ((unint64_t)v62 >= v63)
                {
                  long long v65 = (char *)*v55;
                  uint64_t v66 = (v62 - (unsigned char *)*v55) >> 4;
                  unint64_t v67 = v66 + 1;
                  if ((unint64_t)(v66 + 1) >> 60) {
                    sub_10006A748();
                  }
                  uint64_t v68 = v63 - (void)v65;
                  if (v68 >> 3 > v67) {
                    unint64_t v67 = v68 >> 3;
                  }
                  if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v69 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v69 = v67;
                  }
                  if (v69 >> 60) {
                    sub_10006A7CC();
                  }
                  long long v70 = (char *)operator new(16 * v69);
                  int v71 = &v70[16 * v66];
                  *(void *)int v71 = v57;
                  *((void *)v71 + 1) = v61;
                  if (v61)
                  {
                    atomic_fetch_add_explicit(v61 + 1, 1uLL, memory_order_relaxed);
                    long long v62 = *(char **)(a1 + 672);
                    long long v65 = *(char **)(a1 + 664);
                  }
                  int v8 = (void **)(a1 + 648);
                  uint64_t v72 = &v70[16 * v69];
                  long long v64 = v71 + 16;
                  if (v62 == v65)
                  {
                    *(void *)(a1 + 664) = v71;
                    *(void *)(a1 + 672) = v64;
                    *(void *)(a1 + 680) = v72;
                  }
                  else
                  {
                    do
                    {
                      long long v73 = *((_OWORD *)v62 - 1);
                      v62 -= 16;
                      *((_OWORD *)v71 - 1) = v73;
                      v71 -= 16;
                      *(void *)long long v62 = 0;
                      *((void *)v62 + 1) = 0;
                    }
                    while (v62 != v65);
                    long long v65 = *(char **)(a1 + 664);
                    long long v74 = *(char **)(a1 + 672);
                    *(void *)(a1 + 664) = v71;
                    *(void *)(a1 + 672) = v64;
                    *(void *)(a1 + 680) = v72;
                    while (v74 != v65)
                    {
                      uint64_t v75 = (std::__shared_weak_count *)*((void *)v74 - 1);
                      if (v75) {
                        sub_10004D2C8(v75);
                      }
                      v74 -= 16;
                    }
                  }
                  if (v65) {
                    operator delete(v65);
                  }
                }
                else
                {
                  *(void *)long long v62 = v57;
                  *((void *)v62 + 1) = v61;
                  if (v61) {
                    atomic_fetch_add_explicit(v61 + 1, 1uLL, memory_order_relaxed);
                  }
                  long long v64 = v62 + 16;
                }
                *(void *)(a1 + 672) = v64;
              }
            }
            else if (*(unsigned char *)(v59 + 48))
            {
              goto LABEL_121;
            }
            int v76 = (void **)v56[1];
            if (v76)
            {
              do
              {
                int v77 = v76;
                int v76 = (void **)*v76;
              }
              while (v76);
            }
            else
            {
              do
              {
                int v77 = (void **)v56[2];
                BOOL v22 = *v77 == v56;
                long long v56 = v77;
              }
              while (!v22);
            }
            long long v56 = v77;
          }
          while (v77 != v8);
        }
        sub_100CE1030(a1);
        sub_100CE1A68(a1);
        if (v79) {
          sub_10004D2C8(v79);
        }
        break;
      default:
        goto LABEL_116;
    }
  }
}

void sub_100CDF148(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23)
{
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CDF224(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 176);
  uint64_t v2 = (void *)(a1 + 184);
  if (v1 != (void *)(a1 + 184))
  {
    do
    {
      TransportMasterController::getManager_sync(a1, *((_DWORD *)v1 + 7), &v7);
      if (v7) {
        (*(void (**)(void, void))(**(void **)(v7 + 80) + 40))(*(void *)(v7 + 80), *((unsigned int *)v1 + 8));
      }
      if (v8) {
        sub_10004D2C8(v8);
      }
      uint64_t v4 = (void *)v1[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v1[2];
          BOOL v6 = *v5 == (void)v1;
          uint64_t v1 = v5;
        }
        while (!v6);
      }
      uint64_t v1 = v5;
    }
    while (v5 != v2);
  }
}

void sub_100CDF2EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CDF304(uint64_t a1)
{
  uint64_t v1 = a1;
  v63[0] = 0;
  v63[1] = 0;
  long long v62 = (uint64_t *)v63;
  uint64_t v2 = *(void **)(a1 + 640);
  uint64_t v3 = (void *)(a1 + 648);
  if (v2 == (void *)(a1 + 648))
  {
    char v4 = 0;
  }
  else
  {
    char v4 = 0;
    do
    {
      uint64_t v5 = sub_100CE324C(&v62, v2[7], (uint64_t *)v2[8]);
      *(_WORD *)uint64_t v5 = 0;
      *((unsigned char *)v5 + 2) = 0;
      if (v4) {
        char v4 = 1;
      }
      else {
        char v4 = (*(uint64_t (**)(void))(**(void **)(v2[7] + 96) + 48))(*(void *)(v2[7] + 96));
      }
      BOOL v6 = (void *)v2[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          BOOL v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v2[2];
          BOOL v21 = *v7 == (void)v2;
          uint64_t v2 = v7;
        }
        while (!v21);
      }
      uint64_t v2 = v7;
    }
    while (v7 != v3);
  }
  int v8 = *(char **)(v1 + 200);
  int v9 = *(char **)(v1 + 208);
  if (v8 == v9)
  {
    char v10 = 0;
    if ((v4 & 1) == 0) {
      goto LABEL_91;
    }
LABEL_63:
    if ((*(unsigned char *)(v1 + 776) == 0) | v10 & 1) {
      goto LABEL_91;
    }
    TransportMasterController::getManager_sync(v1, *(_DWORD *)(v1 + 280), &v60);
    if (!v60 || (*(unsigned int (**)(void))(**(void **)(v60 + 80) + 32))(*(void *)(v60 + 80)) == 2) {
      goto LABEL_89;
    }
    sub_100058DB0(__p, "CS call during which Internet was not possible ended");
    Registry::getTimerService((uint64_t *)buf, *(Registry **)(v1 + 440));
    uint64_t v37 = (***(uint64_t (****)(void))buf)(*(void *)buf);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    long long v38 = (AutoStartTimer **)(v1 + 760);
    int v39 = *(AutoStartTimer **)(v1 + 760);
    if (v39)
    {
      if (v37 < AutoStartTimer::getExpiryTime(v39) && AutoStartTimer::getExpiryTime(*v38) - v37 >= 15000000000)
      {
        uint64_t v52 = *(NSObject **)(v1 + 40);
        if (!os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
LABEL_87:
          if (v59 < 0) {
            operator delete(__p[0]);
          }
LABEL_89:
          if (v61) {
            sub_10004D2C8(v61);
          }
          goto LABEL_91;
        }
        int v53 = __p;
        if (v59 < 0) {
          int v53 = (xpc_object_t *)__p[0];
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v53;
        uint64_t v46 = "#I Already disallowed for the requested duration. No need to do anything for: %s";
        uint64_t v47 = v52;
        uint32_t v48 = 12;
LABEL_86:
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, v46, buf, v48);
        goto LABEL_87;
      }
      long long v40 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Stop existing timer and start a new one.", buf, 2u);
      }
      uint64_t v41 = *(std::__shared_weak_count **)(v1 + 768);
      uint64_t *v38 = 0;
      *(void *)(v1 + 768) = 0;
      if (v41) {
        sub_10004D2C8(v41);
      }
    }
    sub_100058DB0(object, "DisallowFeaturesTimer");
    Registry::getTimerService(&v64, *(Registry **)(v1 + 440));
    *(void *)std::string buf = off_101A4F940;
    *(void *)&uint8_t buf[8] = v1;
    long long v70 = buf;
    AutoStartTimer::create();
    long long v42 = v68;
    long long v68 = 0uLL;
    uint64_t v43 = *(std::__shared_weak_count **)(v1 + 768);
    *(_OWORD *)long long v38 = v42;
    if (v43)
    {
      sub_10004D2C8(v43);
      if (*((void *)&v68 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v68 + 1));
      }
    }
    sub_10003B34C(buf);
    if (v65) {
      sub_10004D2C8(v65);
    }
    if (SHIBYTE(v67) < 0) {
      operator delete(object[0]);
    }
    long long v44 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_87;
    }
    int v45 = __p;
    if (v59 < 0) {
      int v45 = (xpc_object_t *)__p[0];
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v45;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = 15000;
    uint64_t v46 = "#I Data switching disallowed; Reason: %s; for next: %lld seconds";
    uint64_t v47 = v44;
    uint32_t v48 = 22;
    goto LABEL_86;
  }
  char v10 = 0;
  uint64_t v11 = *(char **)(v1 + 200);
  uint64_t v57 = *(char **)(v1 + 208);
  uint64_t v54 = v1;
  do
  {
    *(void *)std::string buf = v8;
    *(void *)&uint8_t buf[8] = "kCallStatus";
    sub_100048BAC((uint64_t)buf, object);
    unsigned int v13 = xpc::dyn_cast_or_default((xpc *)object, (const object *)9, v12);
    xpc_release(object[0]);
    object[0] = 0;
    object[1] = 0;
    uint64_t v67 = 0;
    __p[0] = v8;
    __p[1] = "kUuid";
    sub_100048BAC((uint64_t)__p, &v68);
    memset(buf, 0, sizeof(buf));
    xpc::dyn_cast_or_default();
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    xpc_release((xpc_object_t)v68);
    if (v13 <= 9 && ((1 << v13) & 0x24C) != 0)
    {
      int v14 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = SHIBYTE(v67);
        uint64_t v16 = (xpc_object_t *)object[0];
        uint64_t v17 = asString();
        *(_DWORD *)std::string buf = 136315394;
        char v18 = object;
        if (v15 < 0) {
          char v18 = v16;
        }
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v17;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Call: %s is not active; status: %s",
          buf,
          0x16u);
        int v9 = v57;
      }
    }
    else
    {
      *(void *)std::string buf = v8;
      *(void *)&uint8_t buf[8] = "kCallSubType";
      sub_100048BAC((uint64_t)buf, __p);
      char v20 = xpc::dyn_cast_or_default((xpc *)__p, (const object *)1, v19);
      xpc_release(__p[0]);
      BOOL v21 = v20 == 4 || v20 == 8;
      char v22 = v21;
      char v56 = v22;
      BOOL v23 = v21 || v20 == 1;
      *(void *)std::string buf = v8;
      *(void *)&uint8_t buf[8] = "kCallSimSlot";
      sub_100048BAC((uint64_t)buf, __p);
      int v25 = xpc::dyn_cast_or_default((xpc *)__p, 0, v24);
      xpc_release(__p[0]);
      log = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
      {
        if (v67 >= 0) {
          long long v26 = object;
        }
        else {
          long long v26 = (xpc_object_t *)object[0];
        }
        uint64_t v27 = subscriber::asString();
        uint64_t v28 = asString();
        uint64_t v29 = asString();
        *(_DWORD *)std::string buf = 136315906;
        *(void *)&uint8_t buf[4] = v26;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v27;
        *(_WORD *)&unsigned char buf[22] = 2080;
        long long v70 = (uint8_t *)v28;
        __int16 v71 = 2080;
        uint64_t v72 = v29;
        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I Call: %s is active on SimSlot: %s; status: %s, type: %s",
          buf,
          0x2Au);
        uint64_t v1 = v54;
        int v9 = v57;
      }
      TransportMasterController::getManager_sync(v1, v25, buf);
      long long v30 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)buf)
      {
        long long v31 = sub_100CE324C(&v62, *(unint64_t *)buf, *(uint64_t **)&buf[8]);
        if (*(unsigned char *)v31) {
          BOOL v32 = 1;
        }
        else {
          BOOL v32 = v20 == 1;
        }
        char v33 = v32;
        *(unsigned char *)long long v31 = v33;
        char v34 = v56;
        if (*((unsigned char *)v31 + 1)) {
          char v34 = 1;
        }
        *((unsigned char *)v31 + 1) = v34;
        if (*((unsigned char *)v31 + 2)) {
          BOOL v35 = 1;
        }
        else {
          BOOL v35 = v20 == 2;
        }
        char v36 = v35;
        *((unsigned char *)v31 + 2) = v36;
      }
      if (v30) {
        sub_10004D2C8(v30);
      }
      v10 |= v23;
    }
    if (SHIBYTE(v67) < 0) {
      operator delete(object[0]);
    }
    v11 += 8;
    v8 += 8;
  }
  while (v11 != v9);
  if (v4) {
    goto LABEL_63;
  }
LABEL_91:
  *(unsigned char *)(v1 + 776) = v10 & 1;
  long long v49 = v62;
  if (v62 != (uint64_t *)v63)
  {
    do
    {
      sub_100EE7B80(v49[4], *((unsigned __int8 *)v49 + 48), *((unsigned __int8 *)v49 + 49), *((unsigned __int8 *)v49 + 50), v10 & 1);
      int v50 = (uint64_t *)v49[1];
      if (v50)
      {
        do
        {
          BOOL v51 = v50;
          int v50 = (uint64_t *)*v50;
        }
        while (v50);
      }
      else
      {
        do
        {
          BOOL v51 = (uint64_t *)v49[2];
          BOOL v21 = *v51 == (void)v49;
          long long v49 = v51;
        }
        while (!v21);
      }
      long long v49 = v51;
    }
    while (v51 != (uint64_t *)v63);
  }
  sub_10011276C(v63[0]);
}

void sub_100CDFA70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t object,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,std::__shared_weak_count *a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_10003B34C((void *)(v38 - 160));
  if (a32) {
    sub_10004D2C8(a32);
  }
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(object);
  }
  if (a27) {
    sub_10004D2C8(a27);
  }
  sub_10011276C(a29);
  _Unwind_Resume(a1);
}

void sub_100CDFBC0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 224);
  uint64_t v2 = (void *)(a1 + 232);
  if (v1 != (void *)(a1 + 232))
  {
    do
    {
      TransportMasterController::getManager_sync(a1, *((_DWORD *)v1 + 7), &v9);
      if (v9)
      {
        (*(void (**)(void, BOOL))(**(void **)(v9 + 96) + 56))(*(void *)(v9 + 96), *((_DWORD *)v1 + 8) == 0);
      }
      else
      {
        char v4 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v5 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v12 = v5;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N No manager for SIM %s", buf, 0xCu);
        }
      }
      if (v10) {
        sub_10004D2C8(v10);
      }
      BOOL v6 = (void *)v1[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          BOOL v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v1[2];
          BOOL v8 = *v7 == (void)v1;
          uint64_t v1 = v7;
        }
        while (!v8);
      }
      uint64_t v1 = v7;
    }
    while (v7 != v2);
  }
}

void sub_100CDFD28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CDFD44(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 248);
  uint64_t v2 = (void *)(a1 + 256);
  if (v1 != (void *)(a1 + 256))
  {
    do
    {
      TransportMasterController::getManager_sync(a1, *((_DWORD *)v1 + 7), &v9);
      if (v9)
      {
        (*(void (**)(void, void))(**(void **)(v9 + 96) + 64))(*(void *)(v9 + 96), *((unsigned int *)v1 + 8));
      }
      else
      {
        char v4 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v5 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v12 = v5;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N No manager for SIM: %s", buf, 0xCu);
        }
      }
      if (v10) {
        sub_10004D2C8(v10);
      }
      BOOL v6 = (void *)v1[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          BOOL v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v1[2];
          BOOL v8 = *v7 == (void)v1;
          uint64_t v1 = v7;
        }
        while (!v8);
      }
      uint64_t v1 = v7;
    }
    while (v7 != v2);
  }
}

void sub_100CDFEA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CDFEC0(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 272) != a2)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315394;
      uint64_t v5 = asString();
      __int16 v6 = 2080;
      uint64_t v7 = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I WiFiStatus %s ==>> %s", (uint8_t *)&v4, 0x16u);
    }
    sub_100CE1A68(a1);
  }
}

void sub_100CDFF9C(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 280) != a2)
  {
    if (*(unsigned char *)(a1 + 408)) {
      sub_100CE3334(a1);
    }
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315394;
      uint64_t v5 = subscriber::asString();
      __int16 v6 = 2080;
      uint64_t v7 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I (change states) PreferredDataSim %s ==>> %s", (uint8_t *)&v4, 0x16u);
    }
    sub_100CE1030(a1);
  }
}

void sub_100CE0088(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 276) != a2)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315394;
      uint64_t v5 = subscriber::asString();
      __int16 v6 = 2080;
      uint64_t v7 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I (change states) CurrentDataSim %s ==>> %s", (uint8_t *)&v4, 0x16u);
    }
    sub_100CE1030(a1);
    sub_100CE1A68(a1);
  }
}

void sub_100CE016C(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 284);
  if (v2 != a2)
  {
    BOOL v3 = a2;
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = asStringBool(v3);
      uint64_t v7 = asStringBool(*(unsigned char *)(a1 + 284));
      *(_DWORD *)OsLogContext __p = 136315394;
      *(void *)&__p[4] = v6;
      __int16 v9 = 2080;
      uint64_t v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Airplane mode %s ==>> %s", __p, 0x16u);
      int v2 = *(unsigned __int8 *)(a1 + 284);
    }
    if (v2) {
      goto LABEL_5;
    }
    if (*(void *)(a1 + 672) - *(void *)(a1 + 664) >= 0x11uLL)
    {
      sub_100058DB0(__p, "Airplane mode disabled");
      sub_100CE0E84(a1, (uint64_t *)__p);
      if (v11 < 0) {
        operator delete(*(void **)__p);
      }
      if (*(unsigned char *)(a1 + 284)) {
LABEL_5:
      }
        sub_100CE3334(a1);
    }
    sub_100CE1030(a1);
    sub_100CE1A68(a1);
  }
}

void sub_100CE02AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CE02D0(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 288);
  int v2 = (void **)(a1 + 296);
  if (v1 != (void **)(a1 + 296))
  {
    uint64_t v3 = a1 + 640;
    int v4 = (void **)(a1 + 648);
    do
    {
      uint64_t v5 = sub_100046F68(v3, v1 + 4);
      if (v4 != v5)
      {
        uint64_t v6 = v5;
        uint64_t v7 = (uint64_t)v5[7];
        BOOL v8 = (std::__shared_weak_count *)v6[8];
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v7)
        {
          if (*((unsigned char *)v1 + 64)) {
            BOOL v9 = *((_DWORD *)v1 + 17) == 0;
          }
          else {
            BOOL v9 = 0;
          }
          sub_100EE7D2C(v7, v9);
        }
        if (v8) {
          sub_10004D2C8(v8);
        }
      }
      uint64_t v10 = (void **)v1[1];
      if (v10)
      {
        do
        {
          char v11 = v10;
          uint64_t v10 = (void **)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          char v11 = (void **)v1[2];
          BOOL v12 = *v11 == v1;
          uint64_t v1 = v11;
        }
        while (!v12);
      }
      uint64_t v1 = v11;
    }
    while (v11 != v2);
  }
}

void sub_100CE03AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CE03C4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 312);
  int v2 = (void *)(a1 + 320);
  if (v1 != (void *)(a1 + 320))
  {
    do
    {
      TransportMasterController::getManager_sync(a1, *((_DWORD *)v1 + 7), &v7);
      if (v7) {
        (*(void (**)(void, void))(**(void **)(v7 + 96) + 96))(*(void *)(v7 + 96), *((unsigned int *)v1 + 8));
      }
      if (v8) {
        sub_10004D2C8(v8);
      }
      int v4 = (void *)v1[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          int v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v1[2];
          BOOL v6 = *v5 == (void)v1;
          uint64_t v1 = v5;
        }
        while (!v6);
      }
      uint64_t v1 = v5;
    }
    while (v5 != v2);
  }
}

void sub_100CE048C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CE04A4(uint64_t a1)
{
  if ((operator==() & 1) == 0)
  {
    sub_100CE1030(a1);
  }
}

void sub_100CE04F8(TransportMasterController *a1)
{
  int v2 = *((void *)a1 + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ------ TransportMasterController state ------", buf, 2u);
    int v2 = *((void *)a1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v3 = *((void *)a1 + 91) == 0;
    *(_DWORD *)std::string buf = 67109120;
    LODWORD(v23) = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I WaitingToComeInService[%d]", buf, 8u);
    int v2 = *((void *)a1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((void *)a1 + 95)) {
      BOOL v4 = 0;
    }
    else {
      BOOL v4 = *((void *)a1 + 91) == 0;
    }
    *(_DWORD *)std::string buf = 67109120;
    LODWORD(v23) = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DataSwitchingAllowed[%d]", buf, 8u);
    int v2 = *((void *)a1 + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL RawDynamicCellularDataSwitchState_sync = TransportMasterController::getRawDynamicCellularDataSwitchState_sync(a1);
    uint64_t v6 = asStringBool(RawDynamicCellularDataSwitchState_sync);
    *(_DWORD *)std::string buf = 136315138;
    BOOL v23 = (void *)v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I  DynamicCellularDataSwitch: %s", buf, 0xCu);
  }
  uint64_t v7 = (void *)*((void *)a1 + 86);
  if (v7 != (void *)((char *)a1 + 696))
  {
    do
    {
      BOOL v8 = *((void *)a1 + 5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v9 = v7 + 4;
        if (*((char *)v7 + 55) < 0) {
          BOOL v9 = (void *)*v9;
        }
        *(_DWORD *)std::string buf = 136315138;
        BOOL v23 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I  Assertion: %s", buf, 0xCu);
      }
      uint64_t v10 = (void *)v7[1];
      if (v10)
      {
        do
        {
          char v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          char v11 = (void *)v7[2];
          BOOL v12 = *v11 == (void)v7;
          uint64_t v7 = v11;
        }
        while (!v12);
      }
      uint64_t v7 = v11;
    }
    while (v11 != (void *)((char *)a1 + 696));
  }
  unsigned int v13 = *((void *)a1 + 5);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315138;
    BOOL v23 = (void *)v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I  RecommendedSim: %s", buf, 0xCu);
  }
  int v15 = (void *)*((void *)a1 + 80);
  if (v15 != (void *)((char *)a1 + 648))
  {
    do
    {
      uint64_t v16 = *((void *)a1 + 5);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = (const char *)(v15 + 4);
        uint64_t v18 = *((unsigned __int8 *)v15 + 55);
        int v19 = (char)v18;
        if ((v18 & 0x80u) != 0) {
          uint64_t v18 = v15[5];
        }
        if (v19 < 0) {
          uint64_t v17 = (const char *)v15[4];
        }
        if (!v18) {
          uint64_t v17 = "<invalid>";
        }
        *(_DWORD *)std::string buf = 136315138;
        BOOL v23 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I  Manager: %s", buf, 0xCu);
      }
      char v20 = (void *)v15[1];
      if (v20)
      {
        do
        {
          BOOL v21 = v20;
          char v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          BOOL v21 = (void *)v15[2];
          BOOL v12 = *v21 == (void)v15;
          int v15 = v21;
        }
        while (!v12);
      }
      int v15 = v21;
    }
    while (v21 != (void *)((char *)a1 + 648));
  }
}

void sub_100CE0878(uint64_t a1, void *a2)
{
  if (a2[2] != *(void *)(a1 + 376))
  {
LABEL_21:
    sub_100CE1030(a1);
    return;
  }
  BOOL v4 = (void *)*a2;
  int v2 = a2 + 1;
  BOOL v3 = v4;
  if (v4 != v2)
  {
    uint64_t v5 = *(void **)(a1 + 360);
    while (1)
    {
      BOOL v6 = *((_DWORD *)v3 + 7) == *((_DWORD *)v5 + 7) && *((unsigned __int8 *)v3 + 32) == *((unsigned __int8 *)v5 + 32);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v3[1];
      BOOL v8 = v3;
      if (v7)
      {
        do
        {
          BOOL v3 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          BOOL v3 = (void *)v8[2];
          BOOL v6 = *v3 == (void)v8;
          BOOL v8 = v3;
        }
        while (!v6);
      }
      BOOL v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v6);
      }
      uint64_t v5 = v10;
      if (v3 == v2) {
        return;
      }
    }
    goto LABEL_21;
  }
}

void sub_100CE0924(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 384);
  int v2 = (void *)(a1 + 392);
  if (v1 != (void *)(a1 + 392))
  {
    do
    {
      TransportMasterController::getManager_sync(a1, *((_DWORD *)v1 + 7), &v7);
      if (v7) {
        (*(void (**)(void, void))(**(void **)(v7 + 80) + 56))(*(void *)(v7 + 80), *((unsigned __int8 *)v1 + 32));
      }
      if (v8) {
        sub_10004D2C8(v8);
      }
      BOOL v4 = (void *)v1[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          BOOL v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v1[2];
          BOOL v6 = *v5 == (void)v1;
          uint64_t v1 = v5;
        }
        while (!v6);
      }
      uint64_t v1 = v5;
    }
    while (v5 != v2);
  }
}

void sub_100CE09EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CE0A04(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asStringBool(*(unsigned char *)(a1 + 408));
    int v4 = 136315138;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fInPrivateNetworkModeSink enabled=%s", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t sub_100CE0AA8(uint64_t result)
{
  if (*(unsigned char *)(result + 408))
  {
    uint64_t v1 = result;
    int v2 = *(void **)(result + 640);
    uint64_t v3 = (void *)(result + 648);
    if (v2 != (void *)(result + 648))
    {
      do
      {
        uint64_t result = (*(uint64_t (**)(void, BOOL))(**(void **)(v2[7] + 96) + 72))(*(void *)(v2[7] + 96), *(_DWORD *)(*(void *)(v2[7] + 56) + 52) == *(_DWORD *)(v1 + 412));
        int v4 = (void *)v2[1];
        if (v4)
        {
          do
          {
            uint64_t v5 = v4;
            int v4 = (void *)*v4;
          }
          while (v4);
        }
        else
        {
          do
          {
            uint64_t v5 = (void *)v2[2];
            BOOL v6 = *v5 == (void)v2;
            int v2 = v5;
          }
          while (!v6);
        }
        int v2 = v5;
      }
      while (v5 != v3);
    }
  }
  return result;
}

void sub_100CE0B60(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 416);
  int v2 = (void *)(a1 + 424);
  if (v1 != (void *)(a1 + 424))
  {
    do
    {
      TransportMasterController::getManager_sync(a1, *((_DWORD *)v1 + 7), &v7);
      if (v7) {
        (*(void (**)(void, void))(**(void **)(v7 + 96) + 80))(*(void *)(v7 + 96), *((unsigned __int8 *)v1 + 32));
      }
      if (v8) {
        sub_10004D2C8(v8);
      }
      int v4 = (void *)v1[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          int v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v1[2];
          BOOL v6 = *v5 == (void)v1;
          uint64_t v1 = v5;
        }
        while (!v6);
      }
      uint64_t v1 = v5;
    }
    while (v5 != v2);
  }
}

void sub_100CE0C28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL TransportMasterController::getRawDynamicCellularDataSwitchState_sync(TransportMasterController *this)
{
  int v2 = DataUtils::otherSimSlot();
  TransportMasterController::getManager_sync((uint64_t)this, v2, &v5);
  if (v5) {
    BOOL v3 = sub_10025B63C(v5 + 128, 0) == 1;
  }
  else {
    BOOL v3 = 0;
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  return v3;
}

void sub_100CE0CB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CE0CCC(uint64_t a1)
{
  return a1 + 24;
}

uint64_t sub_100CE0CD4(uint64_t a1)
{
  return a1 - 32;
}

uint64_t sub_100CE0CDC(uint64_t *a1, void *a2)
{
  int v4 = a1 + 5;
  uint64_t v5 = a1 + 4;
  sub_10005CD2C((uint64_t)(a1 + 4), (char *)a1[5]);
  *(v4 - 1) = *a2;
  BOOL v6 = a2 + 1;
  uint64_t v7 = a2[1];
  void *v4 = v7;
  uint64_t v8 = a2[2];
  v4[1] = v8;
  if (v8)
  {
    *(void *)(v7 + 16) = v4;
    *a2 = v6;
    *BOOL v6 = 0;
    a2[2] = 0;
  }
  else
  {
    void *v5 = v4;
  }
  uint64_t result = a1[3];
  if (result)
  {
    uint64_t v10 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v10();
  }
  return result;
}

void TransportMasterController::getManager_sync(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 624);
  BOOL v6 = *(void **)v5;
  uint64_t v7 = *(void **)(v5 + 8);
  if (v6 != v7)
  {
    while (*(unsigned char *)(*v6 + 49) || *(_DWORD *)(*v6 + 52) != a2)
    {
      v6 += 2;
      if (v6 == v7) {
        goto LABEL_17;
      }
    }
  }
  if (v6 == v7)
  {
LABEL_17:
    BOOL v9 = 0;
    goto LABEL_18;
  }
  uint64_t v8 = *v6;
  BOOL v9 = (std::__shared_weak_count *)v6[1];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v8 || (uint64_t v10 = sub_100046F68(a1 + 640, (void **)(v8 + 24)), (void **)(a1 + 648) == v10))
  {
LABEL_18:
    *a3 = 0;
    a3[1] = 0;
    if (!v9) {
      return;
    }
    goto LABEL_14;
  }
  char v11 = (atomic_ullong *)v10[8];
  *a3 = v10[7];
  a3[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed);
  }
  if (v9)
  {
LABEL_14:
    sub_10004D2C8(v9);
  }
}

void sub_100CE0E84(uint64_t a1, uint64_t *a2)
{
  if (*(void *)(a1 + 728)) {
    sub_100CE33CC(a1);
  }
  sub_100058DB0(&__p, "AllowSimsToComeInService");
  Registry::getTimerService(&v8, *(Registry **)(a1 + 440));
  *(void *)&long long buf = off_101A4F8C0;
  *((void *)&buf + 1) = a1;
  p_long long buf = &buf;
  AutoStartTimer::create();
  long long v4 = v12;
  long long v12 = 0uLL;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 736);
  *(_OWORD *)(a1 + 728) = v4;
  if (v5)
  {
    sub_10004D2C8(v5);
    if (*((void *)&v12 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
    }
  }
  sub_10003B34C(&buf);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11 < 0) {
    operator delete(__p);
  }
  BOOL v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = (uint64_t *)*a2;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Created timer to allow SIMs to come in service due to: %s", (uint8_t *)&buf, 0xCu);
  }
}

void sub_100CE0FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100CE1030(uint64_t a1)
{
  BOOL isDynamicCellularDataSwitchingSupported_sync = TransportMasterController::isDynamicCellularDataSwitchingSupported_sync((TransportMasterController *)a1);
  BOOL v3 = *(NSObject **)(a1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (!isDynamicCellularDataSwitchingSupported_sync)
  {
    if (v4)
    {
      uint64_t v8 = (uint64_t)(*(void *)(a1 + 672) - *(void *)(a1 + 664)) >> 4;
      int v9 = *(unsigned __int8 *)(a1 + 284);
      *(_DWORD *)long long buf = 134218240;
      *(void *)&uint8_t buf[4] = v8;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v9;
      uint64_t v10 = "#I DynamicCellularDataSwitching is not supported. ActiveManagers[%lu]; AirplaneMode[%d]";
      char v11 = v3;
      uint32_t v12 = 18;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
    }
LABEL_15:
    LODWORD(v6) = *(_DWORD *)(a1 + 280);
LABEL_16:
    sub_100CE2828(a1, v6);
    return;
  }
  if (v4)
  {
    uint64_t v5 = (uint64_t)(*(void *)(a1 + 672) - *(void *)(a1 + 664)) >> 4;
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I DynamicCellularDataSwitching is supported. Num of active managers: %lu", buf, 0xCu);
  }
  if (*(_DWORD *)(a1 + 344) != 5)
  {
    LODWORD(v6) = *(_DWORD *)(a1 + 340);
    if (v6)
    {
      uint64_t v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I We are in Emergency mode!", buf, 2u);
        LODWORD(v6) = *(_DWORD *)(a1 + 340);
      }
      goto LABEL_16;
    }
  }
  if (*(void *)(a1 + 728) || *(void *)(a1 + 760))
  {
    unsigned int v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = (uint64_t)(*(void *)(a1 + 672) - *(void *)(a1 + 664)) >> 4;
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v14;
      uint64_t v10 = "#I DynamicCellularDataSwitching is not allowed. Num of active managers: %lu";
      char v11 = v13;
      uint32_t v12 = 12;
      goto LABEL_14;
    }
    goto LABEL_15;
  }
  if (*(void *)(a1 + 704))
  {
    int v15 = *(_DWORD *)(a1 + 712);
    if (v15 == *(_DWORD *)(a1 + 276))
    {
      TransportMasterController::getManager_sync(a1, v15, buf);
      if (*(void *)buf
        && (*(int (**)(void))(**(void **)(*(void *)buf + 96) + 24))(*(void *)(*(void *)buf + 96)) >= 2)
      {
        uint64_t v16 = *(NSObject **)(a1 + 40);
        int v17 = 0;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = *(void *)(a1 + 704);
          LODWORD(v80) = 134217984;
          *(void *)((char *)&v80 + 4) = v18;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Honoring Internet assertion. Number of assertions: %lu", (uint8_t *)&v80, 0xCu);
          int v17 = 0;
        }
      }
      else
      {
        int v17 = 1;
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (!v17) {
        return;
      }
      int v19 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = *(void *)(a1 + 704);
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Ignoring the assertion(s). Number of assertions: %lu", buf, 0xCu);
      }
    }
  }
  int v21 = *(_DWORD *)(a1 + 280);
  uint64_t v6 = DataUtils::otherSimSlot();
  TransportMasterController::getManager_sync(a1, v21, &v80);
  uint64_t v22 = v80;
  if ((void)v80)
  {
    int v23 = (*(uint64_t (**)(void))(**(void **)(v80 + 96) + 24))(*(void *)(v80 + 96));
    int v24 = (*(uint64_t (**)(void))(**(void **)(v22 + 96) + 40))(*(void *)(v22 + 96));
    int v25 = (*(uint64_t (**)(void))(**(void **)(v22 + 96) + 32))(*(void *)(v22 + 96));
    int v27 = sub_100EE83AC(v22, v26);
    int v28 = v27;
    if (v27)
    {
      if (*(unsigned char *)(a1 + 408))
      {
        if (v23 >= v27) {
          int v29 = v25;
        }
        else {
          int v29 = 0;
        }
        if (v29 == 1)
        {
          long long v30 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v31 = subscriber::asString();
            if ((v23 - 1) > 2) {
              BOOL v32 = "kOff";
            }
            else {
              BOOL v32 = off_101A4F9B0[v23 - 1];
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v31;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v32;
            uint64_t v38 = "#I Selected: preferred SIM: %s, quality: %s (wrm recommended privateNW)";
            int v39 = v30;
            uint32_t v40 = 22;
            goto LABEL_65;
          }
          goto LABEL_66;
        }
        TransportMasterController::getManager_sync(a1, v6, &v75);
        uint64_t v41 = v75;
        if (v75)
        {
          int v42 = (*(uint64_t (**)(void))(**(void **)(v75 + 96) + 24))(*(void *)(v75 + 96));
          int v44 = sub_100EE83BC(v41, v43);
          int v45 = (*(uint64_t (**)(void))(**(void **)(v41 + 96) + 32))(*(void *)(v41 + 96));
          int v46 = v42 >= v44 ? v45 : 0;
          if (v46 == 1)
          {
            uint64_t v47 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v48 = subscriber::asString();
              if ((v42 - 1) > 2) {
                long long v49 = "kOff";
              }
              else {
                long long v49 = off_101A4F9B0[v42 - 1];
              }
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = v48;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v49;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Selected: non-data preferred SIM: %s, quality: %s (wrm recommended privateNW)", buf, 0x16u);
            }
            sub_100CE2828(a1, v6);
            if (v76) {
              sub_10004D2C8(v76);
            }
            goto LABEL_70;
          }
        }
        if (v76) {
          sub_10004D2C8(v76);
        }
      }
      if (v23 < v28) {
        char v50 = 1;
      }
      else {
        char v50 = v24;
      }
      if (v50)
      {
        int v35 = 1;
        goto LABEL_71;
      }
      BOOL v51 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v52 = subscriber::asString();
        if ((v23 - 1) > 2) {
          int v53 = "kOff";
        }
        else {
          int v53 = off_101A4F9B0[v23 - 1];
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v52;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v53;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Selected: preferred SIM: %s, quality: %s (no congestion)", buf, 0x16u);
      }
      sub_100CE2828(a1, v21);
      int v24 = 0;
      goto LABEL_70;
    }
    char v36 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v37 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v37;
      uint64_t v38 = "#I Selected: preferred SIM: %s (CB doesn't allow moving data from this SIM)";
      int v39 = v36;
      uint32_t v40 = 12;
LABEL_65:
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v38, buf, v40);
    }
LABEL_66:
    sub_100CE2828(a1, v21);
LABEL_70:
    int v35 = 0;
    goto LABEL_71;
  }
  char v33 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = subscriber::asString();
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v34;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Selected: preferred SIM: %s (no manager for preferred SIM)", buf, 0xCu);
  }
  sub_100CE2828(a1, v21);
  int v23 = 0;
  int v35 = 0;
  int v24 = 1;
LABEL_71:
  if (*((void *)&v80 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v80 + 1));
  }
  if (v35)
  {
    TransportMasterController::getManager_sync(a1, v6, buf);
    uint64_t v54 = *(void *)buf;
    if (!*(void *)buf) {
      goto LABEL_105;
    }
    int v55 = (*(uint64_t (**)(void))(**(void **)(*(void *)buf + 96) + 24))(*(void *)(*(void *)buf + 96));
    char v56 = (*(uint64_t (**)(void))(**(void **)(v54 + 96) + 40))(*(void *)(v54 + 96));
    uint64_t v57 = *(void *)(v54 + 56);
    long long v58 = *(std::__shared_weak_count **)(v54 + 64);
    if (v58) {
      atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v59 = (uint64_t *)*(unsigned __int8 *)(v57 + 48);
    if (v59)
    {
      if (sub_100CE2B40(*(Registry **)(a1 + 440), v6, v59))
      {
        if (v55 >= 1)
        {
LABEL_80:
          int v61 = sub_100EE83BC(v54, v60);
          if (v58) {
            sub_10004D2C8(v58);
          }
          if (v55 >= v61)
          {
            if (!v23)
            {
              long long v74 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v80) = 0;
                _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I Selected: non-data preferred SIM (preferred SIM has no Internet)", (uint8_t *)&v80, 2u);
              }
              goto LABEL_106;
            }
            if ((v56 & 1) == 0)
            {
              if (v24)
              {
                long long v62 = *(NSObject **)(a1 + 40);
                if (!os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
                {
LABEL_123:
                  char v56 = 0;
                  goto LABEL_106;
                }
                LOWORD(v80) = 0;
                unint64_t v63 = "#I Selected: non-data preferred SIM is not congested (preferred SIM is congested)";
              }
              else
              {
                if (v55 <= v23)
                {
                  char v56 = 0;
                  LODWORD(v6) = v21;
                  int v55 = v23;
                  goto LABEL_106;
                }
                long long v62 = *(NSObject **)(a1 + 40);
                if (!os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_123;
                }
                LOWORD(v80) = 0;
                unint64_t v63 = "#I Selected: non-data preferred SIM has better quality";
              }
              _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, v63, (uint8_t *)&v80, 2u);
              goto LABEL_123;
            }
          }
LABEL_105:
          LODWORD(v6) = v21;
          int v55 = v23;
          char v56 = v24;
LABEL_106:
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          long long v70 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v71 = subscriber::asString();
            if ((v55 - 1) > 2) {
              uint64_t v72 = "kOff";
            }
            else {
              uint64_t v72 = off_101A4F9B0[v55 - 1];
            }
            uint64_t v73 = asStringBool(v56);
            *(_DWORD *)long long buf = 136315650;
            *(void *)&uint8_t buf[4] = v71;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v72;
            __int16 v78 = 2080;
            uint64_t v79 = v73;
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I Selected: %s, internet quality: %s, congested: %s", buf, 0x20u);
          }
          goto LABEL_16;
        }
      }
      else
      {
        uint64_t v64 = *(void *)(a1 + 368);
        if (v64)
        {
          uint64_t v65 = a1 + 368;
          do
          {
            int v66 = *(_DWORD *)(v64 + 28);
            BOOL v67 = v66 < (int)v6;
            if (v66 >= (int)v6) {
              long long v68 = (uint64_t *)v64;
            }
            else {
              long long v68 = (uint64_t *)(v64 + 8);
            }
            if (!v67) {
              uint64_t v65 = v64;
            }
            uint64_t v64 = *v68;
          }
          while (*v68);
          if (v65 != a1 + 368 && *(_DWORD *)(v65 + 28) <= (int)v6)
          {
            uint64_t v60 = (uint64_t *)*(unsigned __int8 *)(v65 + 32);
            if (v60 && v55 > 0) {
              goto LABEL_80;
            }
          }
        }
      }
    }
    if (v58) {
      sub_10004D2C8(v58);
    }
    goto LABEL_105;
  }
}

void sub_100CE19F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CE1A68(uint64_t a1)
{
  int v2 = *(uint64_t **)(a1 + 672);
  BOOL v3 = *(uint64_t **)(a1 + 664);
  if ((unint64_t)((char *)v2 - (char *)v3) < 0x11 || *(unsigned char *)(a1 + 284) || *(void *)(a1 + 728))
  {
    BOOL v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v5 = *(void *)(a1 + 728) == 0;
      int v6 = *(unsigned __int8 *)(a1 + 284);
      *(_DWORD *)long long buf = 67109632;
      *(_DWORD *)&uint8_t buf[4] = v5;
      *(_WORD *)&uint8_t buf[8] = 2048;
      *(void *)&buf[10] = ((char *)v2 - (char *)v3) >> 4;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Cannot perform Vega: Allowed[%d]; ActiveManagers[%lu]; AirplaneMode[%d]",
        buf,
        0x18u);
      BOOL v3 = *(uint64_t **)(a1 + 664);
      int v2 = *(uint64_t **)(a1 + 672);
    }
    if (v3 != v2)
    {
      uint64_t v7 = v3;
      do
      {
        uint64_t v8 = *v7;
        v7 += 2;
        *(unsigned char *)(v8 + 116) = 0;
        *(_DWORD *)(v8 + 120) = -1;
      }
      while (v7 != v2);
      goto LABEL_9;
    }
    goto LABEL_59;
  }
  uint64_t v20 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Vega is supported", buf, 2u);
  }
  int v21 = *(unsigned __int8 *)(a1 + 272);
  if (v21 == 1)
  {
    BOOL v22 = 1;
    int v23 = 1;
  }
  else
  {
    int v24 = *(_DWORD *)(a1 + 712);
    int v25 = *(_DWORD *)(a1 + 276);
    BOOL v22 = v24 == v25;
    if (v24 != v25)
    {
      long long v26 = *(NSObject **)(a1 + 40);
      BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
      int v24 = v25;
      if (v27)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Data switching is in progress, we should not change transport.", buf, 2u);
        int v24 = *(_DWORD *)(a1 + 276);
      }
    }
    TransportMasterController::getManager_sync(a1, v24, buf);
    if (!*(void *)buf
      || !(*(unsigned int (**)(void))(**(void **)(*(void *)buf + 96) + 24))(*(void *)(*(void *)buf + 96)))
    {
      int v28 = *(NSObject **)(a1 + 40);
      BOOL v22 = 0;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unint64_t v69 = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Current data sim does not have internet.", v69, 2u);
        BOOL v22 = 0;
      }
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    int v23 = 0;
  }
  int v29 = *(uint64_t **)(a1 + 664);
  long long v30 = *(uint64_t **)(a1 + 672);
  if (v29 == v30)
  {
LABEL_59:
    uint64_t v19 = 0;
    long long v70 = 0;
    uint64_t v71 = 0;
    *(void *)unint64_t v69 = &v70;
    goto LABEL_60;
  }
  do
  {
    if (!(*(unsigned int (**)(void))(**(void **)(*v29 + 80) + 16))(*(void *)(*v29 + 80))) {
      goto LABEL_55;
    }
    if (!v22) {
      goto LABEL_57;
    }
    if (v21 != 1
      && !sub_100EE8614(*v29)
      && (sub_100CE2B40(*(Registry **)(a1 + 440), *(unsigned int *)(a1 + 276), v31) & 1) == 0)
    {
      uint64_t v34 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v35 = *(void *)(*v29 + 56);
        char v36 = *(std::__shared_weak_count **)(*v29 + 64);
        if (v36) {
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v37 = (void *)(v35 + 24);
        if (*(char *)(v35 + 47) < 0) {
          uint64_t v37 = (void *)*v37;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v37;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Vega not allowed in roaming for: %s", buf, 0xCu);
        if (v36) {
          sub_10004D2C8(v36);
        }
      }
LABEL_55:
      char v32 = 0;
      int v33 = -1;
      goto LABEL_56;
    }
    char v32 = 1;
    int v33 = v23;
LABEL_56:
    uint64_t v38 = *v29;
    *(unsigned char *)(v38 + 116) = v32;
    *(_DWORD *)(v38 + 120) = v33;
LABEL_57:
    v29 += 2;
  }
  while (v29 != v30);
  BOOL v3 = *(uint64_t **)(a1 + 664);
  int v2 = *(uint64_t **)(a1 + 672);
LABEL_9:
  long long v70 = 0;
  uint64_t v71 = 0;
  *(void *)unint64_t v69 = &v70;
  if (v3 == v2)
  {
    uint64_t v19 = 0;
  }
  else
  {
    do
    {
      uint64_t v9 = *v3;
      if (sub_100012EE8(*v3)) {
        unint64_t v10 = *(void *)(v9 + 116);
      }
      else {
        unint64_t v10 = 0xFFFFFFFF00000000;
      }
      uint64_t v11 = *(void *)(*v3 + 56);
      uint32_t v12 = *(std::__shared_weak_count **)(*v3 + 64);
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v72 = 0;
      unsigned int v13 = (uint64_t **)sub_100046ED4((uint64_t)v69, &v72, (void **)(v11 + 24));
      uint64_t v14 = *v13;
      if (!*v13)
      {
        *(void *)&uint8_t buf[16] = 0;
        uint64_t v14 = (uint64_t *)operator new(0x40uLL);
        *(void *)&uint8_t buf[8] = &v70;
        uint8_t buf[16] = 0;
        int v15 = v14 + 4;
        if (*(char *)(v11 + 47) < 0)
        {
          sub_10004FC84(v15, *(void **)(v11 + 24), *(void *)(v11 + 32));
        }
        else
        {
          long long v16 = *(_OWORD *)(v11 + 24);
          v14[6] = *(void *)(v11 + 40);
          *(_OWORD *)int v15 = v16;
        }
        v14[7] = 0xFFFFFFFF00000000;
        uint64_t v17 = v72;
        uint64_t *v14 = 0;
        v14[1] = 0;
        v14[2] = v17;
        NSObject *v13 = v14;
        uint64_t v18 = v14;
        if (**(void **)v69)
        {
          *(void *)unint64_t v69 = **(void **)v69;
          uint64_t v18 = *v13;
        }
        sub_100046C90(v70, v18);
        ++v71;
      }
      v14[7] = v10;
      if (v12) {
        sub_10004D2C8(v12);
      }
      v3 += 2;
    }
    while (v3 != v2);
    uint64_t v19 = v71;
  }
LABEL_60:
  if (*(void *)(a1 + 112) == v19)
  {
    int v39 = *(unsigned __int8 **)(a1 + 96);
    if (v39 != (unsigned __int8 *)(a1 + 104))
    {
      uint32_t v40 = *(unsigned __int8 **)v69;
      while (sub_10001D294(v39 + 32, v40 + 32) && v39[56] == v40[56] && *((_DWORD *)v39 + 15) == *((_DWORD *)v40 + 15))
      {
        uint64_t v41 = (unsigned __int8 *)*((void *)v39 + 1);
        int v42 = v39;
        if (v41)
        {
          do
          {
            int v39 = v41;
            uint64_t v41 = *(unsigned __int8 **)v41;
          }
          while (v41);
        }
        else
        {
          do
          {
            int v39 = (unsigned __int8 *)*((void *)v42 + 2);
            BOOL v43 = *(void *)v39 == (void)v42;
            int v42 = v39;
          }
          while (!v43);
        }
        int v44 = (unsigned __int8 *)*((void *)v40 + 1);
        if (v44)
        {
          do
          {
            int v45 = v44;
            int v44 = *(unsigned __int8 **)v44;
          }
          while (v44);
        }
        else
        {
          do
          {
            int v45 = (unsigned __int8 *)*((void *)v40 + 2);
            BOOL v43 = *(void *)v45 == (void)v40;
            uint32_t v40 = v45;
          }
          while (!v43);
        }
        uint32_t v40 = v45;
        if (v39 == (unsigned __int8 *)(a1 + 104)) {
          goto LABEL_124;
        }
      }
      goto LABEL_78;
    }
  }
  else
  {
LABEL_78:
    if ((uint8_t *)(a1 + 96) != v69)
    {
      int v46 = *(uint64_t ***)v69;
      if (*(void *)(a1 + 112))
      {
        uint64_t v47 = *(void *)(a1 + 104);
        uint64_t v48 = *(void *)(a1 + 96);
        *(void *)(a1 + 96) = a1 + 104;
        *(void *)(v47 + 16) = 0;
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        if (*(void *)(v48 + 8)) {
          uint64_t v49 = *(void *)(v48 + 8);
        }
        else {
          uint64_t v49 = v48;
        }
        *(void *)long long buf = a1 + 96;
        *(void *)&uint8_t buf[8] = v49;
        *(void *)&uint8_t buf[16] = v49;
        if (v49)
        {
          *(void *)&uint8_t buf[8] = sub_1000EA590(v49);
          char v50 = &v70;
          if (v46 != &v70)
          {
            do
            {
              std::string::operator=((std::string *)(v49 + 32), (const std::string *)(v46 + 4));
              *(void *)(v49 + 56) = v46[7];
              BOOL v51 = *(uint64_t **)&buf[16];
              uint64_t v72 = 0;
              uint64_t v52 = (uint64_t **)sub_1000EA518(a1 + 96, &v72, (void *)(*(void *)&buf[16] + 32));
              sub_100046C38((uint64_t **)(a1 + 96), v72, v52, v51);
              uint64_t v49 = *(void *)&buf[8];
              *(void *)&uint8_t buf[16] = *(void *)&buf[8];
              if (*(void *)&buf[8]) {
                *(void *)&uint8_t buf[8] = sub_1000EA590(*(uint64_t *)&buf[8]);
              }
              int v53 = v46[1];
              if (v53)
              {
                do
                {
                  char v50 = (uint64_t **)v53;
                  int v53 = (uint64_t *)*v53;
                }
                while (v53);
              }
              else
              {
                do
                {
                  char v50 = (uint64_t **)v46[2];
                  BOOL v43 = *v50 == (uint64_t *)v46;
                  int v46 = v50;
                }
                while (!v43);
              }
              if (!v49) {
                break;
              }
              int v46 = v50;
            }
            while (v50 != &v70);
          }
        }
        else
        {
          char v50 = v46;
        }
        sub_1000EA5E4((uint64_t)buf);
        int v46 = v50;
      }
      if (v46 != &v70)
      {
        do
        {
          memset(buf, 0, sizeof(buf));
          sub_100CE7084(buf, a1 + 96, (uint64_t)(v46 + 4));
          uint64_t v72 = 0;
          uint64_t v54 = (uint64_t **)sub_1000EA518(a1 + 96, &v72, (void *)(*(void *)buf + 32));
          sub_100046C38((uint64_t **)(a1 + 96), v72, v54, *(uint64_t **)buf);
          int v55 = v46[1];
          if (v55)
          {
            do
            {
              char v56 = (uint64_t **)v55;
              int v55 = (uint64_t *)*v55;
            }
            while (v55);
          }
          else
          {
            do
            {
              char v56 = (uint64_t **)v46[2];
              BOOL v43 = *v56 == (uint64_t *)v46;
              int v46 = v56;
            }
            while (!v43);
          }
          int v46 = v56;
        }
        while (v56 != &v70);
      }
    }
    uint64_t v57 = *(void *)(a1 + 88);
    if (v57) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v57 + 48))(v57, a1 + 96);
    }
    long long v58 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I Updated fTransportMasterRatRecommendationOverrideSource:", buf, 2u);
    }
    char v59 = *(uint64_t **)v69;
    if (*(uint64_t ***)v69 != &v70)
    {
      do
      {
        uint64_t v60 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
        {
          int v61 = (const char *)v59[4];
          uint64_t v62 = *((unsigned __int8 *)v59 + 55);
          int v63 = (char)v62;
          if ((v62 & 0x80u) != 0) {
            uint64_t v62 = v59[5];
          }
          if (v63 >= 0) {
            int v61 = (const char *)(v59 + 4);
          }
          if (v62) {
            uint64_t v64 = v61;
          }
          else {
            uint64_t v64 = "<invalid>";
          }
          uint64_t v65 = asStringBool(*((unsigned char *)v59 + 56));
          uint64_t v66 = asString();
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = v64;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v65;
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v74 = v66;
          _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I | %s: %s, %s", buf, 0x20u);
        }
        BOOL v67 = (uint64_t *)v59[1];
        if (v67)
        {
          do
          {
            long long v68 = (uint64_t **)v67;
            BOOL v67 = (uint64_t *)*v67;
          }
          while (v67);
        }
        else
        {
          do
          {
            long long v68 = (uint64_t **)v59[2];
            BOOL v43 = *v68 == v59;
            char v59 = (uint64_t *)v68;
          }
          while (!v43);
        }
        char v59 = (uint64_t *)v68;
      }
      while (v68 != &v70);
    }
  }
LABEL_124:
  sub_10005CD2C((uint64_t)v69, (char *)v70);
}

void sub_100CE2300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100CE237C(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100CE7434;
  uint64_t v5[3] = &unk_101A4F830;
  _OWORD v5[4] = a1 + 8;
  v5[5] = &v4;
  int v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005B1D0;
    unint64_t v10 = &unk_101A4F870;
    uint64_t v11 = &v13;
    uint32_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    blocuint64_t k = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005A46C;
    unint64_t v10 = &unk_101A4F850;
    uint64_t v11 = &v13;
    uint32_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_100CE24AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v3 = (void *)(a1 + 8);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a3;
    xpc_object_t __p[2] = *(void **)(a3 + 16);
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, v3);
  operator new();
}

void sub_100CE2608(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100CE26E4(uint64_t a1)
{
}

void sub_100CE26EC(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100CE27C8(uint64_t a1)
{
}

BOOL TransportMasterController::isDynamicCellularDataSwitchingSupported_sync(TransportMasterController *this)
{
  return (TransportMasterController::getRawDynamicCellularDataSwitchState_sync(this) || *((unsigned char *)this + 408))
      && *((void *)this + 84) - *((void *)this + 83) >= 0x11uLL
      && *((unsigned char *)this + 284) == 0;
}

void sub_100CE2828(uint64_t a1, int a2)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(a1 + 712);
    BOOL v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Recommending slot: %s", buf, 0xCu);
    }
    *(_DWORD *)(a1 + 712) = a2;
    if (v4 != a2)
    {
      int v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a1 + 704);
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Removed all Internet assertions. Number of assertions: %lu", buf, 0xCu);
      }
      sub_10005CD2C(a1 + 688, *(char **)(a1 + 696));
      *(void *)(a1 + 688) = a1 + 696;
      *(void *)(a1 + 704) = 0;
      *(void *)(a1 + 696) = 0;
      sub_100CE1A68(a1);
      if (*(_DWORD *)(a1 + 712) != *(_DWORD *)(a1 + 280)) {
        sub_1011DEFFC(buf);
      }
      uint64_t v8 = *(std::__shared_weak_count **)(a1 + 752);
      *(_OWORD *)(a1 + 744) = 0u;
      if (v8) {
        sub_10004D2C8(v8);
      }
    }
    write_rest_value();
    sub_100058DB0(buf, "/cc/events/recommended_data_sim");
    xpc_object_t v9 = xpc_null_create();
    ctu::RestModule::sendEvent();
    xpc_release(0);
    if (v11 < 0) {
      operator delete(*(void **)buf);
    }
    xpc_release(v9);
  }
}

void sub_100CE2ACC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12, void *__p, std::__shared_weak_count *a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CE2B40@<X0>(Registry *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, a1);
  BOOL v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v6;
  unint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v16);
  if (v10)
  {
    uint64_t v12 = v10[3];
    char v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  char v11 = 0;
  char v13 = 1;
  if (!v12) {
    goto LABEL_13;
  }
LABEL_10:
  if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 744))(v12, a2))
  {
    uint64_t v14 = 1;
    if (v13) {
      return v14;
    }
    goto LABEL_14;
  }
LABEL_13:
  uint64_t v14 = 0;
  if ((v13 & 1) == 0) {
LABEL_14:
  }
    sub_10004D2C8(v11);
  return v14;
}

void sub_100CE2C6C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100CE2C88(uint64_t a1, uint64_t a2)
{
  int v4 = (uint64_t **)(a1 + 688);
  uint64_t result = (uint64_t *)sub_100046F68(a1 + 688, (void **)a2);
  if ((uint64_t *)(a1 + 696) == result)
  {
    unint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = *(void *)a2;
      }
      int v8 = 136315138;
      uint64_t v9 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Added Internet assertion: %s", (uint8_t *)&v8, 0xCu);
    }
    return sub_100046BAC(v4, (void **)a2, a2);
  }
  return result;
}

uint64_t *sub_100CE2D68(uint64_t a1, uint64_t a2)
{
  return sub_100CE2C88(a1 - 56, a2);
}

void sub_100CE2D70(uint64_t a1, uint64_t a2)
{
  int v4 = DataUtils::otherSimSlot();
  TransportMasterController::getManager_sync(a1, v4, &v14);
  uint64_t v5 = v14;
  if (v14 && (*(unsigned int (**)(void))(**(void **)(v14 + 96) + 24))(*(void *)(v14 + 96)))
  {
    unint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = (void *)(*(void *)a2 + 24);
      if (*(char *)(*(void *)a2 + 47) < 0) {
        uint64_t v7 = (void *)*v7;
      }
      uint64_t v8 = *(void *)(v5 + 56);
      uint64_t v9 = *(std::__shared_weak_count **)(v5 + 64);
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v10 = (void *)(v8 + 24);
      if (*(char *)(v8 + 47) < 0) {
        unint64_t v10 = (void *)*v10;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v10;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Suspend search for: %s by marking critical activity on: %s", buf, 0x16u);
      if (v9) {
        sub_10004D2C8(v9);
      }
    }
    *(void *)long long buf = 1;
    *(_OWORD *)&uint8_t buf[16] = 0u;
    uint64_t v18 = 0;
    *(void *)&uint8_t buf[8] = a1 + 120;
    char v11 = (uint64_t **)sub_100CE7138((uint64_t)&buf[16], (void *)(a1 + 152));
    uint64_t v12 = *(void *)(v5 + 56);
    char v13 = *(std::__shared_weak_count **)(v5 + 64);
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v16 = (long long *)(v12 + 24);
    *((unsigned char *)sub_1001010C0(v11, (void **)(v12 + 24), (uint64_t)&unk_10144E20E, &v16) + 56) = 1;
    if (v13) {
      sub_10004D2C8(v13);
    }
    sub_100CE7358((uint64_t)buf);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_100CE2F3C(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_100CE7358((uint64_t)va);
  if (a3) {
    sub_10004D2C8(a3);
  }
  _Unwind_Resume(a1);
}

void sub_100CE2F74(uint64_t a1, uint64_t a2)
{
}

void sub_100CE2F7C(uint64_t a1, uint64_t a2)
{
  int v4 = DataUtils::otherSimSlot();
  TransportMasterController::getManager_sync(a1, v4, &v14);
  uint64_t v5 = v14;
  if (v14)
  {
    unint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = (void *)(*(void *)a2 + 24);
      if (*(char *)(*(void *)a2 + 47) < 0) {
        uint64_t v7 = (void *)*v7;
      }
      uint64_t v8 = *(void *)(v5 + 56);
      uint64_t v9 = *(std::__shared_weak_count **)(v5 + 64);
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v10 = (void *)(v8 + 24);
      if (*(char *)(v8 + 47) < 0) {
        unint64_t v10 = (void *)*v10;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v10;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Resume search for: %s by unmarking critical activity on: %s", buf, 0x16u);
      if (v9) {
        sub_10004D2C8(v9);
      }
    }
    *(void *)long long buf = 1;
    *(_OWORD *)&uint8_t buf[16] = 0u;
    uint64_t v18 = 0;
    *(void *)&uint8_t buf[8] = a1 + 120;
    char v11 = (uint64_t **)sub_100CE7138((uint64_t)&buf[16], (void *)(a1 + 152));
    uint64_t v12 = *(void *)(v5 + 56);
    char v13 = *(std::__shared_weak_count **)(v5 + 64);
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v16 = (long long *)(v12 + 24);
    *((unsigned char *)sub_1001010C0(v11, (void **)(v12 + 24), (uint64_t)&unk_10144E20E, &v16) + 56) = 0;
    if (v13) {
      sub_10004D2C8(v13);
    }
    sub_100CE7358((uint64_t)buf);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_100CE3118(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_100CE7358((uint64_t)va);
  if (a3) {
    sub_10004D2C8(a3);
  }
  _Unwind_Resume(a1);
}

void sub_100CE314C(uint64_t a1, uint64_t a2)
{
}

void sub_100CE3154(uint64_t a1, uint64_t a2)
{
  int v4 = (uint64_t **)(a1 + 688);
  uint64_t v5 = sub_100046F68(a1 + 688, (void **)a2);
  if ((void **)(a1 + 696) != v5)
  {
    uint64_t v6 = (uint64_t)v5;
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v8 = (void *)a2;
      }
      else {
        uint64_t v8 = *(void **)a2;
      }
      int v9 = 136315138;
      unint64_t v10 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Removing Internet assertion: %s", (uint8_t *)&v9, 0xCu);
    }
    sub_1000E1C44(v4, v6);
    sub_100CE1030(a1);
  }
}

void sub_100CE3244(uint64_t a1, uint64_t a2)
{
}

uint64_t **sub_100CE324C(uint64_t **a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v6;
        unint64_t v9 = v6[4];
        if (v9 <= a2) {
          break;
        }
        uint64_t v6 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_9;
        }
      }
      if (v9 >= a2) {
        break;
      }
      uint64_t v6 = v8[1];
      if (!v6)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_9;
      }
    }
    char v11 = v8;
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_9:
    unint64_t v10 = (uint64_t **)operator new(0x38uLL);
    char v11 = v10;
    v10[4] = (uint64_t *)a2;
    v10[5] = a3;
    if (a3) {
      atomic_fetch_add_explicit(a3 + 1, 1uLL, memory_order_relaxed);
    }
    *((unsigned char *)v10 + 50) = 0;
    *((_WORD *)v10 + 24) = 0;
    void *v10 = 0;
    v10[1] = 0;
    v10[2] = (uint64_t *)v8;
    *uint64_t v7 = (uint64_t *)v10;
    uint64_t v12 = (uint64_t *)**a1;
    char v13 = (uint64_t *)v10;
    if (v12)
    {
      *a1 = v12;
      char v13 = *v7;
    }
    sub_100046C90(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v11 + 6;
}

uint64_t sub_100CE3334(uint64_t result)
{
  if (*(unsigned char *)(result + 408))
  {
    uint64_t v1 = *(void **)(result + 640);
    char v2 = (void *)(result + 648);
    if (v1 != (void *)(result + 648))
    {
      do
      {
        uint64_t result = (*(uint64_t (**)(void))(**(void **)(v1[7] + 96) + 112))(*(void *)(v1[7] + 96));
        BOOL v3 = (void *)v1[1];
        if (v3)
        {
          do
          {
            int v4 = v3;
            BOOL v3 = (void *)*v3;
          }
          while (v3);
        }
        else
        {
          do
          {
            int v4 = (void *)v1[2];
            BOOL v5 = *v4 == (void)v1;
            uint64_t v1 = v4;
          }
          while (!v5);
        }
        uint64_t v1 = v4;
      }
      while (v4 != v2);
    }
  }
  return result;
}

void sub_100CE33CC(uint64_t a1)
{
  char v2 = (_OWORD *)(a1 + 728);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 736);
  _OWORD *v2 = 0u;
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Removed timer to allow SIMs to come in service", v5, 2u);
  }
}

void *sub_100CE3448(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100CE34CC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A4ECE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100CE34EC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A4ECE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100CE3540(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 24))();
}

void sub_100CE3568(ServiceManager::Service *this)
{
  *(void *)this = off_101A4EDC8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100CE35C4(ServiceManager::Service *this)
{
  *(void *)this = off_101A4EDC8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100CE3634@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "TransportMasterController");
}

unsigned char *sub_100CE3644@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  char v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100CE3684(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  BOOL v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  long long v4 = 0uLL;
  sub_10003E168(&v4, (void *)(v2 + 8));
  long long v4 = 0uLL;
  operator new();
}

uint64_t sub_100CE3754()
{
  return 1;
}

uint64_t sub_100CE375C()
{
  return 1;
}

uint64_t sub_100CE3764()
{
  return 2;
}

void sub_100CE376C(uint64_t a1, void **a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  BOOL v5 = *a2;
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v6 = *a3;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v6);
  }
  *(void *)&long long v10 = &object;
  *((void *)&v10 + 1) = "kIsEraseInstall";
  sub_100048BAC((uint64_t)&v10, &v11);
  char v8 = xpc::dyn_cast_or_default((xpc *)&v11, 0, v7);
  xpc_release(v11);
  if ((v8 & 1) == 0)
  {
    if (v6)
    {
      dispatch_retain(v6);
      dispatch_group_enter(v6);
    }
    long long v10 = 0uLL;
    sub_10003E168(&v10, (void *)(v4 + 8));
    long long v10 = 0uLL;
    operator new();
  }
  if (v6)
  {
    dispatch_group_leave(v6);
    dispatch_release(v6);
  }
  xpc_release(object);
}

void sub_100CE38D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  xpc_release(*(xpc_object_t *)(v13 - 40));
  if (v12)
  {
    dispatch_group_leave(v12);
    dispatch_release(v12);
  }
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_100CE3914(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  long long v2 = 0uLL;
  sub_10003E168(&v2, (void *)(v1 + 8));
  long long v2 = 0uLL;
  operator new();
}

void sub_100CE39C8(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  long long v5 = 0uLL;
  sub_10003E168(&v5, (void *)(v3 + 8));
  group[1] = 0;
  long long v5 = 0uLL;
  operator new();
}

void sub_100CE3AA4(ServiceManager::Service *this)
{
  *(void *)this = off_101A4EDC8;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100CE3B00(ServiceManager::Service *this)
{
  *(void *)this = off_101A4EDC8;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_100CE3B70()
{
  return 0;
}

uint64_t sub_100CE3B78()
{
  return 0;
}

uint64_t *sub_100CE3B84(uint64_t a1)
{
  uint64_t v2 = a1;
  return sub_100046B58(&v2);
}

void sub_100CE3BAC(uint64_t a1)
{
  uint64_t v1 = a1;
  v5[0] = 0;
  v5[1] = 0;
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  sub_100076564(v5);
}

void sub_100CE3CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v15 = a14;
  a14 = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 32))(v15);
  }
  sub_1003C2130(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100CE3D14(uint64_t a1)
{
  uint64_t v27 = a1;
  uint64_t v1 = *(void **)a1;
  Registry::createRestModuleOneTimeUseConnection(&v28, *(Registry **)(*(void *)a1 + 440));
  ctu::RestModule::connect();
  uint64_t v2 = (capabilities::ct *)v29;
  if (v29) {
    sub_10004D2C8(v29);
  }
  if (capabilities::ct::supportsGemini(v2))
  {
    uint64_t v3 = (uint64_t (***)())operator new(0x20uLL);
    NSObject *v3 = off_101A4EE30;
    v3[1] = (uint64_t (**)())v1;
    std::locale v3[2] = (uint64_t (**)())sub_100CDE3C0;
    v3[3] = 0;
    char v36 = v3;
    uint64_t v33 = 0;
    v30[3] = 0;
    PersonalitiesTracker::bind();
    sub_100100490(v30);
    sub_10010040C(__p);
    sub_100100388(&v34);
    uint64_t v4 = (uint64_t (***)())(v1 + 8);
    uint64_t v34 = off_101A4EEB0;
    uint64_t v35 = v1 + 57;
    char v36 = &v34;
    if (&v34 != v1 + 8)
    {
      long long v5 = (uint64_t (***)())v1[11];
      if (v5 == v4)
      {
        __p[1] = v1 + 57;
        uint64_t v32 = 0;
        __p[0] = off_101A4EEB0;
        char v36 = 0;
        ((void (*)(void *, uint64_t (***)()))(*v4)[3])(v1 + 8, &v34);
        (*(void (**)(void))(*(void *)v1[11] + 32))(v1[11]);
        v1[11] = 0;
        char v36 = &v34;
        (*((void (**)(void **, void *))__p[0] + 3))(__p, v1 + 8);
        (*((void (**)(void **))__p[0] + 4))(__p);
      }
      else
      {
        v1[8] = off_101A4EEB0;
        v1[9] = v1 + 57;
        char v36 = v5;
      }
      v1[11] = v4;
    }
    sub_100CE3448(&v34);
    uint64_t v6 = v1[11];
    if (v6) {
      (*(void (**)(uint64_t, void *))(*(void *)v6 + 48))(v6, v1 + 12);
    }
    uint64_t v34 = off_101A4EF40;
    uint64_t v35 = v1 + 57;
    char v36 = &v34;
    sub_10098310C(&v34, v1 + 15);
    sub_10097E974(&v34);
    uint64_t v7 = v1[18];
    if (v7) {
      (*(void (**)(uint64_t, void *))(*(void *)v7 + 48))(v7, v1 + 19);
    }
    sub_100058DB0(__p, "/cc/props/registration_status");
    char v8 = (uint64_t (***)())operator new(0x28uLL);
    void *v8 = off_101A4EFC0;
    v8[1] = (uint64_t (**)())(v1 + 22);
    _OWORD v8[2] = (uint64_t (**)())v1;
    void v8[3] = (uint64_t (**)())sub_100CDF224;
    void v8[4] = 0;
    char v36 = v8;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/current_calls");
    unint64_t v9 = (uint64_t (***)())operator new(0x28uLL);
    std::__shared_weak_count *v9 = off_101A4F040;
    v9[1] = (uint64_t (**)())(v1 + 25);
    CFTypeRef v9[2] = (uint64_t (**)())v1;
    void v9[3] = (uint64_t (**)())sub_100CDF304;
    void v9[4] = 0;
    char v36 = v9;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/internet_connection_availability_any_sim");
    long long v10 = (uint64_t (***)())operator new(0x28uLL);
    void *v10 = off_101A4F0C0;
    v10[1] = (uint64_t (**)())(v1 + 28);
    v10[2] = (uint64_t (**)())v1;
    v10[3] = (uint64_t (**)())sub_100CDFBC0;
    v10[4] = 0;
    char v36 = v10;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/bb_driver_data_modes");
    xpc_object_t v11 = (uint64_t (***)())operator new(0x28uLL);
    std::__shared_weak_count *v11 = off_101A4F140;
    v11[1] = (uint64_t (**)())(v1 + 31);
    v11[2] = (uint64_t (**)())v1;
    v11[3] = (uint64_t (**)())sub_100CDFD44;
    _OWORD v11[4] = 0;
    char v36 = v11;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/wifi_status");
    uint64_t v12 = (uint64_t (***)())operator new(0x28uLL);
    NSObject *v12 = off_101A4F1C0;
    v12[1] = (uint64_t (**)())(v1 + 34);
    _OWORD v12[2] = (uint64_t (**)())v1;
    void v12[3] = (uint64_t (**)())sub_100CDFEC0;
    void v12[4] = 0;
    char v36 = v12;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/user_preferred_data_slot");
    uint64_t v13 = (uint64_t (***)())operator new(0x28uLL);
    uint64_t *v13 = off_101A4F240;
    v13[1] = (uint64_t (**)())(v1 + 35);
    _OWORD v13[2] = (uint64_t (**)())v1;
    _OWORD v13[3] = (uint64_t (**)())sub_100CDFF9C;
    v13[4] = 0;
    char v36 = v13;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/current_data_slot");
    uint64_t v14 = (uint64_t (***)())operator new(0x28uLL);
    uint64_t *v14 = off_101A4F2C0;
    v14[1] = (uint64_t (**)())((char *)v1 + 276);
    v14[2] = (uint64_t (**)())v1;
    void v14[3] = (uint64_t (**)())sub_100CE0088;
    v14[4] = 0;
    char v36 = v14;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/airplane_mode");
    uint64_t v15 = (uint64_t (***)())operator new(0x28uLL);
    std::__shared_weak_count *v15 = off_101A4F340;
    v15[1] = (uint64_t (**)())((char *)v1 + 284);
    _OWORD v15[2] = (uint64_t (**)())v1;
    void v15[3] = (uint64_t (**)())sub_100CE016C;
    _OWORD v15[4] = 0;
    char v36 = v15;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/ims_registration_state");
    unint64_t v16 = (uint64_t (***)())operator new(0x28uLL);
    long long *v16 = off_101A4F3C0;
    v16[1] = (uint64_t (**)())(v1 + 36);
    v16[2] = (uint64_t (**)())v1;
    v16[3] = (uint64_t (**)())sub_100CE02D0;
    v16[4] = 0;
    char v36 = v16;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/rat");
    uint64_t v17 = (uint64_t (***)())operator new(0x28uLL);
    *uint64_t v17 = off_101A4F440;
    v17[1] = (uint64_t (**)())(v1 + 39);
    v17[2] = (uint64_t (**)())v1;
    void v17[3] = (uint64_t (**)())sub_100CE03C4;
    v17[4] = 0;
    char v36 = v17;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/emergency_mode");
    uint64_t v18 = (uint64_t (***)())operator new(0x28uLL);
    uint64_t *v18 = off_101A4F4C0;
    v18[1] = (uint64_t (**)())(v1 + 42);
    void v18[2] = (uint64_t (**)())v1;
    v18[3] = (uint64_t (**)())sub_100CE04A4;
    v18[4] = 0;
    char v36 = v18;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/events/dump_state");
    uint64_t v19 = (uint64_t (***)())operator new(0x20uLL);
    NSObject *v19 = off_101A4F540;
    v19[1] = (uint64_t (**)())v1;
    _OWORD v19[2] = (uint64_t (**)())sub_100CE04F8;
    v19[3] = 0;
    char v36 = v19;
    ctu::RestModule::observeEvent();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/effective_data_roaming_setting");
    uint64_t v20 = (uint64_t (***)())operator new(0x28uLL);
    NSObject *v20 = off_101A4F5C0;
    v20[1] = (uint64_t (**)())(v1 + 45);
    _OWORD v20[2] = (uint64_t (**)())v1;
    v20[3] = (uint64_t (**)())sub_100CE0878;
    _OWORD v20[4] = 0;
    char v36 = v20;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/reg_data_attached");
    int v21 = (uint64_t (***)())operator new(0x28uLL);
    void *v21 = off_101A4F640;
    v21[1] = (uint64_t (**)())(v1 + 48);
    v21[2] = (uint64_t (**)())v1;
    v21[3] = (uint64_t (**)())sub_100CE0924;
    v21[4] = 0;
    char v36 = v21;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/in_private_network_mode");
    BOOL v22 = (uint64_t (***)())operator new(0x28uLL);
    *BOOL v22 = off_101A4F6C0;
    v22[1] = (uint64_t (**)())(v1 + 51);
    void v22[2] = (uint64_t (**)())v1;
    v22[3] = (uint64_t (**)())sub_100CE0A04;
    v22[4] = 0;
    char v36 = v22;
    ctu::RestModule::observeProperty();
    int v23 = (capabilities::ct *)sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    if (capabilities::ct::supportsCerberus(v23))
    {
      sub_100058DB0(__p, "/cc/props/pnw_sub_preference");
      int v24 = (uint64_t (***)())operator new(0x28uLL);
      char *v24 = off_101A4F740;
      v24[1] = (uint64_t (**)())((char *)v1 + 412);
      std::string v24[2] = (uint64_t (**)())v1;
      void v24[3] = (uint64_t (**)())sub_100CE0AA8;
      v24[4] = 0;
      char v36 = v24;
      ctu::RestModule::observeProperty();
      sub_10003F600(&v34);
      if (SHIBYTE(v32) < 0) {
        operator delete(__p[0]);
      }
    }
    sub_100058DB0(__p, "/cc/props/congestion_status");
    int v25 = (uint64_t (***)())operator new(0x28uLL);
    *int v25 = off_101A4F7C0;
    v25[1] = (uint64_t (**)())(v1 + 52);
    std::string v25[2] = (uint64_t (**)())v1;
    v25[3] = (uint64_t (**)())sub_100CE0B60;
    v25[4] = 0;
    char v36 = v25;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v34);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    TransportMasterController::setupAwdMetricCallbacks_sync((TransportMasterController *)v1);
  }
  return sub_1003C2130(&v27);
}

void sub_100CE485C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100CE495C(void *a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = (uint64_t *)(*a1 + 64);
  v6[0] = 0;
  v6[1] = 0;
  long long v5 = v6;
  sub_100CE0CDC(v2, &v5);
  sub_10005CD2C((uint64_t)&v5, v6[0]);
  sub_10019E028((uint64_t *)(v1 + 664));
  sub_1001FEC70(*(void **)(v1 + 648));
  *(void *)(v1 + 640) = v1 + 648;
  *(void *)(v1 + 656) = 0;
  *(void *)(v1 + 648) = 0;
  ctu::RestModule::disconnect((ctu::RestModule *)(v1 + 456));
  return sub_1003C2130((uint64_t *)&v4);
}

void sub_100CE49E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100CE4A0C()
{
}

__n128 sub_100CE4A20(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A4EE30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100CE4A74(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4EE30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE4AAC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v6 + v4);
  }
  return v4(v6, a3, a4);
}

uint64_t sub_100CE4AFC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE4B3C()
{
}

void sub_100CE4B4C()
{
}

void *sub_100CE4B60(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A4EEB0;
  result[1] = v3;
  return result;
}

uint64_t sub_100CE4BA8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A4EEB0;
  a2[1] = v2;
  return result;
}

void sub_100CE4BD4(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v23 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v23 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v23 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      write_rest_value();
      OsLogContext __p = &v23;
      uint64_t v17 = "first";
      sub_100035E70((uint64_t)&__p, &v21, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v21);
      xpc_object_t v21 = 0;
      write_rest_value();
      OsLogContext __p = &v23;
      uint64_t v17 = "second";
      sub_100035E70((uint64_t)&__p, &v19, &v20);
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_object_t v11 = v23;
      if (v23) {
        xpc_retain(v23);
      }
      else {
        xpc_object_t v11 = xpc_null_create();
      }
      xpc_release(v23);
      xpc_array_append_value(v4, v11);
      xpc_release(v11);
      uint64_t v12 = (void *)v6[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v6[2];
          BOOL v14 = *v13 == (void)v6;
          uint64_t v6 = v13;
        }
        while (!v14);
      }
      uint64_t v6 = v13;
    }
    while (v13 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/transport_master_rat_recommendation_override");
  xpc_object_t v23 = v15;
  if (v15) {
    xpc_retain(v15);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (v18 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
}

void sub_100CE4E8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100CE4F44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE4F84()
{
}

void sub_100CE4F94()
{
}

void *sub_100CE4FA8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A4EF40;
  result[1] = v3;
  return result;
}

uint64_t sub_100CE4FF0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A4EF40;
  a2[1] = v2;
  return result;
}

void sub_100CE501C(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100982DFC(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/critical_activity_on_sim_personality");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100CE50C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100CE5104(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE5144()
{
}

void sub_100CE5154()
{
}

__n128 sub_100CE5168(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4EFC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE51BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4EFC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE51F4(uint64_t *a1, xpc_object_t *a2)
{
  sub_100026EC0(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  xpc_object_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100CE5270(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE52B0()
{
}

void sub_100CE52C0()
{
}

__n128 sub_100CE52D4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F040;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE5328(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F040;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE5360(uint64_t a1, xpc_object_t *a2)
{
  sub_1001F299C(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  xpc_object_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100CE53DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE541C()
{
}

void sub_100CE542C()
{
}

__n128 sub_100CE5440(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F0C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE5494(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F0C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE54CC(uint64_t *a1, xpc_object_t *a2)
{
  sub_100989968(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  xpc_object_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100CE5548(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE5588()
{
}

void sub_100CE5598()
{
}

__n128 sub_100CE55AC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F140;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE5600(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F140;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE5638(void *a1, xpc_object_t *a2)
{
  uint64_t v2 = a1;
  xpc_object_t v3 = *a2;
  uint64_t v4 = a1[1];
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  xpc_object_t v5 = (uint64_t **)(v4 + 8);
  sub_1000346F8(v4, *(void **)(v4 + 8));
  *(void *)uint64_t v4 = v4 + 8;
  *(void *)(v4 + 16) = 0;
  *(void *)(v4 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_object_t object = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    sub_100048BF4(&v28, &object, 0);
    xpc_release(object);
    xpc_object_t object = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    int v25 = v2;
    sub_100048BF4(v27, &object, count);
    xpc_release(object);
    for (uint64_t i = v29; ; uint64_t i = ++v29)
    {
      if (i == v27[1] && v28 == v27[0])
      {
        xpc_release(v28);
        xpc_release(v28);
        uint64_t v2 = v25;
        goto LABEL_54;
      }
      xpc_object_t v26 = 0;
      xpc_object_t object = &v28;
      uint64_t v31 = i;
      sub_10003FBDC((uint64_t)&object, &v26);
      if (xpc_get_type(v26) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_52:
      xpc_release(v26);
    }
    xpc_object_t v8 = v26;
    if (v26)
    {
      xpc_retain(v26);
      xpc_object_t v33 = v8;
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v33 = v8;
      if (!v8)
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v8 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v8);
      xpc_object_t v9 = v33;
      goto LABEL_27;
    }
    xpc_object_t v9 = xpc_null_create();
LABEL_26:
    xpc_object_t v33 = v9;
LABEL_27:
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t object = &v33;
      uint64_t v31 = "first";
      sub_100048BAC((uint64_t)&object, &v32);
      xpc_type_t type = xpc_get_type(v32);
      if (type == (xpc_type_t)&_xpc_type_string)
      {
        int v34 = 0;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v34, (int *)&v32, v13);
        int v11 = v34;
      }
      else if (type == (xpc_type_t)&_xpc_type_BOOL {
             || type == (xpc_type_t)&_xpc_type_int64
      }
             || type == (xpc_type_t)&_xpc_type_uint64)
      {
        int v11 = xpc::dyn_cast_or_default((xpc *)&v32, 0, (uint64_t)v13);
      }
      else
      {
        int v11 = 0;
      }
      xpc_release(v32);
      xpc_object_t object = &v33;
      uint64_t v31 = "second";
      sub_100048BAC((uint64_t)&object, &v32);
      xpc_type_t v14 = xpc_get_type(v32);
      if (v14 == (xpc_type_t)&_xpc_type_string)
      {
        int v34 = 0;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v34, (int *)&v32, v15);
        int v10 = v34;
      }
      else if (v14 == (xpc_type_t)&_xpc_type_BOOL {
             || v14 == (xpc_type_t)&_xpc_type_int64
      }
             || v14 == (xpc_type_t)&_xpc_type_uint64)
      {
        int v10 = xpc::dyn_cast_or_default((xpc *)&v32, 0, (uint64_t)v15);
      }
      else
      {
        int v10 = 0;
      }
      xpc_release(v32);
    }
    else
    {
      int v10 = 0;
      int v11 = 0;
    }
    xpc_release(v33);
    xpc_release(v8);
    uint64_t v16 = *v5;
    uint64_t v17 = (uint64_t **)(v4 + 8);
    char v18 = (uint64_t **)(v4 + 8);
    if (*v5)
    {
      while (1)
      {
        while (1)
        {
          char v18 = (uint64_t **)v16;
          int v19 = *((_DWORD *)v16 + 7);
          if (v19 <= v11) {
            break;
          }
          uint64_t v16 = *v18;
          uint64_t v17 = v18;
          if (!*v18) {
            goto LABEL_51;
          }
        }
        if (v19 >= v11) {
          break;
        }
        uint64_t v16 = v18[1];
        if (!v16)
        {
          uint64_t v17 = v18 + 1;
          goto LABEL_51;
        }
      }
    }
    else
    {
LABEL_51:
      xpc_object_t v20 = (uint64_t *)operator new(0x28uLL);
      *((_DWORD *)v20 + 7) = v11;
      *((_DWORD *)v20 + 8) = v10;
      sub_100046C38((uint64_t **)v4, (uint64_t)v18, v17, v20);
    }
    goto LABEL_52;
  }
LABEL_54:
  xpc_release(v3);
  xpc_object_t v21 = (uint64_t (*)(void *))v2[3];
  uint64_t v22 = v2[4];
  xpc_object_t v23 = (void *)(v2[2] + (v22 >> 1));
  if (v22) {
    xpc_object_t v21 = *(uint64_t (**)(void *))(*v23 + v21);
  }

  return v21(v23);
}

void sub_100CE5A78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, xpc_object_t a12, uint64_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t object, uint64_t a17, xpc_object_t a18, xpc_object_t a19)
{
  xpc_release(object);
  xpc_release(a14);
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100CE5B54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE5B94()
{
}

void sub_100CE5BA4()
{
}

__n128 sub_100CE5BB8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F1C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE5C0C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F1C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE5C44(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned __int8 *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned __int8 v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v7);
    unsigned __int8 *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned __int8 *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  int v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    int v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100CE5D3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE5D7C()
{
}

void sub_100CE5D8C()
{
}

__n128 sub_100CE5DA0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F240;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE5DF4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F240;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE5E2C(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  int v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    int v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100CE5F24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE5F64()
{
}

void sub_100CE5F74()
{
}

__n128 sub_100CE5F88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F2C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE5FDC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F2C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE6014(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  int v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    int v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100CE610C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE614C()
{
}

void sub_100CE615C()
{
}

__n128 sub_100CE6170(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F340;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE61C4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F340;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE61FC(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100CE6298(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE62D8()
{
}

void sub_100CE62E8()
{
}

__n128 sub_100CE62FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F3C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE6350(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F3C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE6388(uint64_t *a1, xpc_object_t *a2)
{
  sub_1002430C8(a1[1], a2);
  xpc_object_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    xpc_object_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100CE6404(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE6444()
{
}

void sub_100CE6454()
{
}

__n128 sub_100CE6468(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F440;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE64BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F440;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE64F4(uint64_t *a1, xpc_object_t *a2)
{
  sub_100026EC0(a1[1], a2);
  xpc_object_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    xpc_object_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100CE6570(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE65B0()
{
}

void sub_100CE65C0()
{
}

__n128 sub_100CE65D4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F4C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE6628(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F4C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100CE6660(void *a1, const xpc::object *a2)
{
  xpc_object_t v3 = (EmergencyMode *)a1[1];
  long long v4 = *(_OWORD *)v3;
  int v9 = *((_DWORD *)v3 + 4);
  long long v8 = v4;
  read_rest_value(v3, a2);
  int v5 = (void (*)(void *, long long *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    int v5 = *(void (**)(void *, long long *))(*v7 + v5);
  }
  v5(v7, &v8);
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v8);
}

void sub_100CE66F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100CE6708(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE6748()
{
}

void sub_100CE6758()
{
}

__n128 sub_100CE676C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A4F540;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100CE67C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F540;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE67F8(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  xpc_object_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100CE6840(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE6880()
{
}

void sub_100CE6890()
{
}

__n128 sub_100CE68A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F5C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE68F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F5C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100CE6930(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  long long v4 = v3 + 1;
  int v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  int v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    std::locale v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100CE69F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100CE6A08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE6A48()
{
}

void sub_100CE6A58()
{
}

__n128 sub_100CE6A6C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F640;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE6AC0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F640;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE6AF8(uint64_t *a1, xpc_object_t *a2)
{
  sub_10003447C(a1[1], a2);
  xpc_object_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    xpc_object_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100CE6B74(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE6BB4()
{
}

void sub_100CE6BC4()
{
}

__n128 sub_100CE6BD8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F6C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE6C2C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F6C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE6C64(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  int v5 = (uint64_t (*)(void *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    int v5 = *(uint64_t (**)(void *))(*v7 + v5);
  }

  return v5(v7);
}

uint64_t sub_100CE6CEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE6D2C()
{
}

void sub_100CE6D3C()
{
}

__n128 sub_100CE6D50(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F740;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE6DA4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F740;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE6DDC(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    int *v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  int v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    int v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100CE6ECC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE6F0C()
{
}

void sub_100CE6F1C()
{
}

__n128 sub_100CE6F30(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A4F7C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100CE6F84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4F7C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100CE6FBC(uint64_t *a1, xpc_object_t *a2)
{
  sub_10003447C(a1[1], a2);
  xpc_object_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    xpc_object_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100CE7038(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE7078()
{
}

unsigned char *sub_100CE7084(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2 + 8;
  *a1 = 0;
  a1[2] = 0;
  a1[1] = 0;
  uint64_t v6 = a1 + 1;
  uint64_t v7 = (char *)operator new(0x40uLL);
  *a1 = v7;
  *uint64_t v6 = v5;
  *((unsigned char *)a1 + 16) = 0;
  __n128 result = v7 + 32;
  if (*(char *)(a3 + 23) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__n128 result = *(_OWORD *)a3;
    *((void *)v7 + 6) = *(void *)(a3 + 16);
  }
  *((void *)v7 + 7) = *(void *)(a3 + 24);
  *((unsigned char *)a1 + 16) = 1;
  return result;
}

void sub_100CE711C(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100CE7138(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = (void **)(a2 + 1);
  uint64_t v5 = (void **)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      xpc_object_t v15 = 0;
      uint64_t v6 = *(void **)(a1 + 8);
      if (*(void **)a1 == v3)
      {
        long long v8 = v3;
        if (!v6) {
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t v7 = v3;
        if (v6)
        {
          do
          {
            long long v8 = v6;
            uint64_t v6 = (void *)v6[1];
          }
          while (v6);
        }
        else
        {
          do
          {
            long long v8 = (void *)v7[2];
            BOOL v9 = *v8 == (void)v7;
            uint64_t v7 = v8;
          }
          while (v9);
        }
        if ((sub_100046FE8(v8 + 4, v5 + 4) & 0x80) == 0)
        {
          uint64_t v10 = (uint64_t **)sub_100046ED4(a1, &v15, v5 + 4);
          goto LABEL_11;
        }
        if (!*v3)
        {
LABEL_14:
          xpc_object_t v15 = v3;
          uint64_t v10 = (uint64_t **)v3;
LABEL_15:
          memset(v14, 0, sizeof(v14));
          sub_100CE72A4(a1, (uint64_t)(v5 + 4), v14);
          sub_100046C38((uint64_t **)a1, (uint64_t)v15, v10, v14[0]);
          goto LABEL_16;
        }
      }
      xpc_object_t v15 = v8;
      uint64_t v10 = (uint64_t **)(v8 + 1);
LABEL_11:
      if (!*v10) {
        goto LABEL_15;
      }
LABEL_16:
      uint64_t v11 = (void **)v5[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void **)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void **)v5[2];
          BOOL v9 = *v12 == v5;
          uint64_t v5 = v12;
        }
        while (!v9);
      }
      uint64_t v5 = v12;
    }
    while (v12 != v4);
  }
  return a1;
}

void sub_100CE728C(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

unsigned char *sub_100CE72A4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  uint64_t v6 = a3 + 1;
  uint64_t v7 = (char *)operator new(0x40uLL);
  *a3 = v7;
  *uint64_t v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = v7 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__n128 result = *(_OWORD *)a2;
    *((void *)v7 + 6) = *(void *)(a2 + 16);
  }
  v7[56] = *(unsigned char *)(a2 + 24);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100CE733C(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100CE7358(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (!sub_100591608((void *)(v2 + 32), (void *)(a1 + 16)))
    {
      uint64_t v3 = v2 + 40;
      sub_10005CD2C(v2 + 32, *(char **)(v2 + 40));
      *(void *)(v2 + 32) = *(void *)(a1 + 16);
      uint64_t v4 = (void *)(a1 + 24);
      uint64_t v5 = *(void *)(a1 + 24);
      *(void *)(v2 + 40) = v5;
      uint64_t v6 = *(void *)(a1 + 32);
      *(void *)(v2 + 48) = v6;
      if (v6)
      {
        *(void *)(v5 + 16) = v3;
        *(void *)(a1 + 16) = v4;
        void *v4 = 0;
        *(void *)(a1 + 32) = 0;
      }
      else
      {
        *(void *)(v2 + 32) = v3;
      }
      uint64_t v7 = *(void *)(v2 + 24);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, v2 + 32);
      }
    }
  }
  sub_10005CD2C(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

BOOL sub_100CE7434(capabilities::ct *a1)
{
  uint64_t v1 = (TransportMasterController *)**((void **)a1 + 5);
  if (!capabilities::ct::supportsGemini(a1)) {
    return 0;
  }
  BOOL RawDynamicCellularDataSwitchState_sync = TransportMasterController::getRawDynamicCellularDataSwitchState_sync(v1);
  uint64_t v3 = *((void *)v1 + 5);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    uint64_t v6 = asStringBool(RawDynamicCellularDataSwitchState_sync);
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I getDynamicCellularDataSwitchingState: user preference: %s", (uint8_t *)&v5, 0xCu);
  }
  return RawDynamicCellularDataSwitchState_sync;
}

uint64_t *sub_100CE74FC(capabilities::ct *a1)
{
  uint64_t v1 = *(void *)a1;
  int v29 = a1;
  uint64_t v30 = v1;
  uint64_t v2 = *(void *)v1;
  if (!capabilities::ct::supportsGemini(a1)) {
    goto LABEL_44;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v2 + 440));
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_10:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12) {
LABEL_11:
  }
    (*(void (**)(uint64_t, void))(*(void *)v12 + 752))(v12, *(unsigned __int8 *)(v1 + 8));
LABEL_12:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  unsigned int v14 = (void **)(v1 + 16);
  if (*(char *)(v1 + 39) < 0)
  {
    unint64_t v15 = *(void *)(v1 + 24);
    if (v15)
    {
      __dst[1] = 0;
      uint64_t v32 = 0;
      __dst[0] = 0;
      sub_10004FC84(__dst, *v14, v15);
      goto LABEL_19;
    }
  }
  else if (*(unsigned char *)(v1 + 39))
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)v14;
    uint64_t v32 = *(void *)(v1 + 32);
LABEL_19:
    uint64_t v16 = (void *)HIBYTE(v32);
    int v17 = SHIBYTE(v32);
    if (v32 < 0) {
      uint64_t v16 = __dst[1];
    }
    if (v16)
    {
      int v18 = *(unsigned __int8 *)(v1 + 8);
      int v19 = sub_100046F68(v2 + 640, __dst);
      if ((void **)(v2 + 648) == v19) {
        goto LABEL_35;
      }
      xpc_object_t v20 = v19;
      uint64_t v21 = (uint64_t)v19[7];
      uint64_t v22 = (std::__shared_weak_count *)v20[8];
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v21)
      {
LABEL_35:
        *(_OWORD *)long long buf = 0u;
        long long v35 = 0u;
        memset(__p, 0, sizeof(__p));
        sub_100CE7A28(buf);
      }
      if (sub_100EE83CC(v21, v18 != 0)) {
        sub_100CE1030(v2);
      }
      if (v22) {
        sub_10004D2C8(v22);
      }
    }
    else
    {
      int v25 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        xpc_object_t v26 = (void **)__dst[0];
        if (v17 >= 0) {
          xpc_object_t v26 = __dst;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v26;
        _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "saveDynamicCellularDataSwitchingState_sync: Invalid personalityId: %s", buf, 0xCu);
      }
    }
    if (SHIBYTE(v32) < 0) {
      operator delete(__dst[0]);
    }
    goto LABEL_44;
  }
  int v23 = DataUtils::otherSimSlot();
  int v24 = *(unsigned __int8 *)(v1 + 8);
  TransportMasterController::getManager_sync(v2, v23, buf);
  if (*(void *)buf)
  {
    if (sub_100EE83CC(*(uint64_t *)buf, v24 != 0)) {
      sub_100CE1030(v2);
    }
  }
  else
  {
    uint64_t v27 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)asStringBool(v24 != 0);
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "setDynamicCellularDataSwitchingState: New user preference: %s is not applicable right now", (uint8_t *)__p, 0xCu);
    }
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
LABEL_44:
  sub_10033CAD4(&v30);
  return sub_100046B58((uint64_t *)&v29);
}

void sub_100CE7974(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23)
{
  uint64_t v25 = a23;
  a23 = 0;
  if (v25) {
    sub_10026CD9C((uint64_t)&a23, v25);
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10033CAD4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100CE7A28(void *a1)
{
  *a1 = off_1019B1C28;
  operator new();
}

void sub_100CE7AE8()
{
}

void sub_100CE7B0C(void ***a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = **a1;
  if (v1[91])
  {
    uint64_t v2 = v1[83];
    uint64_t v3 = v1[84];
    while (v2 != v3)
    {
      if ((*(unsigned int (**)(void))(**(void **)(*(void *)v2 + 80) + 16))(*(void *)(*(void *)v2 + 80)) == 1) {
        goto LABEL_7;
      }
      v2 += 16;
    }
    sub_100CE33CC((uint64_t)v1);
    sub_100CE1030((uint64_t)v1);
  }
LABEL_7:
  sub_100CE1A68((uint64_t)v1);
  operator delete();
}

void sub_100CE7BD0()
{
}

void sub_100CE7C00(uint64_t **a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = **a1;
  sub_100CE1030(v1);
  sub_100CE1A68(v1);
  operator delete();
}

void sub_100CE7C60()
{
}

void sub_100CE7C90()
{
}

void *sub_100CE7CA4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A4F8C0;
  result[1] = v3;
  return result;
}

uint64_t sub_100CE7CEC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A4F8C0;
  a2[1] = v2;
  return result;
}

void sub_100CE7D18(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  sub_100CE33CC(v1);
  sub_100CE1030(v1);

  sub_100CE1A68(v1);
}

uint64_t sub_100CE7D5C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE7D9C()
{
}

void sub_100CE7DAC()
{
}

void *sub_100CE7DC0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A4F940;
  result[1] = v3;
  return result;
}

uint64_t sub_100CE7E08(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A4F940;
  a2[1] = v2;
  return result;
}

void sub_100CE7E34(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 768);
  *(_OWORD *)(v1 + 760) = 0u;
  if (v2) {
    sub_10004D2C8(v2);
  }

  sub_100CE1030(v1);
}

uint64_t sub_100CE7E80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100CE7EC0()
{
}

uint64_t sub_100CE7ECC@<X0>(unsigned char *a1@<X0>, void *a2@<X8>)
{
  uint64_t v20 = 0;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)OsLogContext __p = 0u;
  long long v9 = 0u;
  memset(v7, 0, sizeof(v7));
  long long v6 = 0u;
  sub_10004BD84((uint64_t)&v6);
  if (*(void *)a1)
  {
    sub_10004B96C(v7, (uint64_t)"kDedicatedAPN", 13);
    if ((*a1 & 2) == 0) {
      goto LABEL_7;
    }
    sub_10004B96C(v7, (uint64_t)" ,", 2);
    goto LABEL_6;
  }
  if ((*(void *)a1 & 2) != 0) {
LABEL_6:
  }
    sub_10004B96C(v7, (uint64_t)"kInternet", 9);
LABEL_7:
  sub_10004BC98((uint64_t)v7 + 8, a2);
  *(void *)((char *)&v7[-1]
  *(void *)&v7[0] = v4;
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100CE80B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const void **sub_100CE80D4@<X0>(Registry **a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  void (***v36)(CFDictionaryRef *__return_ptr, void, uint64_t);
  char v37;
  uint64_t (*v38)(uint64_t);
  void *Value;
  void *v40;
  CFTypeID v41;
  void *v42;
  void *v43;
  CFTypeID v44;
  CFDictionaryRef v45;
  void *v46;
  CFDictionaryRef v47;
  CFDictionaryRef v48;
  void *v49;
  std::__shared_weak_count *v50;
  std::mutex *v51;
  std::mutex *v52;
  unsigned __int8 *v53;
  uint64_t v54;
  unsigned int v55;
  void *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;
  char v59;
  uint64_t (*v60)(uint64_t);
  void *__p;
  void *v63;
  void *v64;
  const void *v65;
  CFDictionaryRef v66;
  CFDictionaryRef theDict;
  std::__shared_weak_count *v68;
  CFDictionaryRef v69;
  CFDictionaryRef v70;
  CFDictionaryRef v71;

  unint64_t v69 = 0;
  long long v70 = 0;
  int v6 = *(unsigned __int8 *)(**(void **)a2 + 49);
  if (!*(unsigned char *)(**(void **)a2 + 49))
  {
    if (sub_1000BE198(@"kCTCarrierEntitlements")) {
      goto LABEL_64;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    long long v18 = ServiceMap;
    uint64_t v20 = (void *)v19;
    if (v19 < 0)
    {
      uint64_t v21 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        uint64_t v20 = (void *)v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(ServiceMap);
    OsLogContext __p = v20;
    int v24 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&__p);
    if (v24)
    {
      uint64_t v26 = v24[3];
      uint64_t v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
        goto LABEL_51;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v25 = 0;
    char v27 = 1;
LABEL_51:
    (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v26 + 96))(&v71, v26, *(unsigned int *)(**(void **)a2 + 52), 1, @"CarrierEntitlements", 0, 0);
    sub_10004EFE4(&theDict, (CFTypeRef *)&v71);
    OsLogContext __p = v70;
    long long v70 = theDict;
    CFDictionaryRef theDict = 0;
    sub_100057D78((const void **)&__p);
    sub_100057D78((const void **)&theDict);
    sub_1000577C4((const void **)&v71);
    if ((v27 & 1) == 0) {
      sub_10004D2C8(v25);
    }
    BOOL v51 = (std::mutex *)Registry::getServiceMap(*a1);
    uint64_t v52 = v51;
    if (v19 < 0)
    {
      int v53 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v54 = 5381;
      do
      {
        uint64_t v19 = v54;
        int v55 = *v53++;
        uint64_t v54 = (33 * v54) ^ v55;
      }
      while (v55);
    }
    std::mutex::lock(v51);
    OsLogContext __p = (void *)v19;
    char v56 = sub_10004D37C(&v52[1].__m_.__sig, (unint64_t *)&__p);
    if (v56)
    {
      long long v58 = v56[3];
      uint64_t v57 = (std::__shared_weak_count *)v56[4];
      if (v57)
      {
        atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v52);
        atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v57);
        char v59 = 0;
LABEL_61:
        (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v58 + 96))(&v71, v58, *(unsigned int *)(**(void **)a2 + 52), 1, @"PushSettings", 0, 0);
        sub_10004EFE4(&theDict, (CFTypeRef *)&v71);
        OsLogContext __p = v69;
        unint64_t v69 = theDict;
        CFDictionaryRef theDict = 0;
        sub_100057D78((const void **)&__p);
        sub_100057D78((const void **)&theDict);
        sub_1000577C4((const void **)&v71);
        if (v59) {
          goto LABEL_64;
        }
        char v50 = v57;
        goto LABEL_63;
      }
    }
    else
    {
      long long v58 = 0;
    }
    std::mutex::unlock(v52);
    uint64_t v57 = 0;
    char v59 = 1;
    goto LABEL_61;
  }
  if (v6 != 1)
  {
    if (v6 != 2) {
      goto LABEL_64;
    }
    CFDictionaryRef theDict = 0;
    uint64_t v7 = (std::mutex *)Registry::getServiceMap(*a1);
    uint64_t v8 = v7;
    if (v9 < 0)
    {
      long long v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(v7);
    OsLogContext __p = (void *)v9;
    long long v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&__p);
    if (v13)
    {
      uint64_t v15 = v13[3];
      long long v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_25:
        (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, uint64_t))(*(void *)v15 + 112))(&theDict, v15, **(void **)a2 + 24);
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        if (theDict) {
          uint64_t v38 = sub_100080778;
        }
        else {
          uint64_t v38 = 0;
        }
        if (v38)
        {
          CFTypeRef Value = (void *)CFDictionaryGetValue(theDict, @"CarrierEntitlements");
          uint32_t v40 = Value;
          if (Value)
          {
            uint64_t v41 = CFGetTypeID(Value);
            if (v41 == CFDictionaryGetTypeID())
            {
              OsLogContext __p = v40;
              sub_100282490((const void **)&v70, (CFTypeRef *)&__p);
            }
          }
          int v42 = (void *)CFDictionaryGetValue(theDict, @"PushSettings");
          BOOL v43 = v42;
          if (v42)
          {
            int v44 = CFGetTypeID(v42);
            if (v44 == CFDictionaryGetTypeID())
            {
              OsLogContext __p = v43;
              sub_100282490((const void **)&v69, (CFTypeRef *)&__p);
            }
          }
        }
        sub_100057D78((const void **)&theDict);
        goto LABEL_64;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    long long v14 = 0;
    char v16 = 1;
    goto LABEL_25;
  }
  CFDictionaryRef theDict = 0;
  long long v68 = 0;
  xpc_object_t v28 = (std::mutex *)Registry::getServiceMap(*a1);
  int v29 = v28;
  if (v30 < 0)
  {
    uint64_t v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v32 = 5381;
    do
    {
      uint64_t v30 = v32;
      unsigned int v33 = *v31++;
      uint64_t v32 = (33 * v32) ^ v33;
    }
    while (v33);
  }
  std::mutex::lock(v28);
  OsLogContext __p = (void *)v30;
  int v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)&__p);
  if (v34)
  {
    char v36 = (void (***)(CFDictionaryRef *__return_ptr, void, uint64_t))v34[3];
    long long v35 = (std::__shared_weak_count *)v34[4];
    if (v35)
    {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v29);
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v35);
      uint64_t v37 = 0;
      goto LABEL_40;
    }
  }
  else
  {
    char v36 = 0;
  }
  std::mutex::unlock(v29);
  long long v35 = 0;
  uint64_t v37 = 1;
LABEL_40:
  (**v36)(&theDict, v36, **(void **)a2 + 24);
  if ((v37 & 1) == 0) {
    sub_10004D2C8(v35);
  }
  int v45 = theDict;
  if (theDict)
  {
    int v46 = operator new(8uLL);
    OsLogContext __p = v46;
    *int v46 = @"CarrierEntitlements";
    int v63 = v46 + 1;
    uint64_t v64 = v46 + 1;
    (*(void (**)(const void **__return_ptr, CFDictionaryRef, void **, void))(*(void *)v45 + 120))(&v65, v45, &__p, 0);
    sub_10004EFE4(&v66, &v65);
    uint64_t v47 = v70;
    long long v70 = v66;
    uint64_t v71 = v47;
    uint64_t v66 = 0;
    sub_100057D78((const void **)&v71);
    sub_100057D78((const void **)&v66);
    sub_1000577C4(&v65);
    if (__p)
    {
      int v63 = __p;
      operator delete(__p);
    }
    uint64_t v48 = theDict;
    uint64_t v49 = operator new(8uLL);
    OsLogContext __p = v49;
    *uint64_t v49 = @"PushSettings";
    int v63 = v49 + 1;
    uint64_t v64 = v49 + 1;
    (*(void (**)(const void **__return_ptr, CFDictionaryRef, void **, void))(*(void *)v48 + 120))(&v65, v48, &__p, 0);
    sub_10004EFE4(&v66, &v65);
    uint64_t v71 = v69;
    unint64_t v69 = v66;
    uint64_t v66 = 0;
    sub_100057D78((const void **)&v71);
    sub_100057D78((const void **)&v66);
    sub_1000577C4(&v65);
    if (__p)
    {
      int v63 = __p;
      operator delete(__p);
    }
  }
  char v50 = v68;
  if (v68) {
LABEL_63:
  }
    sub_10004D2C8(v50);
LABEL_64:
  if (v70) {
    uint64_t v60 = sub_100080778;
  }
  else {
    uint64_t v60 = 0;
  }
  if (v60)
  {
    sub_100CE888C(v70, a3);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  sub_100057D78((const void **)&v69);
  return sub_100057D78((const void **)&v70);
}

void sub_100CE87B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, const void *a14, uint64_t a15, const void *a16, const void *a17, __int16 a18, char a19, char a20)
{
}

void sub_100CE888C(CFDictionaryRef theDict@<X1>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (theDict)
  {
    CFTypeRef Value = CFDictionaryGetValue(theDict, @"ExtraEndPoints");
    if (Value)
    {
      CFTypeID v4 = CFGetTypeID(Value);
      if (v4 == CFArrayGetTypeID())
      {
        CFDictionaryCreateMutableCopy(0, 0, theDict);
        operator new();
      }
    }
    operator new();
  }
}

void sub_100CE90B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, const void *a17, void **a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  sub_10005717C((const void **)&a18);
  a18 = a10;
  sub_10005CBF0(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_100CE9234(char **a1, long long *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = (v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v12 = v5 - (void)*a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    uint64_t v26 = result;
    long long v14 = (char *)sub_10006A794(result, v13);
    char v16 = &v14[16 * v10];
    long long v17 = *a2;
    *(_OWORD *)char v16 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v16 + 16;
    uint64_t v19 = *a1;
    long long v18 = a1[1];
    if (v18 == *a1)
    {
      int64x2_t v21 = vdupq_n_s64((unint64_t)v18);
    }
    else
    {
      do
      {
        long long v20 = *((_OWORD *)v18 - 1);
        v18 -= 16;
        *((_OWORD *)v16 - 1) = v20;
        v16 -= 16;
        *(void *)long long v18 = 0;
        *((void *)v18 + 1) = 0;
      }
      while (v18 != v19);
      int64x2_t v21 = *(int64x2_t *)a1;
    }
    *a1 = v16;
    a1[1] = v9;
    int64x2_t v24 = v21;
    uint64_t v22 = a1[2];
    a1[2] = &v14[16 * v15];
    uint64_t v25 = v22;
    uint64_t v23 = v21.i64[0];
    uint64_t result = sub_10019E528((uint64_t)&v23);
  }
  else
  {
    *(void *)uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    *((void *)v7 + 1) = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 16;
  }
  a1[1] = v9;
  return result;
}

void sub_100CE9360(void *a1, __CFDictionary *a2, CFDictionaryRef theDict)
{
  CFIndex Count = CFDictionaryGetCount(theDict);
  keys = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10004EE3C(&keys, Count);
  values = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10004EE3C(&values, Count);
  CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
  if (Count)
  {
    for (uint64_t i = 0; i != Count; ++i)
      CFDictionarySetValue(a2, keys[i], values[i]);
  }
  sub_100C3EE4C(a1, a2);
  if (values)
  {
    uint64_t v9 = values;
    operator delete(values);
  }
  if (keys)
  {
    uint64_t v12 = keys;
    operator delete(keys);
  }
}

void sub_100CE9434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CE946C(CFDictionaryRef theDict@<X0>, unsigned int a2@<W2>, void *a3@<X8>)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_100CE888C(theDict, &v8);
  unint64_t v5 = v8;
  if (v8 == v9)
  {
LABEL_5:
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    if (a2 > 0xC) {
      sub_1000C14F0("bitset test argument out of range");
    }
    while (1)
    {
      uint64_t v6 = *v5;
      if ((*(void *)(*v5 + 80) & (1 << a2)) != 0) {
        break;
      }
      v5 += 2;
      if (v5 == v9) {
        goto LABEL_5;
      }
    }
    uint64_t v7 = v5[1];
    *a3 = v6;
    a3[1] = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
  }
  unint64_t v11 = (void **)&v8;
  sub_10005CBF0(&v11);
}

void sub_100CE9538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10005CBF0(&a12);
  _Unwind_Resume(a1);
}

int *sub_100CE9554(uint64_t a1)
{
  uint64_t result = (int *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"SupportedEntitlements");
  int v5 = 0;
  if (result)
  {
    uint64_t v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v5, v2, v4);
      return (int *)(v5 & 0x3FFFFFLL);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100CE95C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef cf, const void *a6, char a7, long long *a8, int a9)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 16) = a7;
  if (*((char *)a8 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *(void **)a8, *((void *)a8 + 1));
  }
  else
  {
    long long v13 = *a8;
    *(void *)(a1 + 40) = *((void *)a8 + 2);
    *(_OWORD *)(a1 + 24) = v13;
  }
  *(_DWORD *)(a1 + 48) = a9;
  *(void *)(a1 + 56) = a4;
  sub_10004EFAC((void *)(a1 + 64), cf);
  sub_10004EFAC((void *)(a1 + 72), a6);
  *(void *)(a1 + 80) = 0;
  if (*(unsigned char *)(a1 + 16))
  {
    *(void *)(a1 + 88) = 0;
LABEL_22:
    uint64_t v26 = 2;
    goto LABEL_23;
  }
  long long v14 = sub_100CE9554(a1);
  uint64_t v15 = sub_100022E58();
  uint64_t v18 = *v15;
  char v16 = v15 + 1;
  long long v17 = (void *)v18;
  if ((uint64_t *)v18 == v16)
  {
    uint64_t v19 = 0;
  }
  else
  {
    uint64_t v19 = 0;
    do
    {
      unsigned int v20 = *((_DWORD *)v17 + 7);
      if (v20 >= 0x16) {
        sub_1000C14F0("bitset test argument out of range");
      }
      uint64_t v21 = 1 << v20;
      if ((v21 & (unint64_t)v14) == 0) {
        uint64_t v21 = 0;
      }
      uint64_t v22 = (uint64_t *)v17[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          uint64_t v22 = (uint64_t *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (uint64_t *)v17[2];
          BOOL v24 = *v23 == (void)v17;
          long long v17 = v23;
        }
        while (!v24);
      }
      v19 |= v21;
      long long v17 = v23;
    }
    while (v23 != v16);
  }
  int v25 = *(unsigned __int8 *)(a1 + 16);
  *(void *)(a1 + 88) = v19;
  if (v25) {
    goto LABEL_22;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"AllowedConnectivityOnly");
  CFStringRef v29 = Value;
  if (Value)
  {
    CFTypeID v30 = CFGetTypeID(Value);
    if (v30 == CFStringGetTypeID())
    {
      if (CFStringCompare(v29, @"DedicatedAPN", 1uLL) == kCFCompareEqualTo)
      {
        uint64_t v26 = 1;
        goto LABEL_23;
      }
      if (CFStringCompare(v29, @"Internet", 1uLL) == kCFCompareEqualTo) {
        goto LABEL_22;
      }
      os_log_t oslog = 0;
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, kCtLoggingSystemName, "ent.set");
      ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, &buf);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      uint64_t v31 = oslog;
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.var0) = 138412290;
        *(char **)((char *)&buf.var0 + 4) = (char *)v29;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#E Unknown value '%@' in CB key 'AllowedConnectivityOnly'", (uint8_t *)&buf, 0xCu);
      }
      ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
    }
  }
  os_log_t oslog = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  unsigned int v33 = ServiceMap;
  if (v34 < 0)
  {
    long long v35 = (unsigned __int8 *)(v34 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v36 = 5381;
    do
    {
      uint64_t v34 = v36;
      unsigned int v37 = *v35++;
      uint64_t v36 = (33 * v36) ^ v37;
    }
    while (v37);
  }
  std::mutex::lock(ServiceMap);
  buf.var0 = (char *)v34;
  uint64_t v38 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)&buf);
  if (!v38)
  {
    uint64_t v40 = 0;
    goto LABEL_38;
  }
  uint64_t v40 = v38[3];
  int v39 = (std::__shared_weak_count *)v38[4];
  if (!v39)
  {
LABEL_38:
    std::mutex::unlock(v33);
    int v39 = 0;
    char v41 = 1;
    goto LABEL_39;
  }
  atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v33);
  atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v39);
  char v41 = 0;
LABEL_39:
  (*(void (**)(os_log_t *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v40 + 96))(&oslog, v40, *(unsigned int *)(a1 + 48), 1, @"AllowedServicesTypeMaskOnInternet", 0, 0);
  if ((v41 & 1) == 0) {
    sub_10004D2C8(v39);
  }
  int v42 = (unint64_t *)oslog;
  buf.var0 = 0;
  if (oslog && (CFTypeID v43 = CFGetTypeID(oslog), v43 == CFNumberGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&buf, v42, v44);
    if ((BYTE1(buf.var0) & 0x80) != 0) {
      uint64_t v26 = 3;
    }
    else {
      uint64_t v26 = 1;
    }
  }
  else
  {
    uint64_t v26 = 1;
  }
  sub_1000577C4((const void **)&oslog);
LABEL_23:
  *(void *)(a1 + 96) = v26;
  return a1;
}

void sub_100CE999C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  sub_100057D78(v6);
  sub_100057D78(v5);
  if (*(char *)(v3 + 47) < 0) {
    operator delete(*v4);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(v3 + 8);
  if (v8) {
    sub_10004D2C8(v8);
  }
  _Unwind_Resume(a1);
}

void sub_100CE9A24(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  char v27 = (void *)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v27);
  if (!v10)
  {
    std::mutex::unlock(v5);
    long long v13 = 0;
    LODWORD(v12) = 0;
    goto LABEL_25;
  }
  uint64_t v12 = v10[3];
  unint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v5);
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
    if (!v12)
    {
      long long v13 = 0;
LABEL_24:
      sub_10004D2C8(v11);
      goto LABEL_25;
    }
  }
  else
  {
    std::mutex::unlock(v5);
    if (!v12)
    {
      long long v13 = 0;
      goto LABEL_25;
    }
  }
  int v25 = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, void, void, void, uint64_t))(*(void *)v12 + 24))(&cf, v12, a1 + 24, kEntitlementsServerAddress, kCarrierEntitlementsWalletDomain, 0, 1);
  *(void *)CFStringRef v29 = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v26 = 0;
  char v27 = 0;
  sub_100056248(&v27, (CFTypeRef *)v29);
  if (v27) {
    long long v14 = sub_1000810B8;
  }
  else {
    long long v14 = 0;
  }
  if (v14) {
    sub_100083EB8(&v26, (const void **)&v27);
  }
  sub_1000558F4((const void **)&v27);
  uint64_t v15 = v26;
  int v25 = v26;
  uint64_t v26 = 0;
  sub_1000558F4(&v26);
  sub_1000577C4((const void **)v29);
  sub_1000577C4(&cf);
  if (v15) {
    char v16 = sub_1000810B8;
  }
  else {
    char v16 = 0;
  }
  if (v16)
  {
    char v27 = 0;
    long long v28 = 0uLL;
    ctu::cf::assign();
    long long v13 = v27;
    uint64_t v17 = v28;
    uint64_t v18 = *(void *)((char *)&v28 + 7);
    *(void *)a2 = v27;
    *(void *)(a2 + 8) = v17;
    *(void *)(a2 + 15) = v18;
    LODWORD(v12) = HIBYTE(v28);
    *(unsigned char *)(a2 + 23) = HIBYTE(v28);
  }
  else
  {
    long long v13 = 0;
    LODWORD(v12) = 0;
  }
  sub_1000558F4(&v25);
  if (v11) {
    goto LABEL_24;
  }
LABEL_25:
  if ((v12 & 0x80u) == 0) {
    uint64_t v19 = v12;
  }
  else {
    uint64_t v19 = *(void *)(a2 + 8);
  }
  if (!v19)
  {
    CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"ServerAddress");
    if (Value)
    {
      CFTypeID v21 = CFGetTypeID(Value);
      if (v21 == CFStringGetTypeID())
      {
        char v27 = 0;
        long long v28 = 0uLL;
        ctu::cf::assign();
        uint64_t v22 = v27;
        *(void *)CFStringRef v29 = v28;
        *(void *)&v29[7] = *(void *)((char *)&v28 + 7);
        char v23 = HIBYTE(v28);
        if ((v12 & 0x80) != 0) {
          operator delete(v13);
        }
        *(void *)a2 = v22;
        *(void *)(a2 + 8) = *(void *)v29;
        *(void *)(a2 + 15) = *(void *)&v29[7];
        *(unsigned char *)(a2 + 23) = v23;
      }
    }
  }
}

void sub_100CE9D18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (v26 < 0) {
    operator delete(v25);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100CE9DBC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = (const void **)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"TLSTrustedCACertificates");
  if (result
    && (CFArrayRef v4 = (const __CFArray *)result,
        CFTypeID v5 = CFGetTypeID(result),
        uint64_t result = (const void **)CFArrayGetTypeID(),
        (const void **)v5 == result))
  {
    *(void *)CFTypeID v21 = 0;
    CFIndex Count = CFArrayGetCount(v4);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, Count, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      uint64_t v8 = *(__CFArray **)v21;
      *(void *)CFTypeID v21 = Mutable;
      *(void *)&long long v26 = v8;
      sub_1000440D4((const void **)&v26);
    }
    for (CFIndex i = 0; i < CFArrayGetCount(v4); ++i)
    {
      v19[0] = 0;
      v19[1] = 0;
      uint64_t v20 = 0;
      CFArrayGetValueAtIndex(v4, i);
      long long v26 = 0uLL;
      uint64_t v27 = 0;
      ctu::cf::assign();
      *(_OWORD *)uint64_t v19 = v26;
      uint64_t v20 = v27;
      char v16 = 0;
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      ctu::base64::decode();
      CFTypeRef cf = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      OsLogContext __p = 0;
      sub_10005C928(&__p, v16, (uint64_t)v17, v17 - (unsigned char *)v16);
      BOOL v24 = 0;
      uint64_t v25 = 0;
      char v23 = 0;
      sub_10005C928(&v23, __p, (uint64_t)v12, v12 - (unsigned char *)__p);
      CFDataRef v22 = 0;
      long long v26 = 0uLL;
      uint64_t v27 = 0;
      sub_10005C928(&v26, v23, (uint64_t)v24, v24 - (unsigned char *)v23);
      CFDataRef v28 = 0;
      if (ctu::cf::convert_copy())
      {
        CFDataRef v10 = v22;
        CFDataRef v22 = v28;
        CFDataRef v29 = v10;
        sub_100030068((const void **)&v29);
      }
      if ((void)v26)
      {
        *((void *)&v26 + 1) = v26;
        operator delete((void *)v26);
      }
      CFDataRef data = v22;
      CFDataRef v22 = 0;
      sub_100030068((const void **)&v22);
      if (v23)
      {
        BOOL v24 = v23;
        operator delete(v23);
      }
      CFTypeRef cf = SecCertificateCreateWithData(0, data);
      sub_100030068((const void **)&data);
      if (__p)
      {
        uint64_t v12 = __p;
        operator delete(__p);
      }
      sub_10057011C(*(__CFArray **)v21, cf);
      sub_100120040(&cf);
      if (v16)
      {
        uint64_t v17 = v16;
        operator delete(v16);
      }
      if (SHIBYTE(v20) < 0) {
        operator delete(v19[0]);
      }
    }
    sub_100044D6C(a2, (CFTypeRef *)v21);
    return sub_1000440D4((const void **)v21);
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void sub_100CE9FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,const void *a27,__int16 a28,char a29,char a30)
{
}

void sub_100CEA0C0(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  if (sub_10121F67C() || sub_10121F6B4())
  {
    *(void *)char v16 = 0;
    DevicePersistentCopyValue((uint64_t *)&v14, kTestUseLoopback, 0);
    sub_100056248(v16, (CFTypeRef *)&v14);
    sub_1000577C4((const void **)&v14);
    if (*(void *)v16) {
      CFArrayRef v4 = sub_1000810B8;
    }
    else {
      CFArrayRef v4 = 0;
    }
    if (v4)
    {
      long long v14 = 0;
      long long v15 = 0uLL;
      ctu::cf::assign();
      uint64_t v6 = v14;
      uint64_t v5 = v15;
      uint64_t v7 = *(void *)((char *)&v15 + 7);
      *(void *)a2 = v14;
      *(void *)(a2 + 8) = v5;
      *(void *)(a2 + 15) = v7;
      unsigned int v8 = HIBYTE(v15);
      *(unsigned char *)(a2 + 23) = HIBYTE(v15);
      uint64_t v9 = *(void *)(a2 + 8);
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t v6 = 0;
      unsigned int v8 = 0;
    }
    sub_1000558F4((const void **)v16);
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v9 = 0;
    unsigned int v8 = 0;
  }
  if ((v8 & 0x80u) == 0) {
    uint64_t v10 = v8;
  }
  else {
    uint64_t v10 = v9;
  }
  if (!v10)
  {
    CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"BindingInterface");
    if (Value)
    {
      CFGetTypeID(Value);
      CFStringGetTypeID();
    }
    long long v14 = 0;
    long long v15 = 0uLL;
    ctu::cf::assign();
    uint64_t v12 = v14;
    *(void *)char v16 = v15;
    *(void *)&v16[7] = *(void *)((char *)&v15 + 7);
    char v13 = HIBYTE(v15);
    if ((v8 & 0x80) != 0) {
      operator delete(v6);
    }
    *(void *)a2 = v12;
    *(void *)(a2 + 8) = *(void *)v16;
    *(void *)(a2 + 15) = *(void *)&v16[7];
    *(unsigned char *)(a2 + 23) = v13;
  }
}

void sub_100CEA27C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v16 < 0) {
    operator delete(v15);
  }
  _Unwind_Resume(exception_object);
}

BOOL *sub_100CEA2E4(uint64_t a1)
{
  uint64_t result = (BOOL *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"SendSelfRegistrationUpdate");
  if (result)
  {
    uint64_t v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFBooleanGetTypeID())
    {
      char v5 = 0;
      ctu::cf::assign((ctu::cf *)&v5, v2, v4);
      return (BOOL *)(v5 != 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const void **sub_100CEA358@<X0>(const void **result@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  if (!*((unsigned char *)result + 16))
  {
    CFTypeRef Value = CFDictionaryGetValue((CFDictionaryRef)result[8], @"Authentication");
    CFBooleanRef v4 = 0;
    sub_10004EFE4(&v4, &Value);
    *a2 = v4;
    CFBooleanRef v4 = 0;
    return sub_100057D78(&v4);
  }
  return result;
}

void sub_100CEA3C0(_Unwind_Exception *a1)
{
  sub_100057D78(v1);
  _Unwind_Resume(a1);
}

unint64_t *sub_100CEA3D4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  uint64_t result = (unint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"SupportedAuthorizationTokens");
  if (result)
  {
    uint64_t v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFNumberGetTypeID())
    {
      uint64_t v5 = 0;
      ctu::cf::assign((ctu::cf *)&v5, v2, v4);
      return (unint64_t *)(v5 & 1);
    }
    return 0;
  }
  return result;
}

BOOL *sub_100CEA44C(uint64_t a1)
{
  uint64_t result = (BOOL *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"EnableDeviceAccountIdentifier");
  if (result)
  {
    uint64_t v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFBooleanGetTypeID())
    {
      char v5 = 0;
      ctu::cf::assign((ctu::cf *)&v5, v2, v4);
      return (BOOL *)(v5 != 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100CEA4C0(uint64_t a1)
{
  CFTypeRef Value = (int *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"UpdatePeriod");
  if (!Value) {
    return 1440;
  }
  uint64_t v2 = Value;
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 != CFNumberGetTypeID()) {
    return 1440;
  }
  int v6 = 0;
  if (ctu::cf::assign((ctu::cf *)&v6, v2, v4)) {
    return 60 * v6;
  }
  else {
    return 1440;
  }
}

uint64_t sub_100CEA540(uint64_t a1)
{
  CFTypeRef Value = (int *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"PseudonymUpdatePeriod");
  if (!Value) {
    return 4320;
  }
  uint64_t v2 = Value;
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 != CFNumberGetTypeID()) {
    return 4320;
  }
  int v6 = 0;
  if (ctu::cf::assign((ctu::cf *)&v6, v2, v4)) {
    return 60 * v6;
  }
  else {
    return 4320;
  }
}

uint64_t *sub_100CEA5C0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = (uint64_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"ProvisioningRecheckPeriod");
  if (result)
  {
    CFNumberRef v4 = result;
    CFTypeID v5 = CFGetTypeID(result);
    if (v5 == CFNumberGetTypeID())
    {
      uint64_t v9 = 2;
      uint64_t result = (uint64_t *)ctu::cf::assign((ctu::cf *)&v9, v4, v6);
      unint64_t v7 = v9 & 0xFFFFFFFFFFFFFF00;
      uint64_t v8 = v9;
      if (!result)
      {
        unint64_t v7 = 0;
        uint64_t v8 = 0;
      }
    }
    else
    {
      uint64_t v8 = 0;
      unint64_t v7 = 0;
      uint64_t result = 0;
    }
  }
  else
  {
    uint64_t v8 = 0;
    unint64_t v7 = 0;
  }
  *(void *)a2 = v7 | v8;
  *(unsigned char *)(a2 + 8) = (_BYTE)result;
  *(_DWORD *)(a2 + 9) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(void *)(a2 + 16) = 2;
  return result;
}

void sub_100CEA680(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  CFTypeRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"UserAgent");
  if (Value)
  {
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFStringGetTypeID())
    {
      ctu::cf::assign();
      if (*(char *)(a2 + 23) < 0) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 15) = 0;
      *(unsigned char *)(a2 + 23) = 0;
    }
  }
}

void sub_100CEB5C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (*(char *)(v23 - 121) < 0) {
    operator delete(*(void **)(v23 - 144));
  }
  sub_100057D78((const void **)(v23 - 176));
  if (*(char *)(v22 + 23) < 0) {
    operator delete(*(void **)v22);
  }
  _Unwind_Resume(a1);
}

void sub_100CEB718(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  sub_100058DB0((void *)a2, "1");
  CFTypeRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"ProtocolVersion");
  if (Value)
  {
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFStringGetTypeID())
    {
      ctu::cf::assign();
      if (*(char *)(a2 + 23) < 0) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 15) = 0;
      *(unsigned char *)(a2 + 23) = 0;
    }
  }
}

void sub_100CEB80C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v14 + 23) < 0) {
    operator delete(*(void **)v14);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100CEB840(uint64_t a1)
{
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"AllowCurrentLocation");
  if (!Value) {
    return 0;
  }
  CFBooleanRef v2 = Value;
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 != CFBooleanGetTypeID() || CFBooleanGetValue(v2) != 1) {
    return 0;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12B10, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101B12B10))
    {
      sub_100E8C994(&qword_101B12B08);
      __cxa_atexit((void (*)(void *))LocationInterface::~LocationInterface, &qword_101B12B08, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B12B10);
    }
  }
  return (sub_100E8CB10() & 1) != 0;
}

void sub_100CEB910(_Unwind_Exception *a1)
{
}

void *sub_100CEB928@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"AllowedIMSIPrefixes");
  if (Value)
  {
    CFTypeID v4 = Value;
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFArrayGetTypeID()) {
      CFNumberRef v6 = v4;
    }
    else {
      CFNumberRef v6 = 0;
    }
  }
  else
  {
    CFNumberRef v6 = 0;
  }

  return sub_100044D34(a2, v6);
}

int *sub_100CEB998(uint64_t a1)
{
  uint64_t result = (int *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"Timeout");
  unsigned int v5 = 0;
  if (result)
  {
    CFBooleanRef v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v5, v2, v4);
      return (int *)v5;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100CEBA04(uint64_t a1)
{
  CFBooleanRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"FailureDelay");
  uint64_t result = 80;
  unsigned int v5 = 80;
  if (Value)
  {
    CFTypeID v3 = CFGetTypeID(Value);
    if (v3 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v5, (int *)Value, v4);
      return v5;
    }
    else
    {
      return 80;
    }
  }
  return result;
}

uint64_t sub_100CEBA78(uint64_t a1)
{
  CFBooleanRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"TempFailureBackoffDelay");
  uint64_t result = 80;
  unsigned int v5 = 80;
  if (Value)
  {
    CFTypeID v3 = CFGetTypeID(Value);
    if (v3 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v5, (int *)Value, v4);
      return v5;
    }
    else
    {
      return 80;
    }
  }
  return result;
}

uint64_t sub_100CEBAEC(uint64_t a1)
{
  CFBooleanRef Value = (BOOL *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"InvalidateSimForUnknownSubscriber");
  if (Value)
  {
    CFTypeID v3 = Value;
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFBooleanGetTypeID()) {
      unsigned int v5 = v3;
    }
    else {
      unsigned int v5 = 0;
    }
  }
  else
  {
    unsigned int v5 = 0;
  }
  unsigned __int8 v7 = 0;
  ctu::cf::assign((ctu::cf *)&v7, v5, v2);
  return v7;
}

uint64_t sub_100CEBB54(uint64_t a1)
{
  CFBooleanRef Value = (BOOL *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"SupportSecureIntent");
  if (Value)
  {
    CFTypeID v3 = Value;
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFBooleanGetTypeID()) {
      unsigned int v5 = v3;
    }
    else {
      unsigned int v5 = 0;
    }
  }
  else
  {
    unsigned int v5 = 0;
  }
  unsigned __int8 v7 = 0;
  ctu::cf::assign((ctu::cf *)&v7, v5, v2);
  return v7;
}

BOOL sub_100CEBBBC(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  CFBooleanRef Value = (BOOL *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), a2);
  if (Value && (unsigned __int8 v7 = Value, v8 = CFGetTypeID(Value), v8 == CFBooleanGetTypeID()))
  {
    char v20 = 0;
    ctu::cf::assign((ctu::cf *)&v20, v7, v9);
    return v20 != 0;
  }
  else
  {
    CFArrayRef v10 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), @"SupportedActions");
    if (v10)
    {
      CFArrayRef v11 = v10;
      CFTypeID v12 = CFGetTypeID(v10);
      if (v12 == CFArrayGetTypeID())
      {
        CFIndex Count = CFArrayGetCount(v11);
        if (Count)
        {
          CFIndex v14 = Count;
          CFIndex v15 = 0;
          while (1)
          {
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v11, v15);
            if (ValueAtIndex)
            {
              CFStringRef v17 = ValueAtIndex;
              CFTypeID v18 = CFGetTypeID(ValueAtIndex);
              if (v18 == CFStringGetTypeID() && CFStringCompare(a2, v17, 1uLL) == kCFCompareEqualTo) {
                break;
              }
            }
            if (v14 == ++v15) {
              return a3;
            }
          }
          return 1;
        }
      }
    }
  }
  return a3;
}

const void **sub_100CEBCDC@<X0>(uint64_t a1@<X0>, const void **a2@<X8>)
{
  *a2 = 0;
  uint64_t result = *(const void ***)(a1 + 72);
  if (result) {
    CFTypeID v4 = sub_100080778;
  }
  else {
    CFTypeID v4 = 0;
  }
  if (v4)
  {
    CFBooleanRef Value = CFDictionaryGetValue((CFDictionaryRef)result, @"Topic");
    CFNumberRef v6 = Value;
    if (Value)
    {
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFStringGetTypeID()) {
        CFTypeID v8 = v6;
      }
      else {
        CFTypeID v8 = 0;
      }
    }
    else
    {
      CFTypeID v8 = 0;
    }
    CFTypeRef v9 = v8;
    return sub_100013168(a2, &v9);
  }
  return result;
}

void sub_100CEBD74(_Unwind_Exception *a1)
{
  sub_1000558F4(v1);
  _Unwind_Resume(a1);
}

const void **sub_100CEBD88@<X0>(uint64_t a1@<X0>, int a2@<W1>, const void **a3@<X8>)
{
  *a3 = 0;
  uint64_t result = *(const void ***)(a1 + 72);
  if (result) {
    unsigned int v5 = sub_100080778;
  }
  else {
    unsigned int v5 = 0;
  }
  if (v5)
  {
    if ((a2 - 1) > 9) {
      CFStringRef v6 = &stru_101AC1B28;
    }
    else {
      CFStringRef v6 = off_101A4FAC0[a2 - 1];
    }
    CFBooleanRef Value = CFDictionaryGetValue((CFDictionaryRef)result, v6);
    CFTypeID v8 = Value;
    if (Value)
    {
      CFTypeID v9 = CFGetTypeID(Value);
      if (v9 == CFStringGetTypeID()) {
        CFArrayRef v10 = v8;
      }
      else {
        CFArrayRef v10 = 0;
      }
    }
    else
    {
      CFArrayRef v10 = 0;
    }
    CFTypeRef v11 = v10;
    return sub_100013168(a3, &v11);
  }
  return result;
}

void sub_100CEBE3C(_Unwind_Exception *a1)
{
  sub_1000558F4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100CEBE50(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    CFTypeID v4 = (void *)(a1 + 8);
    sub_1000346F8(a1, *(void **)(a1 + 8));
    *(void *)a1 = *a2;
    unsigned int v5 = a2 + 1;
    uint64_t v6 = a2[1];
    void *v4 = v6;
    uint64_t v7 = a2[2];
    *(void *)(a1 + 16) = v7;
    if (v7)
    {
      *(void *)(v6 + 16) = v4;
      *a2 = v5;
      void *v5 = 0;
      a2[2] = 0;
    }
    else
    {
      *(void *)a1 = v4;
    }
  }
  else
  {
    *(void *)a1 = *a2;
    CFTypeID v8 = a2 + 1;
    uint64_t v9 = a2[1];
    *(void *)(a1 + 8) = v9;
    uint64_t v10 = a1 + 8;
    uint64_t v11 = a2[2];
    *(void *)(a1 + 16) = v11;
    if (v11)
    {
      *(void *)(v9 + 16) = v10;
      *a2 = v8;
      void *v8 = 0;
      a2[2] = 0;
    }
    else
    {
      *(void *)a1 = v10;
    }
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t sub_100CEBF10(uint64_t a1, int *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  CFTypeID v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 4 * a3;
    do
    {
      sub_100602B88((uint64_t **)a1, v4, a2, a2);
      ++a2;
      v6 -= 4;
    }
    while (v6);
  }
  return a1;
}

void sub_100CEBF78(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100CEBF90(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100CEBFF8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_100CEC098(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CEC014(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100CEC04C(uint64_t a1)
{
  return sub_100CEC098(*(void *)(a1 + 24));
}

uint64_t sub_100CEC054(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100CEC098(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    sub_100057D78((const void **)(result + 72));
    sub_100057D78((const void **)(v1 + 64));
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    CFBooleanRef v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100CEC110(uint64_t a1, NSObject **a2, void *a3, char *a4, char *a5, void *a6, void *a7, uint64_t *a8)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v42, kCtLoggingSystemName, a5);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  CFIndex v15 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v15) {
    dispatch_retain(v15);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&cf, &v42);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&cf);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&cf);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v42);
  *(void *)a1 = &off_101A4FB20;
  *(void *)(a1 + 48) = *a3;
  uint64_t v16 = a3[1];
  *(void *)(a1 + 56) = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0((void *)(a1 + 64), a4);
  sub_100058DB0(&__p, a4);
  CFStringRef v17 = *(NSObject **)(a1 + 24);
  int v39 = v17;
  if (v17) {
    dispatch_retain(v17);
  }
  ctu::RestModule::RestModule();
  if (v39) {
    dispatch_release(v39);
  }
  if (v41 < 0) {
    operator delete(__p);
  }
  uint64_t v18 = *a8;
  *(void *)(a1 + 104) = *a8;
  uint64_t v19 = a8[1];
  *(void *)(a1 + 112) = v19;
  if (v19)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 16), 1uLL, memory_order_relaxed);
    uint64_t v18 = *a8;
  }
  *(_DWORD *)(a1 + 120) = *(_DWORD *)(v18 + 8);
  *(unsigned char *)(a1 + 124) = 0;
  *(void *)(a1 + 128) = *a6;
  uint64_t v20 = a6[1];
  *(void *)(a1 + 136) = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 144) = *a7;
  uint64_t v21 = a7[1];
  *(void *)(a1 + 152) = v21;
  if (v21) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v22 = *(void *)(*a7 + 56);
  if (v22 > 4) {
    uint64_t v23 = ":? ";
  }
  else {
    uint64_t v23 = (const char *)*((void *)&off_101A4FD90 + v22);
  }
  *(_OWORD *)(a1 + 184) = 0u;
  *(void *)(a1 + 160) = v23;
  *(unsigned char *)(a1 + 168) = 0;
  *(void *)(a1 + 172) = 0;
  *(unsigned char *)(a1 + 304) = 0;
  *(unsigned char *)(a1 + 312) = 0;
  *(unsigned char *)(a1 + 336) = 0;
  *(_WORD *)(a1 + 344) = 0;
  *(unsigned char *)(a1 + 346) = 0;
  *(void *)(a1 + 348) = 0;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(unsigned char *)(a1 + 280) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v25 = ServiceMap;
  if (v26 < 0)
  {
    uint64_t v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v28 = 5381;
    do
    {
      uint64_t v26 = v28;
      unsigned int v29 = *v27++;
      uint64_t v28 = (33 * v28) ^ v29;
    }
    while (v29);
  }
  std::mutex::lock(ServiceMap);
  v42.char var0 = (char *)v26;
  CFTypeID v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)&v42);
  if (!v30)
  {
    uint64_t v32 = 0;
    goto LABEL_27;
  }
  uint64_t v32 = v30[3];
  uint64_t v31 = (std::__shared_weak_count *)v30[4];
  if (!v31)
  {
LABEL_27:
    std::mutex::unlock(v25);
    uint64_t v31 = 0;
    char v33 = 1;
    goto LABEL_28;
  }
  atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v25);
  atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v31);
  char v33 = 0;
LABEL_28:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v32 + 24))(&cf, v32, ***(void ***)(a1 + 128) + 24, @"subscriber-blocked", kCarrierEntitlementsWalletDomain, 0, 3);
  uint64_t v34 = (BOOL *)cf;
  LOBYTE(v42.var0) = 0;
  if (cf)
  {
    CFTypeID v35 = CFGetTypeID(cf);
    if (v35 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)&v42, v34, v36);
    }
  }
  char var0 = (char)v42.var0;
  sub_1000577C4(&cf);
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  *(unsigned char *)(a1 + 356) = var0;
  *(void *)(a1 + 360) = 0;
  *(_DWORD *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = 0;
  *(unsigned char *)(a1 + 384) = 0;
  return a1;
}

void sub_100CEC4A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  if (*(unsigned char *)(v20 + 336) && *(char *)(v20 + 335) < 0) {
    operator delete(*(void **)(v20 + 312));
  }
  if (*(unsigned char *)(v20 + 304) && *(char *)(v20 + 303) < 0) {
    operator delete(*(void **)(v20 + 280));
  }
  if (*(char *)(v20 + 279) < 0) {
    operator delete(*(void **)(v20 + 256));
  }
  if (*(char *)(v20 + 255) < 0) {
    operator delete(*(void **)(v20 + 232));
  }
  if (*(char *)(v20 + 231) < 0) {
    operator delete(*(void **)(v20 + 208));
  }
  if (*(char *)(v20 + 207) < 0) {
    operator delete(*v24);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v20 + 152);
  if (v27) {
    sub_10004D2C8(v27);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v20 + 136);
  if (v28) {
    sub_10004D2C8(v28);
  }
  unsigned int v29 = *(std::__shared_weak_count **)(v20 + 112);
  if (v29) {
    std::__shared_weak_count::__release_weak(v29);
  }
  CFTypeID v30 = *(std::__shared_weak_count **)(v20 + 96);
  if (v30) {
    sub_10004D2C8(v30);
  }
  if (*(char *)(v20 + 87) < 0) {
    operator delete(*v22);
  }
  uint64_t v31 = *(std::__shared_weak_count **)(v20 + 56);
  if (v31) {
    sub_10004D2C8(v31);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100CEC610(uint64_t a1)
{
  *(void *)a1 = &off_101A4FB20;
  *(unsigned char *)(a1 + 124) = 1;
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 88));
  uint64_t v2 = *(void *)(a1 + 376);
  *(void *)(a1 + 376) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 360);
  *(void *)(a1 + 360) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  if (*(unsigned char *)(a1 + 336) && *(char *)(a1 + 335) < 0) {
    operator delete(*(void **)(a1 + 312));
  }
  if (*(unsigned char *)(a1 + 304) && *(char *)(a1 + 303) < 0) {
    operator delete(*(void **)(a1 + 280));
  }
  if (*(char *)(a1 + 279) < 0) {
    operator delete(*(void **)(a1 + 256));
  }
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*(void **)(a1 + 208));
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  CFTypeID v4 = *(std::__shared_weak_count **)(a1 + 152);
  if (v4) {
    sub_10004D2C8(v4);
  }
  unsigned int v5 = *(std::__shared_weak_count **)(a1 + 136);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 112);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 96);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  CFTypeID v8 = *(std::__shared_weak_count **)(a1 + 56);
  if (v8) {
    sub_10004D2C8(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100CEC79C(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v1, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100CEC7E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CEC800(uint64_t a1, unsigned int a2)
{
  CFTypeID v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v6 = *(void *)(a1 + 160);
    if (a2 > 8) {
      uint64_t v7 = "Reason unknown??";
    }
    else {
      uint64_t v7 = off_101A4FE70[a2];
    }
    int v10 = 136316162;
    uint64_t v11 = v5;
    __int16 v12 = 2080;
    char v13 = " ";
    __int16 v14 = 2080;
    uint64_t v15 = v6;
    __int16 v16 = 2080;
    CFStringRef v17 = "";
    __int16 v18 = 2080;
    uint64_t v19 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sreset_sync: %s", (uint8_t *)&v10, 0x34u);
  }
  unsigned int v8 = a2 - 1;
  uint64_t v9 = "CheckEntitlementsReason::kUserInitiated";
  switch(a2)
  {
    case 0u:
      goto LABEL_22;
    case 1u:
    case 3u:
      *(unsigned char *)(a1 + 384) = 0;
      if (a2 == 1)
      {
        sub_100CECA44(a1, (uint64_t)"CheckEntitlementsReason::kSubscriberModified", v8 < 8);
        *(_DWORD *)(a1 + 176) = 0;
        if (*(unsigned char *)(a1 + 336))
        {
          if (*(char *)(a1 + 335) < 0) {
            operator delete(*(void **)(a1 + 312));
          }
          *(unsigned char *)(a1 + 336) = 0;
        }
      }
      else
      {
        if (a2 == 3)
        {
          uint64_t v9 = "CheckEntitlementsReason::kBundleChangeTriggered";
        }
        else if (a2 == 2)
        {
LABEL_10:
          uint64_t v9 = "CheckEntitlementsReason::kSubscriberStateChanged";
        }
        else
        {
LABEL_11:
          uint64_t v9 = "Reason unknown??";
        }
LABEL_22:
        sub_100CECA44(a1, (uint64_t)v9, v8 < 8);
        *(_DWORD *)(a1 + 176) = 0;
      }
      *(unsigned char *)(a1 + 168) = 0;
      sub_100CECC5C(a1);
      return;
    case 2u:
      goto LABEL_10;
    case 4u:
      uint64_t v9 = "CheckEntitlementsReason::kSelfInitiated";
      goto LABEL_22;
    case 5u:
      uint64_t v9 = "CheckEntitlementsReason::kUpdateTimerExpired";
      goto LABEL_22;
    case 6u:
      uint64_t v9 = "CheckEntitlementsReason::kProvisioningTimerExpired";
      goto LABEL_22;
    case 7u:
      uint64_t v9 = "CheckEntitlementsReason::kServerInitiated";
      goto LABEL_22;
    case 8u:
      uint64_t v9 = "CheckEntitlementsReason::kRefreshUserAppToken";
      goto LABEL_22;
    default:
      goto LABEL_11;
  }
}

void sub_100CECA44(uint64_t a1, uint64_t a2, int a3)
{
  if (*(_DWORD *)(a1 + 348) || *(_DWORD *)(a1 + 352))
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v8 = *(void *)(a1 + 160);
      int v14 = 136316162;
      uint64_t v15 = v7;
      __int16 v16 = 2080;
      CFStringRef v17 = " ";
      __int16 v18 = 2080;
      uint64_t v19 = v8;
      __int16 v20 = 2080;
      uint64_t v21 = "";
      __int16 v22 = 2080;
      uint64_t v23 = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sreset failures <%s>", (uint8_t *)&v14, 0x34u);
    }
    *(void *)(a1 + 348) = 0;
    uint64_t v9 = *(void *)(a1 + 360);
    *(void *)(a1 + 360) = 0;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
  }
  if (a3)
  {
    *(_DWORD *)(a1 + 368) = 0;
    uint64_t v10 = *(void *)(a1 + 376);
    if (v10)
    {
      uint64_t v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v13 = *(void *)(a1 + 160);
        int v14 = 136316162;
        uint64_t v15 = v12;
        __int16 v16 = 2080;
        CFStringRef v17 = " ";
        __int16 v18 = 2080;
        uint64_t v19 = v13;
        __int16 v20 = 2080;
        uint64_t v21 = "";
        __int16 v22 = 2080;
        uint64_t v23 = a2;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sblock on communication removed <%s>", (uint8_t *)&v14, 0x34u);
        uint64_t v10 = *(void *)(a1 + 376);
        *(void *)(a1 + 376) = 0;
        if (!v10) {
          return;
        }
      }
      else
      {
        *(void *)(a1 + 376) = 0;
      }
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
}

void sub_100CECC5C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 168)) {
    goto LABEL_19;
  }
  CFDictionaryRef theDict = 0;
  (**(void (***)(uint8_t *__return_ptr, uint64_t))a1)(buf, a1);
  sub_100CEA358(*(const void ***)buf, &theDict);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (theDict) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (!v2)
  {
    CFTypeID v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v51 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = v51;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      uint64_t v6 = "#D %s%sNo Authentication Settings for Entitlements Server";
      goto LABEL_56;
    }
LABEL_12:
    *(unsigned char *)(a1 + 168) = 1;
LABEL_13:
    sub_100057D78((const void **)&theDict);
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v50 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = v50;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "#D %s%sAuthentication is disabled", buf, 0x16u);
    }
    *(_DWORD *)(a1 + 172) = 0;
    if (*(char *)(a1 + 207) < 0)
    {
      *(void *)(a1 + 192) = 0;
      uint64_t v8 = *(unsigned char **)(a1 + 184);
    }
    else
    {
      uint64_t v8 = (unsigned char *)(a1 + 184);
      *(unsigned char *)(a1 + 207) = 0;
    }
    unsigned char *v8 = 0;
    goto LABEL_19;
  }
  uint64_t v3 = ***(PersonalityInfo ****)(a1 + 128);
  if (*((unsigned char *)v3 + 49))
  {
    CFTypeID v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v5 = PersonalityInfo::logPrefix(v3);
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      uint64_t v6 = "#D %s%sAuthentication via SIM is not expected";
LABEL_56:
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, v6, buf, 0x16u);
      goto LABEL_12;
    }
    goto LABEL_12;
  }
  CFBooleanRef Value = (int *)CFDictionaryGetValue(theDict, @"Type");
  CFStringRef v17 = Value;
  *(_DWORD *)OsLogContext buf = 0;
  if (!Value || (CFTypeID v18 = CFGetTypeID(Value), v18 != CFNumberGetTypeID()))
  {
    int v20 = 0;
    goto LABEL_52;
  }
  ctu::cf::assign((ctu::cf *)buf, v17, v19);
  int v20 = *(_DWORD *)buf;
  if ((*(_DWORD *)buf - 1) >= 5)
  {
LABEL_52:
    CFNumberRef v44 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    uint64_t v45 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v46 = *(void *)(a1 + 160);
    *(_DWORD *)OsLogContext buf = 136316162;
    *(void *)&uint8_t buf[4] = v45;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v46;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    *(_WORD *)&buf[42] = 1024;
    *(_DWORD *)&buf[44] = v20;
    uint64_t v47 = "#W %s%s%s%sUnsupported/Unknown Authentication Type for Entitlements Server : %d";
    uint64_t v48 = v44;
    uint32_t v49 = 48;
LABEL_54:
    _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, v47, buf, v49);
    goto LABEL_13;
  }
  int v120 = *(_DWORD *)buf;
  if (*(_DWORD *)buf == 2)
  {
    uint64_t v21 = *(void *)(a1 + 128);
    int v22 = *(unsigned __int8 *)(v21 + 296);
    uint64_t v23 = *(NSObject **)(a1 + 40);
    BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
    if (!v22)
    {
      if (!v24) {
        goto LABEL_13;
      }
      uint64_t v55 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)v21);
      uint64_t v56 = *(void *)(a1 + 160);
      *(_DWORD *)OsLogContext buf = 136315906;
      *(void *)&uint8_t buf[4] = v55;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v56;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      uint64_t v47 = "#W %s%s%s%sIMS info is not ready yet";
      goto LABEL_95;
    }
    if (v24)
    {
      uint64_t v25 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)v21);
      uint64_t v26 = *(void *)(a1 + 160);
      uint64_t v27 = *(void *)(a1 + 128);
      uint64_t v28 = (void *)(v27 + 168);
      if (*(char *)(v27 + 191) < 0) {
        uint64_t v28 = (void *)*v28;
      }
      *(_DWORD *)OsLogContext buf = 136316162;
      *(void *)&uint8_t buf[4] = v25;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v26;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      *(_WORD *)&buf[42] = 2080;
      *(void *)&buf[44] = v28;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s  IMPI: %s", buf, 0x34u);
      uint64_t v23 = *(NSObject **)(a1 + 40);
      uint64_t v21 = *(void *)(a1 + 128);
    }
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)v21);
      uint64_t v30 = *(void *)(a1 + 160);
      unint64_t v31 = 0xAAAAAAAAAAAAAAABLL
          * ((uint64_t)(*(void *)(*(void *)(a1 + 128) + 224) - *(void *)(*(void *)(a1 + 128) + 216)) >> 3);
      *(_DWORD *)OsLogContext buf = 136316162;
      *(void *)&uint8_t buf[4] = v29;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v30;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      *(_WORD *)&buf[42] = 2048;
      *(void *)&buf[44] = v31;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s  IMPU: %lu items", buf, 0x34u);
      uint64_t v21 = *(void *)(a1 + 128);
    }
    uint64_t v32 = *(uint64_t **)(v21 + 216);
    for (CFIndex i = *(uint64_t **)(v21 + 224); v32 != i; v32 += 3)
    {
      uint64_t v34 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v35 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        CFBooleanRef v36 = v32;
        if (*((char *)v32 + 23) < 0) {
          CFBooleanRef v36 = (uint64_t *)*v32;
        }
        uint64_t v37 = *(void *)(a1 + 160);
        *(_DWORD *)OsLogContext buf = 136316162;
        *(void *)&uint8_t buf[4] = v35;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v37;
        *(_WORD *)&unsigned char buf[32] = 2080;
        *(void *)&buf[34] = "";
        *(_WORD *)&buf[42] = 2080;
        *(void *)&buf[44] = v36;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s  IMPU: %s", buf, 0x34u);
      }
    }
  }
  CFDictionaryGetValue(theDict, @"Username");
  memset(buf, 0, 24);
  ctu::cf::assign();
  uint64_t v38 = *(void *)buf;
  *(void *)long long v124 = *(void *)&buf[8];
  *(void *)&v124[7] = *(void *)&buf[15];
  uint64_t v39 = buf[23];
  uint64_t v40 = (void **)(a1 + 184);
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*v40);
  }
  *(void *)(a1 + 192) = *(void *)v124;
  char v41 = (uint64_t *)(a1 + 192);
  *(void *)(a1 + 184) = v38;
  *(void *)(a1 + 199) = *(void *)&v124[7];
  *(unsigned char *)(a1 + 207) = v39;
  int v42 = v120;
  if ((v39 & 0x80) != 0) {
    uint64_t v43 = *v41;
  }
  else {
    uint64_t v43 = v39;
  }
  if (v120 == 5 && v43)
  {
    uint64_t v52 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v53 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v54 = *(void *)(a1 + 160);
      *(_DWORD *)OsLogContext buf = 136316162;
      *(void *)&uint8_t buf[4] = v53;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v54;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      *(_WORD *)&buf[42] = 2112;
      *(void *)&buf[44] = @"Username";
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sBlind signature authentication shouldn't coexist with %@ key in bundle. Fix it.", buf, 0x34u);
      LOBYTE(v39) = *(unsigned char *)(a1 + 207);
    }
    if ((v39 & 0x80) == 0)
    {
      *(unsigned char *)(a1 + 184) = 0;
      *(unsigned char *)(a1 + 207) = 0;
      goto LABEL_81;
    }
    **(unsigned char **)(a1 + 184) = 0;
    *(void *)(a1 + 192) = 0;
    LODWORD(v39) = *(unsigned __int8 *)(a1 + 207);
  }
  if ((v39 & 0x80) != 0)
  {
    uint64_t v57 = *v41;
    if (*v41)
    {
      long long v58 = (char *)*v40;
      goto LABEL_72;
    }
LABEL_81:
    int v63 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v64 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v65 = *(void *)(a1 + 160);
      *(_DWORD *)OsLogContext buf = 136315906;
      *(void *)&uint8_t buf[4] = v64;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v65;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAuthentication without Username", buf, 0x2Au);
    }
    goto LABEL_83;
  }
  if (!v39) {
    goto LABEL_81;
  }
  uint64_t v57 = v39;
  long long v58 = (char *)(a1 + 184);
LABEL_72:
  if (v57 < 5) {
    goto LABEL_93;
  }
  char v59 = &v58[v57];
  uint64_t v60 = v58;
  while (1)
  {
    int v61 = (char *)memchr(v60, 36, v57 - 4);
    if (!v61) {
      goto LABEL_93;
    }
    if (*(_DWORD *)v61 == 1397573924 && v61[4] == 73) {
      break;
    }
    uint64_t v60 = v61 + 1;
    uint64_t v57 = v59 - (unsigned char *)v60;
    if (v59 - (unsigned char *)v60 < 5) {
      goto LABEL_93;
    }
  }
  if (v61 == v59 || (std::string::size_type v71 = v61 - v58, v61 - v58 == -1))
  {
LABEL_93:
    uint64_t v23 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    uint64_t v75 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v76 = *(void *)(a1 + 160);
    *(_DWORD *)OsLogContext buf = 136315906;
    *(void *)&uint8_t buf[4] = v75;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v76;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    uint64_t v47 = "#W %s%s%s%sUnable to find subscriber key for replacement";
    goto LABEL_95;
  }
  uint64_t v72 = *(void *)(a1 + 128);
  char v73 = *(unsigned char *)(v72 + 87);
  if (v73 < 0) {
    uint64_t v74 = *(void *)(v72 + 72);
  }
  else {
    uint64_t v74 = *(unsigned __int8 *)(v72 + 87);
  }
  if (!v74)
  {
    int v80 = *(unsigned __int8 *)(v72 + 88);
    uint64_t v23 = *(NSObject **)(a1 + 40);
    BOOL v81 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
    if (v80)
    {
      if (!v81) {
        goto LABEL_13;
      }
      uint64_t v82 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)v72);
      uint64_t v83 = *(void *)(a1 + 160);
      *(_DWORD *)OsLogContext buf = 136315906;
      *(void *)&uint8_t buf[4] = v82;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v83;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      uint64_t v47 = "#W %s%s%s%sNo compatible IMSI available";
    }
    else
    {
      if (!v81) {
        goto LABEL_13;
      }
      uint64_t v94 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)v72);
      uint64_t v95 = *(void *)(a1 + 160);
      *(_DWORD *)OsLogContext buf = 136315906;
      *(void *)&uint8_t buf[4] = v94;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v95;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      uint64_t v47 = "#W %s%s%s%sNo IMSI is available";
    }
    goto LABEL_95;
  }
  if (v73 >= 0) {
    int v77 = (const std::string::value_type *)(v72 + 64);
  }
  else {
    int v77 = *(const std::string::value_type **)(v72 + 64);
  }
  if (v73 >= 0) {
    std::string::size_type v78 = *(unsigned __int8 *)(v72 + 87);
  }
  else {
    std::string::size_type v78 = *(void *)(v72 + 72);
  }
  std::string::replace((std::string *)(a1 + 184), v71, 5uLL, v77, v78);
  if (*(char *)(a1 + 207) < 0) {
    uint64_t v79 = *v41;
  }
  else {
    uint64_t v79 = *(unsigned __int8 *)(a1 + 207);
  }
  if (!v79)
  {
    uint64_t v23 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    uint64_t v92 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v93 = *(void *)(a1 + 160);
    *(_DWORD *)OsLogContext buf = 136315906;
    *(void *)&uint8_t buf[4] = v92;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v93;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    uint64_t v47 = "#W %s%s%s%sUnable to replace subscriber identifier";
LABEL_95:
    uint64_t v48 = v23;
    uint32_t v49 = 42;
    goto LABEL_54;
  }
  std::string::size_type v84 = sub_100195000((uint64_t *)(a1 + 184), "$MCC", 0);
  unint64_t v85 = sub_100195000((uint64_t *)(a1 + 184), "$MNC", 0);
  if (v84 != -1 || v85 != -1)
  {
    std::string::size_type __pos = v85;
    memset(buf, 0, 48);
    sub_100E63EA4((uint64_t)buf);
    if (v84 != -1)
    {
      int v86 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v118 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        *(_DWORD *)long long v124 = 136315394;
        *(void *)&v124[4] = v118;
        *(_WORD *)&v124[12] = 2080;
        *(void *)&v124[14] = " ";
        _os_log_debug_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEBUG, "#D %s%sCarrier uses MCC in user name", v124, 0x16u);
      }
      if ((buf[23] & 0x80u) == 0) {
        std::string::size_type v87 = buf[23];
      }
      else {
        std::string::size_type v87 = *(void *)&buf[8];
      }
      if (!v87)
      {
        long long v96 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v97 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v98 = *(void *)(a1 + 160);
          *(_DWORD *)long long v124 = 136315906;
          *(void *)&v124[4] = v97;
          *(_WORD *)&v124[12] = 2080;
          *(void *)&v124[14] = " ";
          *(_WORD *)&v124[22] = 2080;
          uint64_t v125 = v98;
          __int16 v126 = 2080;
          uint64_t v127 = "";
          uint64_t v99 = "#W %s%s%s%sRequired MCC not found";
LABEL_179:
          _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, v99, v124, 0x2Au);
        }
LABEL_180:
        sub_1001085D8((uint64_t)buf);
        goto LABEL_13;
      }
      if ((buf[23] & 0x80u) == 0) {
        uint64_t v88 = buf;
      }
      else {
        uint64_t v88 = *(uint8_t **)buf;
      }
      std::string::replace((std::string *)(a1 + 184), v84, 4uLL, (const std::string::value_type *)v88, v87);
    }
    if (__pos == -1)
    {
LABEL_152:
      sub_1001085D8((uint64_t)buf);
      int v42 = v120;
      goto LABEL_153;
    }
    uint64_t v89 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v119 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      *(_DWORD *)long long v124 = 136315394;
      *(void *)&v124[4] = v119;
      *(_WORD *)&v124[12] = 2080;
      *(void *)&v124[14] = " ";
      _os_log_debug_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEBUG, "#D %s%sCarrier uses MNC in user name", v124, 0x16u);
    }
    signed __int8 v90 = buf[47];
    if ((char)buf[47] < 0)
    {
      int v91 = *(_DWORD *)&buf[32];
      if (*(void *)&buf[32]) {
        goto LABEL_137;
      }
    }
    else if (buf[47])
    {
      int v91 = buf[47];
LABEL_137:
      if (v91 <= 2)
      {
        if (3 - v91 <= 1) {
          int v100 = 1;
        }
        else {
          int v100 = 3 - v91;
        }
        do
        {
          std::operator+<char>();
          if ((char)buf[47] < 0) {
            operator delete(*(void **)&buf[24]);
          }
          *(_OWORD *)&uint8_t buf[24] = *(_OWORD *)v124;
          *(void *)&unsigned char buf[40] = *(void *)&v124[16];
          --v100;
        }
        while (v100);
        signed __int8 v90 = buf[47];
      }
      if (v90 >= 0) {
        xpc_object_t v101 = (const std::string::value_type *)&buf[24];
      }
      else {
        xpc_object_t v101 = *(const std::string::value_type **)&buf[24];
      }
      if (v90 >= 0) {
        std::string::size_type v102 = v90;
      }
      else {
        std::string::size_type v102 = *(void *)&buf[32];
      }
      std::string::replace((std::string *)(a1 + 184), __pos, 4uLL, v101, v102);
      goto LABEL_152;
    }
    long long v96 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v114 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v115 = *(void *)(a1 + 160);
      *(_DWORD *)long long v124 = 136315906;
      *(void *)&v124[4] = v114;
      *(_WORD *)&v124[12] = 2080;
      *(void *)&v124[14] = " ";
      *(_WORD *)&v124[22] = 2080;
      uint64_t v125 = v115;
      __int16 v126 = 2080;
      uint64_t v127 = "";
      uint64_t v99 = "#W %s%s%s%sRequired MNC not found";
      goto LABEL_179;
    }
    goto LABEL_180;
  }
LABEL_153:
  long long v103 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v116 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    long long v117 = (void *)(a1 + 184);
    if (*(char *)(a1 + 207) < 0) {
      long long v117 = *v40;
    }
    *(_DWORD *)OsLogContext buf = 136315650;
    *(void *)&uint8_t buf[4] = v116;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v117;
    _os_log_debug_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEBUG, "#D %s%sUser name is %s", buf, 0x20u);
    int v42 = v120;
  }
  long long v129 = 0u;
  memset(buf, 0, sizeof(buf));
  if (*(char *)(a1 + 207) < 0)
  {
    uint64_t v40 = (void **)*v40;
    size_t v104 = *v41;
  }
  else
  {
    size_t v104 = *(unsigned __int8 *)(a1 + 207);
  }
  memset(v124, 0, sizeof(v124));
  sub_1007DC9C0((char *)v124, (char *)v40, (char *)v40 + v104, v104);
  sub_1010E83D4((uint64_t)buf, 0, 1, 0, (uint64_t)v124);
  if (*(void *)v124)
  {
    *(void *)&v124[8] = *(void *)v124;
    operator delete(*(void **)v124);
  }
  sub_1010E7AC0(buf, v124);
  long long v122 = *(void **)v124;
  if (*(void *)v124 == *(void *)&v124[8])
  {
    long long v107 = *(NSObject **)(a1 + 40);
    char v108 = 0;
    if (!os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_173;
    }
    uint64_t v109 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v110 = *(void *)(a1 + 160);
    *(_DWORD *)long long v124 = 136315906;
    *(void *)&v124[4] = v109;
    *(_WORD *)&v124[12] = 2080;
    *(void *)&v124[14] = " ";
    *(_WORD *)&v124[22] = 2080;
    uint64_t v125 = v110;
    __int16 v126 = 2080;
    uint64_t v127 = "";
    long long v111 = "#W %s%s%s%sInvalid Identity Data";
LABEL_171:
    _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, v111, v124, 0x2Au);
    char v108 = 0;
    goto LABEL_172;
  }
  ctu::base64::encode();
  long long v105 = (void **)(a1 + 208);
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*v105);
  }
  *(_OWORD *)long long v105 = *(_OWORD *)v124;
  *(void *)(a1 + 224) = *(void *)&v124[16];
  if (*(char *)(a1 + 231) < 0) {
    uint64_t v106 = *(void *)(a1 + 216);
  }
  else {
    uint64_t v106 = *(unsigned __int8 *)(a1 + 231);
  }
  if (!v106)
  {
    long long v107 = *(NSObject **)(a1 + 40);
    char v108 = 0;
    int v42 = v120;
    if (!os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_173;
    }
    uint64_t v112 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v113 = *(void *)(a1 + 160);
    *(_DWORD *)long long v124 = 136315906;
    *(void *)&v124[4] = v112;
    *(_WORD *)&v124[12] = 2080;
    *(void *)&v124[14] = " ";
    *(_WORD *)&v124[22] = 2080;
    uint64_t v125 = v113;
    __int16 v126 = 2080;
    uint64_t v127 = "";
    long long v111 = "#W %s%s%s%sInvalid User Name";
    goto LABEL_171;
  }
  char v108 = 1;
LABEL_172:
  int v42 = v120;
LABEL_173:
  if (v122) {
    operator delete(v122);
  }
  sub_100B63E7C(buf);
  if ((v108 & 1) == 0) {
    goto LABEL_13;
  }
LABEL_83:
  *(_DWORD *)(a1 + 172) = v42;
  *(unsigned char *)(a1 + 168) = 1;
  uint64_t v66 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v67 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v68 = *(int *)(a1 + 172);
    if (v68 > 5) {
      unint64_t v69 = "";
    }
    else {
      unint64_t v69 = off_101A4FE40[v68];
    }
    uint64_t v70 = *(void *)(a1 + 160);
    *(_DWORD *)OsLogContext buf = 136316162;
    *(void *)&uint8_t buf[4] = v67;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v70;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    *(_WORD *)&buf[42] = 2080;
    *(void *)&buf[44] = v69;
    _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sUsing %s for authentication", buf, 0x34u);
  }
  sub_100057D78((const void **)&theDict);
LABEL_19:
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v11 = (void *)(*(void *)(a1 + 128) + 64);
    if (*(char *)(*(void *)(a1 + 128) + 87) < 0) {
      uint64_t v11 = (void *)*v11;
    }
    uint64_t v12 = *(void *)(a1 + 160);
    if (*(unsigned char *)(a1 + 168)) {
      uint64_t v13 = "true";
    }
    else {
      uint64_t v13 = "false";
    }
    uint64_t v14 = *(int *)(a1 + 172);
    if (v14 > 5) {
      uint64_t v15 = "";
    }
    else {
      uint64_t v15 = off_101A4FE40[v14];
    }
    *(_DWORD *)OsLogContext buf = 136316674;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v12;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    *(_WORD *)&buf[42] = 2080;
    *(void *)&buf[44] = v11;
    *(_WORD *)&buf[52] = 2080;
    *(void *)&buf[54] = v13;
    *(_WORD *)&buf[62] = 2080;
    *(void *)&long long v129 = v15;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sgetAuthSettings: '%s', ready: %s (%s)", buf, 0x48u);
  }
}

void sub_100CEDE94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, const void *a17, uint64_t buf, int a19, __int16 a20,uint64_t a21,__int16 a22,uint64_t a23,__int16 a24,uint64_t a25,__int16 a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
}

uint64_t sub_100CEE08C()
{
  return 1;
}

void sub_100CEE094(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v4 = *(void *)(a1 + 160);
    *(_DWORD *)uint64_t v15 = 136315906;
    *(void *)&_OWORD v15[4] = v3;
    __int16 v16 = 2080;
    CFStringRef v17 = " ";
    __int16 v18 = 2080;
    uint64_t v19 = v4;
    __int16 v20 = 2080;
    uint64_t v21 = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sBlock further attempts...", v15, 0x2Au);
  }
  *(unsigned char *)(a1 + 356) = 1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v15 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)v15);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_11:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v13 + 16))(v13, ***(void ***)(a1 + 128) + 24, @"subscriber-blocked", kCFBooleanTrue, kCarrierEntitlementsWalletDomain, 0, 3, 0);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_100CEE290(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CEE2C0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 424))();
}

uint64_t sub_100CEE2EC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v4 = *(void *)(a1 + 160);
    uint64_t v5 = *(int *)(a1 + 172);
    if (v5 > 5) {
      uint64_t v6 = "";
    }
    else {
      uint64_t v6 = off_101A4FE40[v5];
    }
    *(_DWORD *)OsLogContext buf = 136316162;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v4;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    *(_WORD *)&buf[42] = 2080;
    *(void *)&buf[44] = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | Authentication Type: %s", buf, 0x34u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v8 = *(void *)(a1 + 160);
    uint64_t v9 = (void *)(a1 + 184);
    if (*(char *)(a1 + 207) < 0) {
      uint64_t v9 = (void *)*v9;
    }
    *(_DWORD *)OsLogContext buf = 136316162;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v8;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    *(_WORD *)&buf[42] = 2080;
    *(void *)&buf[44] = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | Authentication Username: %s", buf, 0x34u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v11 = *(void *)(a1 + 160);
    int v12 = *(_DWORD *)(a1 + 348);
    int v13 = *(_DWORD *)(a1 + 352);
    uint64_t v14 = asStringBool(*(unsigned char *)(a1 + 356));
    *(_DWORD *)OsLogContext buf = 136316674;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v11;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    *(_WORD *)&buf[42] = 1024;
    *(_DWORD *)&buf[44] = v12;
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = v13;
    *(_WORD *)&buf[54] = 2080;
    *(void *)&buf[56] = v14;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | %d Failures, %d interim failures, fBlockSubscriber = %s", buf, 0x40u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v16 = *(void *)(a1 + 160);
    int v17 = *(_DWORD *)(a1 + 368);
    __int16 v18 = "engaged";
    if (!*(void *)(a1 + 376)) {
      __int16 v18 = "idle";
    }
    *(_DWORD *)OsLogContext buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v16;
    *(_WORD *)&unsigned char buf[32] = 2080;
    *(void *)&buf[34] = "";
    *(_WORD *)&buf[42] = 1024;
    *(_DWORD *)&buf[44] = v17;
    *(_WORD *)&buf[48] = 2080;
    *(void *)&buf[50] = v18;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | server backoff retry cnt: %d, timer %s", buf, 0x3Au);
  }
  if (*(void *)(*(void *)(a1 + 144) + 56))
  {
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v21 = *(void *)(a1 + 160);
      *(_DWORD *)OsLogContext buf = 136315906;
      *(void *)&uint8_t buf[4] = v20;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v21;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | List tasks on endpoint:", buf, 0x2Au);
    }
    uint64_t v22 = 0;
    int v23 = 0;
    do
    {
      if ((*(void *)(*(void *)(a1 + 144) + 80) >> v22))
      {
        ++v23;
        BOOL v24 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
          uint64_t v26 = *(void *)(a1 + 160);
          uint64_t v27 = sub_100C89608(v22);
          *(_DWORD *)OsLogContext buf = 136316418;
          *(void *)&uint8_t buf[4] = v25;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v26;
          *(_WORD *)&unsigned char buf[32] = 2080;
          *(void *)&buf[34] = "";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = v23;
          *(_WORD *)&buf[48] = 2080;
          *(void *)&buf[50] = v27;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s |  %d) Task: %s", buf, 0x3Au);
        }
      }
      ++v22;
    }
    while (v22 != 13);
    uint64_t v28 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v30 = *(void *)(a1 + 160);
      *(_DWORD *)OsLogContext buf = 136316162;
      *(void *)&uint8_t buf[4] = v29;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v30;
      *(_WORD *)&unsigned char buf[32] = 2080;
      *(void *)&buf[34] = "";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = v23;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | %d task(s) overall", buf, 0x30u);
    }
  }
  unint64_t v48 = *(void *)(*(void *)(a1 + 144) + 88);
  uint64_t v76 = 0;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v63 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_10004BD84((uint64_t)buf);
  char v47 = 1;
  unint64_t v31 = operator new(0x20uLL);
  void *v31 = off_101A4FDD0;
  v31[1] = &v48;
  void v31[2] = buf;
  v31[3] = &v47;
  v61[3] = v31;
  sub_100022878((uint64_t)v61);
  sub_1000227F0(v61);
  uint64_t v32 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v34 = 0;
    uint64_t v35 = *(void *)(a1 + 160);
    strcpy((char *)v46, "0000000000000000000000");
    uint64_t v36 = 21;
    HIBYTE(v46[2]) = 22;
    do
    {
      if ((v48 >> v34))
      {
        if (SHIBYTE(v46[2]) >= 0) {
          uint64_t v37 = v46;
        }
        else {
          uint64_t v37 = (void **)v46[0];
        }
        *((unsigned char *)v37 + v36) = 49;
      }
      ++v34;
      --v36;
    }
    while (v34 != 22);
    int v38 = SHIBYTE(v46[2]);
    uint64_t v39 = (void **)v46[0];
    sub_10004BC98((uint64_t)&buf[24], __p);
    uint64_t v40 = v46;
    if (v38 < 0) {
      uint64_t v40 = v39;
    }
    if (v45 >= 0) {
      char v41 = __p;
    }
    else {
      char v41 = (void **)__p[0];
    }
    *(_DWORD *)uint32_t v49 = 136316418;
    uint64_t v50 = v33;
    __int16 v51 = 2080;
    uint64_t v52 = " ";
    __int16 v53 = 2080;
    uint64_t v54 = v35;
    __int16 v55 = 2080;
    uint64_t v56 = "";
    __int16 v57 = 2082;
    long long v58 = v40;
    __int16 v59 = 2082;
    uint64_t v60 = v41;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | supported entitlements on endpoint: %{public}s, [%{public}s]", v49, 0x3Eu);
    if (v45 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v46[2]) < 0) {
      operator delete(v46[0]);
    }
  }
  *(void *)&uint8_t buf[16] = v42;
  if (SHIBYTE(v65) < 0) {
    operator delete(*((void **)&v64 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100CEEB28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  if (v34 < 0) {
    operator delete(v33);
  }
  sub_10008248C((uint64_t)&a33);
  _Unwind_Resume(a1);
}

void sub_100CEEB6C(uint64_t a1)
{
}

void sub_100CEEB7C(uint64_t a1, void *a2)
{
  (*(void (**)(uint64_t, void))(*(void *)a1 + 288))(a1, 0);
  memset(&__s1, 0, sizeof(__s1));
  ctu::base64::encode();
  std::string::size_type v4 = 0;
  char v5 = 0;
  std::string::size_type size = 0;
  if (a2[1] != *a2)
  {
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v11 = *(void *)(a1 + 160);
      *(_DWORD *)OsLogContext buf = 136315906;
      uint64_t v18 = v10;
      __int16 v19 = 2080;
      uint64_t v20 = " ";
      __int16 v21 = 2080;
      uint64_t v22 = v11;
      __int16 v23 = 2080;
      BOOL v24 = "";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sFailed to convert token to base64", buf, 0x2Au);
      std::string::size_type v4 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
      std::string::size_type size = __s1.__r_.__value_.__l.__size_;
      char v5 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
    }
  }
  if (v5 >= 0) {
    std::string::size_type v7 = v4;
  }
  else {
    std::string::size_type v7 = size;
  }
  uint64_t v8 = *(unsigned __int8 *)(a1 + 255);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a1 + 240);
  }
  if (v7 != v8)
  {
    int v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v14 = *(void *)(a1 + 160);
      uint64_t v15 = a2[1] - *a2;
      *(_DWORD *)OsLogContext buf = 136316162;
      uint64_t v18 = v13;
      __int16 v19 = 2080;
      uint64_t v20 = " ";
      __int16 v21 = 2080;
      uint64_t v22 = v14;
      __int16 v23 = 2080;
      BOOL v24 = "";
      __int16 v25 = 2048;
      uint64_t v26 = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReceived authentication token of %zu bytes", buf, 0x34u);
    }
    std::string::operator=((std::string *)(a1 + 232), &__s1);
    if ((*((unsigned char *)&__s1.__r_.__value_.__s + 23) & 0x80) != 0) {
      operator delete(__s1.__r_.__value_.__l.__data_);
    }
  }
}

void sub_100CEEE24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CEEE50(uint64_t a1, const std::string *a2, const std::string *a3)
{
  (*(void (**)(uint64_t, void))(*(void *)a1 + 296))(a1, 0);
  uint64_t v6 = (const void **)(a1 + 256);
  uint64_t v7 = *(unsigned __int8 *)(a1 + 279);
  if ((v7 & 0x80u) == 0) {
    uint64_t v8 = *(unsigned __int8 *)(a1 + 279);
  }
  else {
    uint64_t v8 = *(void *)(a1 + 264);
  }
  std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  int v10 = (char)size;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = a2->__r_.__value_.__l.__size_;
  }
  if (v8 == size)
  {
    if (v10 >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    }
    if ((v7 & 0x80) == 0)
    {
      if (*(unsigned char *)(a1 + 279))
      {
        int v12 = (unsigned __int8 *)(a1 + 256);
        while (*v12 == v11->__r_.__value_.__s.__data_[0])
        {
          ++v12;
          uint64_t v11 = (const std::string *)((char *)v11 + 1);
          if (!--v7) {
            goto LABEL_26;
          }
        }
        goto LABEL_17;
      }
LABEL_26:
      uint64_t v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
        uint64_t v20 = *(void *)(a1 + 160);
        int v21 = 136315906;
        uint64_t v22 = v19;
        __int16 v23 = 2080;
        BOOL v24 = " ";
        __int16 v25 = 2080;
        uint64_t v26 = v20;
        __int16 v27 = 2080;
        uint64_t v28 = "";
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sservice token update ignored - no change", (uint8_t *)&v21, 0x2Au);
      }
      return;
    }
    if (!memcmp(*v6, v11, *(void *)(a1 + 264))) {
      goto LABEL_26;
    }
  }
LABEL_17:
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
    uint64_t v15 = *(void *)(a1 + 160);
    uint64_t v16 = (const void *)(a1 + 256);
    if (*(char *)(a1 + 279) < 0) {
      uint64_t v16 = *v6;
    }
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v17 = a2;
    }
    else {
      int v17 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    }
    int v21 = 136316418;
    uint64_t v22 = v14;
    __int16 v23 = 2080;
    BOOL v24 = " ";
    __int16 v25 = 2080;
    uint64_t v26 = v15;
    __int16 v27 = 2080;
    uint64_t v28 = "";
    __int16 v29 = 2080;
    uint64_t v30 = v16;
    __int16 v31 = 2080;
    uint64_t v32 = v17;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sChanging service token from %s to %s", (uint8_t *)&v21, 0x3Eu);
  }
  std::string::operator=((std::string *)(a1 + 256), a2);
  sub_100179AF8((std::string *)(a1 + 280), a3);
}

uint64_t sub_100CEF0C4(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 304))(a1, 0);
}

void sub_100CEF0F4(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 344) != a2)
  {
    BOOL v2 = a2;
    std::string::size_type v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      int v6 = 136315650;
      uint64_t v7 = v5;
      __int16 v8 = 2080;
      uint64_t v9 = " ";
      __int16 v10 = 2080;
      uint64_t v11 = asStringBool(v2);
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#D %s%sSetting wait for token: %s", (uint8_t *)&v6, 0x20u);
    }
    *(unsigned char *)(a1 + 344) = v2;
  }
}

void sub_100CEF1E8(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 345) != a2)
  {
    BOOL v2 = a2;
    std::string::size_type v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      int v6 = 136315650;
      uint64_t v7 = v5;
      __int16 v8 = 2080;
      uint64_t v9 = " ";
      __int16 v10 = 2080;
      uint64_t v11 = asStringBool(v2);
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#D %s%sSetting wait for service token: %s", (uint8_t *)&v6, 0x20u);
    }
    *(unsigned char *)(a1 + 345) = v2;
  }
}

void sub_100CEF2DC(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 346) != a2)
  {
    BOOL v2 = a2;
    std::string::size_type v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 346));
      int v7 = 136315906;
      uint64_t v8 = v5;
      __int16 v9 = 2080;
      __int16 v10 = " ";
      __int16 v11 = 2080;
      uint64_t v12 = v6;
      __int16 v13 = 2080;
      uint64_t v14 = asStringBool(v2);
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#D %s%sSetting wait for Subscriber ID from %s to %s", (uint8_t *)&v7, 0x2Au);
    }
    *(unsigned char *)(a1 + 346) = v2;
  }
}

void sub_100CEF3EC(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 356))
  {
    std::string::size_type v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = PersonalityInfo::logPrefix(***(PersonalityInfo ****)(a1 + 128));
      uint64_t v6 = *(void *)(a1 + 160);
      *(_DWORD *)int v17 = 136316162;
      *(void *)&v17[4] = v5;
      __int16 v18 = 2080;
      uint64_t v19 = " ";
      __int16 v20 = 2080;
      uint64_t v21 = v6;
      __int16 v22 = 2080;
      __int16 v23 = "";
      __int16 v24 = 2080;
      uint64_t v25 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sUNBLOCK UNKNOWN SUBSCRIBER because of '%s'", v17, 0x34u);
    }
    *(unsigned char *)(a1 + 356) = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    uint64_t v8 = ServiceMap;
    if (v9 < 0)
    {
      __int16 v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    *(void *)int v17 = v9;
    __int16 v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)v17);
    if (v13)
    {
      uint64_t v15 = v13[3];
      uint64_t v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
LABEL_12:
    (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v15 + 32))(v15, ***(void ***)(a1 + 128) + 24, @"subscriber-blocked", kCarrierEntitlementsWalletDomain, 0, 3);
    if ((v16 & 1) == 0) {
      sub_10004D2C8(v14);
    }
  }
}

void sub_100CEF5E8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CEF618(uint64_t a1, unsigned int a2)
{
  if (a2 > 8) {
    BOOL v2 = "Reason unknown??";
  }
  else {
    BOOL v2 = off_101A4FE70[a2];
  }
  sub_100CECA44(a1, (uint64_t)v2, 1);
}

std::string *sub_100CEF640(std::string *result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (v2)
  {
    if (!result[14].__r_.__value_.__s.__data_[0]) {
      return sub_100093B44(result + 13, (const std::string *)a2);
    }
  }
  return result;
}

void sub_100CEF66C(uint64_t a1, os_log_t *a2)
{
  std::string::size_type v4 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)a1);
    uint64_t v6 = (const char *)(a1 + 16);
    if (*(char *)(a1 + 39) < 0) {
      uint64_t v6 = *(const char **)v6;
    }
    *(_DWORD *)OsLogContext buf = 136316162;
    uint64_t v32 = v5;
    __int16 v33 = 2080;
    int v34 = " ";
    __int16 v35 = 2080;
    uint64_t v36 = "";
    __int16 v37 = 2080;
    int v38 = "";
    __int16 v39 = 2080;
    uint64_t v40 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fImei: %s", buf, 0x34u);
    std::string::size_type v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)a1);
    uint64_t v8 = (const char *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      uint64_t v8 = *(const char **)v8;
    }
    *(_DWORD *)OsLogContext buf = 136316162;
    uint64_t v32 = v7;
    __int16 v33 = 2080;
    int v34 = " ";
    __int16 v35 = 2080;
    uint64_t v36 = "";
    __int16 v37 = 2080;
    int v38 = "";
    __int16 v39 = 2080;
    uint64_t v40 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fMeid: %s", buf, 0x34u);
    std::string::size_type v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)a1);
    __int16 v10 = (const char *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0) {
      __int16 v10 = *(const char **)v10;
    }
    uint64_t v11 = asStringBool(*(unsigned char *)(a1 + 88) == 0);
    *(_DWORD *)OsLogContext buf = 136316418;
    uint64_t v32 = v9;
    __int16 v33 = 2080;
    int v34 = " ";
    __int16 v35 = 2080;
    uint64_t v36 = "";
    __int16 v37 = 2080;
    int v38 = "";
    __int16 v39 = 2080;
    uint64_t v40 = v10;
    __int16 v41 = 2080;
    uint64_t v42 = v11;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fImsi: %s, compatible:%s ", buf, 0x3Eu);
    std::string::size_type v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)a1);
    uint64_t v13 = v12;
    if (*(unsigned char *)(a1 + 296))
    {
      sub_1005933FC(a1 + 96, __p);
      if (v30 >= 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (void **)__p[0];
      }
      *(_DWORD *)OsLogContext buf = 136316162;
      uint64_t v32 = v13;
      __int16 v33 = 2080;
      int v34 = " ";
      __int16 v35 = 2080;
      uint64_t v36 = "";
      __int16 v37 = 2080;
      int v38 = "";
      __int16 v39 = 2080;
      uint64_t v40 = (const char *)v14;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fIMSInfo: %s", buf, 0x34u);
      if (v30 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      *(_DWORD *)OsLogContext buf = 136316162;
      uint64_t v32 = v12;
      __int16 v33 = 2080;
      int v34 = " ";
      __int16 v35 = 2080;
      uint64_t v36 = "";
      __int16 v37 = 2080;
      int v38 = "";
      __int16 v39 = 2080;
      uint64_t v40 = "-";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fIMSInfo: %s", buf, 0x34u);
    }
    std::string::size_type v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)a1);
    if (*(unsigned char *)(a1 + 328))
    {
      char v16 = (const char *)(a1 + 304);
      if (*(char *)(a1 + 327) < 0) {
        char v16 = *(const char **)v16;
      }
    }
    else
    {
      char v16 = "-";
    }
    *(_DWORD *)OsLogContext buf = 136316162;
    uint64_t v32 = v15;
    __int16 v33 = 2080;
    int v34 = " ";
    __int16 v35 = 2080;
    uint64_t v36 = "";
    __int16 v37 = 2080;
    int v38 = "";
    __int16 v39 = 2080;
    uint64_t v40 = v16;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fPAssociatedUri: %s", buf, 0x34u);
    std::string::size_type v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)a1);
    __int16 v18 = (const char *)(a1 + 336);
    if (*(char *)(a1 + 359) < 0) {
      __int16 v18 = *(const char **)v18;
    }
    *(_DWORD *)OsLogContext buf = 136316162;
    uint64_t v32 = v17;
    __int16 v33 = 2080;
    int v34 = " ";
    __int16 v35 = 2080;
    uint64_t v36 = "";
    __int16 v37 = 2080;
    int v38 = "";
    __int16 v39 = 2080;
    uint64_t v40 = v18;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fSubscriberID: %s", buf, 0x34u);
    std::string::size_type v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)a1);
    __int16 v20 = (const char *)(a1 + 360);
    if (*(char *)(a1 + 383) < 0) {
      __int16 v20 = *(const char **)v20;
    }
    *(_DWORD *)OsLogContext buf = 136316162;
    uint64_t v32 = v19;
    __int16 v33 = 2080;
    int v34 = " ";
    __int16 v35 = 2080;
    uint64_t v36 = "";
    __int16 v37 = 2080;
    int v38 = "";
    __int16 v39 = 2080;
    uint64_t v40 = v20;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fDeviceAccountID: %s", buf, 0x34u);
    std::string::size_type v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)a1);
    __int16 v22 = (const char *)(a1 + 384);
    if (*(char *)(a1 + 407) < 0) {
      __int16 v22 = *(const char **)v22;
    }
    *(_DWORD *)OsLogContext buf = 136316162;
    uint64_t v32 = v21;
    __int16 v33 = 2080;
    int v34 = " ";
    __int16 v35 = 2080;
    uint64_t v36 = "";
    __int16 v37 = 2080;
    int v38 = "";
    __int16 v39 = 2080;
    uint64_t v40 = v22;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fUniqueID: %s", buf, 0x34u);
    std::string::size_type v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)a1);
    __int16 v24 = (const char *)(a1 + 408);
    if (*(char *)(a1 + 431) < 0) {
      __int16 v24 = *(const char **)v24;
    }
    *(_DWORD *)OsLogContext buf = 136316162;
    uint64_t v32 = v23;
    __int16 v33 = 2080;
    int v34 = " ";
    __int16 v35 = 2080;
    uint64_t v36 = "";
    __int16 v37 = 2080;
    int v38 = "";
    __int16 v39 = 2080;
    uint64_t v40 = v24;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | fAliasID: %s", buf, 0x34u);
    std::string::size_type v4 = *a2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)a1);
    uint64_t v26 = asStringBool(*(unsigned char *)(a1 + 465));
    if (*(unsigned char *)(a1 + 465)) {
      BOOL v27 = *(unsigned char *)(a1 + 464) != 0;
    }
    else {
      BOOL v27 = 0;
    }
    uint64_t v28 = asStringBool(v27);
    *(_DWORD *)OsLogContext buf = 136316418;
    uint64_t v32 = v25;
    __int16 v33 = 2080;
    int v34 = " ";
    __int16 v35 = 2080;
    uint64_t v36 = "";
    __int16 v37 = 2080;
    int v38 = "";
    __int16 v39 = 2080;
    uint64_t v40 = (const char *)v26;
    __int16 v41 = 2080;
    uint64_t v42 = v28;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s | MonitorMode: %s, RetryControl: %s", buf, 0x3Eu);
  }
}

void sub_100CEFDC8()
{
}

__n128 sub_100CEFDDC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A4FDD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100CEFE30(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A4FDD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void *sub_100CEFE68(void *result, int *a2)
{
  int v2 = *a2;
  if (*a2 >= 0x16) {
    sub_1000C14F0("bitset test argument out of range");
  }
  uint64_t v3 = result;
  if ((*(void *)result[1] >> v2))
  {
    std::string::size_type v4 = (unsigned char *)result[3];
    uint64_t v5 = (void *)(result[2] + 16);
    if (*v4) {
      uint64_t v6 = "";
    }
    else {
      uint64_t v6 = ", ";
    }
    uint64_t v7 = sub_10004B96C(v5, (uint64_t)v6, 2 * (*v4 == 0));
    uint64_t v8 = sub_100059954(v2);
    size_t v9 = strlen(v8);
    __n128 result = sub_10004B96C(v7, (uint64_t)v8, v9);
    *(unsigned char *)v3[3] = 0;
  }
  return result;
}

uint64_t sub_100CEFF14(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100CEFF54()
{
}

void sub_100CEFF60(uint64_t a1)
{
  *(void *)a1 = off_101A4FEC8;
  uint64_t v4 = *(void *)(a1 + 64);
  int v2 = (void *)(a1 + 64);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v5) {
    sub_100206334(a1 + 56, v5);
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v6) {
    sub_100206334(a1 + 48, v6);
  }
  uint64_t v8 = (void **)(a1 + 24);
  sub_100047F64(&v8);
  sub_100110A40((void ***)(a1 + 16), 0);
  uint64_t v7 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v7) {
    sub_100206334(a1 + 8, v7);
  }
  PB::Base::~Base((PB::Base *)a1);
}

void sub_100CF0018(uint64_t a1)
{
  sub_100CEFF60(a1);

  operator delete();
}

uint64_t sub_100CF0050(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_101A4FEC8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 76) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (*(void *)(a2 + 64)) {
    operator new();
  }
  if (*(void *)(a2 + 56)) {
    operator new();
  }
  if (*(void *)(a2 + 48)) {
    operator new();
  }
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (a1 != a2) {
    sub_10005CA3C(a1 + 24, *(std::string **)(a2 + 24), *(long long **)(a2 + 32), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3));
  }
  char v4 = *(unsigned char *)(a2 + 76);
  if ((v4 & 2) != 0)
  {
    char v5 = *(unsigned char *)(a2 + 73);
    *(unsigned char *)(a1 + 76) |= 2u;
    *(unsigned char *)(a1 + 73) = v5;
    char v4 = *(unsigned char *)(a2 + 76);
  }
  if (v4)
  {
    char v6 = *(unsigned char *)(a2 + 72);
    *(unsigned char *)(a1 + 76) |= 1u;
    *(unsigned char *)(a1 + 72) = v6;
  }
  return a1;
}

uint64_t sub_100CF030C(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(void *)(a1 + 8)) {
    PB::TextFormatter::format();
  }
  char v5 = *(const PB::Data **)(a1 + 16);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  if (*(unsigned char *)(a1 + 76)) {
    PB::TextFormatter::format(this, "forceUserConsent", *(unsigned char *)(a1 + 72));
  }
  uint64_t v6 = *(void *)(a1 + 24);
  for (uint64_t i = *(void *)(a1 + 32); v6 != i; v6 += 24)
    PB::TextFormatter::format();
  if ((*(unsigned char *)(a1 + 76) & 2) != 0) {
    PB::TextFormatter::format(this, "localErrorRecovery", *(unsigned char *)(a1 + 73));
  }
  if (*(void *)(a1 + 48)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 56)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 64)) {
    PB::TextFormatter::format();
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100CF0440(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    uint64_t v8 = (uint64_t *)(a1 + 24);
    uint64_t v9 = a1 + 40;
    while (1)
    {
      uint64_t v10 = *(void *)this;
      if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
        break;
      }
      char v17 = 0;
      unsigned int v18 = 0;
      unint64_t v13 = 0;
      if (v2 > v3) {
        unint64_t v3 = v2;
      }
      do
      {
        if (v3 == v2)
        {
          int v4 = 1;
          *((unsigned char *)this + 24) = 1;
          return v4 == 0;
        }
        unint64_t v19 = v2 + 1;
        char v20 = *(unsigned char *)(v10 + v2);
        *((void *)this + 1) = v19;
        v13 |= (unint64_t)(v20 & 0x7F) << v17;
        if ((v20 & 0x80) == 0) {
          goto LABEL_23;
        }
        v17 += 7;
        unint64_t v2 = v19;
        BOOL v16 = v18++ > 8;
      }
      while (!v16);
LABEL_20:
      unsigned __int8 v21 = 0;
      LODWORD(v22) = 0;
LABEL_21:
      uint64_t result = PB::Reader::skip(this, v22, v21, 0);
      if (!result) {
        return result;
      }
LABEL_36:
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v11 = 0;
    unsigned int v12 = 0;
    unint64_t v13 = 0;
    while (1)
    {
      unint64_t v14 = v2 + 1;
      *((void *)this + 1) = v2 + 1;
      char v15 = *(unsigned char *)(v10 + v2);
      v13 |= (unint64_t)(v15 & 0x7F) << v11;
      if ((v15 & 0x80) == 0) {
        break;
      }
      v11 += 7;
      unint64_t v2 = v14;
      BOOL v16 = v12++ > 8;
      if (v16) {
        goto LABEL_20;
      }
    }
LABEL_23:
    unsigned __int8 v21 = v13 & 7;
    if ((v13 & 7) != 4)
    {
      unint64_t v22 = v13 >> 3;
      switch((v13 >> 3))
      {
        case 1u:
          operator new();
        case 3u:
          operator new();
        case 4u:
          operator new();
        case 5u:
          operator new();
        case 6u:
          operator new();
        case 7u:
          uint64_t v25 = *(void **)(a1 + 32);
          unint64_t v24 = *(void *)(a1 + 40);
          if ((unint64_t)v25 >= v24)
          {
            unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v25 - *v8) >> 3);
            unint64_t v36 = v35 + 1;
            if (v35 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_1000D8578();
            }
            unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - *v8) >> 3);
            if (2 * v37 > v36) {
              unint64_t v36 = 2 * v37;
            }
            if (v37 >= 0x555555555555555) {
              unint64_t v38 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v38 = v36;
            }
            _OWORD v41[4] = v9;
            if (v38) {
              __int16 v39 = (char *)sub_10004812C(v9, v38);
            }
            else {
              __int16 v39 = 0;
            }
            uint64_t v40 = &v39[24 * v35];
            v41[0] = v39;
            v41[1] = v40;
            v41[3] = &v39[24 * v38];
            *(void *)uint64_t v40 = 0;
            *((void *)v40 + 1) = 0;
            *((void *)v40 + 2) = 0;
            v41[2] = v40 + 24;
            sub_100048204(v8, v41);
            uint64_t v26 = *(void **)(a1 + 32);
            sub_100048174((uint64_t)v41);
          }
          else
          {
            *uint64_t v25 = 0;
            v25[1] = 0;
            std::string v25[2] = 0;
            uint64_t v26 = v25 + 3;
            *(void *)(a1 + 32) = v25 + 3;
          }
          *(void *)(a1 + 32) = v26;
          PB::Reader::read();
          goto LABEL_36;
        case 8u:
          *(unsigned char *)(a1 + 76) |= 2u;
          unint64_t v27 = *((void *)this + 1);
          if (v27 >= *((void *)this + 2))
          {
            BOOL v30 = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v28 = v27 + 1;
            int v29 = *(unsigned __int8 *)(*(void *)this + v27);
            *((void *)this + 1) = v28;
            BOOL v30 = v29 != 0;
          }
          *(unsigned char *)(a1 + 73) = v30;
          goto LABEL_36;
        case 9u:
          *(unsigned char *)(a1 + 76) |= 1u;
          unint64_t v31 = *((void *)this + 1);
          if (v31 >= *((void *)this + 2))
          {
            BOOL v34 = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v32 = v31 + 1;
            int v33 = *(unsigned __int8 *)(*(void *)this + v31);
            *((void *)this + 1) = v32;
            BOOL v34 = v33 != 0;
          }
          *(unsigned char *)(a1 + 72) = v34;
          goto LABEL_36;
        default:
          goto LABEL_21;
      }
    }
    int v4 = 0;
  }
  return v4 == 0;
}

void sub_100CF0900(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100048174((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100CF0938(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 16);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  if (*(void *)(v3 + 64)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 56)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 48)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 8)) {
    uint64_t result = PB::Writer::write();
  }
  uint64_t v5 = *(void *)(v3 + 24);
  uint64_t v6 = *(void *)(v3 + 32);
  while (v5 != v6)
  {
    uint64_t result = PB::Writer::write();
    v5 += 24;
  }
  char v7 = *(unsigned char *)(v3 + 76);
  if ((v7 & 2) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 73), 8u);
    char v7 = *(unsigned char *)(v3 + 76);
  }
  if (v7)
  {
    char v8 = *(unsigned char *)(v3 + 72);
    return PB::Writer::write(this, v8, 9u);
  }
  return result;
}

__CFString *sub_100CF0A38(int a1)
{
  uint64_t result = 0;
  switch(a1)
  {
    case 2:
      uint64_t v3 = kCTCarrierEntitlementKeyFaceTime;
      goto LABEL_19;
    case 3:
      uint64_t v3 = kCTCarrierEntitlementKeyTethering;
      goto LABEL_19;
    case 6:
      uint64_t v3 = kCTCarrierEntitlementKeyVoLTE;
      goto LABEL_19;
    case 7:
      uint64_t v3 = kCTCarrierEntitlementKeyVoWiFi;
      goto LABEL_19;
    case 8:
      uint64_t v3 = kCTCarrierEntitlementKeyThumper;
      goto LABEL_19;
    case 10:
      uint64_t v3 = kCTCarrierEntitlementKeyMultiSIM;
      goto LABEL_19;
    case 11:
      uint64_t v3 = kCTCarrierEntitlementKeySAWatch;
      goto LABEL_19;
    case 12:
      uint64_t v3 = kCTCarrierEntitlementKeyMultiSIMTransfer;
      goto LABEL_19;
    case 13:
      uint64_t v3 = kCTCarrierEntitlementKeyiPhonePlanTransfer;
      goto LABEL_19;
    case 14:
      uint64_t v3 = kCTCarrierEntitlementKeySAWatchTransfer;
      goto LABEL_19;
    case 15:
      uint64_t v3 = kCTCarrierEntitlementKey5GService;
      goto LABEL_19;
    case 16:
      uint64_t v3 = kCTCarrierEntitlementKeyiPadSignup;
      goto LABEL_19;
    case 17:
      uint64_t v3 = kCTCarrierEntitlementKeyCustomQoS;
      goto LABEL_19;
    case 18:
      uint64_t v3 = kCTCarrierEntitlementKeyPrivateNetProvisioning;
      goto LABEL_19;
    case 19:
      uint64_t v3 = kCTCarrierEntitlementKeyNtCarrierService;
      goto LABEL_19;
    case 20:
      uint64_t v3 = kCTCarrierEntitlementKeyHeraService;
      goto LABEL_19;
    case 21:
      uint64_t v3 = &kCTCarrierEntitlementKeyEnhancedThroughput;
LABEL_19:
      uint64_t result = *v3;
      break;
    default:
      return result;
  }
  return result;
}

const char *sub_100CF0B8C(unsigned int a1)
{
  if (a1 > 0xA) {
    return "????";
  }
  else {
    return off_101A4FFC8[a1];
  }
}

CFStringRef sub_100CF0BB0(int a1)
{
  if (a1) {
    return @"kTotal";
  }
  else {
    return @"wifi_pseudonym";
  }
}

uint64_t sub_100CF0BCC@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v49 = 0;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  *(_OWORD *)unint64_t v37 = 0u;
  long long v38 = 0u;
  memset(v36, 0, sizeof(v36));
  long long v35 = 0u;
  sub_10004BD84((uint64_t)&v35);
  sub_10004B96C(v36, (uint64_t)"{", 1);
  if (a1[1] != *a1)
  {
    sub_10004B96C(v36, (uint64_t)"plan:{", 6);
    unint64_t v27 = a2;
    uint64_t v4 = *a1;
    uint64_t v31 = a1[1];
    if (*a1 != v31)
    {
      char v5 = 1;
      do
      {
        if ((v5 & 1) == 0) {
          sub_10004B96C(v36, (uint64_t)", ", 2);
        }
        uint64_t v67 = 0;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v63 = 0u;
        long long v64 = 0u;
        long long v61 = 0u;
        long long v62 = 0u;
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        long long v53 = 0u;
        long long v54 = 0u;
        long long v51 = 0u;
        long long v52 = 0u;
        *(_OWORD *)uint64_t v50 = 0u;
        sub_10004BD84((uint64_t)v50);
        sub_10004B96C(&v51, (uint64_t)"(", 1);
        if (*(unsigned char *)(v4 + 4))
        {
          uint64_t v6 = sub_10004B96C(&v51, (uint64_t)"type: ", 6);
          if (*(_DWORD *)v4) {
            char v7 = "unmetered";
          }
          else {
            char v7 = "metered";
          }
          if (*(_DWORD *)v4) {
            uint64_t v8 = 9;
          }
          else {
            uint64_t v8 = 7;
          }
          sub_10004B96C(v6, (uint64_t)v7, v8);
        }
        if (*(unsigned char *)(v4 + 9))
        {
          sub_10004B96C(&v51, (uint64_t)", experience: ", 14);
          std::ostream::operator<<();
        }
        if (*(unsigned char *)(v4 + 16))
        {
          sub_10004B96C(&v51, (uint64_t)", volume cap: ", 14);
          std::ostream::operator<<();
        }
        if (*(unsigned char *)(v4 + 48))
        {
          sub_10004B96C(&v51, (uint64_t)", RAT:", 6);
          uint64_t v10 = *(_DWORD **)(v4 + 24);
          uint64_t v9 = *(_DWORD **)(v4 + 32);
          while (v10 != v9)
          {
            char v11 = sub_10004B96C(&v51, (uint64_t)" ", 1);
            if (*v10) {
              unsigned int v12 = "sub6";
            }
            else {
              unsigned int v12 = "mmw";
            }
            if (*v10) {
              uint64_t v13 = 4;
            }
            else {
              uint64_t v13 = 3;
            }
            sub_10004B96C(v11, (uint64_t)v12, v13);
            ++v10;
          }
        }
        if (*(unsigned char *)(v4 + 57))
        {
          sub_10004B96C(&v51, (uint64_t)", SA provisioned: ", 18);
          std::ostream::operator<<();
        }
        sub_10004B96C(&v51, (uint64_t)")", 1);
        sub_10004BC98((uint64_t)&v51 + 8, &v32);
        v50[0] = v30;
        *(xpc_object_t *)((char *)v50 + *(v30 - 3)) = v29;
        *(void *)&long long v51 = v28;
        if (SHIBYTE(v56) < 0) {
          operator delete(*((void **)&v55 + 1));
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        std::ios::~ios();
        if ((v34 & 0x80u) == 0) {
          unint64_t v14 = &v32;
        }
        else {
          unint64_t v14 = v32;
        }
        if ((v34 & 0x80u) == 0) {
          uint64_t v15 = v34;
        }
        else {
          uint64_t v15 = v33;
        }
        sub_10004B96C(v36, (uint64_t)v14, v15);
        if ((char)v34 < 0) {
          operator delete(v32);
        }
        char v5 = 0;
        v4 += 64;
      }
      while (v4 != v31);
    }
    sub_10004B96C(v36, (uint64_t)"}", 1);
    a2 = v27;
  }
  if (a1[3])
  {
    BOOL v16 = sub_10004B96C(v36, (uint64_t)" alt-server:\"", 13);
    uint64_t v17 = a1[3];
    uint64_t v67 = 0;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    *(_OWORD *)uint64_t v50 = 0u;
    sub_10004BD84((uint64_t)v50);
    sub_10004B96C(&v51, (uint64_t)"(", 1);
    if (*(unsigned char *)(v17 + 24))
    {
      unsigned int v18 = sub_10004B96C(&v51, (uint64_t)"url: ", 5);
      int v19 = *(char *)(v17 + 23);
      if (v19 >= 0) {
        uint64_t v20 = v17;
      }
      else {
        uint64_t v20 = *(void *)v17;
      }
      if (v19 >= 0) {
        uint64_t v21 = *(unsigned __int8 *)(v17 + 23);
      }
      else {
        uint64_t v21 = *(void *)(v17 + 8);
      }
      sub_10004B96C(v18, v20, v21);
    }
    sub_10004B96C(&v51, (uint64_t)")", 1);
    sub_10004BC98((uint64_t)&v51 + 8, &v32);
    *(xpc_object_t *)((char *)v50
    *(void *)&long long v51 = v22;
    if (SHIBYTE(v56) < 0) {
      operator delete(*((void **)&v55 + 1));
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    std::ios::~ios();
    if ((v34 & 0x80u) == 0) {
      uint64_t v23 = &v32;
    }
    else {
      uint64_t v23 = v32;
    }
    if ((v34 & 0x80u) == 0) {
      uint64_t v24 = v34;
    }
    else {
      uint64_t v24 = v33;
    }
    sub_10004B96C(v16, (uint64_t)v23, v24);
    if ((char)v34 < 0) {
      operator delete(v32);
    }
  }
  if (*((unsigned char *)a1 + 41))
  {
    sub_10004B96C(v36, (uint64_t)" primary-account-holder:\"", 25);
    std::ostream::operator<<();
  }
  sub_10004B96C(v36, (uint64_t)"}", 1);
  sub_10004BC98((uint64_t)v36 + 8, a2);
  *(void *)((char *)&v36[-1]
  *(void *)&v36[0] = v25;
  if (SHIBYTE(v38) < 0) {
    operator delete(v37[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100CF1348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_10008248C((uint64_t)&a26);
  _Unwind_Resume(a1);
}

uint64_t sub_100CF139C(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a2 + 4);
  if (*(unsigned char *)(a1 + 4)) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    if ((*(unsigned char *)(a1 + 4) != 0) != (v4 != 0)) {
      return 0;
    }
  }
  else if (*(_DWORD *)a1 != *(_DWORD *)a2)
  {
    return 0;
  }
  int v6 = *(unsigned __int8 *)(a2 + 9);
  if (*(unsigned char *)(a1 + 9)) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    if (*(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8)) {
      goto LABEL_17;
    }
    return 0;
  }
  if ((*(unsigned char *)(a1 + 9) != 0) != (v6 != 0)) {
    return 0;
  }
LABEL_17:
  if (*(unsigned char *)(a1 + 16) && *(unsigned char *)(a2 + 16))
  {
    if (*(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)) {
      return 0;
    }
  }
  else if ((*(unsigned char *)(a1 + 16) != 0) != (*(unsigned char *)(a2 + 16) != 0))
  {
    return 0;
  }
  uint64_t result = sub_100C8A1F4((uint64_t *)(a1 + 24), a2 + 24);
  if (result)
  {
    uint64_t result = (*(unsigned char *)(a1 + 57) != 0) == (*(unsigned char *)(a2 + 57) != 0);
    if (*(unsigned char *)(a1 + 57))
    {
      if (*(unsigned char *)(a2 + 57)) {
        return *(unsigned __int8 *)(a1 + 56) == *(unsigned __int8 *)(a2 + 56);
      }
    }
  }
  return result;
}

uint64_t sub_100CF14C8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3 - *(void *)a1 != *(void *)(a2 + 8) - *(void *)a2) {
    return 0;
  }
LABEL_2:
  if (v2 != v3)
  {
    uint64_t v6 = *(void *)a2;
    uint64_t v7 = *(void *)(a2 + 8);
    while (v6 != v7)
    {
      if (sub_100CF139C(v2, v6))
      {
        if (v6 == v7) {
          return 0;
        }
        v2 += 64;
        goto LABEL_2;
      }
      v6 += 64;
    }
    return 0;
  }
  if (*(void *)(a1 + 24) != *(void *)(a2 + 24)) {
    return 0;
  }
  int v9 = (*(unsigned char *)(a1 + 41) != 0) ^ (*(unsigned char *)(a2 + 41) != 0);
  if (*(unsigned char *)(a1 + 41))
  {
    if (*(unsigned char *)(a2 + 41)) {
      int v9 = *(unsigned __int8 *)(a1 + 40) != *(unsigned __int8 *)(a2 + 40);
    }
  }
  return v9 ^ 1u;
}

void sub_100CF15A0()
{
}

void sub_100CF1668(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void *sub_100CF169C(void *a1, void *a2, NSObject **a3)
{
  BOOL v5 = *a3;
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  sub_100058DB0(__p, "/phoneNumberSimNotification");
  v10[0] = off_101999E18;
  v10[1] = sub_100CF17E4;
  v10[3] = v10;
  sub_100A85938((uint64_t)a1, a2, &object, "server.pnr", (long long *)__p, (uint64_t)v10);
  sub_10008863C(v10);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  if (object) {
    dispatch_release(object);
  }
  *a1 = &off_101A50030;
  return a1;
}

void sub_100CF17AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, dispatch_object_t object, uint64_t a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(a1);
}

const char *sub_100CF17E4(int a1)
{
  char v1 = "server.pnr.?";
  if (a1 == 2) {
    char v1 = "server.pnr.2";
  }
  if (a1 == 1) {
    return "server.pnr.1";
  }
  else {
    return v1;
  }
}

void sub_100CF1810(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = a3[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 80);
  *(void *)(a1 + 72) = v4;
  *(void *)(a1 + 80) = v3;
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t sub_100CF1840@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 56));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, &v19);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)OsLogContext buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Registry does not contain GestaltUtilityInterface. File a radar!!", buf, 2u);
    }
    goto LABEL_14;
  }
LABEL_11:
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v11 + 72))(v11))
  {
    uint64_t v15 = 1;
    if (v12) {
      return v15;
    }
    goto LABEL_16;
  }
  unint64_t v14 = *(NSObject **)(a1 + 40);
  uint64_t v15 = 0;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v17 = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Device is Green Tea capable. Will strip out phone number.", v17, 2u);
LABEL_14:
    uint64_t v15 = 0;
  }
  if ((v12 & 1) == 0) {
LABEL_16:
  }
    sub_10004D2C8(v10);
  return v15;
}

void sub_100CF19E0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CF19FC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    buf.char var0 = 136315138;
    *(void *)&buf.var1 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s, checking to send phone number report to the server", (uint8_t *)&buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 56));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&buf.char var0 = v8;
  char v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&buf);
  if (v12)
  {
    uint64_t v13 = v12[3];
    unint64_t v14 = (std::__shared_weak_count *)v12[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v13) {
        goto LABEL_9;
      }
LABEL_15:
      memset(&v38, 0, sizeof(v38));
      if (!sub_100CF1840(a1, v15)) {
        goto LABEL_40;
      }
      subscriber::makeSimSlotRange();
      uint64_t v20 = v35;
      unint64_t v19 = v36;
      if (v35 == v36) {
        goto LABEL_42;
      }
      uint64_t v21 = v37;
      while ((v37(*v20) & 1) == 0)
      {
        if (++v20 == v36)
        {
          uint64_t v20 = v36;
          break;
        }
      }
      xpc_object_t v22 = v36;
      if (v20 == v36) {
        goto LABEL_42;
      }
      char v32 = v16;
      char v23 = 0;
      do
      {
        uint64_t v24 = *v20;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v41 = 0u;
        long long v40 = 0u;
        memset(&buf, 0, sizeof(buf));
        xpc_object_t v25 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v24);
        sub_100105A4C((Registry **)(a1 + 56), v25, v24, (uint64_t)&buf);
        if (BYTE8(v45))
        {
          CSIPhoneNumber::getBaseNumber((uint64_t *)__p, &buf);
          if ((v34 & 0x80u) == 0) {
            uint64_t v26 = __p;
          }
          else {
            uint64_t v26 = (void **)__p[0];
          }
          if ((v34 & 0x80u) == 0) {
            std::string::size_type v27 = v34;
          }
          else {
            std::string::size_type v27 = (std::string::size_type)__p[1];
          }
          std::string::append(&v38, (const std::string::value_type *)v26, v27);
          if ((char)v34 < 0) {
            operator delete(__p[0]);
          }
          char v23 = 1;
        }
        sub_10057CA94((uint64_t)&buf);
        xpc_object_t v28 = v20 + 1;
        uint64_t v20 = v19;
        if (v28 != v19)
        {
          uint64_t v20 = v28;
          while ((v21(*v20) & 1) == 0)
          {
            if (++v20 == v19)
            {
              uint64_t v20 = v19;
              break;
            }
          }
        }
      }
      while (v20 != v22);
      char v16 = v32;
      if ((v23 & 1) == 0)
      {
LABEL_42:
        xpc_object_t v29 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.var0) = 0;
          uint64_t v18 = 2;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Phone number is not available, will retry later", (uint8_t *)&buf, 2u);
        }
        else
        {
          uint64_t v18 = 2;
        }
      }
      else
      {
LABEL_40:
        if ((*(uint64_t (**)(uint64_t, std::string *))(*(void *)a1 + 48))(a1, &v38))
        {
          uint64_t v18 = (*(uint64_t (**)(uint64_t, std::string *))(*(void *)a1 + 16))(a1, &v38);
        }
        else
        {
          BOOL v30 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.var0) = 0;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I No need to send phone number report", (uint8_t *)&buf, 2u);
          }
          uint64_t v18 = 3;
        }
      }
      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v38.__r_.__value_.__l.__data_);
        if (v16) {
          return v18;
        }
      }
      else if (v16)
      {
        return v18;
      }
LABEL_50:
      sub_10004D2C8(v14);
      return v18;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v7);
  unint64_t v14 = 0;
  char v16 = 1;
  if (v13) {
    goto LABEL_15;
  }
LABEL_9:
  uint64_t v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.var0) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Registry does not contain SettingsController. File a radar!!", (uint8_t *)&buf, 2u);
  }
  uint64_t v18 = 4;
  if ((v16 & 1) == 0) {
    goto LABEL_50;
  }
  return v18;
}

void sub_100CF1E20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, std::__shared_weak_count *a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if ((v28 & 1) == 0) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CF1EA8(void *a1, unsigned __int8 **a2)
{
  uint64_t v21 = 0;
  DevicePersistentCopyValue((uint64_t *)buf, @"ReportedPhoneNumber", 0);
  sub_100056248(&v21, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (v21) {
    uint64_t v4 = sub_1000810B8;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    uint64_t v20 = *(void *)&buf[16];
    *(_OWORD *)OsLogContext __p = *(_OWORD *)buf;
    uint64_t v5 = HIBYTE(*(void *)&buf[16]);
    uint64_t v6 = a2[1];
    int v7 = *((char *)a2 + 23);
    if ((buf[23] & 0x80u) == 0) {
      uint64_t v8 = (unsigned __int8 *)HIBYTE(*(void *)&buf[16]);
    }
    else {
      uint64_t v8 = *(unsigned __int8 **)&buf[8];
    }
    if (v7 >= 0) {
      uint64_t v6 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
    }
    if (v8 != v6)
    {
LABEL_24:
      unsigned int v11 = a1[5];
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
LABEL_32:
        xpc_object_t object = xpc_null_create();
        (*(void (**)(void *, xpc_object_t *))(*a1 + 64))(a1, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        uint64_t v12 = 1;
        goto LABEL_33;
      }
      if ((v5 & 0x80u) == 0) {
        unint64_t v14 = __p;
      }
      else {
        unint64_t v14 = (void **)__p[0];
      }
      if (v7 >= 0) {
        int v9 = (unsigned __int8 *)a2;
      }
      else {
        int v9 = *a2;
      }
LABEL_31:
      *(_DWORD *)CSIPhoneNumber buf = 136315394;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Phone numbers are not matching, %s != %s, generating report", buf, 0x16u);
      goto LABEL_32;
    }
    if (v7 >= 0) {
      int v9 = (unsigned __int8 *)a2;
    }
    else {
      int v9 = *a2;
    }
    if ((buf[23] & 0x80) != 0)
    {
      unint64_t v14 = (void **)__p[0];
      int v16 = memcmp(__p[0], v9, *(size_t *)&buf[8]);
      unsigned int v11 = a1[5];
      BOOL v17 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
      if (v16)
      {
        if (!v17) {
          goto LABEL_32;
        }
        goto LABEL_31;
      }
      if (!v17) {
        goto LABEL_43;
      }
    }
    else
    {
      if (v5)
      {
        uint64_t v10 = 0;
        while (*((unsigned __int8 *)__p + v10) == v9[v10])
        {
          if (v5 == ++v10)
          {
            unsigned int v11 = a1[5];
            uint64_t v12 = 0;
            if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_33;
            }
            goto LABEL_40;
          }
        }
        goto LABEL_24;
      }
      unsigned int v11 = a1[5];
      uint64_t v12 = 0;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
LABEL_33:
        if (SHIBYTE(v20) < 0) {
          operator delete(__p[0]);
        }
        goto LABEL_35;
      }
LABEL_40:
      unint64_t v14 = __p;
    }
    *(_DWORD *)CSIPhoneNumber buf = 136315394;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Same phone numbers, saved: %s, current phone number: %s, not reporting again", buf, 0x16u);
LABEL_43:
    uint64_t v12 = 0;
    goto LABEL_33;
  }
  uint64_t v13 = a1[5];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I No saved phone number identity, generating report", buf, 2u);
  }
  uint64_t v12 = 1;
LABEL_35:
  sub_1000558F4(&v21);
  return v12;
}

void sub_100CF21BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100CF2234@<X0>(uint64_t a1@<X0>, CFDataRef *a2@<X8>)
{
  *a2 = 0;
  CFMutableDictionaryRef v45 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v5 = v45;
    CFMutableDictionaryRef v45 = Mutable;
    *(void *)&buf.char var0 = v5;
    sub_10005717C((const void **)&buf);
  }
  CFMutableDictionaryRef v44 = v45;
  if (v45) {
    CFRetain(v45);
  }
  uint64_t v6 = (os_log_t *)(a1 + 40);
  BOOL v7 = sub_100105644((os_log_t *)(a1 + 40), &v44, (Registry **)(a1 + 56));
  sub_10005717C((const void **)&v44);
  if (!v7)
  {
    unsigned int v11 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.var0) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Failed to add common key values", (uint8_t *)&buf, 2u);
    }
    return sub_10005717C((const void **)&v45);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 80);
  if (v8)
  {
    int v9 = std::__shared_weak_count::lock(v8);
    if (v9)
    {
      uint64_t v10 = *(void *)(a1 + 72);
      if (v10)
      {
        CFMutableDictionaryRef v43 = v45;
        if (v45) {
          CFRetain(v45);
        }
        (*(void (**)(uint64_t, CFMutableDictionaryRef *))(*(void *)v10 + 24))(v10, &v43);
        sub_10005717C((const void **)&v43);
        CFMutableDictionaryRef v42 = v45;
        if (v45) {
          CFRetain(v45);
        }
        (*(void (**)(uint64_t, CFMutableDictionaryRef *, uint64_t))(*(void *)v10 + 32))(v10, &v42, 1);
        sub_10005717C((const void **)&v42);
        goto LABEL_19;
      }
    }
  }
  else
  {
    int v9 = 0;
  }
  uint64_t v12 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.var0) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Could not get parent for adding device information in payload", (uint8_t *)&buf, 2u);
    if (!v9) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if (v9) {
LABEL_19:
  }
    sub_10004D2C8(v9);
LABEL_20:
  subscriber::makeSimSlotRange();
  unint64_t v14 = v39;
  uint64_t v13 = v40;
  if (v39 != v40)
  {
    uint64_t v15 = v41;
    while ((v15(*v14) & 1) == 0)
    {
      if (++v14 == v13)
      {
        unint64_t v14 = v13;
        break;
      }
    }
    int v16 = v40;
    while (v14 != v16)
    {
      uint64_t v17 = *v14;
      uint64_t v18 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v17);
      if (sub_100CF1840(a1, v19))
      {
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        memset(&buf, 0, sizeof(buf));
        sub_100105A4C((Registry **)(a1 + 56), v18, v17, (uint64_t)&buf);
        if (BYTE8(v38))
        {
          uint64_t v20 = *v18;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            CSIPhoneNumber::getBaseNumber((uint64_t *)&v47, &buf);
            uint64_t v21 = &v47;
            if (v48 < 0) {
              uint64_t v21 = (long long *)v47;
            }
            *(_DWORD *)std::string __dst = 136315138;
            *(void *)&__dst[4] = v21;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Setting the Phone Number: %s", __dst, 0xCu);
            if (SHIBYTE(v48) < 0) {
              operator delete((void *)v47);
            }
          }
          xpc_object_t v22 = v45;
          CFStringRef v23 = sub_100A8590C(v17);
          CSIPhoneNumber::getBaseNumber((uint64_t *)__p, &buf);
          if (SHIBYTE(v30) < 0)
          {
            sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string __dst = *(_OWORD *)__p;
            uint64_t v52 = v30;
          }
          long long v46 = 0;
          if (SHIBYTE(v52) < 0)
          {
            sub_10004FC84(&v47, *(void **)__dst, *(unint64_t *)&__dst[8]);
          }
          else
          {
            long long v47 = *(_OWORD *)__dst;
            uint64_t v48 = v52;
          }
          uint64_t v49 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v24 = v46;
            long long v46 = v49;
            uint64_t v50 = v24;
            sub_1000558F4(&v50);
          }
          if (SHIBYTE(v48) < 0) {
            operator delete((void *)v47);
          }
          CFPropertyListRef value = v46;
          long long v46 = 0;
          sub_1000558F4((const void **)&v46);
          if (SHIBYTE(v52) < 0) {
            operator delete(*(void **)__dst);
          }
          CFDictionarySetValue(v22, v23, value);
          sub_1000558F4((const void **)&value);
          if (SHIBYTE(v30) < 0) {
            operator delete(__p[0]);
          }
        }
        sub_10057CA94((uint64_t)&buf);
      }
      xpc_object_t v25 = v14 + 1;
      unint64_t v14 = v13;
      if (v25 != v13)
      {
        unint64_t v14 = v25;
        while ((v15(*v14) & 1) == 0)
        {
          if (++v14 == v13)
          {
            unint64_t v14 = v13;
            break;
          }
        }
      }
    }
  }
  CFDataRef Data = CFPropertyListCreateData(0, v45, kCFPropertyListXMLFormat_v1_0, 0, 0);
  CFDataRef v27 = *a2;
  *a2 = Data;
  *(void *)&buf.char var0 = v27;
  sub_100030068((const void **)&buf);
  return sub_10005717C((const void **)&v45);
}

void sub_100CF271C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100CF2814(uint64_t a1, xpc *a2)
{
  if (xpc_get_type(*(xpc_object_t *)a2) == (xpc_type_t)&_xpc_type_null)
  {
    return (const void **)DevicePersistentSaveValue(@"ReportedPhoneNumber", 0);
  }
  else
  {
    xpc::bridge((uint64_t *)&v5, a2, v3);
    DevicePersistentSaveValue();
    return sub_1000577C4(&v5);
  }
}

void sub_100CF28A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100CF28BC(uint64_t a1)
{
  sub_100A85CB8(a1);

  operator delete();
}

void sub_100CF28F4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100CF29C0(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100CF2A98);
  __cxa_rethrow();
}

void sub_100CF29E8(_Unwind_Exception *a1)
{
}

void sub_100CF2A00(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100CF2A38(uint64_t a1)
{
}

uint64_t sub_100CF2A54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100CF2A98(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t getContextIdForType@<X0>(Registry **a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  CFMutableDictionaryRef v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    BOOL v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v17);
  if (v10)
  {
    uint64_t v12 = v10[3];
    unsigned int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  unsigned int v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    uint64_t v14 = 0xFFFFFFFFLL;
    if (v13) {
      return v14;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 776))(v12);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 256))(v12, v15, a2);
  if ((v13 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v11);
  return v14;
}

void sub_100CF2C24(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t getInterfaceBytes(int a1)
{
  bzero(v4, 0x2C8uLL);
  *(_OWORD *)unint64_t v6 = xmmword_101565FC0;
  int v7 = a1;
  int v8 = 5;
  size_t v3 = 712;
  if (sysctl(v6, 6u, v4, &v3, 0, 0)) {
    return 0;
  }
  else {
    return v5;
  }
}

uint64_t getInternetInterfaceIndex(uint64_t a1, Registry **a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v6 = 0;
  sub_100CF2D74(a2, 1, (uint64_t *)__p);
  if (v6 >= 0) {
    char v2 = __p;
  }
  else {
    char v2 = (void **)__p[0];
  }
  unsigned int v3 = if_nametoindex((const char *)v2);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  if (v3) {
    return v3;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void sub_100CF2D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CF2D74@<X0>(Registry **a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v7;
  unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, &v17);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_7:
    if (v14) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 776))(v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13 + 256))(v13, v15, a2);
  if ((v14 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v12);
LABEL_13:
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  return CSIPDPManager::getInterfaceNameById();
}

void sub_100CF2EEC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t getTetheringInterfaceIndex(os_log_t *a1, Registry **a2, uint64_t a3)
{
  if (a3 == 16 || a3 == 0x8000000)
  {
    long long __p = 0uLL;
    uint64_t v10 = 0;
    sub_100CF2D74(a2, a3, (uint64_t *)&__p);
    if (v10 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    unsigned int v5 = if_nametoindex(p_p);
    if (v5) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = 0xFFFFFFFFLL;
    }
    if (SHIBYTE(v10) < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    unint64_t v7 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__p) = 134217984;
      *(void *)((char *)&__p + 4) = a3;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%08llX is not a tethering connection type", (uint8_t *)&__p, 0xCu);
    }
    return 0xFFFFFFFFLL;
  }
  return v6;
}

void sub_100CF3028(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sockaddrToString@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *a1;
  if (result) {
    uint64_t v4 = sub_10008324C;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4
    && (long long v28 = 0u,
        memset(v29, 0, sizeof(v29)),
        *(_OWORD *)std::string __s = 0u,
        __int16 v25 = 0,
        *(_DWORD *)uint64_t v24 = 0,
        BytePtr = (const sockaddr *)CFDataGetBytePtr((CFDataRef)result),
        uint64_t result = getnameinfo(BytePtr, BytePtr->sa_len, __s, 0x39u, v24, 6u, 10),
        !result))
  {
    v29[24] = 0;
    HIBYTE(v25) = 0;
    uint64_t v23 = 0;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    *(_OWORD *)long long __p = 0u;
    long long v12 = 0u;
    memset(v10, 0, sizeof(v10));
    sub_10004DE24((uint64_t)v10);
    size_t v6 = strlen(__s);
    unint64_t v7 = sub_10004B96C(v10, (uint64_t)__s, v6);
    char v26 = 44;
    int v8 = sub_10004B96C(v7, (uint64_t)&v26, 1);
    size_t v9 = strlen(v24);
    sub_10004B96C(v8, (uint64_t)v24, v9);
    sub_10004BC98((uint64_t)v10 + 8, a2);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[1]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    return std::ios::~ios();
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return result;
}

void sub_100CF3280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void cellplan::CellularPlanControllerPhone::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100CF3EEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,dispatch_object_t object,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  if (a29) {
    (*(void (**)(uint64_t))(*(void *)a29 + 8))(a29);
  }
  long long v33 = *(std::__shared_weak_count **)(v31 - 120);
  if (v33) {
    sub_10004D2C8(v33);
  }
  sub_10004D2C8(v30);
  _Unwind_Resume(a1);
}

void sub_100CF3FF4(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    dispatch_barrier_async_f(v2[3], v2, (dispatch_function_t)sub_100D15CB0);
    __cxa_rethrow();
  }
  JUMPOUT(0x100CF42A4);
}

void sub_100CF4020(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  __cxa_end_catch();
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (a12)
  {
    sub_10004D2C8(a12);
    if (!v12) {
LABEL_10:
    }
      JUMPOUT(0x100CF42A4);
  }
  else if (!v12)
  {
    goto LABEL_10;
  }
  dispatch_release(v12);
  goto LABEL_10;
}

void sub_100CF4030(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x100CF4034);
  }
  sub_10006A6AC(a1);
}

void sub_100CF4040(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,dispatch_object_t object,uint64_t a23,uint64_t a24,dispatch_object_t a25,uint64_t a26,uint64_t a27,uint64_t a28,dispatch_object_t a29,uint64_t a30)
{
  if (object) {
    dispatch_release(object);
  }
  if (a25) {
    dispatch_release(a25);
  }
  if (*(char *)(v33 - 105) < 0) {
    operator delete(*(void **)(v33 - 128));
  }
  long long v34 = (std::__shared_weak_count *)v30[35];
  if (v34) {
    sub_10004D2C8(v34);
  }
  long long v35 = (std::__shared_weak_count *)v30[33];
  if (v35) {
    sub_10004D2C8(v35);
  }
  long long v36 = (std::__shared_weak_count *)v30[31];
  if (v36) {
    sub_10004D2C8(v36);
  }
  long long v37 = (std::__shared_weak_count *)v30[29];
  if (v37) {
    sub_10004D2C8(v37);
  }
  long long v38 = (std::__shared_weak_count *)v30[27];
  if (v38) {
    sub_10004D2C8(v38);
  }
  long long v39 = (std::__shared_weak_count *)v30[25];
  if (v39) {
    sub_10004D2C8(v39);
  }
  long long v40 = (std::__shared_weak_count *)v30[23];
  if (v40) {
    sub_10004D2C8(v40);
  }
  long long v41 = (std::__shared_weak_count *)v30[21];
  if (v41) {
    sub_10004D2C8(v41);
  }
  CFMutableDictionaryRef v42 = (std::__shared_weak_count *)v30[19];
  if (v42) {
    sub_10004D2C8(v42);
  }
  CFMutableDictionaryRef v43 = (std::__shared_weak_count *)v30[17];
  if (v43) {
    sub_10004D2C8(v43);
  }
  CFMutableDictionaryRef v44 = (std::__shared_weak_count *)v30[15];
  if (v44) {
    std::__shared_weak_count::__release_weak(v44);
  }
  CFMutableDictionaryRef v45 = (std::__shared_weak_count *)v30[13];
  if (v45) {
    sub_10004D2C8(v45);
  }
  CellularPlanMultiplexerDelegate::~CellularPlanMultiplexerDelegate(v32);
  uint64_t v46 = v30[6];
  v30[6] = 0;
  if (v46) {
    (*(void (**)(uint64_t))(*(void *)v46 + 8))(v46);
  }
  ctu::OsLogLogger::~OsLogLogger(v31);
  sub_100087E88(a10);
  JUMPOUT(0x100CF41F0);
}

void sub_100CF4284(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100CF428C()
{
}

const char *sub_100CF42AC(int a1)
{
  uint64_t v1 = "cp.ctr.ph.?";
  if (a1 == 2) {
    uint64_t v1 = "cp.ctr.ph.2";
  }
  if (a1 == 1) {
    return "cp.ctr.ph.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_100CF42D8(uint64_t a1)
{
  *(void *)a1 = off_101A50108;
  *(void *)(a1 + 56) = off_101A503A0;
  *(void *)(a1 + 64) = off_101A503D8;
  *(void *)(a1 + 72) = off_101A50498;
  *(void *)(a1 + 80) = off_101A504D8;
  char v2 = (CellularPlanMultiplexerDelegate *)(a1 + 88);
  *(void *)(a1 + 88) = off_101A50558;
  sub_1003DAC14(a1 + 1224);
  unsigned int v3 = *(const void **)(a1 + 1216);
  if (v3) {
    _Block_release(v3);
  }
  if (*(unsigned char *)(a1 + 1208))
  {
    if (*(char *)(a1 + 1207) < 0) {
      operator delete(*(void **)(a1 + 1184));
    }
    sub_1000558F4((const void **)(a1 + 1176));
    sub_1000558F4((const void **)(a1 + 1168));
    if (*(char *)(a1 + 1159) < 0) {
      operator delete(*(void **)(a1 + 1136));
    }
    if (*(char *)(a1 + 1135) < 0) {
      operator delete(*(void **)(a1 + 1112));
    }
  }
  sub_100D15E74(*(void **)(a1 + 1096));
  uint64_t v4 = *(const void **)(a1 + 1080);
  if (v4) {
    _Block_release(v4);
  }
  sub_1000886C0(a1 + 1048, *(char **)(a1 + 1056));
  unsigned int v5 = *(void **)(a1 + 1008);
  if (v5)
  {
    *(void *)(a1 + 1016) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void *)(a1 + 1000);
  *(void *)(a1 + 1000) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  if (*(char *)(a1 + 999) < 0) {
    operator delete(*(void **)(a1 + 976));
  }
  sub_10005D144(*(void **)(a1 + 960));
  sub_10005D144(*(void **)(a1 + 936));
  long long v22 = (void **)(a1 + 896);
  sub_100150960(&v22);
  sub_100087ED0(a1 + 872, *(void **)(a1 + 880));
  sub_10030AAD0(a1 + 848, *(void **)(a1 + 856));
  sub_1000346F8(a1 + 824, *(void **)(a1 + 832));
  sub_1000346F8(a1 + 800, *(void **)(a1 + 808));
  sub_100087784(a1 + 744);
  sub_100D15E20(*(atomic_uint ***)(a1 + 720));
  sub_1003C8134((unsigned char *)(a1 + 600));
  sub_100D151FC((void *)(a1 + 568));
  long long v22 = (void **)(a1 + 544);
  sub_1003DACB8(&v22);
  if (*(char *)(a1 + 527) < 0) {
    operator delete(*(void **)(a1 + 504));
  }
  if (*(unsigned char *)(a1 + 464))
  {
    if (*(char *)(a1 + 495) < 0) {
      operator delete(*(void **)(a1 + 472));
    }
    *(unsigned char *)(a1 + 464) = 0;
  }
  if (*(unsigned char *)(a1 + 432))
  {
    if (*(char *)(a1 + 463) < 0) {
      operator delete(*(void **)(a1 + 440));
    }
    *(unsigned char *)(a1 + 432) = 0;
  }
  if (*(char *)(a1 + 431) < 0) {
    operator delete(*(void **)(a1 + 408));
  }
  long long v22 = (void **)(a1 + 360);
  sub_1000C56F4(&v22);
  if (*(char *)(a1 + 351) < 0) {
    operator delete(*(void **)(a1 + 328));
  }
  long long v22 = (void **)(a1 + 304);
  sub_10008A88C(&v22);
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 296);
  if (v7) {
    sub_10004D2C8(v7);
  }
  int v8 = *(std::__shared_weak_count **)(a1 + 280);
  if (v8) {
    sub_10004D2C8(v8);
  }
  size_t v9 = *(std::__shared_weak_count **)(a1 + 264);
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 248);
  if (v10) {
    sub_10004D2C8(v10);
  }
  unsigned int v11 = *(std::__shared_weak_count **)(a1 + 232);
  if (v11) {
    sub_10004D2C8(v11);
  }
  long long v12 = *(std::__shared_weak_count **)(a1 + 216);
  if (v12) {
    sub_10004D2C8(v12);
  }
  long long v13 = *(std::__shared_weak_count **)(a1 + 200);
  if (v13) {
    sub_10004D2C8(v13);
  }
  long long v14 = *(std::__shared_weak_count **)(a1 + 184);
  if (v14) {
    sub_10004D2C8(v14);
  }
  long long v15 = *(std::__shared_weak_count **)(a1 + 168);
  if (v15) {
    sub_10004D2C8(v15);
  }
  long long v16 = *(std::__shared_weak_count **)(a1 + 152);
  if (v16) {
    sub_10004D2C8(v16);
  }
  long long v17 = *(std::__shared_weak_count **)(a1 + 136);
  if (v17) {
    sub_10004D2C8(v17);
  }
  long long v18 = *(std::__shared_weak_count **)(a1 + 120);
  if (v18) {
    std::__shared_weak_count::__release_weak(v18);
  }
  long long v19 = *(std::__shared_weak_count **)(a1 + 104);
  if (v19) {
    sub_10004D2C8(v19);
  }
  CellularPlanMultiplexerDelegate::~CellularPlanMultiplexerDelegate(v2);
  uint64_t v20 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100CF4694(uint64_t a1)
{
  return sub_100CF42D8(a1 - 56);
}

uint64_t sub_100CF469C(uint64_t a1)
{
  return sub_100CF42D8(a1 - 64);
}

uint64_t sub_100CF46A4(uint64_t a1)
{
  return sub_100CF42D8(a1 - 72);
}

uint64_t sub_100CF46AC(uint64_t a1)
{
  return sub_100CF42D8(a1 - 80);
}

uint64_t sub_100CF46B4(uint64_t a1)
{
  return sub_100CF42D8(a1 - 88);
}

void sub_100CF46BC(uint64_t a1)
{
  sub_100CF42D8(a1);

  operator delete();
}

void sub_100CF46F4(uint64_t a1)
{
  sub_100CF42D8(a1 - 56);

  operator delete();
}

void sub_100CF4730(uint64_t a1)
{
  sub_100CF42D8(a1 - 64);

  operator delete();
}

void sub_100CF476C(uint64_t a1)
{
  sub_100CF42D8(a1 - 72);

  operator delete();
}

void sub_100CF47A8(uint64_t a1)
{
  sub_100CF42D8(a1 - 80);

  operator delete();
}

void sub_100CF47E4(uint64_t a1)
{
  sub_100CF42D8(a1 - 88);

  operator delete();
}

void sub_100CF4820(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2 || (v3 = *(Registry **)(a1 + 8), (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  unsigned int v5 = v4;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v4);
  sub_100058DB0(__p, "/cc/props/carrier_entitlements_info");
  uint64_t v6 = (Registry **)operator new(0x28uLL);
  *uint64_t v6 = (Registry *)off_101A510F8;
  v6[1] = (Registry *)(a1 + 848);
  v6[2] = (Registry *)a1;
  std::string v6[3] = v3;
  int v6[4] = (Registry *)v5;
  char v32 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  (***(void (****)(Registry **__return_ptr))(a1 + 128))(&v30);
  Registry::createRestModuleOneTimeUseConnection(&v26, v30);
  ctu::RestModule::connect();
  if (v27) {
    sub_10004D2C8(v27);
  }
  if (v31) {
    sub_10004D2C8(v31);
  }
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  unint64_t v7 = (Registry **)operator new(0x28uLL);
  *unint64_t v7 = (Registry *)off_101A51178;
  v7[1] = (Registry *)(a1 + 304);
  _DWORD v7[2] = (Registry *)a1;
  v7[3] = (Registry *)sub_100CF5008;
  _OWORD v7[4] = 0;
  char v32 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/remote_vinyl_info");
  int v8 = (Registry **)operator new(0x28uLL);
  std::__shared_weak_count *v8 = (Registry *)off_101A511F8;
  v8[1] = (Registry *)(a1 + 328);
  _OWORD v8[2] = (Registry *)a1;
  void v8[3] = (Registry *)sub_100CF5700;
  void v8[4] = 0;
  char v32 = v8;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/remote_provisioning_device_identifiers");
  size_t v9 = (Registry **)operator new(0x28uLL);
  std::__shared_weak_count *v9 = (Registry *)off_101A51278;
  v9[1] = (Registry *)(a1 + 408);
  CFTypeRef v9[2] = (Registry *)a1;
  void v9[3] = (Registry *)sub_100CF5F48;
  void v9[4] = 0;
  char v32 = v9;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/family_provisioning_device_info");
  uint64_t v10 = (Registry **)operator new(0x28uLL);
  std::__shared_weak_count *v10 = (Registry *)off_101A512F8;
  v10[1] = (Registry *)(a1 + 544);
  v10[2] = (Registry *)a1;
  v10[3] = (Registry *)sub_100CF601C;
  _OWORD v10[4] = 0;
  char v32 = v10;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/user_preferred_data_slot");
  unsigned int v11 = (Registry **)operator new(0x28uLL);
  std::__shared_weak_count *v11 = (Registry *)off_101A51378;
  v11[1] = (Registry *)(a1 + 400);
  v11[2] = (Registry *)a1;
  v11[3] = (Registry *)sub_100CF6D28;
  _OWORD v11[4] = 0;
  char v32 = v11;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100CF6D58((void *)(a1 + 568), a1 + 288);
  sub_100058DB0(__p, "/cc/props/regulatory_restriction_active");
  uint64_t v30 = (Registry *)off_101A51488;
  uint64_t v31 = (std::__shared_weak_count *)(a1 + 1044);
  char v32 = &v30;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_1002D80F0(a1 + 736);
  sub_100BB0998(a1 + 737);
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  long long v12 = (Registry **)operator new(0x28uLL);
  std::__shared_weak_count *v12 = (Registry *)off_101A51508;
  v12[1] = (Registry *)(a1 + 744);
  _OWORD v12[2] = (Registry *)a1;
  void v12[3] = (Registry *)sub_100CF6E18;
  void v12[4] = 0;
  char v32 = v12;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_10012E338(a1 + 800);
  sub_100C0E2B8(a1 + 824);
  sub_1005BE214(a1 + 872);
  sub_100058DB0(__p, "/cc/props/remote_paired_device_list");
  long long v13 = (Registry **)operator new(0x28uLL);
  std::__shared_weak_count *v13 = (Registry *)off_101A51588;
  v13[1] = (Registry *)(a1 + 896);
  _OWORD v13[2] = (Registry *)a1;
  _OWORD v13[3] = (Registry *)sub_100CF6E54;
  v13[4] = 0;
  char v32 = v13;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_1008F2A18(a1 + 920);
  sub_100058DB0(__p, "/cc/events/dump_state");
  long long v14 = (Registry **)operator new(0x20uLL);
  std::__shared_weak_count *v14 = (Registry *)off_101A51608;
  v14[1] = (Registry *)a1;
  v14[2] = (Registry *)sub_100CF6FFC;
  void v14[3] = 0;
  char v32 = v14;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  (*(void (**)(void))(**(void **)(a1 + 144) + 24))(*(void *)(a1 + 144));
  (*(void (**)(void))(**(void **)(a1 + 208) + 288))(*(void *)(a1 + 208));
  (***(void (****)(Registry **__return_ptr))(a1 + 128))(&v30);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v15, v30);
  long long v17 = ServiceMap;
  if (v18 < 0)
  {
    long long v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v18;
  long long v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)__p);
  if (v22)
  {
    uint64_t v24 = v22[3];
    uint64_t v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  uint64_t v23 = 0;
LABEL_35:
  __int16 v25 = *(std::__shared_weak_count **)(a1 + 232);
  *(void *)(a1 + 224) = v24;
  *(void *)(a1 + 232) = v23;
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (v31) {
    sub_10004D2C8(v31);
  }
}

void sub_100CF4F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100CF5008(uint64_t a1, _DWORD **a2)
{
  (***(void (****)(_OWORD *__return_ptr))(a1 + 128))(v44);
  v45[0] = v44[0];
  v44[0] = 0uLL;
  subscriber::makeSimSlotRange();
  if (*((void *)&v45[0] + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v45[0] + 1));
  }
  if (*((void *)&v44[0] + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v44[0] + 1));
  }
  unsigned int v5 = v38;
  uint64_t v4 = v39;
  if (v38 != v39)
  {
    uint64_t v6 = v40;
    while ((v40(*v5) & 1) == 0)
    {
      if (++v5 == v39)
      {
        unsigned int v5 = v39;
        break;
      }
    }
    unint64_t v7 = v39;
    if (v5 != v39)
    {
      int v8 = 0;
      size_t v9 = (uint64_t *)(a1 + 1056);
      while (1)
      {
        unsigned int v37 = 0;
        unsigned int v37 = *v5;
        memset(v45, 0, sizeof(v45));
        sub_100CCD910(v37, (_DWORD **)(a1 + 304), (char *)v45);
        memset(v44, 0, sizeof(v44));
        sub_100CCD910(v37, a2, (char *)v44);
        if (!LOBYTE(v45[0]) || !LOBYTE(v44[0])) {
          goto LABEL_72;
        }
        if (subscriber::isSimReady()) {
          goto LABEL_43;
        }
        if (!LOBYTE(v45[0])) {
          goto LABEL_85;
        }
        if (!subscriber::isSimReady())
        {
LABEL_43:
          if (!LOBYTE(v45[0])) {
LABEL_85:
          }
            __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
          v8 |= subscriber::isSimAbsent();
          goto LABEL_72;
        }
        *(_OWORD *)long long __p = 0u;
        long long v43 = 0u;
        sub_100CF9568((uint64_t)__p, a1, v37);
        if (LOBYTE(__p[0])) {
          break;
        }
LABEL_71:
        int v8 = 1;
LABEL_72:
        sub_1003DD210(v44);
        sub_1003DD210(v45);
        long long v34 = v5 + 1;
        unsigned int v5 = v4;
        if (v34 != v4)
        {
          unsigned int v5 = v34;
          while ((v6(*v5) & 1) == 0)
          {
            if (++v5 == v4)
            {
              unsigned int v5 = v4;
              break;
            }
          }
        }
        if (v5 == v7) {
          goto LABEL_82;
        }
      }
      uint64_t v10 = *v9;
      if (*v9)
      {
        uint64_t v11 = a1 + 1056;
        do
        {
          signed int v12 = *(_DWORD *)(v10 + 32);
          BOOL v13 = v12 < (int)v37;
          if (v12 >= (int)v37) {
            long long v14 = (uint64_t *)v10;
          }
          else {
            long long v14 = (uint64_t *)(v10 + 8);
          }
          if (!v13) {
            uint64_t v11 = v10;
          }
          uint64_t v10 = *v14;
        }
        while (*v14);
        if ((uint64_t *)v11 != v9 && (signed int)v37 >= *(_DWORD *)(v11 + 32))
        {
          *(void *)CSIPhoneNumber buf = &v37;
          long long v15 = sub_10008CC40((uint64_t **)(a1 + 1048), (int *)&v37, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
          if (!LOBYTE(__p[0])) {
            __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
          }
          uint64_t v16 = *((unsigned __int8 *)v15 + 63);
          if ((v16 & 0x80u) == 0) {
            long long v17 = (uint64_t *)*((unsigned __int8 *)v15 + 63);
          }
          else {
            long long v17 = v15[6];
          }
          uint64_t v18 = (uint64_t *)HIBYTE(v43);
          int v19 = SHIBYTE(v43);
          if (v43 < 0) {
            uint64_t v18 = (uint64_t *)v43;
          }
          if (v17 == v18)
          {
            uint64_t v20 = (const void **)(v15 + 5);
            unsigned int v21 = __p[1];
            if (v43 >= 0) {
              long long v22 = &__p[1];
            }
            else {
              long long v22 = (void **)__p[1];
            }
            if ((v16 & 0x80) != 0)
            {
              if (memcmp(*v20, v22, (size_t)v15[6])) {
                goto LABEL_46;
              }
            }
            else if (*((unsigned char *)v15 + 63))
            {
              while (*(unsigned __int8 *)v20 == *(unsigned __int8 *)v22)
              {
                uint64_t v20 = (const void **)((char *)v20 + 1);
                long long v22 = (void **)((char *)v22 + 1);
                if (!--v16) {
                  goto LABEL_79;
                }
              }
              goto LABEL_46;
            }
LABEL_79:
            if ((v19 & 0x80000000) == 0) {
              goto LABEL_71;
            }
            goto LABEL_70;
          }
        }
      }
LABEL_46:
      uint64_t v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = subscriber::asString();
        *(_DWORD *)CSIPhoneNumber buf = 136315138;
        *(void *)&uint8_t buf[4] = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I New sim swap in slot %s", buf, 0xCu);
      }
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 128) + 640))(buf);
      unsigned int v25 = (*(uint64_t (**)(void, void))(**(void **)buf + 56))(*(void *)buf, v37);
      sub_1002C74D0((uint64_t **)(a1 + 952), v37, &v37)[5] = (uint64_t *)v25;
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      memset(buf, 0, sizeof(buf));
      uint64_t v26 = *(void *)(a1 + 360);
      if (*(void *)(a1 + 368) == v26 || !*(unsigned char *)(a1 + 352))
      {
        if (*(void *)(a1 + 544) == *(void *)(a1 + 552))
        {
LABEL_57:
          uint64_t v28 = *(void *)(a1 + 1000);
          if (v28)
          {
            (*(void (**)(uint64_t))(*(void *)v28 + 16))(v28);
            uint64_t v29 = *(void *)(a1 + 1000);
            *(void *)(a1 + 1000) = 0;
            if (v29) {
              (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
            }
          }
          if (*(void *)(a1 + 256))
          {
            uint64_t v30 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long v36 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "reset provisioning - 4FF change", v36, 2u);
            }
            uint64_t v31 = a1 + 328;
            if (*(unsigned char *)(a1 + 1224)) {
              uint64_t v31 = a1 + 1368;
            }
            uint64_t v33 = v31 + 32;
            uint64_t v32 = *(void *)(v31 + 32);
            if (*(void *)(v33 + 8) != v32)
            {
              *(_OWORD *)CSIPhoneNumber buf = *(_OWORD *)(v32 + 16);
              (*(void (**)(void, uint8_t *))(**(void **)(a1 + 256) + 152))(*(void *)(a1 + 256), buf);
            }
          }
          if (!LOBYTE(__p[0]) || (SHIBYTE(v43) & 0x80000000) == 0) {
            goto LABEL_71;
          }
          unsigned int v21 = __p[1];
LABEL_70:
          operator delete(v21);
          goto LABEL_71;
        }
      }
      else
      {
        *(_OWORD *)CSIPhoneNumber buf = *(_OWORD *)(v26 + 16);
      }
      CFDataRef v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v36 = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Have a remote device paired", v36, 2u);
      }
      sub_100CF7880(a1, v37);
      goto LABEL_57;
    }
  }
  LOBYTE(v8) = 0;
LABEL_82:
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 160) + 64))(*(void *)(a1 + 160), a1 + 304);
  uint64_t result = sub_100CF76C4(a1);
  if (v8) {
    return (unsigned char *)(*(uint64_t (**)(void))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96));
  }
  return result;
}

void sub_100CF5668(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53)
{
  if (a23)
  {
    if (a29 < 0) {
      operator delete(__p);
    }
  }
  sub_1003DD210(&a30);
  sub_1003DD210(&a52);
  _Unwind_Resume(a1);
}

void sub_100CF5700(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 328;
  if (RemoteVinylInfo::operator==())
  {
    unsigned int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I RemoteVinylInfo: No update", buf, 2u);
    }
    return;
  }
  long long v53 = 0uLL;
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I RemoteVinylInfo: Updating", buf, 2u);
  }
  uint64_t v7 = *(void *)(a1 + 256);
  if (*(unsigned char *)(a1 + 352))
  {
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 360);
      if (*(void *)(a1 + 368) != v8)
      {
        long long v53 = *(_OWORD *)(v8 + 16);
        uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 104))(v7);
        if (v9 != (void)v53 || v10 != *((void *)&v53 + 1))
        {
          signed int v12 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)CSIPhoneNumber buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "reset provisioning - ongoing for another csn", buf, 2u);
          }
          (*(void (**)(void))(**(void **)(a1 + 256) + 160))(*(void *)(a1 + 256));
        }
      }
    }
  }
  else
  {
    if (v7)
    {
      uint64_t v13 = *(void *)(a1 + 360);
      if (*(void *)(a1 + 368) != v13)
      {
        long long v53 = *(_OWORD *)(v13 + 16);
        uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 104))(v7);
        if (v14 == (void)v53 && v15 == *((void *)&v53 + 1))
        {
          long long v17 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)CSIPhoneNumber buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "reset provisioning - left proximity", buf, 2u);
          }
          (*(void (**)(void, long long *))(**(void **)(a1 + 256) + 152))(*(void *)(a1 + 256), &v53);
        }
      }
    }
    LODWORD(v47) = 0;
    *(void *)&v46[0] = 0;
    memset(buf, 0, sizeof(buf));
    BYTE8(v46[0]) = 0;
    memset((char *)v46 + 12, 0, 34);
    int v18 = RemoteVinylInfo::operator==();
    v44.__r_.__value_.__r.__words[0] = (std::string::size_type)&v46[1];
    sub_1000C56F4((void ***)&v44);
    if (SBYTE7(v46[0]) < 0)
    {
      operator delete(*(void **)buf);
      if (!v18) {
        goto LABEL_34;
      }
    }
    else if (!v18)
    {
      goto LABEL_34;
    }
    int v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Detected all remote devices un-paired", buf, 2u);
    }
    uint64_t v20 = *(void *)(a1 + 192);
    if (v20)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 40))(v20, 3, 10);
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 192) + 40))(*(void *)(a1 + 192), 3, 12);
    }
  }
LABEL_34:
  uint64_t v21 = *(void *)(a1 + 360);
  uint64_t v22 = *(void *)(a1 + 368);
  memset(&v44, 0, sizeof(v44));
  if (v21 != v22)
  {
    *(_OWORD *)CSIPhoneNumber buf = 0u;
    v46[0] = 0u;
    sub_1000C5E38((uint64_t)buf, v21 + 56);
    if (BYTE8(v46[0]))
    {
      uint64_t v23 = *(void *)buf;
      if (*(void *)buf != *(void *)&buf[8])
      {
        while (!*(unsigned char *)(v23 + 89))
        {
          v23 += 216;
          if (v23 == *(void *)&buf[8]) {
            goto LABEL_42;
          }
        }
      }
      if (v23 == *(void *)&buf[8] || (std::string::operator=(&v44, (const std::string *)(v23 + 16)), BYTE8(v46[0])))
      {
LABEL_42:
        long long v41 = buf;
        sub_1000C57C8((void ***)&v41);
      }
    }
    std::string::size_type size = HIBYTE(v44.__r_.__value_.__r.__words[2]);
    if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v44.__r_.__value_.__l.__size_;
    }
    if (size) {
      (*(void (**)(void, uint64_t, std::string *))(**(void **)(a1 + 160) + 88))(*(void *)(a1 + 160), 1, &v44);
    }
  }
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 160) + 32))(*(void *)(a1 + 160), v4);
  sub_100CF7414(a1);
  sub_100CF76C4(a1);
  uint64_t v25 = *(void *)(a2 + 32);
  uint64_t v26 = *(void *)(a2 + 40);
  if (v26 != v25 && *(unsigned char *)(a2 + 24))
  {
    long long v53 = *(_OWORD *)(v25 + 16);
    uint64_t v27 = *(void *)(a1 + 360);
    uint64_t v28 = *(void *)(a1 + 368);
LABEL_79:
    unint64_t v38 = *(unsigned int *)(v25 + 12) | (unint64_t)&_mh_execute_header;
    goto LABEL_80;
  }
  uint64_t v27 = *(void *)(a1 + 360);
  uint64_t v28 = *(void *)(a1 + 368);
  if (v28 != v27 && *(unsigned char *)(a1 + 352))
  {
    long long v53 = *(_OWORD *)(v27 + 16);
    uint64_t v29 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Detected a remote device paired", buf, 2u);
    }
    (*(void (**)(void))(**(void **)(a1 + 96) + 48))(*(void *)(a1 + 96));
    (***(void (****)(long long *__return_ptr))(a1 + 128))(&v40);
    *(_OWORD *)CSIPhoneNumber buf = v40;
    long long v40 = 0uLL;
    subscriber::makeSimSlotRange();
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (*((void *)&v40 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v40 + 1));
    }
    uint64_t v31 = v41;
    uint64_t v30 = v42;
    if (v41 != (uint8_t *)v42)
    {
      uint64_t v32 = v43;
      while ((v32(*(unsigned int *)v31) & 1) == 0)
      {
        v31 += 4;
        if (v31 == (uint8_t *)v30)
        {
          uint64_t v31 = (uint8_t *)v30;
          break;
        }
      }
      uint64_t v33 = v42;
LABEL_64:
      while (v31 != (uint8_t *)v33)
      {
        uint64_t v34 = *(unsigned int *)v31;
        uint64_t v35 = *(void *)(a1 + 192);
        if (v35)
        {
          int v36 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v35 + 32))(v35, *(unsigned int *)v31, 10);
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 192) + 32))(*(void *)(a1 + 192), v34, 12);
        }
        else
        {
          int v36 = 6;
        }
        uint64_t v52 = 0;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v47 = 0u;
        memset(v46, 0, sizeof(v46));
        *(_OWORD *)CSIPhoneNumber buf = 0u;
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 160) + 248))(buf);
        if (buf[0] && v36 == 2 && !*(void *)(a1 + 1000) && v50 == 3) {
          sub_100CF7880(a1, v34);
        }
        sub_1003DD2D4(buf);
        unsigned int v37 = v31 + 4;
        uint64_t v31 = (uint8_t *)v30;
        if (v37 != (uint8_t *)v30)
        {
          uint64_t v31 = v37;
          while ((v32(*(unsigned int *)v31) & 1) == 0)
          {
            v31 += 4;
            if (v31 == (uint8_t *)v30)
            {
              uint64_t v31 = (uint8_t *)v30;
              goto LABEL_64;
            }
          }
        }
      }
    }
    goto LABEL_87;
  }
  if (v26 != v25) {
    goto LABEL_79;
  }
  unint64_t v38 = 0;
LABEL_80:
  if (v27 != v28)
  {
    if (HIDWORD(v38) && *(_DWORD *)(v27 + 12) == v38) {
      goto LABEL_83;
    }
LABEL_85:
    long long v39 = (void (**)(void))(**(void **)(a1 + 96) + 48);
    goto LABEL_86;
  }
  if (HIDWORD(v38)) {
    goto LABEL_85;
  }
LABEL_83:
  long long v39 = (void (**)(void))(**(void **)(a1 + 96) + 16);
LABEL_86:
  (*v39)();
LABEL_87:
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
}

void sub_100CF5EAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a23)
  {
    a11 = &a20;
    sub_1000C57C8((void ***)&a11);
  }
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CF5F48(uint64_t a1)
{
  int v2 = cellplan::RemoteDeviceIdentifiers::operator!=();
  unsigned int v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "false";
    if (v2) {
      uint64_t v4 = "true";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I RemoteDeviceIdentifiers updated: %s", (uint8_t *)&v5, 0xCu);
  }
  if (v2) {
    sub_100CF7414(a1);
  }
}

void sub_100CF601C(uint64_t a1, uint64_t *a2)
{
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 160) + 56))(*(void *)(a1 + 160), a1 + 544);
  uint64_t v4 = *(void *)(a1 + 544);
  uint64_t v5 = *(void *)(a1 + 552);
  if (v4 != v5)
  {
    uint64_t v6 = v60;
    uint64_t v7 = (std::string *)&__p[1];
    while (1)
    {
      uint64_t v9 = *a2;
      uint64_t v8 = a2[1];
      uint64_t v10 = *a2;
      if (*a2 == v8)
      {
        uint64_t v11 = *a2;
      }
      else
      {
        while ((cellplan::RemoteProvisioningDeviceInfo::operator==() & 1) == 0)
        {
          v10 += 216;
          if (v10 == v8)
          {
            uint64_t v10 = v8;
            break;
          }
        }
        uint64_t v11 = a2[1];
      }
      if (v10 != v11) {
        goto LABEL_49;
      }
      long long v75 = 0uLL;
      uint64_t v76 = 0;
      sub_100311ED8(&v75, *(void *)(v4 + 176), *(void *)(v4 + 184), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(v4 + 184) - *(void *)(v4 + 176)) >> 3));
      if ((void)v75 != *((void *)&v75 + 1))
      {
        uint64_t v12 = *(void *)(a1 + 256);
        if (v12)
        {
          if (*(void *)(a1 + 1080))
          {
            long long v74 = *(_OWORD *)(v75 + 16);
            *(void *)CSIPhoneNumber buf = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 104))(v12);
            *(void *)&uint8_t buf[8] = v13;
            if (*(void *)buf == (void)v74 && v13 == *((void *)&v74 + 1))
            {
              if (*((void *)&v75 + 1) == (void)v75) {
                sub_10015B728();
              }
              if (*(unsigned char *)(v75 + 80) && *(void *)(v75 + 56) != *(void *)(v75 + 64))
              {
                long long v51 = v7;
                uint64_t v52 = (uint64_t)v6;
                uint64_t v21 = *a2;
                uint64_t v22 = a2[1];
                *(_OWORD *)long long v72 = v74;
                if (v21 == v22)
                {
                  uint64_t v7 = v51;
                }
                else
                {
                  do
                  {
                    memset(buf, 0, sizeof(buf));
                    *(void *)&long long v59 = 0;
                    sub_100311ED8(buf, *(void *)(v21 + 176), *(void *)(v21 + 184), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(v21 + 184) - *(void *)(v21 + 176)) >> 3));
                    if (*(void *)buf == *(void *)&buf[8])
                    {
                      *(void *)&long long v53 = buf;
                      sub_1000C56F4((void ***)&v53);
                    }
                    else
                    {
                      BOOL v24 = *(void *)(*(void *)buf + 16) != *(void *)v72
                         || *(void *)(*(void *)buf + 24) != *(void *)&v72[8];
                      *(void *)&long long v53 = buf;
                      sub_1000C56F4((void ***)&v53);
                      if (!v24) {
                        goto LABEL_67;
                      }
                    }
                    v21 += 216;
                  }
                  while (v21 != v22);
                  uint64_t v21 = v22;
LABEL_67:
                  uint64_t v7 = v51;
                  uint64_t v6 = (void **)v52;
                  if (v21 != a2[1])
                  {
                    *(_OWORD *)long long v72 = 0u;
                    long long v73 = 0u;
                    uint64_t v25 = *(void *)(v21 + 176);
                    if (*(void *)(v21 + 184) == v25) {
                      sub_10015B728();
                    }
                    sub_1000C5E38((uint64_t)v72, v25 + 56);
                    if (BYTE8(v73))
                    {
                      if (*((void *)&v75 + 1) == (void)v75) {
                        sub_10015B728();
                      }
                      if (0x84BDA12F684BDA13 * ((uint64_t)(*(void *)(v75 + 64) - *(void *)(v75 + 56)) >> 3) <= 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)&v72[8] - *(void *)v72) >> 3)) {
                        goto LABEL_84;
                      }
                    }
                    uint64_t v26 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)CSIPhoneNumber buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I leverage VinylInfoInd as fetch response", buf, 2u);
                    }
                    uint64_t v27 = *(void *)(a1 + 160);
                    int v28 = *(_DWORD *)(a1 + 1040);
                    uint64_t v55 = 0;
                    long long v54 = 0uLL;
                    v56[0] = 0;
                    char v57 = 0;
                    sub_1003DB514((uint64_t)buf, v28, &v54, (uint64_t)v56, 0);
                    (*(void (**)(uint64_t, void, uint8_t *))(*(void *)v27 + 96))(v27, 0, buf);
                    if (v71) {
                      sub_1000C584C(v52);
                    }
                    if (SHIBYTE(v59) < 0) {
                      operator delete(*(void **)&buf[8]);
                    }
                    if (v57) {
                      sub_1000C584C((uint64_t)v56);
                    }
                    if (SHIBYTE(v55) < 0) {
                      operator delete((void *)v54);
                    }
                    if (*((void *)&v75 + 1) == (void)v75) {
                      sub_10015B728();
                    }
                    uint64_t v29 = *(void *)(a1 + 1080);
                    buf[0] = 0;
                    sub_1000C5DA8((uint64_t)&buf[8], v75);
                    buf[0] = 1;
                    (*(void (**)(uint64_t, void, uint8_t *))(v29 + 16))(v29, 0, buf);
                    sub_1000C60A0(buf);
                    if (BYTE8(v73))
                    {
LABEL_84:
                      *(void *)CSIPhoneNumber buf = v72;
                      sub_1000C57C8((void ***)buf);
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (*(unsigned char *)v4) {
        break;
      }
LABEL_29:
      long long v69 = 0u;
      long long v70 = 0u;
      *(_OWORD *)uint64_t v67 = 0u;
      memset(__p, 0, sizeof(__p));
      long long v65 = 0u;
      *(_OWORD *)long long v66 = 0u;
      long long v63 = 0u;
      *(_OWORD *)long long v64 = 0u;
      long long v61 = 0u;
      *(_OWORD *)long long v62 = 0u;
      long long v59 = 0u;
      *(_OWORD *)long long v60 = 0u;
      *(_OWORD *)CSIPhoneNumber buf = 0u;
      cellplan::RemoteDeviceIdentifiers::operator=();
      std::string::operator=(v7, (const std::string *)(v4 + 144));
      __p[4] = *(void **)(v4 + 168);
      if (v7 != (std::string *)(v4 + 144)) {
        sub_1003DB294((uint64_t)&__p[5], *(void *)(v4 + 176), *(void *)(v4 + 184), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(v4 + 184) - *(void *)(v4 + 176)) >> 3));
      }
      uint64_t v20 = *(void *)(v4 + 200);
      DWORD2(v70) = *(_DWORD *)(v4 + 208);
      *(void *)&long long v70 = v20;
      (*(void (**)(void, uint8_t *))(**(void **)(a1 + 176) + 32))(*(void *)(a1 + 176), buf);
      *(void *)long long v72 = &__p[5];
      sub_1000C56F4((void ***)v72);
      if (SHIBYTE(__p[3]) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(v67[0]) < 0) {
        operator delete(v66[0]);
      }
      if (BYTE8(v63))
      {
        if (SBYTE7(v65) < 0) {
          operator delete(v64[0]);
        }
        BYTE8(v63) = 0;
      }
      if (BYTE8(v61))
      {
        if (SBYTE7(v63) < 0) {
          operator delete(v62[0]);
        }
        BYTE8(v61) = 0;
      }
      if (SBYTE7(v61) < 0) {
        operator delete(v60[0]);
      }
      if (buf[0] && SHIBYTE(v59) < 0) {
        operator delete(*(void **)&buf[8]);
      }
      *(void *)CSIPhoneNumber buf = &v75;
      sub_1000C56F4((void ***)buf);
LABEL_49:
      v4 += 216;
      if (v4 == v5) {
        goto LABEL_86;
      }
    }
    if (v11 != a2[1])
    {
      uint64_t v15 = v9 + 8 * ((v10 - v9) >> 3);
      uint64_t v16 = *(void *)(v15 + 176);
      if (v16 == *(void *)(v15 + 184)) {
        unint64_t v17 = 0;
      }
      else {
        unint64_t v17 = *(unsigned int *)(v16 + 12) | (unint64_t)&_mh_execute_header;
      }
      uint64_t v18 = *(void *)(v4 + 176);
      if (v18 == *(void *)(v4 + 184))
      {
        if (!HIDWORD(v17))
        {
LABEL_25:
          int v19 = (void (**)(void))(**(void **)(a1 + 96) + 16);
LABEL_28:
          (*v19)();
          goto LABEL_29;
        }
      }
      else if (HIDWORD(v17) && *(_DWORD *)(v18 + 12) == v17)
      {
        goto LABEL_25;
      }
    }
    int v19 = (void (**)(void))(**(void **)(a1 + 96) + 48);
    goto LABEL_28;
  }
LABEL_86:
  if (*a2 != a2[1] && *(void *)(a1 + 544) == *(void *)(a1 + 552))
  {
    uint64_t v30 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Detected all altAccount devices un-paired", buf, 2u);
    }
    uint64_t v31 = *(void *)(a1 + 192);
    if (v31)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v31 + 40))(v31, 3, 11);
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 192) + 40))(*(void *)(a1 + 192), 3, 14);
    }
  }
  uint64_t v32 = *(void *)(a1 + 544);
  uint64_t v33 = *(void *)(a1 + 552);
  if (v32 != v33)
  {
    while (!*(unsigned char *)v32)
    {
      v32 += 216;
      if (v32 == v33) {
        goto LABEL_108;
      }
    }
  }
  if (v32 == v33)
  {
LABEL_108:
    buf[0] = 0;
    LOBYTE(v62[0]) = 0;
    LOBYTE(v64[0]) = 0;
    LOBYTE(v66[1]) = 0;
    LODWORD(v69) = 0;
    long long v59 = 0uLL;
    *(void *)&uint8_t buf[8] = 0;
    LOBYTE(v60[0]) = 0;
    long long v65 = 0uLL;
    v64[1] = 0;
    LOBYTE(v66[0]) = 0;
    v67[1] = 0;
    __p[0] = 0;
    v67[0] = 0;
    LOBYTE(__p[1]) = 0;
    memset((char *)&__p[1] + 4, 0, 34);
    *(unsigned char *)(a1 + 1224) = 0;
    cellplan::RemoteDeviceIdentifiers::operator=();
    long long v41 = (void **)(a1 + 1368);
    if (*(char *)(a1 + 1391) < 0) {
      operator delete(*v41);
    }
    *(_OWORD *)long long v41 = *(_OWORD *)v67;
    *(void **)(a1 + 1384) = __p[0];
    HIBYTE(__p[0]) = 0;
    LOBYTE(v67[0]) = 0;
    *(void **)(a1 + 1392) = __p[1];
    sub_1003DB434((void **)(a1 + 1400));
    *(_OWORD *)(a1 + 1400) = *(_OWORD *)&__p[2];
    *(void **)(a1 + 1416) = __p[4];
    memset(&__p[2], 0, 24);
    *(void **)(a1 + 1424) = __p[5];
    *(_DWORD *)(a1 + 1432) = v69;
    *(void *)long long v72 = &__p[2];
  }
  else
  {
    *(void *)&long long v69 = 0;
    *(_OWORD *)uint64_t v67 = 0u;
    memset(__p, 0, sizeof(__p));
    long long v65 = 0u;
    *(_OWORD *)long long v66 = 0u;
    long long v63 = 0u;
    *(_OWORD *)long long v64 = 0u;
    long long v61 = 0u;
    *(_OWORD *)long long v62 = 0u;
    long long v59 = 0u;
    *(_OWORD *)long long v60 = 0u;
    *(_OWORD *)CSIPhoneNumber buf = 0u;
    sub_1003DB738((uint64_t)buf, a1 + 1224);
    *(unsigned char *)(a1 + 1224) = *(unsigned char *)v32;
    cellplan::RemoteDeviceIdentifiers::operator=();
    std::string::operator=((std::string *)(a1 + 1368), (const std::string *)(v32 + 144));
    *(void *)(a1 + 1392) = *(void *)(v32 + 168);
    if (a1 + 1224 != v32) {
      sub_1003DB294(a1 + 1400, *(void *)(v32 + 176), *(void *)(v32 + 184), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(v32 + 184) - *(void *)(v32 + 176)) >> 3));
    }
    uint64_t v34 = *(void *)(v32 + 200);
    *(_DWORD *)(a1 + 1432) = *(_DWORD *)(v32 + 208);
    *(void *)(a1 + 1424) = v34;
    long long v75 = 0uLL;
    uint64_t v35 = *(void *)(v32 + 176);
    if (*(void *)(v32 + 184) == v35)
    {
      CFMutableDictionaryRef v42 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v72 = 0;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#E Cannot find EID", v72, 2u);
      }
    }
    else
    {
      long long v75 = *(_OWORD *)(v35 + 16);
      uint64_t v36 = *(void *)(a1 + 256);
      if (v36)
      {
        uint64_t v37 = (*(uint64_t (**)(uint64_t))(*(void *)v36 + 104))(v36);
        if (v37 != (void)v75 || v38 != *((void *)&v75 + 1))
        {
          long long v40 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long v72 = 0;
            _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Switched to a different gizmo while provisioning ongoing", v72, 2u);
          }
          (*(void (**)(void))(**(void **)(a1 + 256) + 160))(*(void *)(a1 + 256));
        }
      }
    }
    if (!LOBYTE(__p[1]) && *(unsigned char *)(a1 + 1392))
    {
      long long v43 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v72 = 0;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I Detected an altAccount device being switched", v72, 2u);
      }
      (***(void (****)(long long *__return_ptr))(a1 + 128))(&v53);
      long long v74 = v53;
      long long v53 = 0uLL;
      subscriber::makeSimSlotRange();
      if (*((void *)&v74 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v74 + 1));
      }
      if (*((void *)&v53 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v53 + 1));
      }
      CFMutableDictionaryRef v45 = *(unsigned int **)v72;
      std::string v44 = *(unsigned int **)&v72[8];
      if (*(void *)v72 != *(void *)&v72[8])
      {
        uint64_t v46 = (uint64_t (*)(void))v73;
        while ((v46(*v45) & 1) == 0)
        {
          if (++v45 == v44)
          {
            CFMutableDictionaryRef v45 = v44;
            break;
          }
        }
        long long v47 = *(unsigned int **)&v72[8];
LABEL_127:
        while (v45 != v47)
        {
          uint64_t v48 = *(void *)(a1 + 192);
          if (v48)
          {
            uint64_t v49 = *v45;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v48 + 32))(v48, v49, 11);
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 192) + 32))(*(void *)(a1 + 192), v49, 14);
          }
          long long v50 = v45 + 1;
          CFMutableDictionaryRef v45 = v44;
          if (v50 != v44)
          {
            CFMutableDictionaryRef v45 = v50;
            while ((v46(*v45) & 1) == 0)
            {
              if (++v45 == v44)
              {
                CFMutableDictionaryRef v45 = v44;
                goto LABEL_127;
              }
            }
          }
        }
      }
      sub_100CF7954(a1, 1);
    }
    *(void *)long long v72 = &__p[2];
  }
  sub_1000C56F4((void ***)v72);
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v67[0]);
  }
  if (SHIBYTE(v65) < 0) {
    operator delete(v64[1]);
  }
  if (LOBYTE(v62[0]))
  {
    if (SHIBYTE(v63) < 0) {
      operator delete(v62[1]);
    }
    LOBYTE(v62[0]) = 0;
  }
  if (LOBYTE(v60[0]))
  {
    if (SHIBYTE(v61) < 0) {
      operator delete(v60[1]);
    }
    LOBYTE(v60[0]) = 0;
  }
  if (SHIBYTE(v59) < 0) {
    operator delete(*(void **)&buf[8]);
  }
}

void sub_100CF6C24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,int a52,__int16 a53,char a54,char a55)
{
  if (*(unsigned char *)(v55 - 152))
  {
    a15 = v55 - 176;
    sub_1000C57C8((void ***)&a15);
  }
  *(void *)(v55 - 144) = v55 - 128;
  sub_1000C56F4((void ***)(v55 - 144));
  _Unwind_Resume(a1);
}

uint64_t sub_100CF6D28(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 160) + 72))(*(void *)(a1 + 160), a1 + 400);
}

uint64_t sub_100CF6D58(void *a1, uint64_t a2)
{
  v4[0] = off_101A513F8;
  v4[1] = a2;
  v4[3] = v4;
  sub_100D17234(v4, a1);
  sub_100D151FC(v4);
  uint64_t result = a1[3];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 48))(result, a1 + 4);
  }
  return result;
}

uint64_t sub_100CF6E18(uint64_t result)
{
  if (*(unsigned __int8 *)(result + 744) - 1 <= 2) {
    return (*(uint64_t (**)(void))(**(void **)(result + 96) + 16))();
  }
  return result;
}

void sub_100CF6E54(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 1208)) {
    return;
  }
  for (uint64_t i = *(void *)(a1 + 896); i != *(void *)(a1 + 904); i += 184)
  {
    if (*(unsigned char *)(i + 177) == 1) {
      return;
    }
  }
  (***(void (****)(Registry **__return_ptr))(a1 + 128))(&v15);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, v15);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v17);
  if (!v10)
  {
    uint64_t v12 = 0;
    goto LABEL_13;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11)
  {
LABEL_13:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    goto LABEL_14;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
LABEL_14:
  uint64_t v14 = a1 + 1112;
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v12) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 16))(v12, v14);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  sub_100D15518(v14);
}

void sub_100CF6FD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CF6FFC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 144);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 192))(v2);
  }
  (*(void (**)(void))(**(void **)(a1 + 160) + 296))(*(void *)(a1 + 160));
  uint64_t v3 = *(void *)(a1 + 256);
  if (v3)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v10[0] = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 104))(v3);
      v10[1] = v5;
      (*(void (**)(void))(**(void **)(a1 + 256) + 104))(*(void *)(a1 + 256));
      ctu::hex((uint64_t *)__p, (ctu *)v10, (const void *)0x10, v6);
      uint64_t v7 = v12 >= 0 ? __p : *(unsigned char **)__p;
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      uint64_t v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Provisioning in flight for (%s)", buf, 0xCu);
      if (v12 < 0) {
        operator delete(*(void **)__p);
      }
    }
  }
  if (*(unsigned char *)(a1 + 1208))
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v9 = (void *)(a1 + 1112);
      if (*(char *)(a1 + 1135) < 0) {
        unsigned int v9 = (void *)*v9;
      }
      *(_DWORD *)long long __p = 136315138;
      *(void *)&__p[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Suppressing until ready Notification: (%s)", __p, 0xCu);
    }
  }
}

uint64_t sub_100CF71F0(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 144) + 32))(*(void *)(a1 + 144));

  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 288));
}

void sub_100CF724C(unsigned char *a1, uint64_t a2, uint64_t a3)
{
  if (*(_OWORD *)a3 == 0) {
    goto LABEL_17;
  }
  long long v27 = 0uLL;
  uint64_t v4 = *(void *)(a2 + 360);
  if (*(void *)(a2 + 368) != v4) {
    long long v27 = *(_OWORD *)(v4 + 16);
  }
  if ((void)v27 != *(void *)a3 || *((void *)&v27 + 1) != *(void *)(a3 + 8))
  {
    uint64_t v6 = *(void *)(a2 + 544);
    uint64_t v7 = *(void *)(a2 + 552);
    if (v6 != v7)
    {
      uint64_t v8 = v6 + 144;
      while (1)
      {
        uint64_t v9 = *(void *)(v8 + 32);
        if (*(void *)(v8 + 40) != v9) {
          long long v27 = *(_OWORD *)(v9 + 16);
        }
        if ((void)v27 == *(void *)a3 && *((void *)&v27 + 1) == *(void *)(a3 + 8)) {
          break;
        }
        uint64_t v11 = v8 + 72;
        v8 += 216;
        if (v11 == v7) {
          goto LABEL_17;
        }
      }
      sub_100D15280((uint64_t)v13, 1, (long long *)v8, (long long *)(v8 - 136));
      sub_100D15364((uint64_t)a1, (uint64_t)v13);
      goto LABEL_20;
    }
LABEL_17:
    *a1 = 0;
    a1[8] = 0;
    a1[88] = 0;
    return;
  }
  sub_100D15280((uint64_t)v13, 0, (long long *)(a2 + 328), (long long *)(a2 + 408));
  sub_100D15364((uint64_t)a1, (uint64_t)v13);
LABEL_20:
  if (v26 < 0) {
    operator delete(__p);
  }
  if (v22)
  {
    if (v24 < 0) {
      operator delete(v23);
    }
    char v22 = 0;
  }
  if (v19)
  {
    if (v21 < 0) {
      operator delete(v20);
    }
    char v19 = 0;
  }
  if (v18 < 0) {
    operator delete(v17);
  }
  char v12 = (void **)&v16;
  sub_1000C56F4(&v12);
  if (v15 < 0) {
    operator delete(v14);
  }
}

void sub_100CF73F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100D15474((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100CF7414(uint64_t a1)
{
  uint64_t v24 = 0;
  memset(v23, 0, sizeof(v23));
  *(_OWORD *)std::string __s1 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v15 = 0u;
  *(_OWORD *)uint64_t v16 = 0u;
  long long v13 = 0u;
  *(_OWORD *)uint64_t v14 = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  *(_OWORD *)char v12 = 0u;
  long long v10 = 0u;
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 160) + 208))(&v10);
  if ((_BYTE)v10 && *(unsigned char *)(a1 + 432))
  {
    uint64_t v2 = BYTE7(v22);
    if ((SBYTE7(v22) & 0x80u) == 0) {
      uint64_t v3 = (void *)BYTE7(v22);
    }
    else {
      uint64_t v3 = __s1[1];
    }
    uint64_t v4 = (void *)*(unsigned __int8 *)(a1 + 431);
    int v5 = (char)v4;
    if ((char)v4 < 0) {
      uint64_t v4 = *(void **)(a1 + 416);
    }
    if (v3 == v4)
    {
      if (v5 >= 0) {
        uint64_t v6 = (unsigned __int8 *)(a1 + 408);
      }
      else {
        uint64_t v6 = *(unsigned __int8 **)(a1 + 408);
      }
      if ((BYTE7(v22) & 0x80) == 0)
      {
        if (BYTE7(v22))
        {
          uint64_t v7 = __s1;
          while (*(unsigned __int8 *)v7 == *v6)
          {
            uint64_t v7 = (void **)((char *)v7 + 1);
            ++v6;
            if (!--v2) {
              goto LABEL_40;
            }
          }
          goto LABEL_19;
        }
LABEL_40:
        cellplan::RemoteDeviceIdentifiers::operator=();
        if (!(_BYTE)v10) {
          __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
        }
        (*(void (**)(void, char *))(**(void **)(a1 + 176) + 32))(*(void *)(a1 + 176), (char *)&v10 + 8);
        goto LABEL_21;
      }
      if (!memcmp(__s1[0], v6, (size_t)__s1[1])) {
        goto LABEL_40;
      }
    }
  }
LABEL_19:
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v9[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot update db, remote device info unavailable yet", (uint8_t *)v9, 2u);
  }
LABEL_21:
  if ((_BYTE)v10)
  {
    v9[0] = (void **)v23;
    sub_1000C56F4(v9);
    if (SBYTE7(v22) < 0) {
      operator delete(__s1[0]);
    }
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[1]);
    }
    if (LOBYTE(v16[0]))
    {
      if (SHIBYTE(v17) < 0) {
        operator delete(v16[1]);
      }
      LOBYTE(v16[0]) = 0;
    }
    if (LOBYTE(v14[0]))
    {
      if (SHIBYTE(v15) < 0) {
        operator delete(v14[1]);
      }
      LOBYTE(v14[0]) = 0;
    }
    if (SHIBYTE(v13) < 0) {
      operator delete(v12[1]);
    }
    if (BYTE8(v10))
    {
      if (SHIBYTE(v12[0]) < 0) {
        operator delete(v11[0]);
      }
    }
  }
}

void sub_100CF76A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

unsigned char *sub_100CF76C4(uint64_t a1)
{
  long long v2 = 0uLL;
  memset(v8, 0, sizeof(v8));
  if (*(unsigned char *)(a1 + 600))
  {
    sub_1003C8068((uint64_t)v8, (long long *)(a1 + 608));
    long long v2 = 0uLL;
  }
  v7[5] = v2;
  v7[6] = v2;
  v7[3] = v2;
  _OWORD v7[4] = v2;
  v7[1] = v2;
  _DWORD v7[2] = v2;
  v7[0] = v2;
  (*(void (**)(_OWORD *__return_ptr))(**(void **)(a1 + 160) + 216))(v7);
  int v3 = *(unsigned __int8 *)(a1 + 600);
  int v4 = LOBYTE(v7[0]);
  if (*(unsigned char *)(a1 + 600) && LOBYTE(v7[0]))
  {
    if (cellplan::operator==()) {
      goto LABEL_16;
    }
    int v3 = *(unsigned __int8 *)(a1 + 600);
    int v4 = LOBYTE(v7[0]);
  }
  else if ((v3 != 0) != (LOBYTE(v7[0]) == 0))
  {
    goto LABEL_16;
  }
  if (v3)
  {
    if (v4) {
      sub_1003DF16C(a1 + 600, (uint64_t)v7 + 8);
    }
    else {
      sub_1003C816C(a1 + 600);
    }
  }
  else if (v4)
  {
    sub_1003C8068(a1 + 600, (_OWORD *)((char *)v7 + 8));
  }
  uint64_t v5 = *(void *)(a1 + 592);
  if (v5) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 48))(v5, a1 + 600);
  }
LABEL_16:
  sub_1003C8134(v7);
  return sub_1003C8134(v8);
}

void sub_100CF7854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
}

void sub_100CF7880(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100CF8EAC;
  uint64_t v5[3] = &unk_101A505A8;
  _OWORD v5[4] = a1;
  int v4 = _Block_copy(v5);
  uint64_t v6 = v4;
  sub_100CF79E4(a1, a2, 0, 1, &v6);
  if (v4) {
    _Block_release(v4);
  }
}

void sub_100CF7934(_Unwind_Exception *exception_object)
{
  if (v1) {
    _Block_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CF7954(uint64_t a1, char a2)
{
  int v4 = _Block_copy(&stru_101A50E80);
  uint64_t v5 = v4;
  sub_100CF79E4(a1, 3, 0, a2, &v5);
  if (v4) {
    _Block_release(v4);
  }
}

void sub_100CF79C4(_Unwind_Exception *exception_object)
{
  if (v1) {
    _Block_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CF79E4(uint64_t a1, uint64_t a2, unsigned int a3, char a4, void **a5)
{
  v80[0] = 0;
  v80[1] = v80;
  v80[2] = 0x2000000000;
  char v81 = 0;
  v77[0] = 0;
  v77[1] = v77;
  v77[2] = 0x4002000000;
  v77[3] = sub_100D08FD4;
  v79[0] = 0;
  v79[1] = 0;
  v77[4] = sub_100D09010;
  std::string::size_type v78 = v79;
  (***(void (****)(unsigned char *__return_ptr))(a1 + 128))(v113);
  long long buf = *(_OWORD *)v113;
  *(_OWORD *)uint64_t v113 = 0uLL;
  subscriber::makeSimSlotRange();
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (*(void *)&v113[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v113[8]);
  }
  uint64_t v8 = v74;
  uint64_t v7 = v75;
  if (v74 != v75)
  {
    uint64_t v9 = v76;
    while ((v76(*v8) & 1) == 0)
    {
      if (++v8 == v75)
      {
        uint64_t v8 = v75;
        break;
      }
    }
    long long v65 = v75;
    if (v8 != v75)
    {
      int v10 = 0;
      long long v63 = (uint64_t *)(a1 + 936);
      long long v60 = (uint64_t *)(a1 + 960);
      do
      {
        uint64_t v11 = *v8;
        memset(&__p, 0, sizeof(__p));
        if (a2 == 3) {
          goto LABEL_25;
        }
        (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 160) + 280))(&buf);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        __p.__r_.__value_.__r.__words[2] = v105;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = buf;
        if (SBYTE7(v105) < 0)
        {
          if (__p.__r_.__value_.__l.__size_ == 32)
          {
            char v12 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_25;
            }
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            goto LABEL_22;
          }
          *__p.__r_.__value_.__l.__data_ = 0;
          __p.__r_.__value_.__l.__size_ = 0;
        }
        else
        {
          if (SBYTE7(v105) == 32)
          {
            char v12 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_25;
            }
            p_p = &__p;
LABEL_22:
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = p_p;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Pending subscription device id (%s)", (uint8_t *)&buf, 0xCu);
            goto LABEL_25;
          }
          __p.__r_.__value_.__s.__data_[0] = 0;
          *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
        }
LABEL_25:
        int v14 = v10 + 1;
        aBlock[0] = _NSConcreteStackBlock;
        aBlock[1] = 1174405120;
        aBlock[2] = sub_100D09020;
        aBlock[3] = &unk_101A50BB8;
        int v71 = v11;
        aBlock[4] = v77;
        aBlock[5] = v80;
        aBlock[6] = a1;
        char v72 = v14;
        long long v15 = *a5;
        int v67 = v14;
        if (*a5) {
          long long v15 = _Block_copy(v15);
        }
        uint64_t v16 = a2;
        long long v70 = v15;
        long long v17 = _Block_copy(aBlock);
        int v94 = v11;
        char v18 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v11);
        (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 128) + 640))(&buf);
        long long v68 = v17;
        uint64_t v93 = 0;
        char v19 = (*(uint64_t (**)(void, const void **, uint64_t))(*(void *)buf + 16))(buf, &v93, v11);
        sub_100057D78(&v93);
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v19)
        {
          long long v20 = v68;
          (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 128) + 640))(v113);
          (*(void (**)(long long *__return_ptr))(**(void **)v113 + 152))(&buf);
          uint64_t v21 = (**(uint64_t (***)(void))buf)(buf);
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          if (*(void *)&v113[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v113[8]);
          }
          if (a4) {
            goto LABEL_69;
          }
          uint64_t v22 = *v63;
          if (!*v63) {
            goto LABEL_69;
          }
          uint64_t v23 = a1 + 936;
          do
          {
            int v24 = *(_DWORD *)(v22 + 32);
            BOOL v25 = v24 < (int)v11;
            if (v24 >= (int)v11) {
              char v26 = (uint64_t *)v22;
            }
            else {
              char v26 = (uint64_t *)(v22 + 8);
            }
            if (!v25) {
              uint64_t v23 = v22;
            }
            uint64_t v22 = *v26;
          }
          while (*v26);
          if ((uint64_t *)v23 == v63) {
            goto LABEL_69;
          }
          if (*(_DWORD *)(v23 + 32) > (int)v11) {
            goto LABEL_69;
          }
          uint64_t v27 = *v60;
          if (!*v60) {
            goto LABEL_69;
          }
          uint64_t v28 = a1 + 960;
          do
          {
            int v29 = *(_DWORD *)(v27 + 32);
            BOOL v30 = v29 < (int)v11;
            if (v29 >= (int)v11) {
              uint64_t v31 = (uint64_t *)v27;
            }
            else {
              uint64_t v31 = (uint64_t *)(v27 + 8);
            }
            if (!v30) {
              uint64_t v28 = v27;
            }
            uint64_t v27 = *v31;
          }
          while (*v31);
          if ((uint64_t *)v28 == v60
            || *(_DWORD *)(v28 + 32) > (int)v11
            || (uint64_t v32 = sub_1002C74D0((uint64_t **)(a1 + 928), v11, &v94)[5],
                v21 - (uint64_t)v32 >= 1000000000 * (uint64_t)sub_1002C74D0((uint64_t **)(a1 + 952), v11, &v94)[5]))
          {
LABEL_69:
            uint64_t v35 = *v18;
            if (os_log_type_enabled(*v18, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I fetching subscription info", (uint8_t *)&buf, 2u);
            }
            memset(v112, 0, sizeof(v112));
            long long v20 = v68;
            sub_100CF9568((uint64_t)v112, a1, v11);
            if (!LOBYTE(v112[0])
              || *(void *)(a1 + 360) == *(void *)(a1 + 368) && *(void *)(a1 + 544) == *(void *)(a1 + 552))
            {
              long long v40 = *v18;
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "no iccid or no Watch paired", (uint8_t *)&buf, 2u);
              }
              long long v109 = 0u;
              long long v110 = 0u;
              long long v107 = 0u;
              long long v108 = 0u;
              long long v105 = 0u;
              long long v106 = 0u;
              long long buf = 0u;
              (*((void (**)(void *, uint64_t, long long *))v68 + 2))(v68, 3, &buf);
              *(void *)uint64_t v113 = (char *)&v109 + 8;
              sub_10023F96C((void ***)v113);
              *(void *)uint64_t v113 = &v108;
              sub_10023FA88((void ***)v113);
              a2 = v16;
              int v10 = v67;
              if ((_BYTE)v106)
              {
                if (SHIBYTE(v107) < 0) {
                  operator delete(*((void **)&v106 + 1));
                }
                LOBYTE(v106) = 0;
              }
              if ((_BYTE)buf && SHIBYTE(v105) < 0)
              {
                long long v41 = (void *)*((void *)&buf + 1);
                goto LABEL_156;
              }
            }
            else
            {
              memset(v111, 0, sizeof(v111));
              long long v109 = 0u;
              long long v110 = 0u;
              long long v107 = 0u;
              long long v108 = 0u;
              long long v105 = 0u;
              long long v106 = 0u;
              long long buf = 0u;
              std::string::operator=((std::string *)&buf, (const std::string *)&v112[1]);
              std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string::size_type size = __p.__r_.__value_.__l.__size_;
              }
              if (size) {
                sub_10032AFC0((unsigned char *)&v105 + 8, &__p);
              }
              if (!BYTE8(v105))
              {
                (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 128) + 640))(v113);
                int v38 = (*(uint64_t (**)(void, uint64_t))(**(void **)v113 + 88))(*(void *)v113, v11);
                if (*(void *)&v113[8]) {
                  sub_10004D2C8(*(std::__shared_weak_count **)&v113[8]);
                }
                if (v38)
                {
                  uint64_t v39 = *(void *)(a1 + 360);
                  if (*(void *)(a1 + 368) != v39)
                  {
                    long long v103 = *(_OWORD *)(v39 + 16);
                    ctu::hex((uint64_t *)v113, (ctu *)&v103, (const void *)0x10, v37);
                    if (BYTE8(v105))
                    {
                      if (SBYTE7(v107) < 0) {
                        operator delete((void *)v106);
                      }
                      long long v106 = *(_OWORD *)v113;
                      *(void *)&long long v107 = *(void *)&v113[16];
                    }
                    else
                    {
                      long long v106 = *(_OWORD *)v113;
                      *(void *)&long long v107 = *(void *)&v113[16];
                      BYTE8(v105) = 1;
                    }
                    uint64_t v42 = *(void *)(a1 + 360);
                    uint64_t v43 = *(void *)(a1 + 368);
                    memset(v92, 0, sizeof(v92));
                    sub_100311ED8(v92, v42, v43, 0x2E8BA2E8BA2E8BA3 * ((v43 - v42) >> 3));
                    sub_100CF9E88(a1, v11, v92, (uint64_t *)&v109);
                    *(void *)uint64_t v113 = v92;
                    sub_1000C56F4((void ***)v113);
                  }
                }
                long long v20 = v68;
                if (!BYTE8(v105) && *(unsigned char *)(a1 + 1224))
                {
                  long long v103 = 0uLL;
                  uint64_t v59 = *(void *)(a1 + 1400);
                  if (*(void *)(a1 + 1408) != v59)
                  {
                    long long v103 = *(_OWORD *)(v59 + 16);
                    ctu::hex((uint64_t *)v113, (ctu *)&v103, (const void *)0x10, v37);
                    if (BYTE8(v105))
                    {
                      if (SBYTE7(v107) < 0) {
                        operator delete((void *)v106);
                      }
                      long long v106 = *(_OWORD *)v113;
                      *(void *)&long long v107 = *(void *)&v113[16];
                    }
                    else
                    {
                      long long v106 = *(_OWORD *)v113;
                      *(void *)&long long v107 = *(void *)&v113[16];
                      BYTE8(v105) = 1;
                    }
                  }
                  if (*(unsigned char *)(a1 + 1256)) {
                    std::string::operator=((std::string *)((char *)&v107 + 8), (const std::string *)(a1 + 1264));
                  }
                }
              }
              *(_DWORD *)uint64_t v113 = 11;
              std::string v44 = sub_1009127C8((uint64_t **)(a1 + 1088), 11, v113);
              if (*((_DWORD *)sub_1005BD92C(v44 + 5, v11, &v94) + 8) == 2)
              {
                memset(&v113[32], 0, 32);
                memset(v113, 0, 32);
                *(_DWORD *)&v113[32] = 3;
                v113[36] = 1;
                if (BYTE8(v110))
                {
                  std::string::operator=((std::string *)v111, (const std::string *)v113);
                  *(void *)&v111[24] = *(void *)&v113[24];
                  *(void *)&v111[29] = *(void *)&v113[29];
                  std::string::operator=((std::string *)&v111[40], (const std::string *)&v113[40]);
                  if ((v113[63] & 0x80000000) != 0) {
                    operator delete(*(void **)&v113[40]);
                  }
                }
                else
                {
                  memset(v111, 0, 24);
                  *(void *)&v111[24] = *(void *)&v113[24];
                  *(void *)&v111[29] = *(void *)&v113[29];
                  *(std::string *)&v111[40] = *(std::string *)&v113[40];
                  BYTE8(v110) = 1;
                }
                if ((v113[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v113);
                }
              }
              CFMutableDictionaryRef v45 = *(std::__shared_weak_count **)(a1 + 16);
              if (!v45 || (uint64_t v46 = *(void *)(a1 + 8), (v47 = std::__shared_weak_count::lock(v45)) == 0)) {
                sub_100088B9C();
              }
              uint64_t v48 = v47;
              p_shared_weak_owners = &v47->__shared_weak_owners_;
              atomic_fetch_add_explicit(&v47->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v47);
              *(void *)uint64_t v113 = 0;
              *(void *)&v113[8] = v113;
              *(void *)&v113[16] = 0x3002000000;
              *(void *)&v113[24] = sub_100D092C4;
              *(void *)&v113[32] = sub_100D092D4;
              *(void *)&v113[40] = 0;
              if (a3)
              {
                (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 128) + 640))(&v89);
                (*(void (**)(long long *__return_ptr))(*(void *)v89 + 152))(&v103);
                uint64_t v49 = v103;
                sub_100058DB0(v87, "GetSIMStatusRspTimeout");
                long long v50 = *(NSObject **)(a1 + 24);
                dispatch_object_t object = v50;
                if (v50) {
                  dispatch_retain(v50);
                }
                v83[0] = _NSConcreteStackBlock;
                v83[1] = 1174405120;
                v83[2] = sub_100D0930C;
                v83[3] = &unk_101A50BF0;
                v83[5] = v18;
                v83[4] = v113;
                long long v51 = v68;
                if (v68) {
                  long long v51 = _Block_copy(v68);
                }
                std::string::size_type v84 = v51;
                unint64_t v85 = _Block_copy(v83);
                sub_100118A44(v49, (uint64_t)v87, 1, 30000000, &object, &v85);
                uint64_t v52 = v91;
                uint64_t v91 = 0;
                uint64_t v53 = *(void *)(*(void *)&v113[8] + 40);
                *(void *)(*(void *)&v113[8] + 40) = v52;
                long long v20 = v68;
                if (v53)
                {
                  (*(void (**)(uint64_t))(*(void *)v53 + 8))(v53);
                  uint64_t v54 = v91;
                  uint64_t v91 = 0;
                  if (v54) {
                    (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
                  }
                }
                if (v85) {
                  _Block_release(v85);
                }
                if (object) {
                  dispatch_release(object);
                }
                if (v88 < 0) {
                  operator delete(v87[0]);
                }
                if (*((void *)&v103 + 1)) {
                  sub_10004D2C8(*((std::__shared_weak_count **)&v103 + 1));
                }
                if (v90) {
                  sub_10004D2C8(v90);
                }
                if (v84) {
                  _Block_release(v84);
                }
              }
              uint64_t v55 = *(void (****)(void, uint64_t, long long *, void, void **))(a1 + 240);
              v95[0] = _NSConcreteStackBlock;
              v95[1] = 1174405120;
              v95[2] = sub_100D094C8;
              v95[3] = &unk_101A50C28;
              v95[5] = a1;
              v95[6] = v46;
              long long v96 = v48;
              atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
              char v102 = a3;
              v95[4] = v113;
              int v101 = v11;
              char v97 = 0;
              a2 = v16;
              int v10 = v67;
              if (LOBYTE(v112[0]))
              {
                if (SHIBYTE(v112[3]) < 0)
                {
                  sub_10004FC84(&v98, v112[1], (unint64_t)v112[2]);
                }
                else
                {
                  long long v98 = *(_OWORD *)&v112[1];
                  uint64_t v99 = v112[3];
                }
                char v97 = 1;
              }
              if (v20) {
                long long v56 = _Block_copy(v20);
              }
              else {
                long long v56 = 0;
              }
              int v100 = v56;
              uint64_t v82 = _Block_copy(v95);
              (**v55)(v55, v11, &buf, a3, &v82);
              if (v82) {
                _Block_release(v82);
              }
              if (v100) {
                _Block_release(v100);
              }
              if (v97)
              {
                if (SHIBYTE(v99) < 0) {
                  operator delete((void *)v98);
                }
                char v97 = 0;
              }
              if (v96) {
                std::__shared_weak_count::__release_weak(v96);
              }
              _Block_object_dispose(v113, 8);
              uint64_t v57 = *(void *)&v113[40];
              *(void *)&v113[40] = 0;
              if (v57) {
                (*(void (**)(uint64_t))(*(void *)v57 + 8))(v57);
              }
              std::__shared_weak_count::__release_weak(v48);
              sub_100D15774((uint64_t)&v110 + 8);
              *(void *)uint64_t v113 = &v109;
              sub_100047F64((void ***)v113);
              if (SHIBYTE(v108) < 0) {
                operator delete(*((void **)&v107 + 1));
              }
              if (BYTE8(v105))
              {
                if (SBYTE7(v107) < 0) {
                  operator delete((void *)v106);
                }
                BYTE8(v105) = 0;
              }
              if (SBYTE7(v105) < 0)
              {
                long long v41 = (void *)buf;
LABEL_156:
                operator delete(v41);
              }
            }
            if (LOBYTE(v112[0]) && SHIBYTE(v112[3]) < 0) {
              operator delete(v112[1]);
            }
            if (!v20) {
              goto LABEL_162;
            }
            goto LABEL_161;
          }
          uint64_t v33 = *v18;
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Skip getSIMStatus, as too frequent actions!", (uint8_t *)&buf, 2u);
          }
          *(void *)long long v111 = 0;
          long long v109 = 0u;
          long long v110 = 0u;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          long long buf = 0u;
          (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 160) + 112))(&buf);
          if ((_BYTE)buf)
          {
            (*((void (**)(void *, uint64_t, char *))v68 + 2))(v68, 1, (char *)&buf + 8);
            a2 = v16;
            int v10 = v67;
          }
          else
          {
            memset(v114, 0, sizeof(v114));
            memset(v113, 0, sizeof(v113));
            (*((void (**)(void *, uint64_t, unsigned char *))v68 + 2))(v68, 2, v113);
            v112[0] = (void **)&v114[1] + 1;
            sub_10023F96C(v112);
            v112[0] = (void **)v114;
            sub_10023FA88(v112);
            a2 = v16;
            int v10 = v67;
            if (v113[32])
            {
              if ((v113[63] & 0x80000000) != 0) {
                operator delete(*(void **)&v113[40]);
              }
              v113[32] = 0;
            }
            if (v113[0] && (v113[31] & 0x80000000) != 0) {
              operator delete(*(void **)&v113[8]);
            }
          }
          sub_1003DD04C(&buf);
        }
        else
        {
          uint64_t v34 = *v18;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "doesn't support entitlements", (uint8_t *)&buf, 2u);
          }
          long long v109 = 0u;
          long long v110 = 0u;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          long long buf = 0u;
          long long v20 = v68;
          (*((void (**)(void *, uint64_t, long long *))v68 + 2))(v68, 3, &buf);
          *(void *)uint64_t v113 = (char *)&v109 + 8;
          sub_10023F96C((void ***)v113);
          *(void *)uint64_t v113 = &v108;
          sub_10023FA88((void ***)v113);
          int v10 = v67;
          if ((_BYTE)v106)
          {
            if (SHIBYTE(v107) < 0) {
              operator delete(*((void **)&v106 + 1));
            }
            LOBYTE(v106) = 0;
          }
          if ((_BYTE)buf && SHIBYTE(v105) < 0) {
            operator delete(*((void **)&buf + 1));
          }
        }
LABEL_161:
        _Block_release(v20);
LABEL_162:
        if (v70) {
          _Block_release(v70);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        long long v58 = v8 + 1;
        uint64_t v8 = v7;
        if (v58 != v7)
        {
          uint64_t v8 = v58;
          while ((v9(*v8) & 1) == 0)
          {
            if (++v8 == v7)
            {
              uint64_t v8 = v7;
              break;
            }
          }
        }
      }
      while (v8 != v65);
    }
  }
  _Block_object_dispose(v77, 8);
  sub_10034422C((uint64_t)&v78, v79[0]);
  _Block_object_dispose(v80, 8);
}

void sub_100CF8BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *aBlock,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62,uint64_t a63)
{
  sub_1003DA218(v73 - 240);
  sub_1003DD04C(&STACK[0x340]);
  _Block_release(aBlock);
  if (a55) {
    _Block_release(a55);
  }
  if (a62 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a67, 8);
  sub_10034422C(a22, (void *)a72);
  _Block_object_dispose(&a73, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100CF8EAC(uint64_t result, void *a2)
{
  long long v2 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    int v3 = *(void **)(result + 32);
    do
    {
      if (*((_DWORD *)v2 + 10) == 2)
      {
        int v4 = v3[5];
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          uint64_t v14 = subscriber::asString();
          int v15 = *((_DWORD *)v2 + 10);
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v14;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v15;
          _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Done getSIMStatusOnDeviceOr4FFChange for slot %s: %d", buf, 0x12u);
        }
        aBlock[0] = _NSConcreteStackBlock;
        aBlock[1] = 0x40000000;
        aBlock[2] = sub_100D17B24;
        aBlock[3] = &unk_101A51678;
        aBlock[4] = v3 + 1;
        aBlock[5] = sub_100CF9410;
        aBlock[6] = 0;
        uint64_t v5 = _Block_copy(aBlock);
        uint64_t v6 = (std::__shared_weak_count *)v3[2];
        if (v6)
        {
          uint64_t v7 = std::__shared_weak_count::lock(v6);
          if (v7)
          {
            uint64_t v8 = v7;
            uint64_t v9 = v3[3];
            void aBlock[7] = v9;
            if (v5) {
              int v10 = _Block_copy(v5);
            }
            else {
              int v10 = 0;
            }
            aBlock[8] = v10;
            dispatch_retain(v9);
            memset(buf, 0, 32);
            sub_100D17B70(v17, v9, v10);
            sub_100D17B70(v18, v17[0], v17[1]);
            sub_100D17B70(v19, v18[0], v18[1]);
            BOOL v25 = 0;
            sub_100D17B70(v20, v19[0], v19[1]);
            sub_100D17B70(v21, v20[0], v20[1]);
            sub_100D17B70(v22, v21[0], v21[1]);
            sub_100D17B70(v23, v22[0], v22[1]);
            sub_100D17B70(&v26, v23[0], v23[1]);
            sub_100D182A4((uint64_t)v23);
            sub_100D182A4((uint64_t)v22);
            sub_100D182A4((uint64_t)v21);
            BOOL v25 = &off_101A51698;
            sub_100D182A4((uint64_t)v20);
            sub_100D182A4((uint64_t)v19);
            sub_100A347F0((uint64_t *)&v25, (uint64_t *)&buf[24]);
            sub_100A35098((uint64_t *)&v25);
            sub_100D182A4((uint64_t)v18);
            sub_100D182A4((uint64_t)v17);
            atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            operator new();
          }
        }
        sub_100088B9C();
      }
      uint64_t v11 = (void *)v2[1];
      if (v11)
      {
        do
        {
          char v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          char v12 = (void *)v2[2];
          BOOL v13 = *v12 == (void)v2;
          long long v2 = v12;
        }
        while (!v13);
      }
      long long v2 = v12;
    }
    while (v12 != a2 + 1);
  }
  return result;
}

void sub_100CF930C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,char a29,uint64_t a30,char a31)
{
  if (a2)
  {
    *(void *)(v33 - 200) = v31;
    sub_100163BC8(v33 - 152);
    uint64_t v35 = *(void *)(v33 - 224);
    if (v35) {
      (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
    }
    std::__shared_weak_count::__release_weak(v32);
    sub_100A33BDC(v33 - 208);
    sub_100D182A4((uint64_t)&a27);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CF9410(uint64_t a1)
{
  (***(void (****)(long long *__return_ptr))(a1 + 128))(&v7);
  long long v8 = v7;
  long long v7 = 0uLL;
  uint64_t v2 = SlotIdFromPersonalityId();
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
  if (*((void *)&v7 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v7 + 1));
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100CF9768;
  aBlock[3] = &unk_101A505C8;
  aBlock[4] = a1;
  int v5 = v2;
  int v3 = _Block_copy(aBlock);
  uint64_t v6 = v3;
  sub_100CF79E4(a1, v2, 0, 0, &v6);
  if (v3) {
    _Block_release(v3);
  }
}

void sub_100CF9528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (v18) {
    _Block_release(v18);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100CF9568(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  memset(v6, 0, sizeof(v6));
  sub_100CCD910(a3, (_DWORD **)(a2 + 304), (char *)v6);
  if (LOBYTE(v6[0]))
  {
    uint64_t v4 = BYTE7(v8);
    if (SBYTE7(v8) < 0) {
      uint64_t v4 = *((void *)&v7 + 1);
    }
    if (v4) {
      sub_10032AFC0((unsigned char *)a1, (const std::string *)&v7);
    }
  }
  return sub_1003DD210(v6);
}

void sub_100CF9624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_1003DD210(&a9);
  if (*(unsigned char *)v9)
  {
    if (*(char *)(v9 + 31) < 0) {
      operator delete(*(void **)(v9 + 8));
    }
    *(unsigned char *)uint64_t v9 = 0;
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CF965C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 224);
  if (!v2) {
    return 0;
  }
  uint64_t v7 = 0;
  long long v8 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v2 + 16))(&v7);
  if (!v7) {
    goto LABEL_8;
  }
  if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 16))(v7, 1))
  {
    uint64_t v3 = 1;
    goto LABEL_9;
  }
  uint64_t v4 = *(NSObject **)(a1 + 40);
  uint64_t v3 = 0;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Device passcode is not enabled", v6, 2u);
LABEL_8:
    uint64_t v3 = 0;
  }
LABEL_9:
  if (v8) {
    sub_10004D2C8(v8);
  }
  return v3;
}

void sub_100CF9750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CF9768(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = a2 + 8;
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4) {
    goto LABEL_11;
  }
  int v5 = (int *)(a1 + 40);
  int v6 = *(_DWORD *)(a1 + 40);
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      long long v10 = (uint64_t *)v4;
    }
    else {
      long long v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }
  while (*v10);
  if (v7 != v3 && v6 >= *(_DWORD *)(v7 + 32))
  {
    long long v12 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48));
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(v7 + 40);
      v17[0] = 67109120;
      v17[1] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I handleRefreshEntitlementCache, rsp: %d", (uint8_t *)v17, 8u);
    }
    unsigned int v14 = *(_DWORD *)(v7 + 40);
    if (v14 <= 3 && v14 != 2)
    {
      uint64_t v16 = sub_100256E84((uint64_t **)(v2 + 712), *v5, v5);
      sub_10016111C((uint64_t *)v16 + 5);
    }
  }
  else
  {
LABEL_11:
    long long v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v17[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "slot response not found", (uint8_t *)v17, 2u);
    }
  }
}

uint64_t **sub_100CF98EC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  sub_100CF9984(a1, a2, 10, a3, a4);
  sub_100CF9984(a1, a2, 12, a3, a4);
  sub_100CF9984(a1, a2, 11, a3, a4);

  return sub_100CF9984(a1, a2, 14, a3, a4);
}

uint64_t **sub_100CF9984(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  int v39 = a3;
  int v40 = a2;
  long long v10 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (((*a4 >> a3) & 1) == 0)
  {
    int v24 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v42 = sub_100059954(a3);
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s entitlement not supported", buf, 0xCu);
    }
    BOOL v25 = sub_1009127C8((uint64_t **)(a1 + 1088), a3, &v39);
    uint64_t result = sub_1005BD92C(v25 + 5, a2, &v40);
    int v26 = 6;
    goto LABEL_27;
  }
  long long v11 = v10;
  long long v12 = *v10;
  if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v42 = sub_100059954(a3);
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s entitlement supported", buf, 0xCu);
  }
  uint64_t v15 = *(void *)(a5 + 8);
  uint64_t v14 = a5 + 8;
  uint64_t v13 = v15;
  if (!v15) {
    goto LABEL_14;
  }
  uint64_t v16 = v14;
  do
  {
    int v17 = *(_DWORD *)(v13 + 28);
    BOOL v18 = v17 < (int)a3;
    if (v17 >= (int)a3) {
      char v19 = (uint64_t *)v13;
    }
    else {
      char v19 = (uint64_t *)(v13 + 8);
    }
    if (!v18) {
      uint64_t v16 = v13;
    }
    uint64_t v13 = *v19;
  }
  while (*v19);
  if (v16 == v14 || *(_DWORD *)(v16 + 28) > (int)a3)
  {
LABEL_14:
    long long v20 = *v11;
    if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = sub_100059954(a3);
      *(_DWORD *)long long buf = 136315138;
      uint64_t v42 = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s is not tracked", buf, 0xCu);
    }
    uint64_t v22 = sub_1009127C8((uint64_t **)(a1 + 1088), a3, &v39);
    uint64_t result = sub_1005BD92C(v22 + 5, a2, &v40);
    *((_DWORD *)result + 8) = 6;
    switch((int)a3)
    {
      case 10:
      case 12:
        if (*(void *)(a1 + 368) != *(void *)(a1 + 360))
        {
          if (*(unsigned char *)(a1 + 352))
          {
            uint64_t result = *(uint64_t ***)(a1 + 192);
            if (result) {
              goto LABEL_23;
            }
          }
        }
        if (a3 == 11) {
          goto LABEL_21;
        }
        break;
      case 11:
      case 14:
LABEL_21:
        if (*(void *)(a1 + 544) != *(void *)(a1 + 552))
        {
          uint64_t result = *(uint64_t ***)(a1 + 192);
          if (result) {
LABEL_23:
          }
            uint64_t result = (uint64_t **)((uint64_t (*)(uint64_t **, uint64_t, uint64_t))(*result)[4])(result, a2, a3);
        }
        break;
      default:
        return result;
    }
    return result;
  }
  int v27 = *(_DWORD *)(v16 + 32);
  if (v27 == 4)
  {
    uint64_t v28 = *v11;
    if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = sub_100059954(a3);
      *(_DWORD *)long long buf = 136315138;
      uint64_t v42 = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s set to requested, ignore ...", buf, 0xCu);
    }
    BOOL v30 = sub_1009127C8((uint64_t **)(a1 + 1088), a3, &v39);
    uint64_t result = sub_1005BD92C(v30 + 5, a2, &v40);
    int v26 = 4;
LABEL_27:
    *((_DWORD *)result + 8) = v26;
    return result;
  }
  uint64_t v31 = sub_1009127C8((uint64_t **)(a1 + 1088), a3, &v39);
  uint64_t result = sub_1005BD92C(v31 + 5, a2, &v40);
  if (*((_DWORD *)result + 8) != v27)
  {
    uint64_t v32 = *v11;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = sub_100059954(a3);
      uint64_t v34 = sub_1009127C8((uint64_t **)(a1 + 1088), a3, &v39);
      unsigned int v35 = *((_DWORD *)sub_1005BD92C(v34 + 5, a2, &v40) + 8) - 1;
      if (v35 > 5) {
        uint64_t v36 = "???";
      }
      else {
        uint64_t v36 = off_101A51E78[v35];
      }
      if ((v27 - 1) > 5) {
        unint64_t v37 = "???";
      }
      else {
        unint64_t v37 = off_101A51EA8[v27 - 1];
      }
      *(_DWORD *)long long buf = 136315650;
      uint64_t v42 = v33;
      __int16 v43 = 2080;
      std::string v44 = v36;
      __int16 v45 = 2080;
      uint64_t v46 = v37;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s from [%s] to [%s]", buf, 0x20u);
    }
    int v38 = sub_1009127C8((uint64_t **)(a1 + 1088), a3, &v39);
    uint64_t result = sub_1005BD92C(v38 + 5, a2, &v40);
    *((_DWORD *)result + 8) = v27;
    if ((a3 & 0xFFFFFFFE) == 0xA)
    {
      if (v27 == 2) {
        sub_100CF7880(a1, a2);
      }
      return (uint64_t **)(*(uint64_t (**)(void))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96));
    }
  }
  return result;
}

void sub_100CF9E88(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v5 = *a3;
  if (a3[1] == *a3)
  {
    int v24 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v26 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "fSlotInfo is empty", v26, 2u);
    }
  }
  else if (*(unsigned char *)(v5 + 80) && *(void *)(v5 + 56) != *(void *)(v5 + 64))
  {
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    uint64_t v41 = 0;
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 128) + 640))(v26);
    (*(void (**)(uint64_t *__return_ptr))(**(void **)v26 + 32))(&v39);
    if (*(void *)&v26[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v26[8]);
    }
    if (v39 != v40)
    {
      uint64_t v8 = *a3;
      if (a3[1] == *a3) {
        sub_10015B728();
      }
      if (!*(unsigned char *)(v8 + 80)) {
        sub_10016C840();
      }
      uint64_t v9 = *(void *)(v8 + 56);
      for (uint64_t i = *(void *)(v8 + 64); v9 != i; v9 += 216)
      {
        uint64_t v38 = 0;
        *(_OWORD *)std::string __p = 0u;
        long long v37 = 0u;
        *(_OWORD *)uint64_t v34 = 0u;
        long long v35 = 0u;
        long long v32 = 0u;
        *(_OWORD *)uint64_t v33 = 0u;
        *(_OWORD *)BOOL v30 = 0u;
        *(_OWORD *)uint64_t v31 = 0u;
        *(_OWORD *)uint64_t v28 = 0u;
        long long v29 = 0u;
        *(_OWORD *)int v26 = 0u;
        long long v27 = 0u;
        long long v11 = (void *)(v9 + 16);
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 160) + 120))(v26);
        if (!(_BYTE)v38 || BYTE8(v29) != 5) {
          goto LABEL_15;
        }
        (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 128) + 640))(&buf);
        char v12 = (*(uint64_t (**)(void, void))(*(void *)buf + 144))(buf, a2);
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if ((v12 & 1) == 0)
        {
          uint64_t v21 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            if (*(char *)(v9 + 39) < 0) {
              long long v11 = (void *)*v11;
            }
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v11;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Skipping unusable plan (%s) in signup request", (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
LABEL_15:
          uint64_t v14 = v39;
          uint64_t v13 = v40;
          if (v39 != v40)
          {
            unint64_t v15 = *(unsigned __int8 *)(v9 + 39);
            while (1)
            {
              unint64_t v16 = *(char *)(v14 + 23) < 0 ? *(void *)(v14 + 8) : *(unsigned __int8 *)(v14 + 23);
              if ((v15 & 0x80) != 0)
              {
                if (v16 == -1) {
LABEL_67:
                }
                  sub_1000C14D8();
                BOOL v18 = *(const void **)(v9 + 16);
                size_t v17 = *(void *)(v9 + 24) >= v16 ? v16 : *(void *)(v9 + 24);
              }
              else
              {
                if (v16 == -1) {
                  goto LABEL_67;
                }
                size_t v17 = v15 >= v16 ? v16 : v15;
                BOOL v18 = (const void *)(v9 + 16);
              }
              char v19 = *(char *)(v14 + 23) >= 0 ? (const void *)v14 : *(const void **)v14;
              if (!memcmp(v18, v19, v17) && v17 == v16) {
                break;
              }
              v14 += 24;
              if (v14 == v13) {
                goto LABEL_47;
              }
            }
            unint64_t v22 = a4[1];
            if (v22 >= a4[2])
            {
              uint64_t v23 = sub_10030E9EC(a4, (long long *)(v9 + 16));
            }
            else
            {
              sub_1000D87F8(a4, (long long *)(v9 + 16));
              uint64_t v23 = v22 + 24;
            }
            a4[1] = v23;
          }
        }
LABEL_47:
        if ((_BYTE)v38)
        {
          if (SBYTE7(v37) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v35) < 0) {
            operator delete(v34[1]);
          }
          if (SHIBYTE(v34[0]) < 0) {
            operator delete(v33[0]);
          }
          if (SHIBYTE(v32) < 0) {
            operator delete(v31[1]);
          }
          if (SHIBYTE(v31[0]) < 0) {
            operator delete(v30[0]);
          }
          if (SBYTE7(v29) < 0) {
            operator delete(v28[0]);
          }
          if (SHIBYTE(v27) < 0) {
            operator delete(*(void **)&v26[8]);
          }
        }
      }
    }
    *(void *)int v26 = &v39;
    sub_100047F64((void ***)v26);
  }
}

void sub_100CFA2C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CFA334(uint64_t a1, long long *a2, long long *a3, void *aBlock)
{
  long long v17 = *a2;
  if (aBlock) {
    uint64_t v7 = _Block_copy(aBlock);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *(const void **)(a1 + 1080);
  *(void *)(a1 + 1080) = v7;
  if (v8) {
    _Block_release(v8);
  }
  uint64_t v9 = *(void *)(a1 + 144);
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *((void *)a2 + 1);
  sub_100326828(a3, &v13);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  _OWORD v15[2] = sub_100CFA4F4;
  void v15[3] = &unk_101A505E8;
  _OWORD v15[4] = a1;
  long long v16 = v17;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  _OWORD v12[2] = sub_100CFA824;
  void v12[3] = &unk_101A50608;
  void v12[4] = a1;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, void *, void *))(*(void *)v9 + 40))(v9, v10, v11, &v13, v15, v12);
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_100CFA4C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100CFA4F4(void *result, unsigned __int8 *a2)
{
  if (*a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = result[4];
    uint64_t v5 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = a2[99];
      int v7 = a2[98];
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v6;
      LOWORD(__p) = 1024;
      *(_DWORD *)((char *)&__p + 2) = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I have new profile Disable [%d] Delete [%d]", buf, 0xEu);
      int v8 = *a2;
      uint64_t v9 = *(void *)(v4 + 160);
      int v10 = *(_DWORD *)(v4 + 1040);
      uint64_t v12 = 0;
      long long v11 = 0uLL;
      if (!v8) {
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
    }
    else
    {
      uint64_t v9 = *(void *)(v4 + 160);
      int v10 = *(_DWORD *)(v4 + 1040);
      uint64_t v12 = 0;
      long long v11 = 0uLL;
    }
    sub_1000C5AB4((uint64_t)v13, (uint64_t)(a2 + 8));
    char v14 = 1;
    sub_1003DB514((uint64_t)buf, v10, &v11, (uint64_t)v13, 0);
    (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v9 + 96))(v9, 1, buf);
    if (v18[216]) {
      sub_1000C584C((uint64_t)v18);
    }
    if (v17 < 0) {
      operator delete(__p);
    }
    if (v14) {
      sub_1000C584C((uint64_t)v13);
    }
    if (SHIBYTE(v12) < 0) {
      operator delete((void *)v11);
    }
    if (!*a2) {
      __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
    }
    if (a2[99] || a2[98])
    {
      *(void *)long long buf = 0;
      std::string __p = 0;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v4 + 96) + 64))(buf);
      if (*(void *)buf) {
        (*(void (**)(void))(**(void **)buf + 128))(*(void *)buf);
      }
      if (__p) {
        sub_10004D2C8((std::__shared_weak_count *)__p);
      }
    }
    uint64_t result = *(void **)(v4 + 256);
    if (result)
    {
      if (!*a2) {
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
      return (void *)(*(uint64_t (**)(void *, void *, unsigned __int8 *))(*result + 80))(result, v3 + 5, a2 + 8);
    }
  }
  return result;
}

void sub_100CFA7C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,int a44,__int16 a45,char a46,char a47,std::__shared_weak_count *a48)
{
  if (a48) {
    sub_10004D2C8(a48);
  }
  _Unwind_Resume(exception_object);
}

void sub_100CFA824(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(void *)(v3 + 1080))
  {
    uint64_t v6 = *(void *)(v3 + 160);
    int v7 = *(_DWORD *)(v3 + 1040);
    uint64_t v38 = 0;
    long long v37 = 0uLL;
    v40[0] = 0;
    char v41 = 0;
    sub_1003DB514((uint64_t)&buf, v7, &v37, (uint64_t)v40, 0);
    (*(void (**)(uint64_t, void, long long *))(*(void *)v6 + 96))(v6, 0, &buf);
    if (v47[192]) {
      sub_1000C584C((uint64_t)&v45);
    }
    if (SHIBYTE(v44) < 0) {
      operator delete(*((void **)&buf + 1));
    }
    if (v41) {
      sub_1000C584C((uint64_t)v40);
    }
    if (SHIBYTE(v38) < 0) {
      operator delete((void *)v37);
    }
    if (!*(unsigned char *)a3) {
      goto LABEL_40;
    }
    uint64_t v36 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    *(_OWORD *)long long v32 = 0u;
    long long v33 = 0u;
    uint64_t v8 = 1368;
    if (*(unsigned char *)(v3 + 1224))
    {
      uint64_t v9 = v3 + 1368;
    }
    else
    {
      uint64_t v8 = 328;
      uint64_t v9 = v3 + 328;
    }
    if (*(char *)(v9 + 23) < 0)
    {
      sub_10004FC84(v32, *(void **)(v3 + v8), *(void *)(v9 + 8));
    }
    else
    {
      *(_OWORD *)long long v32 = *(_OWORD *)v9;
      *(void *)&long long v33 = *(void *)(v9 + 16);
    }
    uint64_t v12 = *(void *)(v9 + 24);
    uint64_t v11 = *(void *)(v9 + 32);
    *(void *)&long long v35 = 0;
    *((void *)&v33 + 1) = v12;
    long long v34 = 0uLL;
    sub_100311ED8(&v34, v11, *(void *)(v9 + 40), 0x2E8BA2E8BA2E8BA3 * ((*(void *)(v9 + 40) - v11) >> 3));
    *((void *)&v35 + 1) = *(void *)(v9 + 56);
    LODWORD(v36) = *(_DWORD *)(v9 + 64);
    if (*(unsigned char *)a3)
    {
      uint64_t v14 = *((void *)&v34 + 1);
      uint64_t v13 = v34;
      *(_OWORD *)uint64_t v48 = *(_OWORD *)(a3 + 24);
      if ((void)v34 == *((void *)&v34 + 1)) {
        goto LABEL_37;
      }
      while (1)
      {
        sub_1000C5DA8((uint64_t)&buf, v13);
        BOOL v16 = v43 != *(void *)v48 || v44 != *(void *)&v48[8];
        if (v47[24])
        {
          uint64_t v39 = (void **)v47;
          sub_1000C57C8(&v39);
        }
        if (v46 < 0) {
          operator delete(v45);
        }
        if (!v16) {
          break;
        }
        v13 += 88;
        if (v13 == v14)
        {
          uint64_t v13 = v14;
          break;
        }
      }
      if (v13 == *((void *)&v34 + 1))
      {
LABEL_37:
        BOOL v18 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          if (!*(unsigned char *)a3) {
            __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
          }
          ctu::hex((uint64_t *)&buf, (ctu *)(a3 + 24), (const void *)0x10, v19);
          if (v43 >= 0) {
            p_long long buf = &buf;
          }
          else {
            p_long long buf = (long long *)buf;
          }
          *(_DWORD *)uint64_t v48 = 136315138;
          *(void *)&v48[4] = p_buf;
          _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find CSN: %s in remote vinyl info", v48, 0xCu);
          if (SHIBYTE(v43) < 0) {
            operator delete((void *)buf);
          }
        }
        goto LABEL_38;
      }
      if (*(unsigned char *)a3)
      {
        long long v17 = *(_OWORD *)(a3 + 24);
        *(_OWORD *)uint64_t v13 = *(_OWORD *)(a3 + 8);
        *(_OWORD *)(v13 + 16) = v17;
        std::string::operator=((std::string *)(v13 + 32), (const std::string *)(a3 + 40));
        sub_1000C86CC(v13 + 56, a3 + 64);
        (*(void (**)(void, void **))(**(void **)(v3 + 160) + 32))(*(void *)(v3 + 160), v32);
LABEL_38:
        *(void *)&long long buf = &v34;
        sub_1000C56F4((void ***)&buf);
        if (SBYTE7(v33) < 0) {
          operator delete(v32[0]);
        }
LABEL_40:
        (*(void (**)(void))(**(void **)(v3 + 96) + 16))(*(void *)(v3 + 96));
        int v20 = *a2;
        uint64_t v21 = *(NSObject **)(v3 + 40);
        BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
        if (v20 == 1)
        {
          if (v22)
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Install successful", (uint8_t *)&buf, 2u);
          }
          uint64_t v23 = 0;
        }
        else
        {
          if (v22)
          {
            if (v20 != 2)
            {
              exceptiouint64_t n = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
              ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
            }
            uint64_t v24 = asString();
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v24;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I error fetching profiles: %s", (uint8_t *)&buf, 0xCu);
            int v20 = *a2;
          }
          if (v20 != 2)
          {
            if (v20 == 1)
            {
              long long v29 = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
              ctu::ResultIsNotError::ResultIsNotError(v29);
            }
            BOOL v30 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
            ctu::ResultIsEmptyError::ResultIsEmptyError(v30);
          }
          uint64_t v23 = sub_100CFAE78(a2[1]);
        }
        uint64_t v25 = *(void *)(v3 + 1080);
        LOBYTE(buf) = 0;
        if (*(unsigned char *)a3)
        {
          sub_1000C5DA8((uint64_t)&buf + 8, a3 + 8);
          LOBYTE(buf) = 1;
        }
        (*(void (**)(uint64_t, uint64_t, long long *))(v25 + 16))(v25, v23, &buf);
        sub_1000C60A0(&buf);
        return;
      }
      int v27 = 1212;
      uint64_t v28 = "get";
    }
    else
    {
      int v27 = 1222;
      uint64_t v28 = "operator->";
    }
    __assert_rtn(v28, "optional.hpp", v27, "this->is_initialized()");
  }
  int v10 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I fetch profile callback already invoked", (uint8_t *)&buf, 2u);
  }
}

void sub_100CFADE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,int a57,__int16 a58,char a59,char a60)
{
  __cxa_free_exception(v60);
  _Unwind_Resume(a1);
}

uint64_t sub_100CFAE78(uint64_t result)
{
  if ((int)result > 19)
  {
    if ((result - 20) < 2) {
      return 5;
    }
    if (result == 25) {
      return 11;
    }
    return 2;
  }
  if (result != 6 && result != 8)
  {
    if (result == 9) {
      return 7;
    }
    return 2;
  }
  return result;
}

void sub_100CFAECC(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v5 = *(void *)(a1 + 144);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  CFTypeRef v9[2] = sub_100CFAFC4;
  void v9[3] = &unk_101A50628;
  void v9[4] = a1;
  uint64_t v8 = *a4;
  if (*a4) {
    uint64_t v8 = _Block_copy(v8);
  }
  aBlocuint64_t k = v8;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v5 + 48))(v5, v6, v7, a3, v9);
  if (aBlock) {
    _Block_release(aBlock);
  }
}

void sub_100CFAFA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CFAFC4(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *a2;
  if (v4 == 2)
  {
    uint64_t v7 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 136315138;
      uint64_t v15 = asString();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I User consent send failure (%s)", (uint8_t *)&v14, 0xCu);
      int v8 = *a2;
      if (v8 != 2)
      {
        if (v8 == 1)
        {
          exceptiouint64_t n = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          ctu::ResultIsNotError::ResultIsNotError(exception);
        }
        uint64_t v13 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(v13);
      }
    }
    unsigned int v9 = sub_100CFAE78(a2[1]);
    return (*(uint64_t (**)(void, unint64_t))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v9 | (unint64_t)&_mh_execute_header);
  }
  else
  {
    if (v4 == 1)
    {
      uint64_t v5 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v14) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I User Consent successfully sent", (uint8_t *)&v14, 2u);
      }
    }
    else
    {
      uint64_t v11 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v14) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I User consent send failure", (uint8_t *)&v14, 2u);
      }
    }
    return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_100CFB1D4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_100CFB1F4(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a2 + 40);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_100CFB228(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 40);
  if (v1) {
    _Block_release(v1);
  }
}

void sub_100CFB24C(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
}

uint64_t sub_100CFB254(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 96) + 16))();
}

uint64_t sub_100CFB27C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))();
}

void sub_100CFB2A4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)(a2 + 48);
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 5) < 2) {
    return;
  }
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  uint64_t v5 = a2 + 24;
  memset(&v35, 0, sizeof(v35));
  if ((sub_100CCD2E8() & 1) == 0)
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 47) >= 0) {
        uint64_t v12 = v5;
      }
      else {
        uint64_t v12 = *(void *)(a2 + 24);
      }
      *(_DWORD *)char v46 = 136315138;
      v47[0] = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "failed to convert to EID bytes for %s", v46, 0xCu);
    }
    goto LABEL_92;
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 176) + 24))(v46);
  if (v62)
  {
    if (v46[0])
    {
      std::string::operator=(&v35, (const std::string *)((char *)v47 + 4));
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 47) >= 0) {
          uint64_t v7 = v5;
        }
        else {
          uint64_t v7 = *(void *)(a2 + 24);
        }
        int v8 = &v35;
        if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          int v8 = (std::string *)v35.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v7;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v8;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I selected ICCID on remote device (%s): %s", buf, 0x16u);
      }
    }
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!v35.__r_.__value_.__l.__size_) {
      goto LABEL_74;
    }
    uint64_t v10 = *(void *)(a2 + 48);
    unsigned int v9 = *(long long **)(a2 + 56);
    sub_10004FC84(&__p, v35.__r_.__value_.__l.__data_, v35.__r_.__value_.__l.__size_);
  }
  else
  {
    if (!*((unsigned char *)&v35.__r_.__value_.__s + 23)) {
      goto LABEL_74;
    }
    uint64_t v10 = *(void *)(a2 + 48);
    unsigned int v9 = *(long long **)(a2 + 56);
    std::string __p = v35;
  }
  char v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((long long *)v10 == v9) {
    goto LABEL_43;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  while (1)
  {
    uint64_t v16 = *(unsigned __int8 *)(v10 + 23);
    if ((v16 & 0x80u) == 0) {
      uint64_t v17 = *(unsigned __int8 *)(v10 + 23);
    }
    else {
      uint64_t v17 = *(void *)(v10 + 8);
    }
    if (v17 != size) {
      goto LABEL_40;
    }
    if ((v16 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v10 + 23)) {
      goto LABEL_42;
    }
    uint64_t v18 = 0;
    while (*(unsigned __int8 *)(v10 + v18) == p_p->__r_.__value_.__s.__data_[v18])
    {
      if (v16 == ++v18) {
        goto LABEL_42;
      }
    }
LABEL_40:
    v10 += 96;
    if ((long long *)v10 == v9) {
      goto LABEL_43;
    }
  }
  if (memcmp(*(const void **)v10, p_p, *(void *)(v10 + 8))) {
    goto LABEL_40;
  }
LABEL_42:
  unsigned int v9 = (long long *)v10;
LABEL_43:
  if (v13 < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v9 != *(long long **)(a2 + 56))
  {
    *(_OWORD *)uint64_t v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    *(_OWORD *)uint64_t v43 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_1003DD5AC((char *)buf, v9);
    int v20 = *(char **)(a2 + 48);
    for (uint64_t i = *(void *)(a2 + 56); (char *)i != v20; sub_10016A8DC(i))
      i -= 96;
    uint64_t v22 = a2 + 64;
    unint64_t v21 = *(void *)(a2 + 64);
    *(void *)(a2 + 56) = v20;
    if ((unint64_t)v20 >= v21)
    {
      unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v20[-*v2] >> 5);
      if (v24 + 1 > 0x2AAAAAAAAAAAAAALL) {
        sub_10006A748();
      }
      unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21 - *v2) >> 5);
      uint64_t v26 = 2 * v25;
      if (2 * v25 <= v24 + 1) {
        uint64_t v26 = v24 + 1;
      }
      if (v25 >= 0x155555555555555) {
        unint64_t v27 = 0x2AAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v27 = v26;
      }
      uint64_t v40 = a2 + 64;
      if (v27) {
        uint64_t v28 = (char *)sub_100157260(a2 + 64, v27);
      }
      else {
        uint64_t v28 = 0;
      }
      uint64_t v36 = v28;
      long long v37 = &v28[96 * v24];
      uint64_t v38 = v37;
      uint64_t v39 = &v28[96 * v27];
      sub_1003DD5AC(v37, (long long *)buf);
      v38 += 96;
      sub_10016A810(v2, &v36);
      uint64_t v23 = *(char **)(a2 + 56);
      sub_10016A954((uint64_t)&v36);
    }
    else
    {
      sub_1003DD5AC(v20, (long long *)buf);
      uint64_t v23 = v20 + 96;
      *(void *)(a2 + 56) = v23;
    }
    *(void *)(a2 + 56) = v23;
    long long v29 = *(char **)(a2 + 48);
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 64) - (void)v29) >> 5);
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((v23 - v29) >> 5);
    if (v30 > v31)
    {
      uint64_t v40 = v22;
      if (v23 == v29)
      {
        long long v32 = 0;
        uint64_t v33 = 0;
      }
      else
      {
        long long v32 = (char *)sub_100157260(v22, 0xAAAAAAAAAAAAAAABLL * ((v23 - v29) >> 5));
      }
      uint64_t v36 = v32;
      long long v37 = &v32[96 * v31];
      uint64_t v38 = v37;
      uint64_t v39 = &v32[96 * v33];
      sub_10016A810(v2, &v36);
      sub_10016A954((uint64_t)&v36);
    }
    if (SHIBYTE(v45) < 0) {
      operator delete(v44[1]);
    }
    if (SHIBYTE(v44[0]) < 0) {
      operator delete(v43[0]);
    }
    if (SHIBYTE(v42) < 0) {
      operator delete(*(void **)&buf[24]);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
LABEL_74:
  if (v62)
  {
    *(void *)long long buf = &v61;
    sub_1000C56F4((void ***)buf);
    if (v60 < 0) {
      operator delete(v59);
    }
    if (v58 < 0) {
      operator delete(v57);
    }
    if (v54)
    {
      if (v56 < 0) {
        operator delete(v55);
      }
      char v54 = 0;
    }
    if (v51)
    {
      if (v53 < 0) {
        operator delete(v52);
      }
      char v51 = 0;
    }
    if (v50 < 0) {
      operator delete(v49);
    }
    if (v46[0] && v48 < 0) {
      operator delete(*(void **)((char *)v47 + 4));
    }
  }
LABEL_92:
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
}

void sub_100CFB7EC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x100CFB6BCLL);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CFB894(uint64_t result, uint64_t a2)
{
  BOOL v2 = *(unsigned char *)(a2 + 1224) == 0;
  *(void *)(result + 8) = 0;
  uint64_t v3 = (void **)(result + 8);
  if (v2) {
    int v4 = 12;
  }
  else {
    int v4 = 14;
  }
  *(void *)(result + 16) = 0;
  *(void *)uint64_t result = v3;
  uint64_t v5 = *(int **)(a2 + 304);
  uint64_t v6 = *(int **)(a2 + 312);
  if (v5 != v6)
  {
    uint64_t v7 = result;
    int v8 = (void *)(a2 + 1096);
    do
    {
      uint64_t v9 = *v8;
      if (*v8)
      {
        int v10 = *v5;
        uint64_t v11 = v8;
        do
        {
          int v12 = *(_DWORD *)(v9 + 32);
          BOOL v13 = v12 < v4;
          if (v12 >= v4) {
            int v14 = (uint64_t *)v9;
          }
          else {
            int v14 = (uint64_t *)(v9 + 8);
          }
          if (!v13) {
            uint64_t v11 = (void *)v9;
          }
          uint64_t v9 = *v14;
        }
        while (*v14);
        if (v11 != v8 && v4 >= *((_DWORD *)v11 + 8))
        {
          uint64_t v17 = v11[6];
          uint64_t v15 = v11 + 6;
          uint64_t v16 = v17;
          if (v17)
          {
            uint64_t v18 = v15;
            do
            {
              int v19 = *(_DWORD *)(v16 + 28);
              BOOL v20 = v19 < v10;
              if (v19 >= v10) {
                unint64_t v21 = (uint64_t *)v16;
              }
              else {
                unint64_t v21 = (uint64_t *)(v16 + 8);
              }
              if (!v20) {
                uint64_t v18 = (void *)v16;
              }
              uint64_t v16 = *v21;
            }
            while (*v21);
            if (v18 != v15 && v10 >= *((_DWORD *)v18 + 7) && *((_DWORD *)v18 + 8) == 2)
            {
              uint64_t v22 = *v3;
              uint64_t v23 = v3;
              unint64_t v24 = v3;
              if (!*v3) {
                goto LABEL_36;
              }
              uint64_t v23 = v3;
              while (1)
              {
                while (1)
                {
                  unint64_t v24 = (void **)v22;
                  unint64_t v25 = v22 + 4;
                  if ((sub_100046FE8((void *)v5 + 9, (void **)v22 + 4) & 0x80) == 0) {
                    break;
                  }
                  uint64_t v22 = *v24;
                  uint64_t v23 = v24;
                  if (!*v24) {
                    goto LABEL_36;
                  }
                }
                uint64_t result = sub_100046FE8(v25, (void **)v5 + 9);
                if ((result & 0x80) == 0) {
                  break;
                }
                uint64_t v23 = v24 + 1;
                uint64_t v22 = v24[1];
                if (!v22) {
                  goto LABEL_36;
                }
              }
              uint64_t v26 = (char *)*v23;
              if (!*v23)
              {
LABEL_36:
                uint64_t v26 = (char *)operator new(0x40uLL);
                unint64_t v27 = v26 + 32;
                if (*((char *)v5 + 95) < 0)
                {
                  sub_10004FC84(v27, *((void **)v5 + 9), *((void *)v5 + 10));
                }
                else
                {
                  long long v28 = *(_OWORD *)(v5 + 18);
                  *((void *)v26 + 6) = *((void *)v5 + 11);
                  *(_OWORD *)unint64_t v27 = v28;
                }
                v26[56] = 0;
                *(void *)uint64_t v26 = 0;
                *((void *)v26 + 1) = 0;
                *((void *)v26 + 2) = v24;
                *uint64_t v23 = v26;
                uint64_t v29 = **(void **)v7;
                unint64_t v30 = (uint64_t *)v26;
                if (v29)
                {
                  *(void *)uint64_t v7 = v29;
                  unint64_t v30 = (uint64_t *)*v23;
                }
                uint64_t result = (uint64_t)sub_100046C90(*(uint64_t **)(v7 + 8), v30);
                ++*(void *)(v7 + 16);
              }
              v26[56] = 3;
            }
          }
        }
      }
      v5 += 42;
    }
    while (v5 != v6);
  }
  return result;
}

void sub_100CFBA7C(_Unwind_Exception *a1)
{
  operator delete(v1);
  sub_1000DA2E4(*v2);
  _Unwind_Resume(a1);
}

char *sub_100CFBAA0@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  char v3 = *result;
  if (*result)
  {
    if (result[31] < 0)
    {
      uint64_t result = (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 1), *((void *)result + 2));
    }
    else
    {
      *(_OWORD *)a2 = *(_OWORD *)(result + 8);
      *(void *)(a2 + 16) = *((void *)result + 3);
    }
    char v3 = 1;
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
  *(unsigned char *)(a2 + 24) = v3;
  return result;
}

void sub_100CFBB04(void *a1, int a2, uint64_t a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  CFTypeRef v9[2] = sub_100CFBC20;
  void v9[3] = &unk_101A50668;
  int v10 = a2;
  void v9[4] = a3;
  void v9[5] = a1;
  int v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  int v8 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v5;
  int v12 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v8, block);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v7);
}

void sub_100CFBC20(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v15 = 0u;
  uint64_t v3 = 1368;
  if (*(unsigned char *)(v2 + 1224))
  {
    uint64_t v4 = v2 + 1368;
  }
  else
  {
    uint64_t v3 = 328;
    uint64_t v4 = v2 + 328;
  }
  if (*(char *)(v4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)(v2 + v3), *(void *)(v4 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v4;
    *(void *)&long long v15 = *(void *)(v4 + 16);
  }
  uint64_t v6 = *(void *)(v4 + 24);
  uint64_t v5 = *(void *)(v4 + 32);
  *(void *)&long long v17 = 0;
  *((void *)&v15 + 1) = v6;
  long long v16 = 0uLL;
  sub_100311ED8(&v16, v5, *(void *)(v4 + 40), 0x2E8BA2E8BA2E8BA3 * ((*(void *)(v4 + 40) - v5) >> 3));
  *((void *)&v17 + 1) = *(void *)(v4 + 56);
  LODWORD(v18) = *(_DWORD *)(v4 + 64);
  for (uint64_t i = v16; i != *((void *)&v16 + 1); i += 88)
  {
    if (*(_DWORD *)(i + 12) == 5)
    {
      BOOL v9 = 0;
      goto LABEL_22;
    }
  }
  *(_OWORD *)long long buf = 0u;
  long long v20 = 0u;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 128) + 640))(&v12);
  (*(void (**)(uint8_t *__return_ptr))(*(void *)v12 + 24))(buf);
  if (v13) {
    sub_10004D2C8(v13);
  }
  BOOL v9 = *((void *)&v16 + 1) != (void)v16 && *(_DWORD *)buf != 0;
  if (SHIBYTE(v20) < 0) {
    operator delete(*(void **)&buf[8]);
  }
LABEL_22:
  int v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = "false";
    if (v9) {
      uint64_t v11 = "true";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I isRemotePlanAvailable: %s", buf, 0xCu);
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  *(void *)long long buf = &v16;
  sub_1000C56F4((void ***)buf);
  if (SBYTE7(v15) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100CFBEAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100CFBEE4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100CFBEDCLL);
}

void sub_100CFBEFC(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  _OWORD v8[2] = sub_100CFC014;
  void v8[3] = &unk_101A50690;
  void v8[4] = a2;
  v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (!v3 || (uint64_t v4 = a1[1], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  uint64_t v7 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v4;
  int v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t sub_100CFC014(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I isRemoteCellularPlanSupported", v7, 2u);
  }
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(v2 + 128) + 56))(*(void *)(v2 + 128));
  return (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 16))(v4, v5);
}

void sub_100CFC0C4(void *a1, int a2, uint64_t a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  CFTypeRef v9[2] = sub_100CFC1E0;
  void v9[3] = &unk_101A506B8;
  int v10 = a2;
  void v9[4] = a3;
  void v9[5] = a1;
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (!v4 || (v5 = a1[1], (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  int v8 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v5;
  uint64_t v12 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v8, block);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v7);
}

void sub_100CFC1E0(uint64_t a1)
{
  uint64_t v2 = (int *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(a1 + 48));
  uint64_t v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I shouldShowAddNewRemotePlan", (uint8_t *)&buf, 2u);
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v3 + 128) + 640))(v138);
  (*(void (**)(long long *__return_ptr))(**(void **)v138 + 24))(&buf);
  int v6 = buf;
  unint64_t v7 = *((void *)&buf + 1);
  int v8 = (void *)v143;
  int v9 = SHIBYTE(v143);
  v137[0] = DWORD2(v143);
  *(_DWORD *)((char *)v137 + 3) = *(_DWORD *)((char *)&v143 + 11);
  HIBYTE(v143) = 0;
  BYTE8(buf) = 0;
  if (*(void *)&v138[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v138[8]);
  }
  if (*(unsigned char *)(v3 + 1224))
  {
    v6 &= ~4u;
    if (v9 < 0)
    {
      int v8 = 0;
      *(unsigned char *)unint64_t v7 = 0;
    }
    else
    {
      int v9 = 0;
      v7 &= 0xFFFFFFFFFFFFFF00;
    }
  }
  int v10 = (*(uint64_t (**)(void, void))(**(void **)(v3 + 160) + 168))(*(void *)(v3 + 160), *v2);
  int v11 = v6 | 8;
  if (!v10) {
    int v11 = v6;
  }
  unsigned int v77 = v11;
  if ((*(uint64_t (**)(void))(**(void **)(v3 + 128) + 56))(*(void *)(v3 + 128)))
  {
    unint64_t v74 = (unint64_t)v8;
    int v76 = v9;
    uint64_t v133 = 0;
    long long v132 = 0u;
    long long v131 = 0u;
    long long v130 = 0u;
    long long __dst = 0u;
    if (*(unsigned char *)(v3 + 1224)) {
      uint64_t v12 = (long long *)(v3 + 1368);
    }
    else {
      uint64_t v12 = (long long *)(v3 + 328);
    }
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(&__dst, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long __dst = *v12;
      *(void *)&long long v130 = *((void *)v12 + 2);
    }
    uint64_t v16 = *((void *)v12 + 3);
    uint64_t v15 = *((void *)v12 + 4);
    *(void *)&long long v132 = 0;
    *((void *)&v130 + 1) = v16;
    long long v131 = 0uLL;
    sub_100311ED8(&v131, v15, *((void *)v12 + 5), 0x2E8BA2E8BA2E8BA3 * ((*((void *)v12 + 5) - v15) >> 3));
    *((void *)&v132 + 1) = *((void *)v12 + 7);
    LODWORD(v133) = *((_DWORD *)v12 + 16);
    uint64_t v17 = v131;
    int v9 = v76;
    if ((void)v131 != *((void *)&v131 + 1))
    {
      while (*(_DWORD *)(v17 + 12) != 5)
      {
        v17 += 88;
        if (v17 == *((void *)&v131 + 1)) {
          goto LABEL_25;
        }
      }
      long long v20 = *v4;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I a remote sim is unauthorized", (uint8_t *)&buf, 2u);
      }
      uint64_t v21 = *(void *)(a1 + 32);
      if (v76 < 0)
      {
        sub_10004FC84(__p, (void *)v7, (unint64_t)v8);
      }
      else
      {
        __p[0] = (void *)v7;
        __p[1] = v8;
        *(_DWORD *)uint64_t v127 = v137[0];
        *(_DWORD *)&v127[3] = *(_DWORD *)((char *)v137 + 3);
        char v128 = v76;
      }
      (*(void (**)(uint64_t, void, void, void **, void))(v21 + 16))(v21, 0, v77, __p, 0);
      if (v128 < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_71;
    }
LABEL_25:
    long long v151 = 0u;
    long long v152 = 0u;
    long long v149 = 0u;
    long long v150 = 0u;
    long long v147 = 0u;
    long long v148 = 0u;
    long long v145 = 0u;
    long long v146 = 0u;
    long long v143 = 0u;
    long long v144 = 0u;
    long long buf = 0u;
    sub_100CCD910(*v2, (_DWORD **)(v3 + 304), (char *)&buf);
    if ((_BYTE)buf) {
      uint64_t isSimReady = subscriber::isSimReady();
    }
    else {
      uint64_t isSimReady = 0;
    }
    long long v141 = 0uLL;
    if (*((void *)&v131 + 1) == (void)v131)
    {
      uint64_t v26 = *v4;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v138 = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I csn unavailable, do not show", v138, 2u);
      }
      uint64_t v27 = *(void *)(a1 + 32);
      if (v76 < 0)
      {
        sub_10004FC84(v123, (void *)v7, (unint64_t)v8);
      }
      else
      {
        v123[0] = (void *)v7;
        v123[1] = v8;
        *(_DWORD *)long long v124 = v137[0];
        *(_DWORD *)&v124[3] = *(_DWORD *)((char *)v137 + 3);
        char v125 = v76;
      }
      (*(void (**)(uint64_t, uint64_t, void, void **, void))(v27 + 16))(v27, isSimReady, v77, v123, 0);
      if ((v125 & 0x80000000) == 0) {
        goto LABEL_69;
      }
      uint64_t v33 = v123[0];
      goto LABEL_68;
    }
    long long v141 = *(_OWORD *)(v131 + 16);
    if (*(void *)(v3 + 256))
    {
      *(_OWORD *)long long v138 = 0uLL;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v3 + 96) + 64))(v138);
      if (((*(uint64_t (**)(void))(**(void **)(v3 + 160) + 176))(*(void *)(v3 + 160)) & 1) != 0
        || *v2 != *(_DWORD *)(v3 + 1040)
        || ((*(void *)&long long v140 = (*(uint64_t (**)(void))(**(void **)(v3 + 256) + 104))(*(void *)(v3 + 256)),
             *((void *)&v140 + 1) = v22,
             (void)v140 == (void)v141)
          ? (BOOL v23 = v22 == *((void *)&v141 + 1))
          : (BOOL v23 = 0),
            !v23
         || !*(void *)v138
         || ((*(uint64_t (**)(void))(**(void **)v138 + 192))(*(void *)v138) & 1) == 0))
      {
        unint64_t v24 = *v4;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v140) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "another provisioning operation is present, do not show", (uint8_t *)&v140, 2u);
        }
        uint64_t v25 = *(void *)(a1 + 32);
        if (v76 < 0)
        {
          sub_10004FC84(v120, (void *)v7, (unint64_t)v8);
        }
        else
        {
          v120[0] = (void *)v7;
          v120[1] = v8;
          *(_DWORD *)uint64_t v121 = v137[0];
          *(_DWORD *)&v121[3] = *(_DWORD *)((char *)v137 + 3);
          char v122 = v76;
        }
        (*(void (**)(uint64_t, void, void, void **, void))(v25 + 16))(v25, 0, v77, v120, 0);
        if (v122 < 0) {
          operator delete(v120[0]);
        }
        if (*(void *)&v138[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v138[8]);
        }
        goto LABEL_70;
      }
      if (*(void *)&v138[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v138[8]);
      }
    }
    else if (*(unsigned char *)(v3 + 1224))
    {
      int __src = (unsigned char *)v7;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v3 + 160) + 272))(v138);
      uint64_t v29 = *(void *)&v138[8];
      uint64_t v28 = *(void *)v138;
      *(void *)&long long v140 = v138;
      sub_1000C63B8((void ***)&v140);
      BOOL v23 = v28 == v29;
      unint64_t v7 = (unint64_t)__src;
      int v9 = v76;
      if (!v23)
      {
        unint64_t v30 = *v4;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long v138 = 0;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I tinker paired and pending ALS profile/es", v138, 2u);
        }
        int v31 = *(_DWORD *)(a1 + 48);
        uint64_t v32 = *(void *)(a1 + 32);
        if (v76 < 0)
        {
          sub_10004FC84(v117, __src, (unint64_t)v8);
        }
        else
        {
          v117[0] = __src;
          v117[1] = v8;
          *(_DWORD *)uint64_t v118 = v137[0];
          *(_DWORD *)&void v118[3] = *(_DWORD *)((char *)v137 + 3);
          char v119 = v76;
        }
        (*(void (**)(uint64_t, BOOL, void, void **, void))(v32 + 16))(v32, v31 == 1, v77, v117, 0);
        if ((v119 & 0x80000000) == 0) {
          goto LABEL_70;
        }
        uint64_t v39 = v117[0];
        goto LABEL_94;
      }
    }
    if ((isSimReady & 1) == 0)
    {
      long long v37 = *v4;
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v138 = 0;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I sim info not available or sim not ready", v138, 2u);
      }
      uint64_t v38 = *(void *)(a1 + 32);
      if (v9 < 0)
      {
        sub_10004FC84(v114, (void *)v7, (unint64_t)v8);
      }
      else
      {
        v114[0] = v7;
        v114[1] = v8;
        *(_DWORD *)uint64_t v115 = v137[0];
        *(_DWORD *)&v115[3] = *(_DWORD *)((char *)v137 + 3);
        char v116 = v9;
      }
      (*(void (**)(uint64_t, void, void, void *, void))(v38 + 16))(v38, 0, v77, v114, 0);
      if ((v116 & 0x80000000) == 0) {
        goto LABEL_69;
      }
      uint64_t v33 = (void *)v114[0];
      goto LABEL_68;
    }
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(v3 + 160) + 240))(v138);
    int v34 = v138[0];
    sub_100D1568C((uint64_t)v138);
    if (v34)
    {
      std::string v35 = *v4;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v138 = 0;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I has a selectable plan", v138, 2u);
      }
      uint64_t v36 = *(void *)(a1 + 32);
      if (v76 < 0)
      {
        sub_10004FC84(v111, (void *)v7, (unint64_t)v8);
      }
      else
      {
        v111[0] = v7;
        v111[1] = v8;
        *(_DWORD *)uint64_t v112 = v137[0];
        *(_DWORD *)&v112[3] = *(_DWORD *)((char *)v137 + 3);
        char v113 = v76;
      }
      (*(void (**)(uint64_t, void, void, void *, void))(v36 + 16))(v36, 0, v77, v111, 0);
      if ((v113 & 0x80000000) == 0) {
        goto LABEL_69;
      }
      uint64_t v33 = (void *)v111[0];
LABEL_68:
      operator delete(v33);
LABEL_69:
      int v9 = v76;
LABEL_70:
      sub_1003DD210(&buf);
LABEL_71:
      *(void *)&long long buf = &v131;
      sub_1000C56F4((void ***)&buf);
      if ((SBYTE7(v130) & 0x80000000) == 0) {
        goto LABEL_74;
      }
      int v19 = (void *)__dst;
      goto LABEL_73;
    }
    if (*(unsigned char *)(v3 + 1224)) {
      uint64_t v40 = (const std::string *)(v3 + 1232);
    }
    else {
      uint64_t v40 = (const std::string *)(v3 + 408);
    }
    if ((sub_100CFD86C(*(void *)(v3 + 128), *v2, v40) & 1) == 0)
    {
      long long v47 = *v4;
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        uint64_t v64 = cellplan::asString();
        *(_DWORD *)long long v138 = 136315138;
        *(void *)&v138[4] = v64;
        _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Carrier doesn't support the device sku: %s", v138, 0xCu);
      }
      uint64_t v48 = *(void *)(a1 + 32);
      if (v76 < 0)
      {
        sub_10004FC84(v108, (void *)v7, (unint64_t)v8);
      }
      else
      {
        v108[0] = v7;
        v108[1] = v8;
        *(_DWORD *)long long v109 = v137[0];
        *(_DWORD *)&v109[3] = *(_DWORD *)((char *)v137 + 3);
        char v110 = v76;
      }
      (*(void (**)(uint64_t, uint64_t, void, void *, uint64_t))(v48 + 16))(v48, 1, v77, v108, 21);
      if ((v110 & 0x80000000) == 0) {
        goto LABEL_69;
      }
      uint64_t v33 = (void *)v108[0];
      goto LABEL_68;
    }
    if (!v77)
    {
      uint64_t v49 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v138 = 0;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I No cellular plan flow types allowed", v138, 2u);
      }
      uint64_t v50 = *(void *)(a1 + 32);
      if (v76 < 0)
      {
        sub_10004FC84(v105, (void *)v7, v74);
      }
      else
      {
        v105[0] = v7;
        v105[1] = v74;
        *(_DWORD *)long long v106 = v137[0];
        *(_DWORD *)&v106[3] = *(_DWORD *)((char *)v137 + 3);
        char v107 = v76;
      }
      (*(void (**)(uint64_t, void, void, void *, uint64_t))(v50 + 16))(v50, 0, 0, v105, 22);
      if ((v107 & 0x80000000) == 0) {
        goto LABEL_69;
      }
      uint64_t v33 = (void *)v105[0];
      goto LABEL_68;
    }
    int v9 = v76;
    if (!sub_10004D710()) {
      goto LABEL_107;
    }
    LOBYTE(v140) = 1;
    uint64_t v41 = sub_100365D74();
    sub_100058DB0(v138, "EnablePlanSelection");
    sub_1002260B0(v41, (void **)v138, (BOOL *)&v140);
    if (v139 < 0) {
      operator delete(*(void **)v138);
    }
    if (!(_BYTE)v140)
    {
      char v60 = *v4;
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v138 = 0;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I Non-POR - allowing new plan", v138, 2u);
      }
      uint64_t v61 = *(void *)(a1 + 32);
      if (v76 < 0)
      {
        sub_10004FC84(v102, (void *)v7, (unint64_t)v8);
      }
      else
      {
        v102[0] = v7;
        v102[1] = v8;
        *(_DWORD *)long long v103 = v137[0];
        *(_DWORD *)&v103[3] = *(_DWORD *)((char *)v137 + 3);
        char v104 = v76;
      }
      (*(void (**)(uint64_t, uint64_t, void, void *, void))(v61 + 16))(v61, 1, v77, v102, 0);
      if ((v104 & 0x80000000) == 0) {
        goto LABEL_70;
      }
      uint64_t v39 = (void *)v102[0];
    }
    else
    {
LABEL_107:
      unsigned int v42 = (*(uint64_t (**)(void))(**(void **)(v3 + 128) + 304))();
      if (*(unsigned char *)(v3 + 1224)) {
        uint64_t v43 = v3 + 1368;
      }
      else {
        uint64_t v43 = v3 + 328;
      }
      unsigned int v44 = *(_DWORD *)(v43 + 64);
      if (v44 < v42 && v44)
      {
        long long v45 = *v4;
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long v138 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Current watch OS version is lower than the minimum compatible version", v138, 2u);
        }
        uint64_t v46 = *(void *)(a1 + 32);
        if (v76 < 0)
        {
          sub_10004FC84(v99, (void *)v7, (unint64_t)v8);
        }
        else
        {
          v99[0] = v7;
          v99[1] = v8;
          *(_DWORD *)int v100 = v137[0];
          *(_DWORD *)&v100[3] = *(_DWORD *)((char *)v137 + 3);
          char v101 = v76;
        }
        (*(void (**)(uint64_t, uint64_t, void, void *, uint64_t))(v46 + 16))(v46, 1, v77, v99, 32);
        if ((v101 & 0x80000000) == 0) {
          goto LABEL_70;
        }
        uint64_t v39 = (void *)v99[0];
        goto LABEL_94;
      }
      if (!*(unsigned char *)(v3 + 736) && sub_100CFDA28((void *)v3, *v2))
      {
        char v51 = *v4;
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long v138 = 0;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I device is in roaming", v138, 2u);
        }
        uint64_t v52 = *(void *)(a1 + 32);
        if (v76 < 0)
        {
          sub_10004FC84(v96, (void *)v7, (unint64_t)v8);
        }
        else
        {
          v96[0] = v7;
          v96[1] = v8;
          *(_DWORD *)char v97 = v137[0];
          *(_DWORD *)&v97[3] = *(_DWORD *)((char *)v137 + 3);
          char v98 = v76;
        }
        (*(void (**)(uint64_t, uint64_t, void, void *, uint64_t))(v52 + 16))(v52, 1, v77, v96, 14);
        if ((v98 & 0x80000000) == 0) {
          goto LABEL_70;
        }
        uint64_t v39 = (void *)v96[0];
        goto LABEL_94;
      }
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v3 + 128) + 640))(v138);
      uint64_t v95 = 0;
      int v53 = (*(uint64_t (**)(void, const void **, void))(**(void **)v138 + 16))(*(void *)v138, &v95, *v2);
      sub_100057D78(&v95);
      if (*(void *)&v138[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v138[8]);
      }
      if (!v53) {
        goto LABEL_152;
      }
      if (*(unsigned char *)(v3 + 1224)) {
        int v54 = 11;
      }
      else {
        int v54 = 10;
      }
      int v94 = v54;
      (***(void (****)(long long *__return_ptr))(v3 + 128))(&v93);
      long long v140 = v93;
      long long v93 = 0uLL;
      PersonalityIdFromSlotId();
      unsigned int v55 = (unsigned __int16)sub_1003B64CC(v3 + 848, (void **)v138, v54);
      if (v55 <= 0x100) {
        char v56 = 0;
      }
      else {
        char v56 = v55;
      }
      if (v139 < 0) {
        operator delete(*(void **)v138);
      }
      if (*((void *)&v140 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v140 + 1));
      }
      if (*((void *)&v93 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v93 + 1));
      }
      uint64_t v57 = sub_1009127C8((uint64_t **)(v3 + 1088), v54, &v94);
      if (*((_DWORD *)sub_1005BD92C(v57 + 5, *v2, v2) + 8) == 2)
      {
LABEL_152:
        if (*(unsigned char *)(v3 + 1224)
          && (*(unsigned int (**)(void, void))(**(void **)(v3 + 160) + 136))(*(void *)(v3 + 160), *v2))
        {
          char v58 = *v4;
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long v138 = 0;
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I active remote plan found for primary iccid", v138, 2u);
          }
          uint64_t v59 = *(void *)(a1 + 32);
          if (v9 < 0)
          {
            sub_10004FC84(v84, (void *)v7, (unint64_t)v8);
          }
          else
          {
            v84[0] = v7;
            v84[1] = v8;
            *(_DWORD *)unint64_t v85 = v137[0];
            *(_DWORD *)&v85[3] = *(_DWORD *)((char *)v137 + 3);
            char v86 = v9;
          }
          (*(void (**)(uint64_t, void, void, void *, void))(v59 + 16))(v59, 0, v77, v84, 0);
          if ((v86 & 0x80000000) == 0) {
            goto LABEL_70;
          }
          uint64_t v39 = (void *)v84[0];
        }
        else if ((*(unsigned int (**)(void))(**(void **)(v3 + 160) + 160))(*(void *)(v3 + 160)))
        {
          char v62 = *v4;
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long v138 = 0;
            _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I Subscription is pending release", v138, 2u);
          }
          uint64_t v63 = *(void *)(a1 + 32);
          if (v9 < 0)
          {
            sub_10004FC84(v81, (void *)v7, (unint64_t)v8);
          }
          else
          {
            v81[0] = v7;
            v81[1] = v8;
            *(_DWORD *)uint64_t v82 = v137[0];
            *(_DWORD *)&v82[3] = *(_DWORD *)((char *)v137 + 3);
            char v83 = v9;
          }
          (*(void (**)(uint64_t, void, void, void *, void))(v63 + 16))(v63, 0, v77, v81, 0);
          if ((v83 & 0x80000000) == 0) {
            goto LABEL_70;
          }
          uint64_t v39 = (void *)v81[0];
        }
        else
        {
          uint64_t v65 = *(void *)(a1 + 32);
          if (v9 < 0)
          {
            sub_10004FC84(v78, (void *)v7, (unint64_t)v8);
          }
          else
          {
            v78[0] = v7;
            v78[1] = v8;
            *(_DWORD *)uint64_t v79 = v137[0];
            *(_DWORD *)&v79[3] = *(_DWORD *)((char *)v137 + 3);
            char v80 = v9;
          }
          (*(void (**)(uint64_t, uint64_t, void, void *, void))(v65 + 16))(v65, 1, v77, v78, 0);
          if ((v80 & 0x80000000) == 0) {
            goto LABEL_70;
          }
          uint64_t v39 = (void *)v78[0];
        }
        goto LABEL_94;
      }
      v77 &= 2u;
      if (v76 < 0)
      {
        int v8 = 0;
        *(unsigned char *)unint64_t v7 = 0;
      }
      else
      {
        int v9 = 0;
        v7 &= 0xFFFFFFFFFFFFFF00;
      }
      unint64_t v75 = (unint64_t)v8;
      if (v77 || v56)
      {
        if (v77) {
          goto LABEL_152;
        }
        long long v68 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
        {
          char v72 = sub_100059954(v54);
          *(_DWORD *)long long v138 = 136315138;
          *(void *)&v138[4] = v72;
          _os_log_error_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "User is not entitled for watch service (%s)", v138, 0xCu);
        }
        uint64_t v69 = *(void *)(a1 + 32);
        if (v9 < 0)
        {
          sub_10004FC84(v87, (void *)v7, v75);
        }
        else
        {
          v87[0] = v7;
          v87[1] = v75;
          *(_DWORD *)char v88 = v137[0];
          *(_DWORD *)&v88[3] = *(_DWORD *)((char *)v137 + 3);
          char v89 = 0;
        }
        (*(void (**)(uint64_t, void, void, void *, uint64_t))(v69 + 16))(v69, 0, 0, v87, 27);
        if ((v89 & 0x80000000) == 0) {
          goto LABEL_70;
        }
        long long v70 = (void **)v87;
      }
      else
      {
        long long v66 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
        {
          int v71 = sub_100059954(v54);
          *(_DWORD *)long long v138 = 136315138;
          *(void *)&v138[4] = v71;
          _os_log_error_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "Carrier does not support watch service (%s)", v138, 0xCu);
        }
        uint64_t v67 = *(void *)(a1 + 32);
        if (v9 < 0)
        {
          sub_10004FC84(v90, (void *)v7, v75);
        }
        else
        {
          v90[0] = v7;
          v90[1] = v75;
          *(_DWORD *)uint64_t v91 = v137[0];
          *(_DWORD *)&v91[3] = *(_DWORD *)((char *)v137 + 3);
          char v92 = 0;
        }
        (*(void (**)(uint64_t, void, void, void *, uint64_t))(v67 + 16))(v67, 0, 0, v90, 22);
        if ((v92 & 0x80000000) == 0) {
          goto LABEL_70;
        }
        long long v70 = (void **)v90;
      }
      uint64_t v39 = *v70;
    }
LABEL_94:
    operator delete(v39);
    goto LABEL_70;
  }
  BOOL v13 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I does not support remote cellular plan", (uint8_t *)&buf, 2u);
  }
  uint64_t v14 = *(void *)(a1 + 32);
  if (v9 < 0)
  {
    sub_10004FC84(v134, (void *)v7, (unint64_t)v8);
  }
  else
  {
    v134[0] = v7;
    v134[1] = v8;
    *(_DWORD *)uint32_t v135 = v137[0];
    *(_DWORD *)&v135[3] = *(_DWORD *)((char *)v137 + 3);
    char v136 = v9;
  }
  (*(void (**)(uint64_t, void, void, void *, void))(v14 + 16))(v14, 0, v77, v134, 0);
  if (v136 < 0)
  {
    int v19 = (void *)v134[0];
LABEL_73:
    operator delete(v19);
  }
LABEL_74:
  if (v9 < 0) {
    operator delete((void *)v7);
  }
}

void sub_100CFD578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, int a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61,uint64_t a62,uint64_t a63)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  sub_1003DD210(&STACK[0x2C0]);
  sub_1003CC6D4((uint64_t)&a70);
  if (a13 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CFD86C(uint64_t a1, uint64_t a2, const std::string *a3)
{
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 640))(&v11);
  (*(void (**)(void **__return_ptr))(*(void *)v11 + 72))(&__p);
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (!a3[3].__r_.__value_.__s.__data_[16]) {
    goto LABEL_20;
  }
  uint64_t v4 = (unsigned __int8 *)__p;
  uint64_t v5 = v14;
  if (__p == v14)
  {
    uint64_t v6 = 1;
    if (!__p) {
      return v6;
    }
    goto LABEL_22;
  }
  uint64_t v6 = 1;
  while (2)
  {
    int v7 = std::string::compare(a3 + 4, "Watch4,4");
    int v8 = *v4;
    if (v7 >= 1 && v8 == 7)
    {
LABEL_20:
      uint64_t v6 = 1;
    }
    else
    {
      switch(a3[3].__r_.__value_.__s.__data_[16])
      {
        case 5:
          if ((v8 - 2) < 3) {
            goto LABEL_20;
          }
          goto LABEL_18;
        case 6:
          if (v8 == 2) {
            goto LABEL_20;
          }
          goto LABEL_18;
        case 8:
          break;
        case 9:
          if ((v8 - 1) < 2) {
            goto LABEL_20;
          }
          goto LABEL_18;
        default:
          if (a3[3].__r_.__value_.__s.__data_[16] == v8) {
            goto LABEL_20;
          }
LABEL_18:
          if (++v4 != v5) {
            continue;
          }
          uint64_t v6 = 0;
          break;
      }
    }
    break;
  }
  uint64_t v4 = (unsigned __int8 *)__p;
  if (__p)
  {
LABEL_22:
    uint64_t v14 = v4;
    operator delete(v4);
  }
  return v6;
}

void sub_100CFD9FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CFDA28(void *a1, int a2)
{
  BOOL v22 = 0;
  if (sub_10004D710())
  {
    uint64_t v4 = sub_100365D74();
    sub_100058DB0(__p, "RoamingSignupOverride");
    sub_1002260B0(v4, (void **)__p, &v22);
    if (v24 < 0) {
      operator delete(*(void **)__p);
    }
    if (v22) {
      return 0;
    }
  }
  uint64_t v6 = a1[101];
  if (!v6) {
    goto LABEL_16;
  }
  int v7 = a1 + 101;
  do
  {
    int v8 = *(_DWORD *)(v6 + 28);
    BOOL v9 = v8 < a2;
    if (v8 >= a2) {
      int v10 = (uint64_t *)v6;
    }
    else {
      int v10 = (uint64_t *)(v6 + 8);
    }
    if (!v9) {
      int v7 = (void *)v6;
    }
    uint64_t v6 = *v10;
  }
  while (*v10);
  if (v7 != a1 + 101 && *((_DWORD *)v7 + 7) <= a2)
  {
    BOOL v12 = *((_DWORD *)v7 + 8) == 4;
  }
  else
  {
LABEL_16:
    uint64_t v11 = a1[5];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = subscriber::asString();
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = v20;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Roaming results is not found for slot: %s", __p, 0xCu);
    }
    BOOL v12 = 0;
  }
  uint64_t v13 = a1[104];
  if (!v13) {
    goto LABEL_29;
  }
  uint64_t v14 = a1 + 104;
  do
  {
    int v15 = *(_DWORD *)(v13 + 28);
    BOOL v16 = v15 < a2;
    if (v15 >= a2) {
      uint64_t v17 = (uint64_t *)v13;
    }
    else {
      uint64_t v17 = (uint64_t *)(v13 + 8);
    }
    if (!v16) {
      uint64_t v14 = (void *)v13;
    }
    uint64_t v13 = *v17;
  }
  while (*v17);
  if (v14 != a1 + 104 && *((_DWORD *)v14 + 7) <= a2)
  {
    BOOL v19 = *((unsigned __int8 *)v14 + 32) == 0;
  }
  else
  {
LABEL_29:
    uint64_t v18 = a1[5];
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = subscriber::asString();
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = v21;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "in home countries is not found for slot: %s", __p, 0xCu);
    }
    BOOL v19 = 0;
  }
  return v12 & v19;
}

void sub_100CFDC30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100CFDC54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (***v12)(uint8_t *__return_ptr, void, dispatch_object_t *, uint64_t *, uint64_t);
  NSObject *v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  long long v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  dispatch_object_t object;
  void *__p;
  char v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  unsigned char v31[32];
  long long v32;
  long long v33;
  uint64_t v34;
  uint64_t v35[2];
  uint64_t v36;
  uint8_t v37[16];
  _OWORD v38[2];
  long long v39;
  long long v40;
  long long v41;
  long long v42;
  long long v43;
  _OWORD v44[9];
  uint64_t v45;
  uint8_t buf[16];
  uint8_t *v47;

  long long v45 = 0;
  uint64_t v43 = 0u;
  memset(v44, 0, sizeof(v44));
  uint64_t v41 = 0u;
  unsigned int v42 = 0u;
  uint64_t v39 = 0u;
  uint64_t v40 = 0u;
  sub_100CF724C(&v39, a1, a3);
  int v34 = 0;
  uint64_t v32 = 0u;
  uint64_t v33 = 0u;
  memset(v31, 0, sizeof(v31));
  if (!BYTE8(v39))
  {
    uint64_t v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v37 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Cannot find vinyl info", v37, 2u);
    }
    goto LABEL_40;
  }
  std::string::operator=((std::string *)v31, (const std::string *)&v40);
  *(void *)&v31[24] = *((void *)&v41 + 1);
  sub_1003DB294((uint64_t)&v32, v42, *((uint64_t *)&v42 + 1), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)&v42 + 1) - v42) >> 3));
  *((void *)&v33 + 1) = *((void *)&v43 + 1);
  LODWORD(v34) = v44[0];
  if (*((void *)&v32 + 1) == (void)v32
    || !*(unsigned char *)(v32 + 80)
    || (uint64_t v6 = *(void *)(v32 + 56), v5 = *(void *)(v32 + 64), v5 == v6))
  {
    a2 = 0;
LABEL_10:
    if (!*(void *)(a1 + 272))
    {
      memset(v38, 0, sizeof(v38));
      *(_OWORD *)long long v37 = 0u;
      int v7 = *(NSObject **)(a1 + 40);
      os_signpost_id_t v8 = os_signpost_id_generate(v7);
      if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        BOOL v9 = *(NSObject **)(a1 + 40);
        if (os_signpost_enabled(v9))
        {
          *(_WORD *)long long buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_BEGIN, v8, "CellularPlanRemoteProvisioning", (const char *)&unk_1017DEDA7, buf, 2u);
        }
      }
      *(void *)long long buf = off_101A517B0;
      long long v47 = buf;
      *(void *)long long v37 = v8;
      *(void *)&v37[8] = os_retain(v7);
      sub_1000336E8((uint64_t)v38, (uint64_t)buf);
      sub_100033A10(buf);
      (***(void (****)(uint64_t *__return_ptr))(a1 + 128))(&v29);
      sub_100058DB0(&__p, "Remote_Provisioning");
      v35[0] = *(void *)v37;
      v35[1] = *(void *)&v37[8];
      sub_1000336E8((uint64_t)&v36, (uint64_t)v38);
      memset(v37, 0, sizeof(v37));
      sub_100033AF4(v38);
      Registry::createXpcJetsamAssertion();
      long long v10 = *(_OWORD *)buf;
      memset(buf, 0, sizeof(buf));
      uint64_t v11 = *(std::__shared_weak_count **)(a1 + 280);
      *(_OWORD *)(a1 + 272) = v10;
      if (v11)
      {
        sub_10004D2C8(v11);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      sub_1000339DC(v35);
      if (v28 < 0) {
        operator delete(__p);
      }
      if (v30) {
        sub_10004D2C8(v30);
      }
      sub_1000339DC((uint64_t *)v37);
    }
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 128) + 640))(buf);
    BOOL v12 = *(void (****)(uint8_t *__return_ptr, void, dispatch_object_t *, uint64_t *, uint64_t))buf;
    uint64_t v13 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v13;
    if (v13) {
      dispatch_retain(v13);
    }
    uint64_t v14 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v14 || (int v15 = *(void *)(a1 + 8), (v16 = std::__shared_weak_count::lock(v14)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v17 = v15 + 64;
    if (!v15) {
      uint64_t v17 = 0;
    }
    char v24 = v17;
    uint64_t v25 = v16;
    (**v12)(v37, v12, &object, &v24, a2);
    uint64_t v18 = *(_OWORD *)v37;
    memset(v37, 0, sizeof(v37));
    BOOL v19 = *(std::__shared_weak_count **)(a1 + 264);
    *(_OWORD *)(a1 + 256) = v18;
    if (v19)
    {
      sub_10004D2C8(v19);
      if (*(void *)&v37[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v37[8]);
      }
    }
    if (v25) {
      sub_10004D2C8(v25);
    }
    if (object) {
      dispatch_release(object);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    uint64_t v20 = 1;
  }
  else
  {
    while (!*(unsigned char *)(v6 + 91) || (a2 & 1) != 0)
    {
      v6 += 216;
      if (v6 == v5) {
        goto LABEL_10;
      }
    }
    BOOL v23 = *(NSObject **)(a1 + 40);
    uint64_t v20 = 0;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v37 = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I cannot create remote provisioning, disable not allowed", v37, 2u);
LABEL_40:
      uint64_t v20 = 0;
    }
  }
  *(void *)long long v37 = &v32;
  sub_1000C56F4((void ***)v37);
  if ((v31[23] & 0x80000000) != 0) {
    operator delete(*(void **)v31);
  }
  sub_100D156EC((uint64_t)v44 + 8);
  sub_100D1541C((uint64_t)&v39 + 8);
  return v20;
}

void sub_100CFE110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, dispatch_object_t object, void *__p, uint64_t a6, int a7, __int16 a8, char a9, char a10, uint64_t a11, std::__shared_weak_count *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,...)
{
  va_start(va, a45);
  sub_1000339DC(&a23);
  if (a10 < 0) {
    operator delete(__p);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_1000339DC(&a29);
  sub_1003CC6D4((uint64_t)&a13);
  sub_100D156EC((uint64_t)va);
  sub_100D1541C(v45);
  _Unwind_Resume(a1);
}

const void **sub_100CFE1CC(void *a1, int a2, char a3, const void **a4, const void **a5, char a6, uint64_t a7)
{
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 1174405120;
  _DWORD v17[2] = sub_100CFE334;
  void v17[3] = &unk_101A50718;
  int v20 = a2;
  v17[4] = a7;
  v17[5] = a1;
  sub_100083DA4(&v18, a4);
  sub_100083DA4(&v19, a5);
  char v21 = a6;
  char v22 = a3;
  uint64_t v11 = (std::__shared_weak_count *)a1[2];
  if (!v11 || (uint64_t v12 = a1[1], (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v14 = v13;
  int v15 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100D182E0;
  block[3] = &unk_101A51770;
  block[5] = v12;
  char v24 = v14;
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v17;
  dispatch_async(v15, block);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_10004D2C8(v14);
  sub_1000558F4(&v19);
  return sub_1000558F4(&v18);
}

void sub_100CFE334(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 64));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I handleNewRemoteDataPlanFlowTriggered", buf, 2u);
  }
  *(_OWORD *)long long buf = 0u;
  long long v13 = 0u;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 128) + 640))(&v10);
  (*(void (**)(uint8_t *__return_ptr))(*(void *)v10 + 24))(buf);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if ((buf[0] & 2) != 0)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 64);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 1174405120;
    void v5[2] = sub_100CFEE08;
    uint64_t v5[3] = &unk_101A506E0;
    _OWORD v5[4] = *(void *)(a1 + 32);
    void v5[5] = v2;
    sub_100083DA4(&v6, (const void **)(a1 + 48));
    sub_100083DA4(&v7, (const void **)(a1 + 56));
    int v8 = *(_DWORD *)(a1 + 64);
    __int16 v9 = *(_WORD *)(a1 + 68);
    sub_100CFE56C(v2, v4, (uint64_t)v5);
    sub_1000558F4(&v7);
    sub_1000558F4(&v6);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(*(void **)&buf[8]);
  }
}

void sub_100CFE524(_Unwind_Exception *a1)
{
  sub_1000558F4(v2);
  sub_1000558F4(v1);
  if (*(char *)(v3 - 49) < 0) {
    operator delete(*(void **)(v3 - 72));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100CFE56C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  long long v51 = 0uLL;
  uint64_t v7 = a1 + 1368;
  if (!*(unsigned char *)(a1 + 1224)) {
    uint64_t v7 = a1 + 328;
  }
  uint64_t v8 = *(void *)(v7 + 32);
  if (*(void *)(v7 + 40) != v8 && *(unsigned char *)(v7 + 24)) {
    long long v51 = *(_OWORD *)(v8 + 16);
  }
  uint64_t v50 = 0;
  memset(v49, 0, sizeof(v49));
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  memset(v44, 0, sizeof(v44));
  sub_100CF724C(v44, a1, (uint64_t)&v51);
  memset(v43, 0, sizeof(v43));
  sub_100CCD910(a2, (_DWORD **)(a1 + 304), (char *)v43);
  if (BYTE8(v44[0]) && (void)v46 != *((void *)&v46 + 1) && *(_DWORD *)(v46 + 12) == 5)
  {
    uint64_t v9 = 64;
    goto LABEL_34;
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 160) + 240))(buf);
  int v10 = buf[0];
  sub_100D1568C((uint64_t)buf);
  if (v10)
  {
    uint64_t v11 = *v6;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I has selectable profile", buf, 2u);
    }
    uint64_t v9 = 15;
    goto LABEL_34;
  }
  if (*(void *)(a1 + 256))
  {
    uint64_t v12 = *v6;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I another user operation is running", buf, 2u);
    }
    uint64_t v9 = 13;
    goto LABEL_34;
  }
  *(void *)long long buf = 0;
  uint64_t v41 = 0;
  if (v51 != 0 && BYTE8(v44[0]) && BYTE8(v48))
  {
    if (sub_100CFD86C(*(void *)(a1 + 128), a2, (const std::string *)v49))
    {
      if (!BYTE8(v44[0])) {
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
      if (HIDWORD(v45) == 1)
      {
        long long v13 = *v6;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I remote device locked", buf, 2u);
        }
        uint64_t v9 = 30;
        goto LABEL_34;
      }
      if (BYTE13(v47) && BYTE12(v47) == 1)
      {
        uint64_t v18 = *v6;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I card out of memory", buf, 2u);
        }
        uint64_t v9 = 20;
        goto LABEL_34;
      }
      if (LOBYTE(v44[0]))
      {
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 160) + 272))(buf);
        BOOL v19 = *(std::__shared_weak_count **)buf;
        int v20 = v41;
        *(void *)uint64_t v39 = buf;
        sub_1000C63B8((void ***)v39);
        if (v19 != v20)
        {
          char v21 = *v6;
          BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
          uint64_t v9 = 0;
          if (!v22) {
            goto LABEL_34;
          }
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I tinker paired and pending ALS profile/es", buf, 2u);
          goto LABEL_47;
        }
      }
      if (LOBYTE(v43[0]) && subscriber::isSimLocked())
      {
        BOOL v23 = *v6;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I sim is pin locked", buf, 2u);
        }
        uint64_t v9 = 31;
        goto LABEL_34;
      }
      if (*(unsigned char *)(a1 + 736))
      {
        char v24 = *v6;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I airplane mode is on", buf, 2u);
        }
        uint64_t v9 = 28;
        goto LABEL_34;
      }
      if (*(unsigned char *)(a1 + 737))
      {
        if (sub_100CFDA28((void *)a1, a2))
        {
          uint64_t v25 = *v6;
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I international roaming", buf, 2u);
          }
          uint64_t v9 = 14;
          goto LABEL_34;
        }
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 128) + 640))(buf);
        uint64_t v38 = 0;
        int v27 = (*(uint64_t (**)(void, const void **, uint64_t))(**(void **)buf + 16))(*(void *)buf, &v38, a2);
        if (LOBYTE(v44[0])) {
          int v28 = v27;
        }
        else {
          int v28 = 0;
        }
        if (v28 == 1)
        {
          uint64_t v29 = sub_1000389F8(*(uint64_t **)(a1 + 1096), 11);
          int v30 = *(_DWORD *)sub_1000FA5F4((uint64_t *)v29[1], a2);
          sub_100057D78(&v38);
          if (v41) {
            sub_10004D2C8(v41);
          }
          if (v30 != 2)
          {
            int v31 = *v6;
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              uint64_t v32 = "#I not entitled for SA-Watch service";
LABEL_85:
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v32, buf, 2u);
              goto LABEL_86;
            }
            goto LABEL_86;
          }
        }
        else
        {
          sub_100057D78(&v38);
          if (v41) {
            sub_10004D2C8(v41);
          }
        }
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 128) + 640))(buf);
        long long v37 = 0;
        int v33 = (*(uint64_t (**)(void, const void **, uint64_t))(**(void **)buf + 16))(*(void *)buf, &v37, a2);
        if (LOBYTE(v44[0])) {
          int v34 = 0;
        }
        else {
          int v34 = v33;
        }
        if (v34 != 1)
        {
          sub_100057D78(&v37);
          if (v41) {
            sub_10004D2C8(v41);
          }
          goto LABEL_47;
        }
        std::string v35 = sub_1000389F8(*(uint64_t **)(a1 + 1096), 10);
        int v36 = *(_DWORD *)sub_1000FA5F4((uint64_t *)v35[1], a2);
        sub_100057D78(&v37);
        if (v41) {
          sub_10004D2C8(v41);
        }
        if (v36 == 2)
        {
LABEL_47:
          uint64_t v9 = 0;
          goto LABEL_34;
        }
        int v31 = *v6;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v32 = "#I not entitled for Multi-SIM service";
          goto LABEL_85;
        }
LABEL_86:
        uint64_t v9 = 27;
        goto LABEL_34;
      }
      uint64_t v26 = *v6;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I cellular data is turned off", buf, 2u);
      }
      uint64_t v9 = 29;
    }
    else
    {
      uint64_t v17 = *v6;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I sku mismatch", buf, 2u);
      }
      uint64_t v9 = 21;
    }
  }
  else
  {
    uint64_t v14 = *v6;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      sCardSerialNumberAsString();
      int v15 = v42 >= 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)uint64_t v39 = 136315138;
      *(void *)&v39[4] = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I csn (%s) not found, skip", v39, 0xCu);
      if (v42 < 0) {
        operator delete(*(void **)buf);
      }
    }
    uint64_t v9 = 16;
  }
LABEL_34:
  (*(void (**)(uint64_t, void, void, uint64_t))(a3 + 16))(a3, v51, *((void *)&v51 + 1), v9);
  sub_1003DD210(v43);
  sub_100D156EC((uint64_t)&v48 + 8);
  return sub_100D1541C((uint64_t)v44 + 8);
}