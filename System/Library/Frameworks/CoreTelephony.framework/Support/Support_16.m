void sub_1008DB948(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  v3 = *a2;
  v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  v4 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v3;
  *(void *)(a1 + 104) = v2;
  if (v4) {
    sub_10004D2C8(v4);
  }
}

uint64_t sub_1008DB974@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 104);
  *a2 = *(void *)(result + 96);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1008DB990@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 88);
  *a2 = *(void *)(result + 80);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_1008DB9AC(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    v6 = result;
    result = sub_1008DBA28(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1008DBA0C(_Unwind_Exception *exception_object)
{
  v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1008DBA28(void *a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556) {
    sub_10006A748();
  }
  result = (char *)sub_1008DBA7C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[12 * v4];
  return result;
}

void *sub_1008DBA7C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556) {
    sub_10006A7CC();
  }
  return operator new(12 * a2);
}

BOOL sub_1008DBAC4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 != *a2
    || a1[24] != a2[24]
    || *((_DWORD *)a1 + 7) != *((_DWORD *)a2 + 7)
    || a1[32] != a2[32]
    || *((_DWORD *)a1 + 9) != *((_DWORD *)a2 + 9)
    || a1[40] != a2[40]
    || a1[41] != a2[41]
    || strcmp(*((const char **)a1 + 1), *((const char **)a2 + 1))
    || strcmp(*((const char **)a1 + 2), *((const char **)a2 + 2)))
  {
    return 0;
  }
  BOOL result = sub_10001D294(a1 + 48, a2 + 48);
  if (result) {
    return a1[72] == a2[72];
  }
  return result;
}

void sub_1008DBBA0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1008DBC6C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[7], v1, (dispatch_function_t)sub_1008DBD44);
  __cxa_rethrow();
}

void sub_1008DBC94(_Unwind_Exception *a1)
{
}

void sub_1008DBCAC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1008DBCE4(uint64_t a1)
{
}

uint64_t sub_1008DBD00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1008DBD44(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1008DBD70(uint64_t a1, void *a2)
{
  uint64_t result = sub_1008DBDE8(a1, a2);
  char v4 = 0;
  uint64_t v5 = 0;
  do
  {
    char v6 = v4;
    long long v7 = *(_OWORD *)&a2[2 * v5 + 3];
    *(_OWORD *)(result + 24 + 16 * v5) = v7;
    if (*((void *)&v7 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v7 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    char v4 = 1;
    uint64_t v5 = 1;
  }
  while ((v6 & 1) == 0);
  uint64_t v8 = a2[8];
  *(void *)(result + 56) = a2[7];
  *(void *)(result + 64) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1008DBDE8(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  v3 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  char v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    while (1)
    {
      unint64_t v7 = v5[4];
      uint64_t v6 = v5[5];
      uint64_t v8 = *(void *)(a1 + 8);
      v9 = v3;
      if (*(void **)a1 != v3)
      {
        v10 = *(void **)(a1 + 8);
        v11 = v3;
        if (v8)
        {
          do
          {
            v9 = v10;
            v10 = (void *)v10[1];
          }
          while (v10);
        }
        else
        {
          do
          {
            v9 = (void *)v11[2];
            BOOL v12 = *v9 == (void)v11;
            v11 = v9;
          }
          while (v12);
        }
        if (v9[4] >= v7) {
          break;
        }
      }
      if (v8) {
        v13 = (uint64_t **)v9;
      }
      else {
        v13 = (uint64_t **)v3;
      }
      if (v8) {
        v14 = (uint64_t **)(v9 + 1);
      }
      else {
        v14 = (uint64_t **)v3;
      }
      if (!*v14) {
        goto LABEL_24;
      }
LABEL_27:
      v18 = (void *)v5[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (void *)v5[2];
          BOOL v12 = *v19 == (void)v5;
          uint64_t v5 = v19;
        }
        while (!v12);
      }
      uint64_t v5 = v19;
      if (v19 == v4) {
        return a1;
      }
    }
    v14 = (uint64_t **)v3;
    v13 = (uint64_t **)v3;
    if (v8)
    {
      v15 = *(uint64_t **)(a1 + 8);
      while (1)
      {
        while (1)
        {
          v13 = (uint64_t **)v15;
          unint64_t v16 = v15[4];
          if (v16 <= v7) {
            break;
          }
          v15 = *v13;
          v14 = v13;
          if (!*v13) {
            goto LABEL_24;
          }
        }
        if (v16 >= v7) {
          goto LABEL_27;
        }
        v15 = v13[1];
        if (!v15)
        {
          v14 = v13 + 1;
          break;
        }
      }
    }
LABEL_24:
    v17 = (uint64_t *)operator new(0x30uLL);
    v17[4] = v7;
    v17[5] = v6;
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    sub_100046C38((uint64_t **)a1, (uint64_t)v13, v14, v17);
    goto LABEL_27;
  }
  return a1;
}

void sub_1008DBF60(_Unwind_Exception *a1)
{
  sub_100103DF0(v1, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1008DBF78(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 72;
    sub_1007CECD8(i - 72);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1008DBFC8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1008DBFD8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1008DBFF4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_1008DC004(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *sub_1008DC09C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  v19 = a1;
  uint64_t v20 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 32);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void **)(v1 + 24);
      if (v5 && ((*(uint64_t (**)(void))(*v5 + 584))(*(void *)(v1 + 24)) & 1) != 0)
      {
        uint64_t v6 = v5[17];
        (*(void (**)(uint64_t *__return_ptr, void *))(*v5 + 576))(&v21, v5);
        char v7 = sub_1008C4968(*(void *)(v6 + 8), *(void *)(v6 + 16));
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v7)
        {
          uint64_t v8 = v5[17];
          (*(void (**)(uint64_t *__return_ptr, void *))(*v5 + 576))(&v21, v5);
          v9 = (void *)sub_1008C4A18(*(void *)(v8 + 8), *(void *)(v8 + 16));
          if (v22) {
            sub_10004D2C8(v22);
          }
          BOOL v12 = (void *)*v9;
          v10 = v9 + 1;
          v11 = v12;
          if (v12 != v10)
          {
            do
            {
              uint64_t v13 = v11[4];
              v14 = (std::__shared_weak_count *)v11[5];
              if (v14) {
                atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 464))(v13, v1);
              if (v14) {
                sub_10004D2C8(v14);
              }
              v15 = (void *)v11[1];
              if (v15)
              {
                do
                {
                  unint64_t v16 = v15;
                  v15 = (void *)*v15;
                }
                while (v15);
              }
              else
              {
                do
                {
                  unint64_t v16 = (void *)v11[2];
                  BOOL v17 = *v16 == (void)v11;
                  v11 = v16;
                }
                while (!v17);
              }
              v11 = v16;
            }
            while (v16 != v10);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
  sub_1008DC2D4(&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_1008DC280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v12);
  sub_1008DC2D4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1008DC2D4(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 32);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1008DC328(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v17 = a1;
  uint64_t v18 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 32);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void **)(v1 + 24);
      if (v5 && ((*(uint64_t (**)(void))(*v5 + 584))(*(void *)(v1 + 24)) & 1) != 0)
      {
        uint64_t v6 = v5[17];
        (*(void (**)(uint64_t *__return_ptr, void *))(*v5 + 576))(&v19, v5);
        char v7 = sub_1008C4968(*(void *)(v6 + 8), *(void *)(v6 + 16));
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v7)
        {
          uint64_t v8 = v5[17];
          (*(void (**)(uint64_t *__return_ptr, void *))(*v5 + 576))(&v19, v5);
          v9 = (void *)sub_1008C4A18(*(void *)(v8 + 8), *(void *)(v8 + 16));
          if (v20) {
            sub_10004D2C8(v20);
          }
          BOOL v12 = (void *)*v9;
          v10 = v9 + 1;
          v11 = v12;
          if (v12 != v10)
          {
            do
            {
              (*(void (**)(void, uint64_t))(*(void *)v11[4] + 472))(v11[4], v1);
              uint64_t v13 = (void *)v11[1];
              if (v13)
              {
                do
                {
                  v14 = v13;
                  uint64_t v13 = (void *)*v13;
                }
                while (v13);
              }
              else
              {
                do
                {
                  v14 = (void *)v11[2];
                  BOOL v15 = *v14 == (void)v11;
                  v11 = v14;
                }
                while (!v15);
              }
              v11 = v14;
            }
            while (v14 != v10);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
  sub_1008DC2D4(&v18);
  return sub_100046B58((uint64_t *)&v17);
}

void sub_1008DC4E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v12);
  sub_1008DC2D4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1008DC530(int a1)
{
  if ((a1 - 1) > 0x13) {
    uint64_t v1 = &kCTSIMToolkitPlayToneGeneralBeep;
  }
  else {
    uint64_t v1 = *(&off_101A17608 + a1 - 1);
  }
  return *(void *)v1;
}

uint64_t sub_1008DC55C(uint64_t a1, int a2, int a3)
{
  CFStringRef v3 = sub_100D3CA30(a2, a3);

  return _TMSetSourceAvailable(v3);
}

uint64_t sub_1008DC58C(uint64_t a1, int a2, int a3)
{
  CFStringRef v3 = sub_100D3CA30(a2, a3);

  return _TMSetSourceUnavailable(v3);
}

uint64_t sub_1008DC5BC(double a1, uint64_t a2, int a3)
{
  CFStringRef v4 = sub_100D3CAC8(a3);
  v5.n128_u64[0] = 0x4055400000000000;
  v6.n128_f64[0] = a1;

  return _TMSetSourceTime(v4, v6, v5);
}

uint64_t sub_1008DC600(double a1, uint64_t a2, int a3, int a4, uint64_t a5, MCC *a6)
{
  BOOL v10 = a3 == 2;
  CFStringRef v11 = sub_100D3CAC8(a4);
  if (a3 == 1) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = (2 * v10);
  }
  uint64_t v13 = *(unsigned int *)(a5 + 24);
  uint64_t v14 = *(unsigned int *)(a5 + 48);
  uint64_t IntValue = MCC::getIntValue(a6);
  v16.n128_f64[0] = a1;

  return _TMProvideCellularTimeZone(v11, v12, v13, v14, IntValue, v16);
}

void sub_1008DC6A0(CoreTimeInterface *a1)
{
  CoreTimeInterface::~CoreTimeInterface(a1);

  operator delete();
}

void sub_1008DC6D8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1008DC740(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008DC77C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1008DC7B4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1008DC7E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1008DC964(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1008DCAE8()
{
}

void sub_1008DCB40()
{
}

id **sub_1008DCB64(id **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    sub_1008DCE14(v2);
    operator delete();
  }
  return a1;
}

uint64_t *sub_1008DCBA8(uint64_t *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  id v5 = objc_alloc((Class)NSString);
  if (*((char *)a2 + 23) >= 0) {
    __n128 v6 = a2;
  }
  else {
    __n128 v6 = (uint64_t *)*a2;
  }
  id v7 = [v5 initWithUTF8String:v6];
  uint64_t v8 = (void *)*a1;
  *a1 = (uint64_t)v7;

  uint64_t v9 = objc_opt_new();
  BOOL v10 = (void *)a1[2];
  a1[2] = v9;

  id v11 = [objc_alloc((Class)NWNetworkAgentRegistration) initWithNetworkAgentClass:objc_opt_class()];
  uint64_t v12 = (void *)a1[1];
  a1[1] = (uint64_t)v11;

  if (([(id)a1[1] registerNetworkAgent:a1[2]] & 1) == 0)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    uint64_t v14 = (void *)*a1;
    int v19 = 138412290;
    uint64_t v20 = v14;
    BOOL v15 = "FAILED to register IPsec agent: %@";
LABEL_15:
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&v19, 0xCu);
    goto LABEL_16;
  }
  if (([(id)a1[1] addNetworkAgentToInterfaceNamed:*a1] & 1) == 0)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    __n128 v16 = (void *)*a1;
    int v19 = 138412290;
    uint64_t v20 = v16;
    BOOL v15 = "FAILED to add IPsec agent: %@";
    goto LABEL_15;
  }
  if (([(id)a1[1] updateNetworkAgent:a1[2]] & 1) == 0)
  {
    if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    BOOL v17 = (void *)*a1;
    int v19 = 138412290;
    uint64_t v20 = v17;
    BOOL v15 = "FAILED to update IPsec agent: %@";
    goto LABEL_15;
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = (void *)*a1;
    int v19 = 138412290;
    uint64_t v20 = v13;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "IPsec agent created successfully: %@", (uint8_t *)&v19, 0xCu);
  }
LABEL_16:
  return a1;
}

void sub_1008DCDE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *sub_1008DCE14(id *a1)
{
  id v3 = a1[1];
  if (v3)
  {
    if (a1[2]
      && ([v3 removeNetworkAgentFromInterfaceNamed:*a1] & 1) == 0
      && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      id v9 = *a1;
      int v11 = 138412290;
      id v12 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "FAILED to remove IPsec agent: %@", (uint8_t *)&v11, 0xCu);
    }
    if ([a1[1] isRegistered]
      && ([a1[1] unregisterNetworkAgent] & 1) == 0
      && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      id v10 = *a1;
      int v11 = 138412290;
      id v12 = v10;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "FAILED to un-register IPsec agent: %@", (uint8_t *)&v11, 0xCu);
    }
    id v4 = a1[1];
    a1[1] = 0;
  }
  id v5 = a1[2];
  a1[2] = 0;

  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = *a1;
    int v11 = 138412290;
    id v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "IPsec agent removed successfully: %@", (uint8_t *)&v11, 0xCu);
  }
  id v7 = *a1;
  *a1 = 0;

  return a1;
}

void sub_1008DCFE4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1008DCFF0(uint64_t *a1, unsigned int *a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = *((void *)a2 + 2) - *((void *)a2 + 1);
  if (v3) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  else {
    uint64_t v4 = 0;
  }
  return (*(uint64_t (**)(uint64_t, void, unint64_t, uint64_t))(*(void *)v2 + 16))(v2, *a2, v3 >> 2, v4);
}

uint64_t sub_1008DD030(uint64_t a1)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "lazuli.text/plain");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, &v3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  *(_DWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 56) = a1 + 64;
  return a1;
}

void sub_1008DD0C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1008DD0E8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)uint64_t v18 = 0u;
  long long v19 = 0u;
  memset(v17, 0, sizeof(v17));
  long long v16 = 0u;
  sub_10004BD84((uint64_t)&v16);
  sub_1000BE8E8((uint64_t)&v16, "Content-Type", off_101A8C258);
  sub_1000BE8E8((uint64_t)&v16, "Content-Disposition", &off_101A17778);
  uint64_t v4 = (std::string *)(a1 + 8);
  memset(&v15, 0, sizeof(v15));
  if (*(unsigned char *)(a1 + 48))
  {
    if (*(char *)(a1 + 31) < 0)
    {
      uint64_t v4 = *(std::string **)(a1 + 8);
      size_t v5 = *(void *)(a1 + 16);
    }
    else
    {
      size_t v5 = *(unsigned __int8 *)(a1 + 31);
    }
    __p = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    sub_10012C7D0((char *)&__p, (char *)v4, (char *)v4 + v5, v5);
    ctu::base64::encode();
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v15.__r_.__value_.__l.__data_);
    }
    std::string v15 = v11;
    sub_1000BE8E8((uint64_t)&v16, "Content-Transfer-Encoding", off_101A8C250);
    if (__p)
    {
      uint64_t v13 = __p;
      operator delete(__p);
    }
  }
  else
  {
    std::string::operator=(&v15, v4);
  }
  std::string::size_type size = HIBYTE(v15.__r_.__value_.__r.__words[2]);
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v15.__r_.__value_.__l.__size_;
  }
  __p = (void *)size;
  sub_1008DD444((uint64_t)&v16, "Content-Length", &__p);
  sub_10004B96C(v17, (uint64_t)"\r\n", 2);
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    id v7 = &v15;
  }
  else {
    id v7 = (std::string *)v15.__r_.__value_.__r.__words[0];
  }
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v8 = HIBYTE(v15.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v8 = v15.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v17, (uint64_t)v7, v8);
  sub_10004BC98((uint64_t)v17 + 8, &__p);
  sub_100CC8650(a2, (uint64_t)&__p);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  *(void *)((char *)&v17[-1]
  *(void *)&v17[0] = v9;
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1008DD3DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25)
{
  if (__p) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  sub_10008248C((uint64_t)&a25);
  _Unwind_Resume(a1);
}

void sub_1008DD444(uint64_t a1, char *__s, void *a3)
{
  size_t v5 = (void *)(a1 + 16);
  size_t v6 = strlen(__s);
  id v7 = sub_10004B96C(v5, (uint64_t)__s, v6);
  std::string::size_type v8 = sub_10004B96C(v7, (uint64_t)": ", 2);
  memset(&__p, 0, sizeof(__p));
  long long v17 = 0u;
  memset(v16, 0, sizeof(v16));
  uint64_t v18 = (char *)v16 + 2;
  long long v19 = (char *)&v17 + 10;
  v13[0] = *a3;
  v13[1] = (char *)&v17 + 10;
  char v14 = 48;
  int v15 = 48;
  uint64_t v18 = (std::string::value_type *)sub_100464B1C((uint64_t)v13);
  long long v19 = (char *)&v17 + 10;
  sub_10006E5EC(&__p, v18, (std::string::value_type *)&v17 + 10, (char *)&v17 + 10 - v18);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  std::string v11 = sub_10004B96C(v8, (uint64_t)p_p, size);
  sub_10004B96C(v11, (uint64_t)"\r\n", 2);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1008DD570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1008DD590@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, char **a3@<X8>)
{
  size_t v5 = (char *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  size_t v6 = (char *)operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = sub_1008DD604(v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1008DD5EC(_Unwind_Exception *a1)
{
  sub_10010E764(v1, 0);
  _Unwind_Resume(a1);
}

char *sub_1008DD604(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  size_t v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)size_t v5 = v6;
  }
  return __dst;
}

void sub_1008DD680(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1008DD69C@<X0>(uint64_t a1@<X0>, const void **a2@<X8>)
{
  uint64_t v3 = (const void **)(a1 + 32);
  if (*(void *)(a1 + 32)) {
    long long v4 = sub_1000C06D0;
  }
  else {
    long long v4 = 0;
  }
  if (!v4)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    long long v6 = *v3;
    std::__shared_weak_count *v3 = Mutable;
    std::string::size_type v8 = v6;
    sub_10005717C(&v8);
  }
  return sub_100057240(a2, v3);
}

void sub_1008DD72C(NSObject ***a1, const void *a2, const void *a3)
{
  if (a3)
  {
    sub_1008DD69C((uint64_t)a1, (const void **)theDict);
    CFDictionarySetValue(theDict[0], a2, a3);
    sub_10005717C((const void **)theDict);
  }
  else
  {
    size_t v5 = **a1;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      HIDWORD(theDict[1]) = 0;
      uint64_t v9 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v7 = 0;
      LODWORD(theDict[0]) = 136315138;
      *(CFMutableDictionaryRef *)((char *)theDict + 4) = (CFMutableDictionaryRef)__p;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Cannot add a NULL object to the CF dictionary for key: %s", (uint8_t *)theDict, 0xCu);
      if (SHIBYTE(v7) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_1008DD844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008DD878(NSObject ***a1, const void *a2, const void **a3)
{
  if (*a3) {
    long long v4 = sub_100080934;
  }
  else {
    long long v4 = 0;
  }
  if (v4)
  {
    sub_1008DD69C((uint64_t)a1, (const void **)theDict);
    CFDictionarySetValue(theDict[0], a2, *a3);
    sub_10005717C((const void **)theDict);
  }
  else
  {
    long long v6 = **a1;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      HIDWORD(theDict[1]) = 0;
      uint64_t v10 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v8 = 0;
      LODWORD(theDict[0]) = 136315138;
      *(CFMutableDictionaryRef *)((char *)theDict + 4) = (CFMutableDictionaryRef)__p;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot add a invalid object to the CF dictionary for key: %s", (uint8_t *)theDict, 0xCu);
      if (SHIBYTE(v8) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_1008DD9AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1008DD9E0(uint64_t a1, const void *a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a3;
    uint64_t v8 = *(void *)(a3 + 16);
  }
  if (SHIBYTE(v8) < 0)
  {
    sub_10004FC84(__p, v7[0], (unint64_t)v7[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v7;
    uint64_t v12 = v8;
  }
  uint64_t v10 = 0;
  if (SHIBYTE(v12) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v14 = v12;
  }
  int v15 = 0;
  if (ctu::cf::convert_copy())
  {
    size_t v5 = v10;
    uint64_t v10 = v15;
    long long v16 = v5;
    sub_1000558F4(&v16);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__dst);
  }
  value = v10;
  uint64_t v10 = 0;
  sub_1000558F4((const void **)&v10);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[0]);
  }
  sub_1008DD69C(a1, (const void **)&__dst);
  CFDictionarySetValue((CFMutableDictionaryRef)__dst, a2, value);
  sub_10005717C((const void **)&__dst);
  return sub_1000558F4((const void **)&value);
}

void sub_1008DDB34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

const void **sub_1008DDBA8(uint64_t a1, const void *a2, int a3)
{
  CFNumberRef v9 = 0;
  LODWORD(valuePtr) = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v5)
  {
    long long v6 = v9;
    CFNumberRef v9 = v5;
    valuePtr = v6;
    sub_1000570E8((const void **)&valuePtr);
  }
  value = v9;
  CFNumberRef v9 = 0;
  sub_1000570E8((const void **)&v9);
  sub_1008DD69C(a1, (const void **)&valuePtr);
  CFDictionarySetValue(valuePtr, a2, value);
  sub_10005717C((const void **)&valuePtr);
  return sub_1000570E8((const void **)&value);
}

void sub_1008DDC44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  sub_10005717C((const void **)va1);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1008DDC74(uint64_t a1, const void *a2)
{
  int v3 = *(_DWORD *)(a1 + 8);
  if (v3)
  {
    long long v4 = *(ctu **)(a1 + 32);
    if (v4) {
      uint64_t v5 = sub_1000C06D0;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5)
    {
      ctu::cf_to_xpc((uint64_t *)&object, v4, a2);
      xpc_object_t v6 = object;
      if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
        xpc_retain(v6);
      }
      else {
        xpc_object_t v6 = xpc_null_create();
      }
      xpc_release(object);
      int v9 = *(_DWORD *)(a1 + 8);
      xpc_object_t object = v6;
      if (v6)
      {
        xpc_retain(v6);
        xpc_object_t v10 = v6;
      }
      else
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t object = v10;
      }
      xpc_object_t v11 = xpc_null_create();
      xpc_object_t v14 = v11;
      sub_1000452AC(v9, &object, &v14);
      xpc_release(v11);
      xpc_release(v10);
      xpc_release(v6);
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t object = v7;
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v14 = v8;
      sub_1000452AC(v3, &object, &v14);
      xpc_release(v8);
      xpc_release(v7);
    }
  }
  uint64_t v12 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  xpc_object_t object = v12;
  uint64_t result = sub_10005717C((const void **)&object);
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

void sub_1008DDDD0(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void *sub_1008DDE44(void *a1, void *a2)
{
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_101A17790;
  a1[1] = 0;
  uint64_t v3 = a2[1];
  a1[4] = *a2;
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  ctu::RestModule::RestModule((ctu::RestModule *)(a1 + 6));
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  return a1;
}

void sub_1008DDEB0(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)*((void *)v1 + 5);
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = (std::__shared_weak_count *)*((void *)v1 + 3);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  BasebandModeEvaluator::~BasebandModeEvaluator(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1008DDEDC()
{
  return 3;
}

void sub_1008DDEE4(uint64_t a1, os_log_t *a2)
{
  uint64_t v2 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Evaluator: fixed always on", v3, 2u);
  }
}

void sub_1008DDF44(uint64_t a1, NSObject **a2)
{
  if (*(void *)(a1 + 8))
  {
    sub_100058DB0(&__p, "BasebandModeEvaluatorAlwaysOn");
    long long v4 = *a2;
    dispatch_object_t v15 = v4;
    if (v4) {
      dispatch_retain(v4);
    }
    dispatch_object_t object = 0;
    ctu::RestModule::RestModule();
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 56);
    *(_OWORD *)(a1 + 48) = v20;
    long long v20 = 0uLL;
    if (v5)
    {
      sub_10004D2C8(v5);
      if (*((void *)&v20 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
      }
    }
    if (object) {
      dispatch_release(object);
    }
    if (v15) {
      dispatch_release(v15);
    }
    if (v17 < 0) {
      operator delete(__p);
    }
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v6 = *(void *)(a1 + 24);
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
    }
    sub_1008DE33C((uint64_t)v18);
    xpc_object_t v8 = operator new(0x28uLL);
    *xpc_object_t v8 = off_101A17828;
    v8[1] = a1 + 64;
    v8[2] = a1;
    v8[3] = v7;
    v8[4] = v6;
    long long v22 = v8;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v20);
    if (v19 < 0) {
      operator delete(v18[0]);
    }
    int v9 = *(std::__shared_weak_count **)(a1 + 80);
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    if (v9) {
      sub_10004D2C8(v9);
    }
    sub_100058DB0(&v20, "/cc/assertions/baseband_booted");
    ctu::rest::AssertionHandle::create();
    if (v21 < 0) {
      operator delete((void *)v20);
    }
    long long v10 = *(_OWORD *)v18;
    v18[0] = 0;
    v18[1] = 0;
    xpc_object_t v11 = *(std::__shared_weak_count **)(a1 + 80);
    *(_OWORD *)(a1 + 72) = v10;
    if (v11)
    {
      sub_10004D2C8(v11);
      if (v18[1]) {
        sub_10004D2C8((std::__shared_weak_count *)v18[1]);
      }
    }
    Registry::createRestModuleOneTimeUseConnection(&v12, *(Registry **)(a1 + 32));
    ctu::RestModule::connect();
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
}

void sub_1008DE138(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object, dispatch_object_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1008DE1E0@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(8uLL);
  *a1 = v2;
  *uint64_t v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

uint64_t sub_1008DE220(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 48));
}

void sub_1008DE228(BasebandModeEvaluator *this)
{
  *(void *)this = off_101A17790;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  BasebandModeEvaluator::~BasebandModeEvaluator(this);
}

void sub_1008DE2A8(BasebandModeEvaluator *this)
{
  *(void *)this = off_101A17790;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  BasebandModeEvaluator::~BasebandModeEvaluator(this);

  operator delete();
}

void sub_1008DE33C(uint64_t a1@<X8>)
{
  sub_100058DB0(__p, "/cc/assertions/baseband_booted");
  *(_OWORD *)a1 = *(_OWORD *)__p;
  *(void *)(a1 + 16) = v3;
  __p[1] = 0;
  uint64_t v3 = 0;
  __p[0] = 0;
  ctu::path_join_impl();
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1008DE3AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1008DE3D8(void *a1)
{
  *a1 = off_101A17828;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1008DE424(void *a1)
{
  *a1 = off_101A17828;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1008DE490(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A17828;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1008DE4F4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A17828;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1008DE534(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1008DE544(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1008DE584(void *a1)
{
  ctu::rest::read_rest_value();
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2)
  {
    uint64_t v3 = a1[2];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[3]) {
        sub_1008DE664((unsigned int *)(v3 + 64));
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1008DE604(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1008DE618(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008DE658()
{
}

void sub_1008DE664(unsigned int *a1)
{
  if (a1[1] == 1)
  {
    sub_100058DB0(v3, "/cc/assertions/baseband_booted");
    *(_OWORD *)std::string __p = *(_OWORD *)v3;
    uint64_t v6 = v4;
    v3[1] = 0;
    uint64_t v4 = 0;
    v3[0] = 0;
    ctu::path_join_impl();
    xpc_object_t object = xpc_int64_create(*a1);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    ctu::RestModule::setProperty();
    xpc_release(object);
    if (SHIBYTE(v6) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v4) < 0) {
      operator delete(v3[0]);
    }
  }
}

void sub_1008DE730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1008DE778(uint64_t a1)
{
  *(void *)a1 = off_101A178A8;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_1008DE7F4(uint64_t a1)
{
  sub_1008DE778(a1);

  operator delete();
}

void sub_1008DE82C()
{
}

void sub_1008DE914(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8))(a9);
  }
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  operator delete();
}

uint64_t sub_1008DE998(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 16);

  return v2();
}

uint64_t sub_1008DEA2C(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 24);

  return v2();
}

uint64_t sub_1008DEAA8(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 32);

  return v2();
}

uint64_t sub_1008DEB24(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 40);

  return v2();
}

uint64_t sub_1008DEBA8(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 48);

  return v2();
}

const void **sub_1008DEC44@<X0>(uint64_t a1@<X0>, const void **a2@<X8>)
{
  *a2 = 0;
  uint64_t result = (const void **)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8));
  if (*a2) {
    uint64_t v5 = sub_1000810B8;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5)
  {
    (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 24) + 56))(&v7);
    if (&v7 != a2)
    {
      uint64_t v6 = *a2;
      *a2 = v7;
      uint64_t v7 = 0;
      xpc_object_t v8 = v6;
      sub_1000558F4(&v8);
    }
    return sub_1000558F4(&v7);
  }
  return result;
}

void sub_1008DED14(_Unwind_Exception *a1)
{
  sub_1000558F4(v1);
  _Unwind_Resume(a1);
}

void sub_1008DED28(void *a1, uint64_t a2, void *aBlock)
{
  if (aBlock) {
    uint64_t v5 = _Block_copy(aBlock);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v7 = a1[1];
  uint64_t v6 = (std::__shared_weak_count *)a1[2];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = a1[3];
  int v9 = (std::__shared_weak_count *)a1[4];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = a1[1];
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 1174405120;
  v17[2] = sub_1008DF54C;
  v17[3] = &unk_101A17920;
  _OWORD v17[4] = a1;
  v17[5] = v8;
  uint64_t v18 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5) {
    xpc_object_t v11 = _Block_copy(v5);
  }
  else {
    xpc_object_t v11 = 0;
  }
  char v19 = v11;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v10 + 64))(v10, a2, v17);
  uint64_t v12 = a1[3];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  v14[2] = sub_1008DFDA8;
  v14[3] = &unk_101A17950;
  v14[4] = a1;
  v14[5] = v7;
  uint64_t v15 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5) {
    uint64_t v13 = _Block_copy(v5);
  }
  else {
    uint64_t v13 = 0;
  }
  aBlocka = v13;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v12 + 64))(v12, a2, v14);
  if (aBlocka) {
    _Block_release(aBlocka);
  }
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  if (v19) {
    _Block_release(v19);
  }
  if (v18) {
    std::__shared_weak_count::__release_weak(v18);
  }
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  if (v5) {
    _Block_release(v5);
  }
}

void sub_1008DEF68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *aBlock, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,void *a24)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (a24) {
    _Block_release(a24);
  }
  if (a23)
  {
    std::__shared_weak_count::__release_weak(a23);
    if (!v26)
    {
LABEL_9:
      if (!v25) {
        goto LABEL_10;
      }
      goto LABEL_14;
    }
  }
  else if (!v26)
  {
    goto LABEL_9;
  }
  std::__shared_weak_count::__release_weak(v26);
  if (!v25)
  {
LABEL_10:
    if (!v24) {
LABEL_16:
    }
      _Unwind_Resume(exception_object);
LABEL_15:
    _Block_release(v24);
    goto LABEL_16;
  }
LABEL_14:
  std::__shared_weak_count::__release_weak(v25);
  if (!v24) {
    goto LABEL_16;
  }
  goto LABEL_15;
}

uint64_t sub_1008DEFFC(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 72);

  return v2();
}

uint64_t sub_1008DF078(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 80);

  return v2();
}

uint64_t sub_1008DF0F4(uint64_t a1)
{
  uint64_t result = a1 + 48;
  if (*(char *)(a1 + 71) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t sub_1008DF110(uint64_t a1, uint64_t *a2, uint64_t *a3, const void *a4)
{
  *(void *)a1 = off_101A178A8;
  uint64_t v7 = (uint64_t *)(a1 + 24);
  uint64_t v8 = a1 + 8;
  sub_1008DF41C((uint64_t *)(a1 + 8), a2);
  sub_1008DF41C(v7, a3);
  if (a4) {
    int v9 = _Block_copy(a4);
  }
  else {
    int v9 = 0;
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = v9;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  sub_100058DB0(&v25, "Dual(");
  uint64_t v10 = (const char *)(*(uint64_t (**)(void))(**(void **)v8 + 88))();
  size_t v11 = strlen(v10);
  uint64_t v12 = std::string::append(&v25, v10, v11);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  xpc_object_t v14 = std::string::append(&v26, "+", 1uLL);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v27.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  long long v16 = (const char *)(*(uint64_t (**)(void))(*(void *)*v7 + 88))();
  size_t v17 = strlen(v16);
  uint64_t v18 = std::string::append(&v27, v16, v17);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v28.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  long long v20 = std::string::append(&v28, ")", 1uLL);
  std::string::size_type v21 = v20->__r_.__value_.__r.__words[0];
  v29[0] = v20->__r_.__value_.__l.__size_;
  *(void *)((char *)v29 + 7) = *(std::string::size_type *)((char *)&v20->__r_.__value_.__r.__words[1] + 7);
  char v22 = HIBYTE(v20->__r_.__value_.__r.__words[2]);
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v23 = v29[0];
  *(void *)(a1 + 48) = v21;
  *(void *)(a1 + 56) = v23;
  *(void *)(a1 + 63) = *(void *)((char *)v29 + 7);
  *(unsigned char *)(a1 + 71) = v22;
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_1008DF35C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t *sub_1008DF41C(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  char *result = *a2;
  if (v2) {
    operator new();
  }
  result[1] = 0;
  *a2 = 0;
  return result;
}

void sub_1008DF4A0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1008DF4D8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1008DF508(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void sub_1008DF54C(void *a1, const __CFDictionary *a2, const __CFArray *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v7 = a1[4];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      int v9 = v8;
      uint64_t v10 = a1[5];
      if (v10)
      {
        os_log_t oslog = 0;
        ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, kCtLoggingSystemName, "ps.kvs");
        size_t v11 = oslog;
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(v7 + 8) + 88))(*(void *)(v7 + 8));
          *(_DWORD *)buf = 136315138;
          uint64_t v15 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Received update on transport %s", buf, 0xCu);
        }
        sub_1008DF6DC(v10, a2, a3, *(void *)(v7 + 40));
        (*(void (**)(void))(a1[7] + 16))();
        ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1008DF6B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_1008DF6DC(uint64_t a1, CFDictionaryRef theDict, CFArrayRef theArray, uint64_t a4)
{
  std::string __p = 0;
  v65 = 0;
  unint64_t v66 = 0;
  values = 0;
  v62 = 0;
  unint64_t v63 = 0;
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
        size_t v11 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v12 = CFGetTypeID(ValueAtIndex);
          if (v12 == CFStringGetTypeID())
          {
            if (theDict) {
              Value = (void *)CFDictionaryGetValue(theDict, v11);
            }
            else {
              Value = 0;
            }
            xpc_object_t v14 = v65;
            if ((unint64_t)v65 >= v66)
            {
              int64_t v16 = (v65 - (unsigned char *)__p) >> 3;
              if ((unint64_t)(v16 + 1) >> 61) {
                sub_10006A748();
              }
              unint64_t v17 = (uint64_t)(v66 - (void)__p) >> 2;
              if (v17 <= v16 + 1) {
                unint64_t v17 = v16 + 1;
              }
              if (v66 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v18 = v17;
              }
              if (v18) {
                long long v19 = (char *)sub_10004EF74((uint64_t)&v66, v18);
              }
              else {
                long long v19 = 0;
              }
              long long v20 = &v19[8 * v16];
              *(void *)long long v20 = v11;
              uint64_t v15 = v20 + 8;
              char v22 = (char *)__p;
              std::string::size_type v21 = v65;
              if (v65 != __p)
              {
                do
                {
                  uint64_t v23 = *((void *)v21 - 1);
                  v21 -= 8;
                  *((void *)v20 - 1) = v23;
                  v20 -= 8;
                }
                while (v21 != v22);
                std::string::size_type v21 = (char *)__p;
              }
              std::string __p = v20;
              v65 = v15;
              unint64_t v66 = (unint64_t)&v19[8 * v18];
              if (v21) {
                operator delete(v21);
              }
            }
            else
            {
              *(void *)v65 = v11;
              uint64_t v15 = v14 + 8;
            }
            v65 = v15;
            long long v24 = v62;
            if ((unint64_t)v62 >= v63)
            {
              int64_t v26 = v62 - values;
              if ((unint64_t)(v26 + 1) >> 61) {
                sub_10006A748();
              }
              unint64_t v27 = (uint64_t)(v63 - (void)values) >> 2;
              if (v27 <= v26 + 1) {
                unint64_t v27 = v26 + 1;
              }
              if (v63 - (unint64_t)values >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v28 = v27;
              }
              if (v28) {
                long long v29 = (char *)sub_10004EF74((uint64_t)&v63, v28);
              }
              else {
                long long v29 = 0;
              }
              uint64_t v30 = (void **)&v29[8 * v26];
              *uint64_t v30 = Value;
              std::string v25 = v30 + 1;
              v32 = values;
              v31 = v62;
              if (v62 != values)
              {
                do
                {
                  v33 = *--v31;
                  *--uint64_t v30 = v33;
                }
                while (v31 != v32);
                v31 = values;
              }
              values = v30;
              v62 = v25;
              unint64_t v63 = (unint64_t)&v29[8 * v28];
              if (v31) {
                operator delete(v31);
              }
            }
            else
            {
              *v62 = Value;
              std::string v25 = v24 + 1;
            }
            v62 = v25;
          }
        }
      }
    }
    goto LABEL_72;
  }
  if (theDict)
  {
    unint64_t v34 = CFDictionaryGetCount(theDict);
    unint64_t v35 = v34;
    unint64_t v36 = (v65 - (unsigned char *)__p) >> 3;
    if (v34 <= v36)
    {
      if (v34 >= v36) {
        goto LABEL_58;
      }
      v44 = (char *)__p + 8 * v34;
    }
    else
    {
      unint64_t v37 = v34 - v36;
      if (v34 - v36 > (uint64_t)(v66 - (void)v65) >> 3)
      {
        if (v34 >> 61) {
          sub_10006A748();
        }
        unint64_t v38 = (uint64_t)(v66 - (void)__p) >> 2;
        if (v38 <= v34) {
          unint64_t v38 = v34;
        }
        if (v66 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v39 = v38;
        }
        v40 = (char *)sub_10004EF74((uint64_t)&v66, v39);
        v41 = &v40[8 * v36];
        v43 = &v40[8 * v42];
        bzero(v41, 8 * v37);
        std::string __p = v41;
        v65 = &v41[8 * v37];
        unint64_t v66 = (unint64_t)v43;
LABEL_58:
        unint64_t v45 = v62 - values;
        if (v35 <= v45)
        {
          if (v35 >= v45)
          {
LABEL_71:
            CFDictionaryGetKeysAndValues(theDict, (const void **)__p, (const void **)values);
            goto LABEL_72;
          }
          v53 = &values[v35];
        }
        else
        {
          unint64_t v46 = v35 - v45;
          if (v35 - v45 > (uint64_t)(v63 - (void)v62) >> 3)
          {
            if (v35 >> 61) {
              sub_10006A748();
            }
            unint64_t v47 = (uint64_t)(v63 - (void)values) >> 2;
            if (v47 <= v35) {
              unint64_t v47 = v35;
            }
            if (v63 - (unint64_t)values >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v48 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v48 = v47;
            }
            v49 = (char *)sub_10004EF74((uint64_t)&v63, v48);
            v50 = &v49[8 * v45];
            v52 = &v49[8 * v51];
            bzero(v50, 8 * v46);
            values = (void **)v50;
            v62 = (void **)&v50[8 * v46];
            unint64_t v63 = (unint64_t)v52;
            goto LABEL_71;
          }
          bzero(v62, 8 * v46);
          v53 = &v62[v46];
        }
        v62 = v53;
        goto LABEL_71;
      }
      bzero(v65, 8 * v37);
      v44 = &v65[8 * v37];
    }
    v65 = v44;
    goto LABEL_58;
  }
LABEL_72:
  v54 = __p;
  if (v65 == __p)
  {
    int v56 = 0;
    goto LABEL_82;
  }
  unint64_t v55 = 0;
  int v56 = 0;
  do
  {
    v57 = values;
    if (a4)
    {
      if (!(*(unsigned int (**)(uint64_t, void, void *))(a4 + 16))(a4, v54[v55], values[v55])) {
        goto LABEL_78;
      }
      v54 = __p;
      v57 = values;
    }
    (*(void (**)(uint64_t, void, void *))(*(void *)a1 + 16))(a1, v54[v55], v57[v55]);
    ++v56;
LABEL_78:
    ++v55;
    v54 = __p;
  }
  while (v55 < (v65 - (unsigned char *)__p) >> 3);
  if (v56) {
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  }
LABEL_82:
  os_log_t oslog = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, kCtLoggingSystemName, "ps.kvs");
  v58 = oslog;
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v59 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
    *(_DWORD *)buf = 67109378;
    int v68 = v56;
    __int16 v69 = 2080;
    uint64_t v70 = v59;
    _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I Forwarded %d record(s) to %s", buf, 0x12u);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
  if (values)
  {
    v62 = values;
    operator delete(values);
  }
  if (__p)
  {
    v65 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1008DFCB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1008DFD08(void *a1, void *a2)
{
  uint64_t v3 = a2[6];
  a1[5] = a2[5];
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = (void *)a2[7];
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[7] = result;
  return result;
}

void sub_1008DFD54(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 56);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1008DFDA8(void *a1, const __CFDictionary *a2, const __CFArray *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v7 = a1[4];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      int v9 = v8;
      uint64_t v10 = a1[5];
      if (v10)
      {
        os_log_t oslog = 0;
        ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, kCtLoggingSystemName, "ps.kvs");
        size_t v11 = oslog;
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(v7 + 24) + 88))(*(void *)(v7 + 24));
          *(_DWORD *)buf = 136315138;
          uint64_t v15 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Received update on transport %s", buf, 0xCu);
        }
        sub_1008DF6DC(v10, a2, a3, *(void *)(v7 + 40));
        (*(void (**)(void))(a1[7] + 16))();
        ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1008DFF10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void *sub_1008DFF38(void *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_101A179F0;
  a1[1] = a2;
  (*(void (**)(uint64_t (****__return_ptr)(void)))(**(void **)(a2 + 56) + 24))(&v4);
  a1[4] = (**v4)(v4);
  if (v5) {
    sub_10004D2C8(v5);
  }
  return a1;
}

void sub_1008DFFE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_1008E0010(v10);
  _Unwind_Resume(a1);
}

void *sub_1008E0010(void *a1)
{
  *a1 = off_101A17BE8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  a1[2] = 0;
  a1[3] = 0;
  if (v2)
  {
    sub_10004D2C8(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[3];
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
  return a1;
}

void sub_1008E0070()
{
  long long v0 = 0uLL;
  operator new();
}

void sub_1008E00F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E0128()
{
  sub_1008E0288(&v0);
}

uint64_t sub_1008E01B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "tm.mgr.ssm");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_101A17A30;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = a3;
  *(void *)(a1 + 64) = 0;
  return a1;
}

void sub_1008E0264(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void sub_1008E0288(void *a1@<X8>)
{
  *a1 = 0;
  operator new();
}

void sub_1008E0314(_Unwind_Exception *a1)
{
  sub_1008E17A8(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1008E034C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))();
}

uint64_t sub_1008E0374(uint64_t a1, int a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64));
  if (result != a2)
  {
    if (!a2) {
      operator new();
    }
    if (a2 == 1) {
      sub_1008E0288(v7);
    }
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 48);
      *(_DWORD *)OsLogContext v7 = 136315650;
      *(void *)&v7[4] = v6;
      __int16 v8 = 2080;
      int v9 = " ";
      __int16 v10 = 2080;
      size_t v11 = "kOutOfService";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sServiceState changed to: %s", v7, 0x20u);
    }
    return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56));
  }
  return result;
}

void sub_1008E0594()
{
}

uint64_t sub_1008E05C0(uint64_t result, int a2, int a3, int a4)
{
  BOOL v5 = a3;
  BOOL v6 = a2;
  uint64_t v7 = result;
  if (*(unsigned __int8 *)(result + 36) != a2
    || *(unsigned __int8 *)(result + 37) != a3
    || *(unsigned __int8 *)(result + 38) != a4)
  {
    __int16 v8 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(v7 + 48);
      int v11 = 136316162;
      uint64_t v12 = v9;
      __int16 v13 = 2080;
      xpc_object_t v14 = " ";
      __int16 v15 = 2080;
      uint64_t v16 = asStringBool(v6);
      __int16 v17 = 2080;
      uint64_t v18 = asStringBool(v5);
      __int16 v19 = 2080;
      uint64_t v20 = asStringBool(a4);
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%shandleCurrentCallsInfoChanged: hasActiveCSCall = %s, hasActiveVoLTECall = %s, systemHasAnyActiveCsOrVoLTECall = %s", (uint8_t *)&v11, 0x34u);
    }
    *(unsigned char *)(v7 + 36) = v6;
    *(unsigned char *)(v7 + 37) = v5;
    *(unsigned char *)(v7 + 38) = a4;
    uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(v7 + 64) + 24))(*(void *)(v7 + 64), 0);
    int v10 = 0;
    if (!*(unsigned char *)(v7 + 36))
    {
      if (*(unsigned char *)(v7 + 37)) {
        int v10 = 0;
      }
      else {
        int v10 = a4;
      }
    }
    if (*(unsigned __int8 *)(v7 + 39) != v10)
    {
      *(unsigned char *)(v7 + 39) = v10;
      return (*(uint64_t (**)(void))(**(void **)(v7 + 64) + 32))(*(void *)(v7 + 64));
    }
  }
  return result;
}

uint64_t sub_1008E077C(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 40);
  if (v2 != a2)
  {
    BOOL v3 = a2;
    uint64_t v4 = result;
    BOOL v5 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(v4 + 48);
      int v7 = 136315906;
      uint64_t v8 = v6;
      __int16 v9 = 2080;
      int v10 = " ";
      __int16 v11 = 2080;
      uint64_t v12 = asStringBool(v2 != 0);
      __int16 v13 = 2080;
      uint64_t v14 = asStringBool(v3);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sDataAttached: %s => %s", (uint8_t *)&v7, 0x2Au);
    }
    *(unsigned char *)(v4 + 40) = v3;
    return (*(uint64_t (**)(void, void))(**(void **)(v4 + 64) + 24))(*(void *)(v4 + 64), 0);
  }
  return result;
}

uint64_t sub_1008E08A8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), 0);
}

uint64_t sub_1008E08D4(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 32) != a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(NSObject **)(result + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(v3 + 48);
      int v6 = 136315650;
      uint64_t v7 = v5;
      __int16 v8 = 2080;
      __int16 v9 = " ";
      __int16 v10 = 2080;
      uint64_t v11 = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%shandleRegistrationStatusChanged: registrationStatus = %s", (uint8_t *)&v6, 0x20u);
    }
    *(_DWORD *)(v3 + 32) = a2;
    return (*(uint64_t (**)(void, void))(**(void **)(v3 + 64) + 24))(*(void *)(v3 + 64), 0);
  }
  return result;
}

uint64_t sub_1008E09E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 40))();
}

uint64_t sub_1008E0A08(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64));
  if (result)
  {
    if ((*(uint64_t (**)(void))(**(void **)(a1 + 64) + 40))(*(void *)(a1 + 64)) <= 14999)
    {
      if (*(unsigned char *)(a1 + 38)) {
        return 1;
      }
      else {
        return 3;
      }
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t sub_1008E0AA0()
{
  return 0;
}

void sub_1008E0AA8(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  if (*(unsigned char *)(v3 + 36) || *(unsigned char *)(v3 + 37))
  {
LABEL_3:
    uint64_t v4 = (std::__shared_weak_count *)a1[3];
    a1[2] = 0;
    a1[3] = 0;
    if (v4)
    {
      sub_10004D2C8(v4);
    }
    return;
  }
  if (*(unsigned char *)(v3 + 38)) {
    goto LABEL_8;
  }
  if ((*(_DWORD *)(v3 + 32) & 0xFFFFFFFE) == 4)
  {
    if (!(*(unsigned int (**)(void))(**(void **)(v3 + 56) + 48))(*(void *)(v3 + 56))) {
      goto LABEL_3;
    }
    uint64_t v3 = a1[1];
    if (*(unsigned char *)(v3 + 40)) {
      goto LABEL_3;
    }
  }
  if (a2)
  {
LABEL_8:
    sub_1008E0374(v3, 1);
  }
  else
  {
    (*(void (**)(void))(**(void **)(v3 + 56) + 16))(*(void *)(v3 + 56));
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1[1] + 56) + 24))(&v6);
    sub_1008E0C1C((uint64_t)a1);
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
}

void sub_1008E0C04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E0C1C(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    sub_100058DB0(&__p, "ReEvaluationTimer");
    v7[0] = off_101A17C90;
    v7[1] = a1;
    v7[3] = v7;
    AutoStartTimer::create();
    long long v2 = v6;
    long long v6 = 0uLL;
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
    *(_OWORD *)(a1 + 16) = v2;
    if (v3)
    {
      sub_10004D2C8(v3);
      if (*((void *)&v6 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v6 + 1));
      }
    }
    sub_10003B34C(v7);
    if (v5 < 0) {
      operator delete(__p);
    }
  }
}

void sub_1008E0D18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1008E0D44()
{
  return 0;
}

void sub_1008E0D4C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v1 + 39))
  {
    (*(void (**)(void (****__return_ptr)(void)))(**(void **)(v1 + 56) + 24))(&v2);
    (**v2)();
    operator new();
  }

  sub_1008E0E74(a1);
}

void sub_1008E0E5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E0E74(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 72) && !*(void *)(a1 + 56))
  {
    sub_100058DB0(&__p, "TimerToDetermineIfLowChanceOfComingInService");
    (*(void (**)(void))(**(void **)(*(void *)(a1 + 8) + 56) + 16))(*(void *)(*(void *)(a1 + 8)
                                                                                                  + 56));
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(*(void *)(a1 + 8) + 56) + 24))(&v4);
    v9[0] = off_101A17D10;
    v9[1] = a1;
    v9[3] = v9;
    AutoStartTimer::create();
    long long v2 = v8;
    long long v8 = 0uLL;
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
    *(_OWORD *)(a1 + 56) = v2;
    if (v3)
    {
      sub_10004D2C8(v3);
      if (*((void *)&v8 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
      }
    }
    sub_10003B34C(v9);
    if (v5) {
      sub_10004D2C8(v5);
    }
    if (v7 < 0) {
      operator delete(__p);
    }
  }
}

void sub_1008E0FD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  sub_10003B34C((void *)(v17 - 56));
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1008E1018()
{
  return 1;
}

uint64_t sub_1008E1020(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (*(unsigned char *)(result + 36)
    || *(unsigned char *)(result + 37)
    || !*(unsigned char *)(result + 38)
    && (*(_DWORD *)(result + 32) & 0xFFFFFFFE) == 4
    && ((int v3 = (*(uint64_t (**)(void))(**(void **)(result + 56) + 48))(*(void *)(result + 56)),
         uint64_t result = *(void *)(a1 + 8),
         !v3)
     || *(unsigned char *)(result + 40)))
  {
    return sub_1008E0374(result, 0);
  }
  return result;
}

void sub_1008E10C8(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (a2)
  {
    if (!v3)
    {
      (*(void (**)(void (****__return_ptr)(void)))(**(void **)(*(void *)(a1 + 8) + 56) + 24))(&v5);
      (**v5)();
      operator new();
    }
    return;
  }
  if (!v3) {
    return;
  }
  (*(void (**)(void (****__return_ptr)(void)))(**(void **)(*(void *)(a1 + 8) + 56) + 24))(&v5);
  *(void *)(a1 + 48) += ((uint64_t (*)(void))**v5)() - **(void **)(a1 + 40);
  if (!v6)
  {
    *(void *)(a1 + 40) = 0;
LABEL_9:
    operator delete();
  }
  sub_10004D2C8(v6);
  uint64_t v4 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v4) {
    goto LABEL_9;
  }
  if (sub_1008E1304((void *)a1) > 14999)
  {
    if (!*(unsigned char *)(a1 + 72))
    {
      *(unsigned char *)(a1 + 72) = 1;
      (*(void (**)(void))(**(void **)(*(void *)(a1 + 8) + 56) + 40))(*(void *)(*(void *)(a1 + 8) + 56));
    }
  }
  else
  {
    sub_1008E0E74(a1);
  }
}

void sub_1008E12E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008E1304(void *a1)
{
  (*(void (**)(uint64_t (****__return_ptr)(void)))(**(void **)(a1[1] + 56) + 24))(&v6);
  uint64_t v2 = (**v6)();
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v3 = (void *)a1[5];
  if (v3) {
    uint64_t v3 = (void *)(*v3 - v2);
  }
  uint64_t v4 = (unsigned __int128)(((uint64_t)v3 + v2 - a1[4] - a1[6]) * (__int128)0x431BDE82D7B634DBLL) >> 64;
  return (v4 >> 18) + ((unint64_t)v4 >> 63);
}

void sub_1008E13E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1008E1400(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  a1[7] = 0;
  a1[8] = 0;
  if (v2)
  {
    sub_10004D2C8(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[8];
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
  uint64_t v4 = a1[5];
  a1[5] = 0;
  if (v4) {
    operator delete();
  }

  return sub_1008E0010(a1);
}

void sub_1008E1474(void *a1)
{
  sub_1008E1400(a1);

  operator delete();
}

void *sub_1008E14B4(void *a1)
{
  uint64_t v2 = a1[8];
  a1[8] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_1008E151C(void *a1)
{
  uint64_t v2 = a1[8];
  a1[8] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  operator delete();
}

void sub_1008E15A8(void *a1)
{
  sub_1008E0010(a1);

  operator delete();
}

void sub_1008E15E8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1008E1670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_1008E1718((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E1694(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1008E16CC(uint64_t a1)
{
}

uint64_t sub_1008E16D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1008E1718(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = a2[8];
    a2[8] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)a2[3];
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a2 + 1));
    operator delete();
  }
}

void *sub_1008E17A8(void **a1, void *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1008E1400(result);
    operator delete();
  }
  return result;
}

void sub_1008E17FC()
{
}

void *sub_1008E1810(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A17C90;
  result[1] = v3;
  return result;
}

uint64_t sub_1008E1858(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A17C90;
  a2[1] = v2;
  return result;
}

uint64_t sub_1008E1884(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v2 = (std::__shared_weak_count *)v1[3];
  v1[2] = 0;
  v1[3] = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v1 + 24);

  return v3(v1, 1);
}

uint64_t sub_1008E18EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008E192C()
{
}

void sub_1008E193C()
{
}

void *sub_1008E1950(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A17D10;
  result[1] = v3;
  return result;
}

uint64_t sub_1008E1998(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A17D10;
  a2[1] = v2;
  return result;
}

void sub_1008E19C4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 64);
  *(void *)(v1 + 56) = 0;
  *(void *)(v1 + 64) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (!*(unsigned char *)(v1 + 72))
  {
    *(unsigned char *)(v1 + 72) = 1;
    uint64_t v3 = *(void (**)(void))(**(void **)(*(void *)(v1 + 8) + 56) + 40);
    v3();
  }
}

uint64_t sub_1008E1A48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008E1A88()
{
}

void sub_1008E1A94(void ***a1)
{
  *a1 = (void **)off_101A17D90;
  sub_100110A40(a1 + 1, 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_1008E1AEC(void ***a1)
{
  *a1 = (void **)off_101A17D90;
  sub_100110A40(a1 + 1, 0);
  PB::Base::~Base((PB::Base *)a1);

  operator delete();
}

uint64_t sub_1008E1B58(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = off_101A17D90;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 20) = 0;
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(unsigned char *)(a2 + 20))
  {
    int v2 = *(_DWORD *)(a2 + 16);
    *(unsigned char *)(result + 20) |= 1u;
    *(_DWORD *)(result + 16) = v2;
  }
  return result;
}

uint64_t sub_1008E1C20(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  char v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  if (*(unsigned char *)(a1 + 20)) {
    PB::TextFormatter::format(this, "userConsent", *(_DWORD *)(a1 + 16));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1008E1C98(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 2)
      {
        *(unsigned char *)(a1 + 20) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 > 0xFFFFFFFFFFFFFFF5 || v22 + 10 > v23)
        {
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v27 = 0;
          if (v23 <= v22) {
            unint64_t v23 = *((void *)this + 1);
          }
          while (1)
          {
            if (v23 == v22)
            {
              LODWORD(v27) = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_43;
            }
            unint64_t v32 = v22 + 1;
            char v33 = *(unsigned char *)(v24 + v22);
            *((void *)this + 1) = v32;
            v27 |= (unint64_t)(v33 & 0x7F) << v30;
            if ((v33 & 0x80) == 0) {
              break;
            }
            v30 += 7;
            unint64_t v22 = v32;
            BOOL v14 = v31++ > 8;
            if (v14)
            {
LABEL_39:
              LODWORD(v27) = 0;
              goto LABEL_43;
            }
          }
          if (*((unsigned char *)this + 24)) {
            LODWORD(v27) = 0;
          }
        }
        else
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          while (1)
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              break;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
            if (v14) {
              goto LABEL_39;
            }
          }
        }
LABEL_43:
        *(_DWORD *)(a1 + 16) = v27;
      }
      else
      {
        if (v20 == 1) {
          operator new();
        }
LABEL_24:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_20;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_24;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_1008E1F2C(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  if (*(unsigned char *)(v3 + 20))
  {
    unsigned int v5 = *(_DWORD *)(v3 + 16);
    return PB::Writer::writeVarInt(this, v5, 2u);
  }
  return result;
}

void *sub_1008E1F94@<X0>(void *a1@<X8>)
{
  unint64_t v2 = operator new(0x30uLL);
  v2[1] = 0;
  v2[2] = 0;
  *unint64_t v2 = off_101A17E48;
  v2[3] = off_101A17DE0;
  uint64_t result = sub_1008E244C(v2 + 4);
  v2[3] = off_101A17E98;
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1008E2044(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1008E205C(uint64_t a1, NSObject **a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unsigned int v5 = *a2;
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  sub_1000DA470((uint64_t)v7, a3);
  TTYUtilityHelper::registerForTTYMethodChangedNotification(v4, &object, (uint64_t)v7);
  sub_10003B34C(v7);
  if (object) {
    dispatch_release(object);
  }
}

void sub_1008E20F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1008E2114(uint64_t a1, const void **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_10012A394(&v5, a2);
  uint64_t v3 = TTYUtilityHelper::currentPreferredTransportMethod(v2, (CFUUIDRef *)&v5);
  sub_10012577C(&v5);
  return v3;
}

void sub_1008E2160(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1008E2174@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 8);
  sub_10012A394(&v6, a2);
  TTYUtilityHelper::getTTYRelayPhoneNumber(v4, (CFUUIDRef *)&v6, a3);
  return sub_10012577C(&v6);
}

void sub_1008E21C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

__CFString *sub_1008E21D4(uint64_t a1)
{
  return TTYUtilityHelper::getIncomingCallTTYSwitchNotificationName(*(TTYUtilityHelper **)(a1 + 8));
}

id sub_1008E21DC(uint64_t a1, const void **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_10012A394(&v5, a2);
  id IncomingCallsAsTTYSwitchState = TTYUtilityHelper::getIncomingCallsAsTTYSwitchState(v2, (CFUUIDRef *)&v5);
  sub_10012577C(&v5);
  return IncomingCallsAsTTYSwitchState;
}

void sub_1008E2228(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_1008E2240(void *a1)
{
  *a1 = off_101A17DE0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1008E228C(void *a1)
{
  *a1 = off_101A17DE0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_1008E22F8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A17E48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1008E2318(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A17E48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1008E236C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_1008E2394(void *a1)
{
  *a1 = off_101A17DE0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1008E23E0(void *a1)
{
  *a1 = off_101A17DE0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_1008E244C@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t result = sub_1008E24A8(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1008E2494(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1008E24A8(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A17F00;
  TTYUtilityHelper::TTYUtilityHelper(a1 + 3);
  return a1;
}

void sub_1008E24F0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1008E2504(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A17F00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1008E2524(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A17F00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1008E2578(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1008E25A0(PB::Base *this)
{
  *(void *)this = &off_101A17F50;
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }

  PB::Base::~Base(this);
}

void sub_1008E2654(PB::Base *a1)
{
  sub_1008E25A0(a1);

  operator delete();
}

uint64_t sub_1008E268C(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = &off_101A17F50;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(void *)(result + 16) = 0;
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(unsigned char *)(a2 + 32))
  {
    uint64_t v2 = *(void *)(a2 + 24);
    *(unsigned char *)(result + 32) |= 1u;
    *(void *)(result + 24) = v2;
  }
  return result;
}

uint64_t sub_1008E27C0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_101A17F50;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = 0;
  uint64_t v5 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  uint64_t v6 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v5;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v8 = *v4;
  *uint64_t v4 = v7;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  return a1;
}

uint64_t sub_1008E289C(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, this, "deviceInfo");
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, this, "phoneInfo");
  }
  if (*(unsigned char *)(a1 + 32)) {
    PB::TextFormatter::format(this, "timestamp", *(void *)(a1 + 24));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1008E296C(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 3)
      {
        *(unsigned char *)(a1 + 32) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 > 0xFFFFFFFFFFFFFFF5 || v22 + 10 > v23)
        {
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v27 = 0;
          if (v23 <= v22) {
            unint64_t v23 = *((void *)this + 1);
          }
          while (1)
          {
            if (v23 == v22)
            {
              uint64_t v27 = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_45;
            }
            unint64_t v32 = v22 + 1;
            char v33 = *(unsigned char *)(v24 + v22);
            *((void *)this + 1) = v32;
            v27 |= (unint64_t)(v33 & 0x7F) << v30;
            if ((v33 & 0x80) == 0) {
              break;
            }
            v30 += 7;
            unint64_t v22 = v32;
            BOOL v14 = v31++ > 8;
            if (v14)
            {
LABEL_41:
              uint64_t v27 = 0;
              goto LABEL_45;
            }
          }
          if (*((unsigned char *)this + 24)) {
            uint64_t v27 = 0;
          }
        }
        else
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          while (1)
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              break;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
            if (v14) {
              goto LABEL_41;
            }
          }
        }
LABEL_45:
        *(void *)(a1 + 24) = v27;
      }
      else
      {
        if (v20 == 2) {
          operator new();
        }
        if (v20 == 1) {
          operator new();
        }
LABEL_25:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_20;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_25;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_1008E2D1C(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Base **)(result + 16);
  if (v4) {
    uint64_t result = PB::Writer::writeSubmessage(this, v4, 1u);
  }
  uint64_t v5 = *(const PB::Base **)(v3 + 8);
  if (v5) {
    uint64_t result = PB::Writer::writeSubmessage(this, v5, 2u);
  }
  if (*(unsigned char *)(v3 + 32))
  {
    unint64_t v6 = *(void *)(v3 + 24);
    return PB::Writer::writeVarInt(this, v6, 3u);
  }
  return result;
}

uint64_t sub_1008E2D98(uint64_t result)
{
  if (!*(void *)(result + 16)) {
    operator new();
  }
  return result;
}

uint64_t sub_1008E2E44(uint64_t result)
{
  if (!*(void *)(result + 8)) {
    operator new();
  }
  return result;
}

uint64_t sub_1008E2F10(uint64_t a1)
{
  *(void *)a1 = off_101A17FA0;
  sub_10000A740((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_1008E2F54()
{
  LODWORD(v1[0]) = 2;
  v1[1] = &event::radio::reset;
  sub_1008E3A44((uint64_t)v2, (int *)v1);
  uint64_t v0 = (uint64_t *)sub_1003610D0((uint64_t *)&unk_101B09E30);
  sub_100361114(v0);
}

void sub_1008E32D0(_Unwind_Exception *a1)
{
  sub_100161C9C(v1 - 128);
  _Unwind_Resume(a1);
}

void sub_1008E3314(uint64_t a1)
{
  *(void *)a1 = off_101A17FA0;
  sub_10000A740((atomic_uint **)(a1 + 16));

  operator delete();
}

uint64_t sub_1008E3378@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v2 + 8), 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1008E3394(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_1008E33D8(uint64_t a1, uint64_t a2)
{
  int v4 = sub_1008E3564((uint64_t *)a1, a2);
  sub_1008E35D0((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  unint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      unsigned int v10 = (void *)v5[1];
      unint64_t v11 = v10;
      unint64_t v12 = v5;
      if (v10)
      {
        do
        {
          char v13 = v11;
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          char v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          unint64_t v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          unsigned int v16 = v10;
          unsigned int v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          unsigned int v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      unint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          char v18 = v17;
          unint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          char v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      uint64_t v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_1008E353C(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1008E3564(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_1008E35BC(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1008E35D0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1008E3620(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1008E3638(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1008E36A4(&v2);
}

void sub_1008E3690(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1008E36A4(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1008E3714(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_1008E3728(_Unwind_Exception *a1)
{
}

void sub_1008E3740()
{
}

uint64_t sub_1008E3754(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_1008E37BC()
{
  return 0;
}

uint64_t sub_1008E37C4()
{
  return 0;
}

uint64_t sub_1008E37CC()
{
  return 0;
}

void sub_1008E37D4(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1008E3840(&v2);
}

void sub_1008E382C(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1008E3840(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1008E38B0(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_1008E38C4(_Unwind_Exception *a1)
{
}

void sub_1008E38DC()
{
}

uint64_t sub_1008E38F0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_1008E3954()
{
  return 0;
}

uint64_t sub_1008E395C()
{
  return 0;
}

uint64_t sub_1008E3964()
{
  return 0;
}

uint64_t sub_1008E396C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_1008E39B4()
{
}

uint64_t sub_1008E39C8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 32));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_1008E3A2C()
{
  return 0;
}

uint64_t sub_1008E3A34()
{
  return 0;
}

uint64_t sub_1008E3A3C()
{
  return 0;
}

uint64_t sub_1008E3A44(uint64_t a1, int *a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v3 = *((void *)a2 + 1);
  int v6 = *a2;
  uint64_t v7 = v3;
  uint64_t v5 = off_101A18120;
  sub_100362128((uint64_t *)&v5, (uint64_t *)(a1 + 24));
  sub_100360F80((uint64_t *)&v5);
  return a1;
}

void sub_1008E3AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_100360F80((uint64_t *)&a9);
  sub_100360F80(v9);
  sub_100163C60(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1008E3ADC(uint64_t result, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        a2[4] = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5event7adapter23CSINotificationToSignalINS0_5bind0INS_11EventLoggerIFvvENS_14CS"
                                        "IEventLoggerEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5event7adapter23CSINotificationToSignalINS0_5bind0INS_11EventLoggerIFvvENS_14CSIEventLoggerEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)result;
    *((void *)a2 + 1) = *(void *)(result + 8);
  }
  return result;
}

atomic_uint **sub_1008E3B7C(atomic_uint **result, int a2)
{
  if (*(_DWORD *)result == a2)
  {
    uint64_t v2 = result[1];
    sub_100477910((uint64_t *)v2 + 3);
    uint64_t v3 = (uint64_t *)sub_100161CDC((uint64_t *)v2 + 1);
    return sub_10035414C(v3);
  }
  return result;
}

uint64_t sub_1008E3BD4(uint64_t a1, int *a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  int v5 = *a2;
  uint64_t v4 = (uint64_t)off_101A18140 + 1;
  sub_1001646C0(&v4, (uint64_t *)(a1 + 24));
  sub_100165094(&v4);
  return a1;
}

void sub_1008E3C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_100165094((uint64_t *)&a9);
  sub_100165094(v9);
  sub_100163C60(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1008E3C68(uint64_t result, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        a2[4] = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5event7adapter23SignalToCSINotificationE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5event7adapter23SignalToCSINotificationE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)result;
  }
  return result;
}

atomic_uint **sub_1008E3D00(int *a1)
{
  int v1 = *a1;
  uint64_t v2 = (uint64_t *)sub_1003610D0((uint64_t *)&unk_101B09E10);

  return sub_100362414(v2, v1, 0, 0, 0);
}

uint64_t sub_1008E3D4C(uint64_t a1, int *a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v3 = *((void *)a2 + 1);
  int v6 = *a2;
  uint64_t v7 = v3;
  int v5 = off_101A18160;
  sub_100362128((uint64_t *)&v5, (uint64_t *)(a1 + 24));
  sub_100360F80((uint64_t *)&v5);
  return a1;
}

void sub_1008E3DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_100360F80((uint64_t *)&a9);
  sub_100360F80(v9);
  sub_100163C60(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1008E3DE4(uint64_t result, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        a2[4] = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5event7adapter23CSINotificationToSignalINS0_5bind0IN5boost8signals26signalIFvvE"
                                        "NS4_19optional_last_valueIvEEiNSt3__14lessIiEENS3_8functionIS6_EENSC_IFvRKNS4_10"
                                        "connectionEEEENS4_5mutexEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5event7adapter23CSINotificationToSignalINS0_5bind0IN5boost8signals26signalIFvvENS4_19optional_last_valueIvEEiNSt3__14lessIiEENS3_8functionIS6_EENSC_IFvRKNS4_10connectionEEEENS4_5mutexEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)result;
    *((void *)a2 + 1) = *(void *)(result + 8);
  }
  return result;
}

atomic_uint **sub_1008E3E84(atomic_uint **result, int a2)
{
  if (*(_DWORD *)result == a2)
  {
    uint64_t v2 = (uint64_t *)sub_100161CDC((uint64_t *)result[1] + 1);
    return sub_10035414C(v2);
  }
  return result;
}

void sub_1008E3EC8()
{
  if ((byte_101B09E20 & 1) == 0)
  {
    byte_101B09E20 = 1;
    sub_100213048(&qword_101B09E08);
  }
  if ((byte_101B09E40 & 1) == 0)
  {
    byte_101B09E40 = 1;
    sub_100213048(&qword_101B09E28);
  }
  qword_101B13E20 = (uint64_t)off_101A17FA0;
  operator new();
}

void sub_1008E4134(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10000A740((atomic_uint **)(v1 + 32));
  sub_10000A740((atomic_uint **)(v1 + 8));
  operator delete();
}

void sub_1008E4168(_Unwind_Exception *a1)
{
}

uint64_t sub_1008E4260(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void *sub_1008E4290(void *a1, void *a2, NSObject **a3, void *a4)
{
  uint64_t v8 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, " me.hlp");
  sub_1008E438C(v8, a3, &v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
  *a1 = &off_101A18218;
  a1[6] = *a2;
  uint64_t v9 = a2[1];
  a1[7] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = *a4;
  uint64_t v10 = a4[1];
  a1[12] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 16), 1uLL, memory_order_relaxed);
  }
  a1[13] = 0;
  return a1;
}

void sub_1008E4378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1008E438C(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  int v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_1008E43F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void *sub_1008E4418(void *a1)
{
  *a1 = &off_101A18218;
  uint64_t v2 = (std::__shared_weak_count *)qword_101B13E48;
  qword_101B13E40 = 0;
  qword_101B13E48 = 0;
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (__CFUserNotification *)a1[10];
  if (v3) {
    CFUserNotificationCancel(v3);
  }
  uint64_t v4 = a1[13];
  if (v4) {
    dispatch_release(v4);
  }
  int v5 = (std::__shared_weak_count *)a1[12];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  int v6 = (std::__shared_weak_count *)a1[9];
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[7];
  if (v7) {
    sub_10004D2C8(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_1008E44C8(void *a1)
{
  sub_1008E4418(a1);

  operator delete();
}

void sub_1008E4500(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_1008E45A4();
}

void sub_1008E458C(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E45A4()
{
}

void sub_1008E4660(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E46A8(uint64_t a1)
{
  sub_10003E168(&v4, (void *)(a1 + 8));
  uint64_t v2 = v4;
  uint64_t v1 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = (std::__shared_weak_count *)qword_101B13E48;
  qword_101B13E40 = v2;
  qword_101B13E48 = (uint64_t)v1;
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v1 = v5;
  }
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1008E470C()
{
}

void sub_1008E4720(id a1)
{
  uint64_t v1 = +[NSNotificationCenter defaultCenter];
  uint64_t v2 = CTCellularPlanDanglingListDidChangeNotification;

  [(NSNotificationCenter *)v1 postNotificationName:v2 object:0];
}

void sub_1008E4760(capabilities::ct *a1, long long *a2, long long *a3)
{
  if (capabilities::ct::supportsGemini(a1))
  {
    if (!*((void *)a1 + 13))
    {
      int v6 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
      dispatch_queue_t v7 = dispatch_queue_create("remapChannelIdentifier", v6);
      uint64_t v8 = *((void *)a1 + 13);
      *((void *)a1 + 13) = v7;
      if (v8) {
        dispatch_release(v8);
      }
    }
    sub_10003E168(v11, (void *)a1 + 1);
    long long v9 = *(_OWORD *)v11;
    if (*(void *)&v11[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v11[8] + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(*((std::__shared_weak_count **)&v9 + 1));
    }
    uint64_t v10 = *((void *)a1 + 13);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3321888768;
    block[2] = sub_1008E4A24;
    block[3] = &unk_101A18298;
    *(void *)unint64_t v11 = a1;
    *(_OWORD *)&v11[8] = v9;
    if (*((void *)&v9 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v9 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(&v12, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v12 = *a2;
      uint64_t v13 = *((void *)a2 + 2);
    }
    if (*((char *)a3 + 23) < 0)
    {
      sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
    }
    else
    {
      long long __p = *a3;
      uint64_t v15 = *((void *)a3 + 2);
    }
    long long v17 = *(_OWORD *)v11;
    char v18 = *(std::__shared_weak_count **)&v11[16];
    if (*(void *)&v11[16]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v11[16] + 16), 1uLL, memory_order_relaxed);
    }
    if (SHIBYTE(v13) < 0)
    {
      sub_10004FC84(&v19, (void *)v12, *((unint64_t *)&v12 + 1));
    }
    else
    {
      long long v19 = v12;
      uint64_t v20 = v13;
    }
    if (SHIBYTE(v15) < 0)
    {
      sub_10004FC84(&v21, (void *)__p, *((unint64_t *)&__p + 1));
    }
    else
    {
      long long v21 = __p;
      uint64_t v22 = v15;
    }
    dispatch_async(v10, block);
    if (SHIBYTE(v15) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v13) < 0) {
      operator delete((void *)v12);
    }
    if (*(void *)&v11[16]) {
      std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v11[16]);
    }
    if (SHIBYTE(v22) < 0) {
      operator delete((void *)v21);
    }
    if (SHIBYTE(v20) < 0) {
      operator delete((void *)v19);
    }
    if (v18) {
      std::__shared_weak_count::__release_weak(v18);
    }
    if (*((void *)&v9 + 1)) {
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v9 + 1));
    }
  }
}

void sub_1008E49B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a27) {
    std::__shared_weak_count::__release_weak(a27);
  }
  sub_1008E4DDC((uint64_t)&a9);
  if (v33) {
    std::__shared_weak_count::__release_weak(v33);
  }
  _Unwind_Resume(a1);
}

void sub_1008E4A24(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (!*(void *)(a1 + 40))
      {
LABEL_20:
        sub_10004D2C8(v5);
        return;
      }
      int v6 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        dispatch_queue_t v7 = (const char *)(a1 + 56);
        if (*(char *)(a1 + 79) < 0) {
          dispatch_queue_t v7 = *(const char **)v7;
        }
        uint64_t v8 = (void *)(a1 + 80);
        if (*(char *)(a1 + 103) < 0) {
          uint64_t v8 = (void *)*v8;
        }
        *(_DWORD *)buf = 136315906;
        long long v19 = "";
        __int16 v20 = 2080;
        long long v21 = "";
        __int16 v22 = 2080;
        unint64_t v23 = v7;
        __int16 v24 = 2080;
        char v25 = v8;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sremapChannelIdentifier %s -> %s", buf, 0x2Au);
      }
      uint64_t v16 = 0;
      long long v17 = 0;
      Registry::getMobileHelper(&v16, *(Registry **)(v3 + 48));
      if (v16)
      {
        int v9 = (*(uint64_t (**)(void))(*(void *)v16 + 80))();
        uint64_t v10 = *(NSObject **)(v3 + 40);
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_18;
        }
        unint64_t v11 = "failure";
        *(_DWORD *)buf = 136315650;
        long long v19 = "";
        __int16 v20 = 2080;
        long long v21 = "";
        if (v9) {
          unint64_t v11 = "success";
        }
        __int16 v22 = 2080;
        unint64_t v23 = v11;
        long long v12 = "#I %s%sremapContactsChannelIdentifier result: %s";
        uint64_t v13 = v10;
        uint32_t v14 = 32;
      }
      else
      {
        uint64_t v15 = *(NSObject **)(v3 + 40);
        if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136315394;
        long long v19 = "";
        __int16 v20 = 2080;
        long long v21 = "";
        long long v12 = "#I %s%snotifyRemapping: failed to create Mobile Helper";
        uint64_t v13 = v15;
        uint32_t v14 = 22;
      }
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
LABEL_18:
      if (v17) {
        sub_10004D2C8(v17);
      }
      goto LABEL_20;
    }
  }
}

void sub_1008E4C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

unsigned char *sub_1008E4CA0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  uint64_t result = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  long long v7 = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)uint64_t result = v7;
  return result;
}

void sub_1008E4D48(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 48);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E4D78(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_1008E4DDC(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1008E4E30(capabilities::ct *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 8) = 0;
  uint64_t v8 = (uint64_t **)(a4 + 8);
  *(void *)(a4 + 16) = 0;
  *(void *)a4 = a4 + 8;
  if ((capabilities::ct::supportsGemini(a1) & 1) != 0 && a2[2])
  {
    uint64_t v9 = *((unsigned __int8 *)a3 + 23);
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = a3[1];
    }
    if (v9)
    {
      v49 = a1;
      long long __p = 0;
      unint64_t v55 = 0;
      int v56 = 0;
      id v10 = [objc_alloc((Class)NSMutableArray) initWithCapacity:2 * a2[2]];
      unint64_t v46 = a2;
      uint64_t v13 = (void *)*a2;
      long long v12 = a2 + 1;
      unint64_t v11 = v13;
      if (v13 != v12)
      {
        do
        {
          uint32_t v14 = v11 + 8;
          if (*((char *)v11 + 87) < 0) {
            uint32_t v14 = (void *)*v14;
          }
          objc_msgSend(v10, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14, v46, context));
          uint64_t v15 = v11 + 5;
          if (*((char *)v11 + 63) < 0) {
            uint64_t v15 = (void *)*v15;
          }
          objc_msgSend(v10, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v15));
          uint64_t v16 = v55;
          if (v55 >= v56)
          {
            char v18 = (char *)__p;
            uint64_t v19 = (v55 - (unsigned char *)__p) >> 2;
            unint64_t v20 = v19 + 1;
            if ((unint64_t)(v19 + 1) >> 62) {
              sub_10006A748();
            }
            uint64_t v21 = v56 - (unsigned char *)__p;
            if ((v56 - (unsigned char *)__p) >> 1 > v20) {
              unint64_t v20 = v21 >> 1;
            }
            if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v22 = v20;
            }
            if (v22)
            {
              unint64_t v23 = (char *)sub_10005ECD8((uint64_t)&v56, v22);
              char v18 = (char *)__p;
              uint64_t v16 = v55;
            }
            else
            {
              unint64_t v23 = 0;
            }
            __int16 v24 = &v23[4 * v19];
            *(_DWORD *)__int16 v24 = *((_DWORD *)v11 + 8);
            long long v17 = v24 + 4;
            while (v16 != v18)
            {
              int v25 = *((_DWORD *)v16 - 1);
              v16 -= 4;
              *((_DWORD *)v24 - 1) = v25;
              v24 -= 4;
            }
            long long __p = v24;
            unint64_t v55 = v17;
            int v56 = &v23[4 * v22];
            if (v18) {
              operator delete(v18);
            }
          }
          else
          {
            *(_DWORD *)unint64_t v55 = *((_DWORD *)v11 + 8);
            long long v17 = v16 + 4;
          }
          unint64_t v55 = v17;
          unsigned int v26 = (void *)v11[1];
          if (v26)
          {
            do
            {
              uint64_t v27 = v26;
              unsigned int v26 = (void *)*v26;
            }
            while (v26);
          }
          else
          {
            do
            {
              uint64_t v27 = (void *)v11[2];
              BOOL v28 = *v27 == (void)v11;
              unint64_t v11 = v27;
            }
            while (!v28);
          }
          unint64_t v11 = v27;
        }
        while (v27 != v12);
      }
      if (*((char *)a3 + 23) >= 0) {
        char v29 = a3;
      }
      else {
        char v29 = (uint64_t *)*a3;
      }
      +[NSArray arrayWithObject:](NSArray, "arrayWithObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v29, v46));
      uint64_t v52 = 0;
      v53 = 0;
      Registry::getMobileHelper(&v52, *((Registry **)v49 + 6));
      char v30 = *((void *)v49 + 5);
      if (v52)
      {
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_debug_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEBUG, "#D %s%sLabels", buf, 0x16u);
        }
        *(void *)buf = off_101A18468;
        *(void *)&buf[8] = v49;
        v58 = buf;
        logger::CFTypeRefLogger();
        sub_10012C330(buf);
        CFArrayRef theArray = 0;
        (*(void (**)(CFArrayRef *__return_ptr))(*(void *)v52 + 64))(&theArray);
        if (theArray) {
          unsigned int v31 = sub_100083F10;
        }
        else {
          unsigned int v31 = 0;
        }
        unint64_t v32 = *((void *)v49 + 5);
        if (v31)
        {
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = "";
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "";
            _os_log_debug_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "#D %s%sBadges", buf, 0x16u);
          }
          *(void *)buf = off_101A184E8;
          *(void *)&buf[8] = v49;
          v58 = buf;
          logger::CFTypeRefLogger();
          sub_10012C330(buf);
          CFIndex Count = CFArrayGetCount(theArray);
          unint64_t v34 = *(unsigned char **)(v47 + 16);
          if ((unsigned char *)Count == v34)
          {
            unint64_t v35 = __p;
            if (v55 != __p)
            {
              unint64_t v36 = 0;
              do
              {
                CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v36);
                int v37 = v35[v36];
                unint64_t v38 = *v8;
                unint64_t v39 = (uint64_t **)(a4 + 8);
                v40 = (uint64_t **)(a4 + 8);
                if (*v8)
                {
                  while (1)
                  {
                    while (1)
                    {
                      v40 = (uint64_t **)v38;
                      int v41 = *((_DWORD *)v38 + 8);
                      if (v41 <= v37) {
                        break;
                      }
                      unint64_t v38 = *v40;
                      unint64_t v39 = v40;
                      if (!*v40) {
                        goto LABEL_55;
                      }
                    }
                    if (v41 >= v37) {
                      break;
                    }
                    unint64_t v38 = v40[1];
                    if (!v38)
                    {
                      unint64_t v39 = v40 + 1;
                      goto LABEL_55;
                    }
                  }
                }
                else
                {
LABEL_55:
                  *(void *)&buf[16] = 0;
                  uint64_t v42 = operator new(0x30uLL);
                  *(void *)buf = v42;
                  *(void *)&buf[8] = a4 + 8;
                  buf[16] = 0;
                  v42[8] = v37;
                  sub_100056248((void *)v42 + 5, &ValueAtIndex);
                  buf[16] = 1;
                  sub_100046C38((uint64_t **)a4, (uint64_t)v40, v39, *(uint64_t **)buf);
                  *(void *)buf = 0;
                  sub_1008E94B8((uint64_t)buf, 0);
                }
                ++v36;
                unint64_t v35 = __p;
              }
              while (v36 < (v55 - (unsigned char *)__p) >> 2);
            }
          }
          else
          {
            v44 = *((void *)v49 + 5);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              CFIndex v45 = CFArrayGetCount(theArray);
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = "";
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = "";
              *(_WORD *)&buf[22] = 2048;
              v58 = v34;
              __int16 v59 = 2048;
              CFIndex v60 = v45;
              _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "#E %s%smismatch in labels (%zu) / badges (%zu) - bail out", buf, 0x2Au);
            }
          }
        }
        else if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "#E %s%sEmpty getBadgeLabels result", buf, 0x16u);
        }
        sub_100044D00((const void **)&theArray);
      }
      else if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s%sgetShortLabelForSlots, failed to create Mobile Helper", buf, 0x16u);
      }
      if (v53) {
        sub_10004D2C8(v53);
      }
      if (__p)
      {
        unint64_t v55 = (char *)__p;
        operator delete(__p);
      }
    }
    else
    {
      v43 = *((void *)a1 + 5);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#W %s%slanguage not set yet", buf, 0x16u);
      }
    }
  }
}

void sub_1008E5510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17, uint64_t a18, char a19)
{
  sub_100044D00(&a13);
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (__p)
  {
    a17 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100706DDC(v19, *(const void ***)(v19 + 8));
  _Unwind_Resume(a1);
}

void sub_1008E55B0(uint64_t a1@<X0>, uint64_t **a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = *(NSObject **)(a1 + 40);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sgetShortLabels", buf, 0x16u);
  }
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if ((capabilities::ct::supportsGemini((capabilities::ct *)v9) & 1) != 0 && a2[1] != *a2)
  {
    uint64_t v10 = *((unsigned __int8 *)a3 + 23);
    if ((v10 & 0x80u) != 0) {
      uint64_t v10 = a3[1];
    }
    if (v10)
    {
      id v12 = [objc_alloc((Class)NSMutableArray) initWithCapacity:0x5555555555555556 * (((char *)a2[1] - (char *)*a2) >> 4)];
      uint64_t v13 = *a2;
      uint32_t v14 = a2[1];
      if (*a2 != v14)
      {
        do
        {
          uint64_t v15 = v13 + 3;
          if (*((char *)v13 + 47) < 0) {
            uint64_t v15 = (void *)*v15;
          }
          objc_msgSend(v12, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v15));
          uint64_t v16 = v13;
          if (*((char *)v13 + 23) < 0) {
            uint64_t v16 = (uint64_t *)*v13;
          }
          objc_msgSend(v12, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v16));
          v13 += 6;
        }
        while (v13 != v14);
      }
      if (*((char *)a3 + 23) >= 0) {
        long long v17 = a3;
      }
      else {
        long long v17 = (uint64_t *)*a3;
      }
      +[NSArray arrayWithObject:](NSArray, "arrayWithObject:", +[NSString stringWithUTF8String:v17]);
      uint64_t v30 = 0;
      unsigned int v31 = 0;
      Registry::getMobileHelper(&v30, *(Registry **)(a1 + 48));
      char v18 = *(NSObject **)(a1 + 40);
      if (v30)
      {
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "#D %s%sLabels", buf, 0x16u);
        }
        *(void *)buf = off_101A18568;
        *(void *)&buf[8] = a1;
        unint64_t v34 = buf;
        logger::CFTypeRefLogger();
        sub_10012C330(buf);
        CFArrayRef theArray = 0;
        (*(void (**)(CFArrayRef *__return_ptr))(*(void *)v30 + 64))(&theArray);
        if (theArray) {
          uint64_t v19 = sub_100083F10;
        }
        else {
          uint64_t v19 = 0;
        }
        unint64_t v20 = *(NSObject **)(a1 + 40);
        if (v19)
        {
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = "";
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "";
            _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "#D %s%sBadges", buf, 0x16u);
          }
          *(void *)buf = off_101A185E8;
          *(void *)&buf[8] = a1;
          unint64_t v34 = buf;
          logger::CFTypeRefLogger();
          sub_10012C330(buf);
          CFIndex Count = CFArrayGetCount(theArray);
          CFIndex v22 = Count;
          unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 4);
          if (Count == v23)
          {
            if (Count)
            {
              CFIndex v24 = 0;
              do
              {
                *(void *)buf = CFArrayGetValueAtIndex(theArray, v24);
                unint64_t v25 = a4[1];
                if (v25 >= a4[2])
                {
                  uint64_t v26 = sub_1008E7AA4(a4, (CFTypeRef *)buf);
                }
                else
                {
                  sub_100056248((void *)a4[1], (CFTypeRef *)buf);
                  uint64_t v26 = v25 + 8;
                  a4[1] = v25 + 8;
                }
                a4[1] = v26;
                ++v24;
              }
              while (v22 != v24);
            }
          }
          else
          {
            BOOL v28 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = "";
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = "";
              __int16 v33 = 2048;
              unint64_t v34 = (unsigned char *)v23;
              __int16 v35 = 2048;
              CFIndex v36 = v22;
              _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "#E %s%smismatch in labels (%zu) / badges (%zu) - bail out", buf, 0x2Au);
            }
          }
        }
        else if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "#E %s%sEmpty getBadgeLabels result", buf, 0x16u);
        }
        sub_100044D00((const void **)&theArray);
      }
      else if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%sgetShortLabels, failed to create Mobile Helper", buf, 0x16u);
      }
      if (v31) {
        sub_10004D2C8(v31);
      }
    }
    else
    {
      uint64_t v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#W %s%slanguage not set yet", buf, 0x16u);
      }
    }
  }
}

void sub_1008E5B84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  int v6 = va_arg(va1, std::__shared_weak_count *);
  sub_100044D00((const void **)va);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100084178((void ***)va1);
  _Unwind_Resume(a1);
}

void sub_1008E5C08(uint64_t a1@<X0>, uint64_t **a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = *(NSObject **)(a1 + 40);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sgetLocalizedPredefinedLabels", buf, 0x16u);
  }
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if ((capabilities::ct::supportsGemini((capabilities::ct *)v9) & 1) != 0 && a2[1] != *a2)
  {
    id v11 = [objc_alloc((Class)NSMutableArray) initWithCapacity:0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2)];
    id v12 = *a2;
    uint64_t v13 = a2[1];
    if (*a2 != v13)
    {
      do
      {
        uint32_t v14 = v12;
        if (*((char *)v12 + 23) < 0) {
          uint32_t v14 = (uint64_t *)*v12;
        }
        objc_msgSend(v11, "addObject:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14));
        v12 += 3;
      }
      while (v12 != v13);
    }
    if (*((char *)a3 + 23) < 0)
    {
      if (!a3[1])
      {
LABEL_15:
        +[NSArray array];
        goto LABEL_16;
      }
      a3 = (uint64_t *)*a3;
    }
    else if (!*((unsigned char *)a3 + 23))
    {
      goto LABEL_15;
    }
    +[NSArray arrayWithObject:](NSArray, "arrayWithObject:", +[NSString stringWithUTF8String:a3]);
LABEL_16:
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    Registry::getMobileHelper(&v26, *(Registry **)(a1 + 48));
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (v26)
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "#D %s%sCT Labels", buf, 0x16u);
      }
      *(void *)buf = off_101A18668;
      *(void *)&buf[8] = a1;
      uint64_t v30 = buf;
      logger::CFTypeRefLogger();
      sub_10012C330(buf);
      CFArrayRef theArray = 0;
      (*(void (**)(CFArrayRef *__return_ptr))(*(void *)v26 + 72))(&theArray);
      if (theArray) {
        uint64_t v16 = sub_100083F10;
      }
      else {
        uint64_t v16 = 0;
      }
      long long v17 = *(NSObject **)(a1 + 40);
      if (v16)
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "#D %s%sLocalized labels", buf, 0x16u);
        }
        *(void *)buf = off_101A186E8;
        *(void *)&buf[8] = a1;
        uint64_t v30 = buf;
        logger::CFTypeRefLogger();
        sub_10012C330(buf);
        CFIndex Count = CFArrayGetCount(theArray);
        CFIndex v19 = Count;
        unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2);
        if (Count == v20)
        {
          if (Count)
          {
            CFIndex v21 = 0;
            do
            {
              *(void *)buf = CFArrayGetValueAtIndex(theArray, v21);
              unint64_t v22 = a4[1];
              if (v22 >= a4[2])
              {
                uint64_t v23 = sub_1008E7AA4(a4, (CFTypeRef *)buf);
              }
              else
              {
                sub_100056248((void *)a4[1], (CFTypeRef *)buf);
                uint64_t v23 = v22 + 8;
                a4[1] = v22 + 8;
              }
              a4[1] = v23;
              ++v21;
            }
            while (v19 != v21);
          }
        }
        else
        {
          CFIndex v24 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = "";
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "";
            __int16 v29 = 2048;
            uint64_t v30 = (unsigned char *)v20;
            __int16 v31 = 2048;
            CFIndex v32 = v19;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "#E %s%smismatch in request (%zu) and localized labels (%zu) - bail out", buf, 0x2Au);
          }
        }
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "#E %s%sEmpty getLocalizedPredefinedLabels result", buf, 0x16u);
      }
      sub_100044D00((const void **)&theArray);
    }
    else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%sgetShortLabels, failed to create Mobile Helper", buf, 0x16u);
    }
    if (v27) {
      sub_10004D2C8(v27);
    }
  }
}

void sub_1008E6160(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  int v6 = va_arg(va1, std::__shared_weak_count *);
  sub_100044D00((const void **)va);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100084178((void ***)va1);
  _Unwind_Resume(a1);
}

void sub_1008E61E4(Registry *this@<X1>, void *a2@<X2>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, this);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    long long v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v14);
  if (v10)
  {
    uint64_t v12 = v10[3];
    id v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  id v11 = 0;
  char v13 = 1;
LABEL_9:
  (*(void (**)(uint64_t, void, void, void))(*(void *)v12 + 40))(v12, kAlertDialogLocalizationTable, *a2, a2[1]);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1008E6308(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E6324(void *a1)
{
  uint64_t v2 = (__CFUserNotification *)a1[10];
  if (v2)
  {
    CFUserNotificationCancel(v2);
    a1[10] = 0;
  }
  uint64_t v3 = (uint64_t *)a1[8];
  if (v3)
  {
    uint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = (uint64_t *)*v3;
      uint64_t v6 = *(unsigned __int8 *)(*v3 + 127);
      BOOL v7 = (v6 & 0x80u) != 0;
      if ((v6 & 0x80u) != 0) {
        uint64_t v6 = *(void *)(*v3 + 112);
      }
      uint64_t v8 = (const char *)(v5 + 13);
      if (v7) {
        uint64_t v8 = (const char *)v5[13];
      }
      if (v6) {
        unsigned int v9 = v8;
      }
      else {
        unsigned int v9 = "<invalid>";
      }
      if (*((char *)v5 + 23) < 0) {
        uint64_t v5 = (uint64_t *)*v5;
      }
      int v11 = 136315906;
      uint64_t v12 = "";
      __int16 v13 = 2080;
      unint64_t v14 = "";
      __int16 v15 = 2080;
      uint64_t v16 = v9;
      __int16 v17 = 2080;
      char v18 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sCanceling current alert for %s : %s", (uint8_t *)&v11, 0x2Au);
    }
    uint64_t v10 = (std::__shared_weak_count *)a1[9];
    a1[8] = 0;
    a1[9] = 0;
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
}

void sub_1008E6454(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(uint64_t ***)(a1 + 64);
  if (v2)
  {
    uint64_t v4 = *v2;
    uint64_t v3 = v2[1];
    *a2 = v4;
    a2[1] = v3;
    if (v3) {
      atomic_fetch_add_explicit(v3 + 1, 1uLL, memory_order_relaxed);
    }
    if (v4)
    {
      uint64_t v5 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v6 = (const char *)v4[13];
      uint64_t v7 = *((unsigned __int8 *)v4 + 127);
      int v8 = (char)v7;
      if ((v7 & 0x80u) != 0) {
        uint64_t v7 = v4[14];
      }
      if (v8 >= 0) {
        uint64_t v6 = (const char *)(v4 + 13);
      }
      if (!v7) {
        uint64_t v6 = "<invalid>";
      }
      if (*((char *)v4 + 23) < 0) {
        uint64_t v4 = (uint64_t *)*v4;
      }
      int v13 = 136315906;
      unint64_t v14 = "";
      __int16 v15 = 2080;
      uint64_t v16 = "";
      __int16 v17 = 2080;
      char v18 = v6;
      __int16 v19 = 2080;
      unint64_t v20 = v4;
      unsigned int v9 = "#I %s%scurrent alert for %s : %s";
      uint64_t v10 = v5;
      uint32_t v11 = 42;
      goto LABEL_18;
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
    return;
  }
  int v13 = 136315394;
  unint64_t v14 = "";
  __int16 v15 = 2080;
  uint64_t v16 = "";
  unsigned int v9 = "#I %s%sno current alert";
  uint64_t v10 = v12;
  uint32_t v11 = 22;
LABEL_18:
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v13, v11);
}

void sub_1008E65D0(void *a1, uint8_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = a1 + 8;
  uint64_t v5 = a1[8];
  if (v5)
  {
    unsigned int v9 = (std::__shared_weak_count *)a1[9];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v10 = (std::__shared_weak_count *)a1[9];
      *uint64_t v4 = 0;
      v4[1] = 0;
      if (v10) {
        sub_10004D2C8(v10);
      }
    }
    else
    {
      *uint64_t v4 = 0;
      a1[9] = 0;
    }
    uint64_t v12 = (std::__shared_weak_count *)a3[1];
    uint64_t v17 = *a3;
    char v18 = v12;
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v13 = (std::__shared_weak_count *)a4[1];
    uint64_t v15 = *a4;
    uint64_t v16 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = *(void *)(v5 + 64);
    buf[0] = a2;
    if (!v14) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint8_t *, uint64_t *, uint64_t *))(*(void *)v14 + 48))(v14, buf, &v17, &v15);
    if (v16) {
      sub_10004D2C8(v16);
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  else
  {
    uint32_t v11 = a1[5];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      unint64_t v20 = "";
      __int16 v21 = 2080;
      unint64_t v22 = "";
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "#E %s%sfinalizeDialog - no fAlertInfo?!", buf, 0x16u);
    }
  }
}

void sub_1008E676C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008E679C(uint64_t a1, const __CFString ***a2, void **a3, void *a4)
{
  if (!*(void *)(a1 + 64))
  {
    if (!capabilities::ct::supportsGemini((capabilities::ct *)a1)) {
      return 0;
    }
    sub_1008E9BB0(buf, a2, a3, a4);
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 72);
    *(_OWORD *)(a1 + 64) = *(_OWORD *)buf;
    if (v10) {
      sub_10004D2C8(v10);
    }
    uint32_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%sShow Resolution Alert", buf, 0x16u);
    }
    value = 0;
    sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0AAA8, v12);
    CFStringRef v32 = 0;
    sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0AAB8, v13);
    CFStringRef v31 = 0;
    uint64_t v15 = *a2;
    if (*((char *)*a2 + 23) < 0) {
      uint64_t v15 = (const __CFString **)*v15;
    }
    unint64_t v34 = 0;
    __int16 v35 = 0;
    if (ctu::cf::convert_copy((ctu::cf *)&v35, v15, (const char *)0x8000100, kCFAllocatorDefault, v14))
    {
      uint64_t v16 = v34;
      unint64_t v34 = v35;
      *(void *)buf = v16;
      sub_1000558F4((const void **)buf);
    }
    CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v34;
    unint64_t v34 = 0;
    sub_1000558F4((const void **)&v34);
    CFStringRef v31 = CFStringCreateWithFormat(0, 0, v32, theDict);
    sub_1000558F4((const void **)&theDict);
    __int16 v35 = 0;
    sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0AAC8, v17);
    unint64_t v34 = 0;
    sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0AAD8, v18);
    CFMutableDictionaryRef theDict = 0;
    CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(0, 4, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlertHeaderKey, value);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlertMessageKey, v31);
    CFDictionaryAddValue(theDict, kCFUserNotificationDefaultButtonTitleKey, v35);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlternateButtonTitleKey, v34);
    SInt32 error = 0;
    __int16 v19 = CFUserNotificationCreate(0, 0.0, 0x20uLL, &error, theDict);
    unint64_t v20 = v19;
    *(void *)(a1 + 80) = v19;
    if (error || !v19)
    {
      CFIndex v24 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%sCould not create displayResolutionAlert notification", buf, 0x16u);
        unint64_t v20 = *(__CFUserNotification **)(a1 + 80);
      }
      if (v20)
      {
        CFRelease(v20);
        *(void *)(a1 + 80) = 0;
      }
    }
    else
    {
      CFRunLoopSourceRef source = CFUserNotificationCreateRunLoopSource(0, v19, (CFUserNotificationCallBack)sub_1008E6D24, 0);
      if (source) {
        __int16 v21 = sub_1003F4D44;
      }
      else {
        __int16 v21 = 0;
      }
      if (v21)
      {
        Main = CFRunLoopGetMain();
        CFRunLoopAddSource(Main, source, kCFRunLoopCommonModes);
        uint64_t v23 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%sdisplayResolutionAlert shown", buf, 0x16u);
        }
      }
      else
      {
        unint64_t v25 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%sCould not create displayResolutionAlert runloop", buf, 0x16u);
        }
        CFRelease(*(CFTypeRef *)(a1 + 80));
        *(void *)(a1 + 80) = 0;
      }
      sub_1003F4D4C((const void **)&source);
      if (*(void *)(a1 + 80))
      {
        uint64_t v6 = 1;
LABEL_34:
        sub_10005717C((const void **)&theDict);
        sub_1000558F4((const void **)&v34);
        sub_1000558F4((const void **)&v35);
        sub_1000558F4((const void **)&v31);
        sub_1000558F4((const void **)&v32);
        sub_1000558F4((const void **)&value);
        return v6;
      }
    }
    uint64_t v26 = *(std::__shared_weak_count **)(a1 + 72);
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    if (v26) {
      sub_10004D2C8(v26);
    }
    uint64_t v6 = 0;
    goto LABEL_34;
  }
  uint64_t v5 = *(NSObject **)(a1 + 40);
  uint64_t v6 = 0;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sAlert on the screen - displayResolutionAlert ignored", buf, 0x16u);
    return 0;
  }
  return v6;
}

void sub_1008E6C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va5, a5);
  va_start(va4, a5);
  va_start(va3, a5);
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v8 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v10 = va_arg(va3, const void *);
  va_copy(va4, va3);
  uint64_t v12 = va_arg(va4, const void *);
  va_copy(va5, va4);
  CFAllocatorRef v14 = va_arg(va5, const void *);
  sub_10005717C((const void **)va);
  sub_1000558F4((const void **)va4);
  sub_1000558F4((const void **)va5);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  sub_1000558F4((const void **)va3);
  _Unwind_Resume(a1);
}

void sub_1008E6D24(uint64_t a1, uint64_t a2)
{
  if (qword_101B13E48)
  {
    uint64_t v4 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B13E48);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = (void *)qword_101B13E40;
      if (qword_101B13E40)
      {
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3321888768;
        v12[2] = sub_1008E7BCC;
        v12[3] = &unk_101A18390;
        v12[4] = qword_101B13E40;
        int v13 = v4;
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v14 = a1;
        uint64_t v15 = a2;
        uint64_t v7 = (std::__shared_weak_count *)v6[2];
        if (!v7 || (uint64_t v8 = v6[1], (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v10 = v9;
        uint32_t v11 = v6[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 3321888768;
        block[2] = sub_1008E878C;
        block[3] = &unk_101A183C8;
        block[5] = v8;
        uint64_t v17 = v10;
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        void block[4] = v12;
        dispatch_async(v11, block);
        if (v17) {
          sub_10004D2C8(v17);
        }
        sub_10004D2C8(v10);
        if (v13) {
          sub_10004D2C8(v13);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1008E6E88(uint64_t a1, uint64_t a2)
{
  if (qword_101B13E48)
  {
    uint64_t v4 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B13E48);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = (void *)qword_101B13E40;
      if (qword_101B13E40)
      {
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3321888768;
        v12[2] = sub_1008E87C8;
        v12[3] = &unk_101A18390;
        v12[4] = qword_101B13E40;
        int v13 = v4;
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v14 = a1;
        uint64_t v15 = a2;
        uint64_t v7 = (std::__shared_weak_count *)v6[2];
        if (!v7 || (uint64_t v8 = v6[1], (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v10 = v9;
        uint32_t v11 = v6[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 3321888768;
        block[2] = sub_1008E878C;
        block[3] = &unk_101A183C8;
        block[5] = v8;
        uint64_t v17 = v10;
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        void block[4] = v12;
        dispatch_async(v11, block);
        if (v17) {
          sub_10004D2C8(v17);
        }
        sub_10004D2C8(v10);
        if (v13) {
          sub_10004D2C8(v13);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1008E6FEC(uint64_t a1, uint64_t a2)
{
  if (qword_101B13E48)
  {
    uint64_t v4 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B13E48);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = (void *)qword_101B13E40;
      if (qword_101B13E40)
      {
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3321888768;
        v12[2] = sub_1008E8A80;
        v12[3] = &unk_101A18390;
        v12[4] = qword_101B13E40;
        int v13 = v4;
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v14 = a1;
        uint64_t v15 = a2;
        uint64_t v7 = (std::__shared_weak_count *)v6[2];
        if (!v7 || (uint64_t v8 = v6[1], (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v10 = v9;
        uint32_t v11 = v6[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 3321888768;
        block[2] = sub_1008E878C;
        block[3] = &unk_101A183C8;
        block[5] = v8;
        uint64_t v17 = v10;
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        void block[4] = v12;
        dispatch_async(v11, block);
        if (v17) {
          sub_10004D2C8(v17);
        }
        sub_10004D2C8(v10);
        if (v13) {
          sub_10004D2C8(v13);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_1008E7150(uint64_t a1, void *a2, __CFString ***a3, void *a4)
{
  if (!*(void *)(a1 + 64))
  {
    if (!capabilities::ct::supportsGemini((capabilities::ct *)a1)) {
      return 0;
    }
    sub_1008E9BB0(buf, a2, a3, a4);
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 72);
    *(_OWORD *)(a1 + 64) = *(_OWORD *)buf;
    if (v10) {
      sub_10004D2C8(v10);
    }
    uint32_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%sShow Multichoice Resolution Alert", buf, 0x16u);
    }
    value = 0;
    sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0AB58, v12);
    unint64_t v48 = 0;
    v49 = 0;
    unint64_t v46 = 0;
    uint64_t v47 = 0;
    int v13 = (uint64_t *)((char *)a3[1] - (char *)*a3);
    if ((unint64_t)v13 < 0x11)
    {
      *(void *)SInt32 error = 0;
      sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0AB98, v13);
      BOOL v28 = **a3;
      if (SHIBYTE(v28->data) < 0) {
        BOOL v28 = (__CFString *)v28->isa;
      }
      CFRunLoopSourceRef source = 0;
      CFMutableDictionaryRef theDict = 0;
      if (ctu::cf::convert_copy((ctu::cf *)&theDict, (const __CFString **)v28, (const char *)0x8000100, kCFAllocatorDefault, v27))
      {
        CFRunLoopSourceRef v29 = source;
        CFRunLoopSourceRef source = theDict;
        *(void *)buf = v29;
        sub_1000558F4((const void **)buf);
      }
      CFRunLoopSourceRef v44 = source;
      CFRunLoopSourceRef source = 0;
      sub_1000558F4((const void **)&source);
      uint64_t v30 = (__CFString *)CFStringCreateWithFormat(0, 0, *(CFStringRef *)error, v44);
      CFStringRef v31 = v49;
      v49 = v30;
      *(void *)buf = v31;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v44);
      sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0ABA8, v32);
      *(void *)buf = v48;
      unint64_t v48 = theDict;
      CFMutableDictionaryRef theDict = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&theDict);
      sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0AB88, v33);
      *(void *)buf = v47;
      uint64_t v47 = theDict;
    }
    else
    {
      sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0AB68, v13);
      *(void *)buf = v49;
      v49 = theDict;
      CFMutableDictionaryRef theDict = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&theDict);
      *(void *)SInt32 error = 0;
      sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0AB78, v14);
      uint64_t v16 = **a3;
      if (SHIBYTE(v16->data) < 0) {
        uint64_t v16 = (__CFString *)v16->isa;
      }
      CFRunLoopSourceRef source = 0;
      CFMutableDictionaryRef theDict = 0;
      if (ctu::cf::convert_copy((ctu::cf *)&theDict, (const __CFString **)v16, (const char *)0x8000100, kCFAllocatorDefault, v15))
      {
        CFRunLoopSourceRef v17 = source;
        CFRunLoopSourceRef source = theDict;
        *(void *)buf = v17;
        sub_1000558F4((const void **)buf);
      }
      CFRunLoopSourceRef v44 = source;
      CFRunLoopSourceRef source = 0;
      sub_1000558F4((const void **)&source);
      char v18 = (__CFString *)CFStringCreateWithFormat(0, 0, *(CFStringRef *)error, v44);
      __int16 v19 = v47;
      uint64_t v47 = v18;
      *(void *)buf = v19;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v44);
      __int16 v21 = (*a3)[2];
      if (SHIBYTE(v21->data) < 0) {
        __int16 v21 = (__CFString *)v21->isa;
      }
      CFStringRef v22 = *(const __CFString **)error;
      CFRunLoopSourceRef source = 0;
      CFMutableDictionaryRef theDict = 0;
      if (ctu::cf::convert_copy((ctu::cf *)&theDict, (const __CFString **)v21, (const char *)0x8000100, kCFAllocatorDefault, v20))
      {
        CFRunLoopSourceRef v23 = source;
        CFRunLoopSourceRef source = theDict;
        *(void *)buf = v23;
        sub_1000558F4((const void **)buf);
      }
      CFRunLoopSourceRef v44 = source;
      CFRunLoopSourceRef source = 0;
      sub_1000558F4((const void **)&source);
      CFIndex v24 = (__CFString *)CFStringCreateWithFormat(0, 0, v22, v44);
      unint64_t v25 = v46;
      unint64_t v46 = v24;
      *(void *)buf = v25;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)&v44);
      sub_1008E61E4(*(Registry **)(a1 + 48), &off_101B0AB88, v26);
      *(void *)buf = v48;
      unint64_t v48 = theDict;
    }
    CFMutableDictionaryRef theDict = 0;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&theDict);
    sub_1000558F4((const void **)error);
    CFMutableDictionaryRef theDict = 0;
    CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(0, 5, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlertHeaderKey, value);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlertMessageKey, v49);
    CFDictionaryAddValue(theDict, kCFUserNotificationDefaultButtonTitleKey, v48);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlternateButtonTitleKey, v47);
    if (v46) {
      unint64_t v34 = sub_1000810B8;
    }
    else {
      unint64_t v34 = 0;
    }
    if (v34) {
      CFDictionaryAddValue(theDict, kCFUserNotificationOtherButtonTitleKey, v46);
    }
    error[0] = 0;
    __int16 v35 = CFUserNotificationCreate(0, 0.0, 0, error, theDict);
    CFIndex v36 = v35;
    *(void *)(a1 + 80) = v35;
    if (error[0] || !v35)
    {
      v40 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s%sCould not create displayMultichoiceResolutionAlert notification", buf, 0x16u);
        CFIndex v36 = *(__CFUserNotification **)(a1 + 80);
      }
      if (v36)
      {
        CFRelease(v36);
        *(void *)(a1 + 80) = 0;
      }
    }
    else
    {
      CFRunLoopSourceRef source = CFUserNotificationCreateRunLoopSource(0, v35, (CFUserNotificationCallBack)sub_1008E7940, 0);
      if (source) {
        int v37 = sub_1003F4D44;
      }
      else {
        int v37 = 0;
      }
      if (v37)
      {
        Main = CFRunLoopGetMain();
        CFRunLoopAddSource(Main, source, kCFRunLoopCommonModes);
        unint64_t v39 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s%sdisplayMultichoiceResolutionAlert shown", buf, 0x16u);
        }
      }
      else
      {
        int v41 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I %s%sCould not create displayMultichoiceResolutionAlert runloop", buf, 0x16u);
        }
        CFRelease(*(CFTypeRef *)(a1 + 80));
        *(void *)(a1 + 80) = 0;
      }
      sub_1003F4D4C((const void **)&source);
      if (*(void *)(a1 + 80))
      {
        uint64_t v6 = 1;
LABEL_50:
        sub_10005717C((const void **)&theDict);
        sub_1000558F4((const void **)&v46);
        sub_1000558F4((const void **)&v47);
        sub_1000558F4((const void **)&v48);
        sub_1000558F4((const void **)&v49);
        sub_1000558F4((const void **)&value);
        return v6;
      }
    }
    uint64_t v42 = *(std::__shared_weak_count **)(a1 + 72);
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    if (v42) {
      sub_10004D2C8(v42);
    }
    uint64_t v6 = 0;
    goto LABEL_50;
  }
  uint64_t v5 = *(NSObject **)(a1 + 40);
  uint64_t v6 = 0;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sAlert on the screen - displayMultichoiceResolutionAlertx ignored", buf, 0x16u);
    return 0;
  }
  return v6;
}

void sub_1008E788C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va5, a4);
  va_start(va4, a4);
  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, const void *);
  va_copy(va3, va2);
  unsigned int v9 = va_arg(va3, const void *);
  va_copy(va4, va3);
  uint32_t v11 = va_arg(va4, const void *);
  va_copy(va5, va4);
  int v13 = va_arg(va5, const void *);
  uint64_t v15 = va_arg(va5, void);
  sub_10005717C((const void **)va5);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  sub_1000558F4((const void **)va3);
  sub_1000558F4((const void **)va4);
  _Unwind_Resume(a1);
}

void sub_1008E7940(uint64_t a1, uint64_t a2)
{
  if (qword_101B13E48)
  {
    uint64_t v4 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B13E48);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = (void *)qword_101B13E40;
      if (qword_101B13E40)
      {
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3321888768;
        v12[2] = sub_1008E8C84;
        v12[3] = &unk_101A18390;
        v12[4] = qword_101B13E40;
        int v13 = v4;
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v14 = a1;
        uint64_t v15 = a2;
        uint64_t v7 = (std::__shared_weak_count *)v6[2];
        if (!v7 || (uint64_t v8 = v6[1], (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v10 = v9;
        uint32_t v11 = v6[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 3321888768;
        block[2] = sub_1008E878C;
        block[3] = &unk_101A183C8;
        block[5] = v8;
        CFRunLoopSourceRef v17 = v10;
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        void block[4] = v12;
        dispatch_async(v11, block);
        if (v17) {
          sub_10004D2C8(v17);
        }
        sub_10004D2C8(v10);
        if (v13) {
          sub_10004D2C8(v13);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_1008E7AA4(void *a1, CFTypeRef *a2)
{
  uint64_t v3 = (void *)*a1;
  uint64_t v4 = (uint64_t)(a1[1] - *a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - (void)v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  CFStringRef v22 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10004EF74(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  __int16 v19 = v10;
  v20.i64[0] = (uint64_t)&v10[8 * v4];
  __int16 v21 = &v10[8 * v9];
  sub_100056248(v20.i64[0], a2);
  uint32_t v11 = (void *)v20.i64[0];
  uint64_t v12 = v20.i64[0] + 8;
  v20.i64[1] = v20.i64[0] + 8;
  uint64_t v14 = (void *)*a1;
  int v13 = (void *)a1[1];
  if (v13 == (void *)*a1)
  {
    int64x2_t v16 = vdupq_n_s64((unint64_t)v13);
  }
  else
  {
    do
    {
      *--uint32_t v11 = 0;
      uint64_t v15 = *--v13;
      void *v11 = v15;
      *int v13 = 0;
    }
    while (v13 != v14);
    int64x2_t v16 = *(int64x2_t *)a1;
    uint64_t v12 = v20.i64[1];
  }
  *a1 = v11;
  a1[1] = v12;
  int64x2_t v20 = v16;
  CFRunLoopSourceRef v17 = (char *)a1[2];
  a1[2] = v21;
  __int16 v21 = v17;
  __int16 v19 = (char *)v16.i64[0];
  sub_100083DDC((uint64_t)&v19);
  return v12;
}

void sub_1008E7BB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100083DDC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1008E7BCC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 80) != *(void *)(a1 + 48))
  {
    uint64_t v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sUnsolicited alert response", buf, 0x16u);
    }
    return;
  }
  uint64_t v3 = *(void *)(a1 + 56);
  CFRelease(*(CFTypeRef *)(a1 + 48));
  *(void *)(v1 + 80) = 0;
  uint64_t v4 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    __int16 v59 = 1024;
    int v60 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sResolution Alert result %d", buf, 0x1Cu);
  }
  if (v3 == 3 || v3 == 1)
  {
    uint64_t v6 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sShow Resolution Information Decide Later Alert", buf, 0x16u);
    }
    int v56 = 0;
    sub_1008E61E4(*(Registry **)(v1 + 48), &off_101B0AB28, v7);
    CFStringRef v55 = 0;
    sub_1008E61E4(*(Registry **)(v1 + 48), &off_101B0AB38, v8);
    value = 0;
    uint64_t v10 = **(__CFString ***)(*(void *)(v1 + 64) + 16);
    if (SHIBYTE(v10->data) < 0) {
      uint64_t v10 = (__CFString *)v10->isa;
    }
    CFStringRef v11 = (const __CFString *)v56;
    v57 = 0;
    CFRunLoopSourceRef source = 0;
    if (ctu::cf::convert_copy((ctu::cf *)&source, (const __CFString **)v10, (const char *)0x8000100, kCFAllocatorDefault, v9))
    {
      uint64_t v12 = v57;
      v57 = source;
      *(void *)buf = v12;
      sub_1000558F4((const void **)buf);
    }
    v53 = v57;
    v57 = 0;
    sub_1000558F4((const void **)&v57);
    value = (void *)CFStringCreateWithFormat(0, 0, v11, v53);
    sub_1000558F4(&v53);
    v53 = 0;
    uint64_t v14 = **(__CFString ***)(*(void *)(v1 + 64) + 16);
    if (SHIBYTE(v14->data) < 0) {
      uint64_t v14 = (__CFString *)v14->isa;
    }
    CFStringRef v15 = v55;
    v57 = 0;
    CFRunLoopSourceRef source = 0;
    if (ctu::cf::convert_copy((ctu::cf *)&source, (const __CFString **)v14, (const char *)0x8000100, kCFAllocatorDefault, v13))
    {
      int64x2_t v16 = v57;
      v57 = source;
      *(void *)buf = v16;
      sub_1000558F4((const void **)buf);
    }
    CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v57;
    v57 = 0;
    sub_1000558F4((const void **)&v57);
    v53 = CFStringCreateWithFormat(0, 0, v15, theDict);
    sub_1000558F4((const void **)&theDict);
    v57 = 0;
    sub_1008E61E4(*(Registry **)(v1 + 48), &off_101B0AB48, v17);
    CFMutableDictionaryRef theDict = 0;
    CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(0, 3, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlertHeaderKey, value);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlertMessageKey, v53);
    CFDictionaryAddValue(theDict, kCFUserNotificationDefaultButtonTitleKey, v57);
    SInt32 error = 0;
    char v18 = CFUserNotificationCreate(0, 0.0, 0, &error, theDict);
    __int16 v19 = v18;
    *(void *)(v1 + 80) = v18;
    if (error || !v18)
    {
      v40 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s%sCould not create displayResolutionDecideLaterInformationAlert", buf, 0x16u);
        __int16 v19 = *(__CFUserNotification **)(v1 + 80);
      }
      if (v19)
      {
        CFRelease(v19);
        *(void *)(v1 + 80) = 0;
      }
    }
    else
    {
      CFRunLoopSourceRef source = CFUserNotificationCreateRunLoopSource(0, v18, (CFUserNotificationCallBack)sub_1008E6FEC, 0);
      if (source) {
        int64x2_t v20 = sub_1003F4D44;
      }
      else {
        int64x2_t v20 = 0;
      }
      if (v20)
      {
        Main = CFRunLoopGetMain();
        CFRunLoopAddSource(Main, source, kCFRunLoopCommonModes);
        CFStringRef v22 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%sdisplayResolutionDecideLaterInformationAlert shown", buf, 0x16u);
        }
      }
      else
      {
        uint64_t v42 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %s%sCould not create displayResolutionDecideLaterInformationAlert runloop", buf, 0x16u);
        }
        CFRelease(*(CFTypeRef *)(v1 + 80));
        *(void *)(v1 + 80) = 0;
      }
      sub_1003F4D4C((const void **)&source);
      if (*(void *)(v1 + 80)) {
        goto LABEL_66;
      }
    }
    v43 = *(void **)(v1 + 64);
    CFRunLoopSourceRef v44 = (std::__shared_weak_count *)v43[1];
    *(void *)buf = *v43;
    *(void *)&buf[8] = v44;
    if (v44) {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CFRunLoopSourceRef source = 0;
    uint64_t v50 = 0;
    sub_1008E65D0((void *)v1, 0, (uint64_t *)buf, (uint64_t *)&source);
    if (v44) {
      sub_10004D2C8(v44);
    }
LABEL_66:
    sub_10005717C((const void **)&theDict);
    sub_1000558F4((const void **)&v57);
    CFIndex v45 = &v53;
LABEL_76:
    sub_1000558F4(v45);
    sub_1000558F4((const void **)&value);
    sub_1000558F4((const void **)&v55);
    sub_1000558F4((const void **)&v56);
    return;
  }
  if (!v3)
  {
    CFRunLoopSourceRef v23 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%sShow Resolution Confirmation Alert", buf, 0x16u);
    }
    int v56 = 0;
    sub_1008E61E4(*(Registry **)(v1 + 48), &off_101B0AAE8, v24);
    CFStringRef v55 = 0;
    sub_1008E61E4(*(Registry **)(v1 + 48), &off_101B0AAF8, v25);
    value = 0;
    CFAllocatorRef v27 = **(__CFString ***)(*(void *)(v1 + 64) + 16);
    if (SHIBYTE(v27->data) < 0) {
      CFAllocatorRef v27 = (__CFString *)v27->isa;
    }
    CFStringRef v28 = v55;
    v57 = 0;
    CFRunLoopSourceRef source = 0;
    if (ctu::cf::convert_copy((ctu::cf *)&source, (const __CFString **)v27, (const char *)0x8000100, kCFAllocatorDefault, v26))
    {
      CFRunLoopSourceRef v29 = v57;
      v57 = source;
      *(void *)buf = v29;
      sub_1000558F4((const void **)buf);
    }
    v53 = v57;
    v57 = 0;
    sub_1000558F4((const void **)&v57);
    value = (void *)CFStringCreateWithFormat(0, 0, v28, v53);
    sub_1000558F4(&v53);
    v57 = 0;
    sub_1008E61E4(*(Registry **)(v1 + 48), &off_101B0AB08, v30);
    v53 = 0;
    sub_1008E61E4(*(Registry **)(v1 + 48), &off_101B0AB18, v31);
    CFMutableDictionaryRef theDict = 0;
    CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(0, 4, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlertHeaderKey, v56);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlertMessageKey, value);
    CFDictionaryAddValue(theDict, kCFUserNotificationDefaultButtonTitleKey, v57);
    CFDictionaryAddValue(theDict, kCFUserNotificationAlternateButtonTitleKey, v53);
    SInt32 error = 0;
    CFStringRef v32 = CFUserNotificationCreate(0, 0.0, 0, &error, theDict);
    __int16 v33 = v32;
    *(void *)(v1 + 80) = v32;
    if (error || !v32)
    {
      int v41 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I %s%sCould not create displayResolutionConfirmationAlert", buf, 0x16u);
        __int16 v33 = *(__CFUserNotification **)(v1 + 80);
      }
      if (v33)
      {
        CFRelease(v33);
        *(void *)(v1 + 80) = 0;
      }
    }
    else
    {
      CFRunLoopSourceRef source = CFUserNotificationCreateRunLoopSource(0, v32, (CFUserNotificationCallBack)sub_1008E6E88, 0);
      if (source) {
        unint64_t v34 = sub_1003F4D44;
      }
      else {
        unint64_t v34 = 0;
      }
      if (v34)
      {
        __int16 v35 = CFRunLoopGetMain();
        CFRunLoopAddSource(v35, source, kCFRunLoopCommonModes);
        CFIndex v36 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s%sdisplayResolutionConfirmationAlert shown", buf, 0x16u);
        }
      }
      else
      {
        unint64_t v46 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I %s%sCould not create displayResolutionConfirmationAlert runloop", buf, 0x16u);
        }
        CFRelease(*(CFTypeRef *)(v1 + 80));
        *(void *)(v1 + 80) = 0;
      }
      sub_1003F4D4C((const void **)&source);
      if (*(void *)(v1 + 80)) {
        goto LABEL_75;
      }
    }
    uint64_t v47 = *(void **)(v1 + 64);
    unint64_t v48 = (std::__shared_weak_count *)v47[1];
    *(void *)buf = *v47;
    *(void *)&buf[8] = v48;
    if (v48) {
      atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CFRunLoopSourceRef source = 0;
    uint64_t v50 = 0;
    sub_1008E65D0((void *)v1, 0, (uint64_t *)buf, (uint64_t *)&source);
    if (v48) {
      sub_10004D2C8(v48);
    }
LABEL_75:
    sub_10005717C((const void **)&theDict);
    sub_1000558F4(&v53);
    CFIndex v45 = (const void **)&v57;
    goto LABEL_76;
  }
  int v37 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#W %s%sUnexpected Resolution Alert result", buf, 0x16u);
  }
  unint64_t v38 = *(void **)(v1 + 64);
  unint64_t v39 = (std::__shared_weak_count *)v38[1];
  *(void *)buf = *v38;
  *(void *)&buf[8] = v39;
  if (v39) {
    atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CFRunLoopSourceRef source = 0;
  uint64_t v50 = 0;
  sub_1008E65D0((void *)v1, 0, (uint64_t *)buf, (uint64_t *)&source);
  if (v39) {
    sub_10004D2C8(v39);
  }
}

void sub_1008E8630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va5, a5);
  va_start(va4, a5);
  va_start(va3, a5);
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v10 = va_arg(va3, const void *);
  va_copy(va4, va3);
  uint64_t v12 = va_arg(va4, const void *);
  va_copy(va5, va4);
  uint64_t v14 = va_arg(va5, const void *);
  sub_10005717C((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va5);
  sub_1000558F4((const void **)va2);
  sub_1000558F4((const void **)va3);
  sub_1000558F4((const void **)va4);
  _Unwind_Resume(a1);
}

uint64_t sub_1008E8760(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1008E877C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_1008E878C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1008E879C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1008E87B8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1008E87C8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1[10] != *(void *)(a1 + 48))
  {
    uint64_t v2 = v1[5];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sUnsolicited alert response", buf, 0x16u);
    }
    return;
  }
  uint64_t v3 = *(void *)(a1 + 56);
  CFRelease(*(CFTypeRef *)(a1 + 48));
  v1[10] = 0;
  uint64_t v4 = v1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    __int16 v16 = 1024;
    int v17 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sResolution Confirmation Alert result %d", buf, 0x1Cu);
  }
  if (v3 == 3 || v3 == 1)
  {
    uint64_t v6 = (void *)v1[8];
    uint64_t v7 = (std::__shared_weak_count *)v6[1];
    *(void *)buf = *v6;
    *(void *)&buf[8] = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    if (!v3)
    {
      uint64_t v8 = (void *)v1[8];
      uint64_t v7 = (std::__shared_weak_count *)v8[1];
      *(void *)buf = *v8;
      *(void *)&buf[8] = v7;
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v8 = (void *)v1[8];
      }
      CFAllocatorRef v9 = (uint64_t *)v8[2];
      uint64_t v10 = (std::__shared_weak_count *)v9[1];
      uint64_t v13 = *v9;
      uint64_t v14 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1008E65D0(v1, 1u, (uint64_t *)buf, &v13);
      if (v10) {
        sub_10004D2C8(v10);
      }
      goto LABEL_26;
    }
    CFStringRef v11 = v1[5];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#W %s%sUnexpected Resolution Confirmation Alert result", buf, 0x16u);
    }
    uint64_t v12 = (void *)v1[8];
    uint64_t v7 = (std::__shared_weak_count *)v12[1];
    *(void *)buf = *v12;
    *(void *)&buf[8] = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  sub_1008E65D0(v1, 0, (uint64_t *)buf, &v13);
LABEL_26:
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1008E8A50(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E8A80(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1[10] == *(void *)(a1 + 48))
  {
    uint64_t v3 = *(void *)(a1 + 56);
    CFRelease(*(CFTypeRef *)(a1 + 48));
    v1[10] = 0;
    uint64_t v4 = v1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      __int16 v10 = 1024;
      int v11 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sResolution Information Decide Later Alert result %d", buf, 0x1Cu);
    }
    if ((unint64_t)(v3 - 1) <= 2)
    {
      unint64_t v5 = v1[5];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#W %s%sUnexpected Resolution Information Decide Later Alert result", buf, 0x16u);
      }
    }
    uint64_t v6 = (void *)v1[8];
    uint64_t v7 = (std::__shared_weak_count *)v6[1];
    *(void *)buf = *v6;
    *(void *)&buf[8] = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v8[0] = 0;
    v8[1] = 0;
    sub_1008E65D0(v1, 0, (uint64_t *)buf, v8);
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
  else
  {
    uint64_t v2 = v1[5];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sUnsolicited alert response", buf, 0x16u);
    }
  }
}

void sub_1008E8C6C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E8C84(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1[10] != *(void *)(a1 + 48))
  {
    uint64_t v2 = v1[5];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sUnsolicited alert response", buf, 0x16u);
    }
    return;
  }
  uint64_t v3 = *(void *)(a1 + 56);
  CFRelease(*(CFTypeRef *)(a1 + 48));
  v1[10] = 0;
  uint64_t v4 = v1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    __int16 v12 = 1024;
    int v13 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s Resolution Alert result %d", buf, 0x1Cu);
  }
  unint64_t v5 = (void *)v1[8];
  uint64_t v6 = (uint64_t *)v5[2];
  if (v5[3] - (void)v6 < 0x11uLL)
  {
    if (!v3)
    {
      uint64_t v7 = (std::__shared_weak_count *)v5[1];
      *(void *)buf = *v5;
      *(void *)&buf[8] = v7;
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v6 = *(uint64_t **)(v1[8] + 16);
      }
      uint64_t v8 = (std::__shared_weak_count *)v6[1];
      uint64_t v9 = *v6;
      __int16 v10 = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      goto LABEL_27;
    }
    uint64_t v7 = (std::__shared_weak_count *)v5[1];
    *(void *)buf = *v5;
    *(void *)&buf[8] = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    if (v3 == 2)
    {
      uint64_t v7 = (std::__shared_weak_count *)v5[1];
      *(void *)buf = *v5;
      *(void *)&buf[8] = v7;
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v6 = *(uint64_t **)(v1[8] + 16);
      }
      uint64_t v8 = (std::__shared_weak_count *)v6[3];
      uint64_t v9 = v6[2];
      __int16 v10 = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      goto LABEL_27;
    }
    if (v3 == 1)
    {
      uint64_t v7 = (std::__shared_weak_count *)v5[1];
      *(void *)buf = *v5;
      *(void *)&buf[8] = v7;
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v6 = *(uint64_t **)(v1[8] + 16);
      }
      uint64_t v8 = (std::__shared_weak_count *)v6[1];
      uint64_t v9 = *v6;
      __int16 v10 = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
LABEL_27:
      sub_1008E65D0(v1, 1u, (uint64_t *)buf, &v9);
      if (v8) {
        sub_10004D2C8(v8);
      }
      goto LABEL_32;
    }
    uint64_t v7 = (std::__shared_weak_count *)v5[1];
    *(void *)buf = *v5;
    *(void *)&buf[8] = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  uint64_t v9 = 0;
  __int16 v10 = 0;
  sub_1008E65D0(v1, 0, (uint64_t *)buf, &v9);
LABEL_32:
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1008E8F60(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E8F98(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1008E9064(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1008E913C);
  __cxa_rethrow();
}

void sub_1008E908C(_Unwind_Exception *a1)
{
}

void sub_1008E90A4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1008E90DC(uint64_t a1)
{
}

uint64_t sub_1008E90F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1008E913C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1008E916C()
{
}

void *sub_1008E9180(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A18468;
  result[1] = v3;
  return result;
}

uint64_t sub_1008E91C8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A18468;
  a2[1] = v2;
  return result;
}

void sub_1008E91F4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    __int16 v10 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#D %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1008E92C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008E9304()
{
}

void sub_1008E9314()
{
}

void *sub_1008E9328(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A184E8;
  result[1] = v3;
  return result;
}

uint64_t sub_1008E9370(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A184E8;
  a2[1] = v2;
  return result;
}

void sub_1008E939C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    __int16 v10 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#D %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1008E946C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008E94AC()
{
}

void sub_1008E94B8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const void ***)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1000558F4(v2 + 5);
    }
    operator delete(v2);
  }
}

void sub_1008E9514()
{
}

void *sub_1008E9528(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A18568;
  result[1] = v3;
  return result;
}

uint64_t sub_1008E9570(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A18568;
  a2[1] = v2;
  return result;
}

void sub_1008E959C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    __int16 v10 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#D %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1008E966C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008E96AC()
{
}

void sub_1008E96BC()
{
}

void *sub_1008E96D0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A185E8;
  result[1] = v3;
  return result;
}

uint64_t sub_1008E9718(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A185E8;
  a2[1] = v2;
  return result;
}

void sub_1008E9744(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    __int16 v10 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#D %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1008E9814(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008E9854()
{
}

void sub_1008E9864()
{
}

void *sub_1008E9878(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A18668;
  result[1] = v3;
  return result;
}

uint64_t sub_1008E98C0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A18668;
  a2[1] = v2;
  return result;
}

void sub_1008E98EC(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    __int16 v10 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#D %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1008E99BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008E99FC()
{
}

void sub_1008E9A0C()
{
}

void *sub_1008E9A20(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A186E8;
  result[1] = v3;
  return result;
}

uint64_t sub_1008E9A68(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A186E8;
  a2[1] = v2;
  return result;
}

void sub_1008E9A94(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    __int16 v10 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#D %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1008E9B64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008E9BA4()
{
}

void *sub_1008E9BB0(void *a1, void *a2, void **a3, void *a4)
{
  uint64_t v8 = operator new(0x60uLL);
  v8[1] = 0;
  uint64_t v8[2] = 0;
  *uint64_t v8 = off_101A18768;
  __int16 v9 = a4 + 3;
  __int16 v10 = (void *)a4[3];
  if (!v10)
  {
    __int16 v9 = &v15;
    goto LABEL_5;
  }
  if (v10 != a4)
  {
    CFStringRef v15 = (void *)a4[3];
LABEL_5:
    void *v9 = 0;
    goto LABEL_7;
  }
  CFStringRef v15 = v14;
  (*(void (**)(void *, void *))(*a4 + 24))(a4, v14);
LABEL_7:
  uint64_t v11 = a2[1];
  v8[3] = *a2;
  v8[4] = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  v8[5] = 0;
  v8[6] = 0;
  v8[7] = 0;
  sub_1008E9E78(v8 + 5, *a3, a3[1], ((char *)a3[1] - (char *)*a3) >> 4);
  uint64_t v12 = (uint64_t)v15;
  if (v15)
  {
    if (v15 == v14)
    {
      v8[11] = v8 + 8;
      (*(void (**)(void *))(v14[0] + 24))(v14);
      goto LABEL_14;
    }
    uint64_t v12 = (*(uint64_t (**)(void))(*v15 + 16))();
  }
  v8[11] = v12;
LABEL_14:
  uint64_t result = sub_1008E9FC4(v14);
  *a1 = v8 + 3;
  a1[1] = v8;
  return result;
}

void sub_1008E9D64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008E9DB4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A18768;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1008E9DD4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A18768;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1008E9E28(uint64_t a1)
{
  sub_1008E9FC4((void *)(a1 + 64));
  uint64_t v3 = (void **)(a1 + 40);
  sub_10005CBF0(&v3);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void *sub_1008E9E78(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1001577CC(result, a4);
    uint64_t result = sub_1008E9F00((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1008E9EE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10005CBF0(&a9);
  _Unwind_Resume(a1);
}

void *sub_1008E9F00(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v8;
  v7[3] = 1;
  uint64_t v8 = a4;
  v7[2] = &v9;
  if (a2 != a3)
  {
    do
    {
      *uint64_t v4 = *a2;
      uint64_t v5 = a2[1];
      v4[1] = v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      v4 += 2;
      a2 += 2;
    }
    while (a2 != a3);
    uint64_t v9 = v4;
  }
  sub_1008E9F8C((uint64_t)v7);
  return v4;
}

uint64_t sub_1008E9F8C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10037AA1C(a1);
  }
  return a1;
}

void *sub_1008E9FC4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1008EA048()
{
  return __cxa_atexit((void (*)(void *))sub_1008E4260, &qword_101B13E40, (void *)&_mh_execute_header);
}

BOOL sub_1008EA06C(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[127];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[127];
  }
  else {
    uint64_t v3 = *((void *)a1 + 14);
  }
  uint64_t v4 = a2[127];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 14);
  }
  if (v3 != v4) {
    return 0;
  }
  uint64_t v8 = (const void **)(a1 + 104);
  if (v5 >= 0) {
    uint64_t v9 = a2 + 104;
  }
  else {
    uint64_t v9 = (unsigned __int8 *)*((void *)a2 + 13);
  }
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*v8, v9, *((void *)a1 + 14))) {
      return 0;
    }
  }
  else if (a1[127])
  {
    while (*(unsigned __int8 *)v8 == *v9)
    {
      uint64_t v8 = (const void **)((char *)v8 + 1);
      ++v9;
      if (!--v2) {
        goto LABEL_16;
      }
    }
    return 0;
  }
LABEL_16:
  uint64_t v10 = a1[55];
  if ((v10 & 0x80u) == 0) {
    uint64_t v11 = a1[55];
  }
  else {
    uint64_t v11 = *((void *)a1 + 5);
  }
  uint64_t v12 = a2[55];
  int v13 = (char)v12;
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *((void *)a2 + 5);
  }
  if (v11 != v12) {
    return 0;
  }
  uint64_t v14 = (const void **)(a1 + 32);
  if (v13 >= 0) {
    CFStringRef v15 = a2 + 32;
  }
  else {
    CFStringRef v15 = (unsigned __int8 *)*((void *)a2 + 4);
  }
  if ((v10 & 0x80) != 0)
  {
    if (memcmp(*v14, v15, *((void *)a1 + 5))) {
      return 0;
    }
  }
  else if (a1[55])
  {
    while (*(unsigned __int8 *)v14 == *v15)
    {
      uint64_t v14 = (const void **)((char *)v14 + 1);
      ++v15;
      if (!--v10) {
        goto LABEL_31;
      }
    }
    return 0;
  }
LABEL_31:
  if (a1[177] != a2[177] || *a1 != *a2) {
    return 0;
  }
  uint64_t v16 = a1[151];
  if ((v16 & 0x80u) == 0) {
    uint64_t v17 = a1[151];
  }
  else {
    uint64_t v17 = *((void *)a1 + 17);
  }
  uint64_t v18 = a2[151];
  int v19 = (char)v18;
  if ((v18 & 0x80u) != 0) {
    uint64_t v18 = *((void *)a2 + 17);
  }
  if (v17 != v18) {
    return 0;
  }
  int64x2_t v20 = (const void **)(a1 + 128);
  if (v19 >= 0) {
    __int16 v21 = a2 + 128;
  }
  else {
    __int16 v21 = (unsigned __int8 *)*((void *)a2 + 16);
  }
  if ((v16 & 0x80) != 0)
  {
    if (memcmp(*v20, v21, *((void *)a1 + 17))) {
      return 0;
    }
  }
  else if (a1[151])
  {
    while (*(unsigned __int8 *)v20 == *v21)
    {
      int64x2_t v20 = (const void **)((char *)v20 + 1);
      ++v21;
      if (!--v16) {
        goto LABEL_48;
      }
    }
    return 0;
  }
LABEL_48:
  uint64_t v22 = a1[79];
  if ((v22 & 0x80u) == 0) {
    uint64_t v23 = a1[79];
  }
  else {
    uint64_t v23 = *((void *)a1 + 8);
  }
  uint64_t v24 = a2[79];
  int v25 = (char)v24;
  if ((v24 & 0x80u) != 0) {
    uint64_t v24 = *((void *)a2 + 8);
  }
  if (v23 != v24) {
    return 0;
  }
  CFAllocatorRef v26 = (const void **)(a1 + 56);
  if (v25 >= 0) {
    CFAllocatorRef v27 = a2 + 56;
  }
  else {
    CFAllocatorRef v27 = (unsigned __int8 *)*((void *)a2 + 7);
  }
  if ((v22 & 0x80) != 0)
  {
    if (!memcmp(*v26, v27, *((void *)a1 + 8))) {
      goto LABEL_65;
    }
    return 0;
  }
  if (a1[79])
  {
    while (*(unsigned __int8 *)v26 == *v27)
    {
      CFAllocatorRef v26 = (const void **)((char *)v26 + 1);
      ++v27;
      if (!--v22) {
        goto LABEL_65;
      }
    }
    return 0;
  }
LABEL_65:
  BOOL result = sub_10001D294(a1 + 80, a2 + 80);
  if (result)
  {
    BOOL result = sub_10001D294(a1 + 152, a2 + 152);
    if (result) {
      return a1[176] == a2[176];
    }
  }
  return result;
}

void sub_1008EA2D8(unsigned __int8 *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v42 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v42 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v42 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v42 = v6;
LABEL_9:
  xpc_release(v5);
  if ((a1[127] & 0x80u) == 0) {
    __int16 v7 = (const char *)(a1 + 104);
  }
  else {
    __int16 v7 = (const char *)*((void *)a1 + 13);
  }
  xpc_object_t v40 = xpc_string_create(v7);
  if (!v40) {
    xpc_object_t v40 = xpc_null_create();
  }
  unint64_t v38 = &v42;
  unint64_t v39 = "device_name";
  sub_100035E70((uint64_t)&v38, &v40, &v41);
  xpc_release(v41);
  xpc_object_t v41 = 0;
  xpc_release(v40);
  xpc_object_t v40 = 0;
  if ((a1[55] & 0x80u) == 0) {
    uint64_t v8 = (const char *)(a1 + 32);
  }
  else {
    uint64_t v8 = (const char *)*((void *)a1 + 4);
  }
  xpc_object_t v36 = xpc_string_create(v8);
  if (!v36) {
    xpc_object_t v36 = xpc_null_create();
  }
  unint64_t v38 = &v42;
  unint64_t v39 = "csn";
  sub_100035E70((uint64_t)&v38, &v36, &v37);
  xpc_release(v37);
  xpc_object_t v37 = 0;
  xpc_release(v36);
  xpc_object_t v36 = 0;
  if ((a1[79] & 0x80u) == 0) {
    uint64_t v9 = (const char *)(a1 + 56);
  }
  else {
    uint64_t v9 = (const char *)*((void *)a1 + 7);
  }
  xpc_object_t object = xpc_string_create(v9);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  unint64_t v38 = &v42;
  unint64_t v39 = "imei";
  sub_100035E70((uint64_t)&v38, &object, &v35);
  xpc_release(v35);
  xpc_object_t v35 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  if ((a1[103] & 0x80u) == 0) {
    uint64_t v10 = (const char *)(a1 + 80);
  }
  else {
    uint64_t v10 = (const char *)*((void *)a1 + 10);
  }
  xpc_object_t v32 = xpc_string_create(v10);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  unint64_t v38 = &v42;
  unint64_t v39 = "meid";
  sub_100035E70((uint64_t)&v38, &v32, &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  uint64_t v12 = (ctu::rest::detail *)a1[177];
  int v13 = "kInactive";
  if (v12 == 1) {
    int v13 = "kConfiguring";
  }
  if (v12 == 2) {
    uint64_t v14 = "kActive";
  }
  else {
    uint64_t v14 = v13;
  }
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v30, v12, (unint64_t)v14, v11);
  unint64_t v38 = &v42;
  unint64_t v39 = "device_state";
  sub_100035E70((uint64_t)&v38, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v30);
  xpc_object_t v30 = 0;
  uint64_t v16 = (ctu::rest::detail *)*a1;
  uint64_t v17 = "kUnknown";
  if (v16 == 1) {
    uint64_t v17 = "kDefault";
  }
  if (v16 == 2) {
    uint64_t v18 = "kTinker";
  }
  else {
    uint64_t v18 = v17;
  }
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v28, v16, (unint64_t)v18, v15);
  unint64_t v38 = &v42;
  unint64_t v39 = "mode";
  sub_100035E70((uint64_t)&v38, &v28, &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
  if ((a1[151] & 0x80u) == 0) {
    int v19 = (const char *)(a1 + 128);
  }
  else {
    int v19 = (const char *)*((void *)a1 + 16);
  }
  xpc_object_t v26 = xpc_string_create(v19);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  unint64_t v38 = &v42;
  unint64_t v39 = "os_version";
  sub_100035E70((uint64_t)&v38, &v26, &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if ((a1[175] & 0x80u) == 0) {
    int64x2_t v20 = (const char *)(a1 + 152);
  }
  else {
    int64x2_t v20 = (const char *)*((void *)a1 + 19);
  }
  xpc_object_t v24 = xpc_string_create(v20);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  unint64_t v38 = &v42;
  unint64_t v39 = "model_identifier";
  sub_100035E70((uint64_t)&v38, &v24, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_object_t v22 = xpc_BOOL_create(a1[176]);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  unint64_t v38 = &v42;
  unint64_t v39 = "cellular_supported";
  sub_100035E70((uint64_t)&v38, &v22, &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_object_t v21 = v42;
  *a2 = v42;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v42);
}

void sub_1008EA7A4(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1008EA7BC(unsigned __int8 **a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  xpc_object_t v6 = *a1;
  __int16 v7 = a1[1];
  while (v6 != v7)
  {
    sub_1008EA2D8(v6, &value);
    xpc_object_t v8 = value;
    xpc_array_append_value(v5, value);
    xpc_release(v8);
    v6 += 184;
  }
  *a2 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_1008EA8D8(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_1008EA904(uint64_t *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  uint64_t v5 = *a1;
  for (uint64_t i = a1[1]; i != v5; uint64_t i = sub_1001509E4(i - 184))
    ;
  a1[1] = v5;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_object_t object = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    sub_100048BF4(&v40, &object, 0);
    xpc_release(object);
    xpc_object_t object = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    xpc_object_t v36 = v3;
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v39, &object, count);
    xpc_release(object);
    for (j = v41; j != v39[1] || v40 != v39[0]; j = ++v41)
    {
      v38[0] = &v40;
      v38[1] = j;
      unint64_t v8 = a1[1];
      unint64_t v9 = a1[2];
      if (v8 >= v9)
      {
        unint64_t v11 = 0xD37A6F4DE9BD37A7 * ((uint64_t)(v8 - *a1) >> 3);
        unint64_t v12 = v11 + 1;
        if (v11 + 1 > 0x1642C8590B21642) {
          sub_10006A748();
        }
        unint64_t v13 = 0xD37A6F4DE9BD37A7 * ((uint64_t)(v9 - *a1) >> 3);
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0xB21642C8590B21) {
          unint64_t v14 = 0x1642C8590B21642;
        }
        else {
          unint64_t v14 = v12;
        }
        unint64_t v46 = a1 + 2;
        if (v14) {
          CFStringRef v15 = (char *)sub_100150DA4((uint64_t)(a1 + 2), v14);
        }
        else {
          CFStringRef v15 = 0;
        }
        uint64_t v16 = &v15[184 * v11];
        xpc_object_t object = v15;
        v43 = v16;
        CFIndex v45 = &v15[184 * v14];
        *(_OWORD *)uint64_t v16 = 0u;
        *((_OWORD *)v16 + 1) = 0u;
        *((_OWORD *)v16 + 2) = 0u;
        *((_OWORD *)v16 + 3) = 0u;
        *((_OWORD *)v16 + 4) = 0u;
        *((_OWORD *)v16 + 5) = 0u;
        *((_OWORD *)v16 + 6) = 0u;
        *((_OWORD *)v16 + 7) = 0u;
        *((_OWORD *)v16 + 8) = 0u;
        *((_OWORD *)v16 + 9) = 0u;
        *((_OWORD *)v16 + 10) = 0u;
        *((void *)v16 + 22) = 0;
        CFRunLoopSourceRef v44 = (char *)(v16 + 184);
        sub_100150D2C(a1, &object);
        uint64_t v10 = a1[1];
        sub_100150EDC((uint64_t)&object);
      }
      else
      {
        *(void *)(v8 + 176) = 0;
        *(_OWORD *)(v8 + 144) = 0u;
        *(_OWORD *)(v8 + 160) = 0u;
        *(_OWORD *)(v8 + 112) = 0u;
        *(_OWORD *)(v8 + 128) = 0u;
        *(_OWORD *)(v8 + 80) = 0u;
        *(_OWORD *)(v8 + 96) = 0u;
        *(_OWORD *)(v8 + 48) = 0u;
        *(_OWORD *)(v8 + 64) = 0u;
        *(_OWORD *)(v8 + 16) = 0u;
        *(_OWORD *)(v8 + 32) = 0u;
        *(_OWORD *)unint64_t v8 = 0u;
        uint64_t v10 = v8 + 184;
        a1[1] = v8 + 184;
      }
      a1[1] = v10;
      sub_1000492E0((uint64_t)v38, &v37);
      xpc_object_t v17 = v37;
      xpc_object_t v50 = v37;
      if (v37 && xpc_get_type(v37) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v17);
        xpc_object_t v18 = v50;
      }
      else
      {
        xpc_object_t v18 = xpc_null_create();
        xpc_object_t v50 = v18;
      }
      if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v47 = &v50;
        unint64_t v48 = "device_name";
        sub_100048BAC((uint64_t)&v47, &v49);
        xpc_object_t object = 0;
        v43 = 0;
        CFRunLoopSourceRef v44 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v44) < 0) {
          operator delete(object);
        }
        int v19 = (void **)(v10 - 80);
        if (*(char *)(v10 - 57) < 0) {
          operator delete(*v19);
        }
        long long v20 = *(_OWORD *)v51;
        *(void *)(v10 - 64) = v52;
        *(_OWORD *)int v19 = v20;
        xpc_release(v49);
        uint64_t v47 = &v50;
        unint64_t v48 = "csn";
        sub_100048BAC((uint64_t)&v47, &v49);
        xpc_object_t object = 0;
        v43 = 0;
        CFRunLoopSourceRef v44 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v44) < 0) {
          operator delete(object);
        }
        xpc_object_t v21 = (void **)(v10 - 152);
        if (*(char *)(v10 - 129) < 0) {
          operator delete(*v21);
        }
        long long v22 = *(_OWORD *)v51;
        *(void *)(v10 - 136) = v52;
        *(_OWORD *)xpc_object_t v21 = v22;
        xpc_release(v49);
        uint64_t v47 = &v50;
        unint64_t v48 = "imei";
        sub_100048BAC((uint64_t)&v47, &v49);
        xpc_object_t object = 0;
        v43 = 0;
        CFRunLoopSourceRef v44 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v44) < 0) {
          operator delete(object);
        }
        xpc_object_t v23 = (void **)(v10 - 128);
        if (*(char *)(v10 - 105) < 0) {
          operator delete(*v23);
        }
        long long v24 = *(_OWORD *)v51;
        *(void *)(v10 - 112) = v52;
        *(_OWORD *)xpc_object_t v23 = v24;
        xpc_release(v49);
        uint64_t v47 = &v50;
        unint64_t v48 = "meid";
        sub_100048BAC((uint64_t)&v47, &v49);
        xpc_object_t object = 0;
        v43 = 0;
        CFRunLoopSourceRef v44 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v44) < 0) {
          operator delete(object);
        }
        xpc_object_t v25 = (void **)(v10 - 104);
        if (*(char *)(v10 - 81) < 0) {
          operator delete(*v25);
        }
        long long v26 = *(_OWORD *)v51;
        *(void *)(v10 - 88) = v52;
        *(_OWORD *)xpc_object_t v25 = v26;
        xpc_release(v49);
        xpc_object_t object = &v50;
        v43 = "device_state";
        sub_100048BAC((uint64_t)&object, v51);
        xpc_type_t type = xpc_get_type(*(xpc_object_t *)v51);
        if (type == (xpc_type_t)&_xpc_type_string)
        {
          LOBYTE(v47) = *(unsigned char *)(v10 - 7);
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v47, v51, v28);
          *(unsigned char *)(v10 - 7) = (_BYTE)v47;
        }
        else if (type == (xpc_type_t)&_xpc_type_BOOL {
               || type == (xpc_type_t)&_xpc_type_int64
        }
               || type == (xpc_type_t)&_xpc_type_uint64)
        {
          *(unsigned char *)(v10 - 7) = xpc::dyn_cast_or_default((xpc *)v51, 0, (uint64_t)v28);
        }
        xpc_release(*(xpc_object_t *)v51);
        xpc_object_t object = &v50;
        v43 = "mode";
        sub_100048BAC((uint64_t)&object, v51);
        xpc_type_t v29 = xpc_get_type(*(xpc_object_t *)v51);
        if (v29 == (xpc_type_t)&_xpc_type_string)
        {
          LOBYTE(v47) = *(unsigned char *)(v10 - 184);
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v47, v51, v30);
          *(unsigned char *)(v10 - 184) = (_BYTE)v47;
        }
        else if (v29 == (xpc_type_t)&_xpc_type_BOOL {
               || v29 == (xpc_type_t)&_xpc_type_int64
        }
               || v29 == (xpc_type_t)&_xpc_type_uint64)
        {
          *(unsigned char *)(v10 - 184) = xpc::dyn_cast_or_default((xpc *)v51, 0, (uint64_t)v30);
        }
        xpc_release(*(xpc_object_t *)v51);
        uint64_t v47 = &v50;
        unint64_t v48 = "os_version";
        sub_100048BAC((uint64_t)&v47, &v49);
        xpc_object_t object = 0;
        v43 = 0;
        CFRunLoopSourceRef v44 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v44) < 0) {
          operator delete(object);
        }
        xpc_object_t v31 = (void **)(v10 - 56);
        if (*(char *)(v10 - 33) < 0) {
          operator delete(*v31);
        }
        long long v32 = *(_OWORD *)v51;
        *(void *)(v10 - 40) = v52;
        *(_OWORD *)xpc_object_t v31 = v32;
        xpc_release(v49);
        uint64_t v47 = &v50;
        unint64_t v48 = "model_identifier";
        sub_100048BAC((uint64_t)&v47, &v49);
        xpc_object_t object = 0;
        v43 = 0;
        CFRunLoopSourceRef v44 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v44) < 0) {
          operator delete(object);
        }
        xpc_object_t v33 = (void **)(v10 - 32);
        if (*(char *)(v10 - 9) < 0) {
          operator delete(*v33);
        }
        long long v34 = *(_OWORD *)v51;
        *(void *)(v10 - 16) = v52;
        *(_OWORD *)xpc_object_t v33 = v34;
        xpc_release(v49);
        xpc_object_t object = &v50;
        v43 = "cellular_supported";
        sub_100048BAC((uint64_t)&object, v51);
        *(unsigned char *)(v10 - 8) = xpc::dyn_cast_or_default((xpc *)v51, 0, v35);
        xpc_release(*(xpc_object_t *)v51);
      }
      xpc_release(v50);
      xpc_release(v37);
    }
    xpc_release(v40);
    xpc_release(v40);
    xpc_object_t v3 = v36;
  }
  xpc_release(v3);
}

void sub_1008EB01C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t a11, uint64_t a12, uint64_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, xpc_object_t object, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,xpc_object_t a28)
{
}

double sub_1008EB218@<D0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v4 = *a1;
  if (*a1 != v3)
  {
    uint64_t v4 = *a1;
    while (*(unsigned char *)(v4 + 177) != 2)
    {
      v4 += 184;
      if (v4 == v3) {
        goto LABEL_9;
      }
    }
  }
  if (v4 != v3)
  {
    uint64_t v5 = a2;
    uint64_t v2 = v4;
LABEL_8:
    sub_100150AFC(v5, v2);
    return result;
  }
LABEL_9:
  if (v2 != v3)
  {
    while (*(unsigned char *)(v2 + 177) != 1)
    {
      v2 += 184;
      if (v2 == v3) {
        goto LABEL_15;
      }
    }
  }
  if (v2 != v3)
  {
    uint64_t v5 = a2;
    goto LABEL_8;
  }
LABEL_15:
  *(unsigned char *)a2 = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 162) = 0u;
  return result;
}

void sub_1008EB2C8(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v15 = *(void *)(a2 + 16);
  }
  char v7 = HIBYTE(v15);
  if (v5 != v6)
  {
    if (v15 >= 0) {
      unint64_t v8 = (void *)HIBYTE(v15);
    }
    else {
      unint64_t v8 = __p[1];
    }
    if (v15 >= 0) {
      unint64_t v9 = __p;
    }
    else {
      unint64_t v9 = (void **)__p[0];
    }
    do
    {
      uint64_t v10 = *(unsigned __int8 *)(v5 + 55);
      if ((v10 & 0x80u) == 0) {
        unint64_t v11 = (void *)*(unsigned __int8 *)(v5 + 55);
      }
      else {
        unint64_t v11 = *(void **)(v5 + 40);
      }
      if (v11 == v8)
      {
        if ((v10 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v5 + 32), v9, *(void *)(v5 + 40))) {
            goto LABEL_24;
          }
        }
        else
        {
          if (!*(unsigned char *)(v5 + 55)) {
            goto LABEL_24;
          }
          uint64_t v12 = 0;
          while (*(unsigned __int8 *)(v5 + v12 + 32) == *((unsigned __int8 *)v9 + v12))
          {
            if (v10 == ++v12) {
              goto LABEL_24;
            }
          }
        }
      }
      v5 += 184;
    }
    while (v5 != v6);
    uint64_t v5 = v6;
  }
LABEL_24:
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  if (v5 == a1[1])
  {
    sub_100058DB0(a3, (char *)&unk_10163C59D);
  }
  else if (*(char *)(v5 + 127) < 0)
  {
    sub_10004FC84(a3, *(void **)(v5 + 104), *(void *)(v5 + 112));
  }
  else
  {
    long long v13 = *(_OWORD *)(v5 + 104);
    a3[2] = *(void *)(v5 + 120);
    *(_OWORD *)a3 = v13;
  }
}

void sub_1008EB424()
{
}

void sub_1008EB498()
{
}

uint64_t sub_1008EB4BC(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v10, kCtLoggingSystemName, "rm.mdl");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v10);
  ctu::OsLogLogger::OsLogLogger(v6, (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_101A187B8;
  *(void *)(a1 + 32) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 40) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 48) = *a3;
  uint64_t v8 = a3[1];
  *(void *)(a1 + 56) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 16), 1uLL, memory_order_relaxed);
  }
  *(_WORD *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 66) = 1;
  *(_DWORD *)(a1 + 68) = 2;
  *(unsigned char *)(a1 + 72) = 8;
  *(_DWORD *)(a1 + 73) = 0;
  return a1;
}

void sub_1008EB5DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  RadioModelInterface::~RadioModelInterface(v2);
  _Unwind_Resume(a1);
}

void sub_1008EB610(void *a1)
{
  *a1 = off_101A187B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  RadioModelInterface::~RadioModelInterface((RadioModelInterface *)a1);
}

void sub_1008EB690(void *a1)
{
  sub_1008EB610(a1);

  operator delete();
}

void sub_1008EB6C8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v3 = *(char *)(a1 + 73);
    if (v3 > 4) {
      uint64_t v4 = "???";
    }
    else {
      uint64_t v4 = off_101A18918[v3];
    }
    unint64_t v5 = *(char *)(a1 + 74);
    if (v5 > 4) {
      uint64_t v6 = "???";
    }
    else {
      uint64_t v6 = off_101A18918[v5];
    }
    int v7 = 136315650;
    uint64_t v8 = v4;
    __int16 v9 = 2080;
    OsLogContext v10 = v6;
    __int16 v11 = 2080;
    uint64_t v12 = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Clearing: Current: %s, Pending: %s and Operating Mode: %s", (uint8_t *)&v7, 0x20u);
  }
  *(_WORD *)(a1 + 72) = 8;
  *(unsigned char *)(a1 + 74) = 0;
}

void sub_1008EB7D4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 136315394;
    uint64_t v14 = printers::asString((printers *)(a1 + 64), v3);
    __int16 v15 = 2080;
    uint64_t v16 = printers::asString((printers *)(a1 + 65), v4);
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Radio Intialized: %s, Ticket Available: %s", (uint8_t *)&v13, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = asString();
    uint64_t v6 = asString();
    int v13 = 136315394;
    uint64_t v14 = v5;
    __int16 v15 = 2080;
    uint64_t v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Current Modes: Operating %s & Airplane Mode: %s", (uint8_t *)&v13, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v7 = *(char *)(a1 + 73);
    if (v7 > 4) {
      uint64_t v8 = "???";
    }
    else {
      uint64_t v8 = off_101A18918[v7];
    }
    unint64_t v9 = *(char *)(a1 + 74);
    if (v9 > 4) {
      OsLogContext v10 = "???";
    }
    else {
      OsLogContext v10 = off_101A18918[v9];
    }
    int v13 = 136315394;
    uint64_t v14 = (uint64_t)v8;
    __int16 v15 = 2080;
    uint64_t v16 = (uint64_t)v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Operating Mode Requests: Current %s & Pending %s", (uint8_t *)&v13, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = printers::asString((printers *)(a1 + 75), v11);
    int v13 = 136315138;
    uint64_t v14 = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Send Airplane Mode Notification: %s", (uint8_t *)&v13, 0xCu);
  }
}

uint64_t sub_1008EB9DC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 64) = a2;
  return result;
}

uint64_t sub_1008EB9E4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 65) = a2;
  return result;
}

atomic_uint **sub_1008EB9EC(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I baseband on", v4, 2u);
  }
  sub_100477910(&event::baseband::on[3]);
  uint64_t v2 = (uint64_t *)sub_100161CDC(&event::baseband::on[1]);
  return sub_10035414C(v2);
}

atomic_uint **sub_1008EBA68(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I baseband off (reset)", v4, 2u);
  }
  sub_100477910(&event::baseband::reset[3]);
  uint64_t v2 = (uint64_t *)sub_100161CDC(&event::baseband::reset[1]);
  return sub_10035414C(v2);
}

atomic_uint **sub_1008EBAE4(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I baseband off (shutdown)", v4, 2u);
  }
  sub_100477910(&event::baseband::off[3]);
  uint64_t v2 = (uint64_t *)sub_100161CDC(&event::baseband::off[1]);
  return sub_10035414C(v2);
}

uint64_t sub_1008EBB60(uint64_t a1, int a2)
{
  int v2 = a2;
  unint64_t v4 = *(char *)(a1 + 72);
  if (v4 > 8) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = dword_1015082D4[v4];
  }
  *(unsigned char *)(a1 + 72) = a2;
  uint64_t v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Baseband %s mode", buf, 0xCu);
    int v2 = *(unsigned __int8 *)(a1 + 72);
  }
  switch(v2)
  {
    case 0:
      sub_100477910(&event::radio::on[3]);
      v57 = (uint64_t *)sub_100161CDC(&event::radio::on[1]);
      sub_10035414C(v57);
      sub_1002583FC();
      if (*(unsigned char *)(a1 + 75)) {
        sub_1008EC73C(a1, 0, (uint64_t *)*(unsigned __int8 *)(a1 + 75));
      }
      else {
        *(unsigned char *)(a1 + 75) = 1;
      }
      uint64_t v5 = 2;
      break;
    case 1:
    case 7:
      sub_100477910(&event::radio::off[3]);
      unint64_t v7 = (uint64_t *)sub_100161CDC(&event::radio::off[1]);
      sub_10035414C(v7);
      if (*(unsigned char *)(a1 + 75))
      {
        sub_1008EC73C(a1, 1, (uint64_t *)*(unsigned __int8 *)(a1 + 75));
        goto LABEL_9;
      }
      uint64_t v5 = 0;
      *(unsigned char *)(a1 + 75) = 1;
      break;
    case 2:
    case 3:
    case 5:
LABEL_9:
      uint64_t v5 = 0;
      break;
    case 6:
      uint64_t v5 = 1;
      break;
    default:
      break;
  }
  char v8 = *(unsigned char *)(a1 + 72);
  *(void *)&long long v85 = 0;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  *(_OWORD *)buf = 0u;
  long long v70 = 0u;
  sub_10004DE24((uint64_t)buf);
  unint64_t v9 = (const char *)asString();
  size_t v10 = strlen(v9);
  sub_10004B96C(buf, (uint64_t)v9, v10);
  sub_10004BC98((uint64_t)&buf[8], __p);
  sub_1001AA668(&event::baseband::operatingMode[3], (uint64_t *)__p);
  if (SBYTE7(v66) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v74) < 0) {
    operator delete(*((void **)&v73 + 1));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  __int16 v11 = (uint64_t *)sub_1004F7D50(&event::baseband::operatingMode[1]);
  char v64 = v8;
  long long v63 = 0uLL;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  *(_OWORD *)buf = 0u;
  long long v70 = 0u;
  uint64_t v12 = (pthread_mutex_t *)sub_100060E64(v11 + 3);
  sub_100061F70(buf, v12);
  uint64_t v13 = v11[1];
  if (v13)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v13 + 8), memory_order_acquire) == 1) {
      sub_1004F83C0(v11, buf, 0, 1);
    }
    uint64_t v14 = *v11;
    uint64_t v15 = v11[1];
    if (v15) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v15 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v14 = *v11;
  }
  long long v16 = v63;
  *(void *)&long long v63 = v14;
  *((void *)&v63 + 1) = v15;
  *(_OWORD *)long long __p = v16;
  sub_10000A740((atomic_uint **)&__p[1]);
  sub_10000A6C8(*((pthread_mutex_t **)&v80 + 1));
  sub_10000A5F8(buf);
  long long v82 = 0u;
  long long v83 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  *(_OWORD *)buf = 0u;
  *(void *)&long long v84 = 0;
  *((void *)&v84 + 1) = 10;
  *(void *)&long long v85 = &buf[8];
  *((void *)&v85 + 1) = 0;
  uint64_t v87 = 0;
  uint64_t v88 = 0;
  v86 = &v64;
  xpc_object_t v17 = (uint64_t *)sub_1004F801C((uint64_t *)&v63);
  v62[0] = buf;
  v62[1] = v11;
  v62[2] = sub_1004F9380(v17);
  uint64_t v18 = sub_1004F801C((uint64_t *)&v63);
  sub_100060EA8((uint64_t *)(v18 + 16));
  int v19 = (uint64_t *)sub_1004F801C((uint64_t *)&v63);
  uint64_t v20 = *(void *)(sub_1004F9380(v19) + 8);
  xpc_object_t v21 = (uint64_t *)sub_1004F801C((uint64_t *)&v63);
  uint64_t v22 = sub_1004F9380(v21);
  *(void *)v67 = v20;
  *(void *)&v67[8] = v22;
  *(void *)&long long v68 = buf;
  *((void *)&v68 + 1) = v22;
  sub_1008EDDF4((uint64_t *)v67);
  xpc_object_t v23 = (uint64_t *)sub_1004F801C((uint64_t *)&v63);
  uint64_t v24 = sub_1004F9380(v23);
  xpc_object_t v25 = (uint64_t *)sub_1004F801C((uint64_t *)&v63);
  v58 = (void *)v24;
  uint64_t v59 = sub_1004F9380(v25);
  int v60 = buf;
  uint64_t v61 = v59;
  sub_1008EDDF4((uint64_t *)&v58);
  *(_OWORD *)long long __p = *(_OWORD *)v67;
  long long v66 = v68;
  long long v26 = v58;
  xpc_object_t v27 = *(uint64_t **)v67;
  if (*(void **)v67 != v58)
  {
    xpc_object_t v28 = (unsigned char *)v66;
    BOOL v29 = *(unsigned char *)v66 == 0;
    do
    {
      if (v29)
      {
        uint64_t v30 = sub_1004F8060(v27 + 2);
        uint64_t v31 = sub_1004F8B10((uint64_t *)(v30 + 32));
        sub_1004F9A98((void *)(v31 + 24));
        if (!*v28) {
          *xpc_object_t v28 = 1;
        }
      }
      if (!*(unsigned char *)v66) {
        __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
      }
      __p[0] = *((void **)__p[0] + 1);
      sub_1008EDDF4((uint64_t *)__p);
      xpc_object_t v28 = (unsigned char *)v66;
      if (*(unsigned char *)v66) {
        *(unsigned char *)long long v66 = 0;
      }
      xpc_object_t v27 = (uint64_t *)__p[0];
      BOOL v29 = 1;
    }
    while (__p[0] != v26);
  }
  sub_1008EE170(v62);
  sub_1008EE338((uint64_t)buf);
  sub_10000A740((atomic_uint **)&v63 + 1);
  v86 = 0;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  *(_OWORD *)buf = 0u;
  sub_10004BD84((uint64_t)buf);
  long long v32 = sub_10004B96C(&v70, (uint64_t)"\n=== Operating Mode Status ===", 30);
  xpc_object_t v33 = sub_10004B96C(v32, (uint64_t)"\n Operating Mode = ", 19);
  long long v34 = (const char *)asString();
  size_t v35 = strlen(v34);
  xpc_object_t v36 = sub_10004B96C(v33, (uint64_t)v34, v35);
  xpc_object_t v37 = sub_10004B96C(v36, (uint64_t)"\n Current Transition = ", 23);
  unint64_t v38 = *(char *)(a1 + 73);
  if (v38 > 4) {
    unint64_t v39 = "???";
  }
  else {
    unint64_t v39 = off_101A18918[v38];
  }
  size_t v40 = strlen(v39);
  xpc_object_t v41 = sub_10004B96C(v37, (uint64_t)v39, v40);
  xpc_object_t v42 = sub_10004B96C(v41, (uint64_t)"\n Pending Transition = ", 23);
  unint64_t v43 = *(char *)(a1 + 74);
  if (v43 > 4) {
    CFRunLoopSourceRef v44 = "???";
  }
  else {
    CFRunLoopSourceRef v44 = off_101A18918[v43];
  }
  size_t v45 = strlen(v44);
  sub_10004B96C(v42, (uint64_t)v44, v45);
  switch(*(unsigned char *)(a1 + 73))
  {
    case 0:
      goto LABEL_51;
    case 1:
      int v46 = 0;
      goto LABEL_43;
    case 2:
      int v46 = 1;
      goto LABEL_43;
    case 3:
      int v46 = 6;
      goto LABEL_43;
    case 4:
      int v46 = 7;
      goto LABEL_43;
    default:
      int v46 = 8;
LABEL_43:
      if (v46 != *(unsigned __int8 *)(a1 + 72))
      {
        xpc_object_t v49 = "\n Current Transition: Waiting for mode change";
        uint64_t v50 = 45;
        goto LABEL_50;
      }
      *(unsigned char *)(a1 + 73) = 0;
      sub_10004B96C(&v70, (uint64_t)"\n Current Transition: Settled", 29);
      if (!*(unsigned char *)(a1 + 74)) {
        goto LABEL_51;
      }
      sub_10004B96C(&v70, (uint64_t)"\n Pending Transition: ", 22);
      unsigned int v47 = *(unsigned __int8 *)(a1 + 74);
      unint64_t v48 = 0x706010008uLL >> (8 * v47);
      if (v47 >= 5) {
        LOBYTE(v48) = 8;
      }
      if ((v48 & 0xF) == *(unsigned char *)(a1 + 72))
      {
        *(unsigned char *)(a1 + 74) = 0;
        xpc_object_t v49 = "Settled";
        uint64_t v50 = 7;
LABEL_50:
        sub_10004B96C(&v70, (uint64_t)v49, v50);
        goto LABEL_51;
      }
      CFStringRef v55 = "Going Online";
      xpc_object_t v49 = "Settled";
      uint64_t v56 = 12;
      uint64_t v50 = 7;
      switch(*(unsigned char *)(a1 + 74))
      {
        case 0:
          goto LABEL_50;
        case 1:
          goto LABEL_71;
        case 2:
          CFStringRef v55 = "Going Low Power";
          goto LABEL_70;
        case 3:
          CFStringRef v55 = "Going Camp Only";
LABEL_70:
          uint64_t v56 = 15;
          goto LABEL_71;
        case 4:
          CFStringRef v55 = "Going Stewie";
          uint64_t v56 = 12;
LABEL_71:
          sub_10004B96C(&v70, (uint64_t)v55, v56);
          break;
        default:
          break;
      }
      sub_1008ECD5C(a1, *(unsigned __int8 *)(a1 + 74));
      *(unsigned char *)(a1 + 74) = 0;
LABEL_51:
      uint64_t v51 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        sub_10004BC98((uint64_t)&v70 + 8, __p);
        uint64_t v52 = (SBYTE7(v66) & 0x80u) == 0 ? __p : (void **)__p[0];
        *(_DWORD *)v67 = 136446210;
        *(void *)&v67[4] = v52;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I %{public}s\n===  ===  ===  ===  ===  ===  ===", v67, 0xCu);
        if (SBYTE7(v66) < 0) {
          operator delete(__p[0]);
        }
      }
      *(void *)&long long v70 = v53;
      if (SHIBYTE(v75) < 0) {
        operator delete(*((void **)&v74 + 1));
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      std::ios::~ios();
      return v5;
  }
}

void sub_1008EC584(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x1008EC6ECLL);
}

void sub_1008EC5C0()
{
}

void sub_1008EC5C8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void (__cdecl **a30)(std::stringbuf *__hidden this),uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a43 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  JUMPOUT(0x1008EC6ECLL);
}

void sub_1008EC6B4()
{
}

void sub_1008EC73C(uint64_t a1@<X0>, char a2@<W1>, uint64_t *a3@<X8>)
{
  if (a2) {
    goto LABEL_15;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 32));
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    char v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v7;
  __int16 v11 = sub_10004D37C(&v6[1].__m_.__sig, &v27);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_10:
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_13;
    }
LABEL_11:
    sub_100058DB0(__p, "due to Airplane mode change");
    (*(void (**)(uint64_t, uint64_t, void **, uint64_t))(*(void *)v13 + 328))(v13, 3, __p, 1);
    a3 = (uint64_t *)v26;
    if ((a3 & 0x80000000) != 0) {
      operator delete(__p[0]);
    }
    goto LABEL_13;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (v13) {
    goto LABEL_11;
  }
LABEL_13:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
LABEL_15:
  uint64_t v15 = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 32));
  long long v16 = v15;
  xpc_object_t v17 = "N3awd7metrics14MetricCountersE";
  if (((unint64_t)"N3awd7metrics14MetricCountersE" & 0x8000000000000000) != 0)
  {
    uint64_t v18 = (unsigned __int8 *)((unint64_t)"N3awd7metrics14MetricCountersE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      xpc_object_t v17 = (const char *)v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(v15);
  unint64_t v27 = (unint64_t)v17;
  xpc_object_t v21 = sub_10004D37C(&v16[1].__m_.__sig, &v27);
  if (!v21)
  {
    uint64_t v23 = 0;
LABEL_23:
    std::mutex::unlock(v16);
    uint64_t v22 = 0;
    char v24 = 1;
    if (!v23) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  uint64_t v23 = v21[3];
  uint64_t v22 = (std::__shared_weak_count *)v21[4];
  if (!v22) {
    goto LABEL_23;
  }
  atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v16);
  atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v22);
  char v24 = 0;
  if (v23) {
LABEL_24:
  }
    sub_100BAA740(*(void *)(v23 + 448), a2);
LABEL_25:
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
}

void sub_1008EC940(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008EC974()
{
  if (v0) {
    JUMPOUT(0x1008EC968);
  }
  JUMPOUT(0x1008EC960);
}

uint64_t sub_1008EC984(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 72);
}

uint64_t sub_1008EC98C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 73) < 5u) & (0x14u >> *(unsigned char *)(a1 + 73));
}

void sub_1008EC9A8(uint64_t a1)
{
  shouldRadioInitInAirplaneMode = (capabilities::ct *)capabilities::ct::shouldRadioInitInAirplaneMode((capabilities::ct *)a1);
  int v3 = (int)shouldRadioInitInAirplaneMode;
  char v4 = capabilities::ct::supportsVoiceCall(shouldRadioInitInAirplaneMode);
  int v5 = *(unsigned __int8 *)(a1 + 72);
  if ((v5 - 1) >= 5 && v5 != 7 && (v5 != 8 || v3 == 0))
  {
    xpc_object_t v17 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v28) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Baseband booted in online mode", (uint8_t *)&v28, 2u);
    }
    if ((v4 & 1) != 0 || *(unsigned char *)(a1 + 66))
    {
      int v18 = *(_DWORD *)(a1 + 68);
      if (v18)
      {
        if (v18 == 1)
        {
          xpc_object_t v21 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v28) = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Airplane Mode is On: Getting baseband into airplane mode", (uint8_t *)&v28, 2u);
          }
          uint64_t v14 = a1;
          unsigned int v15 = 4;
          goto LABEL_52;
        }
        if (v18 != 3) {
          return;
        }
        __int16 v11 = *(NSObject **)(a1 + 8);
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_17;
        }
        goto LABEL_16;
      }
      unsigned int v20 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v28) = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Airplane Mode is On: Getting baseband into airplane mode", (uint8_t *)&v28, 2u);
      }
    }
    else
    {
      uint64_t v22 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v28) = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Cellular Data is Off", (uint8_t *)&v28, 2u);
      }
      int active = isActiveLowPowerMode();
      BOOL v24 = active == 0;
      if (active) {
        xpc_object_t v25 = &event::radio::off[3];
      }
      else {
        xpc_object_t v25 = (uint64_t *)((char *)&event::radio::disabling + 24);
      }
      if (v24) {
        char v26 = (uint64_t *)((char *)&event::radio::disabling + 8);
      }
      else {
        char v26 = &event::radio::off[1];
      }
      sub_100477910(v25);
      unint64_t v27 = (uint64_t *)sub_100161CDC(v26);
      sub_10035414C(v27);
    }
    uint64_t v14 = a1;
    unsigned int v15 = 2;
    goto LABEL_52;
  }
  unint64_t v7 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v28) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Baseband booted in airplane mode", (uint8_t *)&v28, 2u);
  }
  if (isActiveLowPowerMode())
  {
    char v8 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v28) = 0;
    uint64_t v9 = "#I In Airplane Mode: Do Nothing";
    goto LABEL_11;
  }
  if ((v4 & 1) != 0 || *(unsigned char *)(a1 + 66))
  {
    int v10 = *(_DWORD *)(a1 + 68);
    __int16 v11 = *(NSObject **)(a1 + 8);
    BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    if (v10 != 3)
    {
      if (v12)
      {
        uint64_t v19 = asString();
        int v28 = 136315138;
        uint64_t v29 = v19;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Getting Baseband out of airplane mode %s", (uint8_t *)&v28, 0xCu);
      }
      uint64_t v14 = a1;
      unsigned int v15 = 1;
      goto LABEL_52;
    }
    if (!v12) {
      goto LABEL_17;
    }
LABEL_16:
    uint64_t v13 = asString();
    int v28 = 136315138;
    uint64_t v29 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Getting Baseband out of airplane mode %s", (uint8_t *)&v28, 0xCu);
LABEL_17:
    uint64_t v14 = a1;
    unsigned int v15 = 3;
LABEL_52:
    sub_1008ECD5C(v14, v15);
    return;
  }
  char v8 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v28) = 0;
    uint64_t v9 = "#I Cellular Data is Off: Do Nothing";
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v28, 2u);
  }
}

void sub_1008ECD5C(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = a2;
  if (*(unsigned __int8 *)(a1 + 73) != a2)
  {
    if (*(unsigned char *)(a1 + 73))
    {
      *(unsigned char *)(a1 + 74) = a2;
      goto LABEL_13;
    }
    int v18 = *(unsigned __int8 *)(a1 + 72);
    if (*(unsigned char *)(a1 + 76))
    {
      if ((v18 - 1) < 5 || v18 == 7)
      {
        unsigned int v20 = *(NSObject **)(a1 + 8);
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_WORD *)buf = 0;
        xpc_object_t v21 = "#I Forcing AP mode - in AP mode, no outstanding requests ...";
        uint64_t v22 = v20;
        uint32_t v23 = 2;
LABEL_30:
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v21, buf, v23);
        return;
      }
      unint64_t v43 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I Forcing low power mode", buf, 2u);
        if (*(unsigned char *)(a1 + 73)) {
          goto LABEL_13;
        }
        int v18 = *(unsigned __int8 *)(a1 + 72);
      }
LABEL_77:
      int v41 = 1;
      unsigned int v2 = 2;
      goto LABEL_94;
    }
    if (v18 != 2)
    {
      switch(a2)
      {
        case 1u:
          int v41 = 0;
          break;
        case 2u:
          goto LABEL_77;
        case 3u:
          int v41 = 6;
          break;
        case 4u:
          int v41 = 7;
          break;
        default:
          int v41 = 8;
          break;
      }
LABEL_94:
      if (v41 == v18)
      {
        unsigned int v47 = *(NSObject **)(a1 + 8);
        if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        if (v2 > 4) {
          unint64_t v48 = "???";
        }
        else {
          unint64_t v48 = off_101A18918[(char)v2];
        }
        uint64_t v58 = asString();
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = v48;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v58;
        xpc_object_t v21 = "#I Dropping operation request %s - Already in %s";
        uint64_t v22 = v47;
        goto LABEL_29;
      }
      *(unsigned char *)(a1 + 73) = v2;
      if (v2 >= 5) {
        unsigned __int8 v49 = 8;
      }
      else {
        unsigned __int8 v49 = 0x706010008uLL >> (8 * v2);
      }
      BOOL v50 = (v2 & 0x1F) == 2 && v2 < 5;
      *(unsigned char *)(a1 + 75) = 1;
      uint64_t v51 = *(std::__shared_weak_count **)(a1 + 56);
      if (v51)
      {
        uint64_t v52 = std::__shared_weak_count::lock(v51);
        if (v52)
        {
          xpc_object_t v53 = v52;
          uint64_t v54 = *(void *)(a1 + 48);
          if (v54)
          {
            CFStringRef v55 = *(NSObject **)(a1 + 8);
            BOOL v56 = os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT);
            if (v50)
            {
              if (v56)
              {
                uint64_t v57 = asString();
                *(_DWORD *)buf = 136315138;
                *(void *)&uint8_t buf[4] = v57;
                _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Delay entering %s", buf, 0xCu);
              }
              (*(void (**)(uint64_t))(*(void *)v54 + 24))(v54);
            }
            else
            {
              if (v56)
              {
                uint64_t v59 = asString();
                *(_DWORD *)buf = 136315138;
                *(void *)&uint8_t buf[4] = v59;
                _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Requesting mode %s now", buf, 0xCu);
              }
              (*(void (**)(uint64_t, void))(*(void *)v54 + 16))(v54, v49);
            }
          }
          sub_10004D2C8(v53);
        }
      }
LABEL_13:
      unsigned int v15 = *(NSObject **)(a1 + 8);
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      unint64_t v16 = *(char *)(a1 + 73);
      if (v16 > 4) {
        xpc_object_t v17 = "???";
      }
      else {
        xpc_object_t v17 = off_101A18918[v16];
      }
      unint64_t v24 = *(char *)(a1 + 74);
      if (v24 > 4) {
        xpc_object_t v25 = "???";
      }
      else {
        xpc_object_t v25 = off_101A18918[v24];
      }
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = v17;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v25;
      xpc_object_t v21 = "#I Operating Mode Requests: Current (%s) Pending (%s)";
      uint64_t v22 = v15;
LABEL_29:
      uint32_t v23 = 22;
      goto LABEL_30;
    }
    char v26 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Baseband is in factory test mode. Ignoring request to make it go online", buf, 2u);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v27, *(Registry **)(a1 + 32));
    uint64_t v29 = ServiceMap;
    if (v30 < 0)
    {
      uint64_t v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        uint64_t v30 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(ServiceMap);
    *(void *)buf = v30;
    long long v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
    if (v34)
    {
      uint64_t v36 = v34[3];
      size_t v35 = (std::__shared_weak_count *)v34[4];
      if (v35)
      {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v29);
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v35);
        char v37 = 0;
LABEL_85:
        if (v36)
        {
          if (((*(uint64_t (**)(uint64_t))(*(void *)v36 + 32))(v36) & 1) == 0)
          {
            int v46 = *(NSObject **)(a1 + 8);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
            {
              uint64_t v60 = asString();
              *(_DWORD *)buf = 136315138;
              *(void *)&uint8_t buf[4] = v60;
              _os_log_fault_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_FAULT, "Unexpected Baseband operating mode: %s!", buf, 0xCu);
            }
          }
        }
        if ((v37 & 1) == 0) {
          goto LABEL_68;
        }
        return;
      }
    }
    else
    {
      uint64_t v36 = 0;
    }
    std::mutex::unlock(v29);
    size_t v35 = 0;
    char v37 = 1;
    goto LABEL_85;
  }
  char v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    if (v2 > 4) {
      xpc_object_t v42 = "???";
    }
    else {
      xpc_object_t v42 = off_101A18918[(char)v2];
    }
    unint64_t v44 = *(char *)(a1 + 74);
    if (v44 > 4) {
      size_t v45 = "???";
    }
    else {
      size_t v45 = off_101A18918[v44];
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = v42;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v45;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Incoming operation matches (%s), dropping pending: %s", buf, 0x16u);
  }
  if (!*(unsigned char *)(a1 + 74)) {
    return;
  }
  *(unsigned char *)(a1 + 74) = 0;
  if (v2 != 1) {
    goto LABEL_64;
  }
  memset(&buf[8], 0, 32);
  uint64_t v75 = 0x500000000000000;
  *(_OWORD *)&v76[8] = 0u;
  long long v80 = 0u;
  long long v79 = 0u;
  memset(&v77, 0, sizeof(v77));
  unint64_t v78 = 23;
  qmemcpy(&buf[23], "\tRadio", 6);
  qmemcpy(buf, "Telephony", 9);
  v76[23] = 14;
  qmemcpy(v76, "Operating Mode", 14);
  sub_10003ECB8(&v77, "Requesting operating mode matching current requested operating mode with pending request", 0x58uLL);
  long long v71 = &v78;
  int v72 = 0;
  sub_10019E478((uint64_t)&v71, 5uLL);
  v78 |= 0x11uLL;
  int v5 = (std::mutex *)Registry::getServiceMap((uint64_t *)v78, *(Registry **)(a1 + 32));
  uint64_t v6 = v5;
  if ((v7 & 0x8000000000000000) != 0)
  {
    char v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(v5);
  long long v71 = (unint64_t *)v7;
  __int16 v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v71);
  if (!v11)
  {
    uint64_t v13 = 0;
    goto LABEL_41;
  }
  uint64_t v13 = v11[3];
  BOOL v12 = (std::__shared_weak_count *)v11[4];
  if (!v12)
  {
LABEL_41:
    std::mutex::unlock(v6);
    BOOL v12 = 0;
    char v14 = 1;
    goto LABEL_42;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
LABEL_42:
  sub_1000DB86C((char *)__dst, (long long *)buf);
  v73[3] = 0;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v13 + 16))(v13, __dst, v73);
  sub_1000DBADC(v73);
  if (v70 < 0) {
    operator delete(__p);
  }
  if (v68 < 0) {
    operator delete(v67);
  }
  if (v66 < 0) {
    operator delete(v65);
  }
  if (v64 < 0) {
    operator delete(v63);
  }
  if (v62 < 0) {
    operator delete(__dst[0]);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (SBYTE7(v80) < 0) {
    operator delete((void *)v79);
  }
  if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v77.__r_.__value_.__l.__data_);
  }
  if ((v76[23] & 0x80000000) != 0) {
    operator delete(*(void **)v76);
  }
  if (SHIBYTE(v75) < 0) {
    operator delete(*(void **)&buf[24]);
  }
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
LABEL_64:
  unint64_t v38 = *(std::__shared_weak_count **)(a1 + 56);
  if (v38)
  {
    unint64_t v39 = std::__shared_weak_count::lock(v38);
    if (v39)
    {
      size_t v35 = v39;
      uint64_t v40 = *(void *)(a1 + 48);
      if (v40) {
        (*(void (**)(uint64_t))(*(void *)v40 + 32))(v40);
      }
LABEL_68:
      sub_10004D2C8(v35);
    }
  }
}

void sub_1008ED5FC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1008ED69C(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 68) != a2)
  {
    *(_DWORD *)(a1 + 68) = a2;
    int active = isActiveLowPowerMode();
    if (active) {
      int v5 = "Entering airplane mode";
    }
    else {
      int v5 = "Exiting airplane mode";
    }
    xpc_object_t v17 = _os_activity_create((void *)&_mh_execute_header, v5, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    *(void *)state = 0;
    *(void *)&state[8] = 0;
    os_activity_scope_enter(v17, (os_activity_scope_state_t)state);
    os_activity_scope_leave((os_activity_scope_state_t)state);
    sub_100687EB8((void **)&v17);
    uint64_t v6 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (active) {
        unint64_t v7 = "Entering";
      }
      else {
        unint64_t v7 = "Exiting";
      }
      uint64_t v8 = asString();
      *(_DWORD *)state = 136315394;
      *(void *)&state[4] = v7;
      *(_WORD *)&state[12] = 2080;
      *(void *)&state[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s airplane mode: operatingModeType: %s", state, 0x16u);
    }
    uint64_t v9 = (uint64_t *)*(unsigned __int8 *)(a1 + 64);
    if (*(unsigned char *)(a1 + 64))
    {
      switch(a2)
      {
        case 0:
          int v10 = *(unsigned __int8 *)(a1 + 72);
          if (v10 != 1)
          {
            unsigned int v11 = 2;
            if (v10 == 7) {
              goto LABEL_25;
            }
            goto LABEL_20;
          }
          break;
        case 1:
          int v15 = *(unsigned __int8 *)(a1 + 72);
          unsigned int v11 = 4;
          if (v15 == 1) {
            goto LABEL_25;
          }
          if (v15 != 7)
          {
LABEL_20:
            sub_100477910(&event::radio::disabling[3]);
            unint64_t v16 = (uint64_t *)sub_100161CDC(&event::radio::disabling[1]);
            sub_10035414C(v16);
            goto LABEL_25;
          }
          break;
        case 2:
          if (sub_1008ED914(a1, v9))
          {
            unsigned int v11 = 1;
            goto LABEL_25;
          }
          break;
        case 3:
          if (sub_1008ED914(a1, v9))
          {
            unsigned int v11 = 3;
LABEL_25:
            sub_1008ECD5C(a1, v11);
          }
          break;
        default:
          return;
      }
    }
    else
    {
      BOOL v12 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = asString();
        *(_DWORD *)state = 136315138;
        *(void *)&state[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Baseband not initialized for request %s", state, 0xCu);
      }
      sub_1008EC73C(a1, active, v13);
    }
  }
}

uint64_t sub_1008ED914@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 32));
  char v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  v31[0] = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, v31);
  if (v9)
  {
    uint64_t v11 = v9[3];
    int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  int v10 = 0;
  char v12 = 1;
LABEL_9:
  int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 72))(v11);
  int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 80))(v11);
  unint64_t v16 = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(a1 + 32));
  xpc_object_t v17 = v16;
  if ((v18 & 0x8000000000000000) != 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      unint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  v31[0] = v18;
  uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, v31);
  if (v22)
  {
    uint64_t v23 = v22[3];
    unint64_t v24 = (std::__shared_weak_count *)v22[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v25 = 0;
      if (!v23) {
        goto LABEL_15;
      }
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  std::mutex::unlock(v17);
  unint64_t v24 = 0;
  char v25 = 1;
  if (!v23)
  {
LABEL_15:
    char v26 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v31[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Missing subscriber interface", (uint8_t *)v31, 2u);
    }
    goto LABEL_25;
  }
LABEL_19:
  (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 16))(v23, 1);
  char isSimUnreadable = subscriber::isSimUnreadable();
  if ((v14 ^ 1 | v13) & 1) != 0 || (!*(unsigned char *)(a1 + 65) ? (char v28 = 1) : (char v28 = isSimUnreadable), (v28))
  {
    LOBYTE(v13) = 1;
  }
  else
  {
    uint64_t v30 = *(NSObject **)(a1 + 8);
    LOBYTE(v13) = 0;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v31[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Device is not activated. Waiting for activation ticket to make the baseband go online", (uint8_t *)v31, 2u);
      LOBYTE(v13) = 0;
    }
  }
LABEL_25:
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  return (v23 != 0) & v13;
}

void sub_1008EDBE4(_Unwind_Exception *exception_object)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008EDC24(uint64_t result, char a2)
{
  *(unsigned char *)(result + 66) = a2;
  return result;
}

uint64_t sub_1008EDC2C(capabilities::ct *a1, void *a2)
{
  uint64_t result = capabilities::ct::supportsVoiceCall(a1);
  if ((result & 1) == 0)
  {
    uint64_t v5 = a2[1];
    if (*a2 == v5)
    {
      BOOL v7 = 1;
    }
    else
    {
      uint64_t v6 = *a2 + 168;
      do
      {
        BOOL v7 = *(_DWORD *)(v6 - 160) == 1;
        BOOL v8 = *(_DWORD *)(v6 - 160) != 1 || v6 == v5;
        v6 += 168;
      }
      while (!v8);
    }
    *((unsigned char *)a1 + 76) = v7;
  }
  return result;
}

void sub_1008EDC8C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1008EDD0C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008EDD48(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1008EDD80(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1008EDDB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1008EDDF4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_24;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      uint64_t v3 = *(void *)(*a1 + 16);
      sub_1008EE130(v3);
      sub_10000A4EC(&v19, v3);
      uint64_t v4 = sub_1004F8060((uint64_t *)(*a1 + 16));
      uint64_t v5 = (uint64_t *)(v4 + 32);
      if (*(void *)(v4 + 32))
      {
        uint64_t v6 = v4;
        uint64_t v7 = a1[2];
        BOOL v8 = *(_DWORD **)sub_1004F8B10((uint64_t *)(v4 + 32));
        if (v8 != *(_DWORD **)(sub_1004F8B10(v5) + 8))
        {
          uint64_t v9 = (void *)(v7 + 8);
          while (1)
          {
            memset(v31, 0, sizeof(v31));
            sub_100060B10(v8, (uint64_t)v31);
            if (sub_100060A68((uint64_t)v8)) {
              break;
            }
            sub_100062188(v9, (uint64_t)v31);
            sub_1000624B4((uint64_t)v31);
            v8 += 6;
            if (v8 == *(_DWORD **)(sub_1004F8B10(v5) + 8)) {
              goto LABEL_12;
            }
          }
          if (*(unsigned char *)(v6 + 24))
          {
            *(unsigned char *)(v6 + 24) = 0;
            sub_100060D70((atomic_uint **)v6, &v19);
          }
          sub_1000624B4((uint64_t)v31);
        }
      }
LABEL_12:
      uint64_t v10 = sub_1004F8060((uint64_t *)(*a1 + 16));
      uint64_t v11 = a1[2];
      if (*(unsigned char *)(v10 + 24)) {
        ++*(_DWORD *)(v11 + 280);
      }
      else {
        ++*(_DWORD *)(v11 + 284);
      }
      uint64_t v12 = sub_1004F8060((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v12 + 24)
        || (uint64_t v13 = *(void *)(v12 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v13 + 8), memory_order_acquire))
      {
        int v14 = 1;
      }
      else
      {
        sub_10000A39C(a1, &v19, *a1);
        int v14 = 0;
      }
      (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
      sub_10000A5F8(&v19);
      uint64_t v1 = *a1;
      uint64_t v15 = a1[1];
      if (!v14) {
        break;
      }
      uint64_t v16 = *(void *)(v1 + 8);
      *a1 = v16;
      if (v16 == v15)
      {
        uint64_t v1 = v15;
        goto LABEL_24;
      }
    }
    if (v1 == v15)
    {
LABEL_24:
      uint64_t v17 = a1[3];
      if (v17 != v1)
      {
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v18 = *(void *)(v17 + 16);
        sub_1008EE130(v18);
        sub_10000A4EC(&v19, v18);
        sub_10000A39C(a1, &v19, a1[1]);
        (*(void (**)(void))(**((void **)&v30 + 1) + 32))(*((void *)&v30 + 1));
        sub_10000A5F8(&v19);
      }
    }
  }
}

void sub_1008EE0D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008EE130(uint64_t result)
{
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void *sub_1008EE170(void *a1)
{
  if (*(_DWORD *)(*a1 + 284) > *(_DWORD *)(*a1 + 280))
  {
    unsigned int v2 = (uint64_t *)a1[1];
    uint64_t v3 = a1[2];
    long long v11 = 0u;
    memset(v10, 0, sizeof(v10));
    uint64_t v4 = (pthread_mutex_t *)sub_100060E64(v2 + 3);
    sub_100061F70(v10, v4);
    uint64_t v5 = (uint64_t *)sub_1004F801C(v2);
    if (sub_1004F9380(v5) == v3)
    {
      uint64_t v6 = v2[1];
      if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
        operator new();
      }
      uint64_t v7 = (uint64_t *)sub_1004F801C(v2);
      uint64_t v9 = *(uint64_t **)(sub_1004F9380(v7) + 8);
      sub_1004F8284(v2, v10, 0, &v9, 0);
    }
    sub_10000A6C8(*((pthread_mutex_t **)&v11 + 1));
    sub_10000A5F8(v10);
  }
  return a1;
}

void sub_1008EE2DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008EE338(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 288);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 288), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_1008EE40C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1008EE42C(uint64_t a1, void *a2, NSObject **a3)
{
  uint64_t v6 = dispatch_queue_create("DataPlanProbe", 0);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = v6;
  if (v6)
  {
    uint64_t v7 = v6;
    dispatch_retain(v6);
    *(void *)(a1 + 32) = 0;
    dispatch_release(v7);
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  *(void *)a1 = off_101A18950;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 40) = *a2;
  *(void *)(a1 + 48) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *a3;
  *(void *)(a1 + 56) = *a3;
  if (v9) {
    dispatch_retain(v9);
  }
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = ++dword_101B13E50;
  return a1;
}

void *sub_1008EE4FC(void *a1)
{
  *a1 = off_101A18950;
  sub_1008EE79C(a1 + 9, 0);
  uint64_t v2 = a1[7];
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_1008EE56C(uint64_t a1, int a2, int a3)
{
  os_log_t oslog = 0;
  long long v5 = (const char *)kCtLoggingSystemName;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, v5, LogGroupName);
  uint64_t v7 = oslog;
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)buf = 134218496;
    CFAbsoluteTime v11 = Current;
    __int16 v12 = 1024;
    int v13 = a3;
    __int16 v14 = 1024;
    int v15 = a2;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Retry timer info: current time = %f, retryIn = %d msec (activating: %d)", buf, 0x18u);
  }
  operator new();
}

void sub_1008EE72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1008EE79C(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_10091722C(result);
    operator delete();
  }
  return result;
}

void sub_1008EE7EC(uint64_t a1)
{
  uint64_t v1 = *(_DWORD **)(a1 + 32);
  int v2 = *(unsigned __int8 *)(a1 + 40);
  os_log_t oslog = 0;
  uint64_t v3 = (const char *)kCtLoggingSystemName;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, v3, LogGroupName);
  long long v5 = oslog;
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = v1[16];
    *(_DWORD *)buf = 67109376;
    int v9 = v6;
    __int16 v10 = 1024;
    int v11 = v2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I initiating retry of probe, retryCFIndex Count = %d, activating: %d", buf, 0xEu);
  }
  (*(void (**)(_DWORD *, BOOL))(*(void *)v1 + 16))(v1, v2 != 0);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
}

void sub_1008EE904(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1008EE920()
{
  return 10;
}

void sub_1008EE928(void *a1@<X8>)
{
  if (qword_101B14190 && (int v2 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190)) != 0)
  {
    uint64_t v3 = v2;
    if (DataPlanManagerBootstrap::sInstance) {
      (*(void (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 304))();
    }
    else {
      *a1 = 0;
    }
    sub_10004D2C8(v3);
  }
  else
  {
    *a1 = 0;
  }
}

void sub_1008EE9D4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1008EE9E8(_DWORD *a1)
{
  os_log_t oslog = 0;
  int v2 = (const char *)kCtLoggingSystemName;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, v2, LogGroupName);
  uint64_t v4 = oslog;
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 32))(a1);
    int v6 = a1[16];
    *(_DWORD *)buf = 136315394;
    uint64_t v9 = v5;
    __int16 v10 = 1024;
    int v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Probe Type:%s fRetryCount:%d", buf, 0x12u);
  }
  (*(void (**)(_DWORD *))(*(void *)a1 + 48))(a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
}

void sub_1008EEB28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  _Unwind_Resume(a1);
}

void sub_1008EEB4C(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (!v2 || (v3 = *(void *)(a1 + 48), (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  p_shared_weak_owners = &v4->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v4);
  v26[5] = _NSConcreteStackBlock;
  v26[6] = 1174405120;
  v26[7] = sub_1008EEEF0;
  v26[8] = &unk_101A18A38;
  v26[9] = a1;
  v26[10] = v3;
  long long v27 = v5;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  sub_10017B514();
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 8));
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  v28[0] = v10;
  __int16 v14 = sub_10004D37C(&v9[1].__m_.__sig, v28);
  if (v14)
  {
    uint64_t v16 = v14[3];
    int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_29;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  int v15 = 0;
  char v17 = 1;
  if (!v16) {
    goto LABEL_29;
  }
LABEL_12:
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 56);
  if (!v18 || (v19 = *(void *)(a1 + 48), (long long v20 = std::__shared_weak_count::lock(v18)) == 0)) {
    sub_100088B9C();
  }
  long long v21 = v20;
  atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  long long v22 = *(NSObject **)(a1 + 64);
  if (v22) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 64));
  }
  v26[0] = _NSConcreteStackBlock;
  v26[1] = 0x40000000;
  v26[2] = sub_1008EF0F8;
  v26[3] = &unk_101A18A68;
  v26[4] = a1;
  if (v22)
  {
    long long v23 = _Block_copy(v26);
    long long v24 = v23;
    dispatch_object_t v31 = v22;
    v28[0] = (unint64_t)_NSConcreteStackBlock;
    v28[1] = 1174405120;
    v28[2] = (unint64_t)sub_1008EFCBC;
    v28[3] = (unint64_t)&unk_101A18BE0;
    v28[4] = v19;
    long long v29 = v21;
    atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    if (v23) {
      long long v25 = _Block_copy(v23);
    }
    else {
      long long v25 = 0;
    }
    aBlock = v25;
    (*(void (**)(uint64_t, const char *, uint64_t, dispatch_object_t *, unint64_t *))(*(void *)v16 + 40))(v16, "commCenterOperatingModeAssertion", 1, &v31, v28);
    if (v31) {
      dispatch_release(v31);
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (v29) {
      std::__shared_weak_count::__release_weak(v29);
    }
    if (v24) {
      _Block_release(v24);
    }
  }
  std::__shared_weak_count::__release_weak(v21);
LABEL_29:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (v27) {
    std::__shared_weak_count::__release_weak(v27);
  }
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1008EEE68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a26) {
    std::__shared_weak_count::__release_weak(a26);
  }
  long long v34 = *(NSObject **)(v32 - 104);
  if (v34) {
    dispatch_release(v34);
  }
  if (v29) {
    _Block_release(v29);
  }
  std::__shared_weak_count::__release_weak(v30);
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  if (a20) {
    std::__shared_weak_count::__release_weak(a20);
  }
  std::__shared_weak_count::__release_weak(v27);
  _Unwind_Resume(a1);
}

void sub_1008EEEF0(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 0x40000000;
        v11[2] = sub_1008EF030;
        v11[3] = &unk_101A18A18;
        v11[4] = v3;
        int v6 = (std::__shared_weak_count *)v3[7];
        if (!v6 || (uint64_t v7 = v3[6], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v9 = v8;
        unint64_t v10 = v3[8];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_1008EFB18;
        block[3] = &unk_101A18B30;
        block[5] = v7;
        unsigned int v13 = v9;
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        void block[4] = v11;
        dispatch_async(v10, block);
        if (v13) {
          sub_10004D2C8(v13);
        }
        sub_10004D2C8(v9);
      }
      sub_10004D2C8(v5);
    }
  }
}

void *sub_1008EF030(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v3[0] = off_101A18AB8;
  v3[1] = v1;
  v3[3] = v3;
  sub_10084DE40(v1, (uint64_t)v3);
  return sub_10001E914(v3);
}

void sub_1008EF0B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10001E914((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1008EF0CC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1008EF0E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *sub_1008EF0F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v3[0] = off_101A18B70;
  v3[1] = v1;
  v3[3] = v3;
  sub_10084DE40(v1, (uint64_t)v3);
  return sub_10001E914(v3);
}

void sub_1008EF180(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10001E914((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1008EF194(uint64_t a1, char a2, int a3, int a4, char *a5)
{
  if ((a4 - 2) > 3)
  {
    unsigned int v9 = 0;
    if ((a2 & 1) == 0) {
      goto LABEL_13;
    }
  }
  else
  {
    unsigned int v9 = dword_101508550[a4 - 2];
    if ((a2 & 1) == 0) {
      goto LABEL_13;
    }
  }
  v42[1] = _NSConcreteStackBlock;
  v42[2] = (xpc_object_t)0x40000000;
  v42[3] = sub_1008EF840;
  v42[4] = &unk_101A18A88;
  unsigned int v43 = v9;
  v42[5] = a5;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)a1);
  int v11 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x80106u);
  *(void *)buf = v11;
  if (v11)
  {
    uint64_t v12 = sub_10001C8F4(8);
    uint64_t v14 = *v12;
    unsigned int v13 = (std::__shared_weak_count *)v12[1];
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v14) {
      operator new();
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
    wis::MetricContainer::~MetricContainer(v11);
    operator delete();
  }
LABEL_13:
  if ((a2 & 2) == 0) {
    return;
  }
  int v15 = (uint64_t *)(a3 - 2);
  if (v15 > 3) {
    unsigned int v16 = 0;
  }
  else {
    unsigned int v16 = dword_101508550[(int)v15];
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(a1 + 8));
  uint64_t v18 = ServiceMap;
  if (v19 < 0)
  {
    long long v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v19;
  long long v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
  if (v23)
  {
    uint64_t v25 = v23[3];
    long long v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      char v26 = 0;
      if (!v25) {
        goto LABEL_23;
      }
LABEL_27:
      v42[0] = 0;
      xpc_object_t v28 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v29 = v28;
      if (v28)
      {
        v42[0] = v28;
      }
      else
      {
        xpc_object_t v29 = xpc_null_create();
        v42[0] = v29;
        if (!v29)
        {
          xpc_object_t v30 = xpc_null_create();
          xpc_object_t v29 = 0;
          goto LABEL_34;
        }
      }
      if (xpc_get_type(v29) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v29);
LABEL_35:
        xpc_release(v29);
        xpc_object_t v40 = xpc_int64_create(v16);
        if (!v40) {
          xpc_object_t v40 = xpc_null_create();
        }
        *(void *)buf = v42;
        size_t v45 = "old_mode";
        sub_100035E70((uint64_t)buf, &v40, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v40);
        xpc_object_t v40 = 0;
        xpc_object_t v38 = xpc_int64_create(v9);
        if (!v38) {
          xpc_object_t v38 = xpc_null_create();
        }
        *(void *)buf = v42;
        size_t v45 = "new_mode";
        sub_100035E70((uint64_t)buf, &v38, &v39);
        xpc_release(v39);
        xpc_object_t v39 = 0;
        xpc_release(v38);
        xpc_object_t v38 = 0;
        xpc_object_t v36 = xpc_uint64_create(*(void *)(a1 + 168));
        if (!v36) {
          xpc_object_t v36 = xpc_null_create();
        }
        *(void *)buf = v42;
        size_t v45 = "duration_in_old_mode";
        sub_100035E70((uint64_t)buf, &v36, &v37);
        xpc_release(v37);
        xpc_object_t v37 = 0;
        xpc_release(v36);
        xpc_object_t v36 = 0;
        if (a5[23] >= 0) {
          char v31 = a5;
        }
        else {
          char v31 = *(const char **)a5;
        }
        xpc_object_t v34 = xpc_string_create(v31);
        if (!v34) {
          xpc_object_t v34 = xpc_null_create();
        }
        *(void *)buf = v42;
        size_t v45 = "reason";
        sub_100035E70((uint64_t)buf, &v34, &v35);
        xpc_release(v35);
        xpc_object_t v35 = 0;
        xpc_release(v34);
        xpc_object_t v34 = 0;
        uint64_t v32 = *(NSObject **)(a1 + 80);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v16;
          LOWORD(v45) = 1024;
          *(_DWORD *)((char *)&v45 + 2) = v9;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Submit OperatingModeAssertion oldMode=%d, newMode=%d", buf, 0xEu);
        }
        xpc_object_t v33 = v42[0];
        if (v42[0]) {
          xpc_retain(v42[0]);
        }
        else {
          xpc_object_t v33 = xpc_null_create();
        }
        (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v25 + 16))(v25, "commCenterOperatingModeAssertion", &v33);
        xpc_release(v33);
        xpc_object_t v33 = 0;
        xpc_release(v42[0]);
        goto LABEL_52;
      }
      xpc_object_t v30 = xpc_null_create();
LABEL_34:
      v42[0] = v30;
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v18);
  long long v24 = 0;
  char v26 = 1;
  if (v25) {
    goto LABEL_27;
  }
LABEL_23:
  long long v27 = *(NSObject **)(a1 + 80);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#E No Telephony Analytics Service", buf, 2u);
  }
LABEL_52:
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
}

void sub_1008EF718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_1008EF840(wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *a1, int *a2)
{
  uint64_t v3 = a1;
  int v4 = *((_DWORD *)a1 + 10);
  a2[12] |= 2u;
  a2[10] = v4;
  int v5 = a2[7];
  uint64_t v6 = a2[6];
  if ((int)v6 >= v5)
  {
    if (v5 == a2[8])
    {
      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 4), v5 + 1);
      int v5 = a2[7];
    }
    a2[7] = v5 + 1;
    operator new();
  }
  uint64_t v7 = *((void *)a2 + 2);
  a2[6] = v6 + 1;
  uint64_t v8 = *(_DWORD **)(v7 + 8 * v6);
  v8[11] |= 2u;
  v8[3] = v4;
  int v9 = v8[7];
  uint64_t v10 = (int)v8[6];
  if ((int)v10 >= v9)
  {
    if (v9 == v8[8])
    {
      a1 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v8 + 4), v9 + 1);
      int v9 = v8[7];
    }
    v8[7] = v9 + 1;
    uint64_t v12 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New(a1);
    uint64_t v13 = *((void *)v8 + 2);
    uint64_t v14 = (int)v8[6];
    v8[6] = v14 + 1;
    *(void *)(v13 + 8 * v14) = v12;
  }
  else
  {
    uint64_t v11 = *((void *)v8 + 2);
    v8[6] = v10 + 1;
    uint64_t v12 = *(std::string **)(v11 + 8 * v10);
  }
  uint64_t v15 = *((void *)v3 + 4);
  int v16 = *(char *)(v15 + 23);
  if (v16 >= 0) {
    char v17 = (const std::string::value_type *)*((void *)v3 + 4);
  }
  else {
    char v17 = *(const std::string::value_type **)v15;
  }
  if (v16 >= 0) {
    std::string::size_type v18 = *(unsigned __int8 *)(v15 + 23);
  }
  else {
    std::string::size_type v18 = *(void *)(v15 + 8);
  }

  return std::string::append(v12, v17, v18);
}

void sub_1008EF99C()
{
}

void sub_1008EF9C4()
{
}

void *sub_1008EF9D8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A18AB8;
  result[1] = v3;
  return result;
}

uint64_t sub_1008EFA20(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A18AB8;
  a2[1] = v2;
  return result;
}

void sub_1008EFA4C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)long long __p = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  sub_1008EF194(*(void *)(a1 + 8), 1, *(_DWORD *)(*(void *)(a1 + 8) + 112), *(_DWORD *)(*(void *)(a1 + 8) + 112), (char *)__p);
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1008EFAB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008EFACC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A18B18)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1008EFB0C()
{
  return &off_101A18B18;
}

uint64_t sub_1008EFB18(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1008EFB28(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1008EFB44(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1008EFB58()
{
}

void *sub_1008EFB6C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A18B70;
  result[1] = v3;
  return result;
}

uint64_t sub_1008EFBB4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A18B70;
  a2[1] = v2;
  return result;
}

void sub_1008EFBE0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)long long __p = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v2 = *(void *)(a1 + 8);
  sub_10084D744((void *)v2, 0);
  sub_1008EF194(v2, 2, *(_DWORD *)(v2 + 112), *(_DWORD *)(v2 + 112), (char *)__p);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1008EFC54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008EFC70(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A18BD0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1008EFCB0()
{
  return &off_101A18BD0;
}

void sub_1008EFCBC(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1008EFD34(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_1008EFD48(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = (void *)a2[6];
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_1008EFD94(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t sub_1008EFDE8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void *sub_1008EFE18(void *a1, void *a2, NSObject **a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  v8[0] = *a2;
  v8[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v5 = *a3;
  uint64_t v7 = v5;
  if (!v5)
  {
    sub_1008EE42C((uint64_t)a1, v8, &v7);
    if (!v4) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  dispatch_retain(v5);
  sub_1008EE42C((uint64_t)a1, v8, &v7);
  dispatch_release(v5);
  if (v4) {
LABEL_5:
  }
    sub_10004D2C8(v4);
LABEL_6:
  *a1 = off_101A18C20;
  a1[12] = 0;
  a1[13] = 0;
  a1[11] = 0;
  return a1;
}

void *sub_1008EFED8(void *a1)
{
  *a1 = off_101A18C20;
  sub_1008EE79C(a1 + 9, 0);
  *((_DWORD *)a1 + 16) = 0;
  *((unsigned char *)a1 + 80) = 0;
  (*(void (**)(void *))(*a1 + 24))(a1);

  return sub_1008EE4FC(a1);
}

void sub_1008EFF68(void *a1)
{
  sub_1008EFED8(a1);

  operator delete();
}

const char *sub_1008EFFA0()
{
  return "RedirectProbe";
}

const void **sub_1008EFFAC(uint64_t a1)
{
  uint64_t v2 = (void *)*(unsigned int *)(a1 + 84);
  clientContext.version = 0;
  clientContext.info = v2;
  uint64_t v3 = (CFReadStreamRef *)(a1 + 88);
  memset(&clientContext.retain, 0, 24);
  Main = CFRunLoopGetMain();
  sub_1009165E8(v3, Main);
  CFStringRef v5 = @"http://www.apple.com/library/test/success.html";
  CFStringRef v23 = @"http://www.apple.com/library/test/success.html";
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 48);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 40);
      if (v9)
      {
        CFStringRef theString = 0;
        (*(void (**)(CFStringRef *__return_ptr))(*(void *)v9 + 16))(&theString);
        if (theString) {
          uint64_t v10 = sub_1000810B8;
        }
        else {
          uint64_t v10 = 0;
        }
        if (v10 && CFStringGetLength(theString) >= 1) {
          sub_100083EB8((const void **)&v23, (const void **)&theString);
        }
        sub_1000558F4((const void **)&theString);
      }
      sub_10004D2C8(v8);
      CFStringRef v5 = v23;
    }
    else
    {
      CFStringRef v5 = @"http://www.apple.com/library/test/success.html";
    }
  }
  CFURLRef v11 = CFURLCreateWithString(kCFAllocatorDefault, v5, 0);
  if (!v11)
  {
    sub_1008F03CC();
    int v16 = qword_101B0E138;
    if (!os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT)) {
      return sub_1000558F4((const void **)&v23);
    }
    LOWORD(theString) = 0;
    char v17 = "#I RedirectProbe - httpURL invalid";
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&theString, 2u);
    return sub_1000558F4((const void **)&v23);
  }
  Request = CFHTTPMessageCreateRequest(kCFAllocatorDefault, @"GET", v11, kCFHTTPVersion1_1);
  CFRelease(v11);
  if (!Request)
  {
    sub_1008F03CC();
    int v16 = qword_101B0E138;
    if (!os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT)) {
      return sub_1000558F4((const void **)&v23);
    }
    LOWORD(theString) = 0;
    char v17 = "#I RedirectProbe - httpMessage invalid";
    goto LABEL_26;
  }
  CFReadStreamRef *v3 = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, Request);
  CFRelease(Request);
  if (!*v3)
  {
    sub_1008F03CC();
    int v16 = qword_101B0E138;
    if (!os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT)) {
      return sub_1000558F4((const void **)&v23);
    }
    LOWORD(theString) = 0;
    char v17 = "#I RedirectProbe - fReadStream invalid";
    goto LABEL_26;
  }
  if (!CFReadStreamSetProperty(*v3, kCFStreamPropertyDataConnectionServiceType, kCTDataConnectionServiceTypeInternalDataProbe))
  {
    sub_1008F03CC();
    std::string::size_type v18 = qword_101B0E138;
    if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(theString) = 0;
      uint64_t v19 = "#I RedirectProbe - unable to set stream property";
LABEL_31:
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&theString, 2u);
    }
LABEL_32:
    long long v20 = CFRunLoopGetMain();
    sub_1009165E8(v3, v20);
    return sub_1000558F4((const void **)&v23);
  }
  if (!CFReadStreamSetClient(*v3, 0x1BuLL, (CFReadStreamClientCallBack)sub_1008F0468, &clientContext))
  {
    sub_1008F03CC();
    std::string::size_type v18 = qword_101B0E138;
    if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(theString) = 0;
      uint64_t v19 = "#I RedirectProbe - Unable to set read stream client";
      goto LABEL_31;
    }
    goto LABEL_32;
  }
  uint64_t v13 = *v3;
  uint64_t v14 = CFRunLoopGetMain();
  CFReadStreamScheduleWithRunLoop(v13, v14, kCFRunLoopCommonModes);
  if (CFReadStreamOpen(*v3))
  {
    *(unsigned char *)(a1 + 80) = 1;
    int v15 = sub_1008F0738(a1);
    sub_1008F0554(a1, v15);
  }
  sub_1008F03CC();
  int v16 = qword_101B0E138;
  if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(theString) = 0;
    char v17 = "#I RedirectProbe -Unable to open read stream";
    goto LABEL_26;
  }
  return sub_1000558F4((const void **)&v23);
}

void sub_1008F037C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1008F03CC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0E140, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0E140))
  {
    LogGroupName = (const char *)sGetLogGroupName();
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0E138, kCtLoggingSystemName, LogGroupName);
    __cxa_guard_release(&qword_101B0E140);
  }
}

void sub_1008F0450(_Unwind_Exception *a1)
{
}

void sub_1008F0468(uint64_t a1, uint64_t a2, int a3)
{
  if (qword_101B14190)
  {
    uint64_t v6 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v6)
    {
      uint64_t v7 = v6;
      if (DataPlanManagerBootstrap::sInstance)
      {
        sub_1008EE928(&queue);
        v8[0] = _NSConcreteStackBlock;
        v8[1] = 0x40000000;
        void v8[2] = sub_1008F083C;
        v8[3] = &unk_101A18C58;
        int v9 = a3;
        v8[4] = a1;
        v8[5] = a2;
        dispatch_async(queue, v8);
        if (queue) {
          dispatch_release(queue);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1008F0540(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1008F0554(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 96)) {
    sub_1009165A4((uint64_t *)(a1 + 96));
  }
  sub_1008F03CC();
  uint64_t v3 = qword_101B0E138;
  if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    int v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I RedirectionDataPlanManager - scheduling network time out of %d seconds", buf, 8u);
  }
  operator new();
}

void sub_1008F06DC(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008F0738(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v2) {
    return 5;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 5;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8))(v5);
    if ((v6 & 0xFF00000000) != 0) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 5;
    }
  }
  else
  {
    uint64_t v7 = 5;
  }
  sub_10004D2C8(v4);
  return v7;
}

void sub_1008F07C0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1008F07D4(uint64_t a1)
{
  uint64_t v2 = (CFReadStreamRef *)(a1 + 88);
  Main = CFRunLoopGetMain();
  sub_1009165E8(v2, Main);
  sub_1009165A4((uint64_t *)(a1 + 96));
  uint64_t v4 = *(const void **)(a1 + 104);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 104) = 0;
  }
  *(_DWORD *)(a1 + 64) = 0;

  return sub_1008EE79C((uint64_t *)(a1 + 72), 0);
}

void sub_1008F083C(uint64_t a1)
{
  if (qword_101B0E150)
  {
    uint64_t v2 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B0E150);
    if (v2)
    {
      uint64_t v3 = v2;
      uint64_t v4 = qword_101B0E148;
      if (!qword_101B0E148 || *(_DWORD *)(a1 + 48) != *(_DWORD *)(qword_101B0E148 + 84)) {
        goto LABEL_42;
      }
      sub_1008F03CC();
      uint64_t v5 = qword_101B0E138;
      if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 134217984;
        *(void *)&uint8_t buf[4] = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I RedirectProbe::readStreamCallback: processing stream callback for stream %p", buf, 0xCu);
      }
      uint64_t v7 = *(void *)(a1 + 40);
      sub_1008F03CC();
      uint64_t v8 = qword_101B0E138;
      if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(v4 + 88);
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = v9;
        __int16 v35 = 1024;
        int v36 = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I RedirectProbe::handleReadStreamCallback: handling read stream callback with fReadStream of %p of type %d", buf, 0x12u);
      }
      if (v7 > 7)
      {
        if (v7 != 8)
        {
          if (v7 != 16)
          {
LABEL_42:
            sub_10004D2C8(v3);
            return;
          }
          sub_1008F03CC();
          uint64_t v13 = qword_101B0E138;
          if (!os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_21;
          }
          *(_WORD *)buf = 0;
          uint64_t v14 = "#I read stream end occured, terminating stream";
          int v15 = v13;
          goto LABEL_20;
        }
        sub_1008F03CC();
        char v17 = qword_101B0E138;
        if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I read stream error occured", buf, 2u);
        }
        std::string::size_type v18 = *(__CFReadStream **)(v4 + 88);
        if (v18)
        {
          uint64_t v19 = CFReadStreamCopyError(v18);
          *(void *)buf = v19;
          if (v19) {
            long long v20 = sub_10039195C;
          }
          else {
            long long v20 = 0;
          }
          if (v20)
          {
            CFStringRef Domain = CFErrorGetDomain(v19);
            if (Domain == kCFErrorDomainCFNetwork
              || CFErrorGetCode(*(CFErrorRef *)buf) == 2
              || Domain == kCFErrorDomainPOSIX)
            {
              unsigned int v22 = *(_DWORD *)(v4 + 64) + 1;
              *(_DWORD *)(v4 + 64) = v22;
              if (v22 < (*(unsigned int (**)(uint64_t))(*(void *)v4 + 40))(v4))
              {
                sub_1008F03CC();
                CFStringRef v23 = qword_101B0E138;
                if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
                {
                  int v24 = *(_DWORD *)(v4 + 64);
                  v33[0] = 67109120;
                  v33[1] = v24;
                  _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I retrying http probe, retry count = %d", (uint8_t *)v33, 8u);
                }
                sub_100127D74((const void **)buf);
                sub_1009165A4((uint64_t *)(v4 + 96));
                sub_1008EE56C(v4, 0, 250);
              }
            }
          }
          sub_100127D74((const void **)buf);
        }
        sub_1008F03CC();
        uint64_t v25 = qword_101B0E138;
        BOOL v26 = os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT);
        int v16 = 0;
        if (!v26) {
          goto LABEL_41;
        }
        int v27 = *(_DWORD *)(v4 + 64);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v27;
        xpc_object_t v28 = "#I terminating stream due to stream error(s), retry count = %d";
        xpc_object_t v29 = v25;
        uint32_t v30 = 8;
      }
      else
      {
        if (v7 == 1) {
          goto LABEL_15;
        }
        if (v7 != 2) {
          goto LABEL_42;
        }
        CFIndex v10 = CFReadStreamRead(*(CFReadStreamRef *)(v4 + 88), (UInt8 *)(v4 + 112), 0x4000);
        if (v10 >= 1)
        {
          sub_1008F03CC();
          CFURLRef v11 = qword_101B0E138;
          if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v10;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I read %d bytes from read stream, extending network timeout", buf, 8u);
          }
LABEL_15:
          int v12 = sub_1008F0738(v4);
          sub_1008F0554(v4, v12);
        }
        sub_1008F03CC();
        uint64_t v31 = qword_101B0E138;
        BOOL v32 = os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT);
        if ((v10 & 0x8000000000000000) == 0)
        {
          if (!v32) {
            goto LABEL_21;
          }
          *(_WORD *)buf = 0;
          uint64_t v14 = "#I read zero bytes, assuming stream is complete";
          int v15 = v31;
LABEL_20:
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, buf, 2u);
LABEL_21:
          int v16 = 1;
LABEL_41:
          sub_1008F0CD8(v4, v16);
          goto LABEL_42;
        }
        if (!v32)
        {
LABEL_40:
          int v16 = 0;
          goto LABEL_41;
        }
        *(_WORD *)buf = 0;
        xpc_object_t v28 = "#I Read less than zero bytes, terminating read stream";
        xpc_object_t v29 = v31;
        uint32_t v30 = 2;
      }
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v28, buf, v30);
      goto LABEL_40;
    }
  }
}

void sub_1008F0CAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100127D74((const void **)va);
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

void sub_1008F0CD8(uint64_t a1, int a2)
{
  sub_1009165A4((uint64_t *)(a1 + 96));
  uint64_t v4 = *(__CFReadStream **)(a1 + 88);
  if (v4)
  {
    uint64_t v5 = (__CFHTTPMessage *)CFReadStreamCopyProperty(v4, kCFStreamPropertyHTTPResponseHeader);
    if (v5)
    {
      uint64_t v6 = v5;
      CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v5);
      CFStringRef v8 = CFHTTPMessageCopyResponseStatusLine(v6);
      *(void *)(a1 + 104) = v8;
      if (v8)
      {
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)long long __p = 0u;
        uint64_t v21 = 0;
        sub_1008F03CC();
        uint64_t v9 = qword_101B0E138;
        if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex v10 = __p;
          if (v21 < 0) {
            CFIndex v10 = (void **)__p[0];
          }
          *(_DWORD *)buf = 134218242;
          *(void *)&uint8_t buf[4] = ResponseStatusCode;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I RedirectProbe - stream response error of %ld %s", buf, 0x16u);
        }
        CFRelease(*(CFTypeRef *)(a1 + 104));
        *(void *)(a1 + 104) = 0;
        BOOL v11 = ResponseStatusCode == 200;
        if (SHIBYTE(v21) < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        BOOL v11 = 0;
      }
      CFRelease(v6);
      uint64_t v13 = 0;
    }
    else
    {
      sub_1008F03CC();
      uint64_t v14 = qword_101B0E138;
      if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I no http response from redirect test", buf, 2u);
      }
      BOOL v11 = 0;
      uint64_t v13 = 1;
    }
  }
  else
  {
    sub_1008F03CC();
    int v12 = qword_101B0E138;
    if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I read stream was null in read stream callback", buf, 2u);
    }
    uint64_t v13 = 0;
    BOOL v11 = 0;
  }
  Main = CFRunLoopGetMain();
  sub_1009165E8((CFReadStreamRef *)(a1 + 88), Main);
  sub_1008EE79C((uint64_t *)(a1 + 72), 0);
  *(_DWORD *)(a1 + 64) = 0;
  int v16 = *(std::__shared_weak_count **)(a1 + 48);
  if (v16 && (char v17 = std::__shared_weak_count::lock(v16)) != 0)
  {
    std::string::size_type v18 = v17;
    if (*(unsigned char *)(a1 + 80))
    {
      uint64_t v19 = *(void (****)(void, void, uint64_t, void))(a1 + 40);
      if (v19) {
        (**v19)(v19, a2 & v11, v13, 0);
      }
    }
    *(unsigned char *)(a1 + 80) = 0;
    sub_10004D2C8(v18);
  }
  else
  {
    *(unsigned char *)(a1 + 80) = 0;
  }
}

void sub_1008F0F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

void sub_1008F0FC4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 96))
  {
    sub_1009165A4((uint64_t *)(v1 + 96));
    sub_1008F03CC();
    uint64_t v2 = qword_101B0E138;
    if (os_log_type_enabled((os_log_t)qword_101B0E138, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I RedirectProbe - terminating stream due to network timeout", v3, 2u);
    }
    sub_1008F0CD8(v1, 0);
  }
}

uint64_t sub_1008F104C()
{
  return __cxa_atexit((void (*)(void *))sub_1008EFDE8, &qword_101B0E148, (void *)&_mh_execute_header);
}

uint64_t sub_1008F1070(uint64_t a1)
{
  return a1;
}

void sub_1008F109C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1008F180C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, SubscriberSimCommandDriverDelegateInterface *a12, ctu::OsLogLogger *a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,dispatch_object_t object,dispatch_object_t a22,dispatch_object_t a23,dispatch_object_t a24,dispatch_object_t a25,void *a26,std::__shared_weak_count *a27,int a28,__int16 a29,char a30,char a31)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8))(__p);
  }
  if (a27) {
    sub_10004D2C8(a27);
  }
  sub_10004D2C8(v31);
  _Unwind_Resume(a1);
}

const char *sub_1008F1BE8(int a1)
{
  uint64_t v1 = "subscr.sim.?";
  if (a1 == 2) {
    uint64_t v1 = "subscr.sim.2";
  }
  if (a1 == 1) {
    return "subscr.sim.1";
  }
  else {
    return v1;
  }
}

void *sub_1008F1C14(uint64_t a1)
{
  sub_1000886C0(a1 + 32, *(char **)(a1 + 40));

  return sub_1000882E8((void *)a1);
}

uint64_t sub_1008F1C54(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1008F1CB4(uint64_t a1)
{
  sub_1008FD57C(*(char **)(a1 + 40));

  return sub_1008FD5E0((void *)a1);
}

void *sub_1008F1CF0(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 32);
  sub_10008A88C(&v3);
  return sub_1008FD664((void *)a1);
}

uint64_t sub_1008F1D30(uint64_t a1)
{
  *(void *)a1 = off_101A18CC0;
  uint64_t v2 = (SubscriberSimCommandDriverDelegateInterface *)(a1 + 48);
  *(void *)(a1 + 48) = off_101A18E68;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 976);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1008FD430(a1 + 912);
  sub_1000DA2E4(*(char **)(a1 + 896));
  sub_100087F94(a1 + 864, *(void **)(a1 + 872));
  sub_10019D5B8(a1 + 840, *(void **)(a1 + 848));
  uint64_t v14 = (void **)(a1 + 808);
  sub_1000C56F4(&v14);
  sub_100903B24(a1 + 744);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 736);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1000886C0(a1 + 704, *(char **)(a1 + 712));
  sub_1000882E8((void *)(a1 + 672));
  sub_1000346F8(a1 + 648, *(void **)(a1 + 656));
  sub_10041A760((void *)(a1 + 616));
  sub_10024D0B4(*(void **)(a1 + 600));
  sub_1000346F8(a1 + 568, *(void **)(a1 + 576));
  sub_1000346F8(a1 + 544, *(void **)(a1 + 552));
  sub_1000886C0(a1 + 520, *(char **)(a1 + 528));
  sub_1000886C0(a1 + 496, *(char **)(a1 + 504));
  if (*(unsigned char *)(a1 + 488) && *(char *)(a1 + 487) < 0) {
    operator delete(*(void **)(a1 + 464));
  }
  sub_1000346F8(a1 + 416, *(void **)(a1 + 424));
  sub_1000346F8(a1 + 392, *(void **)(a1 + 400));
  sub_10041A760((void *)(a1 + 360));
  sub_1008FD57C(*(char **)(a1 + 344));
  sub_1008FD5E0((void *)(a1 + 304));
  uint64_t v14 = (void **)(a1 + 280);
  sub_10008A88C(&v14);
  sub_1008FD664((void *)(a1 + 248));
  uint64_t v14 = (void **)(a1 + 224);
  sub_10008A88C(&v14);
  sub_1008FD664((void *)(a1 + 192));
  uint64_t v14 = (void **)(a1 + 168);
  sub_10077EE24(&v14);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 160);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 144);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 128);
  if (v7) {
    sub_10004D2C8(v7);
  }
  CFStringRef v8 = *(std::__shared_weak_count **)(a1 + 112);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  CFIndex v10 = *(std::__shared_weak_count **)(a1 + 88);
  if (v10) {
    sub_10004D2C8(v10);
  }
  BOOL v11 = *(std::__shared_weak_count **)(a1 + 72);
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v12 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  SubscriberSimCommandDriverDelegateInterface::~SubscriberSimCommandDriverDelegateInterface(v2);
  SubscriberSimInterface::~SubscriberSimInterface((SubscriberSimInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_1008F1FC8(uint64_t a1)
{
  return sub_1008F1D30(a1 - 48);
}

void sub_1008F1FD0(uint64_t a1)
{
  sub_1008F1D30(a1);

  operator delete();
}

void sub_1008F2008(uint64_t a1)
{
  sub_1008F1D30(a1 - 48);

  operator delete();
}

void sub_1008F2044(uint64_t a1, dispatch_object_t object)
{
  uint64_t v3 = (void *)(a1 + 8);
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_1008F216C(char **a1)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = qword_101B0E160;
  if ((_UNKNOWN *)qword_101B0E160 == &unk_101B0E168)
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v4 = a1 + 2;
    do
    {
      int v5 = *(_DWORD *)(v2 + 28);
      if ((unint64_t)v3 >= *v4)
      {
        uint64_t v6 = *a1;
        uint64_t v7 = (v3 - *a1) >> 2;
        unint64_t v8 = v7 + 1;
        if ((unint64_t)(v7 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v9 = *v4 - (void)v6;
        if (v9 >> 1 > v8) {
          unint64_t v8 = v9 >> 1;
        }
        if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v10 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v10 = v8;
        }
        if (v10)
        {
          BOOL v11 = (char *)sub_10005ECD8((uint64_t)(a1 + 2), v10);
          uint64_t v6 = *a1;
          uint64_t v3 = a1[1];
        }
        else
        {
          BOOL v11 = 0;
        }
        uint64_t v12 = &v11[4 * v7];
        *(_DWORD *)uint64_t v12 = v5;
        uint64_t v13 = v12 + 4;
        while (v3 != v6)
        {
          int v14 = *((_DWORD *)v3 - 1);
          v3 -= 4;
          *((_DWORD *)v12 - 1) = v14;
          v12 -= 4;
        }
        *a1 = v12;
        a1[1] = v13;
        a1[2] = &v11[4 * v10];
        if (v6) {
          operator delete(v6);
        }
        uint64_t v3 = v13;
      }
      else
      {
        *(_DWORD *)uint64_t v3 = v5;
        v3 += 4;
      }
      a1[1] = v3;
      int v15 = *(void **)(v2 + 8);
      if (v15)
      {
        do
        {
          int v16 = v15;
          int v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          int v16 = *(void **)(v2 + 16);
          BOOL v17 = *v16 == v2;
          uint64_t v2 = (uint64_t)v16;
        }
        while (!v17);
      }
      uint64_t v2 = (uint64_t)v16;
    }
    while (v16 != (void *)&unk_101B0E168);
  }
  uint64_t v18 = qword_101B0E178;
  if ((_UNKNOWN *)qword_101B0E178 != &unk_101B0E180)
  {
    uint64_t v19 = a1 + 2;
    do
    {
      int v20 = *(_DWORD *)(v18 + 28);
      if ((unint64_t)v3 >= *v19)
      {
        uint64_t v21 = *a1;
        uint64_t v22 = (v3 - *a1) >> 2;
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v24 = *v19 - (void)v21;
        if (v24 >> 1 > v23) {
          unint64_t v23 = v24 >> 1;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25)
        {
          BOOL v26 = (char *)sub_10005ECD8((uint64_t)(a1 + 2), v25);
          uint64_t v21 = *a1;
          uint64_t v3 = a1[1];
        }
        else
        {
          BOOL v26 = 0;
        }
        int v27 = &v26[4 * v22];
        *(_DWORD *)int v27 = v20;
        xpc_object_t v28 = v27 + 4;
        while (v3 != v21)
        {
          int v29 = *((_DWORD *)v3 - 1);
          v3 -= 4;
          *((_DWORD *)v27 - 1) = v29;
          v27 -= 4;
        }
        *a1 = v27;
        a1[1] = v28;
        a1[2] = &v26[4 * v25];
        if (v21) {
          operator delete(v21);
        }
        uint64_t v3 = v28;
      }
      else
      {
        *(_DWORD *)uint64_t v3 = v20;
        v3 += 4;
      }
      a1[1] = v3;
      uint32_t v30 = *(void **)(v18 + 8);
      if (v30)
      {
        do
        {
          uint64_t v31 = v30;
          uint32_t v30 = (void *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          uint64_t v31 = *(void **)(v18 + 16);
          BOOL v17 = *v31 == v18;
          uint64_t v18 = (uint64_t)v31;
        }
        while (!v17);
      }
      uint64_t v18 = (uint64_t)v31;
    }
    while (v31 != (void *)&unk_101B0E180);
  }
  uint64_t v32 = qword_101B0E190;
  if ((_UNKNOWN *)qword_101B0E190 != &unk_101B0E198)
  {
    xpc_object_t v33 = a1 + 2;
    do
    {
      int v34 = *(_DWORD *)(v32 + 28);
      if ((unint64_t)v3 >= *v33)
      {
        __int16 v35 = *a1;
        uint64_t v36 = (v3 - *a1) >> 2;
        unint64_t v37 = v36 + 1;
        if ((unint64_t)(v36 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v38 = *v33 - (void)v35;
        if (v38 >> 1 > v37) {
          unint64_t v37 = v38 >> 1;
        }
        if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v39 = v37;
        }
        if (v39)
        {
          xpc_object_t v40 = (char *)sub_10005ECD8((uint64_t)(a1 + 2), v39);
          __int16 v35 = *a1;
          uint64_t v3 = a1[1];
        }
        else
        {
          xpc_object_t v40 = 0;
        }
        int v41 = &v40[4 * v36];
        *(_DWORD *)int v41 = v34;
        xpc_object_t v42 = v41 + 4;
        while (v3 != v35)
        {
          int v43 = *((_DWORD *)v3 - 1);
          v3 -= 4;
          *((_DWORD *)v41 - 1) = v43;
          v41 -= 4;
        }
        *a1 = v41;
        a1[1] = v42;
        a1[2] = &v40[4 * v39];
        if (v35) {
          operator delete(v35);
        }
        uint64_t v3 = v42;
      }
      else
      {
        *(_DWORD *)uint64_t v3 = v34;
        v3 += 4;
      }
      a1[1] = v3;
      unint64_t v44 = *(void **)(v32 + 8);
      if (v44)
      {
        do
        {
          size_t v45 = v44;
          unint64_t v44 = (void *)*v44;
        }
        while (v44);
      }
      else
      {
        do
        {
          size_t v45 = *(void **)(v32 + 16);
          BOOL v17 = *v45 == v32;
          uint64_t v32 = (uint64_t)v45;
        }
        while (!v17);
      }
      uint64_t v32 = (uint64_t)v45;
    }
    while (v45 != (void *)&unk_101B0E198);
  }
  uint64_t v46 = qword_101B0E1A8;
  if ((_UNKNOWN *)qword_101B0E1A8 != &unk_101B0E1B0)
  {
    unsigned int v47 = a1 + 2;
    do
    {
      int v48 = *(_DWORD *)(v46 + 28);
      if ((unint64_t)v3 >= *v47)
      {
        unsigned __int8 v49 = *a1;
        uint64_t v50 = (v3 - *a1) >> 2;
        unint64_t v51 = v50 + 1;
        if ((unint64_t)(v50 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v52 = *v47 - (void)v49;
        if (v52 >> 1 > v51) {
          unint64_t v51 = v52 >> 1;
        }
        if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v53 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v53 = v51;
        }
        if (v53)
        {
          uint64_t v54 = (char *)sub_10005ECD8((uint64_t)(a1 + 2), v53);
          unsigned __int8 v49 = *a1;
          uint64_t v3 = a1[1];
        }
        else
        {
          uint64_t v54 = 0;
        }
        CFStringRef v55 = &v54[4 * v50];
        *(_DWORD *)CFStringRef v55 = v48;
        BOOL v56 = v55 + 4;
        while (v3 != v49)
        {
          int v57 = *((_DWORD *)v3 - 1);
          v3 -= 4;
          *((_DWORD *)v55 - 1) = v57;
          v55 -= 4;
        }
        *a1 = v55;
        a1[1] = v56;
        a1[2] = &v54[4 * v53];
        if (v49) {
          operator delete(v49);
        }
        uint64_t v3 = v56;
      }
      else
      {
        *(_DWORD *)uint64_t v3 = v48;
        v3 += 4;
      }
      a1[1] = v3;
      uint64_t v58 = *(void **)(v46 + 8);
      if (v58)
      {
        do
        {
          uint64_t v59 = v58;
          uint64_t v58 = (void *)*v58;
        }
        while (v58);
      }
      else
      {
        do
        {
          uint64_t v59 = *(void **)(v46 + 16);
          BOOL v17 = *v59 == v46;
          uint64_t v46 = (uint64_t)v59;
        }
        while (!v17);
      }
      uint64_t v46 = (uint64_t)v59;
    }
    while (v59 != (void *)&unk_101B0E1B0);
  }
  unint64_t v60 = (unint64_t)a1[2];
  if ((unint64_t)v3 >= v60)
  {
    char v62 = *a1;
    uint64_t v63 = (v3 - *a1) >> 2;
    unint64_t v64 = v63 + 1;
    if ((unint64_t)(v63 + 1) >> 62) {
      sub_10006A748();
    }
    uint64_t v65 = v60 - (void)v62;
    if (v65 >> 1 > v64) {
      unint64_t v64 = v65 >> 1;
    }
    if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v66 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v66 = v64;
    }
    if (v66)
    {
      v67 = (char *)sub_10005ECD8((uint64_t)(a1 + 2), v66);
      char v62 = *a1;
      uint64_t v3 = a1[1];
    }
    else
    {
      v67 = 0;
    }
    char v68 = &v67[4 * v63];
    __int16 v69 = &v67[4 * v66];
    *(_DWORD *)char v68 = 9;
    uint64_t v61 = v68 + 4;
    while (v3 != v62)
    {
      int v70 = *((_DWORD *)v3 - 1);
      v3 -= 4;
      *((_DWORD *)v68 - 1) = v70;
      v68 -= 4;
    }
    *a1 = v68;
    a1[1] = v61;
    a1[2] = v69;
    if (v62) {
      operator delete(v62);
    }
  }
  else
  {
    *(_DWORD *)uint64_t v3 = 9;
    uint64_t v61 = v3 + 4;
  }
  a1[1] = v61;
}

void sub_1008F26A4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008F26E0(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/device_types");
  v4[0] = off_101A195C8;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1008F2794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1008F27C0(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(unsigned char *)(a1 + 452))
  {
    memset(v18, 0, sizeof(v18));
    uint64_t v4 = *(uint64_t **)(a1 + 168);
    int v5 = *(uint64_t **)(a1 + 176);
    if (v4 == v5) {
      goto LABEL_27;
    }
    do
    {
      sub_1013B8E08(*v4, a3, (uint64_t)v19);
      sub_1008FDFF4(v18, (uint64_t)v19);
      if (v30 < 0) {
        operator delete(__p);
      }
      if (v28 < 0) {
        operator delete(v27);
      }
      if (v26 < 0) {
        operator delete(v25);
      }
      if (v24 < 0) {
        operator delete(v23);
      }
      uint64_t v31 = (void **)&v22;
      sub_10002E39C(&v31);
      if (v20)
      {
        uint64_t v21 = v20;
        operator delete(v20);
      }
      v4 += 2;
    }
    while (v4 != v5);
    uint64_t v6 = *(uint64_t **)(a1 + 168);
    uint64_t v7 = *(uint64_t **)(a1 + 176);
    if (v6 == v7) {
      goto LABEL_27;
    }
    char v8 = 0;
    do
    {
      if (!*(unsigned char *)(a1 + 452)) {
        sub_10016C840();
      }
      if ((SubscriptionSlotConfiguration::contains() & 1) == 0 && sub_1013B84D4(*v6, 1))
      {
        uint64_t v9 = (std::__shared_weak_count *)v6[1];
        v17[0] = *v6;
        v17[1] = (uint64_t)v9;
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1008FA5C0(a1, v17);
        if (v9) {
          sub_10004D2C8(v9);
        }
        char v8 = 1;
      }
      v6 += 2;
    }
    while (v6 != v7);
    if ((v8 & 1) == 0)
    {
LABEL_27:
      int v12 = 0;
    }
    else
    {
      sub_1008F77B8(a1, a2, a3);
      sub_1008F9694(a1, v10, v11);
      int v12 = 1;
    }
    uint64_t v13 = *(uint64_t **)(a1 + 168);
    int v14 = *(uint64_t **)(a1 + 176);
    while (v13 != v14)
    {
      if (!*(unsigned char *)(a1 + 452)) {
        sub_10016C840();
      }
      if (SubscriptionSlotConfiguration::contains()) {
        v12 |= sub_1013B84D4(*v13, 0);
      }
      v13 += 2;
    }
    if (v12)
    {
      sub_1008F77B8(a1, a2, a3);
      sub_1008F9694(a1, v15, v16);
      sub_1008F8114(a1, (uint64_t)v18);
    }
    v19[0] = (void **)v18;
    sub_10008A88C(v19);
  }
}

void sub_1008F29C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  *(void *)(v12 - 72) = &a12;
  sub_10008A88C((void ***)(v12 - 72));
  _Unwind_Resume(a1);
}

void sub_1008F2A18(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/prefs-nb/user_default_voice_slot");
  v4[0] = off_101A197C8;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1008F2ACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1008F2AF8(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/carrier_bundles");
  v4[0] = off_101A198C8;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1008F2BAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1008F2BD8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    char v3 = *(void **)(a1 + 784);
    *(_DWORD *)buf = 134217984;
    uint64_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I outstanding authentication requests: %zu", buf, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 728);
  if (v4)
  {
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v19 = *(_DWORD *)(v4 + 68) == 2;
      uint64_t v7 = printers::asString((printers *)&v19, v6);
      *(_DWORD *)buf = 136315138;
      uint64_t v21 = (void *)v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I baseband booted assertion granted: %s", buf, 0xCu);
    }
  }
  sub_1008F2E04((const void **)a1);
  char v8 = *(uint64_t **)(a1 + 168);
  uint64_t v9 = *(uint64_t **)(a1 + 176);
  while (v8 != v9)
  {
    uint64_t v10 = *v8;
    v8 += 2;
    sub_1013BA1A8(v10);
  }
  unint64_t v11 = *(void **)(a1 + 888);
  if (v11 != (void *)(a1 + 896))
  {
    do
    {
      uint64_t v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = v11 + 4;
        if (*((char *)v11 + 55) < 0) {
          uint64_t v13 = (void *)*v13;
        }
        uint64_t v14 = printers::asString();
        *(_DWORD *)buf = 136315394;
        uint64_t v21 = v13;
        __int16 v22 = 2080;
        uint64_t v23 = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I sim (%s), pin initial active state (%s)", buf, 0x16u);
      }
      uint64_t v15 = (void *)v11[1];
      if (v15)
      {
        do
        {
          unint64_t v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          unint64_t v16 = (void *)v11[2];
          BOOL v17 = *v16 == (void)v11;
          unint64_t v11 = v16;
        }
        while (!v17);
      }
      unint64_t v11 = v16;
    }
    while (v16 != (void *)(a1 + 896));
  }
  return (***(uint64_t (****)(void))(a1 + 104))(*(void *)(a1 + 104));
}

const void **sub_1008F2E04(const void **result)
{
  if (*((unsigned char *)result + 800))
  {
    uint64_t v1 = result;
    CFDateFormatterRef ISO8601Formatter = CFDateFormatterCreateISO8601Formatter(kCFAllocatorDefault, 0x333uLL);
    CFDateFormatterRef v8 = ISO8601Formatter;
    if (ISO8601Formatter) {
      char v3 = sub_1008FBAC8;
    }
    else {
      char v3 = 0;
    }
    if (v3)
    {
      CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(kCFAllocatorDefault, ISO8601Formatter, *((CFAbsoluteTime *)v1 + 99));
      CFStringRef v7 = StringWithAbsoluteTime;
      int v5 = v1[5];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        CStringPtr = CFStringGetCStringPtr(StringWithAbsoluteTime, 0x8000100u);
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I response pending for auth request sent at: %s", buf, 0xCu);
      }
      sub_1000558F4((const void **)&v7);
    }
    else
    {
      uint64_t v6 = v1[5];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "failed to create date formatter", buf, 2u);
      }
    }
    return sub_100201E7C((const void **)&v8);
  }
  return result;
}

void sub_1008F2F5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_1008F2F80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_1008F30A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1008F30AC(uint64_t a1, void *a2)
{
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, (void *)(a1 + 8));
  operator new();
}

void sub_1008F31CC(uint64_t a1, void *a2)
{
}

void sub_1008F31D4(uint64_t a1, uint64_t a2, long long *a3)
{
  char v3 = (void *)(a1 + 8);
  sub_1000593FC((uint64_t)&__p, a3);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, v3);
  operator new();
}

void sub_1008F3300(uint64_t a1, uint64_t a2, long long *a3)
{
}

void sub_1008F3308(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  sub_100908B8C(&v3, a2);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void sub_1008F3414(uint64_t a1, void *a2)
{
}

void sub_1008F341C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5, int *a6, int *a7)
{
  memset(v13, 0, sizeof(v13));
  sub_10005C928(v13, *(const void **)(a2 + 16), *(void *)(a2 + 24), *(void *)(a2 + 24) - *(void *)(a2 + 16));
  int v14 = a3;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  char v16 = a5;
  int v17 = *a6;
  char v18 = *((unsigned char *)a6 + 4);
  int v19 = *a7;
  char v20 = *((unsigned char *)a7 + 4);
  v21[0] = 0;
  v21[1] = 0;
  sub_10003E168(v21, (void *)(a1 + 8));
  operator new();
}

void sub_1008F3624(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  int v17 = *v15;
  if (*v15)
  {
    *(void *)(v14 + 32) = v17;
    operator delete(v17);
  }
  sub_10006A6AC(a1);
}

void sub_1008F3668(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5, int *a6, int *a7)
{
}

void sub_1008F3670(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int a5, int *a6, int *a7)
{
  memset(v14, 0, sizeof(v14));
  sub_10005C928(v14, *(const void **)(a2 + 16), *(void *)(a2 + 24), *(void *)(a2 + 24) - *(void *)(a2 + 16));
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  char v16 = a4;
  int v13 = *a6;
  int v17 = a5;
  int v18 = v13;
  char v19 = *((unsigned char *)a6 + 4);
  int v20 = *a7;
  char v21 = *((unsigned char *)a7 + 4);
  v22[0] = 0;
  v22[1] = 0;
  sub_10003E168(v22, (void *)(a1 + 8));
  operator new();
}

void sub_1008F386C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  char v16 = *v14;
  if (*v14)
  {
    *(void *)(v13 + 32) = v16;
    operator delete(v16);
  }
  sub_10006A6AC(a1);
}

void sub_1008F38B0(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int a5, int *a6, int *a7)
{
}

void sub_1008F38B8(uint64_t a1, uint64_t a2, char a3, char a4, uint64_t a5, int *a6, int *a7)
{
  memset(v13, 0, sizeof(v13));
  sub_10005C928(v13, *(const void **)(a2 + 16), *(void *)(a2 + 24), *(void *)(a2 + 24) - *(void *)(a2 + 16));
  char v14 = a3;
  char v15 = a4;
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a5;
    __p[2] = *(void **)(a5 + 16);
  }
  int v17 = *a6;
  char v18 = *((unsigned char *)a6 + 4);
  int v19 = *a7;
  char v20 = *((unsigned char *)a7 + 4);
  v21[0] = 0;
  v21[1] = 0;
  sub_10003E168(v21, (void *)(a1 + 8));
  operator new();
}

void sub_1008F3AC0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  char v16 = *v14;
  if (*v14)
  {
    *(void *)(v13 + 32) = v16;
    operator delete(v16);
  }
  sub_10006A6AC(a1);
}

void sub_1008F3B04(uint64_t a1, uint64_t a2, char a3, char a4, uint64_t a5, int *a6, int *a7)
{
}

void sub_1008F3B0C(uint64_t a1, uint64_t a2, int a3, char *a4)
{
  uint64_t v6 = (void *)(a1 + 8);
  memset(__p, 0, sizeof(__p));
  sub_10005C928(__p, *(const void **)(a2 + 16), *(void *)(a2 + 24), *(void *)(a2 + 24) - *(void *)(a2 + 16));
  int v8 = a3;
  char v9 = *a4;
  v10[0] = 0;
  v10[1] = 0;
  sub_10003E168(v10, v6);
  operator new();
}

void sub_1008F3C7C(uint64_t a1, uint64_t a2, int a3, char *a4)
{
}

void sub_1008F3C84(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  void v7[4] = a1;
  long long v8 = *a2;
  memset(v9, 0, 24);
  sub_10005C928(v9, *((const void **)a2 + 2), *((void *)a2 + 3), *((void *)a2 + 3) - *((void *)a2 + 2));
  v9[3] = *(void **)a3;
  int v10 = *(_DWORD *)(a3 + 8);
  __p[1] = 0;
  uint64_t v12 = 0;
  __p[0] = 0;
  sub_1008FDDC8(__p, *(const void **)(a3 + 16), *(void *)(a3 + 24), (uint64_t)(*(void *)(a3 + 24) - *(void *)(a3 + 16)) >> 2);
  __int16 v13 = *(_WORD *)(a3 + 40);
  sub_10090994C((uint64_t)&v14, a4);
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, (void *)(a1 + 8));
  operator new();
}

void sub_1008F3E98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1008F3EEC(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1008F3EF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v5, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)int v5 = *(_OWORD *)a2;
    void v5[2] = *(void **)(a2 + 16);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, (void *)(a1 + 8));
  operator new();
}

void sub_1008F40B4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (*(char *)(v16 + 31) < 0) {
    operator delete(*v17);
  }
  sub_10006A6AC(a1);
}

void sub_1008F40F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1008F4100(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10090A4BC;
  v7[3] = &unk_101A199B8;
  void v7[4] = a1 + 8;
  void v7[5] = &v5;
  long long v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    unsigned int v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_10090A600;
    uint64_t v12 = &unk_101A199F8;
    __int16 v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    unsigned int v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_10090A5C4;
    uint64_t v12 = &unk_101A199D8;
    __int16 v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

uint64_t sub_1008F4230(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10090A63C;
  v7[3] = &unk_101A19A18;
  void v7[4] = a1 + 8;
  void v7[5] = &v5;
  long long v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_10090A708;
    uint64_t v12 = &unk_101A19A58;
    __int16 v13 = &v15;
    uint64_t v14 = &v8;
    uint64_t v15 = 0;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_10090A6CC;
    uint64_t v12 = &unk_101A19A38;
    __int16 v13 = &v15;
    uint64_t v14 = &v8;
    uint64_t v15 = 0;
    dispatch_sync(v2, &block);
  }
  return v15;
}

void sub_1008F4360(uint64_t a1, void *a2)
{
  void v4[4] = a1;
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      int v6 = v5;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v5);
    }
    else
    {
      int v6 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    int v6 = 0;
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_1008F4550(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1008F456C(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10090A908;
  void v5[3] = &unk_101A19A78;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  int v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    unsigned __int16 v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10090A9A8;
    uint64_t v10 = &unk_101A19AB8;
    unint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned __int16 v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10090A96C;
    uint64_t v10 = &unk_101A19A98;
    unint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

void sub_1008F4694(uint64_t a1, int a2, uint64_t a3)
{
  void v4[4] = a1;
  int v5 = a2;
  sub_10062B11C((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_1008F47D8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1008F47F0(uint64_t a1, uint64_t a2)
{
  void v3[4] = a1;
  sub_1000332B4((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

void sub_1008F4920(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1008F4938(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10090C238;
  void v5[3] = &unk_101A19B58;
  v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_10090C2D8;
    uint64_t v10 = &unk_101A19B98;
    unint64_t v11 = a2;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    char v9 = sub_100003F28;
    uint64_t v10 = &unk_101A19B78;
    unint64_t v11 = a2;
    uint64_t v12 = &v6;
    dispatch_sync(v2, &block);
  }
}

BOOL sub_1008F4A5C(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10090C33C;
  v7[3] = &unk_101A19BB8;
  void v7[4] = a1 + 8;
  void v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_10005AFF0;
    uint64_t v12 = &unk_101A19BF8;
    unsigned __int16 v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_10005A28C;
    uint64_t v12 = &unk_101A19BD8;
    unsigned __int16 v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void *sub_1008F4B94(uint64_t a1)
{
  v2[0] = off_101A19C28;
  v2[1] = a1;
  v2[3] = v2;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)a1 + 88))(a1, 1, v2);
  return sub_1000F25E0(v2);
}

void sub_1008F4C3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000F25E0((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1008F4C50(uint64_t a1, int a2, uint64_t a3)
{
  v5[4] = a1;
  sub_10033571C((uint64_t)v6, a3);
  v6[8] = a2;
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_1008F4D94(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1008F4DAC(uint64_t a1, int a2, char a3, uint64_t a4)
{
  os_activity_t v10 = _os_activity_create((void *)&_mh_execute_header, "sim-pin-enable", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v8.opaque[0] = 0;
  v8.opaque[1] = 0;
  os_activity_scope_enter(v10, &v8);
  os_activity_scope_leave(&v8);
  v8.opaque[0] = a1;
  LODWORD(v8.opaque[1]) = a2;
  BYTE4(v8.opaque[1]) = a3;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  v11[0] = 0;
  v11[1] = 0;
  sub_10003E168(v11, (void *)(a1 + 8));
  operator new();
}

void sub_1008F4F48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100687EB8((void **)va);
  _Unwind_Resume(a1);
}

void sub_1008F4F64(uint64_t a1, int a2, uint64_t a3)
{
  os_activity_t v8 = _os_activity_create((void *)&_mh_execute_header, "sim-pin-unlock", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0;
  v6.opaque[1] = 0;
  os_activity_scope_enter(v8, &v6);
  os_activity_scope_leave(&v6);
  v6.opaque[0] = a1;
  LODWORD(v6.opaque[1]) = a2;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  v9[0] = 0;
  v9[1] = 0;
  sub_10003E168(v9, (void *)(a1 + 8));
  operator new();
}

void sub_1008F50EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100687EB8((void **)va);
  _Unwind_Resume(a1);
}

void sub_1008F5108(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  os_activity_t v11 = _os_activity_create((void *)&_mh_execute_header, "sim-puk-unlock", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v11, &state);
  os_activity_scope_leave(&state);
  state.opaque[0] = a1;
  LODWORD(state.opaque[1]) = a2;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v9, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)char v9 = *(_OWORD *)a3;
    void v9[2] = *(void **)(a3 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  v12[0] = 0;
  v12[1] = 0;
  sub_10003E168(v12, (void *)(a1 + 8));
  operator new();
}

void sub_1008F52F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100687EB8(&a21);
  _Unwind_Resume(a1);
}

void sub_1008F5328(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  os_activity_t v11 = _os_activity_create((void *)&_mh_execute_header, "sim-pin-change", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v11, &state);
  os_activity_scope_leave(&state);
  state.opaque[0] = a1;
  LODWORD(state.opaque[1]) = a2;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v9, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)char v9 = *(_OWORD *)a3;
    void v9[2] = *(void **)(a3 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  v12[0] = 0;
  v12[1] = 0;
  sub_10003E168(v12, (void *)(a1 + 8));
  operator new();
}

void sub_1008F5514(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100687EB8(&a21);
  _Unwind_Resume(a1);
}

void sub_1008F5548(uint64_t a1, int a2, uint64_t a3)
{
  v5[4] = a1;
  sub_100356358((uint64_t)v6, a3);
  v6[8] = a2;
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_1008F568C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1008F56A4(uint64_t a1, int a2, uint64_t a3)
{
  v5[4] = a1;
  sub_100356358((uint64_t)v6, a3);
  v6[8] = a2;
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_1008F57E8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1008F5800(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *a2;
  v6[4] = a1;
  v6[5] = v5;
  sub_10026E7F8(&v7, (uint64_t)(a2 + 1));
  sub_10090DFD0((uint64_t)&v8, a3);
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, (void *)(a1 + 8));
  operator new();
}

void sub_1008F5990(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1008F59C8(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  sub_10090E7FC((uint64_t)&v3, a2);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void sub_1008F5ADC(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = (void *)(a1 + 8);
  sub_10090E7FC((uint64_t)&v4, a3);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, v3);
  operator new();
}

void sub_1008F5C08(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, void *a4@<X8>)
{
  int v7 = a3;
  int v8 = a2;
  v6[0] = a1;
  v6[1] = &v8;
  v6[2] = &v7;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  void v9[2] = sub_10090EAB0;
  v9[3] = &unk_101A19C98;
  void v9[4] = a1 + 8;
  v9[5] = v6;
  os_activity_t v10 = v9;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    unsigned __int16 v13 = sub_10090EB38;
    uint64_t v14 = &unk_101A19CD8;
    char v15 = a4;
    uint64_t v16 = &v10;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    unsigned __int16 v13 = sub_10090EACC;
    uint64_t v14 = &unk_101A19CB8;
    char v15 = a4;
    uint64_t v16 = &v10;
    dispatch_sync(v4, &block);
  }
}

void sub_1008F5D40(uint64_t a1, int a2, int a3, uint64_t a4)
{
  v5[4] = a1;
  int v6 = a2;
  int v7 = a3;
  sub_10090EBA4((uint64_t)&v8, a4);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_1008F5E78(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1008F5E90(uint64_t a1, int a2, int a3, __int16 a4, uint64_t a5, uint64_t a6)
{
  void v7[4] = a1;
  int v6 = (void *)(a1 + 8);
  int v8 = a2;
  int v9 = a3;
  __int16 v10 = a4;
  *(_OWORD *)long long __p = *(_OWORD *)a5;
  uint64_t v12 = *(void *)(a5 + 16);
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  *(void *)(a5 + 16) = 0;
  sub_10090F104((uint64_t)&v13, a6);
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, v6);
  operator new();
}

void sub_1008F6020(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1008F6030(uint64_t a1, int a2, int a3, uint64_t a4)
{
  int v7 = a3;
  int v8 = a2;
  v6[0] = a1;
  v6[1] = &v8;
  v6[2] = &v7;
  void v6[3] = a4;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10090F6C0;
  block[3] = &unk_101A19CF8;
  void block[4] = a1 + 8;
  block[5] = v6;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8)) {
    dispatch_async_and_wait(v4, block);
  }
  else {
    dispatch_sync(v4, block);
  }
}

void sub_1008F60C8(uint64_t a1, int a2, int a3, uint64_t a4)
{
  v5[4] = a1;
  int v6 = a2;
  int v7 = a3;
  sub_10012CA20((uint64_t)&v8, a4);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_1008F6200(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1008F6218(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10090F7F0;
  v7[3] = &unk_101A19D18;
  void v7[4] = a1 + 8;
  void v7[5] = v5;
  uint64_t v8 = v7;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    os_activity_t v11 = sub_10090C2D8;
    uint64_t v12 = &unk_101A19B98;
    uint64_t v13 = a3;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    os_activity_t v11 = sub_100003F28;
    uint64_t v12 = &unk_101A19B78;
    uint64_t v13 = a3;
    uint64_t v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

void sub_1008F6348(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10090F890;
  void v5[3] = &unk_101A19D38;
  v5[4] = a1 + 8;
  void v5[5] = &v4;
  int v6 = v5;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    int v9 = sub_10090C2D8;
    uint64_t v10 = &unk_101A19B98;
    os_activity_t v11 = a2;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    int v9 = sub_100003F28;
    uint64_t v10 = &unk_101A19B78;
    os_activity_t v11 = a2;
    uint64_t v12 = &v6;
    dispatch_sync(v2, &block);
  }
}

void sub_1008F646C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v9 = a2;
  v8[0] = a1;
  v8[1] = &v9;
  void v8[2] = a3;
  v8[3] = a4;
  v8[4] = a5;
  v8[5] = a6;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10090F8F0;
  block[3] = &unk_101A19D58;
  void block[4] = a1 + 8;
  block[5] = v8;
  uint64_t v7 = a1 + 24;
  int v6 = *(NSObject **)(a1 + 24);
  if (*(void *)(v7 + 8)) {
    dispatch_async_and_wait(v6, block);
  }
  else {
    dispatch_sync(v6, block);
  }
}

void sub_1008F6504(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  void v7[4] = a1;
  int v8 = a2;
  int v9 = a3;
  __p[1] = 0;
  uint64_t v11 = 0;
  __p[0] = 0;
  sub_10005C928(__p, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
  sub_1000DFC90((uint64_t)&v12, a5);
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, (void *)(a1 + 8));
  operator new();
}

void sub_1008F6680(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

BOOL sub_1008F66BC(uint64_t a1, int a2, int a3)
{
  int v7 = a3;
  int v8 = a2;
  v6[0] = a1;
  v6[1] = &v8;
  v6[2] = &v7;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  void v9[2] = sub_1009100BC;
  v9[3] = &unk_101A19D78;
  void v9[4] = a1 + 8;
  v9[5] = v6;
  uint64_t v10 = v9;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    uint64_t v13 = sub_10005AFF0;
    uint64_t v14 = &unk_101A19BF8;
    char v15 = &v17;
    uint64_t v16 = &v10;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    uint64_t v13 = sub_10005A28C;
    uint64_t v14 = &unk_101A19BD8;
    char v15 = &v17;
    uint64_t v16 = &v10;
    dispatch_sync(v3, &block);
  }
  return v17 != 0;
}

void sub_1008F6800(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

BOOL sub_1008F68E4(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100910508;
  v7[3] = &unk_101A19D98;
  void v7[4] = a1 + 8;
  void v7[5] = v5;
  int v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005AFF0;
    uint64_t v12 = &unk_101A19BF8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005A28C;
    uint64_t v12 = &unk_101A19BD8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_1008F6A20(uint64_t a1, int a2, uint64_t *a3, uint64_t a4)
{
  void v6[4] = a1;
  int v7 = a2;
  uint64_t v5 = a3[1];
  uint64_t v8 = *a3;
  uint64_t v9 = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90((uint64_t)&v10, a4);
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, (void *)(a1 + 8));
  operator new();
}

void sub_1008F6B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1008F6BC8(uint64_t a1, int a2, uint64_t *a3, char a4, uint64_t *a5, uint64_t a6)
{
  void v9[4] = a1;
  int v10 = a2;
  uint64_t v7 = a3[1];
  uint64_t v11 = *a3;
  uint64_t v12 = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  char v13 = a4;
  uint64_t v8 = a5[1];
  uint64_t v14 = *a5;
  uint64_t v15 = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90((uint64_t)&v16, a6);
  v9[0] = 0;
  v9[1] = 0;
  sub_10003E168(v9, (void *)(a1 + 8));
  operator new();
}

void sub_1008F6D80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1008F6DBC(uint64_t a1, int a2, uint64_t a3)
{
  void v4[4] = a1;
  int v5 = a2;
  sub_1000DFC90((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_1008F6F00(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_1008F6F18(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_1009115F0;
  void v5[3] = &unk_101A19DB8;
  v5[4] = a1 + 8;
  void v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    unsigned __int16 v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10090A9A8;
    int v10 = &unk_101A19AB8;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned __int16 v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10090A96C;
    int v10 = &unk_101A19A98;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

void sub_1008F7040(uint64_t a1, uint64_t a2)
{
  void v3[4] = a1;
  sub_1000DFC90((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

void sub_1008F7170(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

BOOL sub_1008F7188(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10091169C;
  void v5[3] = &unk_101A19DD8;
  v5[4] = a1 + 8;
  void v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005AFF0;
    int v10 = &unk_101A19BF8;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005A28C;
    int v10 = &unk_101A19BD8;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_1008F72B8(uint64_t a1, int a2, const void **a3)
{
  uint64_t v4 = a1 + 8;
  uint64_t v8 = a1;
  int v9 = a2;
  sub_100062740(&v10, a3);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  void v11[2] = sub_1009116F8;
  v11[3] = &unk_101A19DF8;
  v11[4] = v4;
  void v11[5] = &v8;
  uint64_t v12 = v11;
  int v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint64_t v15 = sub_10005AFF0;
    uint64_t v16 = &unk_101A19BF8;
    char v17 = &v19;
    char v18 = &v12;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint64_t v15 = sub_10005A28C;
    uint64_t v16 = &unk_101A19BD8;
    char v17 = &v19;
    char v18 = &v12;
    dispatch_sync(v5, &block);
  }
  BOOL v6 = v19 != 0;
  sub_100044D00(&v10);
  return v6;
}

BOOL sub_1008F7420(const __CFDictionary *a1, const void *a2, const void *a3)
{
  Value = CFDictionaryGetValue(a1, a2);
  if (Value) {
    CFDictionarySetValue(a1, a3, Value);
  }
  return Value != 0;
}

void sub_1008F7470(__CFDictionary *a1, CFTypeRef cf, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    if (!*(void *)(a3 + 8)) {
      return;
    }
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    if (!*(unsigned char *)(a3 + 23)) {
      return;
    }
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v6 = *(void *)(a3 + 16);
  }
  sub_1007157A4(a1, cf);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1008F7500(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008F751C(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  long long __p = 0;
  int v10 = 0;
  uint64_t v11 = 0;
  sub_1008FAB94(&__p, a1, a2, a3);
  switch(a3)
  {
    case 0:
      subscriber::sDecodeIccid((uint64_t *)&v7, (subscriber *)__p, (const unsigned __int8 *)(v10 - (unsigned char *)__p), v6);
      goto LABEL_7;
    case 1:
    case 2:
      ctu::hex((uint64_t *)&v7, (ctu *)__p, (const void *)(v10 - (unsigned char *)__p), v6);
      goto LABEL_7;
    case 3:
      subscriber::sDecodeImsi((uint64_t *)&v7, (subscriber *)__p, (const unsigned __int8 *)(v10 - (unsigned char *)__p), v6);
      goto LABEL_7;
    case 10:
    case 11:
      subscriber::sDecodeUIMID();
      goto LABEL_7;
    case 12:
      subscriber::sDecode1xImsi((uint64_t *)&v7, (subscriber *)__p, (const unsigned __int8 *)(v10 - (unsigned char *)__p), v6);
LABEL_7:
      if (*(char *)(a4 + 23) < 0) {
        operator delete(*(void **)a4);
      }
      *(_OWORD *)a4 = v7;
      *(void *)(a4 + 16) = v8;
      break;
    default:
      break;
  }
  if (__p)
  {
    int v10 = __p;
    operator delete(__p);
  }
}

void sub_1008F7658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008F76BC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 24);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

const void **sub_1008F7704(__CFDictionary *a1, void *cf, unsigned int a3, CFAllocatorRef allocator)
{
  key = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t valuePtr = a3;
  CFNumberRef v7 = CFNumberCreate(allocator, kCFNumberLongLongType, &valuePtr);
  CFNumberRef v10 = v7;
  if (key) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8) {
    CFDictionarySetValue(a1, key, v7);
  }
  sub_10010F494((const void **)&v10);
  return sub_10010F494((const void **)&key);
}

void sub_1008F7794(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  sub_10010F494((const void **)va);
  sub_10010F494((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1008F77B8(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = a1;
  uint64_t v74 = 0;
  unint64_t v75 = 0;
  unint64_t v76 = 0;
  uint64_t v71 = 0;
  unint64_t v72 = 0;
  unint64_t v73 = 0;
  int v5 = *(uint64_t **)(a1 + 168);
  uint64_t v4 = *(uint64_t **)(a1 + 176);
  if (v5 == v4)
  {
    unint64_t v29 = 0;
    uint64_t v28 = 0;
  }
  else
  {
    do
    {
      uint64_t v101 = 0;
      long long v99 = 0u;
      long long __p = 0u;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v95 = 0u;
      long long v96 = 0u;
      memset(v94, 0, sizeof(v94));
      long long cf = 0u;
      long long v93 = 0u;
      sub_1013B8E08(*v5, a3, (uint64_t)&cf);
      if (*(unsigned char *)(v3 + 452))
      {
        int v7 = *(_DWORD *)(v3 + 444);
        if (v7)
        {
          if (v7 == *(_DWORD *)(*v5 + 32))
          {
            LODWORD(cf) = 1;
          }
          else if (*(_DWORD *)(*v5 + 36) == 1)
          {
            LODWORD(cf) = 0;
          }
        }
        if (capabilities::ct::supportsGemini(v6))
        {
          if (!*(unsigned char *)(v3 + 452)) {
            sub_10016C840();
          }
          int v8 = *(_DWORD *)(v3 + 448);
          if (v8)
          {
            if (v8 == *(_DWORD *)(*v5 + 32))
            {
              LODWORD(cf) = 2;
            }
            else if (*(_DWORD *)(*v5 + 36) == 2)
            {
              LODWORD(cf) = 0;
            }
          }
        }
      }
      int v9 = **(NSObject ***)(*v5 + 352);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v64 = subscriber::asString();
        uint64_t v63 = subscriber::asString();
        uint64_t v10 = subscriber::asString();
        uint64_t v11 = subscriber::asString();
        uint64_t v12 = (char *)&v95 + 8;
        if (v96 < 0) {
          uint64_t v12 = (char *)*((void *)&v95 + 1);
        }
        long long v13 = v93;
        memset(&v70, 0, sizeof(v70));
        char v62 = v12;
        if ((void)v93 == *((void *)&v93 + 1))
        {
          std::string::size_type v21 = 0;
          char v20 = 0;
        }
        else
        {
          uint64_t v14 = v4;
          uint64_t v15 = v3;
          uint64_t v16 = (char *)subscriber::asString();
          sub_10003ED78(&v70, v16);
          uint64_t v17 = v13 + 4;
          while ((void)v13 != *((void *)&v13 + 1))
          {
            char v78 = 1;
            strcpy(__s, ",");
            std::string::append(&v70, __s, 1uLL);
            if (v78 < 0) {
              operator delete(*(void **)__s);
            }
            char v18 = (const char *)subscriber::asString();
            size_t v19 = strlen(v18);
            v17 += 4;
            std::string::append(&v70, v18, v19);
          }
          char v20 = HIBYTE(v70.__r_.__value_.__r.__words[2]);
          std::string::size_type v21 = v70.__r_.__value_.__r.__words[0];
          uint64_t v3 = v15;
          uint64_t v4 = v14;
        }
        uint64_t v22 = subscriber::asString();
        *(_DWORD *)buf = 136316674;
        uint64_t v23 = &v70;
        if (v20 < 0) {
          uint64_t v23 = (std::string *)v21;
        }
        *(void *)&uint8_t buf[4] = v64;
        __int16 v80 = 2080;
        uint64_t v81 = v63;
        __int16 v82 = 2080;
        uint64_t v83 = v10;
        __int16 v84 = 2080;
        uint64_t v85 = v11;
        __int16 v86 = 2080;
        uint64_t v87 = v62;
        __int16 v88 = 2082;
        v89 = v23;
        __int16 v90 = 2080;
        uint64_t v91 = v22;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I publishing sim info [slot:%s instance:%s state:%s tray:%s iccid:(%s) types:[%{public}s] vinyl:%s]", buf, 0x48u);
        if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v70.__r_.__value_.__l.__data_);
        }
      }
      if (cf)
      {
        unint64_t v24 = v72;
        if (v72 >= v73)
        {
          uint64_t v25 = sub_10010B668(&v71, (uint64_t)&cf);
        }
        else
        {
          sub_10002E664(v72, (uint64_t)&cf);
          uint64_t v25 = v24 + 168;
        }
        unint64_t v72 = v25;
      }
      unint64_t v26 = v75;
      if (v75 >= v76)
      {
        uint64_t v27 = sub_10010B668(&v74, (uint64_t)&cf);
      }
      else
      {
        sub_10002E664(v75, (uint64_t)&cf);
        uint64_t v27 = v26 + 168;
      }
      unint64_t v75 = v27;
      if (SHIBYTE(v101) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v99) < 0) {
        operator delete(*((void **)&v98 + 1));
      }
      if (SBYTE7(v98) < 0) {
        operator delete((void *)v97);
      }
      if (SHIBYTE(v96) < 0) {
        operator delete(*((void **)&v95 + 1));
      }
      *(void *)buf = &v94[8];
      sub_10002E39C((void ***)buf);
      if ((void)v93)
      {
        *((void *)&v93 + 1) = v93;
        operator delete((void *)v93);
      }
      v5 += 2;
    }
    while (v5 != v4);
    uint64_t v28 = v71;
    unint64_t v29 = v72;
  }
  unint64_t v30 = 126 - 2 * __clz(0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v29 - v28) >> 3));
  if (v29 == v28) {
    uint64_t v31 = 0;
  }
  else {
    uint64_t v31 = v30;
  }
  sub_1008FE130(v28, v29, v31, 1);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v32, *(Registry **)(v3 + 64));
  int v34 = ServiceMap;
  if (v35 < 0)
  {
    uint64_t v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v37 = 5381;
    do
    {
      uint64_t v35 = v37;
      unsigned int v38 = *v36++;
      uint64_t v37 = (33 * v37) ^ v38;
    }
    while (v38);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long cf = v35;
  unint64_t v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)&cf);
  if (v39)
  {
    uint64_t v41 = v39[3];
    xpc_object_t v40 = (std::__shared_weak_count *)v39[4];
    if (v40)
    {
      atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v34);
      atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v40);
      char v42 = 0;
      goto LABEL_62;
    }
  }
  else
  {
    uint64_t v41 = 0;
  }
  std::mutex::unlock(v34);
  xpc_object_t v40 = 0;
  char v42 = 1;
LABEL_62:
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v41 + 16))(v41))
  {
    if ((v42 & 1) == 0) {
      sub_10004D2C8(v40);
    }
    goto LABEL_75;
  }
  int v44 = _os_feature_enabled_impl();
  if ((v42 & 1) == 0) {
    sub_10004D2C8(v40);
  }
  if (!v44)
  {
LABEL_75:
    memset(v66, 0, sizeof(v66));
    sub_10010CB7C(v66, v74, v75, 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v75 - v74) >> 3));
    memset(v65, 0, sizeof(v65));
    sub_10010CB7C(v65, v71, v72, 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v72 - v71) >> 3));
    sub_1008F9810(v3, v66, v65, v55);
    *(void *)&long long cf = v65;
    sub_10008A88C((void ***)&cf);
    *(void *)&long long cf = v66;
    goto LABEL_88;
  }
  size_t v45 = (std::mutex *)Registry::getServiceMap(v43, *(Registry **)(v3 + 64));
  uint64_t v46 = v45;
  if (v47 < 0)
  {
    int v48 = (unsigned __int8 *)(v47 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v49 = 5381;
    do
    {
      uint64_t v47 = v49;
      unsigned int v50 = *v48++;
      uint64_t v49 = (33 * v49) ^ v50;
    }
    while (v50);
  }
  std::mutex::lock(v45);
  *(void *)&long long cf = v47;
  unint64_t v51 = sub_10004D37C(&v46[1].__m_.__sig, (unint64_t *)&cf);
  if (v51)
  {
    uint64_t v53 = v51[3];
    uint64_t v52 = (std::__shared_weak_count *)v51[4];
    if (v52)
    {
      unsigned int v54 = 1;
      atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v46);
      atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v52);
      if (!v53)
      {
LABEL_84:
        sub_10004D2C8(v52);
        goto LABEL_85;
      }
LABEL_79:
      (*(void (**)(long long *__return_ptr, uint64_t, const __CFString *, void, const CFStringRef, const CFStringRef))(*(void *)v53 + 40))(&cf, v53, @"ExplicitSubscriberDelay", kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      BOOL v56 = (unsigned __int8 *)cf;
      unsigned int v54 = 1;
      buf[0] = 1;
      if ((void)cf)
      {
        CFTypeID v57 = CFGetTypeID((CFTypeRef)cf);
        if (v57 == CFNumberGetTypeID())
        {
          ctu::cf::assign((ctu::cf *)buf, v56, v58);
          unsigned int v54 = buf[0];
        }
        else
        {
          unsigned int v54 = 1;
        }
      }
      sub_1000577C4((const void **)&cf);
      if (!v52) {
        goto LABEL_85;
      }
      goto LABEL_84;
    }
    std::mutex::unlock(v46);
    if (v53) {
      goto LABEL_79;
    }
  }
  else
  {
    std::mutex::unlock(v46);
  }
  unsigned int v54 = 1;
LABEL_85:
  uint64_t v59 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
  {
    LODWORD(cf) = 67109120;
    DWORD1(cf) = v54;
    _os_log_error_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "WARNING: Delaying publishing by %u seconds", (uint8_t *)&cf, 8u);
  }
  dispatch_time_t v60 = dispatch_time(0, 1000000000 * v54);
  uint64_t v61 = *(NSObject **)(v3 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1008F972C;
  block[3] = &unk_101A18ED0;
  void block[4] = v3;
  memset(v68, 0, sizeof(v68));
  sub_10010CB7C(v68, v74, v75, 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v75 - v74) >> 3));
  memset(v69, 0, sizeof(v69));
  sub_10010CB7C(v69, v71, v72, 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v72 - v71) >> 3));
  dispatch_after(v60, v61, block);
  *(void *)&long long cf = v69;
  sub_10008A88C((void ***)&cf);
  *(void *)&long long cf = v68;
LABEL_88:
  sub_10008A88C((void ***)&cf);
  *(void *)&long long cf = &v71;
  sub_10008A88C((void ***)&cf);
  *(void *)&long long cf = &v74;
  sub_10008A88C((void ***)&cf);
}

void sub_1008F7FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,char a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char *a63)
{
  if (v63) {
    sub_10004D2C8(v63);
  }
  a63 = &a41;
  sub_10008A88C((void ***)&a63);
  a63 = &a44;
  sub_10008A88C((void ***)&a63);
  _Unwind_Resume(a1);
}

void sub_1008F8114(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 168);
  uint64_t v3 = *(uint64_t **)(a1 + 176);
  if (v2 != v3)
  {
    unint64_t v6 = (void *)(a1 + 600);
    while (1)
    {
      int v8 = *(_DWORD **)a2;
      int v7 = *(_DWORD **)(a2 + 8);
      if (*(_DWORD **)a2 != v7)
      {
        while (v8[1] != *(_DWORD *)(*v2 + 32))
        {
          v8 += 42;
          if (v8 == v7) {
            goto LABEL_31;
          }
        }
      }
      if (v8 == v7) {
        goto LABEL_31;
      }
      if (subscriber::isSimPresent())
      {
        sub_1013B85B4(*v2, v9, v10);
        if ((subscriber::isSimPresent() & 1) == 0) {
          break;
        }
      }
      sub_1013B85B4(*v2, v9, v10);
      if (subscriber::isSimReady())
      {
        if (subscriber::isSimReady())
        {
          uint64_t v11 = *v2;
          if (*v8 != *(_DWORD *)(*v2 + 36)) {
            goto LABEL_15;
          }
        }
      }
LABEL_31:
      v2 += 2;
      if (v2 == v3) {
        return;
      }
    }
    uint64_t v11 = *v2;
LABEL_15:
    uint64_t v12 = *v6;
    if (*v6)
    {
      int v13 = *(_DWORD *)(v11 + 32);
      uint64_t v14 = v6;
      do
      {
        int v15 = *(_DWORD *)(v12 + 32);
        BOOL v16 = v15 < v13;
        if (v15 >= v13) {
          uint64_t v17 = (uint64_t *)v12;
        }
        else {
          uint64_t v17 = (uint64_t *)(v12 + 8);
        }
        if (!v16) {
          uint64_t v14 = (void *)v12;
        }
        uint64_t v12 = *v17;
      }
      while (*v17);
      if (v14 != v6 && v13 >= *((_DWORD *)v14 + 8))
      {
        char v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v11 + 36));
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Forcing all SIM file updates", buf, 2u);
        }
        size_t v19 = (std::__shared_weak_count *)v2[1];
        uint64_t v20 = *v2;
        std::string::size_type v21 = v19;
        if (v19) {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1008F8304(a1, &v20, v14 + 5);
        if (v21) {
          sub_10004D2C8(v21);
        }
      }
    }
    goto LABEL_31;
  }
}

void sub_1008F82EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008F8304(uint64_t a1, void *a2, void *a3)
{
  if (!subscriber::isValidSimSlot()) {
    return;
  }
  unint64_t v6 = (std::__shared_weak_count *)a2[1];
  v68[0] = *a2;
  v68[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1008FA890(a1, (uint64_t)v68, a3);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v8 = *a2;
  int v7 = (std::__shared_weak_count *)a2[1];
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = qword_101B0E190;
  if ((_UNKNOWN *)qword_101B0E190 == &unk_101B0E198)
  {
    char v10 = 1;
    if (!v7) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  if (*(void *)(v8 + 192))
  {
    char v10 = 1;
    while (1)
    {
      int v11 = *(_DWORD *)(v9 + 28);
      uint64_t v12 = v8 + 192;
      uint64_t v13 = *(void *)(v8 + 192);
      do
      {
        int v14 = *(_DWORD *)(v13 + 32);
        BOOL v15 = v14 < v11;
        if (v14 >= v11) {
          BOOL v16 = (uint64_t *)v13;
        }
        else {
          BOOL v16 = (uint64_t *)(v13 + 8);
        }
        if (!v15) {
          uint64_t v12 = v13;
        }
        uint64_t v13 = *v16;
      }
      while (*v16);
      if (v12 == v8 + 192) {
        break;
      }
      if (*(_DWORD *)(v12 + 32) > v11) {
        break;
      }
      BOOL v17 = *(_DWORD *)(v12 + 44) == 3;
      if (!v17) {
        break;
      }
      char v18 = *(void **)(v9 + 8);
      if (v18)
      {
        do
        {
          size_t v19 = v18;
          char v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          size_t v19 = *(void **)(v9 + 16);
          BOOL v33 = *v19 == v9;
          uint64_t v9 = (uint64_t)v19;
        }
        while (!v33);
      }
      v10 &= v17;
      uint64_t v9 = (uint64_t)v19;
      if (v19 == (void *)&unk_101B0E198) {
        goto LABEL_30;
      }
    }
  }
  char v10 = 0;
LABEL_30:
  if (v7) {
LABEL_31:
  }
    sub_10004D2C8(v7);
LABEL_32:
  LODWORD(__str.__r_.__value_.__l.__data_) = *(_DWORD *)(v8 + 36);
  __int16 v80 = 0;
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  sub_10005DF14((uint64_t *)&v80, a1 + 648);
  uint64_t v20 = v81;
  std::string::size_type v21 = (uint64_t *)&v81;
  if (!v81) {
    goto LABEL_43;
  }
  uint64_t v22 = &v81;
  do
  {
    uint64_t v23 = v20;
    unint64_t v24 = v22;
    int v25 = *((_DWORD *)v20 + 7);
    if (v25 >= SLODWORD(__str.__r_.__value_.__l.__data_)) {
      uint64_t v22 = (uint64_t **)v20;
    }
    else {
      ++v20;
    }
    uint64_t v20 = (uint64_t *)*v20;
  }
  while (v20);
  std::string::size_type v21 = (uint64_t *)&v81;
  if (v22 != &v81
    && (v25 >= SLODWORD(__str.__r_.__value_.__l.__data_) ? (unint64_t v26 = v23) : (unint64_t v26 = v24),
        std::string::size_type v21 = (uint64_t *)v22,
        SLODWORD(__str.__r_.__value_.__l.__data_) >= v26[7]))
  {
    if (v25 >= SLODWORD(__str.__r_.__value_.__l.__data_)) {
      unint64_t v30 = v23;
    }
    else {
      unint64_t v30 = v24;
    }
    v30[32] = v10;
  }
  else
  {
LABEL_43:
    long long __p = 0;
    unint64_t v73 = 0;
    uint64_t v27 = sub_10005CF3C(&v80, v21, (uint64_t **)&__p, (uint64_t *)&v73, (int *)&__str);
    if (!*v27)
    {
      uint64_t v28 = operator new(0x28uLL);
      v28[7] = __str.__r_.__value_.__l.__data_;
      *((unsigned char *)v28 + 32) = v10;
      unint64_t v29 = __p;
      *(void *)uint64_t v28 = 0;
      *((void *)v28 + 1) = 0;
      *((void *)v28 + 2) = v29;
      *uint64_t v27 = (uint64_t)v28;
      if (*v80)
      {
        __int16 v80 = (void ***)*v80;
        uint64_t v28 = (_DWORD *)*v27;
      }
      sub_100046C90(v81, (uint64_t *)v28);
      ++v82;
    }
  }
  if (*(void *)(a1 + 664) == v82)
  {
    uint64_t v31 = *(void **)(a1 + 648);
    if (v31 == (void *)(a1 + 656)) {
      goto LABEL_77;
    }
    uint64_t v32 = (void **)v80;
    while (1)
    {
      BOOL v33 = *((_DWORD *)v31 + 7) == *((_DWORD *)v32 + 7)
         && *((unsigned __int8 *)v31 + 32) == *((unsigned __int8 *)v32 + 32);
      if (!v33) {
        break;
      }
      int v34 = (void *)v31[1];
      uint64_t v35 = v31;
      if (v34)
      {
        do
        {
          uint64_t v31 = v34;
          int v34 = (void *)*v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          uint64_t v31 = (void *)v35[2];
          BOOL v33 = *v31 == (void)v35;
          uint64_t v35 = v31;
        }
        while (!v33);
      }
      uint64_t v36 = (void **)v32[1];
      if (v36)
      {
        do
        {
          uint64_t v37 = v36;
          uint64_t v36 = (void **)*v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          uint64_t v37 = (void **)v32[2];
          BOOL v33 = *v37 == v32;
          uint64_t v32 = v37;
        }
        while (!v33);
      }
      uint64_t v32 = v37;
      if (v31 == (void *)(a1 + 656)) {
        goto LABEL_77;
      }
    }
  }
  if ((void ****)(a1 + 648) != &v80) {
    sub_100912880((uint64_t **)(a1 + 648), v80, &v81);
  }
  uint64_t v38 = *(void *)(a1 + 640);
  if (v38) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v38 + 48))(v38, a1 + 648);
  }
LABEL_77:
  sub_1000346F8((uint64_t)&v80, v81);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v39 = *a2;
  xpc_object_t v40 = (std::__shared_weak_count *)a2[1];
  if (v40) {
    atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v41 = *(void *)(v39 + 192);
  if (!v41) {
    goto LABEL_140;
  }
  uint64_t v42 = v39 + 192;
  do
  {
    int v43 = *(_DWORD *)(v41 + 32);
    BOOL v44 = v43 < 14;
    if (v43 >= 14) {
      size_t v45 = (uint64_t *)v41;
    }
    else {
      size_t v45 = (uint64_t *)(v41 + 8);
    }
    if (!v44) {
      uint64_t v42 = v41;
    }
    uint64_t v41 = *v45;
  }
  while (*v45);
  if (v42 == v39 + 192 || *(int *)(v42 + 32) > 14 || *(_DWORD *)(v42 + 44) != 3) {
    goto LABEL_140;
  }
  int v79 = *(_DWORD *)(v39 + 36);
  long long __p = 0;
  std::string v77 = 0;
  uint64_t v78 = 0;
  sub_1008FAB94(&__p, a1, v79, 14);
  unint64_t v73 = 0;
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  subscriber::sDecodePSISMSC();
  memset(&__str, 0, sizeof(__str));
  if (v73 != v74) {
    std::string::operator=(&__str, v73);
  }
  __int16 v69 = 0;
  std::string v70 = 0;
  uint64_t v71 = 0;
  sub_10008CF3C((uint64_t *)&v69, a1 + 704);
  uint64_t v46 = v70;
  uint64_t v47 = (uint64_t *)&v70;
  if (!v70) {
    goto LABEL_105;
  }
  int v48 = &v70;
  do
  {
    uint64_t v49 = v46;
    unsigned int v50 = v48;
    int v51 = *((_DWORD *)v46 + 8);
    if (v51 >= v79) {
      int v48 = (uint64_t **)v46;
    }
    else {
      ++v46;
    }
    uint64_t v46 = (uint64_t *)*v46;
  }
  while (v46);
  uint64_t v47 = (uint64_t *)&v70;
  if (v48 != &v70 && (v51 >= v79 ? (v52 = v49) : (v52 = v50), uint64_t v47 = (uint64_t *)v48, v79 >= v52[8]))
  {
    CFTypeID v57 = (std::string *)(v50 + 5);
    CFNumberRef v58 = (std::string *)(v49 + 5);
    if (v51 >= v79) {
      uint64_t v59 = v58;
    }
    else {
      uint64_t v59 = v57;
    }
    std::string::operator=(v59, &__str);
  }
  else
  {
LABEL_105:
    uint64_t v83 = 0;
    __int16 v84 = 0;
    uint64_t v53 = sub_1000262C0(&v69, v47, &v84, &v83, &v79);
    if (!*v53)
    {
      int v54 = v79;
      uint64_t v82 = 0;
      CFStringRef v55 = (char *)operator new(0x40uLL);
      uint64_t v81 = (uint64_t *)&v70;
      *((_DWORD *)v55 + 8) = v54;
      BOOL v56 = v55 + 40;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        sub_10004FC84(v56, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
      }
      else
      {
        *(_OWORD *)BOOL v56 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
        *((void *)v55 + 7) = *((void *)&__str.__r_.__value_.__l + 2);
      }
      dispatch_time_t v60 = v84;
      *(void *)CFStringRef v55 = 0;
      *((void *)v55 + 1) = 0;
      *((void *)v55 + 2) = v60;
      uint64_t *v53 = (uint64_t)v55;
      if (*v69)
      {
        __int16 v69 = (void *)*v69;
        CFStringRef v55 = (char *)*v53;
      }
      sub_100046C90(v70, (uint64_t *)v55);
      ++v71;
    }
  }
  if (*(void *)(a1 + 720) != v71) {
    goto LABEL_132;
  }
  uint64_t v61 = *(void **)(a1 + 704);
  if (v61 != (void *)(a1 + 712))
  {
    char v62 = v69;
    while ((sub_10008D2E0((uint64_t)&v80, (uint64_t)(v61 + 4), (uint64_t)(v62 + 4)) & 1) != 0)
    {
      uint64_t v63 = (void *)v61[1];
      uint64_t v64 = v61;
      if (v63)
      {
        do
        {
          uint64_t v61 = v63;
          uint64_t v63 = (void *)*v63;
        }
        while (v63);
      }
      else
      {
        do
        {
          uint64_t v61 = (void *)v64[2];
          BOOL v33 = *v61 == (void)v64;
          uint64_t v64 = v61;
        }
        while (!v33);
      }
      uint64_t v65 = (void *)v62[1];
      if (v65)
      {
        do
        {
          unint64_t v66 = v65;
          uint64_t v65 = (void *)*v65;
        }
        while (v65);
      }
      else
      {
        do
        {
          unint64_t v66 = (void *)v62[2];
          BOOL v33 = *v66 == (void)v62;
          char v62 = v66;
        }
        while (!v33);
      }
      char v62 = v66;
      if (v61 == (void *)(a1 + 712)) {
        goto LABEL_136;
      }
    }
LABEL_132:
    if ((void **)(a1 + 704) != &v69) {
      sub_100429B2C((uint64_t **)(a1 + 704), v69, &v70);
    }
    uint64_t v67 = *(void *)(a1 + 696);
    if (v67) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v67 + 48))(v67, a1 + 704);
    }
  }
LABEL_136:
  sub_1000886C0((uint64_t)&v69, (char *)v70);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  __int16 v80 = (void ***)&v73;
  sub_100047F64((void ***)&v80);
  if (__p)
  {
    std::string v77 = __p;
    operator delete(__p);
  }
LABEL_140:
  if (v40)
  {
    sub_10004D2C8(v40);
  }
}

void sub_1008F89F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, char *a12, uint64_t a13, char *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24)
{
  *(void *)(v27 - 104) = 0;
  sub_10008CD08(v26, v25);
  sub_1000886C0((uint64_t)&a11, a12);
  if (a19 < 0) {
    operator delete(__p);
  }
  long long __p = &a20;
  sub_100047F64((void ***)&__p);
  if (a23)
  {
    a24 = (uint64_t)a23;
    operator delete(a23);
  }
  if (v24) {
    sub_10004D2C8(v24);
  }
  _Unwind_Resume(a1);
}

void sub_1008F8A98(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  switch(sub_1013B85B4(*a2, (uint64_t)a2, a3))
  {
    case 1u:
    case 6u:
    case 7u:
    case 9u:
      uint64_t v5 = *a2;
      unint64_t v6 = **(NSObject ***)(*a2 + 352);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = subscriber::asString();
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Clear SIM PIN cache in state %s", buf, 0xCu);
        uint64_t v5 = *a2;
      }
      int v7 = (std::__shared_weak_count *)a2[1];
      v54[0] = v5;
      v54[1] = (uint64_t)v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1008FA5C0(a1, v54);
      if (v7) {
        sub_10004D2C8(v7);
      }
      return;
    case 3u:
      if (subscriber::isValidSimSlot())
      {
        uint64_t v26 = *a2;
        uint64_t v9 = (std::__shared_weak_count *)a2[1];
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (*(unsigned char *)(v26 + 58))
        {
          uint64_t v27 = *(void *)(v26 + 192);
          if (v27)
          {
            uint64_t v28 = *(os_log_t **)(v26 + 352);
            uint64_t v29 = v26 + 192;
            do
            {
              int v30 = *(_DWORD *)(v27 + 32);
              BOOL v31 = v30 < 0;
              if (v30 >= 0) {
                uint64_t v32 = (uint64_t *)v27;
              }
              else {
                uint64_t v32 = (uint64_t *)(v27 + 8);
              }
              if (!v31) {
                uint64_t v29 = v27;
              }
              uint64_t v27 = *v32;
            }
            while (*v32);
            if (v29 != v26 + 192 && *(int *)(v29 + 32) <= 0 && *(_DWORD *)(v29 + 44) == 3)
            {
              unsigned int v33 = *(unsigned __int8 *)(v26 + 59);
              if (v33 <= 2)
              {
                int v34 = *v28;
                if (os_log_type_enabled(*v28, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 67109120;
                  *(_DWORD *)&uint8_t buf[4] = v33;
                  _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Not enough PIN reties (%d) left", buf, 8u);
                }
                sub_1013B7E70(v26, 0);
              }
              if (v9) {
                atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v35 = operator new(0x28uLL);
              *uint64_t v35 = off_101A1A4A8;
              v35[1] = a1;
              v35[2] = v28;
              v35[3] = v26;
              v35[4] = v9;
              uint64_t v63 = v35;
              sub_1013B9278(v26, (uint64_t)buf, v36);
              sub_1000F25E0(buf);
            }
          }
        }
        goto LABEL_86;
      }
      return;
    case 4u:
      if (subscriber::isValidSimSlot())
      {
        memset(buf, 0, sizeof(buf));
        sub_10003E168(buf, (void *)(a1 + 8));
        operator new();
      }
      return;
    case 5u:
      if (!subscriber::isValidSimSlot()) {
        return;
      }
      uint64_t v10 = *a2;
      uint64_t v9 = (std::__shared_weak_count *)a2[1];
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      memset(buf, 0, sizeof(buf));
      uint64_t v62 = 0;
      sub_1013B7E2C(v10, v8, (uint64_t)buf);
      uint64_t v11 = HIBYTE(v62);
      if (v62 < 0) {
        uint64_t v11 = *(void *)&buf[8];
      }
      if (v11)
      {
        uint64_t v12 = (uint64_t **)(a1 + 888);
        *(void *)long long __dst = buf;
        uint64_t v13 = sub_1009156E0((uint64_t **)(a1 + 888), (void **)buf, (long long **)__dst);
        int v14 = (uint64_t *)*((unsigned __int8 *)v13 + 57);
        if (!*((unsigned char *)v13 + 57)) {
          goto LABEL_21;
        }
        if (*(unsigned char *)(v10 + 58))
        {
          *(void *)long long __dst = buf;
          BOOL v15 = sub_1009156E0((uint64_t **)(a1 + 888), (void **)buf, (long long **)__dst);
          if (!*((unsigned char *)v15 + 57)) {
            sub_10016C840();
          }
          int v14 = (uint64_t *)*((unsigned __int8 *)v15 + 56);
          if (!*((unsigned char *)v15 + 56))
          {
LABEL_21:
            ServiceMap = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(a1 + 64));
            BOOL v17 = ServiceMap;
            if (v18 < 0)
            {
              size_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v20 = 5381;
              do
              {
                uint64_t v18 = v20;
                unsigned int v21 = *v19++;
                uint64_t v20 = (33 * v20) ^ v21;
              }
              while (v21);
            }
            std::mutex::lock(ServiceMap);
            *(void *)long long __dst = v18;
            uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)__dst);
            if (v22)
            {
              uint64_t v24 = v22[3];
              uint64_t v23 = (std::__shared_weak_count *)v22[4];
              if (v23)
              {
                atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v17);
                atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v23);
                char v25 = 0;
LABEL_53:
                if (v24)
                {
                  memset(__dst, 0, sizeof(__dst));
                  uint64_t v58 = 0;
                  if (SHIBYTE(v62) < 0)
                  {
                    sub_10004FC84(__dst, *(void **)buf, *(unint64_t *)&buf[8]);
                  }
                  else
                  {
                    *(_OWORD *)long long __dst = *(_OWORD *)buf;
                    uint64_t v58 = v62;
                  }
                  CFTypeRef cf = 0;
                  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint8_t *, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v24 + 24))(&cf, v24, __dst, @"InitialActiveState", @"SimPin", 0, 1);
                  uint64_t v39 = (BOOL *)cf;
                  if (cf) {
                    xpc_object_t v40 = sub_100080934;
                  }
                  else {
                    xpc_object_t v40 = 0;
                  }
                  if (!v40) {
                    goto LABEL_94;
                  }
                  v60[0] = 0;
                  if (cf)
                  {
                    CFTypeID v41 = CFGetTypeID(cf);
                    if (v41 == CFBooleanGetTypeID()) {
                      ctu::cf::assign((ctu::cf *)v60, v39, v42);
                    }
                  }
                  __int16 v43 = v60[0];
                  *(void *)dispatch_time_t v60 = buf;
                  *((_WORD *)sub_1009156E0(v12, (void **)buf, (long long **)v60) + 28) = v43 | 0x100;
                  BOOL v44 = **(NSObject ***)(v10 + 352);
                  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v59 = buf;
                    sub_1009156E0(v12, (void **)buf, (long long **)&v59);
                    uint64_t v45 = printers::asString();
                    *(_DWORD *)dispatch_time_t v60 = 136315138;
                    *(void *)&v60[4] = v45;
                    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I PIN initial active state cached value: (%s)", v60, 0xCu);
                  }
                  if (*(unsigned char *)(v10 + 58))
                  {
                    *(void *)dispatch_time_t v60 = buf;
                    uint64_t v46 = sub_1009156E0(v12, (void **)buf, (long long **)v60);
                    if (!*((unsigned char *)v46 + 57)) {
                      sub_10016C840();
                    }
                    if (!*((unsigned char *)v46 + 56))
                    {
LABEL_94:
                      if (*(unsigned char *)(v10 + 58)) {
                        uint64_t v47 = &kCFBooleanTrue;
                      }
                      else {
                        uint64_t v47 = &kCFBooleanFalse;
                      }
                      CFBooleanRef v48 = *v47;
                      *(void *)dispatch_time_t v60 = 0;
                      sub_100062778((const void **)v60);
                      CFBooleanRef v55 = v48;
                      *(void *)dispatch_time_t v60 = 0;
                      sub_100062778((const void **)v60);
                      int v49 = (*(uint64_t (**)(uint64_t, uint8_t *, const __CFString *, CFBooleanRef, const __CFString *, void, uint64_t, void))(*(void *)v24 + 16))(v24, __dst, @"InitialActiveState", v48, @"SimPin", 0, 1, 0);
                      if (v49)
                      {
                        unsigned int v50 = **(NSObject ***)(v10 + 352);
                        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)dispatch_time_t v60 = 67109120;
                          *(_DWORD *)&v60[4] = v49;
                          _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "Failed to store PIN initial active state to wallet, error (%d)", v60, 8u);
                        }
                      }
                      else
                      {
                        __int16 v51 = *(unsigned __int8 *)(v10 + 58);
                        *(void *)dispatch_time_t v60 = buf;
                        *((_WORD *)sub_1009156E0(v12, (void **)buf, (long long **)v60) + 28) = v51 | 0x100;
                        uint64_t v52 = **(NSObject ***)(v10 + 352);
                        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v59 = buf;
                          sub_1009156E0(v12, (void **)buf, (long long **)&v59);
                          uint64_t v53 = printers::asString();
                          *(_DWORD *)dispatch_time_t v60 = 136315138;
                          *(void *)&v60[4] = v53;
                          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I Successfully cached PIN initial active state: (%s)", v60, 0xCu);
                        }
                      }
                      sub_100062778((const void **)&v55);
                    }
                  }
                  sub_1000577C4(&cf);
                  if (SHIBYTE(v58) < 0) {
                    operator delete(*(void **)__dst);
                  }
                }
                else
                {
                  uint64_t v38 = **(NSObject ***)(v10 + 352);
                  if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long __dst = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Failed to get Personal Wallet interface", __dst, 2u);
                  }
                }
                if ((v25 & 1) == 0) {
                  sub_10004D2C8(v23);
                }
                goto LABEL_84;
              }
            }
            else
            {
              uint64_t v24 = 0;
            }
            std::mutex::unlock(v17);
            uint64_t v23 = 0;
            char v25 = 1;
            goto LABEL_53;
          }
        }
      }
      else
      {
        uint64_t v37 = **(NSObject ***)(v10 + 352);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long __dst = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "empty ICCID for a ready SIM!!", __dst, 2u);
        }
      }
LABEL_84:
      if (SHIBYTE(v62) < 0) {
        operator delete(*(void **)buf);
      }
LABEL_86:
      if (v9)
      {
        sub_10004D2C8(v9);
      }
      return;
    default:
      return;
  }
}

void sub_1008F932C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (v30) {
    sub_10004D2C8(v30);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008F9424(uint64_t a1, uint64_t *a2)
{
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v26 = &v27;
  int v25 = *(_DWORD *)(*a2 + 32);
  uint64_t v4 = sub_1009127C8((uint64_t **)(a1 + 592), v25, &v25);
  uint64_t v5 = v4[5];
  unint64_t v6 = v4 + 6;
  if (v5 != (uint64_t *)(v4 + 6))
  {
    do
    {
      int v7 = *((_DWORD *)v5 + 7);
      int SimCardForSimFilePath = subscriber::getSimCardForSimFilePath();
      int v9 = SimCardForSimFilePath;
      uint64_t v10 = v27;
      uint64_t v11 = &v27;
      uint64_t v12 = &v27;
      if (v27)
      {
        do
        {
          while (1)
          {
            uint64_t v12 = (uint64_t **)v10;
            int v13 = *((_DWORD *)v10 + 8);
            if (v13 <= SimCardForSimFilePath) {
              break;
            }
            uint64_t v10 = *v12;
            uint64_t v11 = v12;
            if (!*v12) {
              goto LABEL_10;
            }
          }
          if (v13 >= SimCardForSimFilePath)
          {
            BOOL v15 = (char *)v12;
            goto LABEL_13;
          }
          uint64_t v10 = v12[1];
        }
        while (v10);
        uint64_t v11 = v12 + 1;
      }
LABEL_10:
      BOOL v15 = (char *)operator new(0x40uLL);
      *((_DWORD *)v15 + 8) = v9;
      *((void *)v15 + 7) = 0;
      *((void *)v15 + 6) = 0;
      *((void *)v15 + 5) = v15 + 48;
      *(void *)BOOL v15 = 0;
      *((void *)v15 + 1) = 0;
      *((void *)v15 + 2) = v12;
      char *v11 = (uint64_t *)v15;
      int v14 = (uint64_t *)v15;
      if (*v26)
      {
        uint64_t v26 = (uint64_t **)*v26;
        int v14 = *v11;
      }
      sub_100046C90(v27, v14);
      ++v28;
LABEL_13:
      sub_1003E516C((uint64_t *)v15 + 5, v7, v7);
      BOOL v16 = (uint64_t *)v5[1];
      if (v16)
      {
        do
        {
          BOOL v17 = v16;
          BOOL v16 = (uint64_t *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          BOOL v17 = (uint64_t *)v5[2];
          BOOL v18 = *v17 == (void)v5;
          uint64_t v5 = v17;
        }
        while (!v18);
      }
      uint64_t v5 = v17;
    }
    while (v17 != (uint64_t *)v6);
  }
  size_t v19 = v26;
  if (v26 != &v27)
  {
    do
    {
      *(_OWORD *)long long __p = 0u;
      long long v24 = 0u;
      long long v22 = 0u;
      sub_1013B8918(*a2, *((_DWORD *)v19 + 8), (uint64_t)&v22);
      if (BYTE8(v24))
      {
        (*(void (**)(void, long long *, uint64_t **))(**(void **)(a1 + 104) + 104))(*(void *)(a1 + 104), &v22, v19 + 5);
        if (BYTE8(v24))
        {
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
        }
      }
      uint64_t v20 = v19[1];
      if (v20)
      {
        do
        {
          unsigned int v21 = (uint64_t **)v20;
          uint64_t v20 = (uint64_t *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          unsigned int v21 = (uint64_t **)v19[2];
          BOOL v18 = *v21 == (uint64_t *)v19;
          size_t v19 = v21;
        }
        while (!v18);
      }
      size_t v19 = v21;
    }
    while (v21 != &v27);
  }
  sub_10024D0B4(v27);
}

void sub_1008F9658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *a17)
{
}

void sub_1008F9694(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = *(uint64_t **)(a1 + 168);
  for (uint64_t i = *(uint64_t **)(a1 + 176); v3 != i; v3 += 2)
  {
    unint64_t v6 = (std::__shared_weak_count *)v3[1];
    v7[0] = *v3;
    v7[1] = (uint64_t)v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1008F8A98(a1, v7, a3);
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
}

void sub_1008F9714(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008F972C(void *a1)
{
  memset(v5, 0, sizeof(v5));
  uint64_t v2 = a1[4];
  sub_10010CB7C(v5, a1[5], a1[6], 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(a1[6] - a1[5]) >> 3));
  memset(v4, 0, sizeof(v4));
  sub_10010CB7C(v4, a1[8], a1[9], 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(a1[9] - a1[8]) >> 3));
  sub_1008F9810(v2, v5, v4, v3);
  unint64_t v6 = (void **)v4;
  sub_10008A88C(&v6);
  unint64_t v6 = (void **)v5;
  sub_10008A88C(&v6);
}

void sub_1008F97E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v14 - 40) = v13;
  sub_10008A88C((void ***)(v14 - 40));
  *(void *)(v14 - 40) = &a13;
  sub_10008A88C((void ***)(v14 - 40));
  _Unwind_Resume(a1);
}

void sub_1008F9810(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *(Registry **)(a1 + 64));
  unint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unsigned int v33 = (_DWORD *)v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v33);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (v15) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v15 + 24))(v15, a2);
LABEL_11:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  uint64_t v17 = *(void *)(a1 + 224);
  uint64_t v18 = *(void *)(a1 + 232);
  uint64_t v19 = *a2;
  if (v18 - v17 == a2[1] - *a2)
  {
    while (v17 != v18 && BasicSimInfo::operator==())
    {
      v17 += 168;
      v19 += 168;
    }
  }
  sub_1008F9C40(a1 + 192, a2);
  unsigned int v33 = 0;
  int v34 = 0;
  uint64_t v35 = 0;
  sub_10010CB7C(&v33, *(void *)(a1 + 280), *(void *)(a1 + 288), 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(a1 + 288) - *(void *)(a1 + 280)) >> 3));
  uint64_t v22 = *(void *)(a1 + 280);
  uint64_t v23 = *(void *)(a1 + 288);
  uint64_t v24 = *a3;
  if (v23 - v22 == a3[1] - *a3)
  {
    while (v22 != v23)
    {
      if (!BasicSimInfo::operator==()) {
        goto LABEL_21;
      }
      v22 += 168;
      v24 += 168;
    }
  }
  else
  {
LABEL_21:
    if ((uint64_t *)(a1 + 280) != a3) {
      sub_1003DB990(a1 + 280, *a3, a3[1], 0xCF3CF3CF3CF3CF3DLL * ((a3[1] - *a3) >> 3));
    }
    uint64_t v25 = *(void *)(a1 + 272);
    if (v25) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v25 + 48))(v25, a1 + 280);
    }
    sub_1008F9CE0(a1);
  }
  uint64_t v26 = *(uint64_t **)(a1 + 168);
  uint64_t v27 = *(uint64_t **)(a1 + 176);
  while (v26 != v27)
  {
    if (*(_DWORD *)(*v26 + 36))
    {
      uint64_t v28 = sub_1013B85B4(*v26, v20, v21);
      uint64_t v29 = *(unsigned int *)(*v26 + 36);
      int v30 = v33;
      BOOL v31 = v34;
      while (v30 != v31)
      {
        if (*v30 == v29)
        {
          int v32 = subscriber::toSimStatus();
          if (v32 == subscriber::toSimStatus()) {
            goto LABEL_35;
          }
        }
        v30 += 42;
      }
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 120) + 24))(*(void *)(a1 + 120), v29, v28);
    }
LABEL_35:
    v26 += 2;
  }
  unint64_t v36 = (void **)&v33;
  sub_10008A88C(&v36);
}

void sub_1008F9B14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1008F9B58(void *a1, uint64_t *a2)
{
  uint64_t v3 = a1;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  sub_10010CB7C(a1 + 5, a2[5], a2[6], 0xCF3CF3CF3CF3CF3DLL * ((a2[6] - a2[5]) >> 3));
  v3[8] = 0;
  v3[9] = 0;
  v3 += 8;
  v3[2] = 0;
  return sub_10010CB7C(v3, a2[8], a2[9], 0xCF3CF3CF3CF3CF3DLL * ((a2[9] - a2[8]) >> 3));
}

void sub_1008F9BE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10008A88C((void ***)va);
  _Unwind_Resume(a1);
}

void sub_1008F9BFC(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 40);
  uint64_t v2 = (void **)(a1 + 64);
  sub_10008A88C(&v2);
  uint64_t v2 = v1;
  sub_10008A88C(&v2);
}

uint64_t sub_1008F9C40(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)(a1 + 32) != a2) {
    sub_1003DB990(a1 + 32, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
  }
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v4();
  }
  return result;
}

void sub_1008F9CE0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 800))
  {
    sub_1008F2E04((const void **)a1);
  }
  else
  {
    uint64_t v2 = *(void *)(a1 + 784);
    uint64_t v3 = *(NSObject **)(a1 + 40);
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    if (v2)
    {
      if (v4)
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v2;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %zu auth requests outstanding", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v5 = *(void *)(a1 + 728);
      if (v5)
      {
        if (*(_DWORD *)(v5 + 68) == 2)
        {
          uint64_t v6 = a1 + 744;
          do
          {
            if (!*(void *)(a1 + 784)) {
              break;
            }
            long long v57 = 0u;
            long long v58 = 0u;
            long long buf = 0u;
            long long v56 = 0u;
            int v7 = (void *)(*(void *)(*(void *)(a1 + 752) + ((*(void *)(a1 + 776) >> 3) & 0x1FFFFFFFFFFFFFF8))
                          + ((*(void *)(a1 + 776) & 0x3FLL) << 6));
            *(void *)&long long buf = *v7;
            sub_10026E7F8((uint64_t *)&buf + 1, (uint64_t)(v7 + 1));
            sub_10090DFD0((uint64_t)&v57, (uint64_t)(v7 + 4));
            for (uint64_t i = *(uint64_t **)(a1 + 168); i != *(uint64_t **)(a1 + 176); i += 2)
            {
              uint64_t v11 = *i;
              if (*(_DWORD *)(*i + 36) == buf)
              {
                uint64_t v14 = (std::__shared_weak_count *)i[1];
                if (v14) {
                  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                sub_1013B85B4(v11, v8, v9);
                if (subscriber::isSimSettled())
                {
                  sub_1008FAD1C(v6);
                  long long v53 = 0u;
                  long long v54 = 0u;
                  long long v52 = 0u;
                  sub_1013B8A40(v11, SDWORD1(buf), &v52);
                  uint64_t v15 = **(NSObject ***)(v11 + 352);
                  if (BYTE8(v54))
                  {
                    int v34 = v14;
                    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v16 = subscriber::asString();
                      *(_DWORD *)CFBooleanRef v48 = 136315394;
                      uint64_t v49 = v16;
                      __int16 v50 = 2048;
                      uint64_t v51 = *((void *)&v56 + 1);
                      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Sending auth request for type %s : input has %lu fields", v48, 0x16u);
                    }
                    uint64_t v17 = *(void *)(a1 + 728);
                    uint64_t v18 = *(std::__shared_weak_count **)(a1 + 736);
                    if (v18) {
                      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    uint64_t v35 = v18;
                    uint64_t v19 = v6;
                    *(CFAbsoluteTime *)(a1 + 792) = CFAbsoluteTimeGetCurrent();
                    *(unsigned char *)(a1 + 800) = 1;
                    uint64_t v20 = *(void *)(a1 + 104);
                    uint64_t v21 = DWORD1(buf);
                    sub_10026E7F8(v36, (uint64_t)&buf + 8);
                    *(void *)&long long v41 = a1;
                    *((void *)&v41 + 1) = v17;
                    CFBooleanRef v42 = v35;
                    if (v35) {
                      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    uint64_t v14 = v34;
                    *(void *)&long long v43 = v11;
                    *((void *)&v43 + 1) = v34;
                    if (v34) {
                      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    int v44 = DWORD1(buf);
                    sub_10090DFD0((uint64_t)v45, (uint64_t)&v57);
                    uint64_t v47 = 0;
                    uint64_t v22 = (char *)operator new(0x58uLL);
                    *(void *)uint64_t v22 = off_101A1A018;
                    *(_OWORD *)(v22 + 8) = v41;
                    *((void *)v22 + 3) = v42;
                    *((void *)&v41 + 1) = 0;
                    CFBooleanRef v42 = 0;
                    *((_OWORD *)v22 + 2) = v43;
                    long long v43 = 0uLL;
                    *((_DWORD *)v22 + 12) = v44;
                    sub_10090DFD0((uint64_t)(v22 + 56), (uint64_t)v45);
                    uint64_t v47 = v22;
                    (*(void (**)(uint64_t, long long *, uint64_t, uint64_t *, void *))(*(void *)v20 + 112))(v20, &v52, v21, v36, v46);
                    sub_100273F20(v46);
                    sub_100273F20(v45);
                    uint64_t v6 = v19;
                    if (*((void *)&v43 + 1)) {
                      sub_10004D2C8(*((std::__shared_weak_count **)&v43 + 1));
                    }
                    if (v42) {
                      sub_10004D2C8(v42);
                    }
                    sub_10026CF54((uint64_t)v36, (void *)v36[1]);
                    if (v35) {
                      sub_10004D2C8(v35);
                    }
                    int v13 = 9;
                  }
                  else
                  {
                    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v28 = subscriber::asString();
                      *(_DWORD *)CFBooleanRef v48 = 136315138;
                      uint64_t v49 = v28;
                      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Auth for type %s cannot occur because no SIM type matches", v48, 0xCu);
                    }
                    v38[0] = 0;
                    v38[1] = 0;
                    uint64_t v37 = v38;
                    if (!*((void *)&v58 + 1)) {
                      sub_10007B600();
                    }
                    (*(void (**)(void, void ***))(**((void **)&v58 + 1) + 48))(*((void *)&v58 + 1), &v37);
                    sub_10026CF54((uint64_t)&v37, v38[0]);
                    int v13 = 8;
                  }
                  if (BYTE8(v54) && (void)v53)
                  {
                    *((void *)&v53 + 1) = v53;
                    operator delete((void *)v53);
                  }
                }
                else
                {
                  uint64_t v23 = **(NSObject ***)(v11 + 352);
                  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                  {
                    sub_1013B85B4(v11, v24, v25);
                    uint64_t v27 = subscriber::asString();
                    LODWORD(v52) = 136315138;
                    *(void *)((char *)&v52 + 4) = v27;
                    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Auth deferred because of SIM state %s", (uint8_t *)&v52, 0xCu);
                  }
                  int v13 = 1;
                }
                if (v14) {
                  sub_10004D2C8(v14);
                }
                goto LABEL_51;
              }
            }
            char v12 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              uint64_t v26 = subscriber::asString();
              LODWORD(v52) = 136315138;
              *(void *)((char *)&v52 + 4) = v26;
              _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Auth cannot occur because there is no SIM for (%s)", (uint8_t *)&v52, 0xCu);
            }
            sub_1008FAD1C(v6);
            v40[0] = 0;
            v40[1] = 0;
            uint64_t v39 = v40;
            if (!*((void *)&v58 + 1)) {
              sub_10007B600();
            }
            (*(void (**)(void, void ***))(**((void **)&v58 + 1) + 48))(*((void *)&v58 + 1), &v39);
            sub_10026CF54((uint64_t)&v39, v40[0]);
            int v13 = 8;
LABEL_51:
            sub_100273F20(&v57);
            sub_10026CF54((uint64_t)&buf + 8, (void *)v56);
          }
          while (v13 == 8);
        }
        else
        {
          unsigned int v33 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Baseband booted assertion for auth not granted yet. Keep waiting...", (uint8_t *)&buf, 2u);
          }
        }
      }
      else
      {
        int v30 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Acquiring baseband booted assertion for auth", (uint8_t *)&buf, 2u);
        }
        sub_100058DB0(&buf, "/cc/assertions/baseband_booted");
        ctu::rest::AssertionHandle::create();
        if (SBYTE7(v56) < 0) {
          operator delete((void *)buf);
        }
        long long v31 = v52;
        long long v52 = 0uLL;
        int v32 = *(std::__shared_weak_count **)(a1 + 736);
        *(_OWORD *)(a1 + 728) = v31;
        if (v32)
        {
          sub_10004D2C8(v32);
          if (*((void *)&v52 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v52 + 1));
          }
        }
        *(void *)&long long buf = off_101A19F98;
        *((void *)&buf + 1) = a1;
        *((void *)&v56 + 1) = &buf;
        ctu::rest::AssertionHandle::setHandler_impl();
        sub_100060644(&buf);
      }
    }
    else
    {
      if (v4)
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I No auth requests to process", (uint8_t *)&buf, 2u);
      }
      uint64_t v29 = *(std::__shared_weak_count **)(a1 + 736);
      *(_OWORD *)(a1 + 728) = 0u;
      if (v29) {
        sub_10004D2C8(v29);
      }
    }
  }
}

void sub_1008FA458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (*(unsigned char *)(v17 - 184))
  {
    uint64_t v19 = *(void **)(v17 - 208);
    if (v19)
    {
      *(void *)(v17 - 200) = v19;
      operator delete(v19);
    }
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_1008FADF4(v17 - 176);
  _Unwind_Resume(a1);
}

uint64_t sub_1008FA5C0(uint64_t a1, uint64_t *a2)
{
  sub_1013B7E70(*a2, 0);
  uint64_t result = *(void *)(a1 + 152);
  if (result)
  {
    BOOL v4 = *(uint64_t (**)(void))(*(void *)result + 40);
    return v4();
  }
  return result;
}

void *sub_1008FA63C(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  unint64_t v4 = *a2 | (unint64_t)(a3 << 32);
  v6[0] = off_101A19F08;
  v6[1] = v3;
  v6[2] = v4;
  void v6[3] = v6;
  sub_1008FA6E0(v3, (uint64_t)a2, a3, (uint64_t)v6);
  return sub_10090EC3C(v6);
}

void sub_1008FA6CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10090EC3C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1008FA6E0(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(a2 + 4));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v14 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Reading SIM file %s", buf, 0xCu);
  }
  *(void *)&long long v11 = a1;
  *((void *)&v11 + 1) = *(void *)a2;
  sub_10090EBA4((uint64_t)v12, a4);
  uint64_t v15 = 0;
  unint64_t v9 = (char *)operator new(0x40uLL);
  *(void *)unint64_t v9 = off_101A1A098;
  *(_OWORD *)(v9 + 8) = v11;
  *((_DWORD *)v9 + 6) = a3;
  sub_10090ECC0((uint64_t)(v9 + 32), (uint64_t)v12);
  uint64_t v15 = v9;
  subscriber::SimCommandDriver::readFile();
  sub_100913918(buf);
  return sub_10090EC3C(v12);
}

void sub_1008FA864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_100913918((uint64_t *)va);
  sub_10090EC3C(v9);
  _Unwind_Resume(a1);
}

void sub_1008FA890(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3 + 1;
  unint64_t v4 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    unsigned int v6 = *(_DWORD *)(*(void *)a2 + 36);
    do
    {
      uint64_t v7 = *(void *)(*(void *)a2 + 192);
      if (v7)
      {
        int v8 = *((_DWORD *)v4 + 7);
        uint64_t v9 = *(void *)a2 + 192;
        do
        {
          int v10 = *(_DWORD *)(v7 + 32);
          BOOL v11 = v10 < v8;
          if (v10 >= v8) {
            char v12 = (uint64_t *)v7;
          }
          else {
            char v12 = (uint64_t *)(v7 + 8);
          }
          if (!v11) {
            uint64_t v9 = v7;
          }
          uint64_t v7 = *v12;
        }
        while (*v12);
        if (v9 != *(void *)a2 + 192 && *(_DWORD *)(v9 + 32) <= v8 && *(_DWORD *)(v9 + 44) == 3)
        {
          sub_100D49230(*(void *)a2 + 184, *((_DWORD *)v4 + 7), &v19);
          uint64_t v21 = (void *)__PAIR64__(v8, v6);
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          uint64_t v22 = 0;
          sub_10005C928(&v22, v19, (uint64_t)v20, v20 - (unsigned char *)v19);
          xpc_object_t v29 = 0;
          rest::write_rest_value();
          sub_100058DB0(&__p, "/cc/events/subscriber_sim_file_event");
          xpc_object_t object = v29;
          xpc_object_t v29 = xpc_null_create();
          ctu::RestModule::sendEvent();
          xpc_release(object);
          xpc_object_t object = 0;
          if (v27 < 0) {
            operator delete(__p);
          }
          xpc_release(v29);
          if (v22)
          {
            uint64_t v23 = v22;
            operator delete(v22);
          }
          if (v19)
          {
            uint64_t v20 = v19;
            operator delete(v19);
          }
          unsigned __int16 v13 = sub_100D48D30(*(void *)a2 + 184, v8);
          if ((_BYTE)v13) {
            BOOL v14 = v13 > 0xFFu;
          }
          else {
            BOOL v14 = 0;
          }
          long long __p = (void *)__PAIR64__(v8, v6);
          char v15 = v14;
          char v26 = v15;
          xpc_object_t v29 = 0;
          rest::write_rest_value();
          sub_100058DB0(&v21, "/cc/events/subscriber_sim_file_attributes_event");
          xpc_object_t object = v29;
          xpc_object_t v29 = xpc_null_create();
          ctu::RestModule::sendEvent();
          xpc_release(object);
          xpc_object_t object = 0;
          if (SHIBYTE(v23) < 0) {
            operator delete(v21);
          }
          xpc_release(v29);
        }
      }
      uint64_t v16 = (void *)v4[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (void *)v4[2];
          BOOL v18 = *v17 == (void)v4;
          unint64_t v4 = v17;
        }
        while (!v18);
      }
      unint64_t v4 = v17;
    }
    while (v17 != v3);
  }
}

void sub_1008FAAD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, void *a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,xpc_object_t object,xpc_object_t a26)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  xpc_release(a26);
  _Unwind_Resume(a1);
}

void sub_1008FAB94(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  for (uint64_t i = *(void **)(a2 + 168); i != *(void **)(a2 + 176); i += 2)
  {
    uint64_t v6 = *i;
    if (*(_DWORD *)(*i + 36) == a3)
    {
      int v8 = (std::__shared_weak_count *)i[1];
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_100D49230(v6 + 184, a4, a1);
      if (v8)
      {
        sub_10004D2C8(v8);
      }
      return;
    }
  }
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 56) + 16))(*(void *)(a2 + 56), a3);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315138;
    uint64_t v10 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#E Can't get Sim File %s because there is no SIM", (uint8_t *)&v9, 0xCu);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void sub_1008FAD04(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008FAD1C(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + ((*(void *)(a1 + 32) >> 3) & 0x1FFFFFFFFFFFFFF8))
     + ((*(void *)(a1 + 32) & 0x3FLL) << 6);
  sub_100273F20((void *)(v2 + 32));
  sub_10026CF54(v2 + 8, *(void **)(v2 + 16));
  int64x2_t v3 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_10144F900);
  *(int64x2_t *)(a1 + 32) = v3;
  if (v3.i64[0] >= 0x80uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 64;
  }
}

void *sub_1008FADB0(void *a1)
{
  sub_100273F20(a1 + 6);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int64x2_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t sub_1008FADF4(uint64_t a1)
{
  return a1;
}

void sub_1008FAE2C(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v3 = *a2;
  int v4 = *(_DWORD *)(*a2 + 32);
  int v46 = v4;
  uint64_t v5 = *(void *)(a1 + 600);
  if (!v5) {
    goto LABEL_11;
  }
  int v8 = (uint64_t **)(a1 + 592);
  uint64_t v9 = a1 + 600;
  do
  {
    int v10 = *(_DWORD *)(v5 + 32);
    BOOL v11 = v10 < v4;
    if (v10 >= v4) {
      char v12 = (uint64_t *)v5;
    }
    else {
      char v12 = (uint64_t *)(v5 + 8);
    }
    if (!v11) {
      uint64_t v9 = v5;
    }
    uint64_t v5 = *v12;
  }
  while (*v12);
  if (v9 == a1 + 600 || v4 < *(_DWORD *)(v9 + 32))
  {
LABEL_11:
    unsigned __int16 v13 = **(NSObject ***)(v3 + 352);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "observed files list not available", buf, 2u);
    }
    return;
  }
  int v44 = 0;
  uint64_t v45 = 0;
  v42[1] = 0;
  long long v43 = &v44;
  long long v41 = v42;
  v42[0] = 0;
  BOOL v14 = a3 + 1;
  char v15 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    do
    {
      int v16 = *((_DWORD *)v15 + 7);
      uint64_t v17 = sub_1009127C8(v8, v4, &v46);
      uint64_t v20 = v17[6];
      BOOL v18 = v17 + 6;
      uint64_t v19 = v20;
      if (!v20) {
        goto LABEL_24;
      }
      uint64_t v21 = v18;
      do
      {
        int v22 = *((_DWORD *)v19 + 7);
        BOOL v23 = v22 < v16;
        if (v22 >= v16) {
          uint64_t v24 = (uint64_t **)v19;
        }
        else {
          uint64_t v24 = (uint64_t **)(v19 + 1);
        }
        if (!v23) {
          uint64_t v21 = (uint64_t **)v19;
        }
        uint64_t v19 = *v24;
      }
      while (*v24);
      if (v21 == v18 || v16 < *((_DWORD *)v21 + 7)) {
LABEL_24:
      }
        uint64_t v21 = v18;
      if (v21 == sub_1009127C8(v8, v4, &v46) + 6)
      {
        char v26 = sub_1009127C8(v8, v4, &v46);
        sub_1003E516C((uint64_t *)v26 + 5, v16, v16);
        unint64_t v25 = (uint64_t *)&v43;
      }
      else
      {
        unint64_t v25 = (uint64_t *)&v41;
      }
      sub_1003E516C(v25, v16, v16);
      char v27 = (void *)v15[1];
      if (v27)
      {
        do
        {
          uint64_t v28 = v27;
          char v27 = (void *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          uint64_t v28 = (void *)v15[2];
          BOOL v29 = *v28 == (void)v15;
          char v15 = v28;
        }
        while (!v29);
      }
      char v15 = v28;
    }
    while (v28 != v14);
    if (v45)
    {
      uint64_t v31 = *a2;
      int v30 = (std::__shared_weak_count *)a2[1];
      if (v30 && (atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed), !v45))
      {
        uint64_t v38 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I No new files to be observed", buf, 2u);
        }
      }
      else
      {
        int v32 = v43;
        if (v43 != &v44)
        {
          do
          {
            sub_1013B8BD8(v31, *((_DWORD *)v32 + 7));
            unsigned int v33 = v32[1];
            if (v33)
            {
              do
              {
                int v34 = (void **)v33;
                unsigned int v33 = (void *)*v33;
              }
              while (v33);
            }
            else
            {
              do
              {
                int v34 = (void **)v32[2];
                BOOL v29 = *v34 == v32;
                int v32 = v34;
              }
              while (!v29);
            }
            int v32 = v34;
          }
          while (v34 != &v44);
        }
        if (v30) {
          atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v48 = 0x40000000;
        uint64_t v49 = sub_1008FA63C;
        __int16 v50 = &unk_101A18F00;
        uint64_t v51 = a1;
        sub_1013B8A74(v31, (uint64_t)buf);
        if (!v30) {
          goto LABEL_49;
        }
        sub_10004D2C8(v30);
      }
      sub_10004D2C8(v30);
LABEL_49:
      uint64_t v35 = (std::__shared_weak_count *)a2[1];
      v40[0] = *a2;
      v40[1] = (uint64_t)v35;
      if (v35) {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1008F9424(a1, v40);
      if (v35) {
        sub_10004D2C8(v35);
      }
    }
  }
  uint64_t v36 = *a2;
  uint64_t v37 = (std::__shared_weak_count *)a2[1];
  v39[0] = v36;
  v39[1] = v37;
  if (v37) {
    atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1008FA890(a1, (uint64_t)v39, &v41);
  if (v37) {
    sub_10004D2C8(v37);
  }
  sub_1000346F8((uint64_t)&v41, v42[0]);
  sub_1000346F8((uint64_t)&v43, v44);
}

void sub_1008FB1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, void *a15, uint64_t a16, char a17, void *a18)
{
  if (v18)
  {
    sub_10004D2C8(v18);
    sub_10004D2C8(v18);
  }
  sub_1000346F8((uint64_t)&a14, a15);
  sub_1000346F8((uint64_t)&a17, a18);
  _Unwind_Resume(a1);
}

uint64_t sub_1008FB224(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

void *sub_1008FB274(void *a1)
{
  sub_1008FDF70(a1 + 4);
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_1008FB2B0(uint64_t a1, char a2)
{
  return sub_1000607A8(a1 + 32, a2);
}

uint64_t sub_1008FB2B8(uint64_t a1, uint64_t a2)
{
  return sub_1000DFC90(a1 + 32, a2 + 32);
}

void *sub_1008FB2C4(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 32));
}

uint64_t sub_1008FB2CC(uint64_t result)
{
  if (*(void *)(result + 952) == 1)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I processing first command in SIM commands queue", v4, 2u);
    }
    uint64_t v3 = *(void *)(*(void *)(*(void *)(v1 + 920) + ((*(void *)(v1 + 944) >> 4) & 0xFFFFFFFFFFFFFF8))
                   + 32 * (*(void *)(v1 + 944) & 0x7FLL)
                   + 24);
    if (!v3) {
      sub_10007B600();
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 48))(v3);
  }
  return result;
}

uint64_t sub_1008FB388(uint64_t result)
{
  if (*(void *)(result + 952))
  {
    uint64_t v1 = result;
    uint64_t v2 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I processing next command in SIM commands queue", v4, 2u);
    }
    uint64_t v3 = *(void *)(*(void *)(*(void *)(v1 + 920) + ((*(void *)(v1 + 944) >> 4) & 0xFFFFFFFFFFFFFF8))
                   + 32 * (*(void *)(v1 + 944) & 0x7FLL)
                   + 24);
    if (!v3) {
      sub_10007B600();
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 48))(v3);
  }
  return result;
}

void *sub_1008FB440(void *a1)
{
  sub_100060644(a1 + 8);
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }
  return a1;
}

void *sub_1008FB488(void *a1)
{
  sub_100060644(a1 + 11);
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = (void *)a1[3];
  if (v4)
  {
    a1[4] = v4;
    operator delete(v4);
  }
  return a1;
}

void *sub_1008FB4DC(void *a1)
{
  sub_100060644(a1 + 6);
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1008FB518(Registry *a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1);
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    int v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    int v10 = 0;
  }
  std::mutex::unlock(v4);
  *a2 = v11;
  a2[1] = (uint64_t)v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

uint64_t sub_1008FB5E0(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  sub_1013B85B4(*a2, (uint64_t)a2, a3);
  int isSimReadyOrLocked = subscriber::isSimReadyOrLocked();
  uint64_t v6 = *a2;
  if (isSimReadyOrLocked)
  {
    uint64_t v7 = *(void *)(a1 + 808);
    uint64_t v8 = *(void *)(a1 + 816);
    if (v7 == v8) {
      return 1;
    }
    char v9 = 0;
    int v10 = "bootstrap profile";
    do
    {
LABEL_4:
      if (*(_DWORD *)(v7 + 4) == *(_DWORD *)(v6 + 36) && *(unsigned char *)(v7 + 80))
      {
        for (uint64_t i = *(void *)(v7 + 56); i != *(void *)(v7 + 64); i += 216)
        {
          if (*(unsigned char *)(i + 89)) {
            BOOL v12 = *(unsigned char *)(i + 88) == 0;
          }
          else {
            BOOL v12 = 1;
          }
          if (!v12)
          {
            v7 += 88;
            char v9 = 1;
            if (v7 != v8) {
              goto LABEL_4;
            }
            goto LABEL_21;
          }
        }
      }
      v7 += 88;
    }
    while (v7 != v8);
    if ((v9 & 1) == 0) {
      return 1;
    }
    int v10 = "bootstrap profile";
  }
  else
  {
    int v10 = "invalid state";
  }
LABEL_21:
  unsigned __int16 v13 = **(NSObject ***)(v6 + 352);
  BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v14)
  {
    int v16 = 136315138;
    uint64_t v17 = v10;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I PIN actions are not allowed because %s", (uint8_t *)&v16, 0xCu);
    return 0;
  }
  return result;
}

void sub_1008FB744(uint64_t a1, int a2)
{
  xpc_object_t v8 = 0;
  uint64_t v2 = (ctu::rest::detail *)a2;
  uint64_t v3 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/events/setting_session_complete");
  xpc_object_t object = v8;
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_1008FB7E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_1008FB82C(uint64_t a1, int *a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v23 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v23 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v23 = v5;
LABEL_9:
  xpc_release(v4);
  int v6 = *a2;
  uint64_t v7 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v21, (ctu::rest::detail *)v6, v7, v8);
  uint64_t v19 = &v23;
  uint64_t v20 = "first";
  sub_100035E70((uint64_t)&v19, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  int v9 = a2[1];
  uint64_t v10 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v17, (ctu::rest::detail *)v9, v10, v11);
  uint64_t v19 = &v23;
  uint64_t v20 = "second";
  sub_100035E70((uint64_t)&v19, &v17, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_object_t v12 = v23;
  if (v23) {
    xpc_retain(v23);
  }
  else {
    xpc_object_t v12 = xpc_null_create();
  }
  xpc_release(v23);
  sub_100058DB0(&__p, "/cc/events/setting_session_error");
  xpc_object_t v14 = v12;
  xpc_object_t v13 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(v14);
  if (v16 < 0) {
    operator delete(__p);
  }
  xpc_release(v13);
}

void sub_1008FB9F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_1008FBA74(uint64_t a1, int a2)
{
  int v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_1008FBAC8(uint64_t a1)
{
  return *(void *)a1;
}

void sub_1008FBAD0(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
}

void sub_1008FBAD8(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 64));
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      std::string::size_type v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&buf);
  if (v9)
  {
    uint64_t v10 = v9[3];
    uint64_t v11 = (std::__shared_weak_count *)v9[4];
    if (v11)
    {
      uint64_t v12 = v9[3];
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v10 = v12;
      sub_10004D2C8(v11);
      char v14 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v11 = 0;
  char v14 = 1;
  if (!v10)
  {
LABEL_7:
    char v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not find analytics interface, not submitting metrics.", (uint8_t *)&buf, 2u);
    }
    goto LABEL_285;
  }
LABEL_11:
  if (capabilities::ct::supportsGemini(v13))
  {
    if (*(void *)(a1 + 176) - *(void *)(a1 + 168) < 0x20uLL) {
      goto LABEL_285;
    }
    int v16 = *(_DWORD *)(a1 + 832);
    if (v16 == 2) {
      int64_t v17 = 3;
    }
    else {
      int64_t v17 = 2 * (v16 == 1);
    }
  }
  else
  {
    int64_t v17 = 1;
  }
  xpc_object_t v180 = 0;
  xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v19 = v18;
  if (v18)
  {
    xpc_object_t v180 = v18;
  }
  else
  {
    xpc_object_t v19 = xpc_null_create();
    xpc_object_t v180 = v19;
    if (!v19)
    {
      xpc_object_t v20 = xpc_null_create();
      xpc_object_t v19 = 0;
      goto LABEL_24;
    }
  }
  if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v19);
    goto LABEL_25;
  }
  xpc_object_t v20 = xpc_null_create();
LABEL_24:
  xpc_object_t v180 = v20;
LABEL_25:
  xpc_release(v19);
  xpc_object_t v178 = xpc_int64_create(v17);
  if (!v178) {
    xpc_object_t v178 = xpc_null_create();
  }
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)"dualSimCapability";
  sub_100035E70((uint64_t)&buf, &v178, &v179);
  xpc_release(v179);
  xpc_object_t v179 = 0;
  xpc_release(v178);
  xpc_object_t v178 = 0;
  long long v98 = v11;
  char v99 = v14;
  sub_100058DB0(&buf, "");
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_std::string buf = &buf;
  }
  else {
    p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v176 = xpc_string_create((const char *)p_buf);
  if (!v176) {
    xpc_object_t v176 = xpc_null_create();
  }
  v171 = &v180;
  v172 = "carrierCombo";
  sub_100035E70((uint64_t)&v171, &v176, &v177);
  xpc_release(v177);
  xpc_object_t v177 = 0;
  xpc_release(v176);
  xpc_object_t v176 = 0;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  sub_100058DB0(&buf, "");
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    xpc_object_t v22 = &buf;
  }
  else {
    xpc_object_t v22 = (std::string *)buf.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v174 = xpc_string_create((const char *)v22);
  if (!v174) {
    xpc_object_t v174 = xpc_null_create();
  }
  v171 = &v180;
  v172 = "eSimCarrierCombo";
  sub_100035E70((uint64_t)&v171, &v174, &v175);
  xpc_release(v175);
  xpc_object_t v175 = 0;
  xpc_release(v174);
  xpc_object_t v174 = 0;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  v171 = 0;
  v172 = 0;
  uint64_t v173 = 0;
  sub_1002998C4((uint64_t *)&v171, a1 + 840);
  uint64_t v24 = (std::mutex *)Registry::getServiceMap(v23, *(Registry **)(a1 + 64));
  unint64_t v25 = v24;
  if ((v26 & 0x8000000000000000) != 0)
  {
    char v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v28 = 5381;
    do
    {
      std::string::size_type v26 = v28;
      unsigned int v29 = *v27++;
      uint64_t v28 = (33 * v28) ^ v29;
    }
    while (v29);
  }
  std::mutex::lock(v24);
  buf.__r_.__value_.__r.__words[0] = v26;
  int v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)&buf);
  uint64_t v97 = v10;
  if (!v30)
  {
    uint64_t v31 = 0;
    goto LABEL_48;
  }
  uint64_t v31 = v30[3];
  int v32 = (std::__shared_weak_count *)v30[4];
  if (!v32)
  {
LABEL_48:
    std::mutex::unlock(v25);
    int v32 = 0;
    char v100 = 1;
    goto LABEL_49;
  }
  atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v25);
  atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v32);
  char v100 = 0;
LABEL_49:
  unsigned int v33 = *(uint64_t **)(a1 + 168);
  int v34 = *(uint64_t **)(a1 + 176);
  if (v33 == v34)
  {
    uint64_t v101 = 0;
    unint64_t v103 = 0;
  }
  else
  {
    uint64_t v101 = 0;
    uint64_t v102 = v31;
    unint64_t v103 = 0;
    uint64_t v35 = (uint64_t *)(a1 + 872);
    uint64_t v36 = (uint64_t *)(a1 + 424);
    do
    {
      uint64_t v37 = *(unsigned int *)(*v33 + 36);
      if (v37)
      {
        memset(&buf, 0, sizeof(buf));
        memset(&__str, 0, sizeof(__str));
        uint64_t v38 = *v35;
        if (!*v35) {
          goto LABEL_62;
        }
        uint64_t v39 = a1 + 872;
        do
        {
          int v40 = *(_DWORD *)(v38 + 32);
          BOOL v41 = v40 < (int)v37;
          if (v40 >= (int)v37) {
            CFBooleanRef v42 = (uint64_t *)v38;
          }
          else {
            CFBooleanRef v42 = (uint64_t *)(v38 + 8);
          }
          if (!v41) {
            uint64_t v39 = v38;
          }
          uint64_t v38 = *v42;
        }
        while (*v42);
        if ((uint64_t *)v39 != v35 && (int)v37 >= *(_DWORD *)(v39 + 32))
        {
          std::string::operator=(&buf, (const std::string *)(v39 + 48));
          std::string::operator=(&__str, (const std::string *)(v39 + 72));
        }
        else
        {
LABEL_62:
          long long v43 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v169.__r_.__value_.__l.__data_) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Could not find carrier bundle!", (uint8_t *)&v169, 2u);
          }
        }
        memset(&v169, 0, sizeof(v169));
        int v44 = (char *)asString();
        sub_100058DB0(&v169, v44);
        uint64_t v45 = *v36;
        if (!*v36) {
          goto LABEL_75;
        }
        uint64_t v46 = a1 + 424;
        do
        {
          int v47 = *(_DWORD *)(v45 + 28);
          BOOL v48 = v47 < (int)v37;
          if (v47 >= (int)v37) {
            uint64_t v49 = (uint64_t *)v45;
          }
          else {
            uint64_t v49 = (uint64_t *)(v45 + 8);
          }
          if (!v48) {
            uint64_t v46 = v45;
          }
          uint64_t v45 = *v49;
        }
        while (*v49);
        if ((uint64_t *)v46 != v36 && (int)v37 >= *(_DWORD *)(v46 + 28))
        {
          long long v53 = (char *)asString();
          sub_10003ED78(&v169, v53);
        }
        else
        {
LABEL_75:
          __int16 v50 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), v37);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v167) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "Could not find BB provisioned state!", (uint8_t *)&v167, 2u);
          }
        }
        sub_1013B85B4(*v33, v51, v52);
        long long v54 = (const char *)subscriber::asString();
        long long v167 = 0uLL;
        uint64_t v168 = 0;
        sub_1013B8724(*v33, (char **)&__p);
        subscriber::asString();
        if ((void)__p)
        {
          *((void *)&__p + 1) = __p;
          operator delete((void *)__p);
        }
        int v57 = *(unsigned __int8 *)(*v33 + 58);
        int v58 = *(_DWORD *)(*v33 + 52);
        sub_1013B85B4(*v33, v55, v56);
        if (subscriber::isSimPresent())
        {
          unsigned int v59 = v58 - 2;
          if (v59 <= 3) {
            unsigned int v60 = v103;
          }
          else {
            unsigned int v60 = v103 + 1;
          }
          int v61 = HIDWORD(v103);
          if (v59 < 4) {
            int v61 = HIDWORD(v103) + 1;
          }
          unint64_t v103 = __PAIR64__(v61, v60);
          long long __p = 0uLL;
          uint64_t v166 = 0;
          if (v102) {
            (*(void (**)(long long *__return_ptr))(*(void *)v102 + 16))(&__p);
          }
          else {
            sub_100058DB0(&__p, "");
          }
          if (v37 == *(_DWORD *)(a1 + 440))
          {
            if (v166 >= 0) {
              p_p = (const char *)&__p;
            }
            else {
              p_p = (const char *)__p;
            }
            xpc_object_t v163 = xpc_string_create(p_p);
            if (!v163) {
              xpc_object_t v163 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"dataPrefCarrierName";
            sub_100035E70((uint64_t)&v115, &v163, &object);
            xpc_release(object);
            xpc_object_t object = 0;
            xpc_release(v163);
            xpc_object_t v163 = 0;
          }
          if (v37 == *(_DWORD *)(a1 + 456))
          {
            if (v166 >= 0) {
              uint64_t v63 = (const char *)&__p;
            }
            else {
              uint64_t v63 = (const char *)__p;
            }
            xpc_object_t v161 = xpc_string_create(v63);
            if (!v161) {
              xpc_object_t v161 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"voicePrefCarrierName";
            sub_100035E70((uint64_t)&v115, &v161, &v162);
            xpc_release(v162);
            xpc_object_t v162 = 0;
            xpc_release(v161);
            xpc_object_t v161 = 0;
          }
          if (v37 == 2)
          {
            if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v71 = &buf;
            }
            else {
              uint64_t v71 = (std::string *)buf.__r_.__value_.__r.__words[0];
            }
            xpc_object_t v139 = xpc_string_create((const char *)v71);
            if (!v139) {
              xpc_object_t v139 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier2BundleName";
            sub_100035E70((uint64_t)&v115, &v139, &v140);
            xpc_release(v140);
            xpc_object_t v140 = 0;
            xpc_release(v139);
            xpc_object_t v139 = 0;
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              p_str = &__str;
            }
            else {
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            xpc_object_t v137 = xpc_string_create((const char *)p_str);
            if (!v137) {
              xpc_object_t v137 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier2BundleVersion";
            sub_100035E70((uint64_t)&v115, &v137, &v138);
            xpc_release(v138);
            xpc_object_t v138 = 0;
            xpc_release(v137);
            xpc_object_t v137 = 0;
            if (v166 >= 0) {
              unint64_t v73 = (const char *)&__p;
            }
            else {
              unint64_t v73 = (const char *)__p;
            }
            xpc_object_t v135 = xpc_string_create(v73);
            if (!v135) {
              xpc_object_t v135 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier2Name";
            sub_100035E70((uint64_t)&v115, &v135, &v136);
            xpc_release(v136);
            xpc_object_t v136 = 0;
            xpc_release(v135);
            xpc_object_t v135 = 0;
            xpc_object_t v133 = xpc_string_create(v54);
            if (!v133) {
              xpc_object_t v133 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier2SimState";
            sub_100035E70((uint64_t)&v115, &v133, &v134);
            xpc_release(v134);
            xpc_object_t v134 = 0;
            xpc_release(v133);
            xpc_object_t v133 = 0;
            if (v168 >= 0) {
              uint64_t v74 = (const char *)&v167;
            }
            else {
              uint64_t v74 = (const char *)v167;
            }
            xpc_object_t v131 = xpc_string_create(v74);
            if (!v131) {
              xpc_object_t v131 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier2SimType";
            sub_100035E70((uint64_t)&v115, &v131, &v132);
            xpc_release(v132);
            xpc_object_t v132 = 0;
            xpc_release(v131);
            xpc_object_t v131 = 0;
            xpc_object_t v129 = xpc_BOOL_create(v57 != 0);
            if (!v129) {
              xpc_object_t v129 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier2SimPinEnabled";
            sub_100035E70((uint64_t)&v115, &v129, &v130);
            xpc_release(v130);
            xpc_object_t v130 = 0;
            xpc_release(v129);
            xpc_object_t v129 = 0;
            xpc_object_t v127 = xpc_BOOL_create(v59 < 4);
            if (!v127) {
              xpc_object_t v127 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier2IsVinylCapable";
            sub_100035E70((uint64_t)&v115, &v127, &v128);
            xpc_release(v128);
            xpc_object_t v128 = 0;
            xpc_release(v127);
            xpc_object_t v127 = 0;
            if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v75 = &v169;
            }
            else {
              uint64_t v75 = (std::string *)v169.__r_.__value_.__r.__words[0];
            }
            xpc_object_t v125 = xpc_string_create((const char *)v75);
            if (!v125) {
              xpc_object_t v125 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier2BBServiceProvisioningState";
            sub_100035E70((uint64_t)&v115, &v125, &v126);
            xpc_release(v126);
            xpc_object_t v126 = 0;
            xpc_release(v125);
            xpc_object_t v125 = 0;
            if (v166 >= 0) {
              unint64_t v76 = (const char *)&__p;
            }
            else {
              unint64_t v76 = (const char *)__p;
            }
            xpc_object_t v123 = xpc_string_create(v76);
            if (!v123) {
              xpc_object_t v123 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrierCombo";
            sub_100035E70((uint64_t)&v115, &v123, &v124);
            xpc_release(v124);
            xpc_object_t v124 = 0;
            xpc_release(v123);
            xpc_object_t v123 = 0;
            if (v59 <= 3)
            {
              if (v166 >= 0) {
                std::string v77 = (const char *)&__p;
              }
              else {
                std::string v77 = (const char *)__p;
              }
              xpc_object_t v121 = xpc_string_create(v77);
              if (!v121) {
                xpc_object_t v121 = xpc_null_create();
              }
              v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
              v115.__r_.__value_.__l.__size_ = (std::string::size_type)"eSimCarrierCombo";
              sub_100035E70((uint64_t)&v115, &v121, &v122);
              xpc_release(v122);
              xpc_object_t v122 = 0;
              xpc_release(v121);
              xpc_object_t v121 = 0;
            }
            HIDWORD(v101) = 1;
          }
          else if (v37 == 1)
          {
            if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v64 = &buf;
            }
            else {
              uint64_t v64 = (std::string *)buf.__r_.__value_.__r.__words[0];
            }
            xpc_object_t v159 = xpc_string_create((const char *)v64);
            if (!v159) {
              xpc_object_t v159 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier1BundleName";
            sub_100035E70((uint64_t)&v115, &v159, &v160);
            xpc_release(v160);
            xpc_object_t v160 = 0;
            xpc_release(v159);
            xpc_object_t v159 = 0;
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v65 = &__str;
            }
            else {
              uint64_t v65 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            xpc_object_t v157 = xpc_string_create((const char *)v65);
            if (!v157) {
              xpc_object_t v157 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier1BundleVersion";
            sub_100035E70((uint64_t)&v115, &v157, &v158);
            xpc_release(v158);
            xpc_object_t v158 = 0;
            xpc_release(v157);
            xpc_object_t v157 = 0;
            if (v166 >= 0) {
              unint64_t v66 = (const char *)&__p;
            }
            else {
              unint64_t v66 = (const char *)__p;
            }
            xpc_object_t v155 = xpc_string_create(v66);
            if (!v155) {
              xpc_object_t v155 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier1Name";
            sub_100035E70((uint64_t)&v115, &v155, &v156);
            xpc_release(v156);
            xpc_object_t v156 = 0;
            xpc_release(v155);
            xpc_object_t v155 = 0;
            xpc_object_t v153 = xpc_string_create(v54);
            if (!v153) {
              xpc_object_t v153 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier1SimState";
            sub_100035E70((uint64_t)&v115, &v153, &v154);
            xpc_release(v154);
            xpc_object_t v154 = 0;
            xpc_release(v153);
            xpc_object_t v153 = 0;
            if (v168 >= 0) {
              uint64_t v67 = (const char *)&v167;
            }
            else {
              uint64_t v67 = (const char *)v167;
            }
            xpc_object_t v151 = xpc_string_create(v67);
            if (!v151) {
              xpc_object_t v151 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier1SimType";
            sub_100035E70((uint64_t)&v115, &v151, &v152);
            xpc_release(v152);
            xpc_object_t v152 = 0;
            xpc_release(v151);
            xpc_object_t v151 = 0;
            xpc_object_t v149 = xpc_BOOL_create(v57 != 0);
            if (!v149) {
              xpc_object_t v149 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier1SimPinEnabled";
            sub_100035E70((uint64_t)&v115, &v149, &v150);
            xpc_release(v150);
            xpc_object_t v150 = 0;
            xpc_release(v149);
            xpc_object_t v149 = 0;
            xpc_object_t v147 = xpc_BOOL_create(v59 < 4);
            if (!v147) {
              xpc_object_t v147 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier1IsVinylCapable";
            sub_100035E70((uint64_t)&v115, &v147, &v148);
            xpc_release(v148);
            xpc_object_t v148 = 0;
            xpc_release(v147);
            xpc_object_t v147 = 0;
            if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              char v68 = &v169;
            }
            else {
              char v68 = (std::string *)v169.__r_.__value_.__r.__words[0];
            }
            xpc_object_t v145 = xpc_string_create((const char *)v68);
            if (!v145) {
              xpc_object_t v145 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier1BBServiceProvisioningState";
            sub_100035E70((uint64_t)&v115, &v145, &v146);
            xpc_release(v146);
            xpc_object_t v146 = 0;
            xpc_release(v145);
            xpc_object_t v145 = 0;
            if (v166 >= 0) {
              __int16 v69 = (const char *)&__p;
            }
            else {
              __int16 v69 = (const char *)__p;
            }
            xpc_object_t v143 = xpc_string_create(v69);
            if (!v143) {
              xpc_object_t v143 = xpc_null_create();
            }
            v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
            v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrierCombo";
            sub_100035E70((uint64_t)&v115, &v143, &v144);
            xpc_release(v144);
            xpc_object_t v144 = 0;
            xpc_release(v143);
            xpc_object_t v143 = 0;
            if (v59 <= 3)
            {
              if (v166 >= 0) {
                std::string v70 = (const char *)&__p;
              }
              else {
                std::string v70 = (const char *)__p;
              }
              xpc_object_t v141 = xpc_string_create(v70);
              if (!v141) {
                xpc_object_t v141 = xpc_null_create();
              }
              v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
              v115.__r_.__value_.__l.__size_ = (std::string::size_type)"eSimCarrierCombo";
              sub_100035E70((uint64_t)&v115, &v141, &v142);
              xpc_release(v142);
              xpc_object_t v142 = 0;
              xpc_release(v141);
              xpc_object_t v141 = 0;
            }
            LODWORD(v101) = 1;
          }
          if (SHIBYTE(v166) < 0) {
            operator delete((void *)__p);
          }
        }
        if (SHIBYTE(v168) < 0) {
          operator delete((void *)v167);
        }
        if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v169.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
      v33 += 2;
    }
    while (v33 != v34);
  }
  if (HIDWORD(v103) + v103 == 1)
  {
    int64_t v80 = 1;
    if (v103 == 1) {
      int64_t v79 = 1;
    }
    else {
      int64_t v79 = 2 * (HIDWORD(v103) == 1);
    }
    uint64_t v78 = v97;
    uint64_t v11 = v98;
    char v14 = v99;
  }
  else
  {
    uint64_t v78 = v97;
    uint64_t v11 = v98;
    char v14 = v99;
    if (HIDWORD(v103) + v103 == 2)
    {
      if (v103 == 0x100000001)
      {
        int64_t v79 = 3;
        int64_t v80 = 2;
      }
      else
      {
        uint64_t v81 = 5;
        if (HIDWORD(v103) != 2) {
          uint64_t v81 = 0;
        }
        int64_t v80 = 2;
        if (v103 == 2) {
          int64_t v79 = 4;
        }
        else {
          int64_t v79 = v81;
        }
      }
    }
    else
    {
      int64_t v80 = 0;
      int64_t v79 = 0;
    }
  }
  xpc_object_t v119 = xpc_int64_create(v80);
  if (!v119) {
    xpc_object_t v119 = xpc_null_create();
  }
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)"simUsage";
  sub_100035E70((uint64_t)&buf, &v119, &v120);
  xpc_release(v120);
  xpc_object_t v120 = 0;
  xpc_release(v119);
  xpc_object_t v119 = 0;
  xpc_object_t v117 = xpc_int64_create(v79);
  if (!v117) {
    xpc_object_t v117 = xpc_null_create();
  }
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)"simCombo";
  sub_100035E70((uint64_t)&buf, &v117, &v118);
  xpc_release(v118);
  xpc_object_t v118 = 0;
  xpc_release(v117);
  xpc_object_t v117 = 0;
  memset(&__str, 0, sizeof(__str));
  memset(&v169, 0, sizeof(v169));
  if (v101 & HIDWORD(v101))
  {
    long long v167 = 0uLL;
    uint64_t v168 = 0;
    *(void *)&long long __p = &v180;
    *((void *)&__p + 1) = "carrier1Name";
    sub_100048BAC((uint64_t)&__p, &v115);
    memset(&buf, 0, sizeof(buf));
    xpc::dyn_cast_or_default();
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    xpc_release(v115.__r_.__value_.__l.__data_);
    long long __p = 0uLL;
    uint64_t v166 = 0;
    v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
    v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier2Name";
    sub_100048BAC((uint64_t)&v115, &v116);
    memset(&buf, 0, sizeof(buf));
    xpc::dyn_cast_or_default();
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    xpc_release(v116);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
    buf.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier1IsVinylCapable";
    sub_100048BAC((uint64_t)&buf, &v115);
    int v83 = xpc::dyn_cast_or_default((xpc *)&v115, 0, v82);
    xpc_release(v115.__r_.__value_.__l.__data_);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
    buf.__r_.__value_.__l.__size_ = (std::string::size_type)"carrier2IsVinylCapable";
    sub_100048BAC((uint64_t)&buf, &v115);
    int v85 = xpc::dyn_cast_or_default((xpc *)&v115, 0, v84);
    xpc_release(v115.__r_.__value_.__l.__data_);
    memset(&buf, 0, sizeof(buf));
    uint64_t v86 = HIBYTE(v168);
    if (v168 < 0) {
      uint64_t v86 = *((void *)&v167 + 1);
    }
    if (v86)
    {
      std::string::size_type v87 = sub_1000D8CE8((uint64_t *)&buf, &v167);
      buf.__r_.__value_.__l.__size_ = v87;
    }
    else
    {
      std::string::size_type v87 = 0;
    }
    uint64_t v88 = HIBYTE(v166);
    if (v166 < 0) {
      uint64_t v88 = *((void *)&__p + 1);
    }
    if (v88)
    {
      if (v87 >= buf.__r_.__value_.__r.__words[2])
      {
        std::string::size_type v87 = sub_1000D8CE8((uint64_t *)&buf, &__p);
      }
      else
      {
        if (SHIBYTE(v166) < 0)
        {
          sub_10004FC84((unsigned char *)v87, (void *)__p, *((unint64_t *)&__p + 1));
        }
        else
        {
          long long v89 = __p;
          *(void *)(v87 + 16) = v166;
          *(_OWORD *)std::string::size_type v87 = v89;
        }
        v87 += 24;
      }
      buf.__r_.__value_.__l.__size_ = v87;
    }
    unint64_t v90 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v87 - buf.__r_.__value_.__r.__words[0]) >> 3));
    if (v87 == buf.__r_.__value_.__r.__words[0]) {
      uint64_t v91 = 0;
    }
    else {
      uint64_t v91 = v90;
    }
    sub_100902218((uint64_t)buf.__r_.__value_.__l.__data_, (char *)v87, (uint64_t)&v116, v91, 1);
    sub_100062B40((std::string *)buf.__r_.__value_.__l.__data_, (std::string *)buf.__r_.__value_.__l.__size_, "/", 1uLL, &v115);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    std::string __str = v115;
    if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      v92 = &__str;
    }
    else {
      v92 = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    xpc_object_t v113 = xpc_string_create((const char *)v92);
    if (!v113) {
      xpc_object_t v113 = xpc_null_create();
    }
    v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
    v115.__r_.__value_.__l.__size_ = (std::string::size_type)"carrierCombo";
    sub_100035E70((uint64_t)&v115, &v113, &v114);
    xpc_release(v114);
    xpc_object_t v114 = 0;
    xpc_release(v113);
    xpc_object_t v113 = 0;
    if ((v83 & v85) == 1)
    {
      std::string::operator=(&v169, &__str);
      if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v93 = &v169;
      }
      else {
        long long v93 = (std::string *)v169.__r_.__value_.__r.__words[0];
      }
      xpc_object_t v111 = xpc_string_create((const char *)v93);
      if (!v111) {
        xpc_object_t v111 = xpc_null_create();
      }
      v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
      v115.__r_.__value_.__l.__size_ = (std::string::size_type)"eSimCarrierCombo";
      sub_100035E70((uint64_t)&v115, &v111, &v112);
      xpc_release(v112);
      xpc_object_t v112 = 0;
      xpc_release(v111);
      xpc_object_t v111 = 0;
    }
    xpc_object_t v109 = xpc_BOOL_create(HIDWORD(v103) == 2);
    if (!v109) {
      xpc_object_t v109 = xpc_null_create();
    }
    v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
    v115.__r_.__value_.__l.__size_ = (std::string::size_type)"isMEPEnabled";
    sub_100035E70((uint64_t)&v115, &v109, &v110);
    xpc_release(v110);
    xpc_object_t v110 = 0;
    xpc_release(v109);
    xpc_object_t v109 = 0;
    v115.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
    sub_100047F64((void ***)&v115);
    if (SHIBYTE(v166) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v168) < 0) {
      operator delete((void *)v167);
    }
  }
  uint64_t v94 = *(void *)(a1 + 808);
  if (v94 != *(void *)(a1 + 816))
  {
    if (*(_DWORD *)(v94 + 12) == 5)
    {
      long long v95 = (const char *)asString();
      xpc_object_t v107 = xpc_string_create(v95);
      if (!v107) {
        xpc_object_t v107 = xpc_null_create();
      }
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
      buf.__r_.__value_.__l.__size_ = (std::string::size_type)"PairingState";
      sub_100035E70((uint64_t)&buf, &v107, &v108);
      xpc_release(v108);
      xpc_object_t v108 = 0;
      xpc_release(v107);
      xpc_object_t v107 = 0;
    }
    else
    {
      long long v96 = (const char *)asString();
      xpc_object_t v105 = xpc_string_create(v96);
      if (!v105) {
        xpc_object_t v105 = xpc_null_create();
      }
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v180;
      buf.__r_.__value_.__l.__size_ = (std::string::size_type)"PairingState";
      sub_100035E70((uint64_t)&buf, &v105, &v106);
      xpc_release(v106);
      xpc_object_t v106 = 0;
      xpc_release(v105);
      xpc_object_t v105 = 0;
    }
  }
  xpc_object_t v104 = v180;
  if (v180) {
    xpc_retain(v180);
  }
  else {
    xpc_object_t v104 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v78 + 16))(v78, "commCenterFullSimInfo", &v104);
  xpc_release(v104);
  xpc_object_t v104 = 0;
  if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v169.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if ((v100 & 1) == 0) {
    sub_10004D2C8(v32);
  }
  sub_10019D5B8((uint64_t)&v171, v172);
  xpc_release(v180);
LABEL_285:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1008FD00C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, std::__shared_weak_count *a12, char a13, __int16 a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,xpc_object_t object)
{
  *(void *)(v31 - 104) = v30;
  xpc_object_t object = (xpc_object_t)(v31 - 112);
  sub_100047F64((void ***)&object);
  if (SLOBYTE(STACK[0x24F]) < 0) {
    operator delete((void *)STACK[0x238]);
  }
  if (SLOBYTE(STACK[0x267]) < 0) {
    operator delete((void *)STACK[0x250]);
  }
  if (*(char *)(v31 - 233) < 0) {
    operator delete(*(void **)(v31 - 256));
  }
  if (*(char *)(v31 - 201) < 0) {
    operator delete(*(void **)(v31 - 224));
  }
  if ((a15 & 1) == 0) {
    sub_10004D2C8(a12);
  }
  sub_10019D5B8(v31 - 192, *(void **)(v31 - 184));
  xpc_release(*(xpc_object_t *)(v31 - 120));
  if ((a13 & 1) == 0) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1008FD430(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  xpc_object_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    int v4 = (void *)(a1 + 40);
    xpc_object_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    int v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    int v6 = &v2[v5 >> 7];
    uint64_t v7 = (char *)*v6 + 32 * (v5 & 0x7F);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v5) >> 4) & 0xFFFFFFFFFFFFFF8))
       + 32 * ((*(void *)(a1 + 40) + v5) & 0x7F);
    if (v7 != (char *)v8)
    {
      do
      {
        uint64_t v7 = (char *)(sub_10003B34C(v7) + 4);
        if (v7 - (unsigned char *)*v6 == 4096)
        {
          int v9 = (char *)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      uint64_t v2 = *(void ***)(a1 + 8);
      xpc_object_t v3 = *(void ***)(a1 + 16);
    }
  }
  *int v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      xpc_object_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 64;
    goto LABEL_14;
  }
  if (v11 == 2)
  {
    uint64_t v12 = 128;
LABEL_14:
    *(void *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      xpc_object_t v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1008FD57C(char *a1)
{
  if (a1)
  {
    sub_1008FD57C(*(void *)a1);
    sub_1008FD57C(*((void *)a1 + 1));
    if (a1[64] && a1[63] < 0) {
      operator delete(*((void **)a1 + 5));
    }
    operator delete(a1);
  }
}

void *sub_1008FD5E0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1008FD664(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1008FD6EC()
{
}

void *sub_1008FD700(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A19058;
  result[1] = v3;
  return result;
}

uint64_t sub_1008FD748(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A19058;
  a2[1] = v2;
  return result;
}

void sub_1008FD774(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1008FD77C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008FD7BC()
{
}

void sub_1008FD7CC()
{
}

void *sub_1008FD7E0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A190D8;
  result[1] = v3;
  return result;
}

uint64_t sub_1008FD828(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A190D8;
  a2[1] = v2;
  return result;
}

void sub_1008FD854(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1008FD85C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008FD89C()
{
}

void sub_1008FD8A8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1000346F8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v10, object, 0);
    xpc_release(object[0]);
    v7[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      v7[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(object, v7, count);
    xpc_release(v7[0]);
    for (uint64_t i = v11; i != object[1] || v10 != object[0]; uint64_t i = ++v11)
    {
      v7[1] = i;
      xpc_object_t v8 = 0;
      v7[0] = &v10;
      sub_10003FBDC((uint64_t)v7, &v8);
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v6 = v8;
        v7[0] = 0;
        if (v8) {
          xpc_retain(v8);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_1008FDB24((int *)v7, &v6);
        xpc_release(v6);
        sub_100315328((uint64_t **)a1, (int *)v7, (uint64_t)v7);
      }
      xpc_release(v8);
    }
    xpc_release(v10);
    xpc_release(v10);
  }
  xpc_release(v3);
}

void sub_1008FDA94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12, xpc_object_t a13, uint64_t a14, xpc_object_t a15)
{
  xpc_release(object);
  xpc_release(a15);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_1008FDB24(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v10 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v10 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v7 = &v10;
    xpc_object_t v8 = "first";
    sub_100048BAC((uint64_t)&v7, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v11 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v11, (int *)&object, v5);
      *a1 = v11;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    uint64_t v7 = &v10;
    xpc_object_t v8 = "second";
    sub_100048BAC((uint64_t)&v7, &object);
    *((_WORD *)a1 + 2) = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
    xpc_release(object);
    xpc_object_t v3 = v10;
  }
  xpc_release(v3);
}

void sub_1008FDC88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

void sub_1008FDCDC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 144;
        sub_1008FDD60(v4);
      }
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1008FDD60(uint64_t a1)
{
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  uint64_t v4 = (void **)(a1 + 96);
  sub_10002E39C(&v4);
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    operator delete(v2);
  }
  xpc_object_t v3 = *(void **)(a1 + 40);
  if (v3)
  {
    *(void *)(a1 + 48) = v3;
    operator delete(v3);
  }
}

void *sub_1008FDDC8(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = result;
    if (a4 >> 62) {
      sub_10006A748();
    }
    uint64_t result = sub_10005ECD8((uint64_t)(result + 2), a4);
    uint64_t v7 = result;
    *uint64_t v4 = result;
    v4[1] = result;
    void v4[2] = (char *)result + 4 * v8;
    size_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memmove(result, a2, v9);
    }
    v4[1] = (char *)v7 + v9;
  }
  return result;
}

void sub_1008FDE4C(_Unwind_Exception *exception_object)
{
  xpc_object_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1008FDE68(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1008FDEEC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1008FDF70(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1008FDFF4(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    unint64_t v9 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v7 - *a1) >> 3);
    if (v9 + 1 > 0x186186186186186) {
      sub_10006A748();
    }
    unint64_t v10 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v5 - *a1) >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    if (v10 >= 0xC30C30C30C30C3) {
      unint64_t v12 = 0x186186186186186;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v18 = v4;
    if (v12) {
      xpc_object_t v13 = (char *)sub_10008A268(v4, v12);
    }
    else {
      xpc_object_t v13 = 0;
    }
    uint64_t v14 = v13;
    uint64_t v15 = &v13[168 * v9];
    int64_t v17 = &v13[168 * v12];
    sub_10008A2B4((uint64_t)v15, a2);
    int v16 = v15 + 168;
    sub_10008A1D4(a1, &v14);
    uint64_t v8 = a1[1];
    sub_10008A370((uint64_t)&v14);
  }
  else
  {
    sub_10008A2B4(*(void *)(v4 - 8), a2);
    uint64_t v8 = v7 + 168;
    a1[1] = v7 + 168;
  }
  a1[1] = v8;
}

void sub_1008FE11C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10008A370((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1008FE130(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
LABEL_1:
  uint64_t v9 = a2 - 168;
  unint64_t v10 = a1;
LABEL_2:
  uint64_t v11 = 1 - a3;
  while (1)
  {
    a1 = v10;
    uint64_t v12 = v11;
    uint64_t v13 = a2 - v10;
    unint64_t v14 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(a2 - v10) >> 3);
    if (!(!v5 & v4))
    {
      switch(v14)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          sub_10002E664((uint64_t)v94, a2 - 168);
          sub_10002E664((uint64_t)v82, v10);
          int v26 = v94[0];
          int v27 = v82[0];
          if (v93 < 0) {
            operator delete(v92);
          }
          if (v91 < 0) {
            operator delete(v90);
          }
          if (v89 < 0) {
            operator delete(v88);
          }
          if (v87 < 0) {
            operator delete(v86);
          }
          v156[0] = (void **)&v85;
          sub_10002E39C(v156);
          if (v83)
          {
            BOOL v84 = v83;
            operator delete(v83);
          }
          if (v105 < 0) {
            operator delete(v104);
          }
          if (v103 < 0) {
            operator delete(v102);
          }
          if (v101 < 0) {
            operator delete(v100);
          }
          if (v99 < 0) {
            operator delete(v98);
          }
          v156[0] = (void **)&v97;
          sub_10002E39C(v156);
          if (v95)
          {
            long long v96 = v95;
            operator delete(v95);
          }
          if (v26 < v27) {
            sub_100901744(v10, v9);
          }
          break;
        case 3uLL:
          sub_1008FFCD0(v10, v10 + 168, a2 - 168);
          break;
        case 4uLL:
          sub_100901874(v10, v10 + 168, v10 + 336, a2 - 168);
          break;
        case 5uLL:
          sub_1008FED34(v10, v10 + 168, v10 + 336, v10 + 504, a2 - 168);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v13 <= 4031) {
      break;
    }
    if (v12 == 1)
    {
      sub_1008FF20C(v10, a2, a2);
      return;
    }
    unint64_t v15 = v14 >> 1;
    uint64_t v16 = v10 + 168 * (v14 >> 1);
    if ((unint64_t)v13 >= 0x5401)
    {
      sub_1008FFCD0(v10, v10 + 168 * (v14 >> 1), a2 - 168);
      uint64_t v17 = 168 * v15;
      uint64_t v18 = 168 * v15 + v10 - 168;
      sub_1008FFCD0(v10 + 168, v18, a2 - 336);
      uint64_t v19 = v10 + 336;
      uint64_t v20 = v10 + 168 + v17;
      sub_1008FFCD0(v19, v20, a2 - 504);
      sub_1008FFCD0(v18, v16, v20);
      sub_100901744(a1, v16);
      if (a4) {
        goto LABEL_34;
      }
    }
    else
    {
      sub_1008FFCD0(v10 + 168 * (v14 >> 1), v10, a2 - 168);
      if (a4) {
        goto LABEL_34;
      }
    }
    sub_10002E664((uint64_t)v70, a1 - 168);
    sub_10002E664((uint64_t)v58, a1);
    int v21 = v70[0];
    int v22 = v58[0];
    if (v69 < 0) {
      operator delete(__p);
    }
    if (v67 < 0) {
      operator delete(v66);
    }
    if (v65 < 0) {
      operator delete(v64);
    }
    if (v63 < 0) {
      operator delete(v62);
    }
    v156[0] = (void **)&v61;
    sub_10002E39C(v156);
    if (v59)
    {
      unsigned int v60 = v59;
      operator delete(v59);
    }
    if (v81 < 0) {
      operator delete(v80);
    }
    if (v79 < 0) {
      operator delete(v78);
    }
    if (v77 < 0) {
      operator delete(v76);
    }
    if (v75 < 0) {
      operator delete(v74);
    }
    v156[0] = (void **)&v73;
    sub_10002E39C(v156);
    if (v71)
    {
      unint64_t v72 = v71;
      operator delete(v71);
    }
    if (v21 >= v22)
    {
      unint64_t v10 = sub_100900230(a1, a2);
      goto LABEL_39;
    }
LABEL_34:
    uint64_t v23 = sub_100900A0C(a1, a2);
    if ((v24 & 1) == 0) {
      goto LABEL_37;
    }
    BOOL v25 = sub_10090110C(a1, v23);
    unint64_t v10 = v23 + 168;
    if (sub_10090110C(v23 + 168, a2))
    {
      a3 = -v12;
      a2 = v23;
      if (v25) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v11 = v12 + 1;
    if (!v25)
    {
LABEL_37:
      sub_1008FE130(a1, v23, -v12, a4 & 1);
      unint64_t v10 = v23 + 168;
LABEL_39:
      a4 = 0;
      a3 = -v12;
      goto LABEL_2;
    }
  }
  if ((a4 & 1) == 0)
  {
    if (v10 != a2)
    {
      uint64_t v45 = v10 + 168;
      if (v10 + 168 != a2)
      {
        do
        {
          uint64_t v46 = (long long *)v45;
          sub_10002E664((uint64_t)v156, v45);
          sub_10002E664((uint64_t)v144, a1);
          int v47 = (int)v156[0];
          int v48 = v144[0];
          if (v155 < 0) {
            operator delete(v154);
          }
          if (v153 < 0) {
            operator delete(v152);
          }
          if (v151 < 0) {
            operator delete(v150);
          }
          if (v149 < 0) {
            operator delete(v148);
          }
          *(void *)&long long v130 = v147;
          sub_10002E39C((void ***)&v130);
          if (v145)
          {
            xpc_object_t v146 = v145;
            operator delete(v145);
          }
          if (v167 < 0) {
            operator delete(v166);
          }
          if (v165 < 0) {
            operator delete(v164);
          }
          if (v163 < 0) {
            operator delete(v162);
          }
          if (v161 < 0) {
            operator delete(v160);
          }
          *(void *)&long long v130 = v159;
          sub_10002E39C((void ***)&v130);
          if (v157)
          {
            xpc_object_t v158 = v157;
            operator delete(v157);
          }
          if (v47 < v48)
          {
            uint64_t v135 = 0;
            long long v49 = *(_OWORD *)(a1 + 184);
            long long v130 = *v46;
            *(_OWORD *)xpc_object_t v131 = v49;
            uint64_t v50 = *(void *)(a1 + 200);
            *(void *)(a1 + 184) = 0;
            *(void *)(a1 + 192) = 0;
            long long v133 = *(_OWORD *)(a1 + 208);
            uint64_t v51 = *(void *)(a1 + 224);
            uint64_t v132 = v50;
            uint64_t v134 = v51;
            *(void *)(a1 + 200) = 0;
            *(void *)(a1 + 208) = 0;
            *(void *)(a1 + 216) = 0;
            *(void *)(a1 + 224) = 0;
            LODWORD(v50) = *(_DWORD *)(a1 + 232);
            WORD2(v135) = *(_WORD *)(a1 + 236);
            LODWORD(v135) = v50;
            long long v52 = *(_OWORD *)(a1 + 240);
            uint64_t v137 = *(void *)(a1 + 256);
            long long v136 = v52;
            *(void *)(a1 + 240) = 0;
            *(void *)(a1 + 248) = 0;
            *(void *)(a1 + 256) = 0;
            long long v53 = *(_OWORD *)(a1 + 264);
            uint64_t v139 = *(void *)(a1 + 280);
            long long v138 = v53;
            *(void *)(a1 + 264) = 0;
            *(void *)(a1 + 272) = 0;
            *(void *)(a1 + 280) = 0;
            long long v54 = *(_OWORD *)(a1 + 288);
            uint64_t v141 = *(void *)(a1 + 304);
            long long v140 = v54;
            *(void *)(a1 + 288) = 0;
            *(void *)(a1 + 296) = 0;
            *(void *)(a1 + 304) = 0;
            long long v55 = *(_OWORD *)(a1 + 312);
            uint64_t v143 = *(void *)(a1 + 328);
            long long v142 = v55;
            *(void *)(a1 + 312) = 0;
            *(void *)(a1 + 320) = 0;
            *(void *)(a1 + 328) = 0;
            do
            {
              sub_10032FAFC(a1 + 168, a1);
              sub_10002E664((uint64_t)v118, (uint64_t)&v130);
              a1 -= 168;
              sub_10002E664((uint64_t)v106, a1);
              int v56 = v118[0];
              int v57 = v106[0];
              if (v117 < 0) {
                operator delete(v116);
              }
              if (v115 < 0) {
                operator delete(v114);
              }
              if (v113 < 0) {
                operator delete(v112);
              }
              if (v111 < 0) {
                operator delete(v110);
              }
              v168[0] = (void **)v109;
              sub_10002E39C(v168);
              if (v107)
              {
                xpc_object_t v108 = v107;
                operator delete(v107);
              }
              if (v129 < 0) {
                operator delete(v128);
              }
              if (v127 < 0) {
                operator delete(v126);
              }
              if (v125 < 0) {
                operator delete(v124);
              }
              if (v123 < 0) {
                operator delete(v122);
              }
              v168[0] = (void **)v121;
              sub_10002E39C(v168);
              if (v119)
              {
                xpc_object_t v120 = v119;
                operator delete(v119);
              }
            }
            while (v56 < v57);
            sub_10032FAFC(a1 + 168, (uint64_t)&v130);
            if (SHIBYTE(v143) < 0) {
              operator delete((void *)v142);
            }
            if (SHIBYTE(v141) < 0) {
              operator delete((void *)v140);
            }
            if (SHIBYTE(v139) < 0) {
              operator delete((void *)v138);
            }
            if (SHIBYTE(v137) < 0) {
              operator delete((void *)v136);
            }
            v168[0] = (void **)&v133;
            sub_10002E39C(v168);
            if (v131[0])
            {
              v131[1] = v131[0];
              operator delete(v131[0]);
            }
          }
          uint64_t v45 = (uint64_t)v46 + 168;
          a1 = (uint64_t)v46;
        }
        while ((long long *)((char *)v46 + 168) != (long long *)a2);
      }
    }
    return;
  }
  if (v10 == a2) {
    return;
  }
  uint64_t v28 = v10 + 168;
  if (v10 + 168 == a2) {
    return;
  }
  uint64_t v29 = 0;
  uint64_t v30 = a1;
  while (2)
  {
    uint64_t v31 = (long long *)v28;
    sub_10002E664((uint64_t)v156, v28);
    sub_10002E664((uint64_t)v144, v30);
    int v32 = (int)v156[0];
    int v33 = v144[0];
    if (v155 < 0) {
      operator delete(v154);
    }
    if (v153 < 0) {
      operator delete(v152);
    }
    if (v151 < 0) {
      operator delete(v150);
    }
    if (v149 < 0) {
      operator delete(v148);
    }
    *(void *)&long long v130 = v147;
    sub_10002E39C((void ***)&v130);
    if (v145)
    {
      xpc_object_t v146 = v145;
      operator delete(v145);
    }
    if (v167 < 0) {
      operator delete(v166);
    }
    if (v165 < 0) {
      operator delete(v164);
    }
    if (v163 < 0) {
      operator delete(v162);
    }
    if (v161 < 0) {
      operator delete(v160);
    }
    *(void *)&long long v130 = v159;
    sub_10002E39C((void ***)&v130);
    if (v157)
    {
      xpc_object_t v158 = v157;
      operator delete(v157);
    }
    if (v32 >= v33) {
      goto LABEL_130;
    }
    uint64_t v135 = 0;
    long long v34 = *(_OWORD *)(v30 + 184);
    long long v130 = *v31;
    *(_OWORD *)xpc_object_t v131 = v34;
    uint64_t v35 = *(void *)(v30 + 200);
    *(void *)(v30 + 184) = 0;
    *(void *)(v30 + 192) = 0;
    long long v133 = *(_OWORD *)(v30 + 208);
    uint64_t v36 = *(void *)(v30 + 224);
    uint64_t v132 = v35;
    uint64_t v134 = v36;
    *(void *)(v30 + 200) = 0;
    *(void *)(v30 + 208) = 0;
    *(void *)(v30 + 216) = 0;
    *(void *)(v30 + 224) = 0;
    LODWORD(v35) = *(_DWORD *)(v30 + 232);
    WORD2(v135) = *(_WORD *)(v30 + 236);
    LODWORD(v135) = v35;
    long long v37 = *(_OWORD *)(v30 + 240);
    uint64_t v137 = *(void *)(v30 + 256);
    long long v136 = v37;
    *(void *)(v30 + 240) = 0;
    *(void *)(v30 + 248) = 0;
    *(void *)(v30 + 256) = 0;
    long long v38 = *(_OWORD *)(v30 + 264);
    uint64_t v139 = *(void *)(v30 + 280);
    long long v138 = v38;
    *(void *)(v30 + 264) = 0;
    *(void *)(v30 + 272) = 0;
    *(void *)(v30 + 280) = 0;
    long long v39 = *(_OWORD *)(v30 + 288);
    uint64_t v141 = *(void *)(v30 + 304);
    long long v140 = v39;
    *(void *)(v30 + 288) = 0;
    *(void *)(v30 + 296) = 0;
    *(void *)(v30 + 304) = 0;
    long long v40 = *(_OWORD *)(v30 + 312);
    uint64_t v143 = *(void *)(v30 + 328);
    long long v142 = v40;
    *(void *)(v30 + 312) = 0;
    *(void *)(v30 + 320) = 0;
    *(void *)(v30 + 328) = 0;
    sub_10032FAFC((uint64_t)v31, v30);
    uint64_t v41 = a1;
    if (v30 == a1) {
      goto LABEL_120;
    }
    uint64_t v42 = v29;
    while (2)
    {
      sub_10002E664((uint64_t)v118, (uint64_t)&v130);
      sub_10002E664((uint64_t)v106, a1 + v42 - 168);
      int v43 = v118[0];
      int v44 = v106[0];
      if (v117 < 0) {
        operator delete(v116);
      }
      if (v115 < 0) {
        operator delete(v114);
      }
      if (v113 < 0) {
        operator delete(v112);
      }
      if (v111 < 0) {
        operator delete(v110);
      }
      v168[0] = (void **)v109;
      sub_10002E39C(v168);
      if (v107)
      {
        xpc_object_t v108 = v107;
        operator delete(v107);
      }
      if (v129 < 0) {
        operator delete(v128);
      }
      if (v127 < 0) {
        operator delete(v126);
      }
      if (v125 < 0) {
        operator delete(v124);
      }
      if (v123 < 0) {
        operator delete(v122);
      }
      v168[0] = (void **)v121;
      sub_10002E39C(v168);
      if (v119)
      {
        xpc_object_t v120 = v119;
        operator delete(v119);
        if (v43 >= v44)
        {
          uint64_t v41 = a1 + v42;
          goto LABEL_120;
        }
LABEL_117:
        v30 -= 168;
        sub_10032FAFC(a1 + v42, a1 + v42 - 168);
        v42 -= 168;
        if (!v42)
        {
          uint64_t v41 = a1;
          goto LABEL_120;
        }
        continue;
      }
      break;
    }
    if (v43 < v44) {
      goto LABEL_117;
    }
    uint64_t v41 = v30;
LABEL_120:
    sub_10032FAFC(v41, (uint64_t)&v130);
    if (SHIBYTE(v143) < 0) {
      operator delete((void *)v142);
    }
    if (SHIBYTE(v141) < 0) {
      operator delete((void *)v140);
    }
    if (SHIBYTE(v139) < 0) {
      operator delete((void *)v138);
    }
    if (SHIBYTE(v137) < 0) {
      operator delete((void *)v136);
    }
    v168[0] = (void **)&v133;
    sub_10002E39C(v168);
    if (v131[0])
    {
      v131[1] = v131[0];
      operator delete(v131[0]);
    }
LABEL_130:
    uint64_t v28 = (uint64_t)v31 + 168;
    v29 += 168;
    uint64_t v30 = (uint64_t)v31;
    if ((long long *)((char *)v31 + 168) != (long long *)a2) {
      continue;
    }
    break;
  }
}

  uint64_t v11 = a2 - 24;
  uint64_t v12 = (void **)a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = (uint64_t)v12;
    unint64_t v14 = v13;
    unint64_t v15 = a2 - (char *)v12;
    uint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((a2 - (char *)v12) >> 3);
    if (!(!v6 & v5))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if ((sub_100046FE8((void *)a2 - 3, v12) & 0x80) != 0)
          {
            uint64_t v31 = v12[2];
            uint64_t v29 = *(_OWORD *)v12;
            int v27 = *(_OWORD *)v11;
            void v12[2] = (void *)*((void *)a2 - 1);
            *(_OWORD *)uint64_t v12 = v27;
            *(_OWORD *)uint64_t v11 = v29;
            *((void *)a2 - 1) = v31;
          }
          break;
        case 3uLL:
          sub_100902854(v12, v12 + 3, (void *)a2 - 3);
          break;
        case 4uLL:
          sub_100902EC4((uint64_t)v12, v12 + 3, v12 + 6, (void *)a2 - 3);
          break;
        case 5uLL:
          sub_100902F98((uint64_t)v12, v12 + 3, v12 + 6, v12 + 9, (void *)a2 - 3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 575) {
      break;
    }
    if (v14 == 1)
    {
      if (v12 != (void **)a2)
      {
        sub_1009030A8((uint64_t)v12, a2, a2, a3);
      }
      return;
    }
    uint64_t v17 = v16 >> 1;
    uint64_t v18 = &v12[3 * (v16 >> 1)];
    if ((unint64_t)v15 >= 0xC01)
    {
      sub_100902854(v12, &v12[3 * (v16 >> 1)], (void *)a2 - 3);
      uint64_t v19 = 3 * v17;
      uint64_t v20 = &v12[3 * v17 - 3];
      sub_100902854(v12 + 3, v20, (void *)a2 - 6);
      int v21 = v12 + 6;
      int v22 = &v12[v19 + 3];
      sub_100902854(v21, v22, (void *)a2 - 9);
      sub_100902854(v20, v18, v22);
      uint64_t v30 = *(void **)(a1 + 16);
      uint64_t v28 = *(_OWORD *)a1;
      uint64_t v23 = *(_OWORD *)v18;
      *(void *)(a1 + 16) = v18[2];
      *(_OWORD *)a1 = v23;
      v18[2] = v30;
      *(_OWORD *)uint64_t v18 = v28;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_100902854(&v12[3 * (v16 >> 1)], v12, (void *)a2 - 3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if ((sub_100046FE8((void *)(a1 - 24), (void **)a1) & 0x80) == 0)
    {
      uint64_t v12 = sub_100902990((void **)a1, (unint64_t)a2);
      goto LABEL_18;
    }
LABEL_13:
    char v24 = (void **)sub_100902B08((long long *)a1, a2);
    if ((v25 & 1) == 0) {
      goto LABEL_16;
    }
    int v26 = sub_100902C88(a1, v24);
    uint64_t v12 = v24 + 3;
    if (sub_100902C88((uint64_t)(v24 + 3), (void **)a2))
    {
      a4 = -v14;
      a2 = (char *)v24;
      if (v26) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v26)
    {
LABEL_16:
      sub_100902218(a1, v24, a3, -v14, a5 & 1);
      uint64_t v12 = v24 + 3;
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_100902638((uint64_t)v12, a2);
  }
  else
  {
    sub_100902754(v12, a2);
  }
}

  char v127 = a2 - 16;
  unint64_t v10 = (unint64_t)a1;
  while (1)
  {
    a1 = (void *)v10;
    uint64_t v11 = (uint64_t)&a2[-v10];
    uint64_t v12 = (uint64_t)&a2[-v10] >> 4;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return;
        case 2:
          uint64_t v50 = *((void *)a2 - 2);
          uint64_t v51 = *a1;
          if (*(_DWORD *)(v50 + 148) < *(_DWORD *)(*a1 + 148))
          {
            *a1 = v50;
            *((void *)a2 - 2) = v51;
            long long v52 = a1[1];
            a1[1] = *((void *)a2 - 1);
            *((void *)a2 - 1) = v52;
          }
          break;
        case 3:
          sub_100BC4440(a1, a1 + 2, v127);
          break;
        case 4:
          sub_100BC4788(a1, a1 + 2, a1 + 4, v127);
          break;
        case 5:
          sub_100BC4788(a1, a1 + 2, a1 + 4, a1 + 6);
          long long v53 = *((void *)a2 - 2);
          long long v54 = a1[6];
          if (*(_DWORD *)(v53 + 148) < *(_DWORD *)(v54 + 148))
          {
            a1[6] = v53;
            *((void *)a2 - 2) = v54;
            long long v55 = a1[7];
            a1[7] = *((void *)a2 - 1);
            *((void *)a2 - 1) = v55;
            int v56 = a1[6];
            int v57 = *(_DWORD *)(v56 + 148);
            int v58 = a1[4];
            if (v57 < *(_DWORD *)(v58 + 148))
            {
              unsigned int v59 = a1[5];
              unsigned int v60 = a1[7];
              a1[4] = v56;
              a1[5] = v60;
              a1[6] = v58;
              a1[7] = v59;
              uint64_t v61 = a1[2];
              if (v57 < *(_DWORD *)(v61 + 148))
              {
                uint64_t v62 = a1[3];
                a1[2] = v56;
                a1[3] = v60;
                a1[4] = v61;
                a1[5] = v62;
                char v63 = *a1;
                if (v57 < *(_DWORD *)(*a1 + 148))
                {
                  uint64_t v64 = a1[1];
                  *a1 = v56;
                  a1[1] = v60;
                  a1[2] = v63;
                  a1[3] = v64;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 383) {
      break;
    }
    if (!a3)
    {
      if (a1 == (void *)a2) {
        return;
      }
      int64_t v80 = (unint64_t)(v12 - 2) >> 1;
      char v81 = v80;
      do
      {
        BOOL v82 = v81;
        if (v80 >= v81)
        {
          int v83 = (2 * v81) | 1;
          BOOL v84 = &a1[2 * v83];
          if (2 * v82 + 2 < v12)
          {
            uint64_t v85 = *v84;
            if (*(_DWORD *)(*v84 + 148) < *(_DWORD *)(v84[2] + 148))
            {
              uint64_t v85 = v84[2];
              v84 += 2;
              int v83 = 2 * v82 + 2;
            }
          }
          else
          {
            uint64_t v85 = *v84;
          }
          uint64_t v86 = &a1[2 * v82];
          char v87 = *v86;
          if (*(_DWORD *)(v85 + 148) >= *(_DWORD *)(*v86 + 148))
          {
            uint64_t v88 = a1[2 * v82 + 1];
            void *v86 = 0;
            v86[1] = 0;
            char v89 = *v84;
            do
            {
              unint64_t v90 = v84;
              char v91 = v84[1];
              *unint64_t v90 = 0;
              v90[1] = 0;
              v92 = (std::__shared_weak_count *)v86[1];
              void *v86 = v89;
              v86[1] = v91;
              if (v92) {
                sub_10004D2C8(v92);
              }
              if (v80 < v83) {
                break;
              }
              BOOL v84 = &a1[2 * ((2 * v83) | 1)];
              if (2 * v83 + 2 < v12)
              {
                char v89 = *v84;
                if (*(_DWORD *)(*v84 + 148) >= *(_DWORD *)(v84[2] + 148))
                {
                  int v83 = (2 * v83) | 1;
                }
                else
                {
                  char v89 = v84[2];
                  v84 += 2;
                  int v83 = 2 * v83 + 2;
                }
              }
              else
              {
                char v89 = *v84;
                int v83 = (2 * v83) | 1;
              }
              uint64_t v86 = v90;
            }
            while (*(_DWORD *)(v89 + 148) >= *(_DWORD *)(v87 + 148));
            char v93 = (std::__shared_weak_count *)v90[1];
            *unint64_t v90 = v87;
            v90[1] = v88;
            if (v93) {
              sub_10004D2C8(v93);
            }
          }
        }
        char v81 = v82 - 1;
      }
      while (v82);
      uint64_t v94 = (unint64_t)v11 >> 4;
      while (2)
      {
        long long v95 = 0;
        long long v96 = a2;
        long long v98 = *a1;
        uint64_t v97 = a1[1];
        *a1 = 0;
        a1[1] = 0;
        char v99 = (char *)a1;
        do
        {
          char v100 = &v99[16 * v95 + 16];
          if (2 * v95 + 2 >= v94)
          {
            char v101 = *(void *)v100;
            long long v95 = (2 * v95) | 1;
          }
          else
          {
            char v101 = *(void *)v100;
            if (*(_DWORD *)(*(void *)v100 + 148) >= *(_DWORD *)(*(void *)&v99[16 * v95 + 32] + 148))
            {
              long long v95 = (2 * v95) | 1;
            }
            else
            {
              char v101 = *(void *)&v99[16 * v95 + 32];
              char v100 = &v99[16 * v95 + 32];
              long long v95 = 2 * v95 + 2;
            }
          }
          uint64_t v102 = *((void *)v100 + 1);
          *(void *)char v100 = 0;
          *((void *)v100 + 1) = 0;
          char v103 = (std::__shared_weak_count *)*((void *)v99 + 1);
          *(void *)char v99 = v101;
          *((void *)v99 + 1) = v102;
          if (v103) {
            sub_10004D2C8(v103);
          }
          char v99 = v100;
        }
        while (v95 <= (uint64_t)((unint64_t)(v94 - 2) >> 1));
        a2 -= 16;
        if (v100 == v96 - 16)
        {
          xpc_object_t v116 = (std::__shared_weak_count *)*((void *)v100 + 1);
          *(void *)char v100 = v98;
          *((void *)v100 + 1) = v97;
          if (!v116) {
            goto LABEL_141;
          }
        }
        else
        {
          xpc_object_t v104 = *((_OWORD *)v96 - 1);
          *(void *)a2 = 0;
          *((void *)v96 - 1) = 0;
          char v105 = (std::__shared_weak_count *)*((void *)v100 + 1);
          *(_OWORD *)char v100 = v104;
          if (v105) {
            sub_10004D2C8(v105);
          }
          xpc_object_t v106 = (std::__shared_weak_count *)*((void *)v96 - 1);
          *((void *)v96 - 2) = v98;
          *((void *)v96 - 1) = v97;
          if (v106) {
            sub_10004D2C8(v106);
          }
          xpc_object_t v107 = v100 + 16 - (char *)a1;
          if (v107 < 17) {
            goto LABEL_141;
          }
          xpc_object_t v108 = (((unint64_t)v107 >> 4) - 2) >> 1;
          xpc_object_t v109 = (char *)&a1[2 * v108];
          xpc_object_t v110 = *(void *)v100;
          if (*(_DWORD *)(*(void *)v109 + 148) >= *(_DWORD *)(*(void *)v100 + 148)) {
            goto LABEL_141;
          }
          char v111 = *((void *)v100 + 1);
          *(void *)char v100 = 0;
          *((void *)v100 + 1) = 0;
          xpc_object_t v112 = *(void *)v109;
          do
          {
            char v113 = v109;
            xpc_object_t v114 = *((void *)v109 + 1);
            *(void *)char v113 = 0;
            *((void *)v113 + 1) = 0;
            char v115 = (std::__shared_weak_count *)*((void *)v100 + 1);
            *(void *)char v100 = v112;
            *((void *)v100 + 1) = v114;
            if (v115) {
              sub_10004D2C8(v115);
            }
            if (!v108) {
              break;
            }
            xpc_object_t v108 = (v108 - 1) >> 1;
            xpc_object_t v109 = (char *)&a1[2 * v108];
            xpc_object_t v112 = *(void *)v109;
            char v100 = v113;
          }
          while (*(_DWORD *)(*(void *)v109 + 148) < *(_DWORD *)(v110 + 148));
          xpc_object_t v116 = (std::__shared_weak_count *)*((void *)v113 + 1);
          *(void *)char v113 = v110;
          *((void *)v113 + 1) = v111;
          if (!v116)
          {
LABEL_141:
            if (v94-- <= 2) {
              return;
            }
            continue;
          }
        }
        break;
      }
      sub_10004D2C8(v116);
      goto LABEL_141;
    }
    uint64_t v13 = (unint64_t)v12 >> 1;
    unint64_t v14 = &a1[2 * ((unint64_t)v12 >> 1)];
    if ((unint64_t)v11 < 0x801)
    {
      sub_100BC4440(v14, a1, v127);
    }
    else
    {
      sub_100BC4440(a1, v14, v127);
      sub_100BC4440(a1 + 2, v14 - 2, (void *)a2 - 4);
      sub_100BC4440(a1 + 4, &a1[2 * v13 + 2], (void *)a2 - 6);
      sub_100BC4440(v14 - 2, v14, &a1[2 * v13 + 2]);
      unint64_t v15 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)v14;
      *(_OWORD *)unint64_t v14 = v15;
    }
    --a3;
    uint64_t v16 = *a1;
    if ((a4 & 1) != 0 || *(_DWORD *)(*(a1 - 2) + 148) < *(_DWORD *)(v16 + 148))
    {
      uint64_t v17 = 0;
      uint64_t v18 = a1[1];
      *a1 = 0;
      a1[1] = 0;
      uint64_t v19 = *(_DWORD *)(v16 + 148);
      do
      {
        uint64_t v20 = a1[v17 + 2];
        v17 += 2;
      }
      while (*(_DWORD *)(v20 + 148) < v19);
      int v21 = (char *)&a1[v17];
      int v22 = a2;
      if (v17 == 2)
      {
        int v22 = a2;
        do
        {
          if (v21 >= v22) {
            break;
          }
          char v24 = *((void *)v22 - 2);
          v22 -= 16;
        }
        while (*(_DWORD *)(v24 + 148) >= v19);
      }
      else
      {
        do
        {
          uint64_t v23 = *((void *)v22 - 2);
          v22 -= 16;
        }
        while (*(_DWORD *)(v23 + 148) >= v19);
      }
      if (v21 >= v22)
      {
        unint64_t v10 = (unint64_t)&a1[v17];
      }
      else
      {
        BOOL v25 = *(void *)v22;
        int v26 = v22;
        unint64_t v10 = (unint64_t)v21;
        do
        {
          *(void *)unint64_t v10 = v25;
          *(void *)int v26 = v20;
          int v27 = *(void *)(v10 + 8);
          *(void *)(v10 + 8) = *((void *)v26 + 1);
          *((void *)v26 + 1) = v27;
          do
          {
            uint64_t v28 = *(void *)(v10 + 16);
            v10 += 16;
            uint64_t v20 = v28;
          }
          while (*(_DWORD *)(v28 + 148) < v19);
          do
          {
            uint64_t v29 = *((void *)v26 - 2);
            v26 -= 16;
            BOOL v25 = v29;
          }
          while (*(_DWORD *)(v29 + 148) >= v19);
        }
        while (v10 < (unint64_t)v26);
      }
      uint64_t v30 = (long long *)(v10 - 16);
      if ((void *)(v10 - 16) != a1)
      {
        uint64_t v31 = *v30;
        *(void *)uint64_t v30 = 0;
        *(void *)(v10 - 8) = 0;
        int v32 = (std::__shared_weak_count *)a1[1];
        *(_OWORD *)a1 = v31;
        if (v32) {
          sub_10004D2C8(v32);
        }
      }
      int v33 = *(std::__shared_weak_count **)(v10 - 8);
      *(void *)(v10 - 16) = v16;
      *(void *)(v10 - 8) = v18;
      if (v33) {
        sub_10004D2C8(v33);
      }
      if (v21 < v22) {
        goto LABEL_35;
      }
      long long v34 = sub_100BC4514((char *)a1, (char *)(v10 - 16));
      if (sub_100BC4514((char *)v10, a2))
      {
        a2 = (char *)(v10 - 16);
        if (v34) {
          return;
        }
        goto LABEL_1;
      }
      if (!v34)
      {
LABEL_35:
        sub_100BC3B38(a1, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v35 = a1[1];
      *a1 = 0;
      a1[1] = 0;
      uint64_t v36 = *(_DWORD *)(v16 + 148);
      if (v36 >= *(_DWORD *)(*(void *)v127 + 148))
      {
        long long v38 = (char *)(a1 + 2);
        do
        {
          unint64_t v10 = (unint64_t)v38;
          if (v38 >= a2) {
            break;
          }
          v38 += 16;
        }
        while (v36 >= *(_DWORD *)(*(void *)v10 + 148));
      }
      else
      {
        unint64_t v10 = (unint64_t)a1;
        do
        {
          long long v37 = *(void *)(v10 + 16);
          v10 += 16;
        }
        while (v36 >= *(_DWORD *)(v37 + 148));
      }
      long long v39 = a2;
      if (v10 < (unint64_t)a2)
      {
        long long v39 = a2;
        do
        {
          long long v40 = *((void *)v39 - 2);
          v39 -= 16;
        }
        while (v36 < *(_DWORD *)(v40 + 148));
      }
      if (v10 < (unint64_t)v39)
      {
        uint64_t v41 = *(void *)v10;
        uint64_t v42 = *(void *)v39;
        do
        {
          *(void *)unint64_t v10 = v42;
          *(void *)long long v39 = v41;
          int v43 = *(void *)(v10 + 8);
          *(void *)(v10 + 8) = *((void *)v39 + 1);
          *((void *)v39 + 1) = v43;
          do
          {
            int v44 = *(void *)(v10 + 16);
            v10 += 16;
            uint64_t v41 = v44;
          }
          while (v36 >= *(_DWORD *)(v44 + 148));
          do
          {
            uint64_t v45 = *((void *)v39 - 2);
            v39 -= 16;
            uint64_t v42 = v45;
          }
          while (v36 < *(_DWORD *)(v45 + 148));
        }
        while (v10 < (unint64_t)v39);
      }
      uint64_t v46 = (long long *)(v10 - 16);
      char v4 = v10 - 16 >= (unint64_t)a1;
      char v5 = v10 - 16 == (void)a1;
      if ((void *)(v10 - 16) != a1)
      {
        int v47 = *v46;
        *(void *)uint64_t v46 = 0;
        *(void *)(v10 - 8) = 0;
        int v48 = (std::__shared_weak_count *)a1[1];
        *(_OWORD *)a1 = v47;
        if (v48) {
          sub_10004D2C8(v48);
        }
      }
      a4 = 0;
      long long v49 = *(std::__shared_weak_count **)(v10 - 8);
      *(void *)(v10 - 16) = v16;
      *(void *)(v10 - 8) = v35;
      if (v49)
      {
        sub_10004D2C8(v49);
        a4 = 0;
      }
    }
  }
  char v65 = (char *)(a1 + 2);
  char v67 = a1 == (void *)a2 || v65 == a2;
  if (a4)
  {
    if (!v67)
    {
      char v68 = 0;
      char v69 = (char *)a1;
      do
      {
        std::string v70 = v69;
        char v69 = v65;
        uint64_t v71 = *((void *)v70 + 2);
        unint64_t v72 = *(void *)v70;
        if (*(_DWORD *)(v71 + 148) < *(_DWORD *)(*(void *)v70 + 148))
        {
          uint64_t v73 = *((void *)v70 + 3);
          uint64_t v74 = v68;
          *(void *)char v69 = 0;
          *((void *)v69 + 1) = 0;
          while (1)
          {
            char v75 = (void *)((char *)a1 + v74);
            unint64_t v76 = *(void *)((char *)a1 + v74 + 8);
            *char v75 = 0;
            v75[1] = 0;
            char v77 = *(std::__shared_weak_count **)((char *)a1 + v74 + 24);
            v75[2] = v72;
            v75[3] = v76;
            if (v77) {
              sub_10004D2C8(v77);
            }
            if (!v74) {
              break;
            }
            unint64_t v72 = *(void *)((char *)a1 + v74 - 16);
            v74 -= 16;
            if (*(_DWORD *)(v71 + 148) >= *(_DWORD *)(v72 + 148))
            {
              uint64_t v78 = (void *)((char *)a1 + v74 + 16);
              goto LABEL_90;
            }
          }
          uint64_t v78 = a1;
LABEL_90:
          char v79 = (std::__shared_weak_count *)v78[1];
          *uint64_t v78 = v71;
          v78[1] = v73;
          if (v79) {
            sub_10004D2C8(v79);
          }
        }
        char v65 = v69 + 16;
        v68 += 16;
      }
      while (v69 + 16 != a2);
    }
  }
  else if (!v67)
  {
    xpc_object_t v118 = (std::__shared_weak_count **)(a1 + 3);
    do
    {
      xpc_object_t v119 = a1;
      a1 = v65;
      xpc_object_t v120 = v119[2];
      xpc_object_t v121 = *v119;
      if (*(_DWORD *)(v120 + 148) < *(_DWORD *)(*v119 + 148))
      {
        xpc_object_t v122 = (std::__shared_weak_count *)v119[3];
        char v123 = v118;
        *a1 = 0;
        a1[1] = 0;
        do
        {
          xpc_object_t v124 = *(v123 - 2);
          *(v123 - 3) = 0;
          *(v123 - 2) = 0;
          char v125 = *v123;
          *(v123 - 1) = (std::__shared_weak_count *)v121;
          *char v123 = v124;
          if (v125) {
            sub_10004D2C8(v125);
          }
          xpc_object_t v121 = (uint64_t)*(v123 - 5);
          v123 -= 2;
        }
        while (*(_DWORD *)(v120 + 148) < *(_DWORD *)(v121 + 148));
        xpc_object_t v126 = *v123;
        *(v123 - 1) = (std::__shared_weak_count *)v120;
        *char v123 = v122;
        if (v126) {
          sub_10004D2C8(v126);
        }
      }
      char v65 = (char *)(a1 + 2);
      v118 += 2;
    }
    while (a1 + 2 != (void *)a2);
  }
}

  v339 = a2 - 2;
  j = a1;
  while (1)
  {
    a1 = j;
    uint64_t v12 = (char *)a2 - (char *)j;
    uint64_t v13 = ((char *)a2 - (char *)j) >> 4;
    if (v6 || !v5)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          xpc_object_t v154 = a2 - 2;
          uint64_t result = *(a2 - 2);
          char v155 = *j;
          if (result != *j)
          {
            if ((*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v155 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_773;
            }
            v335 = vabdd_f64(result, v155);
            v336 = fabs(result);
            v337 = fabs(v155);
            if (v336 < v337) {
              v336 = v337;
            }
            v338 = v336 >= 1.0 ? v336 * 2.22044605e-16 : 2.22044605e-16;
            if (v335 > v338) {
              goto LABEL_773;
            }
          }
          uint64_t result = *(a2 - 1);
          char v155 = j[1];
          if (result == v155) {
            return result;
          }
          xpc_object_t v156 = (*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
              && (*(void *)&v155 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL;
          if (v156)
          {
            xpc_object_t v157 = fabs(result);
            xpc_object_t v158 = fabs(v155);
            if (v157 < v158) {
              xpc_object_t v157 = v158;
            }
            if (v157 >= 1.0) {
              xpc_object_t v159 = v157 * 2.22044605e-16;
            }
            else {
              xpc_object_t v159 = 2.22044605e-16;
            }
            if (result >= v155) {
              return result;
            }
            uint64_t result = vabdd_f64(result, v155);
            if (result <= v159) {
              return result;
            }
          }
          else
          {
LABEL_773:
            if (result >= v155) {
              return result;
            }
          }
          v344 = *(_OWORD *)j;
          *(_OWORD *)j = *(_OWORD *)v154;
          uint64_t result = *(double *)&v344;
          *(_OWORD *)xpc_object_t v154 = v344;
          return result;
        case 3uLL:
          return sub_101236220(j, j + 2, v339);
        case 4uLL:
          *(void *)&uint64_t result = sub_101236B98(j, j + 2, j + 4, (unint64_t *)v339).n128_u64[0];
          return result;
        case 5uLL:
          *(void *)&uint64_t result = sub_101236EDC(j, j + 2, j + 4, (uint64_t)(j + 6), (unint64_t *)v339).n128_u64[0];
          return result;
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 383) {
      break;
    }
    if (!a3)
    {
      if (j == a2) {
        return result;
      }
      v193 = (v13 - 2) >> 1;
      v194 = v193;
      while (1)
      {
        v195 = v194;
        if (v193 < v194) {
          goto LABEL_571;
        }
        v196 = (2 * v194) | 1;
        v197 = &j[2 * v196];
        if (2 * v195 + 2 >= (uint64_t)v13) {
          goto LABEL_492;
        }
        v198 = v197[2];
        v199 = *v197;
        if (*v197 != v198)
        {
          if ((*(void *)&v199 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)&v198 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            break;
          }
          v247 = vabdd_f64(v199, v198);
          v248 = fabs(v199);
          v249 = fabs(v198);
          if (v248 < v249) {
            v248 = v249;
          }
          v250 = v248 >= 1.0 ? v248 * 2.22044605e-16 : 2.22044605e-16;
          if (v247 > v250) {
            break;
          }
        }
        v200 = v197[1];
        v201 = v197[3];
        if (v200 == v201) {
          goto LABEL_492;
        }
        if ((*(void *)&v200 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (*(void *)&v201 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v251 = fabs(v200);
          v252 = fabs(v201);
          if (v251 < v252) {
            v251 = v252;
          }
          if (v251 >= 1.0) {
            v253 = v251 * 2.22044605e-16;
          }
          else {
            v253 = 2.22044605e-16;
          }
          if (v200 >= v201 || vabdd_f64(v200, v201) <= v253) {
            goto LABEL_492;
          }
LABEL_491:
          v197 += 2;
          v196 = 2 * v195 + 2;
          goto LABEL_492;
        }
        if (v200 < v201) {
          goto LABEL_491;
        }
LABEL_492:
        v204 = &j[2 * v195];
        v205 = *v197;
        v206 = *v204;
        if (*v197 == *v204) {
          goto LABEL_493;
        }
        if ((*(void *)&v205 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
          || (*(void *)&v206 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_504;
        }
        v240 = vabdd_f64(v205, v206);
        v241 = fabs(v205);
        v242 = fabs(v206);
        if (v241 < v242) {
          v241 = v242;
        }
        v243 = v241 >= 1.0 ? v241 * 2.22044605e-16 : 2.22044605e-16;
        if (v240 <= v243)
        {
LABEL_493:
          v207 = v197[1];
          v208 = v204[1];
          if (v207 != v208)
          {
            if ((*(void *)&v207 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
              && (*(void *)&v208 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              v244 = fabs(v207);
              v245 = fabs(v208);
              if (v244 < v245) {
                v244 = v245;
              }
              if (v244 >= 1.0) {
                v246 = v244 * 2.22044605e-16;
              }
              else {
                v246 = 2.22044605e-16;
              }
              if (v207 < v208 && vabdd_f64(v207, v208) > v246) {
                goto LABEL_571;
              }
            }
            else if (v207 < v208)
            {
              goto LABEL_571;
            }
          }
        }
        else
        {
LABEL_504:
          if (v205 < v206) {
            goto LABEL_571;
          }
          v208 = v204[1];
        }
        *(_OWORD *)v204 = *(_OWORD *)v197;
        if (v193 < v196) {
          goto LABEL_570;
        }
        v211 = fabs(v206);
        v212 = fabs(v208);
        while (1)
        {
          v213 = v197;
          v214 = 2 * v196;
          v196 = (2 * v196) | 1;
          v197 = &j[2 * v196];
          v215 = v214 + 2;
          if (v215 >= (uint64_t)v13) {
            goto LABEL_523;
          }
          v216 = v197[2];
          v217 = *v197;
          if (*v197 != v216)
          {
            if ((*(void *)&v217 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v216 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_521;
            }
            v233 = vabdd_f64(v217, v216);
            v234 = fabs(v217);
            v235 = fabs(v216);
            if (v234 < v235) {
              v234 = v235;
            }
            v236 = v234 >= 1.0 ? v234 * 2.22044605e-16 : 2.22044605e-16;
            if (v233 > v236)
            {
LABEL_521:
              if (v217 >= v216) {
                goto LABEL_523;
              }
              goto LABEL_522;
            }
          }
          v218 = v197[1];
          v219 = v197[3];
          if (v218 == v219) {
            goto LABEL_523;
          }
          if ((*(void *)&v218 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
            && (*(void *)&v219 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            v237 = fabs(v218);
            v238 = fabs(v219);
            if (v237 < v238) {
              v237 = v238;
            }
            if (v237 >= 1.0) {
              v239 = v237 * 2.22044605e-16;
            }
            else {
              v239 = 2.22044605e-16;
            }
            if (v218 >= v219 || vabdd_f64(v218, v219) <= v239) {
              goto LABEL_523;
            }
LABEL_522:
            v197 += 2;
            v196 = v215;
            goto LABEL_523;
          }
          if (v218 < v219) {
            goto LABEL_522;
          }
LABEL_523:
          v222 = *v197;
          if (*v197 != v206)
          {
            if ((*(void *)&v222 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v206 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_541;
            }
            v226 = vabdd_f64(v222, v206);
            v227 = fabs(v222);
            if (v227 < v211) {
              v227 = v211;
            }
            v228 = v227 >= 1.0 ? v227 * 2.22044605e-16 : 2.22044605e-16;
            if (v226 > v228)
            {
LABEL_541:
              if (v222 < v206) {
                break;
              }
              goto LABEL_552;
            }
          }
          v223 = v197[1];
          if (v223 != v208)
          {
            if ((*(void *)&v223 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v208 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              if (v223 < v208) {
                break;
              }
              goto LABEL_552;
            }
            v229 = vabdd_f64(v223, v208);
            v230 = fabs(v223);
            if (v230 < v212) {
              v230 = v212;
            }
            v231 = v230 >= 1.0 ? v230 * 2.22044605e-16 : 2.22044605e-16;
            if (v229 > v231 && v223 < v208) {
              break;
            }
          }
LABEL_552:
          *(_OWORD *)v213 = *(_OWORD *)v197;
          if (v193 < v196) {
            goto LABEL_570;
          }
        }
        v197 = v213;
LABEL_570:
        *v197 = v206;
        v197[1] = v208;
LABEL_571:
        v194 = v195 - 1;
        if (!v195)
        {
          v254 = (unint64_t)v12 >> 4;
          uint64_t result = 1.0;
          while (1)
          {
            v255 = 0;
            v343 = *(_OWORD *)j;
            v256 = v254 - 2;
            if (v254 < 2) {
              v256 = v254 - 1;
            }
            v257 = v256 >> 1;
            v258 = j;
            do
            {
              v259 = v258;
              v258 += 2 * v255 + 2;
              v260 = 2 * v255;
              v255 = (2 * v255) | 1;
              v261 = v260 + 2;
              if (v261 >= v254) {
                goto LABEL_621;
              }
              v262 = v258[2];
              v263 = *v258;
              if (*v258 != v262)
              {
                if ((*(void *)&v263 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                  || (*(void *)&v262 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  goto LABEL_619;
                }
                v268 = vabdd_f64(v263, v262);
                v269 = fabs(v263);
                v270 = fabs(v262);
                if (v269 < v270) {
                  v269 = v270;
                }
                v271 = v269 >= 1.0 ? v269 * 2.22044605e-16 : 2.22044605e-16;
                if (v268 > v271)
                {
LABEL_619:
                  if (v263 >= v262) {
                    goto LABEL_621;
                  }
LABEL_620:
                  v258 += 2;
                  v255 = v261;
                  goto LABEL_621;
                }
              }
              v264 = v258[1];
              v265 = v258[3];
              if (v264 == v265) {
                goto LABEL_621;
              }
              if ((*(void *)&v264 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                && (*(void *)&v265 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                v272 = fabs(v264);
                v273 = fabs(v265);
                if (v272 < v273) {
                  v272 = v273;
                }
                if (v272 >= 1.0) {
                  v274 = v272 * 2.22044605e-16;
                }
                else {
                  v274 = 2.22044605e-16;
                }
                if (v264 < v265 && vabdd_f64(v264, v265) > v274) {
                  goto LABEL_620;
                }
              }
              else if (v264 < v265)
              {
                goto LABEL_620;
              }
LABEL_621:
              *(_OWORD *)v259 = *(_OWORD *)v258;
            }
            while (v255 <= v257);
            a2 -= 2;
            if (v258 == a2)
            {
              *(_OWORD *)v258 = v343;
              goto LABEL_649;
            }
            *(_OWORD *)v258 = *(_OWORD *)a2;
            *(_OWORD *)a2 = v343;
            v275 = (char *)v258 - (char *)j + 16;
            if (v275 < 17) {
              goto LABEL_649;
            }
            v276 = ((unint64_t)v275 >> 4) - 2;
            v277 = v276 >> 1;
            v278 = &j[2 * (v276 >> 1)];
            v279 = *v278;
            v280 = *v258;
            if (*v278 == *v258) {
              goto LABEL_641;
            }
            if ((*(void *)&v279 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v280 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              goto LABEL_656;
            }
            v300 = vabdd_f64(v279, v280);
            v301 = fabs(v279);
            v302 = fabs(v280);
            if (v301 < v302) {
              v301 = v302;
            }
            v303 = v301 >= 1.0 ? v301 * 2.22044605e-16 : 2.22044605e-16;
            if (v300 <= v303)
            {
LABEL_641:
              v281 = v278[1];
              v282 = v258[1];
              if (v281 == v282) {
                goto LABEL_649;
              }
              if ((*(void *)&v281 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                && (*(void *)&v282 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                v304 = fabs(v281);
                v305 = fabs(v282);
                if (v304 < v305) {
                  v304 = v305;
                }
                if (v304 >= 1.0) {
                  v306 = v304 * 2.22044605e-16;
                }
                else {
                  v306 = 2.22044605e-16;
                }
                if (v281 >= v282 || vabdd_f64(v281, v282) <= v306) {
                  goto LABEL_649;
                }
              }
              else if (v281 >= v282)
              {
                goto LABEL_649;
              }
            }
            else
            {
LABEL_656:
              if (v279 >= v280) {
                goto LABEL_649;
              }
              v282 = v258[1];
            }
            *(_OWORD *)v258 = *(_OWORD *)v278;
            if (v276 < 2) {
              goto LABEL_700;
            }
            v285 = fabs(v280);
            v286 = fabs(v282);
            while (2)
            {
              v287 = v278;
              v288 = v277 - 1;
              v277 = (v277 - 1) >> 1;
              v278 = &j[2 * v277];
              v289 = *v278;
              if (*v278 != v280)
              {
                if ((*(void *)&v289 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                  || (*(void *)&v280 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  goto LABEL_678;
                }
                v293 = vabdd_f64(v289, v280);
                v294 = fabs(v289);
                if (v294 < v285) {
                  v294 = v285;
                }
                v295 = v294 >= 1.0 ? v294 * 2.22044605e-16 : 2.22044605e-16;
                if (v293 > v295)
                {
LABEL_678:
                  if (v289 >= v280) {
                    break;
                  }
                  goto LABEL_690;
                }
              }
              v290 = v278[1];
              if (v290 == v282) {
                break;
              }
              if ((*(void *)&v290 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                || (*(void *)&v282 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                if (v290 >= v282) {
                  break;
                }
                goto LABEL_690;
              }
              v296 = vabdd_f64(v290, v282);
              v297 = fabs(v290);
              if (v297 < v286) {
                v297 = v286;
              }
              if (v297 >= 1.0) {
                v298 = v297 * 2.22044605e-16;
              }
              else {
                v298 = 2.22044605e-16;
              }
              if (v296 > v298 && v290 < v282)
              {
LABEL_690:
                *(_OWORD *)v287 = *(_OWORD *)v278;
                if (v288 <= 1) {
                  goto LABEL_700;
                }
                continue;
              }
              break;
            }
            v278 = v287;
LABEL_700:
            *v278 = v280;
            v278[1] = v282;
LABEL_649:
            xpc_object_t v156 = v254-- <= 2;
            if (v156) {
              return result;
            }
          }
        }
      }
      if (v199 >= v198) {
        goto LABEL_492;
      }
      goto LABEL_491;
    }
    unint64_t v14 = v13 >> 1;
    unint64_t v15 = &j[2 * (v13 >> 1)];
    if ((unint64_t)v12 >= 0x801)
    {
      sub_101236220(a1, &a1[2 * (v13 >> 1)], v339);
      sub_101236220(a1 + 2, v15 - 2, a2 - 4);
      sub_101236220(a1 + 4, &a1[2 * v14 + 2], a2 - 6);
      sub_101236220(v15 - 2, v15, &a1[2 * v14 + 2]);
      v340 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)v15;
      *(_OWORD *)unint64_t v15 = v340;
    }
    else
    {
      sub_101236220(&a1[2 * (v13 >> 1)], a1, v339);
    }
    --a3;
    uint64_t result = *a1;
    uint64_t v16 = fabs(*a1);
    if (a4) {
      goto LABEL_33;
    }
    uint64_t v17 = *(a1 - 2);
    if (v17 == result) {
      goto LABEL_11;
    }
    if ((*(void *)&v17 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_32;
    }
    uint64_t v23 = vabdd_f64(v17, result);
    char v24 = fabs(v17);
    if (v24 < v16) {
      char v24 = v16;
    }
    BOOL v25 = v24 >= 1.0 ? v24 * 2.22044605e-16 : 2.22044605e-16;
    if (v23 <= v25)
    {
LABEL_11:
      uint64_t v18 = *(a1 - 1);
      uint64_t v19 = a1[1];
      if (v18 == v19) {
        goto LABEL_206;
      }
      if ((*(void *)&v18 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        uint64_t v20 = fabs(v18);
        int v21 = fabs(v19);
        if (v20 < v21) {
          uint64_t v20 = v21;
        }
        if (v20 >= 1.0) {
          int v22 = v20 * 2.22044605e-16;
        }
        else {
          int v22 = 2.22044605e-16;
        }
        if (v18 < v19 && vabdd_f64(v18, v19) > v22) {
          goto LABEL_33;
        }
        goto LABEL_206;
      }
      if (v18 >= v19) {
        goto LABEL_206;
      }
LABEL_33:
      int v26 = 0;
      int v27 = a1[1];
      uint64_t v28 = fabs(v27);
      while (1)
      {
        uint64_t v29 = a1[v26 + 2];
        if (v29 == result) {
          break;
        }
        if ((*(void *)&v29 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          int v33 = vabdd_f64(v29, result);
          long long v34 = fabs(v29);
          if (v34 < v16) {
            long long v34 = v16;
          }
          uint64_t v35 = v34 >= 1.0 ? v34 * 2.22044605e-16 : 2.22044605e-16;
          if (v33 <= v35) {
            break;
          }
        }
        if (v29 >= result) {
          goto LABEL_65;
        }
LABEL_64:
        v26 += 2;
      }
      uint64_t v30 = a1[v26 + 3];
      if (v30 == v27) {
        goto LABEL_65;
      }
      if ((*(void *)&v30 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || ((void)a1[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        if (v30 >= v27) {
          goto LABEL_65;
        }
        goto LABEL_64;
      }
      uint64_t v36 = vabdd_f64(v30, v27);
      long long v37 = fabs(v30);
      if (v37 < v28) {
        long long v37 = v28;
      }
      if (v37 >= 1.0) {
        long long v38 = v37 * 2.22044605e-16;
      }
      else {
        long long v38 = 2.22044605e-16;
      }
      if (v36 > v38 && v30 < v27) {
        goto LABEL_64;
      }
LABEL_65:
      long long v40 = (unint64_t)&a1[v26 + 2];
      uint64_t i = a2 - 2;
      if (v26 * 8)
      {
        while (1)
        {
          uint64_t v42 = *i;
          if (*i == result) {
            goto LABEL_67;
          }
          if ((*(void *)&v42 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_84;
          }
          uint64_t v46 = vabdd_f64(v42, result);
          int v47 = fabs(v42);
          if (v47 < v16) {
            int v47 = v16;
          }
          int v48 = v47 >= 1.0 ? v47 * 2.22044605e-16 : 2.22044605e-16;
          if (v46 <= v48)
          {
LABEL_67:
            int v43 = i[1];
            if (v43 != v27)
            {
              if ((*(void *)&v43 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                || ((void)a1[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                if (v43 < v27) {
                  goto LABEL_135;
                }
              }
              else
              {
                long long v49 = vabdd_f64(v43, v27);
                uint64_t v50 = fabs(v43);
                if (v50 < v28) {
                  uint64_t v50 = v28;
                }
                if (v50 >= 1.0) {
                  uint64_t v51 = v50 * 2.22044605e-16;
                }
                else {
                  uint64_t v51 = 2.22044605e-16;
                }
                if (v49 > v51 && v43 < v27) {
                  goto LABEL_135;
                }
              }
            }
          }
          else
          {
LABEL_84:
            if (v42 < result) {
              goto LABEL_135;
            }
          }
          i -= 2;
        }
      }
      uint64_t i = a2;
      if (v40 < (unint64_t)a2)
      {
        for (uint64_t i = a2 - 2; ; i -= 2)
        {
          long long v53 = *i;
          if (*i == result) {
            goto LABEL_99;
          }
          if ((*(void *)&v53 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_112;
          }
          int v56 = vabdd_f64(v53, result);
          int v57 = fabs(v53);
          if (v57 < v16) {
            int v57 = v16;
          }
          int v58 = v57 >= 1.0 ? v57 * 2.22044605e-16 : 2.22044605e-16;
          if (v56 <= v58)
          {
LABEL_99:
            long long v54 = i[1];
            if (v54 == v27)
            {
              if (v40 >= (unint64_t)i) {
                break;
              }
            }
            else if ((*(void *)&v54 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL {
                   || ((void)a1[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            }
            {
              if (v40 >= (unint64_t)i || v54 < v27) {
                break;
              }
            }
            else
            {
              uint64_t v61 = vabdd_f64(v54, v27);
              uint64_t v62 = fabs(v54);
              if (v62 < v28) {
                uint64_t v62 = v28;
              }
              if (v62 >= 1.0) {
                char v63 = v62 * 2.22044605e-16;
              }
              else {
                char v63 = 2.22044605e-16;
              }
              uint64_t v64 = v61 <= v63;
              if (v54 >= v27) {
                uint64_t v64 = 1;
              }
              if (v40 >= (unint64_t)i || !v64) {
                break;
              }
            }
          }
          else
          {
LABEL_112:
            if (v53 < result || v40 >= (unint64_t)i) {
              break;
            }
          }
        }
      }
LABEL_135:
      if (v40 >= (unint64_t)i)
      {
        j = (double *)v40;
      }
      else
      {
        char v65 = i;
        j = (double *)v40;
        do
        {
          v341 = *(_OWORD *)j;
          *(_OWORD *)j = *(_OWORD *)v65;
          *(_OWORD *)char v65 = v341;
          while (1)
          {
            while (1)
            {
              unint64_t v66 = j[2];
              j += 2;
              char v67 = v66;
              if (v66 == result) {
                break;
              }
              if ((*(void *)&v67 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                && (*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                uint64_t v71 = vabdd_f64(v67, result);
                unint64_t v72 = fabs(v67);
                if (v72 < v16) {
                  unint64_t v72 = v16;
                }
                uint64_t v73 = v72 >= 1.0 ? v72 * 2.22044605e-16 : 2.22044605e-16;
                if (v71 <= v73) {
                  break;
                }
              }
              if (v67 >= result) {
                goto LABEL_189;
              }
            }
            char v68 = j[1];
            if (v68 == v27) {
              break;
            }
            if ((*(void *)&v68 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              if (v68 >= v27) {
                goto LABEL_189;
              }
            }
            else
            {
              uint64_t v74 = vabdd_f64(v68, v27);
              char v75 = fabs(v68);
              if (v75 < v28) {
                char v75 = v28;
              }
              if (v75 >= 1.0) {
                unint64_t v76 = v75 * 2.22044605e-16;
              }
              else {
                unint64_t v76 = 2.22044605e-16;
              }
              if (v74 <= v76 || v68 >= v27) {
                goto LABEL_189;
              }
            }
          }
          do
          {
            while (1)
            {
              do
              {
LABEL_189:
                while (1)
                {
                  uint64_t v86 = *(v65 - 2);
                  v65 -= 2;
                  char v87 = v86;
                  if (v86 == result) {
                    break;
                  }
                  if ((*(void *)&v87 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                    && (*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    char v79 = vabdd_f64(v87, result);
                    int64_t v80 = fabs(v87);
                    if (v80 < v16) {
                      int64_t v80 = v16;
                    }
                    char v81 = v80 >= 1.0 ? v80 * 2.22044605e-16 : 2.22044605e-16;
                    if (v79 <= v81) {
                      break;
                    }
                  }
                  if (v87 < result) {
                    goto LABEL_196;
                  }
                }
                uint64_t v88 = v65[1];
              }
              while (v88 == v27);
              if ((*(void *)&v88 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                && (*(void *)&v27 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                break;
              }
              if (v88 < v27) {
                goto LABEL_196;
              }
            }
            BOOL v82 = vabdd_f64(v88, v27);
            int v83 = fabs(v88);
            if (v83 < v28) {
              int v83 = v28;
            }
            if (v83 >= 1.0) {
              BOOL v84 = v83 * 2.22044605e-16;
            }
            else {
              BOOL v84 = 2.22044605e-16;
            }
          }
          while (v82 <= v84 || v88 >= v27);
LABEL_196:
          ;
        }
        while (j < v65);
      }
      if (j - 2 != a1) {
        *(_OWORD *)a1 = *((_OWORD *)j - 1);
      }
      *(j - 2) = result;
      *(j - 1) = v27;
      if (v40 < (unint64_t)i)
      {
LABEL_204:
        sub_1012347F4(a1, j - 2, a3, a4 & 1);
        a4 = 0;
      }
      else
      {
        unint64_t v90 = sub_101236738(a1, j - 2);
        if (sub_101236738(j, a2))
        {
          a2 = j - 2;
          if (v90) {
            return result;
          }
          goto LABEL_1;
        }
        if (!v90) {
          goto LABEL_204;
        }
      }
    }
    else
    {
LABEL_32:
      if (v17 < result) {
        goto LABEL_33;
      }
      uint64_t v19 = a1[1];
LABEL_206:
      char v91 = *v339;
      if (result == *v339) {
        goto LABEL_207;
      }
      if ((*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v91 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_229;
      }
      char v99 = vabdd_f64(result, v91);
      char v100 = fabs(v91);
      if (v16 >= v100) {
        char v100 = v16;
      }
      char v101 = v100 >= 1.0 ? v100 * 2.22044605e-16 : 2.22044605e-16;
      if (v99 <= v101)
      {
LABEL_207:
        v92 = *(a2 - 1);
        if (v19 != v92)
        {
          char v93 = (*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
          if ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
            || (*(void *)&v92 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            if (v19 < v92) {
              goto LABEL_232;
            }
          }
          else
          {
            uint64_t v94 = vabdd_f64(v19, v92);
            long long v95 = fabs(v19);
            long long v96 = fabs(v92);
            if (v95 < v96) {
              long long v95 = v96;
            }
            if (v95 >= 1.0) {
              uint64_t v97 = v95 * 2.22044605e-16;
            }
            else {
              uint64_t v97 = 2.22044605e-16;
            }
            if (v94 > v97 && v19 < v92)
            {
              char v93 = 1;
LABEL_232:
              uint64_t v102 = fabs(v19);
              for (j = a1 + 2; ; j += 2)
              {
                char v103 = *j;
                if (result == *j) {
                  goto LABEL_234;
                }
                if ((*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
                  || (*(void *)&v103 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
                {
                  goto LABEL_256;
                }
                xpc_object_t v109 = vabdd_f64(result, v103);
                xpc_object_t v110 = fabs(v103);
                if (v16 >= v110) {
                  xpc_object_t v110 = v16;
                }
                char v111 = v110 >= 1.0 ? v110 * 2.22044605e-16 : 2.22044605e-16;
                if (v109 <= v111)
                {
LABEL_234:
                  xpc_object_t v104 = j[1];
                  if (v19 != v104)
                  {
                    if (v93 && (*(void *)&v104 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                    {
                      char v105 = vabdd_f64(v19, v104);
                      xpc_object_t v106 = fabs(v104);
                      if (v102 >= v106) {
                        xpc_object_t v106 = v102;
                      }
                      if (v106 >= 1.0) {
                        xpc_object_t v107 = v106 * 2.22044605e-16;
                      }
                      else {
                        xpc_object_t v107 = 2.22044605e-16;
                      }
                      if (v105 > v107 && v19 < v104) {
                        goto LABEL_289;
                      }
                    }
                    else if (v19 < v104)
                    {
                      goto LABEL_289;
                    }
                  }
                }
                else
                {
LABEL_256:
                  if (result < v103) {
                    goto LABEL_289;
                  }
                }
              }
            }
          }
        }
      }
      else
      {
LABEL_229:
        if (result < v91)
        {
          char v93 = (*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
          goto LABEL_232;
        }
      }
      j = a1 + 2;
      if (a1 + 2 < a2)
      {
        xpc_object_t v112 = fabs(v19);
        do
        {
          char v113 = *j;
          if (result == *j) {
            goto LABEL_263;
          }
          if ((*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
            || (*(void *)&v113 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_285;
          }
          xpc_object_t v119 = vabdd_f64(result, v113);
          xpc_object_t v120 = fabs(v113);
          if (v16 >= v120) {
            xpc_object_t v120 = v16;
          }
          xpc_object_t v121 = v120 >= 1.0 ? v120 * 2.22044605e-16 : 2.22044605e-16;
          if (v119 <= v121)
          {
LABEL_263:
            xpc_object_t v114 = j[1];
            if (v19 != v114)
            {
              if ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
                || (*(void *)&v114 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
              {
                if (v19 < v114) {
                  break;
                }
              }
              else
              {
                char v115 = vabdd_f64(v19, v114);
                xpc_object_t v116 = fabs(v114);
                if (v112 >= v116) {
                  xpc_object_t v116 = v112;
                }
                if (v116 >= 1.0) {
                  char v117 = v116 * 2.22044605e-16;
                }
                else {
                  char v117 = 2.22044605e-16;
                }
                if (v115 > v117 && v19 < v114) {
                  break;
                }
              }
            }
          }
          else
          {
LABEL_285:
            if (result < v113) {
              break;
            }
          }
          j += 2;
        }
        while (j < a2);
      }
LABEL_289:
      k = a2;
      if (j < a2)
      {
        char v123 = fabs(v19);
        for (k = a2 - 2; ; k -= 2)
        {
          if (result == v91) {
            goto LABEL_292;
          }
          if ((*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
            || (*(void *)&v91 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
          {
            goto LABEL_315;
          }
          char v129 = vabdd_f64(result, v91);
          long long v130 = fabs(v91);
          if (v16 >= v130) {
            long long v130 = v16;
          }
          xpc_object_t v131 = v130 >= 1.0 ? v130 * 2.22044605e-16 : 2.22044605e-16;
          if (v129 <= v131)
          {
LABEL_292:
            xpc_object_t v124 = k[1];
            if (v19 == v124) {
              break;
            }
            if ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
              || (*(void *)&v124 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              if (v19 >= v124) {
                break;
              }
            }
            else
            {
              char v125 = vabdd_f64(v19, v124);
              xpc_object_t v126 = fabs(v124);
              if (v123 >= v126) {
                xpc_object_t v126 = v123;
              }
              if (v126 >= 1.0) {
                char v127 = v126 * 2.22044605e-16;
              }
              else {
                char v127 = 2.22044605e-16;
              }
              if (v125 <= v127 || v19 >= v124) {
                break;
              }
            }
          }
          else
          {
LABEL_315:
            if (result >= v91) {
              break;
            }
          }
          uint64_t v132 = *(k - 2);
          char v91 = v132;
        }
      }
      if (j < k)
      {
        long long v133 = fabs(v19);
        do
        {
          v342 = *(_OWORD *)j;
          *(_OWORD *)j = *(_OWORD *)k;
          *(_OWORD *)k = v342;
          do
          {
            while (1)
            {
              do
              {
                while (1)
                {
                  uint64_t v134 = j[2];
                  j += 2;
                  uint64_t v135 = v134;
                  if (result == v134) {
                    break;
                  }
                  if ((*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
                    && (*(void *)&v135 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
                  {
                    uint64_t v141 = vabdd_f64(result, v135);
                    long long v142 = fabs(v135);
                    if (v16 >= v142) {
                      long long v142 = v16;
                    }
                    uint64_t v143 = v142 >= 1.0 ? v142 * 2.22044605e-16 : 2.22044605e-16;
                    if (v141 <= v143) {
                      break;
                    }
                  }
                  if (result < v135) {
                    goto LABEL_358;
                  }
                }
                long long v136 = j[1];
              }
              while (v19 == v136);
              if ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
                && (*(void *)&v136 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                break;
              }
              if (v19 < v136) {
                goto LABEL_358;
              }
            }
            uint64_t v137 = vabdd_f64(v19, v136);
            long long v138 = fabs(v136);
            if (v133 >= v138) {
              long long v138 = v133;
            }
            if (v138 >= 1.0) {
              uint64_t v139 = v138 * 2.22044605e-16;
            }
            else {
              uint64_t v139 = 2.22044605e-16;
            }
          }
          while (v137 <= v139 || v19 >= v136);
          while (1)
          {
LABEL_358:
            while (1)
            {
              xpc_object_t v147 = *(k - 2);
              k -= 2;
              xpc_object_t v148 = v147;
              if (result == v147) {
                break;
              }
              if ((*(void *)&result & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
                && (*(void *)&v148 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              {
                xpc_object_t v144 = vabdd_f64(result, v148);
                xpc_object_t v145 = fabs(v148);
                if (v16 >= v145) {
                  xpc_object_t v145 = v16;
                }
                xpc_object_t v146 = v145 >= 1.0 ? v145 * 2.22044605e-16 : 2.22044605e-16;
                if (v144 <= v146) {
                  break;
                }
              }
              if (result >= v148) {
                goto LABEL_371;
              }
            }
            char v149 = k[1];
            if (v19 == v149) {
              break;
            }
            if ((*(void *)&v19 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
              || (*(void *)&v149 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
            {
              if (v19 >= v149) {
                break;
              }
            }
            else
            {
              xpc_object_t v150 = vabdd_f64(v19, v149);
              char v151 = fabs(v149);
              if (v133 >= v151) {
                char v151 = v133;
              }
              if (v151 >= 1.0) {
                xpc_object_t v152 = v151 * 2.22044605e-16;
              }
              else {
                xpc_object_t v152 = 2.22044605e-16;
              }
              if (v150 <= v152 || v19 >= v149) {
                break;
              }
            }
          }
LABEL_371:
          ;
        }
        while (j < k);
      }
      char v5 = j - 2 >= a1;
      unint64_t v6 = j - 2 == a1;
      if (j - 2 != a1) {
        *(_OWORD *)a1 = *((_OWORD *)j - 1);
      }
      a4 = 0;
      *(j - 2) = result;
      *(j - 1) = v19;
    }
  }
  xpc_object_t v160 = j + 2;
  xpc_object_t v162 = j == a2 || v160 == a2;
  if ((a4 & 1) == 0)
  {
    if (v162) {
      return result;
    }
    uint64_t result = 1.0;
    while (1)
    {
      v307 = a1;
      a1 = v160;
      v308 = v307[2];
      v309 = *v307;
      if (v308 == *v307) {
        goto LABEL_712;
      }
      if ((*(void *)&v308 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
        || (*(void *)&v309 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        goto LABEL_723;
      }
      v327 = vabdd_f64(v308, v309);
      v328 = fabs(v308);
      v329 = fabs(v309);
      if (v328 < v329) {
        v328 = v329;
      }
      v330 = v328 >= 1.0 ? v328 * 2.22044605e-16 : 2.22044605e-16;
      if (v327 <= v330)
      {
LABEL_712:
        v310 = v307[3];
        v311 = v307[1];
        if (v310 == v311) {
          goto LABEL_752;
        }
        if ((*(void *)&v310 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (*(void *)&v311 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
        {
          v331 = fabs(v310);
          v332 = fabs(v311);
          if (v331 < v332) {
            v331 = v332;
          }
          if (v331 >= 1.0) {
            v333 = v331 * 2.22044605e-16;
          }
          else {
            v333 = 2.22044605e-16;
          }
          if (v310 >= v311 || vabdd_f64(v310, v311) <= v333) {
            goto LABEL_752;
          }
        }
        else if (v310 >= v311)
        {
          goto LABEL_752;
        }
      }
      else
      {
LABEL_723:
        if (v308 >= v309) {
          goto LABEL_752;
        }
        v310 = v307[3];
      }
      v314 = fabs(v308);
      v315 = fabs(v310);
      do
      {
        while (1)
        {
          while (1)
          {
            v316 = v307;
            *((_OWORD *)v307 + 1) = *(_OWORD *)v307;
            v317 = *(v307 - 2);
            v307 -= 2;
            v318 = v317;
            if (v308 == v317) {
              break;
            }
            if ((*(void *)&v308 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
              && (*(void *)&v318 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
            {
              v324 = vabdd_f64(v308, v318);
              v325 = fabs(v318);
              if (v314 >= v325) {
                v325 = v314;
              }
              v326 = v325 >= 1.0 ? v325 * 2.22044605e-16 : 2.22044605e-16;
              if (v324 <= v326) {
                break;
              }
            }
            if (v308 >= v318) {
              goto LABEL_751;
            }
          }
          v319 = *(v316 - 1);
          if (v310 == v319) {
            goto LABEL_751;
          }
          if ((*(void *)&v310 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
            && (*(void *)&v319 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          {
            break;
          }
          if (v310 >= v319) {
            goto LABEL_751;
          }
        }
        v320 = vabdd_f64(v310, v319);
        v321 = fabs(v319);
        if (v315 >= v321) {
          v321 = v315;
        }
        if (v321 >= 1.0) {
          v322 = v321 * 2.22044605e-16;
        }
        else {
          v322 = 2.22044605e-16;
        }
      }
      while (v320 > v322 && v310 < v319);
LABEL_751:
      *v316 = v308;
      v316[1] = v310;
LABEL_752:
      xpc_object_t v160 = a1 + 2;
      if (a1 + 2 == a2) {
        return result;
      }
    }
  }
  if (v162) {
    return result;
  }
  char v163 = 0;
  uint64_t result = 1.0;
  v164 = j;
  while (2)
  {
    char v165 = v164;
    v164 = v160;
    uint64_t v166 = v165[2];
    char v167 = *v165;
    if (v166 == *v165) {
      goto LABEL_413;
    }
    if ((*(void *)&v166 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
      || (*(void *)&v167 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    {
      goto LABEL_424;
    }
    v186 = vabdd_f64(v166, v167);
    v187 = fabs(v166);
    v188 = fabs(v167);
    if (v187 < v188) {
      v187 = v188;
    }
    v189 = v187 >= 1.0 ? v187 * 2.22044605e-16 : 2.22044605e-16;
    if (v186 <= v189)
    {
LABEL_413:
      uint64_t v168 = v165[3];
      std::string v169 = v165[1];
      if (v168 == v169) {
        goto LABEL_472;
      }
      if ((*(void *)&v168 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
        && (*(void *)&v169 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
      {
        v190 = fabs(v168);
        v191 = fabs(v169);
        if (v190 < v191) {
          v190 = v191;
        }
        if (v190 >= 1.0) {
          v192 = v190 * 2.22044605e-16;
        }
        else {
          v192 = 2.22044605e-16;
        }
        if (v168 >= v169 || vabdd_f64(v168, v169) <= v192) {
          goto LABEL_472;
        }
      }
      else if (v168 >= v169)
      {
        goto LABEL_472;
      }
    }
    else
    {
LABEL_424:
      if (v166 >= v167) {
        goto LABEL_472;
      }
      uint64_t v168 = v165[3];
    }
    *(_OWORD *)xpc_object_t v160 = *(_OWORD *)v165;
    v172 = j;
    if (v165 == j) {
      goto LABEL_471;
    }
    uint64_t v173 = fabs(v166);
    xpc_object_t v174 = fabs(v168);
    xpc_object_t v175 = v163;
    while (2)
    {
      xpc_object_t v176 = (double *)((char *)j + v175);
      xpc_object_t v177 = *(double *)((char *)j + v175 - 16);
      if (v166 != v177)
      {
        if ((*(void *)&v166 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
          || (*(void *)&v177 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
        {
          goto LABEL_452;
        }
        v183 = vabdd_f64(v166, v177);
        v184 = fabs(v177);
        if (v173 >= v184) {
          v184 = v173;
        }
        v185 = v184 >= 1.0 ? v184 * 2.22044605e-16 : 2.22044605e-16;
        if (v183 > v185)
        {
LABEL_452:
          if (v166 >= v177) {
            goto LABEL_462;
          }
          goto LABEL_453;
        }
      }
      xpc_object_t v178 = *(v176 - 1);
      if (v168 == v178) {
        goto LABEL_462;
      }
      if ((*(void *)&v168 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000
        || (*(void *)&v178 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
      {
        if (v168 >= v178)
        {
          v172 = (double *)((char *)j + v175);
          goto LABEL_471;
        }
LABEL_453:
        v165 -= 2;
        *(_OWORD *)xpc_object_t v176 = *(_OWORD *)((char *)j + v175 - 16);
        v175 -= 16;
        if (!v175)
        {
          v172 = j;
          goto LABEL_471;
        }
        continue;
      }
      break;
    }
    xpc_object_t v179 = vabdd_f64(v168, v178);
    xpc_object_t v180 = fabs(v178);
    if (v174 >= v180) {
      xpc_object_t v180 = v174;
    }
    if (v180 >= 1.0) {
      v181 = v180 * 2.22044605e-16;
    }
    else {
      v181 = 2.22044605e-16;
    }
    if (v179 > v181 && v168 < v178) {
      goto LABEL_453;
    }
LABEL_462:
    v172 = v165;
LABEL_471:
    char *v172 = v166;
    v172[1] = v168;
LABEL_472:
    xpc_object_t v160 = v164 + 2;
    v163 += 16;
    if (v164 + 2 != a2) {
      continue;
    }
    return result;
  }
}

void sub_1008FECC8(_Unwind_Exception *a1)
{
}

void sub_1008FED34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_100901874(a1, a2, a3, a4);
  sub_10002E664((uint64_t)v102, a5);
  sub_10002E664((uint64_t)v90, a4);
  int v10 = v102[0];
  int v11 = v90[0];
  if (v101 < 0) {
    operator delete(__p);
  }
  if (v99 < 0) {
    operator delete(v98);
  }
  if (v97 < 0) {
    operator delete(v96);
  }
  if (v95 < 0) {
    operator delete(v94);
  }
  v78[0] = (void **)&v93;
  sub_10002E39C(v78);
  if (v91)
  {
    v92 = v91;
    operator delete(v91);
  }
  if (v112 < 0) {
    operator delete(v111);
  }
  if (v110 < 0) {
    operator delete(v109);
  }
  if (v108 < 0) {
    operator delete(v107);
  }
  if (v106 < 0) {
    operator delete(v105[4]);
  }
  v78[0] = v105;
  sub_10002E39C(v78);
  if (v103)
  {
    xpc_object_t v104 = v103;
    operator delete(v103);
  }
  if (v10 < v11)
  {
    sub_100901744(a4, a5);
    sub_10002E664((uint64_t)v78, a4);
    sub_10002E664((uint64_t)v66, a3);
    int v12 = (int)v78[0];
    int v13 = v66[0];
    if (v77 < 0) {
      operator delete(v76);
    }
    if (v75 < 0) {
      operator delete(v74);
    }
    if (v73 < 0) {
      operator delete(v72);
    }
    if (v71 < 0) {
      operator delete(v70);
    }
    v54[0] = (void **)&v69;
    sub_10002E39C(v54);
    if (v67)
    {
      char v68 = v67;
      operator delete(v67);
    }
    if (v89 < 0) {
      operator delete(v88);
    }
    if (v87 < 0) {
      operator delete(v86);
    }
    if (v85 < 0) {
      operator delete(v84);
    }
    if (v83 < 0) {
      operator delete(v82);
    }
    v54[0] = (void **)&v81;
    sub_10002E39C(v54);
    if (v79)
    {
      int64_t v80 = v79;
      operator delete(v79);
    }
    if (v12 < v13)
    {
      sub_100901744(a3, a4);
      sub_10002E664((uint64_t)v54, a3);
      sub_10002E664((uint64_t)v42, a2);
      int v14 = (int)v54[0];
      int v15 = v42[0];
      if (v53 < 0) {
        operator delete(v52);
      }
      if (v51 < 0) {
        operator delete(v50);
      }
      if (v49 < 0) {
        operator delete(v48);
      }
      if (v47 < 0) {
        operator delete(v46);
      }
      v30[0] = (void **)&v45;
      sub_10002E39C(v30);
      if (v43)
      {
        int v44 = v43;
        operator delete(v43);
      }
      if (v65 < 0) {
        operator delete(v64);
      }
      if (v63 < 0) {
        operator delete(v62);
      }
      if (v61 < 0) {
        operator delete(v60);
      }
      if (v59 < 0) {
        operator delete(v58);
      }
      v30[0] = (void **)&v57;
      sub_10002E39C(v30);
      if (v55)
      {
        int v56 = v55;
        operator delete(v55);
      }
      if (v14 < v15)
      {
        sub_100901744(a2, a3);
        sub_10002E664((uint64_t)v30, a2);
        sub_10002E664((uint64_t)v18, a1);
        int v16 = (int)v30[0];
        int v17 = v18[0];
        if (v29 < 0) {
          operator delete(v28);
        }
        if (v27 < 0) {
          operator delete(v26);
        }
        if (v25 < 0) {
          operator delete(v24);
        }
        if (v23 < 0) {
          operator delete(v22);
        }
        char v113 = (void **)&v21;
        sub_10002E39C(&v113);
        if (v19)
        {
          uint64_t v20 = v19;
          operator delete(v19);
        }
        if (v41 < 0) {
          operator delete(v40);
        }
        if (v39 < 0) {
          operator delete(v38);
        }
        if (v37 < 0) {
          operator delete(v36);
        }
        if (v35 < 0) {
          operator delete(v34);
        }
        char v113 = (void **)&v33;
        sub_10002E39C(&v113);
        if (v31)
        {
          int v32 = v31;
          operator delete(v31);
        }
        if (v16 < v17) {
          sub_100901744(a1, a2);
        }
      }
    }
  }
}

void sub_1008FF178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a63 < 0) {
    operator delete(a58);
  }
  if (a57 < 0) {
    operator delete(a52);
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  *(void *)(v63 - 72) = &a36;
  sub_10002E39C((void ***)(v63 - 72));
  if (a33) {
    operator delete(a33);
  }
  _Unwind_Resume(a1);
}

void sub_1008FF20C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = a2 - a1;
    uint64_t v7 = (a2 - a1) / 168;
    if (a2 - a1 >= 169)
    {
      unint64_t v8 = (unint64_t)(v7 - 2) >> 1;
      unint64_t v9 = v8 + 1;
      uint64_t v10 = a1 + 168 * v8;
      do
      {
        sub_100901BE4(a1, v7, v10);
        v10 -= 168;
        --v9;
      }
      while (v9);
    }
    uint64_t v48 = a2;
    if (a2 != a3)
    {
      uint64_t v11 = a2;
      do
      {
        sub_10002E664((uint64_t)v61, v11);
        sub_10002E664((uint64_t)v49, a1);
        int v12 = v61[0];
        int v13 = v49[0];
        if (v60 < 0) {
          operator delete(__p);
        }
        if (v58 < 0) {
          operator delete(v57);
        }
        if (v56 < 0) {
          operator delete(v55);
        }
        if (v54 < 0) {
          operator delete(v53);
        }
        v137[0] = (void **)&v52;
        sub_10002E39C(v137);
        if (v50)
        {
          char v51 = v50;
          operator delete(v50);
        }
        if (v72 < 0) {
          operator delete(v71);
        }
        if (v70 < 0) {
          operator delete(v69);
        }
        if (v68 < 0) {
          operator delete(v67);
        }
        if (v66 < 0) {
          operator delete(v65);
        }
        v137[0] = (void **)&v64;
        sub_10002E39C(v137);
        if (v62)
        {
          uint64_t v63 = v62;
          operator delete(v62);
        }
        if (v12 < v13)
        {
          sub_100901744(v11, a1);
          sub_100901BE4(a1, v7, a1);
        }
        v11 += 168;
      }
      while (v11 != a3);
    }
    if (v6 >= 169)
    {
      int64_t v14 = v6 / 0xA8uLL;
      char v47 = (long long *)(a1 + 72);
      uint64_t v46 = (long long *)(a1 + 96);
      uint64_t v45 = (long long *)(a1 + 120);
      int v44 = (long long *)(a1 + 144);
      do
      {
        uint64_t v15 = 0;
        uint64_t v16 = a1;
        long long v17 = *(_OWORD *)(a1 + 16);
        long long v73 = *(_OWORD *)a1;
        *(_OWORD *)uint64_t v74 = v17;
        uint64_t v75 = *(void *)(a1 + 32);
        *(void *)(a1 + 24) = 0;
        *(void *)(a1 + 32) = 0;
        *(void *)(a1 + 16) = 0;
        long long v76 = *(_OWORD *)(a1 + 40);
        uint64_t v18 = *(void *)(a1 + 56);
        uint64_t v78 = 0;
        uint64_t v77 = v18;
        *(void *)(a1 + 48) = 0;
        *(void *)(a1 + 56) = 0;
        *(void *)(a1 + 40) = 0;
        LODWORD(v18) = *(_DWORD *)(a1 + 64);
        WORD2(v78) = *(_WORD *)(a1 + 68);
        LODWORD(v78) = v18;
        long long v19 = *v47;
        uint64_t v80 = *(void *)(a1 + 88);
        long long v79 = v19;
        *(void *)char v47 = 0;
        *(void *)(a1 + 80) = 0;
        *(void *)(a1 + 88) = 0;
        long long v20 = *v46;
        uint64_t v82 = *(void *)(a1 + 112);
        long long v81 = v20;
        *(void *)uint64_t v46 = 0;
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        long long v21 = *v45;
        uint64_t v84 = *(void *)(a1 + 136);
        long long v83 = v21;
        *(void *)uint64_t v45 = 0;
        *(void *)(a1 + 128) = 0;
        *(void *)(a1 + 136) = 0;
        long long v22 = *v44;
        uint64_t v86 = *(void *)(a1 + 160);
        long long v85 = v22;
        *(void *)int v44 = 0;
        *(void *)(a1 + 152) = 0;
        *(void *)(a1 + 160) = 0;
        do
        {
          uint64_t v23 = v16;
          v16 += 168 * v15 + 168;
          uint64_t v24 = 2 * v15;
          uint64_t v15 = (2 * v15) | 1;
          uint64_t v25 = v24 + 2;
          if (v24 + 2 < v14)
          {
            sub_10002E664((uint64_t)v137, v16);
            sub_10002E664((uint64_t)v125, v16 + 168);
            int v26 = (int)v137[0];
            int v27 = v125[0];
            if (v136 < 0) {
              operator delete(v135);
            }
            if (v134 < 0) {
              operator delete(v133);
            }
            if (v132 < 0) {
              operator delete(v131);
            }
            if (v130 < 0) {
              operator delete(v129);
            }
            *(void *)&long long v111 = v128;
            sub_10002E39C((void ***)&v111);
            if (v126)
            {
              char v127 = v126;
              operator delete(v126);
            }
            if (v148 < 0) {
              operator delete(v147);
            }
            if (v146 < 0) {
              operator delete(v145);
            }
            if (v144 < 0) {
              operator delete(v143);
            }
            if (v142 < 0) {
              operator delete(v141);
            }
            *(void *)&long long v111 = v140;
            sub_10002E39C((void ***)&v111);
            if (v138)
            {
              uint64_t v139 = v138;
              operator delete(v138);
            }
            if (v26 < v27)
            {
              v16 += 168;
              uint64_t v15 = v25;
            }
          }
          sub_10032FAFC(v23, v16);
        }
        while (v15 <= (uint64_t)((unint64_t)(v14 - 2) >> 1));
        uint64_t v28 = v48 - 168;
        BOOL v29 = v16 == v48 - 168;
        v48 -= 168;
        if (v29)
        {
          sub_10032FAFC(v16, (uint64_t)&v73);
        }
        else
        {
          sub_10032FAFC(v16, v28);
          sub_10032FAFC(v28, (uint64_t)&v73);
          uint64_t v30 = v16 - a1 + 168;
          if (v30 >= 169)
          {
            unint64_t v31 = (v30 / 0xA8uLL - 2) >> 1;
            uint64_t v32 = a1 + 168 * v31;
            sub_10002E664((uint64_t)v137, v32);
            sub_10002E664((uint64_t)v125, v16);
            int v33 = (int)v137[0];
            int v34 = v125[0];
            if (v136 < 0) {
              operator delete(v135);
            }
            if (v134 < 0) {
              operator delete(v133);
            }
            if (v132 < 0) {
              operator delete(v131);
            }
            if (v130 < 0) {
              operator delete(v129);
            }
            *(void *)&long long v111 = v128;
            sub_10002E39C((void ***)&v111);
            if (v126)
            {
              char v127 = v126;
              operator delete(v126);
            }
            if (v148 < 0) {
              operator delete(v147);
            }
            if (v146 < 0) {
              operator delete(v145);
            }
            if (v144 < 0) {
              operator delete(v143);
            }
            if (v142 < 0) {
              operator delete(v141);
            }
            *(void *)&long long v111 = v140;
            sub_10002E39C((void ***)&v111);
            if (v138)
            {
              uint64_t v139 = v138;
              operator delete(v138);
            }
            if (v33 < v34)
            {
              uint64_t v116 = 0;
              long long v111 = *(_OWORD *)v16;
              *(_OWORD *)char v112 = *(_OWORD *)(v16 + 16);
              uint64_t v113 = *(void *)(v16 + 32);
              *(void *)(v16 + 16) = 0;
              *(void *)(v16 + 24) = 0;
              *(void *)(v16 + 32) = 0;
              long long v114 = *(_OWORD *)(v16 + 40);
              uint64_t v115 = *(void *)(v16 + 56);
              *(void *)(v16 + 40) = 0;
              *(void *)(v16 + 48) = 0;
              *(void *)(v16 + 56) = 0;
              int v35 = *(_DWORD *)(v16 + 64);
              WORD2(v116) = *(_WORD *)(v16 + 68);
              LODWORD(v116) = v35;
              long long v36 = *(_OWORD *)(v16 + 72);
              uint64_t v118 = *(void *)(v16 + 88);
              long long v117 = v36;
              *(void *)(v16 + 80) = 0;
              *(void *)(v16 + 88) = 0;
              *(void *)(v16 + 72) = 0;
              long long v37 = *(_OWORD *)(v16 + 96);
              uint64_t v120 = *(void *)(v16 + 112);
              long long v119 = v37;
              *(void *)(v16 + 104) = 0;
              *(void *)(v16 + 112) = 0;
              *(void *)(v16 + 96) = 0;
              long long v38 = *(_OWORD *)(v16 + 120);
              uint64_t v122 = *(void *)(v16 + 136);
              long long v121 = v38;
              *(void *)(v16 + 120) = 0;
              *(void *)(v16 + 128) = 0;
              *(void *)(v16 + 136) = 0;
              long long v39 = *(_OWORD *)(v16 + 144);
              uint64_t v124 = *(void *)(v16 + 160);
              long long v123 = v39;
              *(void *)(v16 + 144) = 0;
              *(void *)(v16 + 152) = 0;
              *(void *)(v16 + 160) = 0;
              do
              {
                uint64_t v40 = v32;
                sub_10032FAFC(v16, v32);
                if (!v31) {
                  break;
                }
                unint64_t v31 = (v31 - 1) >> 1;
                uint64_t v32 = a1 + 168 * v31;
                sub_10002E664((uint64_t)v99, v32);
                sub_10002E664((uint64_t)v87, (uint64_t)&v111);
                int v41 = v99[0];
                int v42 = v87[0];
                if (v98 < 0) {
                  operator delete(v97);
                }
                if (v96 < 0) {
                  operator delete(v95);
                }
                if (v94 < 0) {
                  operator delete(v93);
                }
                if (v92 < 0) {
                  operator delete(v91);
                }
                v149[0] = (void **)&v90;
                sub_10002E39C(v149);
                if (v88)
                {
                  char v89 = v88;
                  operator delete(v88);
                }
                if (v110 < 0) {
                  operator delete(v109);
                }
                if (v108 < 0) {
                  operator delete(v107);
                }
                if (v106 < 0) {
                  operator delete(v105);
                }
                if (v104 < 0) {
                  operator delete(v103);
                }
                v149[0] = (void **)&v102;
                sub_10002E39C(v149);
                if (v100)
                {
                  char v101 = v100;
                  operator delete(v100);
                }
                uint64_t v16 = v40;
              }
              while (v41 < v42);
              sub_10032FAFC(v40, (uint64_t)&v111);
              if (SHIBYTE(v124) < 0) {
                operator delete((void *)v123);
              }
              if (SHIBYTE(v122) < 0) {
                operator delete((void *)v121);
              }
              if (SHIBYTE(v120) < 0) {
                operator delete((void *)v119);
              }
              if (SHIBYTE(v118) < 0) {
                operator delete((void *)v117);
              }
              v149[0] = (void **)&v114;
              sub_10002E39C(v149);
              if (v112[0])
              {
                v112[1] = v112[0];
                operator delete(v112[0]);
              }
            }
          }
        }
        if (SHIBYTE(v86) < 0) {
          operator delete((void *)v85);
        }
        if (SHIBYTE(v84) < 0) {
          operator delete((void *)v83);
        }
        if (SHIBYTE(v82) < 0) {
          operator delete((void *)v81);
        }
        if (SHIBYTE(v80) < 0) {
          operator delete((void *)v79);
        }
        v137[0] = (void **)&v76;
        sub_10002E39C(v137);
        if (v74[0])
        {
          v74[1] = v74[0];
          operator delete(v74[0]);
        }
      }
      while (v14-- > 2);
    }
  }
}

void sub_1008FFAC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,unint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,unint64_t a34)
{
  if (SLOBYTE(STACK[0x61F]) < 0) {
    operator delete((void *)STACK[0x608]);
  }
  if (SLOBYTE(STACK[0x607]) < 0) {
    operator delete((void *)STACK[0x5F0]);
  }
  if (SLOBYTE(STACK[0x5EF]) < 0) {
    operator delete((void *)STACK[0x5D8]);
  }
  if (SLOBYTE(STACK[0x5D7]) < 0) {
    operator delete((void *)STACK[0x5C0]);
  }
  STACK[0x420] = a34;
  sub_10002E39C((void ***)&STACK[0x420]);
  int v35 = (void *)STACK[0x588];
  if (STACK[0x588])
  {
    STACK[0x590] = (unint64_t)v35;
    operator delete(v35);
  }
  if (SLOBYTE(STACK[0x2C7]) < 0) {
    operator delete((void *)STACK[0x2B0]);
  }
  if (SLOBYTE(STACK[0x2AF]) < 0) {
    operator delete((void *)STACK[0x298]);
  }
  if (SLOBYTE(STACK[0x297]) < 0) {
    operator delete((void *)STACK[0x280]);
  }
  if (SLOBYTE(STACK[0x27F]) < 0) {
    operator delete((void *)STACK[0x268]);
  }
  STACK[0x420] = a28;
  sub_10002E39C((void ***)&STACK[0x420]);
  long long v36 = (void *)STACK[0x230];
  if (STACK[0x230])
  {
    STACK[0x238] = (unint64_t)v36;
    operator delete(v36);
  }
  _Unwind_Resume(a1);
}

void sub_1008FFCD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10002E664((uint64_t)v126, a2);
  sub_10002E664((uint64_t)v114, a1);
  int v6 = v126[0];
  int v7 = v114[0];
  if (v125 < 0) {
    operator delete(__p);
  }
  if (v123 < 0) {
    operator delete(v122);
  }
  if (v121 < 0) {
    operator delete(v120);
  }
  if (v119 < 0) {
    operator delete(v118);
  }
  uint64_t v137 = (void **)&v117;
  sub_10002E39C(&v137);
  if (v115)
  {
    uint64_t v116 = v115;
    operator delete(v115);
  }
  if (v136 < 0) {
    operator delete(v135);
  }
  if (v134 < 0) {
    operator delete(v133);
  }
  if (v132 < 0) {
    operator delete(v131);
  }
  if (v130 < 0) {
    operator delete(v129[4]);
  }
  uint64_t v137 = v129;
  sub_10002E39C(&v137);
  if (v127)
  {
    xpc_object_t v128 = v127;
    operator delete(v127);
  }
  if (v6 >= v7)
  {
    sub_10002E664((uint64_t)v102, a3);
    sub_10002E664((uint64_t)v90, a2);
    int v14 = v102[0];
    int v15 = v90[0];
    if (v101 < 0) {
      operator delete(v100);
    }
    if (v99 < 0) {
      operator delete(v98);
    }
    if (v97 < 0) {
      operator delete(v96);
    }
    if (v95 < 0) {
      operator delete(v94);
    }
    uint64_t v137 = (void **)&v93;
    sub_10002E39C(&v137);
    if (v91)
    {
      char v92 = v91;
      operator delete(v91);
    }
    if (v113 < 0) {
      operator delete(v112);
    }
    if (v111 < 0) {
      operator delete(v110);
    }
    if (v109 < 0) {
      operator delete(v108);
    }
    if (v107 < 0) {
      operator delete(v106);
    }
    uint64_t v137 = (void **)&v105;
    sub_10002E39C(&v137);
    if (v103)
    {
      char v104 = v103;
      operator delete(v103);
    }
    if (v14 < v15)
    {
      sub_100901744(a2, a3);
      sub_10002E664((uint64_t)v78, a2);
      sub_10002E664((uint64_t)v66, a1);
      int v16 = v78[0];
      int v17 = v66[0];
      if (v77 < 0) {
        operator delete(v76);
      }
      if (v75 < 0) {
        operator delete(v74);
      }
      if (v73 < 0) {
        operator delete(v72);
      }
      if (v71 < 0) {
        operator delete(v70);
      }
      uint64_t v137 = (void **)&v69;
      sub_10002E39C(&v137);
      if (v67)
      {
        char v68 = v67;
        operator delete(v67);
      }
      if (v89 < 0) {
        operator delete(v88);
      }
      if (v87 < 0) {
        operator delete(v86);
      }
      if (v85 < 0) {
        operator delete(v84);
      }
      if (v83 < 0) {
        operator delete(v82);
      }
      uint64_t v137 = (void **)&v81;
      sub_10002E39C(&v137);
      if (v79)
      {
        uint64_t v80 = v79;
        operator delete(v79);
      }
      if (v16 < v17)
      {
        uint64_t v10 = a1;
        uint64_t v13 = a2;
        goto LABEL_109;
      }
    }
  }
  else
  {
    sub_10002E664((uint64_t)v54, a3);
    sub_10002E664((uint64_t)v42, a2);
    int v8 = v54[0];
    int v9 = v42[0];
    if (v53 < 0) {
      operator delete(v52);
    }
    if (v51 < 0) {
      operator delete(v50);
    }
    if (v49 < 0) {
      operator delete(v48);
    }
    if (v47 < 0) {
      operator delete(v46);
    }
    uint64_t v137 = (void **)&v45;
    sub_10002E39C(&v137);
    if (v43)
    {
      int v44 = v43;
      operator delete(v43);
    }
    if (v65 < 0) {
      operator delete(v64);
    }
    if (v63 < 0) {
      operator delete(v62);
    }
    if (v61 < 0) {
      operator delete(v60);
    }
    if (v59 < 0) {
      operator delete(v58);
    }
    uint64_t v137 = (void **)&v57;
    sub_10002E39C(&v137);
    if (v55)
    {
      char v56 = v55;
      operator delete(v55);
    }
    uint64_t v10 = a1;
    if (v8 < v9) {
      goto LABEL_65;
    }
    sub_100901744(a1, a2);
    sub_10002E664((uint64_t)v30, a3);
    sub_10002E664((uint64_t)v18, a2);
    int v11 = v30[0];
    int v12 = v18[0];
    if (v29 < 0) {
      operator delete(v28);
    }
    if (v27 < 0) {
      operator delete(v26);
    }
    if (v25 < 0) {
      operator delete(v24);
    }
    if (v23 < 0) {
      operator delete(v22);
    }
    uint64_t v137 = (void **)&v21;
    sub_10002E39C(&v137);
    if (v19)
    {
      long long v20 = v19;
      operator delete(v19);
    }
    if (v41 < 0) {
      operator delete(v40);
    }
    if (v39 < 0) {
      operator delete(v38);
    }
    if (v37 < 0) {
      operator delete(v36);
    }
    if (v35 < 0) {
      operator delete(v34);
    }
    uint64_t v137 = (void **)&v33;
    sub_10002E39C(&v137);
    if (v31)
    {
      uint64_t v32 = v31;
      operator delete(v31);
    }
    if (v11 < v12)
    {
      uint64_t v10 = a2;
LABEL_65:
      uint64_t v13 = a3;
LABEL_109:
      sub_100901744(v10, v13);
    }
  }
}

void sub_1009001EC(_Unwind_Exception *a1)
{
}

unint64_t sub_100900230(uint64_t a1, unint64_t a2)
{
  long long v4 = *(_OWORD *)(a1 + 16);
  long long v171 = *(_OWORD *)a1;
  *(_OWORD *)v172 = v4;
  uint64_t v5 = *(void *)(a1 + 32);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  long long v174 = *(_OWORD *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v173 = v5;
  uint64_t v175 = v6;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  LOWORD(v5) = *(_WORD *)(a1 + 68);
  uint64_t v7 = *(void *)(a1 + 88);
  uint64_t v176 = 0;
  WORD2(v176) = v5;
  LODWORD(v176) = *(_DWORD *)(a1 + 64);
  long long v8 = *(_OWORD *)(a1 + 72);
  uint64_t v178 = v7;
  long long v177 = v8;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  uint64_t v9 = *(void *)(a1 + 112);
  *(_OWORD *)xpc_object_t v179 = *(_OWORD *)(a1 + 96);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  long long v10 = *(_OWORD *)(a1 + 120);
  uint64_t v11 = *(void *)(a1 + 136);
  uint64_t v180 = v9;
  uint64_t v182 = v11;
  long long v181 = v10;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  long long v12 = *(_OWORD *)(a1 + 144);
  uint64_t v184 = *(void *)(a1 + 160);
  *(_OWORD *)v183 = v12;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  sub_10002E664((uint64_t)v159, (uint64_t)&v171);
  sub_10002E664((uint64_t)v147, a2 - 168);
  int v13 = v159[0];
  int v14 = v147[0];
  if (v158 < 0) {
    operator delete(__p);
  }
  if (v156 < 0) {
    operator delete(v155);
  }
  if (v154 < 0) {
    operator delete(v153);
  }
  if (v152 < 0) {
    operator delete(v151);
  }
  v185[0] = (void **)&v150;
  sub_10002E39C(v185);
  if (v148)
  {
    char v149 = v148;
    operator delete(v148);
  }
  if (v170 < 0) {
    operator delete(v169);
  }
  if (v168 < 0) {
    operator delete(v167);
  }
  if (v166 < 0) {
    operator delete(v165);
  }
  if (v164 < 0) {
    operator delete(v163);
  }
  v185[0] = (void **)&v162;
  sub_10002E39C(v185);
  if (v160)
  {
    char v161 = v160;
    operator delete(v160);
  }
  if (v13 >= v14)
  {
    for (unint64_t i = a1 + 168; i < a2; i += 168)
    {
      sub_10002E664((uint64_t)v111, (uint64_t)&v171);
      sub_10002E664((uint64_t)v99, i);
      int v18 = v111[0];
      int v19 = v99[0];
      if (v110 < 0) {
        operator delete(v109);
      }
      if (v108 < 0) {
        operator delete(v107);
      }
      if (v106 < 0) {
        operator delete(v105);
      }
      if (v104 < 0) {
        operator delete(v103);
      }
      v185[0] = (void **)&v102;
      sub_10002E39C(v185);
      if (v100)
      {
        char v101 = v100;
        operator delete(v100);
      }
      if (v122 < 0) {
        operator delete(v121);
      }
      if (v120 < 0) {
        operator delete(v119);
      }
      if (v118 < 0) {
        operator delete(v117);
      }
      if (v116 < 0) {
        operator delete(v115);
      }
      v185[0] = (void **)&v114;
      sub_10002E39C(v185);
      if (v112)
      {
        char v113 = v112;
        operator delete(v112);
      }
      if (v18 < v19) {
        break;
      }
    }
  }
  else
  {
    unint64_t i = a1;
    do
    {
      sub_10002E664((uint64_t)v135, (uint64_t)&v171);
      i += 168;
      sub_10002E664((uint64_t)v123, i);
      int v16 = v135[0];
      int v17 = v123[0];
      if (v134 < 0) {
        operator delete(v133);
      }
      if (v132 < 0) {
        operator delete(v131);
      }
      if (v130 < 0) {
        operator delete(v129);
      }
      if (v128 < 0) {
        operator delete(v127);
      }
      v185[0] = (void **)&v126;
      sub_10002E39C(v185);
      if (v124)
      {
        char v125 = v124;
        operator delete(v124);
      }
      if (v146 < 0) {
        operator delete(v145);
      }
      if (v144 < 0) {
        operator delete(v143);
      }
      if (v142 < 0) {
        operator delete(v141);
      }
      if (v140 < 0) {
        operator delete(v139);
      }
      v185[0] = (void **)&v138;
      sub_10002E39C(v185);
      if (v136)
      {
        uint64_t v137 = v136;
        operator delete(v136);
      }
    }
    while (v16 >= v17);
  }
  if (i < a2)
  {
    do
    {
      sub_10002E664((uint64_t)v87, (uint64_t)&v171);
      a2 -= 168;
      sub_10002E664((uint64_t)v75, a2);
      int v20 = v87[0];
      int v21 = v75[0];
      if (v86 < 0) {
        operator delete(v85);
      }
      if (v84 < 0) {
        operator delete(v83);
      }
      if (v82 < 0) {
        operator delete(v81);
      }
      if (v80 < 0) {
        operator delete(v79);
      }
      v185[0] = (void **)&v78;
      sub_10002E39C(v185);
      if (v76)
      {
        char v77 = v76;
        operator delete(v76);
      }
      if (v98 < 0) {
        operator delete(v97);
      }
      if (v96 < 0) {
        operator delete(v95);
      }
      if (v94 < 0) {
        operator delete(v93);
      }
      if (v92 < 0) {
        operator delete(v91);
      }
      v185[0] = (void **)&v90;
      sub_10002E39C(v185);
      if (v88)
      {
        char v89 = v88;
        operator delete(v88);
      }
    }
    while (v20 < v21);
  }
  while (i < a2)
  {
    sub_100901744(i, a2);
    do
    {
      sub_10002E664((uint64_t)v63, (uint64_t)&v171);
      i += 168;
      sub_10002E664((uint64_t)v51, i);
      int v22 = v63[0];
      int v23 = v51[0];
      if (v62 < 0) {
        operator delete(v61);
      }
      if (v60 < 0) {
        operator delete(v59);
      }
      if (v58 < 0) {
        operator delete(v57);
      }
      if (v56 < 0) {
        operator delete(v55);
      }
      v185[0] = (void **)&v54;
      sub_10002E39C(v185);
      if (v52)
      {
        char v53 = v52;
        operator delete(v52);
      }
      if (v74 < 0) {
        operator delete(v73);
      }
      if (v72 < 0) {
        operator delete(v71);
      }
      if (v70 < 0) {
        operator delete(v69);
      }
      if (v68 < 0) {
        operator delete(v67);
      }
      v185[0] = (void **)&v66;
      sub_10002E39C(v185);
      if (v64)
      {
        char v65 = v64;
        operator delete(v64);
      }
    }
    while (v22 >= v23);
    do
    {
      sub_10002E664((uint64_t)v39, (uint64_t)&v171);
      a2 -= 168;
      sub_10002E664((uint64_t)v27, a2);
      int v24 = v39[0];
      int v25 = v27[0];
      if (v38 < 0) {
        operator delete(v37);
      }
      if (v36 < 0) {
        operator delete(v35);
      }
      if (v34 < 0) {
        operator delete(v33);
      }
      if (v32 < 0) {
        operator delete(v31);
      }
      v185[0] = (void **)&v30;
      sub_10002E39C(v185);
      if (v28)
      {
        char v29 = v28;
        operator delete(v28);
      }
      if (v50 < 0) {
        operator delete(v49);
      }
      if (v48 < 0) {
        operator delete(v47);
      }
      if (v46 < 0) {
        operator delete(v45);
      }
      if (v44 < 0) {
        operator delete(v43);
      }
      v185[0] = (void **)&v42;
      sub_10002E39C(v185);
      if (v40)
      {
        char v41 = v40;
        operator delete(v40);
      }
    }
    while (v24 < v25);
  }
  if (i - 168 != a1) {
    sub_10032FAFC(a1, i - 168);
  }
  sub_10032FAFC(i - 168, (uint64_t)&v171);
  if (SHIBYTE(v184) < 0) {
    operator delete(v183[0]);
  }
  if (SHIBYTE(v182) < 0) {
    operator delete((void *)v181);
  }
  if (SHIBYTE(v180) < 0) {
    operator delete(v179[0]);
  }
  if (SHIBYTE(v178) < 0) {
    operator delete((void *)v177);
  }
  v185[0] = (void **)&v174;
  sub_10002E39C(v185);
  if (v172[0])
  {
    v172[1] = v172[0];
    operator delete(v172[0]);
  }
  return i;
}

void sub_100900998(_Unwind_Exception *a1)
{
}

uint64_t sub_100900A0C(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = 0;
  long long v5 = *(_OWORD *)(a1 + 16);
  long long v149 = *(_OWORD *)a1;
  *(_OWORD *)uint64_t v150 = v5;
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  long long v152 = *(_OWORD *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v151 = v6;
  uint64_t v153 = v7;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  LOWORD(v6) = *(_WORD *)(a1 + 68);
  uint64_t v8 = *(void *)(a1 + 88);
  uint64_t v154 = 0;
  WORD2(v154) = v6;
  LODWORD(v154) = *(_DWORD *)(a1 + 64);
  long long v9 = *(_OWORD *)(a1 + 72);
  uint64_t v156 = v8;
  long long v155 = v9;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  uint64_t v10 = *(void *)(a1 + 112);
  *(_OWORD *)xpc_object_t v157 = *(_OWORD *)(a1 + 96);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  long long v11 = *(_OWORD *)(a1 + 120);
  uint64_t v12 = *(void *)(a1 + 136);
  uint64_t v158 = v10;
  uint64_t v160 = v12;
  long long v159 = v11;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  long long v13 = *(_OWORD *)(a1 + 144);
  uint64_t v162 = *(void *)(a1 + 160);
  *(_OWORD *)char v161 = v13;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  do
  {
    sub_10002E664((uint64_t)v137, a1 + v4 + 168);
    sub_10002E664((uint64_t)v125, (uint64_t)&v149);
    int v14 = v137[0];
    int v15 = v125[0];
    if (v136 < 0) {
      operator delete(__p);
    }
    if (v134 < 0) {
      operator delete(v133);
    }
    if (v132 < 0) {
      operator delete(v131);
    }
    if (v130 < 0) {
      operator delete(v129);
    }
    v163[0] = (void **)&v128;
    sub_10002E39C(v163);
    if (v126)
    {
      char v127 = v126;
      operator delete(v126);
    }
    if (v148 < 0) {
      operator delete(v147);
    }
    if (v146 < 0) {
      operator delete(v145);
    }
    if (v144 < 0) {
      operator delete(v143);
    }
    if (v142 < 0) {
      operator delete(v141);
    }
    v163[0] = (void **)&v140;
    sub_10002E39C(v163);
    if (v138)
    {
      uint64_t v139 = v138;
      operator delete(v138);
    }
    v4 += 168;
  }
  while (v14 < v15);
  unint64_t v16 = a1 + v4;
  if (v4 == 168)
  {
    if (v16 < a2)
    {
      do
      {
        a2 -= 168;
        sub_10002E664((uint64_t)v113, a2);
        sub_10002E664((uint64_t)v101, (uint64_t)&v149);
        int v19 = v113[0];
        int v20 = v101[0];
        if (v112 < 0) {
          operator delete(v111);
        }
        if (v110 < 0) {
          operator delete(v109);
        }
        if (v108 < 0) {
          operator delete(v107);
        }
        if (v106 < 0) {
          operator delete(v105);
        }
        v163[0] = (void **)&v104;
        sub_10002E39C(v163);
        if (v102)
        {
          char v103 = v102;
          operator delete(v102);
        }
        if (v124 < 0) {
          operator delete(v123);
        }
        if (v122 < 0) {
          operator delete(v121);
        }
        if (v120 < 0) {
          operator delete(v119);
        }
        if (v118 < 0) {
          operator delete(v117);
        }
        v163[0] = (void **)&v116;
        sub_10002E39C(v163);
        if (v114)
        {
          uint64_t v115 = v114;
          operator delete(v114);
        }
      }
      while (v16 < a2 && v19 >= v20);
    }
  }
  else
  {
    do
    {
      a2 -= 168;
      sub_10002E664((uint64_t)v89, a2);
      sub_10002E664((uint64_t)v77, (uint64_t)&v149);
      int v17 = v89[0];
      int v18 = v77[0];
      if (v88 < 0) {
        operator delete(v87);
      }
      if (v86 < 0) {
        operator delete(v85);
      }
      if (v84 < 0) {
        operator delete(v83);
      }
      if (v82 < 0) {
        operator delete(v81);
      }
      v163[0] = (void **)&v80;
      sub_10002E39C(v163);
      if (v78)
      {
        long long v79 = v78;
        operator delete(v78);
      }
      if (v100 < 0) {
        operator delete(v99);
      }
      if (v98 < 0) {
        operator delete(v97);
      }
      if (v96 < 0) {
        operator delete(v95);
      }
      if (v94 < 0) {
        operator delete(v93);
      }
      v163[0] = (void **)&v92;
      sub_10002E39C(v163);
      if (v90)
      {
        char v91 = v90;
        operator delete(v90);
      }
    }
    while (v17 >= v18);
  }
  if (v16 >= a2)
  {
    uint64_t v27 = v16 - 168;
  }
  else
  {
    unint64_t v21 = a1 + v4;
    unint64_t v22 = a2;
    do
    {
      sub_100901744(v21, v22);
      do
      {
        v21 += 168;
        sub_10002E664((uint64_t)v65, v21);
        sub_10002E664((uint64_t)v53, (uint64_t)&v149);
        int v23 = v65[0];
        int v24 = v53[0];
        if (v64 < 0) {
          operator delete(v63);
        }
        if (v62 < 0) {
          operator delete(v61);
        }
        if (v60 < 0) {
          operator delete(v59);
        }
        if (v58 < 0) {
          operator delete(v57);
        }
        v163[0] = (void **)&v56;
        sub_10002E39C(v163);
        if (v54)
        {
          long long v55 = v54;
          operator delete(v54);
        }
        if (v76 < 0) {
          operator delete(v75);
        }
        if (v74 < 0) {
          operator delete(v73);
        }
        if (v72 < 0) {
          operator delete(v71);
        }
        if (v70 < 0) {
          operator delete(v69);
        }
        v163[0] = (void **)&v68;
        sub_10002E39C(v163);
        if (v66)
        {
          char v67 = v66;
          operator delete(v66);
        }
      }
      while (v23 < v24);
      do
      {
        v22 -= 168;
        sub_10002E664((uint64_t)v41, v22);
        sub_10002E664((uint64_t)v29, (uint64_t)&v149);
        int v25 = v41[0];
        int v26 = v29[0];
        if (v40 < 0) {
          operator delete(v39);
        }
        if (v38 < 0) {
          operator delete(v37);
        }
        if (v36 < 0) {
          operator delete(v35);
        }
        if (v34 < 0) {
          operator delete(v33);
        }
        v163[0] = (void **)&v32;
        sub_10002E39C(v163);
        if (v30)
        {
          unint64_t v31 = v30;
          operator delete(v30);
        }
        if (v52 < 0) {
          operator delete(v51);
        }
        if (v50 < 0) {
          operator delete(v49);
        }
        if (v48 < 0) {
          operator delete(v47);
        }
        if (v46 < 0) {
          operator delete(v45);
        }
        v163[0] = (void **)&v44;
        sub_10002E39C(v163);
        if (v42)
        {
          int v43 = v42;
          operator delete(v42);
        }
      }
      while (v25 >= v26);
    }
    while (v21 < v22);
    uint64_t v27 = v21 - 168;
  }
  if (v27 != a1) {
    sub_10032FAFC(a1, v27);
  }
  sub_10032FAFC(v27, (uint64_t)&v149);
  if (SHIBYTE(v162) < 0) {
    operator delete(v161[0]);
  }
  if (SHIBYTE(v160) < 0) {
    operator delete((void *)v159);
  }
  if (SHIBYTE(v158) < 0) {
    operator delete(v157[0]);
  }
  if (SHIBYTE(v156) < 0) {
    operator delete((void *)v155);
  }
  v163[0] = (void **)&v152;
  sub_10002E39C(v163);
  if (v150[0])
  {
    v150[1] = v150[0];
    operator delete(v150[0]);
  }
  return v27;
}

void sub_1009010A8(_Unwind_Exception *a1)
{
}

BOOL sub_10090110C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCF3CF3CF3CF3CF3DLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      sub_10002E664((uint64_t)v98, a2 - 168);
      sub_10002E664((uint64_t)v86, a1);
      int v6 = v98[0];
      int v7 = v86[0];
      if (v97 < 0) {
        operator delete(__p);
      }
      if (v95 < 0) {
        operator delete(v94);
      }
      if (v93 < 0) {
        operator delete(v92);
      }
      if (v91 < 0) {
        operator delete(v90);
      }
      *(void *)&long long v48 = &v89;
      sub_10002E39C((void ***)&v48);
      if (v87)
      {
        char v88 = v87;
        operator delete(v87);
      }
      if (v109 < 0) {
        operator delete(v108);
      }
      if (v107 < 0) {
        operator delete(v106);
      }
      if (v105 < 0) {
        operator delete(v104);
      }
      if (v103 < 0) {
        operator delete(v102);
      }
      *(void *)&long long v48 = &v101;
      sub_10002E39C((void ***)&v48);
      if (v99)
      {
        char v100 = v99;
        operator delete(v99);
      }
      if (v6 < v7) {
        sub_100901744(a1, v2 - 168);
      }
      return 1;
    case 3uLL:
      sub_1008FFCD0(a1, a1 + 168, a2 - 168);
      return 1;
    case 4uLL:
      sub_100901874(a1, a1 + 168, a1 + 336, a2 - 168);
      return 1;
    case 5uLL:
      sub_1008FED34(a1, a1 + 168, a1 + 336, a1 + 504, a2 - 168);
      return 1;
    default:
      uint64_t v8 = a1 + 336;
      sub_1008FFCD0(a1, a1 + 168, a1 + 336);
      uint64_t v9 = a1 + 504;
      if (a1 + 504 == v2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v23 = 0;
      uint64_t v22 = v2;
      break;
  }
  do
  {
    sub_10002E664((uint64_t)v74, v9);
    sub_10002E664((uint64_t)v62, v8);
    int v11 = v74[0];
    int v12 = v62[0];
    if (v73 < 0) {
      operator delete(v72);
    }
    if (v71 < 0) {
      operator delete(v70);
    }
    if (v69 < 0) {
      operator delete(v68);
    }
    if (v67 < 0) {
      operator delete(v66);
    }
    *(void *)&long long v48 = &v65;
    sub_10002E39C((void ***)&v48);
    if (v63)
    {
      char v64 = v63;
      operator delete(v63);
    }
    if (v85 < 0) {
      operator delete(v84);
    }
    if (v83 < 0) {
      operator delete(v82);
    }
    if (v81 < 0) {
      operator delete(v80);
    }
    if (v79 < 0) {
      operator delete(v78);
    }
    *(void *)&long long v48 = &v77;
    sub_10002E39C((void ***)&v48);
    if (v75)
    {
      char v76 = v75;
      operator delete(v75);
    }
    if (v11 >= v12) {
      goto LABEL_87;
    }
    long long v13 = *(_OWORD *)(v9 + 16);
    long long v48 = *(_OWORD *)v9;
    *(_OWORD *)char v49 = v13;
    uint64_t v50 = *(void *)(v9 + 32);
    *(void *)(v9 + 16) = 0;
    *(void *)(v9 + 24) = 0;
    long long v51 = *(_OWORD *)(v9 + 40);
    uint64_t v52 = *(void *)(v9 + 56);
    uint64_t v53 = 0;
    *(void *)(v9 + 32) = 0;
    *(void *)(v9 + 40) = 0;
    *(void *)(v9 + 48) = 0;
    *(void *)(v9 + 56) = 0;
    WORD2(v53) = *(_WORD *)(v9 + 68);
    LODWORD(v53) = *(_DWORD *)(v9 + 64);
    long long v14 = *(_OWORD *)(v9 + 72);
    uint64_t v55 = *(void *)(v9 + 88);
    long long v54 = v14;
    *(void *)(v9 + 72) = 0;
    *(void *)(v9 + 80) = 0;
    long long v15 = *(_OWORD *)(v9 + 96);
    uint64_t v57 = *(void *)(v9 + 112);
    long long v56 = v15;
    *(void *)(v9 + 88) = 0;
    *(void *)(v9 + 96) = 0;
    *(void *)(v9 + 104) = 0;
    *(void *)(v9 + 112) = 0;
    long long v16 = *(_OWORD *)(v9 + 120);
    uint64_t v59 = *(void *)(v9 + 136);
    long long v58 = v16;
    *(void *)(v9 + 120) = 0;
    *(void *)(v9 + 128) = 0;
    long long v17 = *(_OWORD *)(v9 + 144);
    uint64_t v61 = *(void *)(v9 + 160);
    long long v60 = v17;
    *(void *)(v9 + 136) = 0;
    *(void *)(v9 + 144) = 0;
    *(void *)(v9 + 152) = 0;
    *(void *)(v9 + 160) = 0;
    sub_10032FAFC(v9, v8);
    uint64_t v18 = a1;
    if (v8 == a1) {
      goto LABEL_76;
    }
    uint64_t v19 = v10;
    while (1)
    {
      sub_10002E664((uint64_t)v36, (uint64_t)&v48);
      sub_10002E664((uint64_t)v24, a1 + v19 + 168);
      int v20 = v36[0];
      int v21 = v24[0];
      if (v35 < 0) {
        operator delete(v34);
      }
      if (v33 < 0) {
        operator delete(v32);
      }
      if (v31 < 0) {
        operator delete(v30);
      }
      if (v29 < 0) {
        operator delete(v28);
      }
      v110[0] = (void **)&v27;
      sub_10002E39C(v110);
      if (v25)
      {
        int v26 = v25;
        operator delete(v25);
      }
      if (v47 < 0) {
        operator delete(v46);
      }
      if (v45 < 0) {
        operator delete(v44);
      }
      if (v43 < 0) {
        operator delete(v42);
      }
      if (v41 < 0) {
        operator delete(v40);
      }
      v110[0] = (void **)&v39;
      sub_10002E39C(v110);
      if (v37)
      {
        char v38 = v37;
        operator delete(v37);
        if (v20 >= v21)
        {
          uint64_t v18 = a1 + v19 + 336;
          goto LABEL_75;
        }
        goto LABEL_72;
      }
      if (v20 >= v21) {
        break;
      }
LABEL_72:
      v8 -= 168;
      sub_10032FAFC(a1 + v19 + 336, a1 + v19 + 168);
      v19 -= 168;
      if (v19 == -336)
      {
        uint64_t v18 = a1;
        goto LABEL_75;
      }
    }
    uint64_t v18 = v8;
LABEL_75:
    uint64_t v2 = v22;
LABEL_76:
    sub_10032FAFC(v18, (uint64_t)&v48);
    if (SHIBYTE(v61) < 0) {
      operator delete((void *)v60);
    }
    if (SHIBYTE(v59) < 0) {
      operator delete((void *)v58);
    }
    if (SHIBYTE(v57) < 0) {
      operator delete((void *)v56);
    }
    if (SHIBYTE(v55) < 0) {
      operator delete((void *)v54);
    }
    v110[0] = (void **)&v51;
    sub_10002E39C(v110);
    if (v49[0])
    {
      v49[1] = v49[0];
      operator delete(v49[0]);
    }
    if (++v23 == 8) {
      return v9 + 168 == v2;
    }
LABEL_87:
    uint64_t v8 = v9;
    v10 += 168;
    v9 += 168;
  }
  while (v9 != v2);
  return 1;
}

void sub_1009016F0(_Unwind_Exception *a1)
{
}

void sub_100901744(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v8 = *(_OWORD *)a1;
  *(_OWORD *)uint64_t v9 = v3;
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  long long v11 = *(_OWORD *)(a1 + 40);
  uint64_t v12 = *(void *)(a1 + 56);
  uint64_t v13 = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  WORD2(v13) = *(_WORD *)(a1 + 68);
  LODWORD(v13) = *(_DWORD *)(a1 + 64);
  long long v4 = *(_OWORD *)(a1 + 72);
  uint64_t v15 = *(void *)(a1 + 88);
  *(_OWORD *)long long v14 = v4;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  long long v5 = *(_OWORD *)(a1 + 96);
  uint64_t v17 = *(void *)(a1 + 112);
  *(_OWORD *)long long v16 = v5;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  long long v6 = *(_OWORD *)(a1 + 120);
  uint64_t v19 = *(void *)(a1 + 136);
  *(_OWORD *)uint64_t v18 = v6;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  long long v7 = *(_OWORD *)(a1 + 144);
  uint64_t v21 = *(void *)(a1 + 160);
  *(_OWORD *)long long __p = v7;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  sub_10032FAFC(a1, a2);
  sub_10032FAFC(a2, (uint64_t)&v8);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[0]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
  uint64_t v22 = (void **)&v11;
  sub_10002E39C(&v22);
  if (v9[0])
  {
    v9[1] = v9[0];
    operator delete(v9[0]);
  }
}

void sub_100901874(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1008FFCD0(a1, a2, a3);
  sub_10002E664((uint64_t)v74, a4);
  sub_10002E664((uint64_t)v62, a3);
  int v8 = v74[0];
  int v9 = v62[0];
  if (v73 < 0) {
    operator delete(__p);
  }
  if (v71 < 0) {
    operator delete(v70);
  }
  if (v69 < 0) {
    operator delete(v68);
  }
  if (v67 < 0) {
    operator delete(v66);
  }
  char v85 = (void **)&v65;
  sub_10002E39C(&v85);
  if (v63)
  {
    char v64 = v63;
    operator delete(v63);
  }
  if (v84 < 0) {
    operator delete(v83);
  }
  if (v82 < 0) {
    operator delete(v81);
  }
  if (v80 < 0) {
    operator delete(v79);
  }
  if (v78 < 0) {
    operator delete(v77[4]);
  }
  char v85 = v77;
  sub_10002E39C(&v85);
  if (v75)
  {
    char v76 = v75;
    operator delete(v75);
  }
  if (v8 < v9)
  {
    sub_100901744(a3, a4);
    sub_10002E664((uint64_t)v50, a3);
    sub_10002E664((uint64_t)v38, a2);
    int v10 = v50[0];
    int v11 = v38[0];
    if (v49 < 0) {
      operator delete(v48);
    }
    if (v47 < 0) {
      operator delete(v46);
    }
    if (v45 < 0) {
      operator delete(v44);
    }
    if (v43 < 0) {
      operator delete(v42);
    }
    char v85 = (void **)&v41;
    sub_10002E39C(&v85);
    if (v39)
    {
      char v40 = v39;
      operator delete(v39);
    }
    if (v61 < 0) {
      operator delete(v60);
    }
    if (v59 < 0) {
      operator delete(v58);
    }
    if (v57 < 0) {
      operator delete(v56);
    }
    if (v55 < 0) {
      operator delete(v54);
    }
    char v85 = (void **)&v53;
    sub_10002E39C(&v85);
    if (v51)
    {
      uint64_t v52 = v51;
      operator delete(v51);
    }
    if (v10 < v11)
    {
      sub_100901744(a2, a3);
      sub_10002E664((uint64_t)v26, a2);
      sub_10002E664((uint64_t)v14, a1);
      int v12 = v26[0];
      int v13 = v14[0];
      if (v25 < 0) {
        operator delete(v24);
      }
      if (v23 < 0) {
        operator delete(v22);
      }
      if (v21 < 0) {
        operator delete(v20);
      }
      if (v19 < 0) {
        operator delete(v18);
      }
      char v85 = (void **)&v17;
      sub_10002E39C(&v85);
      if (v15)
      {
        long long v16 = v15;
        operator delete(v15);
      }
      if (v37 < 0) {
        operator delete(v36);
      }
      if (v35 < 0) {
        operator delete(v34);
      }
      if (v33 < 0) {
        operator delete(v32);
      }
      if (v31 < 0) {
        operator delete(v30);
      }
      char v85 = (void **)&v29;
      sub_10002E39C(&v85);
      if (v27)
      {
        uint64_t v28 = v27;
        operator delete(v27);
      }
      if (v12 < v13) {
        sub_100901744(a1, a2);
      }
    }
  }
}

void sub_100901BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_100901BE4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a2 - 2;
  if (a2 >= 2)
  {
    uint64_t v4 = a3;
    int64_t v6 = v3 >> 1;
    if ((uint64_t)(v3 >> 1) >= (uint64_t)(0xCF3CF3CF3CF3CF3DLL * ((a3 - a1) >> 3)))
    {
      int64_t v8 = (0x9E79E79E79E79E7ALL * ((a3 - a1) >> 3)) | 1;
      uint64_t v9 = a1 + 168 * v8;
      int64_t v10 = 0x9E79E79E79E79E7ALL * ((a3 - a1) >> 3) + 2;
      unint64_t v32 = v3 >> 1;
      if (v10 < a2)
      {
        sub_10002E664((uint64_t)v131, a1 + 168 * v8);
        sub_10002E664((uint64_t)v119, v9 + 168);
        int v11 = v131[0];
        int v12 = v119[0];
        if (v130 < 0) {
          operator delete(__p);
        }
        if (v128 < 0) {
          operator delete(v127);
        }
        if (v126 < 0) {
          operator delete(v125);
        }
        if (v124 < 0) {
          operator delete(v123);
        }
        *(void *)&long long v81 = &v122;
        sub_10002E39C((void ***)&v81);
        if (v120)
        {
          char v121 = v120;
          operator delete(v120);
        }
        if (v142 < 0) {
          operator delete(v141);
        }
        if (v140 < 0) {
          operator delete(v139);
        }
        if (v138 < 0) {
          operator delete(v137);
        }
        if (v136 < 0) {
          operator delete(v135);
        }
        *(void *)&long long v81 = &v134;
        sub_10002E39C((void ***)&v81);
        if (v132)
        {
          long long v133 = v132;
          operator delete(v132);
        }
        BOOL v13 = v11 < v12;
        int64_t v6 = v32;
        if (v13)
        {
          v9 += 168;
          int64_t v8 = v10;
        }
      }
      sub_10002E664((uint64_t)v107, v9);
      sub_10002E664((uint64_t)v95, v4);
      int v14 = v107[0];
      int v15 = v95[0];
      if (v106 < 0) {
        operator delete(v105);
      }
      if (v104 < 0) {
        operator delete(v103);
      }
      if (v102 < 0) {
        operator delete(v101);
      }
      if (v100 < 0) {
        operator delete(v99);
      }
      *(void *)&long long v81 = &v98;
      sub_10002E39C((void ***)&v81);
      if (v96)
      {
        char v97 = v96;
        operator delete(v96);
      }
      if (v118 < 0) {
        operator delete(v117);
      }
      if (v116 < 0) {
        operator delete(v115);
      }
      if (v114 < 0) {
        operator delete(v113);
      }
      if (v112 < 0) {
        operator delete(v111);
      }
      *(void *)&long long v81 = &v110;
      sub_10002E39C((void ***)&v81);
      if (v108)
      {
        char v109 = v108;
        operator delete(v108);
      }
      if (v14 >= v15)
      {
        long long v16 = *(_OWORD *)(v4 + 16);
        long long v81 = *(_OWORD *)v4;
        *(_OWORD *)char v82 = v16;
        uint64_t v17 = *(void *)(v4 + 32);
        *(void *)(v4 + 16) = 0;
        *(void *)(v4 + 24) = 0;
        long long v84 = *(_OWORD *)(v4 + 40);
        uint64_t v18 = *(void *)(v4 + 56);
        uint64_t v83 = v17;
        uint64_t v85 = v18;
        *(void *)(v4 + 32) = 0;
        *(void *)(v4 + 40) = 0;
        *(void *)(v4 + 48) = 0;
        *(void *)(v4 + 56) = 0;
        LOWORD(v17) = *(_WORD *)(v4 + 68);
        uint64_t v19 = *(void *)(v4 + 88);
        uint64_t v86 = 0;
        WORD2(v86) = v17;
        LODWORD(v86) = *(_DWORD *)(v4 + 64);
        long long v20 = *(_OWORD *)(v4 + 72);
        uint64_t v88 = v19;
        long long v87 = v20;
        *(void *)(v4 + 72) = 0;
        *(void *)(v4 + 80) = 0;
        uint64_t v21 = *(void *)(v4 + 112);
        *(_OWORD *)uint64_t v89 = *(_OWORD *)(v4 + 96);
        *(void *)(v4 + 88) = 0;
        *(void *)(v4 + 96) = 0;
        *(void *)(v4 + 104) = 0;
        *(void *)(v4 + 112) = 0;
        long long v22 = *(_OWORD *)(v4 + 120);
        uint64_t v23 = *(void *)(v4 + 136);
        uint64_t v90 = v21;
        uint64_t v92 = v23;
        long long v91 = v22;
        *(void *)(v4 + 120) = 0;
        *(void *)(v4 + 128) = 0;
        long long v24 = *(_OWORD *)(v4 + 144);
        uint64_t v94 = *(void *)(v4 + 160);
        *(_OWORD *)char v93 = v24;
        *(void *)(v4 + 136) = 0;
        *(void *)(v4 + 144) = 0;
        *(void *)(v4 + 152) = 0;
        *(void *)(v4 + 160) = 0;
        do
        {
          uint64_t v25 = v9;
          sub_10032FAFC(v4, v9);
          if (v6 < v8) {
            break;
          }
          uint64_t v26 = 2 * v8;
          int64_t v8 = (2 * v8) | 1;
          uint64_t v9 = a1 + 168 * v8;
          int64_t v27 = v26 + 2;
          if (v26 + 2 < a2)
          {
            sub_10002E664((uint64_t)v69, a1 + 168 * v8);
            sub_10002E664((uint64_t)v57, v9 + 168);
            int v28 = v69[0];
            int v29 = v57[0];
            if (v68 < 0) {
              operator delete(v67);
            }
            if (v66 < 0) {
              operator delete(v65);
            }
            if (v64 < 0) {
              operator delete(v63);
            }
            if (v62 < 0) {
              operator delete(v61);
            }
            v143[0] = (void **)&v60;
            sub_10002E39C(v143);
            if (v58)
            {
              char v59 = v58;
              operator delete(v58);
            }
            if (v80 < 0) {
              operator delete(v79);
            }
            if (v78 < 0) {
              operator delete(v77);
            }
            if (v76 < 0) {
              operator delete(v75);
            }
            if (v74 < 0) {
              operator delete(v73);
            }
            v143[0] = (void **)&v72;
            sub_10002E39C(v143);
            if (v70)
            {
              char v71 = v70;
              operator delete(v70);
            }
            BOOL v13 = v28 < v29;
            int64_t v6 = v32;
            if (v13)
            {
              v9 += 168;
              int64_t v8 = v27;
            }
          }
          sub_10002E664((uint64_t)v45, v9);
          sub_10002E664((uint64_t)v33, (uint64_t)&v81);
          int v30 = v45[0];
          int v31 = v33[0];
          if (v44 < 0) {
            operator delete(v43);
          }
          if (v42 < 0) {
            operator delete(v41);
          }
          if (v40 < 0) {
            operator delete(v39);
          }
          if (v38 < 0) {
            operator delete(v37);
          }
          v143[0] = (void **)&v36;
          sub_10002E39C(v143);
          if (v34)
          {
            char v35 = v34;
            operator delete(v34);
          }
          if (v56 < 0) {
            operator delete(v55);
          }
          if (v54 < 0) {
            operator delete(v53);
          }
          if (v52 < 0) {
            operator delete(v51);
          }
          if (v50 < 0) {
            operator delete(v49);
          }
          v143[0] = (void **)&v48;
          sub_10002E39C(v143);
          if (v46)
          {
            char v47 = v46;
            operator delete(v46);
          }
          uint64_t v4 = v25;
        }
        while (v30 >= v31);
        sub_10032FAFC(v25, (uint64_t)&v81);
        if (SHIBYTE(v94) < 0) {
          operator delete(v93[0]);
        }
        if (SHIBYTE(v92) < 0) {
          operator delete((void *)v91);
        }
        if (SHIBYTE(v90) < 0) {
          operator delete(v89[0]);
        }
        if (SHIBYTE(v88) < 0) {
          operator delete((void *)v87);
        }
        v143[0] = (void **)&v84;
        sub_10002E39C(v143);
        if (v82[0])
        {
          v82[1] = v82[0];
          operator delete(v82[0]);
        }
      }
    }
  }
}

void sub_1009021D0(_Unwind_Exception *a1)
{
}

void sub_100902218(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, char a5)
{
void sub_100902638(uint64_t a1, void *a2)
{
  if ((void *)a1 != a2)
  {
    uint64_t v17 = v2;
    uint64_t v18 = v3;
    char v6 = (void *)(a1 + 24);
    if ((void *)(a1 + 24) != a2)
    {
      uint64_t v7 = 0;
      int64_t v8 = (void *)a1;
      do
      {
        uint64_t v9 = (void **)v8;
        int64_t v8 = v6;
        if ((sub_100046FE8(v6, v9) & 0x80) != 0)
        {
          long long v15 = *(_OWORD *)v8;
          uint64_t v16 = v8[2];
          v8[1] = 0;
          void v8[2] = 0;
          *int64_t v8 = 0;
          uint64_t v10 = v7;
          do
          {
            uint64_t v11 = a1 + v10;
            int v12 = (void **)(a1 + v10 + 24);
            if (*(char *)(a1 + v10 + 47) < 0) {
              operator delete(*v12);
            }
            *(_OWORD *)int v12 = *(_OWORD *)v11;
            *(void *)(a1 + v10 + 40) = *(void *)(v11 + 16);
            *(unsigned char *)(v11 + 23) = 0;
            *(unsigned char *)uint64_t v11 = 0;
            if (!v10)
            {
              uint64_t v14 = a1;
              goto LABEL_13;
            }
            v10 -= 24;
          }
          while ((sub_100046FE8(&v15, (void **)(v10 + a1)) & 0x80) != 0);
          int v13 = *(char *)(a1 + v10 + 47);
          uint64_t v14 = a1 + v10 + 24;
          if (v13 < 0) {
            operator delete(*(void **)v14);
          }
LABEL_13:
          *(_OWORD *)uint64_t v14 = v15;
          *(void *)(v14 + 16) = v16;
        }
        char v6 = v8 + 3;
        v7 += 24;
      }
      while (v8 + 3 != a2);
    }
  }
}

void sub_100902754(void *a1, void *a2)
{
  if (a1 != a2)
  {
    uint64_t v16 = v2;
    uint64_t v17 = v3;
    char v5 = a1;
    char v6 = a1 + 3;
    if (a1 + 3 != a2)
    {
      uint64_t v7 = a1 - 3;
      do
      {
        int64_t v8 = (void **)v5;
        char v5 = v6;
        if ((sub_100046FE8(v6, v8) & 0x80) != 0)
        {
          long long v14 = *(_OWORD *)v5;
          long long v15 = (void *)v5[2];
          v5[1] = 0;
          void v5[2] = 0;
          *char v5 = 0;
          uint64_t v9 = v7;
          do
          {
            uint64_t v10 = (void **)(v9 + 6);
            if (*((char *)v9 + 71) < 0) {
              operator delete(*v10);
            }
            *(_OWORD *)uint64_t v10 = *(_OWORD *)(v9 + 3);
            v9[8] = v9[5];
            *((unsigned char *)v9 + 47) = 0;
            *((unsigned char *)v9 + 24) = 0;
            char v11 = sub_100046FE8(&v14, (void **)v9);
            v9 -= 3;
          }
          while (v11 < 0);
          int v12 = *((char *)v9 + 71);
          int v13 = (void **)(v9 + 6);
          if (v12 < 0) {
            operator delete(*v13);
          }
          *(_OWORD *)int v13 = v14;
          void v13[2] = v15;
        }
        char v6 = v5 + 3;
        v7 += 3;
      }
      while (v5 + 3 != a2);
    }
  }
}

uint64_t sub_100902854(void **a1, void **a2, void *a3)
{
  char v6 = sub_100046FE8(a2, a1);
  int v7 = (char)sub_100046FE8(a3, a2);
  if (v6 < 0)
  {
    if (v7 < 0)
    {
      uint64_t v21 = a1[2];
      long long v22 = *(_OWORD *)a1;
      long long v23 = (void *)a3[2];
      *(_OWORD *)a1 = *(_OWORD *)a3;
      a1[2] = v23;
      *(_OWORD *)a3 = v22;
      a3[2] = v21;
    }
    else
    {
      uint64_t v9 = a1[2];
      long long v10 = *(_OWORD *)a1;
      char v11 = a2[2];
      *(_OWORD *)a1 = *(_OWORD *)a2;
      a1[2] = v11;
      *(_OWORD *)a2 = v10;
      a2[2] = v9;
      if ((sub_100046FE8(a3, a2) & 0x80) != 0)
      {
        int v12 = a2[2];
        long long v13 = *(_OWORD *)a2;
        long long v14 = (void *)a3[2];
        *(_OWORD *)a2 = *(_OWORD *)a3;
        a2[2] = v14;
        *(_OWORD *)a3 = v13;
        a3[2] = v12;
        return 2;
      }
    }
  }
  else
  {
    if ((v7 & 0x80000000) == 0) {
      return 0;
    }
    long long v15 = a2[2];
    long long v16 = *(_OWORD *)a2;
    uint64_t v17 = (void *)a3[2];
    *(_OWORD *)a2 = *(_OWORD *)a3;
    a2[2] = v17;
    *(_OWORD *)a3 = v16;
    a3[2] = v15;
    if ((sub_100046FE8(a2, a1) & 0x80) != 0)
    {
      uint64_t v18 = a1[2];
      long long v19 = *(_OWORD *)a1;
      long long v20 = a2[2];
      *(_OWORD *)a1 = *(_OWORD *)a2;
      a1[2] = v20;
      *(_OWORD *)a2 = v19;
      a2[2] = v18;
      return 2;
    }
  }
  return 1;
}

void **sub_100902990(void **a1, unint64_t a2)
{
  unint64_t v2 = a2;
  long long v14 = *(_OWORD *)a1;
  long long v15 = a1[2];
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  if ((sub_100046FE8(&v14, (void **)(a2 - 24)) & 0x80) != 0)
  {
    char v5 = a1;
    do
      v5 += 3;
    while ((sub_100046FE8(&v14, v5) & 0x80) == 0);
  }
  else
  {
    uint64_t v4 = a1 + 3;
    do
    {
      char v5 = v4;
      if ((unint64_t)v4 >= v2) {
        break;
      }
      char v6 = sub_100046FE8(&v14, v4);
      uint64_t v4 = v5 + 3;
    }
    while ((v6 & 0x80) == 0);
  }
  if ((unint64_t)v5 < v2)
  {
    do
      v2 -= 24;
    while ((sub_100046FE8(&v14, (void **)v2) & 0x80) != 0);
  }
  while ((unint64_t)v5 < v2)
  {
    long long v7 = *(_OWORD *)v5;
    uint64_t v17 = v5[2];
    long long v16 = v7;
    long long v8 = *(_OWORD *)v2;
    void v5[2] = *(void **)(v2 + 16);
    *(_OWORD *)char v5 = v8;
    long long v9 = v16;
    *(void *)(v2 + 16) = v17;
    *(_OWORD *)unint64_t v2 = v9;
    do
      v5 += 3;
    while ((sub_100046FE8(&v14, v5) & 0x80) == 0);
    do
      v2 -= 24;
    while ((sub_100046FE8(&v14, (void **)v2) & 0x80) != 0);
  }
  long long v10 = v5 - 3;
  if (v5 - 3 == a1)
  {
    if (*((char *)v5 - 1) < 0) {
      operator delete(*a1);
    }
  }
  else
  {
    if (*((char *)a1 + 23) < 0) {
      operator delete(*a1);
    }
    long long v11 = *(_OWORD *)v10;
    a1[2] = *(v5 - 1);
    *(_OWORD *)a1 = v11;
    *((unsigned char *)v5 - 1) = 0;
    *((unsigned char *)v5 - 24) = 0;
  }
  long long v12 = v14;
  *(v5 - 1) = v15;
  *(_OWORD *)long long v10 = v12;
  return v5;
}

void *sub_100902B08(long long *a1, void *a2)
{
  uint64_t v4 = 0;
  long long v15 = *a1;
  uint64_t v16 = *((void *)a1 + 2);
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  *(void *)a1 = 0;
  do
    v4 += 24;
  while ((sub_100046FE8((long long *)((char *)a1 + v4), (void **)&v15) & 0x80) != 0);
  unint64_t v5 = (unint64_t)a1 + v4;
  if (v4 == 24)
  {
    do
    {
      if (v5 >= (unint64_t)a2) {
        break;
      }
      a2 -= 3;
    }
    while ((sub_100046FE8(a2, (void **)&v15) & 0x80) == 0);
  }
  else
  {
    do
      a2 -= 3;
    while ((sub_100046FE8(a2, (void **)&v15) & 0x80) == 0);
  }
  if (v5 >= (unint64_t)a2)
  {
    long long v7 = (void *)((char *)a1 + v4);
  }
  else
  {
    char v6 = a2;
    long long v7 = (void *)((char *)a1 + v4);
    do
    {
      long long v17 = *(_OWORD *)v7;
      long long v8 = v17;
      uint64_t v18 = v7[2];
      uint64_t v9 = v18;
      uint64_t v10 = v6[2];
      *(_OWORD *)long long v7 = *(_OWORD *)v6;
      xpc_object_t v7[2] = v10;
      v6[2] = v9;
      *(_OWORD *)char v6 = v8;
      do
        v7 += 3;
      while ((sub_100046FE8(v7, (void **)&v15) & 0x80) != 0);
      do
        v6 -= 3;
      while ((sub_100046FE8(v6, (void **)&v15) & 0x80) == 0);
    }
    while (v7 < v6);
  }
  long long v11 = (long long *)(v7 - 3);
  if (v7 - 3 == (void *)a1)
  {
    if (*((char *)v7 - 1) < 0) {
      operator delete(*(void **)a1);
    }
  }
  else
  {
    if (*((char *)a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    long long v12 = *v11;
    *((void *)a1 + 2) = *(v7 - 1);
    *a1 = v12;
    *((unsigned char *)v7 - 1) = 0;
    *((unsigned char *)v7 - 24) = 0;
  }
  long long v13 = v15;
  *(v7 - 1) = v16;
  long long *v11 = v13;
  return v7 - 3;
}

BOOL sub_100902C88(uint64_t a1, void **a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      char v6 = a2 - 3;
      if ((sub_100046FE8(a2 - 3, (void **)a1) & 0x80) != 0)
      {
        long long v7 = *(void **)(a1 + 16);
        long long v8 = *(_OWORD *)a1;
        uint64_t v9 = v6[2];
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(void *)(a1 + 16) = v9;
        *(_OWORD *)char v6 = v8;
        v6[2] = v7;
      }
      return 1;
    case 3uLL:
      sub_100902854((void **)a1, (void **)(a1 + 24), a2 - 3);
      return 1;
    case 4uLL:
      sub_100902EC4(a1, (void **)(a1 + 24), (void **)(a1 + 48), a2 - 3);
      return 1;
    case 5uLL:
      sub_100902F98(a1, (void **)(a1 + 24), (void **)(a1 + 48), (void **)(a1 + 72), a2 - 3);
      return 1;
    default:
      uint64_t v10 = (void **)(a1 + 48);
      sub_100902854((void **)a1, (void **)(a1 + 24), (void *)(a1 + 48));
      long long v11 = (void **)(a1 + 72);
      if ((void **)(a1 + 72) == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if ((sub_100046FE8(v11, v10) & 0x80) != 0)
    {
      long long v20 = *(_OWORD *)v11;
      uint64_t v21 = v11[2];
      v11[1] = 0;
      void v11[2] = 0;
      long long *v11 = 0;
      uint64_t v14 = v12;
      do
      {
        uint64_t v15 = a1 + v14;
        uint64_t v16 = (void **)(a1 + v14 + 72);
        if (*(char *)(a1 + v14 + 95) < 0) {
          operator delete(*v16);
        }
        *(_OWORD *)uint64_t v16 = *(_OWORD *)(v15 + 48);
        *(void *)(a1 + v14 + 88) = *(void *)(v15 + 64);
        *(unsigned char *)(v15 + 71) = 0;
        *(unsigned char *)(v15 + 48) = 0;
        if (v14 == -48)
        {
          uint64_t v19 = a1;
          goto LABEL_15;
        }
        char v17 = sub_100046FE8(&v20, (void **)(a1 + v14 + 24));
        v14 -= 24;
      }
      while (v17 < 0);
      int v18 = *(char *)(a1 + v14 + 95);
      uint64_t v19 = a1 + v14 + 72;
      if (v18 < 0) {
        operator delete(*(void **)v19);
      }
LABEL_15:
      *(_OWORD *)uint64_t v19 = v20;
      *(void *)(v19 + 16) = v21;
      if (++v13 == 8) {
        return v11 + 3 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 24;
    v11 += 3;
    if (v11 == a2) {
      return 1;
    }
  }
}

__n128 sub_100902EC4(uint64_t a1, void **a2, void **a3, void *a4)
{
  sub_100902854((void **)a1, a2, a3);
  if ((sub_100046FE8(a4, a3) & 0x80) != 0)
  {
    uint64_t v9 = a3[2];
    long long v10 = *(_OWORD *)a3;
    long long v11 = (void *)a4[2];
    *(_OWORD *)a3 = *(_OWORD *)a4;
    a3[2] = v11;
    *(_OWORD *)a4 = v10;
    a4[2] = v9;
    if ((sub_100046FE8(a3, a2) & 0x80) != 0)
    {
      uint64_t v12 = a2[2];
      long long v13 = *(_OWORD *)a2;
      uint64_t v14 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v14;
      *(_OWORD *)a3 = v13;
      a3[2] = v12;
      if ((sub_100046FE8(a2, (void **)a1) & 0x80) != 0)
      {
        uint64_t v15 = *(void **)(a1 + 16);
        __n128 result = *(__n128 *)a1;
        uint64_t v16 = a2[2];
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = v16;
        *(__n128 *)a2 = result;
        a2[2] = v15;
      }
    }
  }
  return result;
}

__n128 sub_100902F98(uint64_t a1, void **a2, void **a3, void **a4, void *a5)
{
  sub_100902EC4(a1, a2, a3, a4);
  if ((sub_100046FE8(a5, a4) & 0x80) != 0)
  {
    long long v11 = a4[2];
    long long v12 = *(_OWORD *)a4;
    long long v13 = (void *)a5[2];
    *(_OWORD *)a4 = *(_OWORD *)a5;
    a4[2] = v13;
    *(_OWORD *)a5 = v12;
    a5[2] = v11;
    if ((sub_100046FE8(a4, a3) & 0x80) != 0)
    {
      uint64_t v14 = a3[2];
      long long v15 = *(_OWORD *)a3;
      uint64_t v16 = a4[2];
      *(_OWORD *)a3 = *(_OWORD *)a4;
      a3[2] = v16;
      *(_OWORD *)a4 = v15;
      a4[2] = v14;
      if ((sub_100046FE8(a3, a2) & 0x80) != 0)
      {
        char v17 = a2[2];
        long long v18 = *(_OWORD *)a2;
        uint64_t v19 = a3[2];
        *(_OWORD *)a2 = *(_OWORD *)a3;
        a2[2] = v19;
        *(_OWORD *)a3 = v18;
        a3[2] = v17;
        if ((sub_100046FE8(a2, (void **)a1) & 0x80) != 0)
        {
          long long v20 = *(void **)(a1 + 16);
          __n128 result = *(__n128 *)a1;
          uint64_t v21 = a2[2];
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(void *)(a1 + 16) = v21;
          *(__n128 *)a2 = result;
          a2[2] = v20;
        }
      }
    }
  }
  return result;
}

void *sub_1009030A8(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if ((void *)a1 != a2)
  {
    uint64_t v8 = (uint64_t)a2 - a1;
    uint64_t v9 = ((uint64_t)a2 - a1) / 24;
    if ((uint64_t)a2 - a1 >= 25)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      long long v12 = (__n128 *)(a1 + 24 * v10);
      do
      {
        sub_1009032F0(a1, a4, v9, v12);
        long long v12 = (__n128 *)((char *)v12 - 24);
        --v11;
      }
      while (v11);
    }
    long long v13 = a2;
    if (a2 != a3)
    {
      uint64_t v14 = a2;
      do
      {
        if ((sub_100046FE8(v14, (void **)a1) & 0x80) != 0)
        {
          uint64_t v15 = v14[2];
          long long v16 = *(_OWORD *)v14;
          uint64_t v17 = *(void *)(a1 + 16);
          *(_OWORD *)uint64_t v14 = *(_OWORD *)a1;
          v14[2] = v17;
          *(_OWORD *)a1 = v16;
          *(void *)(a1 + 16) = v15;
          sub_1009032F0(a1, a4, v9, (__n128 *)a1);
        }
        v14 += 3;
      }
      while (v14 != a3);
      long long v13 = a3;
    }
    if (v8 >= 25)
    {
      int64_t v18 = v8 / 0x18uLL;
      uint64_t v19 = a2 - 3;
      do
      {
        uint64_t v20 = *(void *)a1;
        *(void *)long long v28 = *(void *)(a1 + 8);
        *(void *)&v28[7] = *(void *)(a1 + 15);
        char v21 = *(unsigned char *)(a1 + 23);
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = 0;
        *(void *)a1 = 0;
        uint64_t v22 = sub_100903480(a1, a4, v18);
        uint64_t v23 = v22;
        int v24 = *(char *)(v22 + 23);
        if (v19 == (void *)v22)
        {
          if (v24 < 0) {
            operator delete(*(void **)v22);
          }
          *(void *)uint64_t v23 = v20;
          *(void *)(v23 + 8) = *(void *)v28;
          *(void *)(v23 + 15) = *(void *)&v28[7];
          *(unsigned char *)(v23 + 23) = v21;
        }
        else
        {
          if (v24 < 0) {
            operator delete(*(void **)v22);
          }
          long long v25 = *(_OWORD *)v19;
          *(void *)(v23 + 16) = v19[2];
          *(_OWORD *)uint64_t v23 = v25;
          void *v19 = v20;
          v19[1] = *(void *)v28;
          *(void *)((char *)v19 + 15) = *(void *)&v28[7];
          *((unsigned char *)v19 + 23) = v21;
          sub_100903550(a1, v23 + 24, a4, 0xAAAAAAAAAAAAAAABLL * ((v23 + 24 - a1) >> 3));
        }
        v19 -= 3;
      }
      while (v18-- > 2);
    }
    return v13;
  }
  return a3;
}

void sub_1009032D8(_Unwind_Exception *exception_object)
{
  if (v2 < 0) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1009032F0(uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v21 = v4;
    uint64_t v22 = v5;
    long long v7 = a4;
    uint64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * (((uint64_t)a4 - a1) >> 3)))
    {
      uint64_t v11 = (0x5555555555555556 * (((uint64_t)a4 - a1) >> 3)) | 1;
      uint64_t v12 = a1 + 24 * v11;
      uint64_t v13 = 0x5555555555555556 * (((uint64_t)a4 - a1) >> 3) + 2;
      if (v13 < a3 && (sub_100046FE8((void *)(a1 + 24 * v11), (void **)(v12 + 24)) & 0x80u) != 0)
      {
        v12 += 24;
        uint64_t v11 = v13;
      }
      if ((sub_100046FE8((void *)v12, (void **)v7) & 0x80) == 0)
      {
        __n128 v19 = *v7;
        unint64_t v20 = v7[1].n128_u64[0];
        v7->n128_u64[1] = 0;
        v7[1].n128_u64[0] = 0;
        v7->n128_u64[0] = 0;
        while (1)
        {
          uint64_t v15 = (__n128 *)v12;
          if (v7[1].n128_i8[7] < 0) {
            operator delete((void *)v7->n128_u64[0]);
          }
          __n128 v16 = *(__n128 *)v12;
          v7[1].n128_u64[0] = *(void *)(v12 + 16);
          *long long v7 = v16;
          *(unsigned char *)(v12 + 23) = 0;
          *(unsigned char *)uint64_t v12 = 0;
          if (v9 < v11) {
            break;
          }
          uint64_t v17 = (2 * v11) | 1;
          uint64_t v12 = a1 + 24 * v17;
          uint64_t v18 = 2 * v11 + 2;
          if (v18 < a3 && (sub_100046FE8((void *)(a1 + 24 * v17), (void **)(v12 + 24)) & 0x80u) != 0)
          {
            v12 += 24;
            uint64_t v17 = v18;
          }
          long long v7 = v15;
          uint64_t v11 = v17;
          if ((sub_100046FE8((void *)v12, (void **)&v19) & 0x80) != 0)
          {
            if (v15[1].n128_i8[7] < 0) {
              operator delete((void *)v15->n128_u64[0]);
            }
            break;
          }
        }
        __n128 result = v19;
        v15[1].n128_u64[0] = v20;
        __n128 *v15 = result;
      }
    }
  }
  return result;
}

uint64_t sub_100903480(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = 0;
  uint64_t v6 = a3 - 2;
  if (a3 < 2) {
    uint64_t v6 = a3 - 1;
  }
  uint64_t v7 = v6 >> 1;
  do
  {
    uint64_t v8 = a1 + 24 * v5 + 24;
    uint64_t v9 = 2 * v5;
    uint64_t v5 = (2 * v5) | 1;
    uint64_t v10 = v9 + 2;
    if (v9 + 2 < a3 && (sub_100046FE8((void *)v8, (void **)(v8 + 24)) & 0x80u) != 0)
    {
      v8 += 24;
      uint64_t v5 = v10;
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    long long v11 = *(_OWORD *)v8;
    *(void *)(a1 + 16) = *(void *)(v8 + 16);
    *(_OWORD *)a1 = v11;
    *(unsigned char *)(v8 + 23) = 0;
    *(unsigned char *)uint64_t v8 = 0;
    a1 = v8;
  }
  while (v5 <= v7);
  return v8;
}

double sub_100903550(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    uint64_t v15 = v4;
    uint64_t v16 = v5;
    unint64_t v7 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v8 = (long long *)(a1 + 24 * v7);
    uint64_t v9 = (long long *)(a2 - 24);
    if ((sub_100046FE8(v8, (void **)(a2 - 24)) & 0x80) != 0)
    {
      long long v13 = *v9;
      uint64_t v14 = *((void *)v9 + 2);
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = 0;
      *(void *)uint64_t v9 = 0;
      while (1)
      {
        long long v11 = v8;
        if (*((char *)v9 + 23) < 0) {
          operator delete(*(void **)v9);
        }
        long long v12 = *v8;
        *((void *)v9 + 2) = *((void *)v8 + 2);
        long long *v9 = v12;
        *((unsigned char *)v8 + 23) = 0;
        *(unsigned char *)uint64_t v8 = 0;
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (long long *)(a1 + 24 * v7);
        uint64_t v9 = v11;
        if ((sub_100046FE8(v8, (void **)&v13) & 0x80) == 0)
        {
          if (*((char *)v11 + 23) < 0) {
            operator delete(*(void **)v11);
          }
          break;
        }
      }
      double result = *(double *)&v13;
      long long *v11 = v13;
      *((void *)v11 + 2) = v14;
    }
  }
  return result;
}

void sub_100903644(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10090367C(uint64_t a1)
{
}

uint64_t sub_100903698(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1009036DC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100903708(ServiceManager::Service *this)
{
  *(void *)this = off_101A191B8;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100903764(ServiceManager::Service *this)
{
  *(void *)this = off_101A191B8;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1009037D4@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SubscriberSimController");
}

_WORD *sub_1009037E4@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v2 = operator new(2uLL);
  *a1 = v2;
  *int v2 = 768;
  double result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100903824(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1008F2044(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1008F2044(v4, 0);
}

uint64_t sub_1009038A8()
{
  return 0;
}

uint64_t sub_1009038B0()
{
  return 1;
}

uint64_t sub_1009038B8()
{
  return 0;
}

void sub_1009038C4(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

void sub_1009039A0(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group, this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(v3 + 8));
  operator new();
}

uint64_t *sub_100903ACC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10005DF6C(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100903B0C(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100903B24(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 >> 6];
    unint64_t v7 = (char *)*v6 + 64 * (v5 & 0x3F);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v5) >> 3) & 0x1FFFFFFFFFFFFFF8))
       + 64 * ((*(void *)(a1 + 40) + v5) & 0x3F);
    if (v7 != (char *)v8)
    {
      do
      {
        sub_100273F20((void *)v7 + 4);
        sub_10026CF54((uint64_t)(v7 + 8), *((void **)v7 + 2));
        v7 += 64;
        if (v7 - (unsigned char *)*v6 == 4096)
        {
          uint64_t v9 = (char *)v6[1];
          ++v6;
          unint64_t v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  *uint64_t v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 32;
    goto LABEL_14;
  }
  if (v11 == 2)
  {
    uint64_t v12 = 64;
LABEL_14:
    *(void *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      long long v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *sub_100903C88(unsigned char **a1)
{
  uint64_t v1 = *a1;
  unint64_t v10 = a1;
  unint64_t v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v13 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down subscriber service %s", buf, 0xCu);
  }
  if (v1[8] == 3)
  {
    ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 80));
    (*(void (**)(void))(**(void **)(v2 + 104) + 64))(*(void *)(v2 + 104));
  }
  else if (!v1[8])
  {
    uint64_t v4 = *(uint64_t **)(v2 + 168);
    for (unint64_t i = *(uint64_t **)(v2 + 176); v4 != i; v4 += 2)
    {
      uint64_t v6 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Clearing PIN cache upon shutdown", buf, 2u);
      }
      sub_1013B9E6C(*v4);
      uint64_t v7 = *(void *)(v2 + 152);
      if (v7) {
        (*(void (**)(uint64_t, void))(*(void *)v7 + 40))(v7, *(unsigned int *)(*v4 + 36));
      }
    }
  }
  uint64_t v8 = *(void *)(v2 + 136);
  if (v8) {
    (*(void (**)(uint64_t, void))(*(void *)v8 + 24))(v8, v1[8]);
  }
  sub_100113010((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100903E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100903E88(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v36 = a1;
  char v37 = v1;
  uint64_t v2 = *v1;
  sub_10003E168(&v42, (void *)(*v1 + 8));
  uint64_t v3 = (std::__shared_weak_count *)operator new(0x30uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)off_101A19238;
  uint64_t v4 = &v3[1].__vftable;
  uint64_t v6 = v42;
  unint64_t v5 = v43;
  uint64_t v42 = 0;
  char v43 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A19330;
  v3[1].__shared_owners_ = v6;
  v3[1].__shared_weak_owners_ = (uint64_t)v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v5);
    uint64_t v7 = v43;
    *uint64_t v4 = off_101A19288;
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
  else
  {
    *uint64_t v4 = off_101A19288;
  }
  char v40 = v3 + 1;
  uint64_t v41 = v3;
  atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  subscriber::SimCommandDriver::setDelegate();
  if (v3) {
    sub_10004D2C8(v3);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(v2 + 64));
  unint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  dispatch_group_t group = (dispatch_group_t)v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&group);
  if (v15)
  {
    uint64_t v17 = v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v16 = 0;
LABEL_15:
  uint64_t v18 = *(std::__shared_weak_count **)(v2 + 160);
  *(void *)(v2 + 152) = v17;
  *(void *)(v2 + 160) = v16;
  if (v18) {
    sub_10004D2C8(v18);
  }
  Registry::createRestModuleOneTimeUseConnection(&v38, *(Registry **)(v2 + 64));
  ctu::RestModule::connect();
  if (v39) {
    sub_10004D2C8(v39);
  }
  dispatch_group_t group = (dispatch_group_t)off_101A193A8;
  uint64_t v45 = v2 + 80;
  p_dispatch_group_t group = &group;
  sub_100905CC8(&group, (void *)(v2 + 192));
  sub_1008FD664(&group);
  uint64_t v19 = *(void *)(v2 + 216);
  if (v19) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v19 + 48))(v19, v2 + 224);
  }
  dispatch_group_t group = (dispatch_group_t)off_101A19438;
  uint64_t v45 = v2 + 80;
  p_dispatch_group_t group = &group;
  sub_100905CC8(&group, (void *)(v2 + 248));
  sub_1008FD664(&group);
  uint64_t v20 = *(void *)(v2 + 272);
  if (v20) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 48))(v20, v2 + 280);
  }
  uint64_t v21 = (dispatch_group_t *)(v2 + 304);
  dispatch_group_t group = (dispatch_group_t)off_101A194B8;
  uint64_t v45 = v2 + 80;
  p_dispatch_group_t group = &group;
  if (&group != (dispatch_group_t *)(v2 + 304))
  {
    uint64_t v22 = *(dispatch_group_t **)(v2 + 328);
    if (v22 == v21)
    {
      __p[1] = (void *)(v2 + 80);
      uint64_t v48 = 0;
      p_dispatch_group_t group = 0;
      __p[0] = off_101A194B8;
      ((void (*)(uint64_t, dispatch_group_t *))(*v21)[3].isa)(v2 + 304, &group);
      (*(void (**)(void))(**(void **)(v2 + 328) + 32))(*(void *)(v2 + 328));
      *(void *)(v2 + 328) = 0;
      p_dispatch_group_t group = &group;
      (*((void (**)(void **, uint64_t))__p[0] + 3))(__p, v2 + 304);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      *(void *)(v2 + 304) = off_101A194B8;
      *(void *)(v2 + 312) = v2 + 80;
      p_dispatch_group_t group = v22;
    }
    *(void *)(v2 + 328) = v21;
  }
  sub_1008FD5E0(&group);
  uint64_t v23 = *(void *)(v2 + 328);
  if (v23) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 48))(v23, v2 + 336);
  }
  dispatch_group_t group = (dispatch_group_t)off_101A19548;
  uint64_t v45 = v2 + 80;
  p_dispatch_group_t group = &group;
  sub_10041CA0C(&group, (void *)(v2 + 360));
  sub_10041A760(&group);
  uint64_t v24 = *(void *)(v2 + 384);
  if (v24) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v24 + 48))(v24, v2 + 392);
  }
  sub_1002DA10C(v2 + 416);
  sub_100722258(v2 + 464);
  sub_1005FE9F4(v2 + 496);
  sub_100058DB0(__p, "/cc/device_info/mins");
  dispatch_group_t group = (dispatch_group_t)off_101A19058;
  uint64_t v45 = v2 + 520;
  p_dispatch_group_t group = &group;
  ctu::RestModule::observeProperty();
  sub_10003F600(&group);
  if (SHIBYTE(v48) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/device_info/prl_versions");
  dispatch_group_t group = (dispatch_group_t)off_101A190D8;
  uint64_t v45 = v2 + 544;
  p_dispatch_group_t group = &group;
  ctu::RestModule::observeProperty();
  sub_10003F600(&group);
  if (SHIBYTE(v48) < 0) {
    operator delete(__p[0]);
  }
  sub_1008F26E0(v2 + 568);
  dispatch_group_t group = (dispatch_group_t)off_101A19648;
  uint64_t v45 = v2 + 80;
  p_dispatch_group_t group = &group;
  sub_10041CA0C(&group, (void *)(v2 + 616));
  sub_10041A760(&group);
  uint64_t v25 = *(void *)(v2 + 640);
  if (v25) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v25 + 48))(v25, v2 + 648);
  }
  dispatch_group_t group = (dispatch_group_t)off_101A196C8;
  uint64_t v45 = v2 + 80;
  p_dispatch_group_t group = &group;
  sub_10008C3B4(&group, (void *)(v2 + 672));
  sub_1000882E8(&group);
  uint64_t v26 = *(void *)(v2 + 696);
  if (v26) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v26 + 48))(v26, v2 + 704);
  }
  sub_10047326C(v2 + 440);
  long long v28 = (capabilities::ct *)capabilities::ct::supportsGemini(v27);
  if ((v28 & 1) != 0 || capabilities::ct::supportsDynamicSID(v28))
  {
    sub_100058DB0(__p, "/cc/props/subscription_configuration");
    long long v29 = (dispatch_group_t *)operator new(0x28uLL);
    *long long v29 = (dispatch_group_t)off_101A19748;
    v29[1] = (dispatch_group_t)(v2 + 444);
    void v29[2] = (dispatch_group_t)v2;
    v29[3] = (dispatch_group_t)sub_1008F27C0;
    _DWORD v29[4] = 0;
    p_dispatch_group_t group = v29;
    ctu::RestModule::observeProperty();
    sub_10003F600(&group);
    if (SHIBYTE(v48) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1001067E0(v2 + 808);
  sub_1008F2A18(v2 + 456);
  sub_100058DB0(__p, "/cc/prefs-nb/activation_gemini_support");
  dispatch_group_t group = (dispatch_group_t)off_101A19848;
  uint64_t v45 = v2 + 832;
  p_dispatch_group_t group = &group;
  ctu::RestModule::observeProperty();
  sub_10003F600(&group);
  if (SHIBYTE(v48) < 0) {
    operator delete(__p[0]);
  }
  sub_10071A3EC(v2 + 840);
  sub_1008F2AF8(v2 + 864);
  sub_100058DB0(__p, "/cc/events/dump_state");
  int v30 = (dispatch_group_t *)operator new(0x20uLL);
  *int v30 = (dispatch_group_t)off_101A19948;
  v30[1] = (dispatch_group_t)v2;
  v30[2] = (dispatch_group_t)sub_1008F2BD8;
  v30[3] = 0;
  p_dispatch_group_t group = v30;
  ctu::RestModule::observeEvent();
  sub_10003F600(&group);
  if (SHIBYTE(v48) < 0) {
    operator delete(__p[0]);
  }
  sub_10004D2C8(v3);
  int v31 = *(subscriber::SimCommandDriver **)(v2 + 104);
  unint64_t v32 = v1[1];
  dispatch_group_t group = v32;
  if (v32)
  {
    dispatch_retain(v32);
    dispatch_group_enter(v32);
  }
  v33.var0.fObj = (dispatch_object_s *)&group;
  subscriber::SimCommandDriver::bootstrap(v31, v33);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  uint64_t v34 = *(void *)(v2 + 136);
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 16))(v34);
  }
  sub_100088C88((uint64_t *)&v37);
  return sub_100046B58((uint64_t *)&v36);
}

void sub_100904738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, dispatch_group_t group, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100904830(uint64_t **a1)
{
  uint64_t v1 = **a1;
  (*(void (**)(void))(**(void **)(v1 + 104) + 56))(*(void *)(v1 + 104));
  sub_1008A2DF8(v1);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(v1 + 64));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unint64_t v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    uint64_t v13 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not initialize analytics metrics.", buf, 2u);
    }
    goto LABEL_31;
  }
LABEL_11:
  sub_10003E168(buf, (void *)(v1 + 8));
  uint64_t v15 = *(void *)buf;
  unsigned int v14 = (std::__shared_weak_count *)v22;
  if (v22)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v14);
  }
  uint64_t v16 = *(NSObject **)(v1 + 24);
  if (v16) {
    dispatch_retain(*(dispatch_object_t *)(v1 + 24));
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1008FBAD0;
  aBlock[3] = &unk_101A18F50;
  aBlock[4] = v1;
  if (v16)
  {
    uint64_t v17 = _Block_copy(aBlock);
    uint64_t v18 = v17;
    dispatch_object_t v28 = v16;
    *(void *)std::string buf = _NSConcreteStackBlock;
    uint64_t v22 = 1174405120;
    uint64_t v23 = sub_100916320;
    uint64_t v24 = &unk_101A1A518;
    uint64_t v25 = v15;
    uint64_t v26 = v14;
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    if (v17) {
      uint64_t v19 = _Block_copy(v17);
    }
    else {
      uint64_t v19 = 0;
    }
    long long v27 = v19;
    (*(void (**)(uint64_t, const char *, uint64_t, dispatch_object_t *, uint8_t *))(*(void *)v11 + 40))(v11, "commCenterFullSimInfo", 1, &v28, buf);
    if (v28) {
      dispatch_release(v28);
    }
    if (v27) {
      _Block_release(v27);
    }
    if (v26) {
      std::__shared_weak_count::__release_weak(v26);
    }
    if (v18) {
      _Block_release(v18);
    }
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
LABEL_31:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  operator delete();
}

void sub_100904B38(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a20) {
    std::__shared_weak_count::__release_weak(a20);
  }
  uint64_t v26 = *(NSObject **)(v25 - 72);
  if (v26) {
    dispatch_release(v26);
  }
  if (v23) {
    _Block_release(v23);
  }
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  operator delete();
}

void sub_100904BCC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A19238;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100904BEC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A19238;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100904C40(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100904C68(SubscriberSimCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A19330;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  SubscriberSimCommandDriverDelegateInterface::~SubscriberSimCommandDriverDelegateInterface(this);
}

void sub_100904CC4(SubscriberSimCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A19330;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  SubscriberSimCommandDriverDelegateInterface::~SubscriberSimCommandDriverDelegateInterface(this);

  operator delete();
}

void sub_100904D34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      unint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 320))(v11, a2, a3, a4);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_100904DEC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100904E00(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        memset(v8, 0, sizeof(v8));
        sub_1009057C8(v8, *a2, a2[1], 0x8E38E38E38E38E39 * (((char *)a2[1] - (char *)*a2) >> 4));
        (*(void (**)(uint64_t, void *))(*(void *)v7 + 328))(v7, v8);
        uint64_t v9 = (void **)v8;
        sub_1008FDCDC(&v9);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100904ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1008FDCDC((void ***)va);
  sub_10004D2C8(v4);
  _Unwind_Resume(a1);
}

void sub_100904EF4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 344))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100904F90(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100904FA4(uint64_t a1, uint64_t a2, long long *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unsigned int v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        sub_1000593FC((uint64_t)__p, a3);
        (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v9 + 336))(v9, a2, __p);
        if (v12)
        {
          if (v11 < 0) {
            operator delete(__p[0]);
          }
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10090505C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100905090(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned int v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    uint64_t v15 = std::__shared_weak_count::lock(v8);
    if (v15)
    {
      uint64_t v16 = v15;
      uint64_t v17 = *(void *)(a1 + 8);
      if (v17) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 352))(v17, a2, a3, a4, a5, a6, a7);
      }
      sub_10004D2C8(v16);
    }
  }
}

void sub_10090516C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100905180(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned int v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    uint64_t v15 = std::__shared_weak_count::lock(v8);
    if (v15)
    {
      uint64_t v16 = v15;
      uint64_t v17 = *(void *)(a1 + 8);
      if (v17) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 360))(v17, a2, a3, a4, a5, a6, a7);
      }
      sub_10004D2C8(v16);
    }
  }
}

void sub_10090525C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100905270(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned int v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    uint64_t v15 = std::__shared_weak_count::lock(v8);
    if (v15)
    {
      uint64_t v16 = v15;
      uint64_t v17 = *(void *)(a1 + 8);
      if (v17) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 368))(v17, a2, a3, a4, a5, a6, a7);
      }
      sub_10004D2C8(v16);
    }
  }
}

void sub_10090534C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100905360(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      unint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 376))(v11, a2, a3, a4);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_100905418(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10090542C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      unint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        uint64_t v12 = *a3;
        int v13 = *((_DWORD *)a3 + 2);
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        long long __p = 0;
        sub_1008FDDC8(&__p, (const void *)a3[2], a3[3], (a3[3] - a3[2]) >> 2);
        __int16 v17 = *((_WORD *)a3 + 20);
        sub_10090994C((uint64_t)v18, a4);
        (*(void (**)(uint64_t, uint64_t, uint64_t *, void *))(*(void *)v11 + 384))(v11, a2, &v12, v18);
        sub_1008FDE68(v18);
        if (__p)
        {
          uint64_t v15 = __p;
          operator delete(__p);
        }
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_100905558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  sub_1008FDE68(&a16);
  if (__p) {
    operator delete(__p);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_100905594(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unsigned int v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 392))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100905638(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10090564C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 400))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1009056E8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1009056FC(SubscriberSimCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A19330;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  SubscriberSimCommandDriverDelegateInterface::~SubscriberSimCommandDriverDelegateInterface(this);
}

void sub_100905758(SubscriberSimCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A19330;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  SubscriberSimCommandDriverDelegateInterface::~SubscriberSimCommandDriverDelegateInterface(this);

  operator delete();
}

unsigned char *sub_1009057C8(unsigned char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x1C71C71C71C71C8) {
      sub_10006A748();
    }
    uint64_t v7 = result;
    double result = operator new(144 * a4);
    unsigned int v8 = result;
    *uint64_t v7 = result;
    v7[1] = result;
    xpc_object_t v7[2] = &result[144 * a4];
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        unint64_t v10 = &a2[v9];
        uint64_t v11 = &v8[v9 * 8];
        *(_OWORD *)uint64_t v11 = *(_OWORD *)&a2[v9];
        *(_OWORD *)(v11 + 13) = *(_OWORD *)((char *)&a2[v9 + 1] + 5);
        uint64_t v12 = (const void *)a2[v9 + 5];
        *((void *)v11 + 4) = a2[v9 + 4];
        *((void *)v11 + 6) = 0;
        *((void *)v11 + 7) = 0;
        *(void *)&v8[v9 * 8 + 40] = 0;
        sub_10005C928(&v8[v9 * 8 + 40], v12, a2[v9 + 6], a2[v9 + 6] - (void)v12);
        *((void *)v11 + 9) = 0;
        int v13 = &v8[v9 * 8 + 72];
        unsigned int v14 = (const void *)a2[v9 + 9];
        *(v13 - 1) = a2[v9 + 8];
        v13[1] = 0;
        void v13[2] = 0;
        sub_10005C928(v13, v14, v10[10], v10[10] - (void)v14);
        uint64_t v15 = &v8[v9 * 8];
        *((void *)v15 + 12) = 0;
        *((void *)v15 + 13) = 0;
        uint64_t v16 = &v8[v9 * 8 + 96];
        _OWORD v16[2] = 0;
        sub_10002E848(v16, v10[12], v10[13], 0xCCCCCCCCCCCCCCCDLL * ((v10[13] - v10[12]) >> 3));
        double result = &v8[v9 * 8 + 120];
        __int16 v17 = (void **)&a2[v9 + 15];
        if (SHIBYTE(a2[v9 + 17]) < 0)
        {
          double result = sub_10004FC84(result, *v17, a2[v9 + 16]);
        }
        else
        {
          *(_OWORD *)double result = *(_OWORD *)v17;
          *(void *)&v8[v9 * 8 + 136] = a2[v9 + 17];
        }
        v9 += 18;
      }
      while (v10 + 18 != a3);
      v8 += v9 * 8;
    }
    v7[1] = v8;
  }
  return result;
}

void sub_10090593C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1008FDCDC((void ***)va);
  _Unwind_Resume(a1);
}

void sub_1009059CC()
{
}

void *sub_1009059E0(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A193A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100905A28(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A193A8;
  a2[1] = v2;
  return result;
}

void sub_100905A54(uint64_t a1, const BasicSimInfo **a2)
{
  xpc_object_t v6 = 0;
  sub_100905B8C(&v6, a2);
  sub_100058DB0(&__p, "/cc/props/sims_on_device");
  xpc_object_t v2 = v6;
  xpc_object_t object = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100905AF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_100905B40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100905B80()
{
}

void sub_100905B8C(xpc_object_t *a1, const BasicSimInfo **a2)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  uint64_t v7 = *a2;
  xpc_object_t v6 = a2[1];
  while (v7 != v6)
  {
    write_rest_value(v7);
    xpc_array_append_value(v5, value);
    xpc_release(value);
    uint64_t v7 = (const BasicSimInfo *)((char *)v7 + 168);
  }
  *a1 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a1 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_100905C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void *sub_100905CC8(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    xpc_object_t v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        double result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        double result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      double result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100905F30(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100905F40()
{
}

void *sub_100905F54(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A19438;
  result[1] = v3;
  return result;
}

uint64_t sub_100905F9C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A19438;
  a2[1] = v2;
  return result;
}

void sub_100905FC8(uint64_t a1, const BasicSimInfo **a2)
{
  xpc_object_t v6 = 0;
  sub_100905B8C(&v6, a2);
  sub_100058DB0(&__p, "/cc/props/sims_in_use");
  xpc_object_t v2 = v6;
  xpc_object_t object = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_10090606C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_1009060B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009060F4()
{
}

void sub_100906104()
{
}

void *sub_100906118(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A194B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100906160(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A194B8;
  a2[1] = v2;
  return result;
}

void sub_10090618C(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  char v5 = a2 + 1;
  xpc_object_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v27 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v27 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v9);
        goto LABEL_16;
      }
      xpc_object_t v10 = xpc_null_create();
LABEL_15:
      xpc_object_t v27 = v10;
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v25, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v27;
      uint64_t v21 = "first";
      sub_100035E70((uint64_t)&__p, &v25, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      if (!*((unsigned char *)v6 + 64)
        || (*((char *)v6 + 63) >= 0 ? (unsigned int v14 = (const char *)(v6 + 5)) : (unsigned int v14 = (const char *)v6[5]),
            (xpc_object_t v23 = xpc_string_create(v14)) == 0))
      {
        xpc_object_t v23 = xpc_null_create();
      }
      long long __p = &v27;
      uint64_t v21 = "second";
      sub_100035E70((uint64_t)&__p, &v23, &v24);
      xpc_release(v24);
      xpc_object_t v24 = 0;
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_object_t v15 = v27;
      if (v27) {
        xpc_retain(v27);
      }
      else {
        xpc_object_t v15 = xpc_null_create();
      }
      xpc_release(v27);
      xpc_array_append_value(v4, v15);
      xpc_release(v15);
      uint64_t v16 = (void *)v6[1];
      if (v16)
      {
        do
        {
          __int16 v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          __int16 v17 = (void *)v6[2];
          BOOL v18 = *v17 == (void)v6;
          xpc_object_t v6 = v17;
        }
        while (!v18);
      }
      xpc_object_t v6 = v17;
    }
    while (v17 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v19 = v4;
  }
  else
  {
    xpc_object_t v19 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/sim_msisdn");
  xpc_object_t v27 = v19;
  if (v19) {
    xpc_retain(v19);
  }
  else {
    xpc_object_t v27 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v22 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
}

void sub_100906480(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100906544(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100906584()
{
}

void sub_100906594()
{
}

void *sub_1009065A8(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A19548;
  result[1] = v3;
  return result;
}

uint64_t sub_1009065F0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A19548;
  a2[1] = v2;
  return result;
}

void sub_10090661C(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/cdma_aux_info_ready");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_1009066C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100906704(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100906744()
{
}

void sub_100906754()
{
}

void *sub_100906768(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A195C8;
  result[1] = v3;
  return result;
}

uint64_t sub_1009067B0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A195C8;
  a2[1] = v2;
  return result;
}

void sub_1009067DC(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1009067E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100906824()
{
}

void sub_100906834()
{
}

void *sub_100906848(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A19648;
  result[1] = v3;
  return result;
}

uint64_t sub_100906890(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A19648;
  a2[1] = v2;
  return result;
}

void sub_1009068BC(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/isim_files_status");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100906960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1009069A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009069E4()
{
}

void sub_1009069F4()
{
}

void *sub_100906A08(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A196C8;
  result[1] = v3;
  return result;
}

uint64_t sub_100906A50(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A196C8;
  a2[1] = v2;
  return result;
}

void sub_100906A7C(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_10008C088(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/psi_smsc");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100906B20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100906B64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100906BA4()
{
}

void sub_100906BB4()
{
}

__n128 sub_100906BC8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A19748;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100906C1C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A19748;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100906C54(void *a1)
{
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *))a1[3];
  uint64_t v3 = a1[4];
  char v4 = (void *)(a1[2] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *))(*v4 + v2);
  }

  return v2(v4);
}

uint64_t sub_100906CD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100906D10()
{
}

void sub_100906D20()
{
}

void *sub_100906D34(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A197C8;
  result[1] = v3;
  return result;
}

uint64_t sub_100906D7C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A197C8;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_100906DA8(uint64_t a1, xpc_object_t *a2)
{
  return sub_10041DCE4((int **)(a1 + 8), a2);
}

uint64_t sub_100906DB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100906DF0()
{
}

void sub_100906E00()
{
}

void *sub_100906E14(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A19848;
  result[1] = v3;
  return result;
}

uint64_t sub_100906E5C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A19848;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_100906E88(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(int **)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int v8 = *v3;
    xpc_type_t result = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v8, (int *)a2, v5);
    int *v3 = v8;
  }
  else if (result == (xpc_type_t)&_xpc_type_BOOL {
         || result == (xpc_type_t)&_xpc_type_int64
  }
         || result == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
    int *v3 = (int)result;
  }
  return result;
}

uint64_t sub_100906F24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100906F64()
{
}

void sub_100906F74()
{
}

void *sub_100906F88(uint64_t a1)
{
  xpc_type_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A198C8;
  result[1] = v3;
  return result;
}

uint64_t sub_100906FD0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A198C8;
  a2[1] = v2;
  return result;
}

void sub_100906FFC(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100907004(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100907044()
{
}

void sub_100907054()
{
}

__n128 sub_100907068(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A19948;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1009070BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A19948;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009070F4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10090713C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10090717C()
{
}

uint64_t *sub_100907188(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v38 = a1;
  uint64_t v39 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(uint64_t **)(*(void *)v1 + 168);
  char v4 = *(uint64_t **)(*(void *)v1 + 176);
  if (v3 == v4)
  {
LABEL_5:
    if (*(void *)(v1 + 16))
    {
      uint64_t v7 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = subscriber::asString();
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#E Got SIM file update, but there is no SIM info for phy slot [%s]????", buf, 0xCu);
      }
    }
    goto LABEL_43;
  }
  int v5 = *(_DWORD *)(v1 + 12);
  while (1)
  {
    uint64_t v6 = *v3;
    if (*(_DWORD *)(*v3 + 32) == *(_DWORD *)(v1 + 8)) {
      break;
    }
    v3 += 2;
    if (v3 == v4) {
      goto LABEL_5;
    }
  }
  int v8 = (std::__shared_weak_count *)v3[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(unsigned int *)(v6 + 36);
  char v48 = 0;
  char v46 = 0;
  uint64_t v47 = 0;
  uint64_t v45 = 0;
  xpc_object_t v10 = *(char ***)(v1 + 16);
  if (v10)
  {
    int v11 = &v45;
    if (&v45 != (void **)v10)
    {
      sub_10006E4A8(&v45, *v10, v10[1], v10[1] - *v10);
      int v11 = *(void ***)(v1 + 16);
    }
    LOBYTE(v41[0]) = 0;
    char v43 = 0;
    uint64_t v44 = 0;
    long long __p = 0;
    sub_10005C928(&__p, *v11, (uint64_t)v11[1], (unsigned char *)v11[1] - (unsigned char *)*v11);
    __int16 v12 = sub_1013B8C98(v6, v5, (uint64_t)&__p);
    LOBYTE(v41[0]) = HIBYTE(v12);
    char v48 = v12;
    if (__p)
    {
      char v43 = __p;
      operator delete(__p);
    }
    int v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v9);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = subscriber::asString();
      xpc_object_t v15 = *(uint64_t **)(v1 + 16);
      uint64_t v17 = *v15;
      uint64_t v16 = v15[1];
      uint64_t v19 = printers::asString((printers *)&v48, v18);
      uint64_t v21 = printers::asString((printers *)v41, v20);
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v16 - v17;
      *(_WORD *)&unsigned char buf[22] = 2080;
      char v50 = (void *)v19;
      LOWORD(v51[0]) = 2080;
      *(void *)((char *)v51 + 2) = v21;
      char v22 = "#I Marking SIM file %s present with %lu bytes (success=%s changed=%s)";
      xpc_object_t v23 = v13;
      uint32_t v24 = 42;
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v22, buf, v24);
    }
  }
  else
  {
    __int16 v25 = sub_100D48B80((uint64_t **)(v6 + 184), v5);
    LOBYTE(__p) = HIBYTE(v25);
    char v48 = v25;
    uint64_t v26 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v9);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = subscriber::asString();
      uint64_t v29 = printers::asString((printers *)&v48, v28);
      uint64_t v31 = printers::asString((printers *)&__p, v30);
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = v27;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v29;
      *(_WORD *)&unsigned char buf[22] = 2080;
      char v50 = (void *)v31;
      char v22 = "#I Marking SIM file %s not present (success=%s changed=%s)";
      xpc_object_t v23 = v26;
      uint32_t v24 = 32;
      goto LABEL_19;
    }
  }
  if (v48 && subscriber::isSimFileEssential() && (sub_1013B86DC(v6) & 1) == 0) {
    sub_1008F77B8(v2, v32, v33);
  }
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)std::string buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = sub_1008FA63C;
  char v50 = &unk_101A18F00;
  v51[0] = v2;
  sub_1013B8A74(v6, (uint64_t)buf);
  if (v8)
  {
    sub_10004D2C8(v8);
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v41[0] = v6;
  v41[1] = v8;
  int v40 = v5;
  sub_100602B08((uint64_t)buf, &v40, 1);
  sub_1008F8304(v2, v41, buf);
  sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v36 = *(void *)(v2 + 168);
  uint64_t v35 = *(void *)(v2 + 176);
  while (v36 != v35)
  {
    if (*(_DWORD *)(*(void *)v36 + 36) == v9)
    {
      if (v36 != v35)
      {
        *(void *)std::string buf = v6;
        *(void *)&uint8_t buf[8] = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1008F8A98(v2, (uint64_t *)buf, v34);
        if (v8) {
          sub_10004D2C8(v8);
        }
      }
      break;
    }
    v36 += 16;
  }
  if (v45)
  {
    char v46 = v45;
    operator delete(v45);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
LABEL_43:
  sub_1009076B4(&v39);
  return sub_100046B58((uint64_t *)&v38);
}

void sub_100907614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22)
{
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
  sub_1009076B4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009076B4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100907708(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v85 = a1;
  uint64_t v86 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v88 = 0;
  uint64_t v89 = 0;
  uint64_t v87 = 0;
  sub_1009057C8(&v87, *(uint64_t **)(v1 + 8), *(uint64_t **)(v1 + 16), 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(v1 + 16) - *(void *)(v1 + 8)) >> 4));
  uint64_t v6 = v87;
  uint64_t v5 = v88;
  if (v87 == v88)
  {
    uint64_t v42 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Received empty Sim list", buf, 2u);
      uint64_t v42 = *(NSObject **)(v2 + 40);
    }
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Resetting SIM information due to BB reset/loss of information", buf, 2u);
    }
    int64x2_t v106 = 0uLL;
    char v107 = 0;
    char v46 = *(uint64_t **)(v2 + 168);
    uint64_t v45 = *(uint64_t **)(v2 + 176);
    if (v46 != v45)
    {
      uint64_t v83 = *(uint64_t **)(v2 + 176);
      do
      {
        sub_1013B8E08(*v46, v44, (uint64_t)buf);
        uint64_t v47 = v106.i64[1];
        if (v106.i64[1] >= (unint64_t)v107)
        {
          unint64_t v53 = 0xCF3CF3CF3CF3CF3DLL * ((v106.i64[1] - v106.i64[0]) >> 3);
          unint64_t v54 = v53 + 1;
          if (v53 + 1 > 0x186186186186186) {
            sub_10006A748();
          }
          if (0x9E79E79E79E79E7ALL * (((uint64_t)v107 - v106.i64[0]) >> 3) > v54) {
            unint64_t v54 = 0x9E79E79E79E79E7ALL * (((uint64_t)v107 - v106.i64[0]) >> 3);
          }
          if (0xCF3CF3CF3CF3CF3DLL * (((uint64_t)v107 - v106.i64[0]) >> 3) >= 0xC30C30C30C30C3) {
            unint64_t v55 = 0x186186186186186;
          }
          else {
            unint64_t v55 = v54;
          }
          char v111 = &v107;
          if (v55) {
            char v56 = (long long *)sub_10008A268((uint64_t)&v107, v55);
          }
          else {
            char v56 = 0;
          }
          char v57 = (_DWORD *)v56 + 42 * v53;
          char v108 = v56;
          v109.i64[0] = (uint64_t)v57;
          uint64_t v110 = (_DWORD *)v56 + 42 * v55;
          *(_OWORD *)char v57 = *(_OWORD *)buf;
          *((void *)v57 + 3) = 0;
          *((void *)v57 + 4) = 0;
          *((void *)v57 + 2) = 0;
          *((_OWORD *)v57 + 1) = *(_OWORD *)v92;
          *((void *)v57 + 4) = v93;
          v92[0] = 0;
          v92[1] = 0;
          uint64_t v93 = 0;
          *((void *)v57 + 5) = 0;
          *((void *)v57 + 6) = 0;
          *((void *)v57 + 7) = 0;
          *(_OWORD *)(v57 + 10) = v94;
          *((void *)v57 + 7) = v95;
          long long v94 = 0uLL;
          uint64_t v95 = 0;
          int v58 = v96;
          *((_WORD *)v57 + 34) = v97;
          v57[16] = v58;
          long long v59 = v98;
          *((void *)v57 + 11) = v99;
          *(_OWORD *)(v57 + 18) = v59;
          uint64_t v99 = 0;
          long long v98 = 0uLL;
          long long v60 = v100;
          *((void *)v57 + 14) = v101;
          *((_OWORD *)v57 + 6) = v60;
          uint64_t v101 = 0;
          long long v100 = 0uLL;
          long long v61 = v102;
          *((void *)v57 + 17) = v103;
          *(_OWORD *)(v57 + 30) = v61;
          long long v102 = 0uLL;
          uint64_t v103 = 0;
          long long v62 = __p;
          *((void *)v57 + 20) = v105;
          *((_OWORD *)v57 + 9) = v62;
          long long __p = 0uLL;
          uint64_t v105 = 0;
          char v63 = v57 + 42;
          v109.i64[1] = (uint64_t)(v57 + 42);
          uint64_t v65 = v106.i64[1];
          uint64_t v64 = v106.i64[0];
          uint64_t v66 = v109.i64[0];
          if (v106.i64[1] == v106.i64[0])
          {
            int64x2_t v67 = vdupq_n_s64(v106.u64[1]);
          }
          else
          {
            do
            {
              v66 -= 168;
              v65 -= 168;
              sub_10008A2B4(v66, v65);
            }
            while (v65 != v64);
            int64x2_t v67 = v106;
            char v63 = (_DWORD *)v109.i64[1];
          }
          v106.i64[0] = v66;
          v106.i64[1] = (uint64_t)v63;
          int64x2_t v109 = v67;
          char v68 = v107;
          char v107 = v110;
          uint64_t v110 = v68;
          char v108 = (long long *)v67.i64[0];
          sub_10008A370((uint64_t)&v108);
          v106.i64[1] = (uint64_t)v63;
          uint64_t v45 = v83;
          if (SHIBYTE(v105) < 0) {
            operator delete((void *)__p);
          }
        }
        else
        {
          *(_OWORD *)v106.i64[1] = *(_OWORD *)buf;
          *(void *)(v47 + 16) = 0;
          *(void *)(v47 + 24) = 0;
          *(void *)(v47 + 32) = 0;
          *(void *)(v47 + 40) = 0;
          *(_OWORD *)(v47 + 16) = *(_OWORD *)v92;
          *(void *)(v47 + 32) = v93;
          v92[0] = 0;
          v92[1] = 0;
          uint64_t v93 = 0;
          *(void *)(v47 + 48) = 0;
          *(void *)(v47 + 56) = 0;
          *(_OWORD *)(v47 + 40) = v94;
          *(void *)(v47 + 56) = v95;
          long long v94 = 0uLL;
          uint64_t v95 = 0;
          int v48 = v96;
          *(_WORD *)(v47 + 68) = v97;
          *(_DWORD *)(v47 + 64) = v48;
          long long v49 = v98;
          *(void *)(v47 + 88) = v99;
          *(_OWORD *)(v47 + 72) = v49;
          uint64_t v99 = 0;
          long long v98 = 0uLL;
          long long v50 = v100;
          *(void *)(v47 + 112) = v101;
          *(_OWORD *)(v47 + 96) = v50;
          uint64_t v101 = 0;
          long long v100 = 0uLL;
          long long v51 = v102;
          *(void *)(v47 + 136) = v103;
          *(_OWORD *)(v47 + 120) = v51;
          long long v102 = 0uLL;
          uint64_t v103 = 0;
          long long v52 = __p;
          *(void *)(v47 + 160) = v105;
          *(_OWORD *)(v47 + 144) = v52;
          long long __p = 0uLL;
          uint64_t v105 = 0;
          v106.i64[1] = v47 + 168;
        }
        if (SHIBYTE(v103) < 0) {
          operator delete((void *)v102);
        }
        if (SHIBYTE(v101) < 0) {
          operator delete((void *)v100);
        }
        if (SHIBYTE(v99) < 0) {
          operator delete((void *)v98);
        }
        char v108 = &v94;
        sub_10002E39C((void ***)&v108);
        if (v92[0])
        {
          v92[1] = v92[0];
          operator delete(v92[0]);
        }
        sub_1013B7970(*v46);
        v46 += 2;
      }
      while (v46 != v45);
    }
    sub_1008F77B8(v2, v43, v44);
    sub_1008F8114(v2, (uint64_t)&v106);
    memset(buf, 0, sizeof(buf));
    char v69 = (uint8_t *)(v2 + 392);
    v92[0] = 0;
    sub_10005DF14((uint64_t *)buf, v2 + 392);
    char v70 = *(int **)(v2 + 392);
    char v71 = (int *)(v2 + 400);
    if (v70 != (int *)(v2 + 400))
    {
      do
      {
        char v108 = (long long *)(v70 + 7);
        *((unsigned char *)sub_10005CE78((uint64_t **)buf, v70 + 7, (uint64_t)&unk_10144E20E, (_DWORD **)&v108) + 32) = 0;
        uint64_t v72 = (int *)*((void *)v70 + 1);
        if (v72)
        {
          do
          {
            char v73 = v72;
            uint64_t v72 = *(int **)v72;
          }
          while (v72);
        }
        else
        {
          do
          {
            char v73 = (int *)*((void *)v70 + 2);
            BOOL v76 = *(void *)v73 == (void)v70;
            char v70 = v73;
          }
          while (!v76);
        }
        char v70 = v73;
      }
      while (v73 != v71);
    }
    if (*(void **)(v2 + 408) == v92[0])
    {
      char v74 = *(int **)v69;
      if (*(int **)v69 == v71)
      {
LABEL_143:
        sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
        *(void *)std::string buf = &v106;
        goto LABEL_144;
      }
      char v75 = *(void **)buf;
      while (1)
      {
        BOOL v76 = v74[7] == *((_DWORD *)v75 + 7) && *((unsigned __int8 *)v74 + 32) == *((unsigned __int8 *)v75 + 32);
        if (!v76) {
          break;
        }
        uint64_t v77 = (int *)*((void *)v74 + 1);
        char v78 = v74;
        if (v77)
        {
          do
          {
            char v74 = v77;
            uint64_t v77 = *(int **)v77;
          }
          while (v77);
        }
        else
        {
          do
          {
            char v74 = (int *)*((void *)v78 + 2);
            BOOL v76 = *(void *)v74 == (void)v78;
            char v78 = v74;
          }
          while (!v76);
        }
        char v79 = (void *)v75[1];
        if (v79)
        {
          do
          {
            char v80 = v79;
            char v79 = (void *)*v79;
          }
          while (v79);
        }
        else
        {
          do
          {
            char v80 = (void *)v75[2];
            BOOL v76 = *v80 == (void)v75;
            char v75 = v80;
          }
          while (!v76);
        }
        char v75 = v80;
        if (v74 == v71) {
          goto LABEL_143;
        }
      }
    }
    if (v69 != buf) {
      sub_100912880((uint64_t **)(v2 + 392), *(void **)buf, &buf[8]);
    }
    uint64_t v81 = *(void *)(v2 + 384);
    if (v81) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v81 + 48))(v81, v2 + 392);
    }
    goto LABEL_143;
  }
  char v108 = 0;
  int64x2_t v109 = 0uLL;
  uint64_t v7 = *(uint64_t **)(v2 + 168);
  int v8 = *(uint64_t **)(v2 + 176);
  if (v7 != v8)
  {
    do
    {
      sub_1013B8E08(*v7, v4, (uint64_t)buf);
      sub_1008FDFF4((uint64_t *)&v108, (uint64_t)buf);
      if (SHIBYTE(v105) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v103) < 0) {
        operator delete((void *)v102);
      }
      if (SHIBYTE(v101) < 0) {
        operator delete((void *)v100);
      }
      if (SHIBYTE(v99) < 0) {
        operator delete((void *)v98);
      }
      v106.i64[0] = (uint64_t)&v94;
      sub_10002E39C((void ***)&v106);
      if (v92[0])
      {
        v92[1] = v92[0];
        operator delete(v92[0]);
      }
      v7 += 2;
    }
    while (v7 != v8);
    uint64_t v6 = v87;
    uint64_t v5 = v88;
  }
  if (v6 != v5)
  {
    uint64_t v84 = v5;
    while (1)
    {
      uint64_t v9 = *(uint64_t **)(v2 + 168);
      xpc_object_t v10 = *(uint64_t **)(v2 + 176);
      if (v9 != v10)
      {
        while (1)
        {
          uint64_t v11 = *v9;
          if (*(_DWORD *)(*v9 + 32) == *(_DWORD *)v6) {
            break;
          }
          v9 += 2;
          if (v9 == v10) {
            goto LABEL_24;
          }
        }
        if (v9 != v10)
        {
          __int16 v12 = (std::__shared_weak_count *)v9[1];
          if (v12) {
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          goto LABEL_61;
        }
      }
LABEL_24:
      sub_1008F216C((char **)buf);
      int v13 = *(NSObject **)(v2 + 24);
      __int16 v12 = (std::__shared_weak_count *)operator new(0x180uLL);
      v12->__shared_owners_ = 0;
      v12->__shared_weak_owners_ = 0;
      v12->__vftable = (std::__shared_weak_count_vtbl *)off_101A19EB8;
      char v112 = v13;
      if (v13) {
        dispatch_retain(v13);
      }
      uint64_t v14 = *(std::__shared_weak_count **)(v2 + 976);
      v106.i64[0] = *(void *)(v2 + 968);
      v106.i64[1] = (uint64_t)v14;
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = (uint64_t)&v12[1];
      sub_1013B7764((uint64_t)&v12[1], (void *)(v2 + 64), &v112, v2 + 40, (int **)buf, &v106);
      if (v14) {
        sub_10004D2C8(v14);
      }
      if (v13) {
        dispatch_release(v13);
      }
      shared_owners = (std::__shared_weak_count *)v12[1].__shared_owners_;
      if (!shared_owners) {
        break;
      }
      if (shared_owners->__shared_owners_ == -1)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v12[1].__vftable = (std::__shared_weak_count_vtbl *)&v12[1];
        v12[1].__shared_owners_ = (uint64_t)v12;
        std::__shared_weak_count::__release_weak(shared_owners);
LABEL_36:
        sub_10004D2C8(v12);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      uint64_t v17 = *(uint64_t **)(v2 + 176);
      unint64_t v16 = *(void *)(v2 + 184);
      if ((unint64_t)v17 >= v16)
      {
        uint64_t v19 = *(uint64_t **)(v2 + 168);
        uint64_t v20 = ((char *)v17 - (char *)v19) >> 4;
        unint64_t v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 60) {
          sub_10006A748();
        }
        uint64_t v22 = v16 - (void)v19;
        if (v22 >> 3 > v21) {
          unint64_t v21 = v22 >> 3;
        }
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v21;
        }
        if (v23 >> 60) {
          sub_10006A7CC();
        }
        uint32_t v24 = (char *)operator new(16 * v23);
        __int16 v25 = (uint64_t *)&v24[16 * v20];
        uint64_t v26 = &v24[16 * v23];
        *__int16 v25 = v11;
        v25[1] = (uint64_t)v12;
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        BOOL v18 = v25 + 2;
        if (v17 == v19)
        {
          *(void *)(v2 + 168) = v25;
          *(void *)(v2 + 176) = v18;
          *(void *)(v2 + 184) = v26;
        }
        else
        {
          do
          {
            uint64_t v27 = *(v17 - 2);
            v17 -= 2;
            *(v25 - 2) = v27;
            v25 -= 2;
            uint64_t v28 = v17[1];
            v25[1] = v28;
            if (v28) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
            }
          }
          while (v17 != v19);
          uint64_t v17 = *(uint64_t **)(v2 + 168);
          uint64_t v29 = *(uint64_t **)(v2 + 176);
          *(void *)(v2 + 168) = v25;
          *(void *)(v2 + 176) = v18;
          *(void *)(v2 + 184) = v26;
          while (v29 != v17)
          {
            int v30 = (std::__shared_weak_count *)*(v29 - 1);
            if (v30) {
              sub_10004D2C8(v30);
            }
            v29 -= 2;
          }
        }
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        uint64_t *v17 = v11;
        v17[1] = (uint64_t)v12;
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        BOOL v18 = v17 + 2;
      }
      *(void *)(v2 + 176) = v18;
LABEL_61:
      if (*(_DWORD *)v6 == 1 && *(_DWORD *)(v11 + 40) != *(_DWORD *)(v6 + 8))
      {
        *(void *)std::string buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        v92[0] = sub_1008A4134;
        v92[1] = &unk_101A14CF0;
        uint64_t v93 = v6 + 8;
        sub_1008A3F54((wis::MetricFactory *)0x800A1);
      }
      uint64_t v31 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), *(unsigned int *)(v6 + 4));
      sub_1013B7A44(v11, v31, (long long *)v6);
      int v32 = *(_DWORD *)v6;
      uint64_t v33 = *(void *)(v6 + 12);
      v106.i32[0] = *(_DWORD *)v6;
      if ((v33 & 0xFF00000000) == 0 || subscriber::isSimAbsent())
      {
        unint64_t v34 = sub_1009127C8((uint64_t **)(v2 + 592), v32, &v106);
        uint64_t v35 = v34 + 6;
        sub_1000346F8((uint64_t)(v34 + 5), v34[6]);
        *(v35 - 1) = v35;
        *uint64_t v35 = 0;
        v35[1] = 0;
      }
      sub_1008F216C((char **)buf);
      char v37 = *(int **)buf;
      uint64_t v36 = *(int **)&buf[8];
      if (*(void *)buf != *(void *)&buf[8])
      {
        do
        {
          int v38 = *v37;
          uint64_t v39 = sub_1009127C8((uint64_t **)(v2 + 592), v32, &v106);
          sub_1003E516C((uint64_t *)v39 + 5, v38, v38);
          ++v37;
        }
        while (v37 != v36);
        char v37 = *(int **)buf;
      }
      if (v37)
      {
        *(void *)&uint8_t buf[8] = v37;
        operator delete(v37);
      }
      v90[0] = v11;
      v90[1] = (uint64_t)v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1008F9424(v2, v90);
      if (v12)
      {
        sub_10004D2C8(v12);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)std::string buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      v92[0] = sub_1008FA63C;
      v92[1] = &unk_101A18F00;
      uint64_t v93 = v2;
      sub_1013B8A74(v11, (uint64_t)buf);
      if (v12)
      {
        sub_10004D2C8(v12);
        sub_10004D2C8(v12);
      }
      v6 += 144;
      if (v6 == v84) {
        goto LABEL_79;
      }
    }
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v12[1].__vftable = (std::__shared_weak_count_vtbl *)&v12[1];
    v12[1].__shared_owners_ = (uint64_t)v12;
    goto LABEL_36;
  }
LABEL_79:
  sub_1008F77B8(v2, v3, v4);
  sub_1008F9694(v2, v40, v41);
  sub_1008F8114(v2, (uint64_t)&v108);
  *(void *)std::string buf = &v108;
LABEL_144:
  sub_10008A88C((void ***)buf);
  *(void *)std::string buf = &v87;
  sub_1008FDCDC((void ***)buf);
  sub_1009083AC(&v86);
  return sub_100046B58((uint64_t *)&v85);
}

void sub_100908278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,__int16 *a24,void *__p,void *a26)
{
  sub_1000346F8((uint64_t)&__p, a26);
  a22 = v26 - 176;
  sub_10008A88C((void ***)&a22);
  a24 = &a17;
  sub_1008FDCDC((void ***)&a24);
  sub_1009083AC(&a16);
  sub_100046B58(&a15);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009083AC(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = (void **)(v1 + 8);
    sub_1008FDCDC(&v2);
    operator delete();
  }
  return result;
}

uint64_t *sub_10090840C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v49 = a1;
  uint64_t v50 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  if (!v3)
  {
    uint64_t v39 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Invalid instance %s", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_110;
  }
  long long v52 = 0;
  uint64_t v53 = 0;
  long long v51 = &v52;
  unint64_t v4 = *(uint64_t **)(v2 + 336);
  uint64_t v5 = (uint64_t **)(v2 + 344);
  if (v4 == (uint64_t *)(v2 + 344))
  {
LABEL_46:
    uint64_t v40 = &v52;
    unint64_t v21 = &v52;
    goto LABEL_47;
  }
  uint64_t v6 = 0;
  uint64_t v7 = &v52;
  while (1)
  {
    int v8 = *((_DWORD *)v4 + 8);
    uint64_t v9 = &v52;
    if (v7 == &v52) {
      goto LABEL_10;
    }
    xpc_object_t v10 = v6;
    uint64_t v11 = &v52;
    if (v6)
    {
      do
      {
        uint64_t v9 = (uint64_t **)v10;
        xpc_object_t v10 = (uint64_t *)v10[1];
      }
      while (v10);
    }
    else
    {
      do
      {
        uint64_t v9 = (uint64_t **)v11[2];
        BOOL v12 = *v9 == (uint64_t *)v11;
        uint64_t v11 = v9;
      }
      while (v12);
    }
    if (*((_DWORD *)v9 + 8) < v8)
    {
LABEL_10:
      BOOL v12 = v6 == 0;
      if (v6) {
        int v13 = v9;
      }
      else {
        int v13 = &v52;
      }
      if (v6) {
        uint64_t v14 = (uint64_t ***)v9;
      }
      else {
        uint64_t v14 = &v51;
      }
      if (v12) {
        xpc_object_t v15 = &v52;
      }
      else {
        xpc_object_t v15 = v9 + 1;
      }
      if (v14[1]) {
        goto LABEL_31;
      }
LABEL_28:
      long long buf = 0uLL;
      unint64_t v55 = 0;
      sub_100908A50(&buf, (uint64_t)&v51, (uint64_t)(v4 + 4));
      uint64_t v17 = (uint64_t *)buf;
      *(void *)long long buf = 0;
      v17[1] = 0;
      uint64_t v17[2] = (uint64_t)v13;
      uint64_t *v15 = v17;
      if (*v51)
      {
        long long v51 = (uint64_t **)*v51;
        uint64_t v17 = *v15;
      }
      sub_100046C90(v52, v17);
      ++v53;
      goto LABEL_31;
    }
    xpc_object_t v15 = &v52;
    int v13 = &v52;
    if (!v6) {
      goto LABEL_28;
    }
    while (1)
    {
      while (1)
      {
        int v13 = (uint64_t **)v6;
        int v16 = *((_DWORD *)v6 + 8);
        if (v16 <= v8) {
          break;
        }
        uint64_t v6 = *v13;
        xpc_object_t v15 = v13;
        if (!*v13) {
          goto LABEL_28;
        }
      }
      if (v16 >= v8) {
        break;
      }
      uint64_t v6 = v13[1];
      if (!v6)
      {
        xpc_object_t v15 = v13 + 1;
        goto LABEL_28;
      }
    }
LABEL_31:
    BOOL v18 = (uint64_t *)v4[1];
    if (v18)
    {
      do
      {
        uint64_t v19 = (uint64_t **)v18;
        BOOL v18 = (uint64_t *)*v18;
      }
      while (v18);
    }
    else
    {
      do
      {
        uint64_t v19 = (uint64_t **)v4[2];
        BOOL v12 = *v19 == v4;
        unint64_t v4 = (uint64_t *)v19;
      }
      while (!v12);
    }
    if (v19 == v5) {
      break;
    }
    uint64_t v7 = v51;
    uint64_t v6 = v52;
    unint64_t v4 = (uint64_t *)v19;
  }
  int v3 = *(_DWORD *)(v1 + 8);
  uint64_t v20 = v52;
  if (!v52) {
    goto LABEL_46;
  }
  do
  {
    while (1)
    {
      unint64_t v21 = (uint64_t **)v20;
      int v22 = *((_DWORD *)v20 + 8);
      if (v22 <= v3) {
        break;
      }
      uint64_t v20 = *v21;
      if (!*v21)
      {
        uint64_t v40 = v21;
        goto LABEL_47;
      }
    }
    if (v22 >= v3)
    {
      unint64_t v41 = (char *)v21;
      goto LABEL_50;
    }
    uint64_t v20 = v21[1];
  }
  while (v20);
  uint64_t v40 = v21 + 1;
LABEL_47:
  unint64_t v41 = (char *)operator new(0x48uLL);
  *((_DWORD *)v41 + 8) = v3;
  v41[40] = 0;
  v41[64] = 0;
  *(void *)unint64_t v41 = 0;
  *((void *)v41 + 1) = 0;
  *((void *)v41 + 2) = v21;
  std::__shared_weak_count *v40 = (uint64_t *)v41;
  unint64_t v23 = (uint64_t *)v41;
  if (*v51)
  {
    long long v51 = (uint64_t **)*v51;
    unint64_t v23 = *v40;
  }
  sub_100046C90(v52, v23);
  ++v53;
LABEL_50:
  sub_100179AF8((std::string *)(v41 + 40), (const std::string *)(v1 + 16));
  uint32_t v24 = (uint64_t ***)(v2 + 336);
  if (*(void *)(v2 + 352) == v53)
  {
    __int16 v25 = *v24;
    if (*v24 != v5)
    {
      uint64_t v26 = v51;
      while (*((_DWORD *)v25 + 8) == *((_DWORD *)v26 + 8)
           && sub_1005A0BB8((unsigned __int8 *)v25 + 40, (unsigned __int8 *)v26 + 40))
      {
        uint64_t v27 = v25[1];
        uint64_t v28 = v25;
        if (v27)
        {
          do
          {
            __int16 v25 = (uint64_t **)v27;
            uint64_t v27 = (uint64_t *)*v27;
          }
          while (v27);
        }
        else
        {
          do
          {
            __int16 v25 = (uint64_t **)v28[2];
            BOOL v12 = *v25 == (uint64_t *)v28;
            uint64_t v28 = v25;
          }
          while (!v12);
        }
        uint64_t v29 = v26[1];
        if (v29)
        {
          do
          {
            int v30 = (uint64_t **)v29;
            uint64_t v29 = (uint64_t *)*v29;
          }
          while (v29);
        }
        else
        {
          do
          {
            int v30 = (uint64_t **)v26[2];
            BOOL v12 = *v30 == (uint64_t *)v26;
            uint64_t v26 = v30;
          }
          while (!v12);
        }
        uint64_t v26 = v30;
        if (v25 == v5) {
          goto LABEL_109;
        }
      }
      goto LABEL_67;
    }
  }
  else
  {
LABEL_67:
    if (v24 != &v51)
    {
      uint64_t v31 = v51;
      if (*(void *)(v2 + 352))
      {
        uint64_t v32 = (uint64_t)*v24;
        *uint32_t v24 = v5;
        (*v5)[2] = 0;
        *uint64_t v5 = 0;
        *(void *)(v2 + 352) = 0;
        if (*(void *)(v32 + 8)) {
          uint64_t v33 = *(void *)(v32 + 8);
        }
        else {
          uint64_t v33 = v32;
        }
        *(void *)&long long buf = v2 + 336;
        *((void *)&buf + 1) = v33;
        unint64_t v55 = (uint64_t *)v33;
        if (v33)
        {
          *((void *)&buf + 1) = sub_1000EA590(v33);
          unint64_t v34 = &v52;
          if (v31 != &v52)
          {
            do
            {
              *(_DWORD *)(v33 + 32) = *((_DWORD *)v31 + 8);
              sub_100179AF8((std::string *)(v33 + 40), (const std::string *)(v31 + 5));
              uint64_t v35 = *v5;
              uint64_t v36 = (uint64_t **)(v2 + 344);
              char v37 = (uint64_t **)(v2 + 344);
              if (*v5)
              {
                do
                {
                  while (1)
                  {
                    uint64_t v36 = (uint64_t **)v35;
                    if (*((_DWORD *)v55 + 8) >= *((_DWORD *)v35 + 8)) {
                      break;
                    }
                    uint64_t v35 = (uint64_t *)*v35;
                    char v37 = v36;
                    if (!*v36) {
                      goto LABEL_80;
                    }
                  }
                  uint64_t v35 = (uint64_t *)v35[1];
                }
                while (v35);
                char v37 = v36 + 1;
              }
LABEL_80:
              sub_100046C38((uint64_t **)(v2 + 336), (uint64_t)v36, v37, v55);
              uint64_t v33 = *((void *)&buf + 1);
              unint64_t v55 = (uint64_t *)*((void *)&buf + 1);
              if (*((void *)&buf + 1)) {
                *((void *)&buf + 1) = sub_1000EA590(*((uint64_t *)&buf + 1));
              }
              int v38 = v31[1];
              if (v38)
              {
                do
                {
                  unint64_t v34 = (uint64_t **)v38;
                  int v38 = (uint64_t *)*v38;
                }
                while (v38);
              }
              else
              {
                do
                {
                  unint64_t v34 = (uint64_t **)v31[2];
                  BOOL v12 = *v34 == (uint64_t *)v31;
                  uint64_t v31 = v34;
                }
                while (!v12);
              }
              if (!v33) {
                break;
              }
              uint64_t v31 = v34;
            }
            while (v34 != &v52);
          }
        }
        else
        {
          unint64_t v34 = v31;
        }
        sub_100908B3C((uint64_t)&buf);
        uint64_t v31 = v34;
      }
      if (v31 != &v52)
      {
        do
        {
          long long buf = 0uLL;
          unint64_t v55 = 0;
          sub_100908A50(&buf, v2 + 336, (uint64_t)(v31 + 4));
          uint64_t v42 = *v5;
          uint64_t v43 = (uint64_t **)(v2 + 344);
          unint64_t v44 = (uint64_t **)(v2 + 344);
          if (*v5)
          {
            do
            {
              while (1)
              {
                uint64_t v43 = (uint64_t **)v42;
                if (*(_DWORD *)(buf + 32) >= *((_DWORD *)v42 + 8)) {
                  break;
                }
                uint64_t v42 = (uint64_t *)*v42;
                unint64_t v44 = v43;
                if (!*v43) {
                  goto LABEL_101;
                }
              }
              uint64_t v42 = (uint64_t *)v42[1];
            }
            while (v42);
            unint64_t v44 = v43 + 1;
          }
LABEL_101:
          sub_100046C38((uint64_t **)(v2 + 336), (uint64_t)v43, v44, (uint64_t *)buf);
          uint64_t v45 = v31[1];
          if (v45)
          {
            do
            {
              char v46 = (uint64_t **)v45;
              uint64_t v45 = (uint64_t *)*v45;
            }
            while (v45);
          }
          else
          {
            do
            {
              char v46 = (uint64_t **)v31[2];
              BOOL v12 = *v46 == (uint64_t *)v31;
              uint64_t v31 = v46;
            }
            while (!v12);
          }
          uint64_t v31 = v46;
        }
        while (v46 != &v52);
      }
    }
    uint64_t v47 = *(void *)(v2 + 328);
    if (v47) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v47 + 48))(v47, v2 + 336);
    }
  }
LABEL_109:
  sub_1008FD57C((char *)v52);
LABEL_110:
  sub_1009089F0(&v50);
  return sub_100046B58((uint64_t *)&v49);
}

void sub_1009089AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_1009089F0((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009089F0(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 40))
    {
      if (*(char *)(v1 + 39) < 0) {
        operator delete(*(void **)(v1 + 16));
      }
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100908A50(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2 + 8;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v6 = operator new(0x48uLL);
  *a1 = v6;
  a1[1] = v5;
  *((unsigned char *)a1 + 16) = 0;
  v6[8] = *(_DWORD *)a3;
  uint64_t result = sub_1000593FC((uint64_t)(v6 + 10), (long long *)(a3 + 8));
  *((unsigned char *)a1 + 16) = 1;
  return result;
}

void sub_100908AB8(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_100908AD4(0, v2);
  _Unwind_Resume(a1);
}

void sub_100908AD4(char a1, void **__p)
{
  if (a1)
  {
    if (*((unsigned char *)__p + 64) && *((char *)__p + 63) < 0) {
      operator delete(__p[5]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t sub_100908B3C(uint64_t a1)
{
  sub_1008FD57C(*(char **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1008FD57C((char *)v2);
  }
  return a1;
}

uint64_t **sub_100908B8C(uint64_t **a1, void *a2)
{
  a1[1] = 0;
  uint64_t v3 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  unint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    while (1)
    {
      uint64_t v6 = a1[1];
      uint64_t v7 = v3;
      if (*a1 != v3)
      {
        int v8 = a1[1];
        uint64_t v9 = v3;
        if (v6)
        {
          do
          {
            uint64_t v7 = v8;
            int v8 = (uint64_t *)v8[1];
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v7 = (uint64_t *)v9[2];
            BOOL v10 = *v7 == (void)v9;
            uint64_t v9 = v7;
          }
          while (v10);
        }
        int v11 = *((_DWORD *)v5 + 7);
        if (*((_DWORD *)v7 + 7) >= v11) {
          break;
        }
      }
      if (v6) {
        BOOL v12 = (uint64_t **)v7;
      }
      else {
        BOOL v12 = (uint64_t **)v3;
      }
      if (v6) {
        int v13 = (uint64_t **)(v7 + 1);
      }
      else {
        int v13 = (uint64_t **)v3;
      }
      if (!*v13) {
        goto LABEL_24;
      }
LABEL_27:
      BOOL v18 = (void *)v5[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          BOOL v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v5[2];
          BOOL v10 = *v19 == (void)v5;
          uint64_t v5 = v19;
        }
        while (!v10);
      }
      uint64_t v5 = v19;
      if (v19 == v4) {
        return a1;
      }
    }
    int v13 = (uint64_t **)v3;
    BOOL v12 = (uint64_t **)v3;
    if (v6)
    {
      uint64_t v14 = a1[1];
      while (1)
      {
        while (1)
        {
          BOOL v12 = (uint64_t **)v14;
          int v15 = *((_DWORD *)v14 + 7);
          if (v15 <= v11) {
            break;
          }
          uint64_t v14 = *v12;
          int v13 = v12;
          if (!*v12) {
            goto LABEL_24;
          }
        }
        if (v15 >= v11) {
          goto LABEL_27;
        }
        uint64_t v14 = v12[1];
        if (!v14)
        {
          int v13 = v12 + 1;
          break;
        }
      }
    }
LABEL_24:
    int v16 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v16 + 28) = *(void *)((char *)v5 + 28);
    *int v16 = 0;
    v16[1] = 0;
    _OWORD v16[2] = (uint64_t)v12;
    *int v13 = v16;
    uint64_t v17 = (uint64_t *)**a1;
    if (v17)
    {
      *a1 = v17;
      int v16 = *v13;
    }
    sub_100046C90(a1[1], v16);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    goto LABEL_27;
  }
  return a1;
}

void sub_100908D14(_Unwind_Exception *a1)
{
  sub_10005D144(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100908D28(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v14 = a1;
  int v15 = v1;
  uint64_t v2 = (void *)*v1;
  v17[0] = 1;
  long long v18 = 0u;
  uint64_t v19 = 0;
  v17[1] = v2 + 45;
  sub_10005DF14((uint64_t *)&v18, (uint64_t)(v2 + 49));
  uint64_t v3 = (void *)v1[1];
  if (v3 != v1 + 2)
  {
    while (2)
    {
      for (unint64_t i = (void *)v2[21]; ; i += 2)
      {
        if (i == (void *)v2[22])
        {
          int v11 = v2[5];
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = subscriber::asString();
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v12;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: sim not available", buf, 0xCu);
          }
          goto LABEL_19;
        }
        uint64_t v5 = *i;
        if (*(_DWORD *)(*i + 32) == *((_DWORD *)v3 + 7)) {
          break;
        }
      }
      uint64_t v6 = (std::__shared_weak_count *)i[1];
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v7 = *((unsigned char *)v3 + 32);
      int v16 = *(_DWORD *)(v5 + 36);
      *(void *)long long buf = &v16;
      *((unsigned char *)sub_10005CE78((uint64_t **)&v18, &v16, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v7;
      if (v6) {
        sub_10004D2C8(v6);
      }
      int v8 = (void *)v3[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          int v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v3[2];
          BOOL v10 = *v9 == (void)v3;
          uint64_t v3 = v9;
        }
        while (!v10);
      }
      uint64_t v3 = v9;
      if (v9 != v1 + 2) {
        continue;
      }
      break;
    }
  }
LABEL_19:
  sub_1009161EC((uint64_t)v17);
  sub_100908F48((uint64_t *)&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_100908F08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  uint64_t v7 = va_arg(va2, void);
  sub_1009161EC((uint64_t)va2);
  sub_100908F48((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100908F48(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_10005D144(*(void **)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100908F98(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = *a1;
  unint64_t v23 = a1;
  uint64_t v24 = v3;
  uint64_t v4 = *(void *)v3;
  int v5 = *(_DWORD *)(v3 + 48);
  int v6 = *(unsigned __int8 *)(v3 + 80);
  uint64_t v7 = *(uint64_t **)(*(void *)v3 + 168);
  int v8 = *(uint64_t **)(*(void *)v3 + 176);
  if (v7 == v8)
  {
LABEL_4:
    uint64_t v9 = 0;
    BOOL v10 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v9 = *v7;
      if (*(_DWORD *)(*v7 + 32) == *(_DWORD *)(v3 + 8)) {
        break;
      }
      v7 += 2;
      if (v7 == v8) {
        goto LABEL_4;
      }
    }
    BOOL v10 = (std::__shared_weak_count *)v7[1];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  if (v5 == 1)
  {
    int v12 = *(_DWORD *)(v3 + 12);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v26 = 0x40000000;
    uint64_t v27 = sub_1008A47B0;
    uint64_t v28 = &unk_101A14D50;
    char v30 = v6;
    int v29 = v12;
    sub_1008A45D0((wis::MetricFactory *)0x800A4);
  }
  else if (!v5)
  {
    sub_1013B7DAC(v9, 0);
    int v11 = *(_DWORD *)(v3 + 12);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v26 = 0x40000000;
    uint64_t v27 = sub_1008A4584;
    uint64_t v28 = &unk_101A14D30;
    char v30 = v6;
    int v29 = v11;
    sub_1008A43A4((wis::MetricFactory *)0x800A3);
  }
  uint64_t v13 = *(void *)(v3 + 84);
  uint64_t v14 = *(void *)(v3 + 92);
  if ((v13 & 0xFF00000000) != 0) {
    *(unsigned char *)(v9 + 59) = v13;
  }
  if ((v14 & 0xFF00000000) != 0) {
    *(unsigned char *)(v9 + 60) = v14;
  }
  if (!v6)
  {
    if (v5 == 1)
    {
      uint64_t v17 = *(void **)(v4 + 120);
      uint64_t v18 = *(unsigned int *)(v3 + 12);
      uint64_t v19 = sub_1013B85B4(v9, a2, a3);
      if (*(unsigned char *)(v3 + 96)) {
        char v20 = *(unsigned char *)(v3 + 92);
      }
      else {
        char v20 = -1;
      }
      unint64_t v21 = (void (**)(void *, uint64_t, uint64_t, void))(*v17 + 56);
    }
    else
    {
      if (v5)
      {
LABEL_30:
        *(_DWORD *)long long buf = *(_DWORD *)(v3 + 12);
        *(_DWORD *)&uint8_t buf[4] = 42;
        sub_1008FB82C(v4 + 80, (int *)buf);
        goto LABEL_31;
      }
      uint64_t v17 = *(void **)(v4 + 120);
      uint64_t v18 = *(unsigned int *)(v3 + 12);
      uint64_t v19 = sub_1013B85B4(v9, a2, a3);
      if (*(unsigned char *)(v3 + 88)) {
        char v20 = *(unsigned char *)(v3 + 84);
      }
      else {
        char v20 = -1;
      }
      unint64_t v21 = (void (**)(void *, uint64_t, uint64_t, void))(*v17 + 40);
    }
    (*v21)(v17, v18, v19, v20);
    goto LABEL_30;
  }
  int v15 = **(NSObject ***)(v9 + 352);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I PIN Entry result is success #sim-pin", buf, 2u);
  }
  sub_1013B9890(v9, v3 + 56, v16);
  sub_1008FB744(v4 + 80, *(_DWORD *)(v3 + 12));
LABEL_31:
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1009092B8(&v24);
  return sub_100046B58((uint64_t *)&v23);
}

void sub_10090928C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1009092B8(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009092B8(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    uint64_t v2 = *(void **)(v1 + 24);
    if (v2)
    {
      *(void *)(v1 + 32) = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100909320(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 72);
  uint64_t v4 = *(unsigned int *)(v1 + 76);
  uint64_t v6 = *(void *)(v1 + 80);
  uint64_t v5 = *(void *)(v1 + 88);
  uint64_t v7 = *(uint64_t **)(*(void *)v1 + 168);
  int v8 = *(uint64_t **)(*(void *)v1 + 176);
  if (v7 == v8)
  {
LABEL_4:
    uint64_t v9 = 0;
    BOOL v10 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v9 = *v7;
      if (*(_DWORD *)(*v7 + 32) == *(_DWORD *)(v1 + 8)) {
        break;
      }
      v7 += 2;
      if (v7 == v8) {
        goto LABEL_4;
      }
    }
    BOOL v10 = (std::__shared_weak_count *)v7[1];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  if ((v6 & 0xFF00000000) != 0) {
    *(unsigned char *)(v9 + 59) = v6;
  }
  if ((v5 & 0xFF00000000) != 0) {
    *(unsigned char *)(v9 + 60) = v5;
  }
  if (v3)
  {
    int v11 = **(NSObject ***)(v9 + 352);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I PIN Entry result is success #sim-pin", buf, 2u);
    }
    sub_1013B9890(v9, v1 + 48, v12);
    int v13 = *(_DWORD *)(v1 + 12);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v18 = 0x40000000;
    uint64_t v19 = sub_1008A4B98;
    char v20 = &unk_101A14D70;
    uint64_t v21 = v2;
    int v22 = v13;
    sub_1008A49B8((wis::MetricFactory *)0x800A5);
    (*(void (**)(void, void))(**(void **)(v2 + 120) + 96))(*(void *)(v2 + 120), *(unsigned int *)(v1 + 12));
    sub_1008FB744(v2 + 80, *(_DWORD *)(v1 + 12));
  }
  else
  {
    (*(void (**)(void, void, uint64_t))(**(void **)(v2 + 120) + 104))(*(void *)(v2 + 120), *(unsigned int *)(v1 + 12), v4);
    *(_DWORD *)long long buf = *(_DWORD *)(v1 + 12);
    *(_DWORD *)&uint8_t buf[4] = v4;
    sub_1008FB82C(v2 + 80, (int *)buf);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10090954C(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100909520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10090954C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090954C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    uint64_t v2 = *(void **)(v1 + 24);
    if (v2)
    {
      *(void *)(v1 + 32) = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1009095B4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v18 = a1;
  uint64_t v19 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(unsigned __int8 *)(v1 + 48);
  char v4 = *(unsigned char *)(v1 + 49);
  uint64_t v6 = *(void *)(v1 + 80);
  uint64_t v5 = *(void *)(v1 + 88);
  uint64_t v7 = *(uint64_t **)(*(void *)v1 + 168);
  int v8 = *(uint64_t **)(*(void *)v1 + 176);
  if (v7 == v8)
  {
LABEL_4:
    uint64_t v9 = 0;
    BOOL v10 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v9 = *v7;
      if (*(_DWORD *)(*v7 + 32) == *(_DWORD *)(v1 + 8)) {
        break;
      }
      v7 += 2;
      if (v7 == v8) {
        goto LABEL_4;
      }
    }
    BOOL v10 = (std::__shared_weak_count *)v7[1];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  if ((v6 & 0xFF00000000) != 0) {
    *(unsigned char *)(v9 + 59) = v6;
  }
  if ((v5 & 0xFF00000000) != 0) {
    *(unsigned char *)(v9 + 60) = v5;
  }
  if (v3)
  {
    int v11 = **(NSObject ***)(v9 + 352);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I PIN Enabled Changed result is success #sim-pin", buf, 2u);
    }
    sub_1013B9890(v9, v1 + 56, v12);
    int v14 = *(_DWORD *)(v1 + 12);
    int v13 = (unsigned int *)(v1 + 12);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v21 = 0x40000000;
    int v22 = sub_1008A4BC0;
    unint64_t v23 = &unk_101A14D90;
    uint64_t v24 = v2;
    char v26 = v4;
    int v25 = v14;
    sub_1008A49B8((wis::MetricFactory *)0x800A5);
    int v15 = *(void **)(v2 + 120);
    uint64_t v16 = (void (**)(void *, void))(*v15 + 80);
  }
  else
  {
    int v15 = *(void **)(v2 + 120);
    int v13 = (unsigned int *)(v1 + 12);
    uint64_t v16 = (void (**)(void *, void))(*v15 + 88);
  }
  (*v16)(v15, *v13);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1009097E4(&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_1009097BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1009097E4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009097E4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    uint64_t v2 = *(void **)(v1 + 24);
    if (v2)
    {
      *(void *)(v1 + 32) = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10090984C(char **a1)
{
  uint64_t v1 = *a1;
  BOOL v10 = a1;
  int v11 = v1;
  uint64_t v2 = *(void **)(*(void *)v1 + 168);
  int v3 = *(void **)(*(void *)v1 + 176);
  if (v2 != v3)
  {
    int v4 = *((_DWORD *)v1 + 12);
    uint64_t v5 = v1 + 52;
    int v6 = *((_DWORD *)v1 + 2);
    while (1)
    {
      uint64_t v7 = *v2;
      if (*(_DWORD *)(*v2 + 32) == v6) {
        break;
      }
      v2 += 2;
      if (v2 == v3) {
        goto LABEL_9;
      }
    }
    int v8 = (std::__shared_weak_count *)v2[1];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_100D48CD8(v7 + 184, v4, v5);
      sub_10004D2C8(v8);
    }
    else
    {
      sub_100D48CD8(v7 + 184, v4, v5);
    }
  }
LABEL_9:
  sub_1009098F4((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

uint64_t *sub_1009098F4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = *(void **)(v1 + 24);
    if (v2)
    {
      *(void *)(v1 + 32) = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_10090994C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_1009099E4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100909A64(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v33 = a1;
  uint64_t v34 = v1;
  uint64_t v2 = *(void *)v1;
  *(void *)uint64_t v35 = *(void *)(v1 + 48);
  *(_DWORD *)&v35[8] = *(_DWORD *)(v1 + 56);
  char v37 = 0;
  uint64_t v38 = 0;
  long long __p = 0;
  sub_1008FDDC8(&__p, *(const void **)(v1 + 64), *(void *)(v1 + 72), (uint64_t)(*(void *)(v1 + 72) - *(void *)(v1 + 64)) >> 2);
  __int16 v39 = *(_WORD *)(v1 + 88);
  sub_10090994C((uint64_t)v43, v1 + 96);
  int v3 = *(_DWORD *)(v1 + 8);
  if (v3)
  {
    for (unint64_t i = *(uint64_t **)(v2 + 168); i != *(uint64_t **)(v2 + 176); i += 2)
    {
      uint64_t v5 = *i;
      if (*(_DWORD *)(*i + 32) == v3) {
        goto LABEL_16;
      }
    }
    goto LABEL_11;
  }
  int v6 = *(_DWORD *)(v1 + 12);
  if (v6)
  {
    for (unint64_t i = *(uint64_t **)(v2 + 168); ; i += 2)
    {
      if (i == *(uint64_t **)(v2 + 176)) {
        goto LABEL_11;
      }
      uint64_t v5 = *i;
      if (*(_DWORD *)(*i + 36) == v6) {
        break;
      }
    }
LABEL_16:
    uint64_t v9 = (std::__shared_weak_count *)i[1];
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    BOOL v10 = **(NSObject ***)(v5 + 352);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = subscriber::asString();
      uint64_t v12 = subscriber::asString();
      uint64_t v14 = printers::asString((printers *)&v39, v13);
      uint64_t v16 = printers::asString((printers *)((char *)&v39 + 1), v15);
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v12;
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v45 = (void *)v14;
      LOWORD(v46[0]) = 2080;
      *(void *)((char *)v46 + 2) = v16;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I handling refresh type %s for card %s, clear cache %s, rebuild cache %s", buf, 0x2Au);
    }
    LODWORD(v40) = *(_DWORD *)(v5 + 36);
    *(void *)((char *)&v40 + 4) = *(void *)&v35[4];
    xpc_object_t v42 = 0;
    rest::write_rest_value();
    sub_100058DB0(buf, "/cc/events/sim_refresh_event");
    xpc_object_t object = v42;
    xpc_object_t v42 = xpc_null_create();
    ctu::RestModule::sendEvent();
    xpc_release(object);
    xpc_object_t object = 0;
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    xpc_release(v42);
    if ((_BYTE)v39)
    {
      if (*(_DWORD *)v35 > 7u) {
        goto LABEL_63;
      }
      if (((1 << v35[0]) & 0xD2) != 0)
      {
        *(void *)&uint8_t buf[8] = 0;
        *(void *)&uint8_t buf[16] = 0;
        *(void *)long long buf = &buf[8];
        int v17 = *(_DWORD *)(v5 + 32);
        uint64_t v18 = *(uint64_t **)(v2 + 600);
        if (v18)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v19 = (uint64_t **)v18;
              int v20 = *((_DWORD *)v18 + 8);
              if (v20 <= v17) {
                break;
              }
              uint64_t v18 = *v19;
              uint64_t v21 = v19;
              if (!*v19) {
                goto LABEL_40;
              }
            }
            if (v20 >= v17) {
              break;
            }
            uint64_t v18 = v19[1];
            if (!v18)
            {
              uint64_t v21 = v19 + 1;
              goto LABEL_40;
            }
          }
        }
        else
        {
          uint64_t v21 = (uint64_t **)(v2 + 600);
          uint64_t v19 = (uint64_t **)(v2 + 600);
LABEL_40:
          int v25 = operator new(0x40uLL);
          v25[8] = v17;
          *((void *)v25 + 7) = 0;
          *((void *)v25 + 6) = 0;
          *((void *)v25 + 5) = v25 + 12;
          sub_100046C38((uint64_t **)(v2 + 592), (uint64_t)v19, v21, (uint64_t *)v25);
          uint64_t v19 = (uint64_t **)v25;
        }
        char v26 = (uint64_t **)v19[5];
        uint64_t v27 = v19 + 6;
        if (v26 != v19 + 6)
        {
          do
          {
            int v28 = *((_DWORD *)v26 + 7);
            if (*(_DWORD *)&v35[4] == subscriber::getSimCardForSimFilePath())
            {
              sub_1013B8BD8(v5, v28);
              sub_1003E516C((uint64_t *)buf, v28, v28);
            }
            int v29 = v26[1];
            if (v29)
            {
              do
              {
                char v30 = (uint64_t **)v29;
                int v29 = (uint64_t *)*v29;
              }
              while (v29);
            }
            else
            {
              do
              {
                char v30 = (uint64_t **)v26[2];
                BOOL v31 = *v30 == (uint64_t *)v26;
                char v26 = v30;
              }
              while (!v31);
            }
            char v26 = v30;
          }
          while (v30 != v27);
        }
        *(void *)&long long v40 = v5;
        *((void *)&v40 + 1) = v9;
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        goto LABEL_52;
      }
      if (((1 << v35[0]) & 0xC) != 0)
      {
        *(void *)&uint8_t buf[8] = 0;
        *(void *)&uint8_t buf[16] = 0;
        *(void *)long long buf = &buf[8];
        int v22 = (int *)__p;
        unint64_t v23 = v37;
        while (v22 != v23)
        {
          int v24 = *v22;
          sub_1013B8BD8(v5, *v22);
          sub_1003E516C((uint64_t *)buf, v24, v24);
          ++v22;
        }
        *(void *)&long long v40 = v5;
        *((void *)&v40 + 1) = v9;
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
LABEL_52:
        sub_1008F8304(v2, &v40, buf);
        if (v9) {
          sub_10004D2C8(v9);
        }
        sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
        goto LABEL_55;
      }
      if (*(_DWORD *)v35 != 5)
      {
LABEL_63:
        uint64_t v32 = **(NSObject ***)(v5 + 352);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Invalid refresh type", buf, 2u);
        }
      }
    }
LABEL_55:
    if (HIBYTE(v39))
    {
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_1008FA63C;
      uint64_t v45 = &unk_101A18F00;
      v46[0] = v2;
      sub_1013B8A74(v5, (uint64_t)buf);
      if (v9) {
        sub_10004D2C8(v9);
      }
    }
    sub_1008FBA74((uint64_t)v43, *(_DWORD *)(v1 + 12));
    if (v9) {
      sub_10004D2C8(v9);
    }
    goto LABEL_13;
  }
LABEL_11:
  uint64_t v7 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find sim", buf, 2u);
  }
LABEL_13:
  sub_1008FDE68(v43);
  if (__p)
  {
    char v37 = (int *)__p;
    operator delete(__p);
  }
  sub_10090A0C4(&v34);
  return sub_100046B58((uint64_t *)&v33);
}

void sub_100909FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object, xpc_object_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,void *a26,int a27,__int16 a28,char a29,char a30)
{
  if (v30) {
    sub_10004D2C8(v30);
  }
  sub_1000346F8((uint64_t)&a25, a26);
  if (v30) {
    sub_10004D2C8(v30);
  }
  sub_1008FDE68(&a21);
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_10090A0C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void *sub_10090A0C4(void *result)
{
  uint64_t v1 = (void *)*result;
  void *result = 0;
  if (v1)
  {
    sub_1008FDE68(v1 + 12);
    uint64_t v2 = (void *)v1[8];
    if (v2)
    {
      v1[9] = v2;
      operator delete(v2);
    }
    int v3 = (void *)v1[3];
    if (v3)
    {
      v1[4] = v3;
      operator delete(v3);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10090A134(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  memset(&v27[1], 0, 32);
  long long v28 = 0u;
  long long v33 = 0u;
  long long v32 = 0u;
  memset(&v30, 0, sizeof(v30));
  long long v29 = 0u;
  unint64_t v31 = 23;
  qmemcpy((char *)&v27[2] + 7, "\tSIM", 4);
  LOBYTE(v27[1]) = 121;
  v27[0] = *(void **)"Telephony";
  BYTE7(v28) = 3;
  std::string::operator=((std::string *)((char *)&v28 + 8), (const std::string *)(v1 + 8));
  std::string::operator=(&v30, (const std::string *)(v1 + 32));
  long long __dst = &v31;
  int v17 = 0;
  sub_10019E478((uint64_t)&__dst, 5uLL);
  v31 |= 0x11uLL;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v31, *(Registry **)(v2 + 64));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  long long __dst = (void *)v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&__dst);
  if (v9)
  {
    uint64_t v11 = v9[3];
    BOOL v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  BOOL v10 = 0;
  char v12 = 1;
LABEL_9:
  sub_1000DB86C((char *)&__dst, (long long *)v27);
  v34[3] = 0;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v11 + 16))(v11, &__dst, v34);
  sub_1000DBADC(v34);
  if (v26 < 0) {
    operator delete(__p);
  }
  if (v24 < 0) {
    operator delete(v23);
  }
  if (v22 < 0) {
    operator delete(v21);
  }
  if (v20 < 0) {
    operator delete(v19);
  }
  if ((v18 & 0x80000000) == 0)
  {
    if (v12) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  operator delete(__dst);
  if ((v12 & 1) == 0) {
LABEL_19:
  }
    sub_10004D2C8(v10);
LABEL_20:
  if (SBYTE7(v33) < 0) {
    operator delete((void *)v32);
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(*((void **)&v28 + 1));
  }
  if (SBYTE7(v28) < 0) {
    operator delete(v27[3]);
  }
  if (SHIBYTE(v27[2]) < 0) {
    operator delete(v27[0]);
  }
  sub_10090A454(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_10090A3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  sub_1000DBADC((void *)(v31 - 88));
  sub_1001278A0((uint64_t)&a12);
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  sub_1001278A0((uint64_t)&a29);
  sub_10090A454(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090A454(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_10090A4BC(uint64_t a1, uint64_t a2, unint64_t a3)
{
  int v3 = *(unsigned int **)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = v3[2];
  for (unint64_t i = *(uint64_t **)(*(void *)v3 + 168); i != *(uint64_t **)(v4 + 176); i += 2)
  {
    uint64_t v7 = *i;
    if (*(_DWORD *)(*i + 36) == v5)
    {
      BOOL v10 = (std::__shared_weak_count *)i[1];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v9 = sub_1013B85B4(v7, v5, a3);
      if (v10) {
        sub_10004D2C8(v10);
      }
      return v9;
    }
  }
  unsigned int v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 56) + 16))(*(void *)(v4 + 56), v5);
  uint64_t v9 = 0;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Sim Info not found", v12, 2u);
    return 0;
  }
  return v9;
}

void sub_10090A5AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10090A5C4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10090A600(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

unint64_t sub_10090A63C(uint64_t a1)
{
  uint64_t v1 = *(_DWORD **)(a1 + 40);
  uint64_t v2 = *(void **)(*(void *)v1 + 168);
  int v3 = *(void **)(*(void *)v1 + 176);
  if (v2 == v3) {
    return 0;
  }
  int v4 = v1[2];
  while (1)
  {
    uint64_t v5 = *v2;
    if (*(_DWORD *)(*v2 + 36) == v4) {
      break;
    }
    v2 += 2;
    if (v2 == v3) {
      return 0;
    }
  }
  uint64_t v7 = (std::__shared_weak_count *)v2[1];
  if (!v7) {
    return *(unsigned int *)(v5 + 32) | ((unint64_t)*(unsigned int *)(v5 + 52) << 32);
  }
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v6 = *(unsigned int *)(v5 + 32) | ((unint64_t)*(unsigned int *)(v5 + 52) << 32);
  sub_10004D2C8(v7);
  return v6;
}

uint64_t sub_10090A6CC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10090A708(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_10090A744(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v11 = a1;
  char v12 = v1;
  uint64_t v2 = *(void **)(*v1 + 168);
  int v3 = *(void **)(*v1 + 176);
  if (v2 == v3)
  {
LABEL_9:
    int v7 = 0;
    int v8 = 0;
  }
  else
  {
    int v4 = *(void **)(*v1 + 168);
    do
    {
      uint64_t v5 = *v4;
      if (*(_DWORD *)(*v4 + 32) == 1)
      {
        uint64_t v9 = (std::__shared_weak_count *)v4[1];
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_10090A8B8(v1[4], *(_DWORD *)(v5 + 40));
        if (v9) {
          sub_10004D2C8(v9);
        }
        goto LABEL_15;
      }
      v4 += 2;
    }
    while (v4 != v3);
    if (v2 == v3) {
      goto LABEL_9;
    }
    while (1)
    {
      uint64_t v6 = *(int *)(*v2 + 52);
      if (v6 < 3) {
        break;
      }
      v2 += 2;
      if (v2 == v3)
      {
        int v7 = 1;
        int v8 = 1;
        goto LABEL_10;
      }
    }
    int v7 = 0;
    int v8 = dword_10150B0E8[v6];
  }
LABEL_10:
  sub_10090A8B8(v1[4], v8 & v7);
LABEL_15:
  sub_10090A868((uint64_t *)&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_10090A838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10090A868(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090A868(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1008FDEEC((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10090A8B8(uint64_t a1, int a2)
{
  int v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 48))(a1, &v3);
}

uint64_t sub_10090A908(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 168);
  uint64_t v3 = *(void *)(v1 + 176);
  if (v2 == v3)
  {
    int v5 = 0;
    unsigned int v6 = 0;
  }
  else
  {
    while (1)
    {
      unsigned int v4 = *(_DWORD *)(*(void *)v2 + 52);
      if (v4 < 3) {
        break;
      }
      v2 += 16;
      if (v2 == v3)
      {
        int v5 = 1;
        unsigned int v6 = 1;
        return v5 | (v6 << 8);
      }
    }
    int v5 = 0;
    unsigned int v6 = 0x10100u >> (8 * v4);
  }
  return v5 | (v6 << 8);
}

uint64_t sub_10090A96C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10090A9A8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_10090A9E4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v91 = a1;
  uint64_t v92 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (Registry **)(*(void *)v1 + 64);
  if (subscriber::isValidSimSlot())
  {
    unsigned int v4 = dispatch_group_create();
    int v5 = v4;
    if (v4)
    {
      dispatch_retain(v4);
      dispatch_group_enter(v5);
      uint64_t v6 = *(unsigned int *)(v1 + 8);
      dispatch_retain(v5);
      dispatch_group_enter(v5);
    }
    else
    {
      uint64_t v6 = *(unsigned int *)(v1 + 8);
    }
    uint64_t v93 = 0;
    unsigned int v97 = v6;
    if (!*(unsigned char *)(v2 + 488) || (uint64_t v9 = *(uint64_t **)(v2 + 504)) == 0)
    {
LABEL_16:
      uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v6);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        int v22 = *(unsigned __int8 *)(v2 + 488);
        unint64_t v23 = *(uint64_t **)(v2 + 504);
        if (v23)
        {
          uint64_t v24 = 1;
          do
          {
            int v25 = *((_DWORD *)v23 + 8);
            if (v25 <= (int)v6)
            {
              if (v25 >= (int)v6) {
                goto LABEL_37;
              }
              ++v23;
            }
            unint64_t v23 = (uint64_t *)*v23;
          }
          while (v23);
        }
        uint64_t v24 = 0;
LABEL_37:
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v22;
        *(_WORD *)&uint8_t buf[8] = 2048;
        *(void *)&buf[10] = v24;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Unable to supply dictionary; MEID(ready=%d) and IMEI(ready=%lu)",
          buf,
          0x12u);
      }
      char v12 = 0;
      uint64_t v93 = 0;
      if (!v5) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    while (1)
    {
      int v10 = *((_DWORD *)v9 + 8);
      if (v10 <= (int)v6)
      {
        if (v10 >= (int)v6)
        {
          *(void *)int v96 = 0;
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (!Mutable)
          {
            char v26 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v97);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to create CFMutableDictionarySharedRef", buf, 2u);
            }
            char v12 = 0;
            uint64_t v93 = 0;
            goto LABEL_158;
          }
          uint64_t v15 = *(__CFDictionary **)v96;
          *(void *)int v96 = Mutable;
          *(void *)long long buf = v15;
          sub_10005717C((const void **)buf);
          unsigned int v16 = subscriber::simSlotAsInstance();
          sub_1008F7704(*(__CFDictionary **)v96, @"kCTMobileEquipmentInfoSlotId", v16, kCFAllocatorDefault);
          int v17 = sub_1000FD774(v2 + 496, (int *)&v97);
          CFStringRef v18 = @"kCTMobileEquipmentInfoIMEI";
          sub_1008F7470(*(__CFDictionary **)v96, @"kCTMobileEquipmentInfoIMEI", (uint64_t)v17);
          v94[0] = 0;
          v94[1] = 0;
          uint64_t v95 = 0;
          sub_1008F751C(v2, v97, 0, (uint64_t)v94);
          sub_1008F7470(*(__CFDictionary **)v96, @"kCTMobileEquipmentInfoICCID", (uint64_t)v94);
          uint64_t v19 = v97;
          char v20 = *(__CFDictionary **)v96;
          if (v5)
          {
            dispatch_retain(v5);
            dispatch_group_enter(v5);
          }
          if (!v20)
          {
            uint64_t v27 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v19);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "dict is null", buf, 2u);
            }
            goto LABEL_117;
          }
          if (*(unsigned char *)(v2 + 488))
          {
            uint64_t v21 = (void **)(v2 + 464);
            if (*(char *)(v2 + 487) < 0)
            {
              unint64_t v28 = *(void *)(v2 + 472);
              if (v28)
              {
                sub_10004FC84(buf, *v21, v28);
                goto LABEL_45;
              }
            }
            else if (*(unsigned char *)(v2 + 487))
            {
              *(_OWORD *)long long buf = *(_OWORD *)v21;
              *(void *)&uint8_t buf[16] = *(void *)(v2 + 480);
LABEL_45:
              sub_1007157A4(v20, @"kCTMobileEquipmentInfoMEID");
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
            }
          }
          for (unint64_t i = *(uint64_t **)(v2 + 168); ; i += 2)
          {
            if (i == *(uint64_t **)(v2 + 176)) {
              goto LABEL_117;
            }
            uint64_t v30 = *i;
            if (*(_DWORD *)(*i + 36) == v19) {
              break;
            }
          }
          uint64_t v31 = (std::__shared_weak_count *)i[1];
          if (v31) {
            unint64_t i = (uint64_t *)atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v90 = v31;
          uint64_t v32 = *(void *)(v2 + 552);
          if (v32)
          {
            unint64_t i = (uint64_t *)(v2 + 552);
            do
            {
              int v33 = *(_DWORD *)(v32 + 28);
              BOOL v34 = v33 < (int)v19;
              if (v33 >= (int)v19) {
                uint64_t v35 = (uint64_t *)v32;
              }
              else {
                uint64_t v35 = (uint64_t *)(v32 + 8);
              }
              if (!v34) {
                unint64_t i = (uint64_t *)v32;
              }
              uint64_t v32 = *v35;
            }
            while (*v35);
            if (i != (uint64_t *)(v2 + 552) && *((_DWORD *)i + 7) <= (int)v19 && *((_WORD *)i + 16)) {
              sub_1008F7704(v20, @"kCTMobileEquipmentInfoPRLVersion", *((unsigned __int16 *)i + 16), kCFAllocatorDefault);
            }
          }
          uint64_t v36 = *(void *)(v2 + 528);
          if (v36)
          {
            unint64_t i = (uint64_t *)(v2 + 528);
            do
            {
              int v37 = *(_DWORD *)(v36 + 32);
              BOOL v38 = v37 < (int)v19;
              if (v37 >= (int)v19) {
                __int16 v39 = (uint64_t *)v36;
              }
              else {
                __int16 v39 = (uint64_t *)(v36 + 8);
              }
              if (!v38) {
                unint64_t i = (uint64_t *)v36;
              }
              uint64_t v36 = *v39;
            }
            while (*v39);
            if (i != (uint64_t *)(v2 + 528) && *((_DWORD *)i + 8) <= (int)v19) {
              sub_1008F7470(v20, @"kCTMobileEquipmentInfoMIN", (uint64_t)(i + 5));
            }
          }
          ServiceMap = (std::mutex *)Registry::getServiceMap(i, *v3);
          unint64_t v41 = ServiceMap;
          if (v42 < 0)
          {
            uint64_t v43 = (unsigned __int8 *)(v42 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v44 = 5381;
            do
            {
              uint64_t v42 = v44;
              unsigned int v45 = *v43++;
              uint64_t v44 = (33 * v44) ^ v45;
            }
            while (v45);
          }
          std::mutex::lock(ServiceMap);
          *(void *)long long buf = v42;
          char v46 = sub_10004D37C(&v41[1].__m_.__sig, (unint64_t *)buf);
          if (v46)
          {
            uint64_t v87 = v20;
            uint64_t v48 = v46[3];
            uint64_t v47 = (std::__shared_weak_count *)v46[4];
            if (v47)
            {
              atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v41);
              atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
              long long v49 = v47;
              sub_10004D2C8(v47);
              char v89 = 0;
              char v20 = v87;
LABEL_85:
              CFStringRef v18 = @"kCTMobileEquipmentInfoIMEI";
              if (v48)
              {
                memset(buf, 0, sizeof(buf));
                (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v48 + 304))(buf, v48, v19);
                sub_1008F7470(v20, @"kCTMobileEquipmentInfoNAI", (uint64_t)buf);
                if ((char)buf[23] < 0) {
                  operator delete(*(void **)buf);
                }
              }
              if (*(_DWORD *)(v30 + 96) == 4)
              {
                v104[0] = 0;
                v104[1] = 0;
                uint64_t v105 = 0;
                sub_1008F751C(v2, v19, 12, (uint64_t)v104);
                sub_1008F7470(v20, @"kCTMobileEquipmentInfo1xIMSI", (uint64_t)v104);
                __p[0] = 0;
                __p[1] = 0;
                uint64_t v103 = 0;
                sub_1008F751C(v2, v19, 11, (uint64_t)__p);
                sub_1008F7470(v20, @"kCTMobileEquipmentInfoEUIMID", (uint64_t)__p);
                long long v51 = (std::mutex *)Registry::getServiceMap(v50, *v3);
                long long v52 = v51;
                if (v53 < 0)
                {
                  unint64_t v54 = (unsigned __int8 *)(v53 & 0x7FFFFFFFFFFFFFFFLL);
                  uint64_t v55 = 5381;
                  do
                  {
                    uint64_t v53 = v55;
                    unsigned int v56 = *v54++;
                    uint64_t v55 = (33 * v55) ^ v56;
                  }
                  while (v56);
                }
                std::mutex::lock(v51);
                *(void *)long long buf = v53;
                char v57 = sub_10004D37C(&v52[1].__m_.__sig, (unint64_t *)buf);
                if (v57)
                {
                  int v58 = v49;
                  uint64_t v60 = v57[3];
                  long long v59 = (std::__shared_weak_count *)v57[4];
                  if (v59)
                  {
                    long long v61 = v20;
                    long long v62 = v58;
                    atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
                    std::mutex::unlock(v52);
                    atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
                    char v63 = v62;
                    char v20 = v61;
                    uint64_t v64 = v59;
                    long long v49 = v63;
                    sub_10004D2C8(v64);
                    char v65 = 0;
                    goto LABEL_98;
                  }
                  long long v49 = v58;
                }
                else
                {
                  uint64_t v60 = 0;
                }
                std::mutex::unlock(v52);
                uint64_t v64 = 0;
                char v65 = 1;
LABEL_98:
                if (v60)
                {
                  char v88 = v65;
                  sub_10003E168(buf, (void *)(v2 + 8));
                  uint64_t v66 = *(void *)buf;
                  int64x2_t v67 = *(std::__shared_weak_count **)&buf[8];
                  uint64_t v98 = *(void *)buf;
                  uint64_t v99 = *(std::__shared_weak_count **)&buf[8];
                  if (*(void *)&buf[8])
                  {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v67);
                  }
                  long long v100 = v20;
                  dispatch_group_t group = v5;
                  if (v5)
                  {
                    dispatch_retain(v5);
                    dispatch_group_enter(v5);
                  }
                  char v107 = 0;
                  char v68 = operator new(0x28uLL);
                  *char v68 = off_101A19E28;
                  v68[1] = v66;
                  uint64_t v98 = 0;
                  uint64_t v99 = 0;
                  void v68[2] = v67;
                  void v68[3] = v20;
                  v68[4] = v5;
                  dispatch_group_t group = 0;
                  char v107 = v68;
                  (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v60 + 256))(v60, v19, buf);
                  sub_100912244(buf);
                  char v69 = group;
                  char v65 = v88;
                  if (group)
                  {
                    dispatch_group_leave(group);
                    dispatch_release(v69);
                  }
                  if (v99) {
                    std::__shared_weak_count::__release_weak(v99);
                  }
                }
                if ((v65 & 1) == 0) {
                  sub_10004D2C8(v64);
                }
                CFStringRef v18 = @"kCTMobileEquipmentInfoIMEI";
                if (SHIBYTE(v103) < 0) {
                  operator delete(__p[0]);
                }
                if (SHIBYTE(v105) < 0) {
                  operator delete(v104[0]);
                }
              }
              if ((v89 & 1) == 0) {
                sub_10004D2C8(v49);
              }
              if (v90) {
                sub_10004D2C8(v90);
              }
LABEL_117:
              if (v5)
              {
                dispatch_group_leave(v5);
                dispatch_release(v5);
                uint64_t v70 = v97;
                char v71 = *(__CFDictionary **)v96;
                dispatch_retain(v5);
                dispatch_group_enter(v5);
                if (v71)
                {
LABEL_119:
                  for (j = *(void **)(v2 + 168); j != *(void **)(v2 + 176); j += 2)
                  {
                    uint64_t v73 = *j;
                    if (*(_DWORD *)(*j + 36) == v70)
                    {
                      BOOL v76 = (std::__shared_weak_count *)j[1];
                      if (v76) {
                        atomic_fetch_add_explicit(&v76->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      if (*(_DWORD *)(v73 + 64) == 4)
                      {
                        memset(buf, 0, sizeof(buf));
                        sub_1008F751C(v2, v70, 3, (uint64_t)buf);
                        sub_1008F7470(v71, @"kCTMobileEquipmentInfoIMSI", (uint64_t)buf);
                        if ((char)buf[23] < 0) {
                          operator delete(*(void **)buf);
                        }
                      }
                      if (v76) {
                        sub_10004D2C8(v76);
                      }
LABEL_136:
                      if (v5)
                      {
                        dispatch_group_leave(v5);
                        dispatch_release(v5);
                        signed int v77 = v97;
                        CFDictionaryRef v78 = *(const __CFDictionary **)v96;
                        dispatch_retain(v5);
                        dispatch_group_enter(v5);
                        if (v78)
                        {
LABEL_138:
                          uint64_t v79 = *(void *)(v2 + 576);
                          if (v79)
                          {
                            uint64_t v80 = v2 + 576;
                            do
                            {
                              signed int v81 = *(_DWORD *)(v79 + 28);
                              BOOL v82 = v81 < v77;
                              if (v81 >= v77) {
                                uint64_t v83 = (uint64_t *)v79;
                              }
                              else {
                                uint64_t v83 = (uint64_t *)(v79 + 8);
                              }
                              if (!v82) {
                                uint64_t v80 = v79;
                              }
                              uint64_t v79 = *v83;
                            }
                            while (*v83);
                            if (v80 != v2 + 576 && *(_DWORD *)(v80 + 28) <= v77)
                            {
                              int v84 = *(_DWORD *)(v80 + 32);
                              if (v84 == 3)
                              {
                                sub_1008F7420(v78, @"kCTMobileEquipmentInfoMEID", @"kCTMobileEquipmentInfoCurrentMobileId");
                                CFStringRef v85 = @"kCTMobileEquipmentInfoCurrentSubscriberId";
                                if (!sub_1008F7420(v78, @"kCTMobileEquipmentInfoMIN", @"kCTMobileEquipmentInfoCurrentSubscriberId"))
                                {
                                  CFStringRef v18 = @"kCTMobileEquipmentInfo1xIMSI";
                                  goto LABEL_162;
                                }
                              }
                              else if ((v84 - 1) <= 1)
                              {
                                sub_1008F7420(v78, @"kCTMobileEquipmentInfoIMSI", @"kCTMobileEquipmentInfoCurrentSubscriberId");
                                CFStringRef v85 = @"kCTMobileEquipmentInfoCurrentMobileId";
LABEL_162:
                                sub_1008F7420(v78, v18, v85);
                              }
                            }
                          }
LABEL_154:
                          if (v5)
                          {
                            dispatch_group_leave(v5);
                            dispatch_release(v5);
                          }
                          char v12 = *(__CFDictionary **)v96;
                          uint64_t v93 = *(__CFDictionary **)v96;
                          *(void *)int v96 = 0;
                          if (SHIBYTE(v95) < 0) {
                            operator delete(v94[0]);
                          }
LABEL_158:
                          sub_10005717C((const void **)v96);
                          if (!v5)
                          {
LABEL_19:
                            *(void *)long long buf = v12;
                            if (v12) {
                              CFRetain(v12);
                            }
                            sub_10062B11C((uint64_t)&buf[8], v1 + 16);
                            operator new();
                          }
LABEL_18:
                          dispatch_group_leave(v5);
                          dispatch_release(v5);
                          goto LABEL_19;
                        }
                      }
                      else
                      {
                        signed int v77 = v97;
                        CFDictionaryRef v78 = *(const __CFDictionary **)v96;
                        if (*(void *)v96) {
                          goto LABEL_138;
                        }
                      }
                      uint64_t v86 = *(NSObject **)(v2 + 40);
                      if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "dict is null", buf, 2u);
                      }
                      goto LABEL_154;
                    }
                  }
                  char v74 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v70);
                  if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_136;
                  }
                  *(_WORD *)long long buf = 0;
                  char v75 = "Sim specific information not available";
LABEL_128:
                  _os_log_error_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_ERROR, v75, buf, 2u);
                  goto LABEL_136;
                }
              }
              else
              {
                uint64_t v70 = v97;
                char v71 = *(__CFDictionary **)v96;
                if (*(void *)v96) {
                  goto LABEL_119;
                }
              }
              char v74 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v70);
              if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
                goto LABEL_136;
              }
              *(_WORD *)long long buf = 0;
              char v75 = "dict is null";
              goto LABEL_128;
            }
            char v20 = v87;
          }
          else
          {
            uint64_t v48 = 0;
          }
          std::mutex::unlock(v41);
          long long v49 = 0;
          char v89 = 1;
          goto LABEL_85;
        }
        ++v9;
      }
      uint64_t v9 = (uint64_t *)*v9;
      if (!v9) {
        goto LABEL_16;
      }
    }
  }
  int v7 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid slot %s for copyMobileEquipmentInfo", buf, 0xCu);
  }
  *(void *)long long buf = 0;
  uint64_t v8 = *(void *)(v1 + 40);
  if (!v8) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v8 + 48))(v8, buf);
  sub_100057D78((const void **)buf);
  sub_10069ACF4(&v92);
  return sub_100046B58((uint64_t *)&v91);
}

void sub_10090B730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,const void *a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  if (v43)
  {
    dispatch_group_leave(v43);
    dispatch_release(v43);
  }
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_10005717C(&a26);
  if (v43)
  {
    dispatch_group_leave(v43);
    dispatch_release(v43);
    dispatch_group_leave(v43);
    dispatch_release(v43);
    dispatch_release(v43);
  }
  sub_10069ACF4(&a16);
  sub_100046B58(&a15);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090B914(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_10010E020((void *)(v1 + 8));
    sub_10005717C((const void **)v1);
    operator delete();
  }
  return result;
}

uint64_t *sub_10090B968(uint64_t a1)
{
  uint64_t v4 = a1;
  sub_10004EFE4(&v5, (CFTypeRef *)a1);
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, const void **))(*(void *)v2 + 48))(v2, &v5);
  sub_100057D78(&v5);
  return sub_10090B914(&v4);
}

void sub_10090B9E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10090BA0C(void **a1)
{
  uint64_t v1 = (void **)*a1;
  uint64_t v2 = (void *)**a1;
  CFTypeRef cf = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    CFTypeRef v4 = cf;
    CFTypeRef cf = Mutable;
    *(void *)long long buf = v4;
    sub_1000440D4((const void **)buf);
  }
  else
  {
    int v5 = v2[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to create CFMutableArraySharedRef", buf, 2u);
    }
    int v17 = 0;
    uint64_t v6 = v1[4];
    if (!v6) {
      sub_10007B600();
    }
    (*(void (**)(void *, const void **))(*v6 + 48))(v6, &v17);
    sub_100044D00(&v17);
  }
  int v7 = dispatch_group_create();
  subscriber::makeSimSlotRange();
  uint64_t v9 = *(unsigned int **)buf;
  uint64_t v8 = (unsigned int *)v20[0];
  if (*(void *)buf != v20[0])
  {
    int v10 = (uint64_t (*)(void))v20[1];
    do
    {
      if (v10(*v9)) {
        goto LABEL_12;
      }
      ++v9;
    }
    while (v9 != v8);
    uint64_t v9 = v8;
LABEL_12:
    uint64_t v11 = (unsigned int *)v20[0];
    while (v9 != v11)
    {
      uint64_t v12 = *v9;
      CFTypeRef v15 = cf;
      if (cf) {
        CFRetain(cf);
      }
      dispatch_group_t group = v7;
      if (v7 && (dispatch_retain(v7), group))
      {
        dispatch_group_enter(group);
        dispatch_group_t v13 = group;
      }
      else
      {
        dispatch_group_t v13 = 0;
      }
      v21[0] = off_101A19AE8;
      v21[1] = v15;
      CFTypeRef v15 = 0;
      dispatch_group_t group = 0;
      void v21[2] = v13;
      v21[3] = v21;
      (*(void (**)(void *, uint64_t, void *))(*v2 + 48))(v2, v12, v21);
      sub_10010E020(v21);
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
      sub_1000440D4(&v15);
      uint64_t v14 = v9 + 1;
      uint64_t v9 = v8;
      if (v14 != v8)
      {
        uint64_t v9 = v14;
        do
        {
          if (v10(*v9)) {
            goto LABEL_27;
          }
          ++v9;
        }
        while (v9 != v8);
        uint64_t v9 = v8;
      }
LABEL_27:
      ;
    }
  }
  *(void *)long long buf = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_1000332B4((uint64_t)v20, (uint64_t)(v1 + 1));
  operator new();
}

void sub_10090BD48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, dispatch_group_t group, uint64_t a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10090BDF8(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100033230((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10090BE48(uint64_t a1)
{
  *(void *)a1 = off_101A19AE8;
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3) {
      dispatch_release(v3);
    }
  }
  sub_1000440D4((const void **)(a1 + 8));
  return a1;
}

void sub_10090BEA8(uint64_t a1)
{
  *(void *)a1 = off_101A19AE8;
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3) {
      dispatch_release(v3);
    }
  }
  sub_1000440D4((const void **)(a1 + 8));

  operator delete();
}

void *sub_10090BF28(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x18uLL);
  *uint64_t v2 = off_101A19AE8;
  sub_10090C0AC((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_10090BF7C(uint64_t a1, void *a2)
{
  *a2 = off_101A19AE8;
  return sub_10090C0AC((uint64_t)(a2 + 1), a1 + 8);
}

const void **sub_10090BFA8(uint64_t a1)
{
  return sub_10090C0F4(a1 + 8);
}

void sub_10090BFB0(void *a1)
{
  sub_10090C0F4((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_10090BFEC(uint64_t a1, const void **a2)
{
  uint64_t v3 = *a2;
  uint64_t v6 = v3;
  *a2 = 0;
  if (v3) {
    CFTypeRef v4 = sub_100080778;
  }
  else {
    CFTypeRef v4 = 0;
  }
  if (v4) {
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 8), v3);
  }
  return sub_100057D78(&v6);
}

void sub_10090C04C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10090C060(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10090C0A0()
{
}

uint64_t sub_10090C0AC(uint64_t a1, uint64_t a2)
{
  sub_100687E80((const void **)a1, (const void **)a2);
  CFTypeRef v4 = *(NSObject **)(a2 + 8);
  *(void *)(a1 + 8) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    int v5 = *(NSObject **)(a1 + 8);
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  return a1;
}

const void **sub_10090C0F4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 8);
    if (v3) {
      dispatch_release(v3);
    }
  }

  return sub_1000440D4((const void **)a1);
}

uint64_t *sub_10090C140(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100033230((void *)(v1 + 8));
    sub_1000440D4((const void **)v1);
    operator delete();
  }
  return result;
}

uint64_t *sub_10090C194(uint64_t a1)
{
  uint64_t v4 = a1;
  sub_100044D6C(&v5, (CFTypeRef *)a1);
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, const void **))(*(void *)v2 + 48))(v2, &v5);
  sub_100044D00(&v5);
  return sub_10090C140(&v4);
}

void sub_10090C214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double sub_10090C238@<D0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v3 = **(void **)(a1 + 40);
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  uint64_t v4 = *(void *)(v3 + 504);
  if (v4)
  {
    uint64_t v5 = v3 + 504;
    uint64_t v6 = v3 + 504;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < 1;
      if (v7 >= 1) {
        uint64_t v9 = (uint64_t *)v4;
      }
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v6 != v5 && *(int *)(v6 + 32) <= 1)
    {
      std::string::basic_string(&v11, (const std::string *)(v6 + 40), 0, 8uLL, (std::allocator<char> *)&v12);
      double result = *(double *)&v11.__r_.__value_.__l.__data_;
      *a2 = v11;
    }
  }
  return result;
}

__n128 sub_10090C2D8(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

uint64_t sub_10090C33C(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = v1[2];
  __n128 v4 = (Registry **)(*(void *)v1 + 64);
  if (subscriber::isValidSimSlot())
  {
    for (unint64_t i = *(uint64_t **)(v2 + 168); i != *(uint64_t **)(v2 + 176); i += 2)
    {
      uint64_t v6 = *i;
      if (*(_DWORD *)(*i + 36) == v3)
      {
        std::string v11 = (std::__shared_weak_count *)i[1];
        if (v11) {
          unint64_t i = (uint64_t *)atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(i, *v4);
        dispatch_group_t v13 = ServiceMap;
        if (v14 < 0)
        {
          CFTypeRef v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v16 = 5381;
          do
          {
            uint64_t v14 = v16;
            unsigned int v17 = *v15++;
            uint64_t v16 = (33 * v16) ^ v17;
          }
          while (v17);
        }
        std::mutex::lock(ServiceMap);
        *(void *)&long long buf = v14;
        CFStringRef v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&buf);
        if (v18)
        {
          char v20 = (GestaltUtilityInterface *)v18[3];
          uint64_t v19 = (std::__shared_weak_count *)v18[4];
          if (v19)
          {
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v13);
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v19);
            char v21 = 0;
            goto LABEL_22;
          }
        }
        else
        {
          char v20 = 0;
        }
        std::mutex::unlock(v13);
        uint64_t v19 = 0;
        char v21 = 1;
LABEL_22:
        char isIPhone = GestaltUtilityInterface::isIPhone(v20);
        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
        if (isIPhone)
        {
LABEL_28:
          uint64_t isSimPresentAndValid = 1;
        }
        else
        {
          if (*(unsigned char *)(v6 + 58))
          {
            int v25 = **(NSObject ***)(v6 + 352);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Allow sim lock for pin protected sim", (uint8_t *)&buf, 2u);
            }
            goto LABEL_28;
          }
          if (*(_DWORD *)(v6 + 52) == 1)
          {
            sub_1013B85B4(v6, v22, v23);
            uint64_t isSimPresentAndValid = subscriber::isSimPresentAndValid();
            v58[0] = isSimPresentAndValid;
            char v26 = **(NSObject ***)(v6 + 352);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v28 = printers::asString((printers *)v58, v27);
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v28;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Allow SIM lock for 4FF: %s", (uint8_t *)&buf, 0xCu);
              uint64_t isSimPresentAndValid = v58[0] != 0;
            }
            goto LABEL_29;
          }
          sub_1013B85B4(v6, v22, v23);
          if (subscriber::isSimReadyOrLocked())
          {
            long long buf = 0uLL;
            uint64_t v60 = 0;
            sub_1013B7E2C(v6, v29, (uint64_t)&buf);
            uint64_t v30 = *(void **)(v2 + 896);
            if (!v30) {
              goto LABEL_50;
            }
            uint64_t v31 = (void *)(v2 + 896);
            do
            {
              char v32 = sub_100046FE8(v30 + 4, (void **)&buf);
              if (v32 >= 0) {
                int v33 = v30;
              }
              else {
                int v33 = v30 + 1;
              }
              if (v32 >= 0) {
                uint64_t v31 = v30;
              }
              uint64_t v30 = (void *)*v33;
            }
            while (*v33);
            if (v31 == (void *)(v2 + 896) || (sub_100046FE8(&buf, (void **)v31 + 4) & 0x80) != 0)
            {
LABEL_50:
              long long v40 = **(NSObject ***)(v6 + 352);
              if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)int v58 = 0;
                int v37 = "#I Allow sim pin lock while initial active state is unknown";
                BOOL v38 = v40;
                uint32_t v39 = 2;
LABEL_52:
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, v58, v39);
              }
LABEL_53:
              uint64_t isSimPresentAndValid = 1;
            }
            else
            {
              BOOL v34 = v31 + 7;
              if (!*((unsigned char *)v31 + 57) || (uint64_t v35 = (uint64_t *)*v34, *v34))
              {
                uint64_t v36 = **(NSObject ***)(v6 + 352);
                if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)int v58 = 136315138;
                  *(void *)&_DWORD v58[4] = printers::asString();
                  int v37 = "#I Allow sim pin lock as per initial active state (%s)";
                  BOOL v38 = v36;
                  uint32_t v39 = 12;
                  goto LABEL_52;
                }
                goto LABEL_53;
              }
              char v57 = 0;
              unint64_t v41 = (std::mutex *)Registry::getServiceMap(v35, *v4);
              uint64_t v42 = v41;
              if (v43 < 0)
              {
                uint64_t v44 = (unsigned __int8 *)(v43 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v45 = 5381;
                do
                {
                  uint64_t v43 = v45;
                  unsigned int v46 = *v44++;
                  uint64_t v45 = (33 * v45) ^ v46;
                }
                while (v46);
              }
              std::mutex::lock(v41);
              *(void *)int v58 = v43;
              uint64_t v47 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)v58);
              if (v47)
              {
                uint64_t v49 = v47[3];
                uint64_t v48 = (std::__shared_weak_count *)v47[4];
                if (v48)
                {
                  atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v42);
                  atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v48);
                  char v50 = 0;
                  goto LABEL_64;
                }
              }
              else
              {
                uint64_t v49 = 0;
              }
              std::mutex::unlock(v42);
              uint64_t v48 = 0;
              char v50 = 1;
LABEL_64:
              (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v49 + 80))(&v56, v49, v3, 1, @"AllowESIMLock", 0, 0);
              sub_1000057AC(&v57, &v56);
              sub_1000577C4(&v56);
              if ((v50 & 1) == 0) {
                sub_10004D2C8(v48);
              }
              if (v57) {
                long long v52 = sub_100084B4C;
              }
              else {
                long long v52 = 0;
              }
              if (v52)
              {
                v58[0] = 0;
                ctu::cf::assign((ctu::cf *)v58, v57, v51);
                int v53 = v58[0];
                uint64_t isSimPresentAndValid = v58[0] != 0;
                unint64_t v54 = **(NSObject ***)(v6 + 352);
                if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v55 = "disabled";
                  if (v53) {
                    uint64_t v55 = "enabled";
                  }
                  *(_DWORD *)int v58 = 136315138;
                  *(void *)&_DWORD v58[4] = v55;
                  _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Carrier override to allow eSIM pin lock is (%s)", v58, 0xCu);
                }
              }
              else
              {
                uint64_t isSimPresentAndValid = 0;
              }
              sub_100062778((const void **)&v57);
            }
            if (SHIBYTE(v60) < 0) {
              operator delete((void *)buf);
            }
            goto LABEL_29;
          }
          uint64_t isSimPresentAndValid = 0;
        }
LABEL_29:
        if (v11) {
          sub_10004D2C8(v11);
        }
        return isSimPresentAndValid;
      }
    }
    BOOL v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
    uint64_t isSimPresentAndValid = 0;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      return isSimPresentAndValid;
    }
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Sim Info not found", (uint8_t *)&buf, 2u);
  }
  else
  {
    int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid sim slot", (uint8_t *)&buf, 2u);
    }
  }
  return 0;
}

void sub_10090C964(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  sub_100062778(&a10);
  if (a18 < 0) {
    operator delete(__p);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(a1);
}

void sub_10090CA08()
{
}

void *sub_10090CA1C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A19C28;
  result[1] = v3;
  return result;
}

uint64_t sub_10090CA64(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A19C28;
  a2[1] = v2;
  return result;
}

uint64_t sub_10090CA90(uint64_t a1, unsigned __int16 *a2)
{
  unsigned int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  __n128 v4 = *(NSObject **)(v3 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v2 >= 0x100)
  {
    if (v5)
    {
      v7[0] = 67109120;
      v7[1] = v2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I queryIfPinEnabled=%d", (uint8_t *)v7, 8u);
    }
    return (*(uint64_t (**)(void, BOOL))(**(void **)(v3 + 120) + 64))(*(void *)(v3 + 120), v2 != 0);
  }
  else
  {
    if (v5)
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I queryIfPinEnabled failed because not ready yet", (uint8_t *)v7, 2u);
    }
    return (*(uint64_t (**)(void))(**(void **)(v3 + 120) + 72))(*(void *)(v3 + 120));
  }
}

uint64_t sub_10090CBD4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10090CC14()
{
}

uint64_t *sub_10090CC20(unsigned int **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  std::string v11 = v1;
  uint64_t v2 = v1[10];
  for (unint64_t i = *(void **)(*(void *)v1 + 168); i != *(void **)(*(void *)v1 + 176); i += 2)
  {
    uint64_t v4 = *i;
    if (*(_DWORD *)(*i + 36) == v2)
    {
      BOOL v8 = (std::__shared_weak_count *)i[1];
      if (v8)
      {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        __int16 v7 = *(unsigned char *)(v4 + 58) != 0;
        sub_10004D2C8(v8);
      }
      else
      {
        __int16 v7 = *(unsigned char *)(v4 + 58) != 0;
      }
      __int16 v6 = 256;
      goto LABEL_12;
    }
  }
  BOOL v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v1 + 56) + 16))(*(void *)(*(void *)v1 + 56), v2);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Sim Info not found", buf, 2u);
  }
  __int16 v6 = 0;
  __int16 v7 = 0;
LABEL_12:
  sub_100335978((uint64_t)(v1 + 2), v6 | v7);
  sub_10090CD5C((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_10090CD40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10090CD5C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1000F25E0((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_10090CDAC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFTypeRef v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  int v4 = *(unsigned __int8 *)(v1 + 12);
  if (*(char *)(v1 + 39) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 16), *(void *)(v1 + 24));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(v1 + 16);
    uint64_t v18 = *(void *)(v1 + 32);
  }
  for (unint64_t i = *(uint64_t **)(v2 + 168); ; i += 2)
  {
    if (i == *(uint64_t **)(v2 + 176))
    {
      __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Cannot find SIM", buf, 2u);
      }
      BOOL v8 = 0;
      goto LABEL_11;
    }
    uint64_t v6 = *i;
    if (*(_DWORD *)(*i + 36) == v3) {
      break;
    }
  }
  BOOL v8 = (std::__shared_weak_count *)i[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if ((subscriber::isValidPin() & 1) == 0)
  {
    char v12 = **(NSObject ***)(v6 + 352);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "PIN unlock skipped: invalid size or characters #sim-pin", buf, 2u);
    }
    goto LABEL_11;
  }
  v23[0] = v6;
  v23[1] = (uint64_t)v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v11 = sub_1008FB5E0(v2, v23, v10);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if ((v11 & 1) == 0)
  {
    dispatch_group_t v13 = **(NSObject ***)(v6 + 352);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I PIN Enable not allowed; skipping",
        buf,
        2u);
    }
    goto LABEL_11;
  }
  *(_OWORD *)char v21 = 0u;
  long long v22 = 0u;
  *(_OWORD *)long long buf = 0u;
  sub_1013B8918(v6, 1, (uint64_t)buf);
  if (!BYTE8(v22))
  {
    uint64_t v14 = **(NSObject ***)(v6 + 352);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v19 = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Cannot create SIM card info", v19, 2u);
    }
LABEL_11:
    (*(void (**)(void, uint64_t))(**(void **)(v2 + 120) + 88))(*(void *)(v2 + 120), v3);
    goto LABEL_12;
  }
  (*(void (**)(void, uint8_t *, BOOL, void **))(**(void **)(v2 + 104) + 96))(*(void *)(v2 + 104), buf, v4 != 0, __p);
  if (BYTE8(v22) && v21[0])
  {
    v21[1] = v21[0];
    operator delete(v21[0]);
  }
LABEL_12:
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[0]);
  }
  sub_10090D148(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_10090D0C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,char a25)
{
  if (a25 && __p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_10090D148(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090D148(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10090D1A0(unsigned int **a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = *a1;
  unint64_t v29 = a1;
  uint64_t v30 = v3;
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = v3[2];
  for (unint64_t i = *(uint64_t **)(*(void *)v3 + 168); ; i += 2)
  {
    if (i == *(uint64_t **)(*(void *)v3 + 176))
    {
      BOOL v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 56) + 16))(*(void *)(v4 + 56), v5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Cannot find SIM", buf, 2u);
      }
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = *(void *)(v4 + 120);
      uint64_t v12 = v3[2];
      char v13 = -1;
      goto LABEL_8;
    }
    uint64_t v7 = *i;
    if (*(_DWORD *)(*i + 36) == v5) {
      break;
    }
  }
  uint64_t v9 = (std::__shared_weak_count *)i[1];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (sub_1013B85B4(v7, v5, a3) == 1)
  {
    sub_1013B7DAC(v7, 0);
    CFTypeRef v15 = **(NSObject ***)(v7 + 352);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v16 = "#I Clear sim pin in progress flag";
      goto LABEL_17;
    }
    goto LABEL_9;
  }
  if (*(unsigned char *)(v7 + 312))
  {
    unsigned int v17 = **(NSObject ***)(v7 + 352);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "PIN unlock in progess : skip this attempt", buf, 2u);
    }
    goto LABEL_9;
  }
  if ((subscriber::isValidPin() & 1) == 0)
  {
    char v20 = **(NSObject ***)(v7 + 352);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "PIN unlock skipped: invalid size or characters #sim-pin", buf, 2u);
    }
    uint64_t v11 = *(void *)(v4 + 120);
    uint64_t v12 = v3[2];
    uint64_t v10 = sub_1013B85B4(v7, v21, v22);
    char v13 = *(unsigned char *)(v7 + 59);
LABEL_8:
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v11 + 40))(v11, v12, v10, v13);
    goto LABEL_9;
  }
  if (sub_1013B85B4(v7, v18, v19) == 3)
  {
    *(_OWORD *)long long __p = 0u;
    long long v34 = 0u;
    *(_OWORD *)long long buf = 0u;
    sub_1013B8918(v7, 1, (uint64_t)buf);
    if (BYTE8(v34))
    {
      sub_1013B7DAC(v7, 1);
      (*(void (**)(void, uint8_t *, unsigned int *))(**(void **)(v4 + 104) + 72))(*(void *)(v4 + 104), buf, v3 + 4);
      if (BYTE8(v34) && __p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
    }
    else
    {
      unint64_t v23 = **(NSObject ***)(v7 + 352);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v31 = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Cannot create SIM card info", v31, 2u);
      }
      uint64_t v26 = *(void *)(v4 + 120);
      uint64_t v27 = v3[2];
      uint64_t v28 = sub_1013B85B4(v7, v24, v25);
      (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v26 + 40))(v26, v27, v28, *(char *)(v7 + 59));
    }
  }
  else
  {
    CFTypeRef v15 = **(NSObject ***)(v7 + 352);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v16 = "#I PIN unlock skipped, SIM is not locked #sim-pin";
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v16, buf, 2u);
    }
  }
LABEL_9:
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_100101068((uint64_t *)&v30);
  return sub_100046B58((uint64_t *)&v29);
}

void sub_10090D540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, char a18)
{
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_100101068(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090D594(unsigned int **a1)
{
  uint64_t v1 = *a1;
  unint64_t v22 = a1;
  unint64_t v23 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = v1[2];
  for (unint64_t i = *(uint64_t **)(*(void *)v1 + 168); ; i += 2)
  {
    if (i == *(uint64_t **)(*(void *)v1 + 176))
    {
      uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Cannot find SIM", buf, 2u);
      }
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      uint64_t v9 = *(void *)(v2 + 120);
      uint64_t v10 = v1[2];
      char v11 = -1;
      goto LABEL_19;
    }
    uint64_t v5 = *i;
    if (*(_DWORD *)(*i + 36) == v3) {
      break;
    }
  }
  uint64_t v7 = (std::__shared_weak_count *)i[1];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!subscriber::isValidPuk() || (subscriber::isValidPin() & 1) == 0)
  {
    uint64_t v12 = **(NSObject ***)(v5 + 352);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I PUK unlock skipped: invalid size or characters for puk/pin #sim-pin", buf, 2u);
    }
    uint64_t v9 = *(void *)(v2 + 120);
    uint64_t v10 = v1[2];
    uint64_t v8 = sub_1013B85B4(v5, v13, v14);
    char v11 = *(unsigned char *)(v5 + 60);
LABEL_19:
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v9 + 56))(v9, v10, v8, v11);
    goto LABEL_20;
  }
  *(_OWORD *)long long __p = 0u;
  long long v27 = 0u;
  *(_OWORD *)long long buf = 0u;
  sub_1013B8918(v5, 1, (uint64_t)buf);
  if (BYTE8(v27))
  {
    (*(void (**)(void, uint8_t *, unsigned int *, unsigned int *))(**(void **)(v2 + 104) + 80))(*(void *)(v2 + 104), buf, v1 + 4, v1 + 10);
    if (BYTE8(v27) && __p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v16 = **(NSObject ***)(v5 + 352);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v24 = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Cannot create SIM card info", v24, 2u);
    }
    uint64_t v19 = *(void *)(v2 + 120);
    uint64_t v20 = v1[2];
    uint64_t v21 = sub_1013B85B4(v5, v17, v18);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v19 + 56))(v19, v20, v21, *(char *)(v5 + 60));
  }
LABEL_20:
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_10090D8A0((uint64_t *)&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_10090D84C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, char a18)
{
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_10090D8A0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090D8A0(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10090D908(unsigned int **a1)
{
  uint64_t v1 = *a1;
  unint64_t v14 = a1;
  CFTypeRef v15 = v1;
  uint64_t v2 = *(void ***)v1;
  uint64_t v3 = v1[2];
  for (unint64_t i = *(uint64_t **)(*(void *)v1 + 168); i != *(uint64_t **)(*(void *)v1 + 176); i += 2)
  {
    uint64_t v5 = *i;
    if (*(_DWORD *)(*i + 36) == v3)
    {
      uint64_t v7 = (std::__shared_weak_count *)i[1];
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if subscriber::isValidPin() && (subscriber::isValidPin())
      {
        v21[0] = v5;
        v21[1] = (uint64_t)v7;
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        char v9 = sub_1008FB5E0((uint64_t)v2, v21, v8);
        if (v7) {
          sub_10004D2C8(v7);
        }
        if (v9)
        {
          *(_OWORD *)long long __p = 0u;
          long long v20 = 0u;
          *(_OWORD *)long long buf = 0u;
          sub_1013B8918(v5, 1, (uint64_t)buf);
          if (BYTE8(v20))
          {
            (*(void (**)(void *, uint8_t *, unsigned int *, unsigned int *))(*v2[13] + 88))(v2[13], buf, v1 + 4, v1 + 10);
            if (BYTE8(v20) && __p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
          }
          else
          {
            uint64_t v13 = **(NSObject ***)(v5 + 352);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v16 = 0;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Cannot create SIM card info", v16, 2u);
            }
            (*(void (**)(void *, void, uint64_t))(*v2[15] + 104))(v2[15], v1[2], 38);
            *(_DWORD *)uint64_t v16 = *(_DWORD *)(v5 + 36);
            int v17 = 38;
            sub_1008FB82C((uint64_t)(v2 + 10), (int *)v16);
          }
        }
        else
        {
          uint64_t v12 = **(NSObject ***)(v5 + 352);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I PIN Change not allowed; skipping",
              buf,
              2u);
          }
          (*(void (**)(void *, void, uint64_t))(*v2[15] + 104))(v2[15], v1[2], 38);
          *(_DWORD *)long long buf = *(_DWORD *)(v5 + 36);
          *(_DWORD *)&uint8_t buf[4] = 38;
          sub_1008FB82C((uint64_t)(v2 + 10), (int *)buf);
        }
      }
      else
      {
        uint64_t v10 = **(NSObject ***)(v5 + 352);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I PIN change skipped: invalid size or characters #sim-pin", buf, 2u);
        }
        (*(void (**)(void *, void, uint64_t))(*v2[15] + 104))(v2[15], v1[2], 40);
        *(_DWORD *)long long buf = *(_DWORD *)(v5 + 36);
        *(_DWORD *)&uint8_t buf[4] = 40;
        sub_1008FB82C((uint64_t)(v2 + 10), (int *)buf);
      }
      if (v7) {
        sub_10004D2C8(v7);
      }
      goto LABEL_26;
    }
  }
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[7] + 16))(v2[7], v3);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Cannot find SIM", buf, 2u);
  }
  (*(void (**)(void *, void, uint64_t))(*v2[15] + 104))(v2[15], v1[2], 38);
  *(_DWORD *)long long buf = v1[2];
  *(_DWORD *)&uint8_t buf[4] = 38;
  sub_1008FB82C((uint64_t)(v2 + 10), (int *)buf);
LABEL_26:
  sub_10045E6BC((uint64_t *)&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_10090DCC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, char a18)
{
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_10045E6BC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090DD40(unsigned int **a1)
{
  uint64_t v1 = *a1;
  char v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = v1[10];
  for (unint64_t i = *(void **)(*(void *)v1 + 168); i != *(void **)(*(void *)v1 + 176); i += 2)
  {
    uint64_t v4 = *i;
    if (*(_DWORD *)(*i + 36) == v2)
    {
      uint64_t v7 = (std::__shared_weak_count *)i[1];
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        int v6 = *(unsigned __int8 *)(v4 + 59);
        sub_10004D2C8(v7);
      }
      else
      {
        int v6 = *(unsigned __int8 *)(v4 + 59);
      }
      goto LABEL_11;
    }
  }
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v1 + 56) + 16))(*(void *)(*(void *)v1 + 56), v2);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Sim Info not found", buf, 2u);
  }
  int v6 = 255;
LABEL_11:
  sub_100356304((uint64_t)(v1 + 2), v6);
  sub_10090DE60((uint64_t *)&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_10090DE44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10090DE60(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1000F8E94((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_10090DEB0(unsigned int **a1)
{
  uint64_t v1 = *a1;
  char v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = v1[10];
  for (unint64_t i = *(void **)(*(void *)v1 + 168); i != *(void **)(*(void *)v1 + 176); i += 2)
  {
    uint64_t v4 = *i;
    if (*(_DWORD *)(*i + 36) == v2)
    {
      uint64_t v7 = (std::__shared_weak_count *)i[1];
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        int v6 = *(unsigned __int8 *)(v4 + 60);
        sub_10004D2C8(v7);
      }
      else
      {
        int v6 = *(unsigned __int8 *)(v4 + 60);
      }
      goto LABEL_11;
    }
  }
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v1 + 56) + 16))(*(void *)(*(void *)v1 + 56), v2);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Sim Info not found", buf, 2u);
  }
  int v6 = 255;
LABEL_11:
  sub_100356304((uint64_t)(v1 + 2), v6);
  sub_10090DE60((uint64_t *)&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_10090DFB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_10090DFD0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_10090E068(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_10090E0E8(void **a1)
{
  uint64_t v1 = *a1;
  char v114 = a1;
  uint64_t v115 = v1;
  uint64_t v2 = (void *)*v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Queuing auth request", buf, 2u);
  }
  *(void *)long long buf = v1[1];
  sub_10026E7F8((uint64_t *)&v117, (uint64_t)(v1 + 2));
  sub_10090DFD0((uint64_t)v120, (uint64_t)(v1 + 5));
  uint64_t v4 = (char *)v2[95];
  uint64_t v5 = (char *)v2[94];
  uint64_t v6 = v4 - v5;
  if (v4 == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 8 * (v4 - v5) - 1;
  }
  unint64_t v8 = v2[97];
  if (v7 == v2[98] + v8)
  {
    BOOL v9 = v8 >= 0x40;
    unint64_t v10 = v8 - 64;
    if (v9)
    {
      v2[97] = v10;
      uint64_t v13 = *(void *)v5;
      char v11 = v5 + 8;
      uint64_t v12 = v13;
      v2[94] = v11;
      if (v4 == (char *)v2[96])
      {
        unint64_t v14 = v2[93];
        uint64_t v15 = (uint64_t)&v11[-v14];
        if ((unint64_t)v11 <= v14)
        {
          uint64_t v41 = (uint64_t)&v4[-v14];
          BOOL v40 = v41 == 0;
          uint64_t v42 = v41 >> 2;
          if (v40) {
            unint64_t v43 = 1;
          }
          else {
            unint64_t v43 = v42;
          }
          uint64_t v44 = (char *)sub_100048350(v43);
          unsigned int v46 = &v44[8 * (v43 >> 2)];
          uint64_t v47 = (uint64_t *)v2[94];
          uint64_t v4 = v46;
          uint64_t v48 = v2[95] - (void)v47;
          if (v48)
          {
            uint64_t v4 = &v46[v48 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v49 = 8 * (v48 >> 3);
            char v50 = &v44[8 * (v43 >> 2)];
            do
            {
              uint64_t v51 = *v47++;
              *(void *)char v50 = v51;
              v50 += 8;
              v49 -= 8;
            }
            while (v49);
          }
          long long v52 = (void *)v2[93];
          v2[93] = v44;
          v2[94] = v46;
          v2[95] = v4;
          v2[96] = &v44[8 * v45];
          if (v52)
          {
            operator delete(v52);
            uint64_t v4 = (char *)v2[95];
          }
        }
        else
        {
          uint64_t v16 = v15 >> 3;
          BOOL v17 = v15 >> 3 < -1;
          uint64_t v18 = (v15 >> 3) + 2;
          if (v17) {
            uint64_t v19 = v18;
          }
          else {
            uint64_t v19 = v16 + 1;
          }
          uint64_t v20 = -(v19 >> 1);
          uint64_t v21 = v19 >> 1;
          unint64_t v22 = &v11[-8 * v21];
          int64_t v23 = v4 - v11;
          if (v4 != v11)
          {
            memmove(&v11[-8 * v21], v11, v4 - v11);
            uint64_t v4 = (char *)v2[94];
          }
          uint64_t v24 = &v4[8 * v20];
          uint64_t v4 = &v22[v23];
          v2[95] = &v22[v23];
          v2[94] = v24;
        }
      }
      *(void *)uint64_t v4 = v12;
    }
    else
    {
      uint64_t v25 = v6 >> 3;
      uint64_t v26 = (char *)v2[96];
      long long v27 = (char *)v2[93];
      if (v6 >> 3 >= (unint64_t)((v26 - v27) >> 3))
      {
        if (v26 == v27) {
          unint64_t v30 = 1;
        }
        else {
          unint64_t v30 = (v26 - v27) >> 2;
        }
        uint64_t v31 = (char *)sub_100048350(v30);
        uint64_t v33 = v32;
        long long v34 = operator new(0x1000uLL);
        uint64_t v35 = &v31[8 * v25];
        uint64_t v36 = &v31[8 * v33];
        if (v25 == v33)
        {
          uint64_t v37 = 8 * v25;
          if (v6 < 1)
          {
            signed int v81 = v34;
            uint64_t v82 = v37 >> 2;
            if (v4 == v5) {
              unint64_t v83 = 1;
            }
            else {
              unint64_t v83 = v82;
            }
            int v84 = (char *)sub_100048350(v83);
            uint64_t v35 = &v84[8 * (v83 >> 2)];
            uint64_t v36 = &v84[8 * v85];
            if (v31) {
              operator delete(v31);
            }
            uint64_t v31 = v84;
            long long v34 = v81;
          }
          else
          {
            uint64_t v38 = v37 >> 3;
            if (v38 >= -1) {
              unint64_t v39 = v38 + 1;
            }
            else {
              unint64_t v39 = v38 + 2;
            }
            v35 -= 8 * (v39 >> 1);
          }
        }
        *(void *)uint64_t v35 = v34;
        uint64_t v4 = v35 + 8;
        for (uint64_t i = v2[95]; i != v2[94]; i -= 8)
        {
          if (v35 == v31)
          {
            if (v4 >= v36)
            {
              if (v36 == v31) {
                unint64_t v91 = 1;
              }
              else {
                unint64_t v91 = (v36 - v31) >> 2;
              }
              uint64_t v92 = (char *)sub_100048350(v91);
              long long v94 = v92;
              uint64_t v35 = &v92[(2 * v91 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v95 = v4 - v31;
              BOOL v40 = v4 == v31;
              uint64_t v4 = v35;
              if (!v40)
              {
                uint64_t v4 = &v35[v95 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v96 = 8 * (v95 >> 3);
                unsigned int v97 = v35;
                uint64_t v98 = v31;
                do
                {
                  uint64_t v99 = *(void *)v98;
                  v98 += 8;
                  *(void *)unsigned int v97 = v99;
                  v97 += 8;
                  v96 -= 8;
                }
                while (v96);
              }
              uint64_t v36 = &v92[8 * v93];
              if (v31) {
                operator delete(v31);
              }
              uint64_t v31 = v94;
            }
            else
            {
              uint64_t v87 = (v36 - v4) >> 3;
              if (v87 >= -1) {
                uint64_t v88 = v87 + 1;
              }
              else {
                uint64_t v88 = v87 + 2;
              }
              uint64_t v89 = v88 >> 1;
              uint64_t v35 = &v31[8 * (v88 >> 1)];
              uint64_t v90 = v31;
              if (v4 != v31)
              {
                memmove(v35, v31, v4 - v31);
                uint64_t v90 = v4;
              }
              uint64_t v4 = &v90[8 * v89];
            }
          }
          uint64_t v100 = *(void *)(i - 8);
          *((void *)v35 - 1) = v100;
          v35 -= 8;
        }
        uint64_t v101 = (void *)v2[93];
        v2[93] = v31;
        v2[94] = v35;
        v2[95] = v4;
        v2[96] = v36;
        if (v101)
        {
          operator delete(v101);
          uint64_t v4 = (char *)v2[95];
        }
        goto LABEL_39;
      }
      uint64_t v28 = operator new(0x1000uLL);
      unint64_t v29 = v28;
      if (v26 == v4)
      {
        if (v5 == v27)
        {
          if (v4 == v5) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v26 - v5) >> 2;
          }
          uint64_t v60 = (char *)sub_100048350(v59);
          uint64_t v5 = &v60[(2 * v59 + 6) & 0xFFFFFFFFFFFFFFF8];
          long long v62 = (uint64_t *)v2[94];
          char v63 = v5;
          uint64_t v64 = v2[95] - (void)v62;
          if (v64)
          {
            char v63 = &v5[v64 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v65 = 8 * (v64 >> 3);
            uint64_t v66 = &v60[(2 * v59 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v67 = *v62++;
              *(void *)uint64_t v66 = v67;
              v66 += 8;
              v65 -= 8;
            }
            while (v65);
          }
          char v68 = (void *)v2[93];
          v2[93] = v60;
          v2[94] = v5;
          v2[95] = v63;
          v2[96] = &v60[8 * v61];
          if (v68)
          {
            operator delete(v68);
            uint64_t v5 = (char *)v2[94];
          }
        }
        *((void *)v5 - 1) = v29;
        char v69 = (char *)v2[94];
        v2[94] = v69 - 8;
        uint64_t v70 = *((void *)v69 - 1);
        v2[94] = v69;
        char v71 = (char *)v2[95];
        if (v71 == (char *)v2[96])
        {
          unint64_t v72 = v2[93];
          uint64_t v73 = (uint64_t)&v69[-v72];
          if ((unint64_t)v69 <= v72)
          {
            uint64_t v102 = (uint64_t)&v71[-v72];
            BOOL v40 = v102 == 0;
            uint64_t v103 = v102 >> 2;
            if (v40) {
              unint64_t v104 = 1;
            }
            else {
              unint64_t v104 = v103;
            }
            uint64_t v105 = (char *)sub_100048350(v104);
            char v107 = &v105[8 * (v104 >> 2)];
            char v108 = (uint64_t *)v2[94];
            char v71 = v107;
            uint64_t v109 = v2[95] - (void)v108;
            if (v109)
            {
              char v71 = &v107[v109 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v110 = 8 * (v109 >> 3);
              char v111 = &v105[8 * (v104 >> 2)];
              do
              {
                uint64_t v112 = *v108++;
                *(void *)char v111 = v112;
                v111 += 8;
                v110 -= 8;
              }
              while (v110);
            }
            char v113 = (void *)v2[93];
            v2[93] = v105;
            v2[94] = v107;
            v2[95] = v71;
            v2[96] = &v105[8 * v106];
            if (v113)
            {
              operator delete(v113);
              char v71 = (char *)v2[95];
            }
          }
          else
          {
            uint64_t v74 = v73 >> 3;
            BOOL v17 = v73 >> 3 < -1;
            uint64_t v75 = (v73 >> 3) + 2;
            if (v17) {
              uint64_t v76 = v75;
            }
            else {
              uint64_t v76 = v74 + 1;
            }
            uint64_t v77 = -(v76 >> 1);
            uint64_t v78 = v76 >> 1;
            uint64_t v79 = &v69[-8 * v78];
            int64_t v80 = v71 - v69;
            if (v71 != v69)
            {
              memmove(&v69[-8 * v78], v69, v71 - v69);
              char v69 = (char *)v2[94];
            }
            char v71 = &v79[v80];
            v2[95] = &v79[v80];
            v2[94] = &v69[8 * v77];
          }
        }
        *(void *)char v71 = v70;
      }
      else
      {
        *(void *)uint64_t v4 = v28;
      }
    }
    uint64_t v4 = (char *)(v2[95] + 8);
    v2[95] = v4;
LABEL_39:
    uint64_t v5 = (char *)v2[94];
  }
  if (v4 == v5)
  {
    unint64_t v54 = 0;
  }
  else
  {
    unint64_t v53 = v2[98] + v2[97];
    unint64_t v54 = (void *)(*(void *)&v5[(v53 >> 3) & 0x1FFFFFFFFFFFFFF8] + ((v53 & 0x3F) << 6));
  }
  void *v54 = *(void *)buf;
  v54[1] = v117;
  uint64_t v55 = v118;
  uint64_t v54[2] = v118;
  unsigned int v56 = v54 + 2;
  uint64_t v57 = v119;
  v54[3] = v119;
  if (v57)
  {
    v55[2] = v56;
    uint64_t v117 = &v118;
    char v118 = 0;
    uint64_t v119 = 0;
  }
  else
  {
    v54[1] = v56;
  }
  sub_10090E068((uint64_t)(v54 + 4), (uint64_t)v120);
  ++v2[98];
  sub_100273F20(v120);
  sub_10026CF54((uint64_t)&v117, v118);
  sub_1008F9CE0((uint64_t)v2);
  sub_10090E7A0((uint64_t *)&v115);
  return sub_100046B58((uint64_t *)&v114);
}

void sub_10090E72C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  operator delete(v15);
  if (v17) {
    operator delete(v17);
  }
  sub_100273F20(v16);
  sub_10026CF54(a10, a15);
  sub_10090E7A0(&a12);
  sub_100046B58(&a11);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090E7A0(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100273F20((void *)(v1 + 40));
    sub_10026CF54(v1 + 16, *(void **)(v1 + 24));
    operator delete();
  }
  return result;
}

uint64_t sub_10090E7FC(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = (int *)(a2 + 1);
  uint64_t v5 = (int *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      sub_100602B88((uint64_t **)a1, v3, v5 + 7, v5 + 7);
      uint64_t v6 = (int *)*((void *)v5 + 1);
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = *(int **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (int *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
    }
    while (v7 != v4);
  }
  return a1;
}

void sub_10090E894(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_10090E8AC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void **)(*(void *)v1 + 168);
  uint64_t v4 = *(void **)(*(void *)v1 + 176);
  if (v3 != v4)
  {
    uint64_t v5 = (void *)(v1 + 8);
    do
    {
      if (*(_DWORD *)(*v3 + 36))
      {
        uint64_t v6 = (std::__shared_weak_count *)v3[1];
        v10[0] = *v3;
        v10[1] = (uint64_t)v6;
        if (v6) {
          atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1008FAE2C(v2, v10, v5);
        if (v6) {
          sub_10004D2C8(v6);
        }
      }
      v3 += 2;
    }
    while (v3 != v4);
  }
  sub_1001B6160(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_10090E958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1001B6160(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090E980(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(uint64_t **)(*(void *)v1 + 168);
  uint64_t v4 = *(uint64_t **)(*(void *)v1 + 176);
  if (v3 != v4)
  {
    while (1)
    {
      uint64_t v5 = *v3;
      if (*(_DWORD *)(*v3 + 36) == *(_DWORD *)(v1 + 8)) {
        break;
      }
      v3 += 2;
      if (v3 == v4) {
        goto LABEL_9;
      }
    }
    uint64_t v6 = (std::__shared_weak_count *)v3[1];
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v10[0] = v5;
    v10[1] = (uint64_t)v6;
    sub_1008FAE2C(v2, v10, (void *)(v1 + 16));
    if (v6)
    {
      sub_10004D2C8(v6);
      sub_10004D2C8(v6);
    }
  }
LABEL_9:
  sub_10090EA5C(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_10090EA2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10)
  {
    sub_10004D2C8(v10);
    sub_10004D2C8(v10);
  }
  sub_10090EA5C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090EA5C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1000346F8(v1 + 16, *(void **)(v1 + 24));
    operator delete();
  }
  return result;
}

void sub_10090EAB0(uint64_t a1@<X0>, void *a2@<X8>)
{
}

double sub_10090EACC(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v3;
    operator delete(v3);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  double result = *(double *)&v5;
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  return result;
}

double sub_10090EB38(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v3;
    operator delete(v3);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  double result = *(double *)&v5;
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  return result;
}

uint64_t sub_10090EBA4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_10090EC3C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10090ECC0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_10090ED40(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v18 = a1;
  v19[0] = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  int v4 = *(_DWORD *)(v1 + 12);
  sub_10090EBA4((uint64_t)v20, v1 + 16);
  long long v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
  uint64_t v6 = v5;
  if (v4 != 36)
  {
    uint64_t v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v16;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Unexpected file (%s) for reading via this API", buf, 0xCu);
    }
    v19[1] = 0;
    v19[2] = 0;
    sub_1008FB224(v21, 0);
  }
  for (uint64_t i = *(uint64_t **)(v2 + 168); i != *(uint64_t **)(v2 + 176); i += 2)
  {
    uint64_t v9 = *i;
    if (*(_DWORD *)(*i + 36) == v3)
    {
      uint64_t v12 = (std::__shared_weak_count *)i[1];
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)long long __p = 0u;
      long long v25 = 0u;
      *(_OWORD *)long long buf = 0u;
      int SimCardForSimFilePath = subscriber::getSimCardForSimFilePath();
      sub_1013B8918(v9, SimCardForSimFilePath, (uint64_t)buf);
      if (BYTE8(v25))
      {
        sub_10090EBA4((uint64_t)v22, (uint64_t)v20);
        sub_1008FA6E0(v2, (uint64_t)buf, v4, (uint64_t)v22);
        sub_10090EC3C(v22);
        if (BYTE8(v25) && __p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
      }
      else
      {
        uint64_t v15 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
        {
          uint64_t v17 = subscriber::asString();
          *(_DWORD *)unint64_t v22 = 136315138;
          *(void *)&v22[4] = v17;
          _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid card info for file : %s", v22, 0xCu);
        }
        *(_OWORD *)unint64_t v22 = 0uLL;
        sub_1008FB224(v21, 0);
        if (*(void *)&v22[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v22[8]);
        }
      }
      goto LABEL_12;
    }
  }
  unint64_t v10 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = subscriber::asString();
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E Can't get Sim File %s because there is no SIM", buf, 0xCu);
  }
  memset(buf, 0, sizeof(buf));
  sub_1008FB224(v21, 0);
  uint64_t v12 = *(std::__shared_weak_count **)&buf[8];
LABEL_12:
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10090EC3C(v20);
  sub_10090F0B4(v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_10090F014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,uint64_t a25,char a26)
{
  if (v26) {
    sub_10004D2C8(v26);
  }
  sub_10090EC3C(&a13);
  sub_10090F0B4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090F0B4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_10090EC3C((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_10090F104(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_10090F184(void *a1)
{
  uint64_t v1 = (uint64_t *)*a1;
  uint64_t v18 = a1;
  uint64_t v19 = v1;
  uint64_t v2 = *v1;
  int v3 = *((_DWORD *)v1 + 2);
  int v4 = *((_DWORD *)v1 + 3);
  unsigned __int16 v5 = *((_WORD *)v1 + 8);
  uint64_t v20 = 0;
  long long v21 = 0uLL;
  sub_1003A10E0(&v20, (const void *)v1[3], v1[4], (v1[4] - v1[3]) >> 1);
  sub_10090F628((uint64_t)v28, (uint64_t)(v1 + 6));
  uint64_t v6 = v20;
  uint64_t v26 = v20;
  uint64_t v25 = v5;
  uint64_t v7 = v21;
  long long v27 = v21;
  uint64_t v20 = 0;
  long long v21 = 0uLL;
  BOOL v8 = *(uint64_t **)(v2 + 168);
  uint64_t v9 = *(uint64_t **)(v2 + 176);
  if (v8 == v9)
  {
LABEL_4:
    __p[0] = 0;
    LOBYTE(v31) = 0;
    if (!v29) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v29 + 48))(v29, __p);
    if ((_BYTE)v31 && *(void *)__p)
    {
      *(void *)&__p[8] = *(void *)__p;
      operator delete(*(void **)__p);
    }
    goto LABEL_25;
  }
  while (1)
  {
    uint64_t v10 = *v8;
    if (*(_DWORD *)(*v8 + 36) == v3) {
      break;
    }
    v8 += 2;
    if (v8 == v9) {
      goto LABEL_4;
    }
  }
  uint64_t v17 = v7;
  uint64_t v11 = (std::__shared_weak_count *)v8[1];
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v23 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  sub_1013B8918(v10, v4, (uint64_t)&v22);
  if (BYTE8(v24))
  {
    *(_WORD *)long long __p = v5;
    *(void *)&__p[16] = 0;
    uint64_t v31 = 0;
    *(void *)&__p[8] = 0;
    sub_1003A10E0(&__p[8], v6, v17, (v17 - (uint64_t)v6) >> 1);
    sub_10090F104((uint64_t)v32, (uint64_t)v28);
    long long v34 = 0;
    uint64_t v12 = operator new(0x48uLL);
    *(void *)uint64_t v12 = off_101A1A128;
    void v12[4] = *(_WORD *)__p;
    *((_OWORD *)v12 + 1) = *(_OWORD *)&__p[8];
    *((void *)v12 + 4) = v31;
    *(void *)&__p[16] = 0;
    uint64_t v31 = 0;
    *(void *)&__p[8] = 0;
    sub_10090F104((uint64_t)(v12 + 20), (uint64_t)v32);
    long long v34 = v12;
    subscriber::SimCommandDriver::readFile();
    sub_100913918(v33);
    sub_1008FDF70(v32);
    if (*(void *)&__p[8])
    {
      *(void *)&__p[16] = *(void *)&__p[8];
      operator delete(*(void **)&__p[8]);
    }
    if (!BYTE8(v24)) {
      goto LABEL_23;
    }
    uint64_t v13 = (void *)v23;
    if (!(void)v23) {
      goto LABEL_23;
    }
    *((void *)&v23 + 1) = v23;
  }
  else
  {
    unint64_t v14 = **(NSObject ***)(v10 + 352);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = subscriber::asString();
      *(_DWORD *)long long __p = 136315138;
      *(void *)&__p[4] = v16;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid card info for type : %s", __p, 0xCu);
    }
    __p[0] = 0;
    LOBYTE(v31) = 0;
    if (!v29) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v29 + 48))(v29, __p);
    if (!(_BYTE)v31) {
      goto LABEL_23;
    }
    uint64_t v13 = *(void **)__p;
    if (!*(void *)__p) {
      goto LABEL_23;
    }
    *(void *)&__p[8] = *(void *)__p;
  }
  operator delete(v13);
LABEL_23:
  if (v11) {
    sub_10004D2C8(v11);
  }
LABEL_25:
  if (v26)
  {
    *(void *)&long long v27 = v26;
    operator delete(v26);
  }
  sub_1008FDF70(v28);
  if (v20)
  {
    *(void *)&long long v21 = v20;
    operator delete(v20);
  }
  sub_10090F5C8(&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_10090F4E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,char a34)
{
  if (v34) {
    sub_10004D2C8(v34);
  }
  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1008FDF70(&a27);
  if (a14)
  {
    a15 = (uint64_t)a14;
    operator delete(a14);
  }
  sub_10090F5C8(&a13);
  sub_100046B58(&a12);
  _Unwind_Resume(a1);
}

void *sub_10090F5C8(void *result)
{
  uint64_t v1 = (void *)*result;
  void *result = 0;
  if (v1)
  {
    sub_1008FDF70(v1 + 6);
    uint64_t v2 = (void *)v1[3];
    if (v2)
    {
      v1[4] = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_10090F628(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_10090F6C0(uint64_t a1)
{
}

uint64_t *sub_10090F6D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned __int16 v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  __p[1] = 0;
  uint64_t v8 = 0;
  __p[0] = 0;
  sub_1008F751C(v2, *(unsigned int *)(v1 + 8), *(_DWORD *)(v1 + 12), (uint64_t)__p);
  uint64_t v3 = *(void *)(v1 + 40);
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v3 + 48))(v3, __p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  sub_10090F7A0(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10090F774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_10090F7A0(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_10090F7A0(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_10012C330((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

std::string *sub_10090F7F0@<X0>(std::string *result@<X0>, std::string *a2@<X8>)
{
  uint64_t v3 = (uint64_t *)result[1].__r_.__value_.__r.__words[2];
  uint64_t v4 = *v3;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  uint64_t v5 = *(void *)(v4 + 504);
  if (v5)
  {
    uint64_t v6 = v4 + 504;
    int v7 = *(_DWORD *)v3[1];
    uint64_t v8 = v6;
    do
    {
      int v9 = *(_DWORD *)(v5 + 32);
      BOOL v10 = v9 < v7;
      if (v9 >= v7) {
        uint64_t v11 = (uint64_t *)v5;
      }
      else {
        uint64_t v11 = (uint64_t *)(v5 + 8);
      }
      if (!v10) {
        uint64_t v8 = v5;
      }
      uint64_t v5 = *v11;
    }
    while (*v11);
    if (v8 != v6 && v7 >= *(_DWORD *)(v8 + 32)) {
      return std::string::operator=(a2, (const std::string *)(v8 + 40));
    }
  }
  return result;
}

void sub_10090F874(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_10090F890@<X0>(std::string *result@<X0>, std::string *a2@<X8>)
{
  uint64_t v3 = *(void *)result[1].__r_.__value_.__r.__words[2];
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  if (*(unsigned char *)(v3 + 488)) {
    return std::string::operator=(a2, (const std::string *)(v3 + 464));
  }
  return result;
}

void sub_10090F8D4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10090F8F0(uint64_t a1)
{
  uint64_t v1 = qword_101B0E190;
  if ((_UNKNOWN *)qword_101B0E190 != &unk_101B0E198)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    uint64_t v3 = *(void *)v2;
    uint64_t v4 = **(unsigned int **)(v2 + 8);
    uint64_t v5 = *(void *)(v2 + 16);
    uint64_t v6 = *(uint64_t **)(v2 + 24);
    uint64_t v8 = *(void *)(v2 + 32);
    int v7 = *(uint64_t **)(v2 + 40);
    while (2)
    {
      int v9 = *(_DWORD *)(v1 + 28);
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      uint64_t v33 = 0;
      sub_1008FAB94(&v31, v3, v4, v9);
      BOOL v10 = v31;
      switch(v9)
      {
        case 5:
          if (v32 == v31)
          {
            if (*(char *)(v5 + 23) < 0)
            {
              **(unsigned char **)uint64_t v5 = 0;
              *(void *)(v5 + 8) = 0;
            }
            else
            {
              *(unsigned char *)uint64_t v5 = 0;
              *(unsigned char *)(v5 + 23) = 0;
            }
            goto LABEL_36;
          }
          (*(void (**)(void, uint64_t))(**(void **)(v3 + 56) + 16))(*(void *)(v3 + 56), v4);
          uint64_t v11 = (char *)subscriber::asString();
          sub_100058DB0(&v29, v11);
          subscriber::sDecodeIsimTLVTransparent();
          if ((v30 & 0x80000000) == 0) {
            goto LABEL_36;
          }
          uint64_t v12 = v29;
          goto LABEL_35;
        case 6:
          if (v32 == v31)
          {
            sub_100047FB8(v6);
            goto LABEL_36;
          }
          (*(void (**)(void, uint64_t))(**(void **)(v3 + 56) + 16))(*(void *)(v3 + 56), v4);
          uint64_t v13 = (char *)subscriber::asString();
          sub_100058DB0(&v27, v13);
          subscriber::sDecodeIsimTLVLinearFixed();
          if ((v28 & 0x80000000) == 0) {
            goto LABEL_36;
          }
          uint64_t v12 = v27;
          goto LABEL_35;
        case 7:
          if (v32 == v31)
          {
            if (*(char *)(v8 + 23) < 0)
            {
              **(unsigned char **)uint64_t v8 = 0;
              *(void *)(v8 + 8) = 0;
            }
            else
            {
              *(unsigned char *)uint64_t v8 = 0;
              *(unsigned char *)(v8 + 23) = 0;
            }
          }
          else
          {
            (*(void (**)(void, uint64_t))(**(void **)(v3 + 56) + 16))(*(void *)(v3 + 56), v4);
            unint64_t v14 = (char *)subscriber::asString();
            sub_100058DB0(&v25, v14);
            subscriber::sDecodeIsimTLVTransparent();
            if (v26 < 0)
            {
              uint64_t v12 = v25;
LABEL_35:
              operator delete(v12);
            }
          }
LABEL_36:
          BOOL v10 = v31;
LABEL_37:
          if (v10)
          {
            uint64_t v32 = v10;
            operator delete(v10);
          }
          uint64_t v20 = *(void **)(v1 + 8);
          if (v20)
          {
            do
            {
              long long v21 = v20;
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            do
            {
              long long v21 = *(void **)(v1 + 16);
              BOOL v22 = *v21 == v1;
              uint64_t v1 = (uint64_t)v21;
            }
            while (!v22);
          }
          uint64_t v1 = (uint64_t)v21;
          if (v21 == (void *)&unk_101B0E198) {
            return;
          }
          continue;
        case 8:
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v24 = 0;
          if (v32 == v31)
          {
            sub_100047FB8(v7);
          }
          else
          {
            (*(void (**)(void, uint64_t))(**(void **)(v3 + 56) + 16))(*(void *)(v3 + 56), v4);
            subscriber::sDecodePcscf();
          }
          uint64_t v15 = (void *)HIBYTE(v24);
          char v16 = HIBYTE(v24);
          if (v24 < 0) {
            uint64_t v15 = __p[1];
          }
          if (v15)
          {
            unint64_t v17 = v7[1];
            if (v17 >= v7[2])
            {
              uint64_t v19 = sub_100048008(v7, (long long *)__p);
            }
            else
            {
              if (SHIBYTE(v24) < 0)
              {
                sub_10004FC84((unsigned char *)v7[1], __p[0], (unint64_t)__p[1]);
              }
              else
              {
                long long v18 = *(_OWORD *)__p;
                *(void *)(v17 + 16) = v24;
                *(_OWORD *)unint64_t v17 = v18;
              }
              uint64_t v19 = v17 + 24;
              v7[1] = v17 + 24;
            }
            v7[1] = v19;
            char v16 = HIBYTE(v24);
          }
          if ((v16 & 0x80) == 0) {
            goto LABEL_36;
          }
          uint64_t v12 = __p[0];
          goto LABEL_35;
        default:
          goto LABEL_37;
      }
    }
  }
}

void sub_10090FC6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35)
{
  *(void *)(v35 + 8) = v36;
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a34) {
    operator delete(a34);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10090FCF8(void *a1)
{
  uint64_t v1 = *a1;
  char v16 = a1;
  uint64_t v17 = v1;
  uint64_t v2 = *(void **)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  int v4 = *(_DWORD *)(v1 + 12);
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  long long v18 = 0;
  sub_10005C928(&v18, *(const void **)(v1 + 16), *(void *)(v1 + 24), *(void *)(v1 + 24) - *(void *)(v1 + 16));
  sub_1000DFC90((uint64_t)v24, v1 + 40);
  for (uint64_t i = (uint64_t *)v2[21]; i != (uint64_t *)v2[22]; i += 2)
  {
    uint64_t v6 = *i;
    if (*(_DWORD *)(*i + 36) == v3)
    {
      int v9 = (std::__shared_weak_count *)i[1];
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)long long __p = 0u;
      long long v23 = 0u;
      long long v21 = 0u;
      int SimCardForSimFilePath = subscriber::getSimCardForSimFilePath();
      sub_1013B8918(v6, SimCardForSimFilePath, (uint64_t)&v21);
      int v11 = BYTE8(v23);
      if (BYTE8(v23))
      {
        if (v4 == 36 || v4 == 33)
        {
          *(void *)&long long buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 1174405120;
          char v26 = sub_1008FB2B0;
          long long v27 = &unk_101A18F20;
          sub_1000DFC90((uint64_t)v28, (uint64_t)v24);
          subscriber::SimCommandDriver::writeFile();
          sub_100060644(v28);
          int v11 = BYTE8(v23);
          goto LABEL_19;
        }
        uint64_t v13 = **(NSObject ***)(v6 + 352);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = subscriber::asString();
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Write operation not permitted for file %s", (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        uint64_t v12 = **(NSObject ***)(v6 + 352);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "No SIM card info", (uint8_t *)&buf, 2u);
        }
      }
      sub_1000607A8((uint64_t)v24, 0);
LABEL_19:
      if (v11 && __p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v9) {
        sub_10004D2C8(v9);
      }
      goto LABEL_24;
    }
  }
  int v7 = v2[5];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = subscriber::asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#E Can't get Sim File %s because there is no SIM", (uint8_t *)&buf, 0xCu);
  }
  sub_1000607A8((uint64_t)v24, 0);
LABEL_24:
  sub_100060644(v24);
  if (v18)
  {
    uint64_t v19 = v18;
    operator delete(v18);
  }
  sub_10091005C(&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_10090FFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, char a20,int a21,uint64_t a22)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
  sub_100060644(&a22);
  if (a12)
  {
    a13 = (uint64_t)a12;
    operator delete(a12);
  }
  sub_10091005C(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void *sub_10091005C(void *result)
{
  uint64_t v1 = (void *)*result;
  void *result = 0;
  if (v1)
  {
    sub_100060644(v1 + 5);
    uint64_t v2 = (void *)v1[2];
    if (v2)
    {
      v1[3] = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1009100BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = **(unsigned int **)(v1 + 8);
  int v4 = **(_DWORD **)(v1 + 16);
  long long __p = 0;
  char v16 = 0;
  uint64_t v17 = 0;
  sub_1008FAB94(&__p, v2, v3, 32);
  uint64_t v5 = __p;
  if (__p == v16)
  {
    LOBYTE(v6) = 0;
    if (!__p) {
      return v6 & 1;
    }
    goto LABEL_10;
  }
  if (v16 - (unsigned char *)__p <= (unint64_t)(v4 - 1) >> 3)
  {
    int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
    LOBYTE(v6) = 0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = subscriber::asString();
      *(_DWORD *)long long buf = 136315650;
      uint64_t v19 = v12;
      __int16 v20 = 2048;
      uint64_t v21 = v16 - (unsigned char *)__p;
      __int16 v22 = 1024;
      int v23 = v4;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E Cannot fetch %s from USIM Service Table. Size mismatch. UST Size:%zd bytes, Service Pos:%u", buf, 0x1Cu);
      LOBYTE(v6) = 0;
    }
  }
  else
  {
    int v6 = *((unsigned __int8 *)__p + ((unint64_t)(v4 - 1) >> 3)) >> ((v4 - 1) & 7);
    char v14 = v6 & 1;
    int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = subscriber::asString();
      uint64_t v10 = printers::asString((printers *)&v14, v9);
      *(_DWORD *)long long buf = 136315394;
      uint64_t v19 = v8;
      __int16 v20 = 2080;
      uint64_t v21 = v10;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I UST[%s] = %s", buf, 0x16u);
      LOBYTE(v6) = v14 != 0;
    }
  }
  uint64_t v5 = __p;
  if (__p)
  {
LABEL_10:
    char v16 = v5;
    operator delete(v5);
  }
  return v6 & 1;
}

void sub_1009102E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100910310(uint64_t **a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = **a1;
  uint64_t v5 = *(uint64_t **)(v4 + 168);
  int v6 = *(uint64_t **)(v4 + 176);
  if (v5 != v6)
  {
    while (1)
    {
      uint64_t v7 = *v5;
      if (*(_DWORD *)(*v5 + 36) == *((_DWORD *)v3 + 2)) {
        break;
      }
      v5 += 2;
      if (v5 == v6) {
        goto LABEL_12;
      }
    }
    uint64_t v8 = (std::__shared_weak_count *)v5[1];
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1013B85B4(v7, a2, a3);
    if (subscriber::isSimAbsent())
    {
      uint64_t v11 = *(void *)(v4 + 120);
      uint64_t v12 = *((unsigned int *)v3 + 2);
      uint64_t v13 = sub_1013B85B4(v7, v9, v10);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11 + 16))(v11, v12, v13);
      goto LABEL_10;
    }
    char v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 56) + 16))(*(void *)(v4 + 56), *((unsigned int *)v3 + 2));
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
LABEL_10:
      if (!v8) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
    sub_1013B85B4(v7, v15, v16);
    *(_DWORD *)long long buf = 136315138;
    uint64_t v18 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "External triggerIfSimNotPresent received but SIM state %s will not allow it", buf, 0xCu);
    if (v8) {
LABEL_11:
    }
      sub_10004D2C8(v8);
  }
LABEL_12:
  operator delete();
}

void sub_1009104C8()
{
  if (v0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

uint64_t sub_100910508(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = *(_DWORD ***)(a1 + 40);
  uint64_t v4 = *v3;
  uint64_t v5 = (uint64_t *)*((void *)*v3 + 21);
  int v6 = (uint64_t *)*((void *)*v3 + 22);
  if (v5 == v6) {
    return 0;
  }
  while (1)
  {
    uint64_t v7 = *v5;
    if (*(_DWORD *)(*v5 + 36) == *v3[1]) {
      break;
    }
    v5 += 2;
    if (v5 == v6) {
      return 0;
    }
  }
  uint64_t v9 = (std::__shared_weak_count *)v5[1];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v10 = sub_1013B85B4(v7, a2, a3);
  if (!subscriber::isSimLocked())
  {
    if (!subscriber::isSimAbsent())
    {
      if ((subscriber::isSimReady() & 1) == 0) {
        goto LABEL_27;
      }
LABEL_24:
      uint64_t v8 = 0;
      if (!v9) {
        return v8;
      }
      goto LABEL_30;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v12, (Registry *)v4[8]);
    char v14 = ServiceMap;
    if ((v15 & 0x8000000000000000) != 0)
    {
      unint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        unint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, &v27);
    if (v19)
    {
      uint64_t v21 = v19[3];
      __int16 v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    __int16 v20 = 0;
    char v22 = 1;
LABEL_21:
    int v23 = (*(uint64_t (**)(uint64_t, void))(*(void *)v21 + 168))(v21, *v3[1]);
    if ((v22 & 1) == 0) {
      sub_10004D2C8(v20);
    }
    if (v23 != 2)
    {
      (*(void (**)(void *, void))(*v4 + 240))(v4, *v3[1]);
      goto LABEL_27;
    }
    goto LABEL_24;
  }
  uint64_t v11 = v4[19];
  if (v11) {
    (*(void (**)(uint64_t, void))(*(void *)v11 + 24))(v11, *v3[1]);
  }
LABEL_27:
  uint64_t v24 = *(NSObject **)(*(uint64_t (**)(void, void))(*(void *)v4[7] + 16))(v4[7], *v3[1]);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    uint64_t v26 = subscriber::asString();
    LODWORD(v27) = 67109378;
    HIDWORD(v27) = v10;
    __int16 v28 = 2080;
    uint64_t v29 = v26;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid sim state: %d(%s)", (uint8_t *)&v27, 0x12u);
  }
  uint64_t v8 = 1;
  if (v9) {
LABEL_30:
  }
    sub_10004D2C8(v9);
  return v8;
}

void sub_1009107F0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10091083C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v22 = a1;
  uint64_t v23 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 24);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90((uint64_t)v27, v1 + 32);
  for (uint64_t i = *(uint64_t **)(v2 + 168); ; i += 2)
  {
    if (i == *(uint64_t **)(v2 + 176))
    {
      int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Sim Info not found", buf, 2u);
      }
      uint64_t v11 = 0;
      goto LABEL_10;
    }
    uint64_t v9 = *i;
    if (*(_DWORD *)(*i + 36) == v3) {
      break;
    }
  }
  uint64_t v11 = (std::__shared_weak_count *)i[1];
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1013B85B4(v9, v6, v7);
  if ((subscriber::isSimReady() & 1) == 0)
  {
    uint64_t v17 = **(NSObject ***)(v9 + 352);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      sub_1013B85B4(v9, v18, v19);
      uint64_t v20 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "SIM state is %s, procedure aborted", buf, 0xCu);
    }
LABEL_10:
    sub_1000607A8((uint64_t)v27, 0);
    goto LABEL_11;
  }
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  sub_1013B8918(v9, 1, (uint64_t)&v24);
  if (BYTE8(v26))
  {
    *(void *)long long buf = v2;
    *(_OWORD *)&uint8_t buf[8] = v24;
    __p[1] = 0;
    uint64_t v30 = 0;
    __p[0] = 0;
    uint64_t v13 = (void *)v25;
    sub_10005C928(__p, (const void *)v25, *((uint64_t *)&v25 + 1), *((void *)&v25 + 1) - v25);
    *(void *)&long long v31 = v5;
    *((void *)&v31 + 1) = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1000DFC90((uint64_t)v32, (uint64_t)v27);
    long long v34 = 0;
    char v14 = (char *)operator new(0x68uLL);
    uint64_t v15 = *(void *)buf;
    *(void *)char v14 = off_101A1A1A8;
    *((void *)v14 + 1) = v15;
    long long v16 = *(_OWORD *)__p;
    *((_OWORD *)v14 + 1) = *(_OWORD *)&buf[8];
    *((_OWORD *)v14 + 2) = v16;
    *((void *)v14 + 6) = v30;
    __p[1] = 0;
    uint64_t v30 = 0;
    __p[0] = 0;
    *(_OWORD *)(v14 + 56) = v31;
    long long v31 = 0uLL;
    sub_100023950((uint64_t)(v14 + 72), (uint64_t)v32);
    long long v34 = v14;
    sub_100913DC8((void *)(v2 + 912), (uint64_t)v33);
    sub_10003B34C(v33);
    sub_100060644(v32);
    if (*((void *)&v31 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v31 + 1));
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    sub_1008FB2CC(v2);
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    uint64_t v21 = **(NSObject ***)(v9 + 352);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not create SIM card info", buf, 2u);
    }
    sub_1000607A8((uint64_t)v27, 0);
  }
LABEL_11:
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_100060644(v27);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100910C8C(&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_100910BC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  if (v29) {
    sub_10004D2C8(v29);
  }
  sub_100060644(&a17);
  if (v28) {
    sub_10004D2C8(v28);
  }
  sub_100910C8C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100910C8C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 32));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100910CE8(void *a1)
{
  uint64_t v1 = *a1;
  long long v25 = a1;
  uint64_t v26 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 24);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v6 = *(unsigned char *)(v1 + 32);
  uint64_t v8 = *(void *)(v1 + 40);
  unint64_t v7 = *(std::__shared_weak_count **)(v1 + 48);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90((uint64_t)v30, v1 + 56);
  for (uint64_t i = *(uint64_t **)(v2 + 168); ; i += 2)
  {
    if (i == *(uint64_t **)(v2 + 176))
    {
      uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Sim Info not found", buf, 2u);
      }
      char v14 = 0;
      goto LABEL_12;
    }
    uint64_t v12 = *i;
    if (*(_DWORD *)(*i + 36) == v3) {
      break;
    }
  }
  char v14 = (std::__shared_weak_count *)i[1];
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1013B85B4(v12, v9, v10);
  if ((subscriber::isSimReady() & 1) == 0)
  {
    unint64_t v19 = **(NSObject ***)(v12 + 352);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      sub_1013B85B4(v12, v20, v21);
      uint64_t v22 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v22;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "SIM state is %s, procedure aborted", buf, 0xCu);
    }
LABEL_12:
    sub_1000607A8((uint64_t)v30, 0);
    goto LABEL_13;
  }
  long long v28 = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  sub_1013B8918(v12, 1, (uint64_t)&v27);
  if (BYTE8(v29))
  {
    *(void *)long long buf = v2;
    *(_OWORD *)&uint8_t buf[8] = v27;
    __p[1] = 0;
    uint64_t v33 = 0;
    __p[0] = 0;
    long long v24 = (void *)v28;
    sub_10005C928(__p, (const void *)v28, *((uint64_t *)&v28 + 1), *((void *)&v28 + 1) - v28);
    *(void *)&long long v34 = v5;
    *((void *)&v34 + 1) = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v35 = v6;
    *(void *)&long long v36 = v8;
    *((void *)&v36 + 1) = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1000DFC90((uint64_t)v37, (uint64_t)v30);
    unint64_t v39 = 0;
    long long v16 = (char *)operator new(0x80uLL);
    uint64_t v17 = *(void *)buf;
    *(void *)long long v16 = off_101A1A2A8;
    *((void *)v16 + 1) = v17;
    long long v18 = *(_OWORD *)__p;
    *((_OWORD *)v16 + 1) = *(_OWORD *)&buf[8];
    *((_OWORD *)v16 + 2) = v18;
    *((void *)v16 + 6) = v33;
    __p[1] = 0;
    uint64_t v33 = 0;
    __p[0] = 0;
    *(_OWORD *)(v16 + 56) = v34;
    long long v34 = 0uLL;
    v16[72] = v35;
    *((_OWORD *)v16 + 5) = v36;
    long long v36 = 0uLL;
    sub_100023950((uint64_t)(v16 + 96), (uint64_t)v37);
    unint64_t v39 = v16;
    sub_100913DC8((void *)(v2 + 912), (uint64_t)v38);
    sub_10003B34C(v38);
    sub_100060644(v37);
    if (*((void *)&v36 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v36 + 1));
    }
    if (*((void *)&v34 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v34 + 1));
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    sub_1008FB2CC(v2);
    if (v24) {
      operator delete(v24);
    }
  }
  else
  {
    uint64_t v23 = **(NSObject ***)(v12 + 352);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not create SIM card info", buf, 2u);
    }
    sub_1000607A8((uint64_t)v30, 0);
  }
LABEL_13:
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_100060644(v30);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1009111A4(&v26);
  return sub_100046B58((uint64_t *)&v25);
}

void sub_1009110D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  if (v35) {
    sub_10004D2C8(v35);
  }
  sub_100060644(&a19);
  if (v34) {
    sub_10004D2C8(v34);
  }
  if (v33) {
    sub_10004D2C8(v33);
  }
  sub_1009111A4(&a12);
  sub_100046B58(&a11);
  _Unwind_Resume(a1);
}

void *sub_1009111A4(void *result)
{
  uint64_t v1 = (void *)*result;
  void *result = 0;
  if (v1)
  {
    sub_100060644(v1 + 7);
    uint64_t v2 = (std::__shared_weak_count *)v1[6];
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[3];
    if (v3) {
      sub_10004D2C8(v3);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10091120C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v20 = a1;
  uint64_t v21 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  sub_1000DFC90((uint64_t)v25, v1 + 16);
  for (uint64_t i = *(uint64_t **)(v2 + 168); ; i += 2)
  {
    if (i == *(uint64_t **)(v2 + 176))
    {
      uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Sim Info not found", buf, 2u);
      }
      uint64_t v9 = 0;
      goto LABEL_8;
    }
    uint64_t v7 = *i;
    if (*(_DWORD *)(*i + 36) == v3) {
      break;
    }
  }
  uint64_t v9 = (std::__shared_weak_count *)i[1];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1013B85B4(v7, v4, v5);
  if ((subscriber::isSimReady() & 1) == 0)
  {
    uint64_t v15 = **(NSObject ***)(v7 + 352);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      sub_1013B85B4(v7, v16, v17);
      uint64_t v18 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v18;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "SIM state is %s, procedure aborted", buf, 0xCu);
    }
LABEL_8:
    sub_1000607A8((uint64_t)v25, 0);
    goto LABEL_9;
  }
  long long v23 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  sub_1013B8918(v7, 1, (uint64_t)&v22);
  if (BYTE8(v24))
  {
    *(void *)long long buf = v2;
    *(_OWORD *)&uint8_t buf[8] = v22;
    __p[1] = 0;
    uint64_t v28 = 0;
    __p[0] = 0;
    uint64_t v11 = (void *)v23;
    sub_10005C928(__p, (const void *)v23, *((uint64_t *)&v23 + 1), *((void *)&v23 + 1) - v23);
    sub_1000DFC90((uint64_t)v29, (uint64_t)v25);
    long long v31 = 0;
    uint64_t v12 = operator new(0x58uLL);
    uint64_t v13 = *(void *)buf;
    *uint64_t v12 = off_101A1A3A8;
    v12[1] = v13;
    long long v14 = *(_OWORD *)__p;
    *((_OWORD *)v12 + 1) = *(_OWORD *)&buf[8];
    *((_OWORD *)v12 + 2) = v14;
    v12[6] = v28;
    __p[1] = 0;
    uint64_t v28 = 0;
    __p[0] = 0;
    sub_100023950((uint64_t)(v12 + 7), (uint64_t)v29);
    long long v31 = v12;
    sub_100913DC8((void *)(v2 + 912), (uint64_t)v30);
    sub_10003B34C(v30);
    sub_100060644(v29);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    sub_1008FB2CC(v2);
    if (v11) {
      operator delete(v11);
    }
  }
  else
  {
    unint64_t v19 = **(NSObject ***)(v7 + 352);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not create SIM card info", buf, 2u);
    }
    sub_1000607A8((uint64_t)v25, 0);
  }
LABEL_9:
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_100060644(v25);
  sub_10041FB18(&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_10091153C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  if (v25) {
    sub_10004D2C8(v25);
  }
  sub_100060644(&a17);
  sub_10041FB18(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1009115F0(uint64_t a1)
{
  return *(unsigned __int16 *)(**(void **)(a1 + 40) + 960);
}

uint64_t *sub_100911600(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  uint64_t v10 = v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 168);
  uint64_t v2 = *(void *)(*(void *)v1 + 176);
  if (v3 == v2)
  {
    char v6 = 0;
  }
  else
  {
    uint64_t v4 = v3 + 16;
    do
    {
      unsigned int v5 = *(_DWORD *)(*(void *)(v4 - 16) + 52) - 3;
      char v6 = v5 < 2;
      BOOL v7 = v5 < 2 || v4 == v2;
      v4 += 16;
    }
    while (!v7);
  }
  sub_1000607A8(v1 + 8, v6);
  sub_1003F5954(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_100911680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_10091169C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = **(void **)(a1 + 40);
  uint64_t v4 = *(void *)(v3 + 168);
  uint64_t v5 = *(void *)(v3 + 176);
  if (v4 == v5) {
    return 0;
  }
  uint64_t v6 = v4 + 16;
  do
  {
    sub_1013B85B4(*(void *)(v6 - 16), a2, a3);
    uint64_t result = subscriber::isSimReady();
    if (result) {
      break;
    }
    BOOL v8 = v6 == v5;
    v6 += 16;
  }
  while (!v8);
  return result;
}

BOOL sub_1009116F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  if (!*(unsigned char *)(*(void *)v1 + 452)) {
    goto LABEL_8;
  }
  if (v3 != 2)
  {
    if (v3 != 1) {
      goto LABEL_8;
    }
    if (*(_DWORD *)(v2 + 444))
    {
      uint64_t v3 = 1;
      goto LABEL_8;
    }
    return 0;
  }
  if (!*(_DWORD *)(v2 + 448)) {
    return 0;
  }
  uint64_t v3 = 2;
LABEL_8:
  v51[0] = 0;
  v51[1] = 0;
  uint64_t v52 = 0;
  sub_1008F751C(v2, v3, 3, (uint64_t)v51);
  *(_OWORD *)uint64_t v49 = 0u;
  long long v50 = 0u;
  *(_OWORD *)uint64_t v48 = 0u;
  sub_100E63EA4((uint64_t)v48);
  int v4 = SHIBYTE(v49[0]);
  if (SHIBYTE(v49[0]) >= 0) {
    uint64_t v5 = (void *)HIBYTE(v49[0]);
  }
  else {
    uint64_t v5 = v48[1];
  }
  char v6 = HIBYTE(v50);
  if (!v5 || (v50 >= 0 ? (uint64_t v7 = HIBYTE(v50)) : (uint64_t v7 = v50), (v33 = v7) == 0))
  {
    BOOL v10 = 0;
    if ((HIBYTE(v50) & 0x80) == 0) {
      goto LABEL_98;
    }
    goto LABEL_103;
  }
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v42 = 0;
  sub_1008F751C(v2, *(unsigned int *)(v1 + 8), 1, (uint64_t)&v45);
  sub_1008F751C(v2, *(unsigned int *)(v1 + 8), 2, (uint64_t)&v42);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 16));
  if (Count >= 1)
  {
    CFIndex v9 = 0;
    BOOL v10 = 1;
    while (1)
    {
      CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 16), v9);
      CFTypeID v12 = CFGetTypeID(ValueAtIndex);
      if (v12 == CFDictionaryGetTypeID()) {
        break;
      }
LABEL_77:
      BOOL v10 = ++v9 < Count;
      if (v9 == Count) {
        goto LABEL_94;
      }
    }
    CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"MCC");
    long long v53 = 0uLL;
    uint64_t v54 = 0;
    ctu::cf::assign();
    *(_OWORD *)__s1 = v53;
    uint64_t v41 = v54;
    CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"MNC");
    long long v53 = 0uLL;
    uint64_t v54 = 0;
    ctu::cf::assign();
    *(_OWORD *)__n = v53;
    uint64_t v39 = v54;
    v36[0] = 0;
    v36[1] = 0;
    uint64_t v37 = 0;
    CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"GID1");
    long long v53 = 0uLL;
    uint64_t v54 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long v36 = v53;
    uint64_t v37 = v54;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v35 = 0;
    CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"GID2");
    long long v53 = 0uLL;
    uint64_t v54 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __p = v53;
    uint64_t v35 = v54;
    char v13 = HIBYTE(v41);
    if (v41 >= 0) {
      long long v14 = (void *)HIBYTE(v41);
    }
    else {
      long long v14 = __s1[1];
    }
    if (v14 != v5) {
      goto LABEL_69;
    }
    if (v4 >= 0) {
      uint64_t v15 = v48;
    }
    else {
      uint64_t v15 = (void **)v48[0];
    }
    if (v41 < 0)
    {
      if (memcmp(__s1[0], v15, (size_t)__s1[1])) {
        goto LABEL_69;
      }
    }
    else if (HIBYTE(v41))
    {
      uint64_t v16 = __s1;
      uint64_t v17 = HIBYTE(v41);
      while (*(unsigned __int8 *)v16 == *(unsigned __int8 *)v15)
      {
        uint64_t v16 = (void **)((char *)v16 + 1);
        uint64_t v15 = (void **)((char *)v15 + 1);
        if (!--v17) {
          goto LABEL_33;
        }
      }
      goto LABEL_69;
    }
LABEL_33:
    uint64_t v18 = HIBYTE(v39);
    if (v39 >= 0) {
      size_t v19 = HIBYTE(v39);
    }
    else {
      size_t v19 = __n[1];
    }
    if (v19 == v33)
    {
      if (v6 >= 0) {
        uint64_t v20 = &v49[1];
      }
      else {
        uint64_t v20 = (void **)v49[1];
      }
      if ((v39 & 0x8000000000000000) == 0)
      {
        if (HIBYTE(v39))
        {
          uint64_t v21 = __n;
          while (*(unsigned __int8 *)v21 == *(unsigned __int8 *)v20)
          {
            uint64_t v21 = (size_t *)((char *)v21 + 1);
            uint64_t v20 = (void **)((char *)v20 + 1);
            if (!--v18) {
              goto LABEL_47;
            }
          }
          goto LABEL_69;
        }
LABEL_47:
        if (v37 >= 0) {
          size_t v22 = HIBYTE(v37);
        }
        else {
          size_t v22 = (size_t)v36[1];
        }
        if (v22) {
          goto LABEL_54;
        }
        long long v23 = (void *)HIBYTE(v35);
        if (v35 < 0) {
          long long v23 = __p[1];
        }
        if (v23)
        {
LABEL_54:
          uint64_t v24 = HIBYTE(v47);
          if (v47 < 0) {
            uint64_t v24 = v46;
          }
          if ((v22 == 0) != (v24 == 0)) {
            goto LABEL_69;
          }
          if (v37 >= 0) {
            long long v25 = v36;
          }
          else {
            long long v25 = (void **)v36[0];
          }
          uint64_t v26 = v45;
          if (v47 >= 0) {
            uint64_t v26 = &v45;
          }
          *(void *)&long long v53 = v26;
          *((void *)&v53 + 1) = v24;
          if (!sub_100235858(&v53, v25, v22)) {
            goto LABEL_69;
          }
          if (v35 >= 0) {
            size_t v27 = HIBYTE(v35);
          }
          else {
            size_t v27 = (size_t)__p[1];
          }
          uint64_t v28 = HIBYTE(v44);
          if (v44 < 0) {
            uint64_t v28 = v43;
          }
          if ((v27 == 0) != (v28 == 0)) {
            goto LABEL_69;
          }
          if (v35 >= 0) {
            uint64_t v30 = __p;
          }
          else {
            uint64_t v30 = (void **)__p[0];
          }
          long long v31 = v42;
          if (v44 >= 0) {
            long long v31 = &v42;
          }
          *(void *)&long long v53 = v31;
          *((void *)&v53 + 1) = v28;
          if (sub_100235858(&v53, v30, v27)) {
            int v29 = 1;
          }
          else {
            int v29 = 4;
          }
        }
        else
        {
          int v29 = 1;
        }
LABEL_70:
        if (SHIBYTE(v35) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v37) < 0) {
          operator delete(v36[0]);
        }
        if (SHIBYTE(v39) < 0)
        {
          operator delete((void *)__n[0]);
          if ((v13 & 0x80) == 0) {
            goto LABEL_76;
          }
        }
        else if ((v13 & 0x80) == 0)
        {
          goto LABEL_76;
        }
        operator delete(__s1[0]);
LABEL_76:
        if (v29 != 4) {
          goto LABEL_94;
        }
        goto LABEL_77;
      }
      if (!memcmp((const void *)__n[0], v20, __n[1])) {
        goto LABEL_47;
      }
    }
LABEL_69:
    int v29 = 4;
    goto LABEL_70;
  }
  BOOL v10 = 0;
LABEL_94:
  if (SHIBYTE(v44) < 0) {
    operator delete(v42);
  }
  if ((SHIBYTE(v47) & 0x80000000) == 0)
  {
    if ((v6 & 0x80) == 0) {
      goto LABEL_98;
    }
LABEL_103:
    operator delete(v49[1]);
    if ((v4 & 0x80000000) == 0) {
      goto LABEL_99;
    }
    goto LABEL_104;
  }
  operator delete(v45);
  if (v6 < 0) {
    goto LABEL_103;
  }
LABEL_98:
  if ((v4 & 0x80000000) == 0) {
    goto LABEL_99;
  }
LABEL_104:
  operator delete(v48[0]);
LABEL_99:
  if (SHIBYTE(v52) < 0) {
    operator delete(v51[0]);
  }
  return v10;
}

void sub_100911C08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *a48,uint64_t a49,uint64_t a50,void *a51)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  if (a47 < 0)
  {
    operator delete(a42);
    if ((v52 & 0x80) == 0)
    {
LABEL_5:
      if ((v51 & 0x80000000) == 0) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }
  else if ((v52 & 0x80) == 0)
  {
    goto LABEL_5;
  }
  operator delete(a51);
  if ((v51 & 0x80000000) == 0)
  {
LABEL_7:
    if (*(char *)(v53 - 121) < 0) {
      operator delete(*(void **)(v53 - 144));
    }
    _Unwind_Resume(exception_object);
  }
LABEL_6:
  operator delete(a48);
  goto LABEL_7;
}

void *sub_100911D1C(void *a1)
{
  *a1 = off_101A19E28;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  int v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_100911D80(void *a1)
{
  *a1 = off_101A19E28;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  int v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void *sub_100911E04(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A19E28;
  sub_100912044(v2 + 1, v1);
  return v2;
}

void *sub_100911E58(uint64_t a1, void *a2)
{
  *a2 = off_101A19E28;
  return sub_100912044(a2 + 1, (void *)(a1 + 8));
}

void sub_100911E84(uint64_t a1)
{
}

void sub_100911E8C(void *a1)
{
  sub_10091209C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100911EC8(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = a1[1];
      if (v4)
      {
        uint64_t v5 = a1[4];
        if (v5)
        {
          dispatch_retain(v5);
          dispatch_group_enter(v5);
        }
        v6[0] = 0;
        v6[1] = 0;
        sub_10003E168(v6, (void *)(v4 + 8));
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100911FF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100912038()
{
}

void *sub_100912044(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[3];
  a1[2] = a2[2];
  a1[3] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = a1[3];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  return a1;
}

void sub_10091209C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 24);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t *sub_1009120F8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v6 = a1;
  uint64_t v7 = v1;
  if (*(unsigned char *)(v1 + 20))
  {
    int v2 = *(_DWORD *)(v1 + 16);
    if (v2)
    {
      uint64_t v3 = *(__CFDictionary **)v1;
      key = @"kCTMobileEquipmentInfoERIVersion";
      if (@"kCTMobileEquipmentInfoERIVersion") {
        CFRetain(@"kCTMobileEquipmentInfoERIVersion");
      }
      int valuePtr = v2;
      CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      CFNumberRef v8 = v4;
      if (key && v4) {
        CFDictionarySetValue(v3, key, v4);
      }
      sub_10010F494((const void **)&v8);
      sub_10010F494((const void **)&key);
    }
  }
  sub_1009121E4(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_1009121A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v7 = va_arg(va3, const void *);
  sub_10010F494((const void **)va2);
  sub_10010F494((const void **)va3);
  sub_1009121E4((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009121E4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    int v2 = *(NSObject **)(v1 + 8);
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = *(NSObject **)(v1 + 8);
      if (v3) {
        dispatch_release(v3);
      }
    }
    operator delete();
  }
  return result;
}

void *sub_100912244(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1009122C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A19EB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009122E8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A19EB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_10091233C(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 368);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 352);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 335) < 0) {
    operator delete(*(void **)(a1 + 312));
  }
  sub_10013E528(a1 + 240);
  sub_1009123EC(a1 + 208, *(void **)(a1 + 216));
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  uint64_t v7 = (void **)(a1 + 152);
  sub_10002E39C(&v7);
  CFNumberRef v4 = *(void **)(a1 + 128);
  if (v4)
  {
    *(void *)(a1 + 136) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 96);
  if (v5)
  {
    *(void *)(a1 + 104) = v5;
    operator delete(v5);
  }
  return sub_100087E88((void *)(a1 + 24));
}

void sub_1009123EC(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1009123EC(a1, *a2);
    sub_1009123EC(a1, a2[1]);
    CFNumberRef v4 = (void *)a2[6];
    if (v4)
    {
      a2[7] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

void sub_100912454()
{
}

__n128 sub_100912468(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = off_101A19F08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1009124B4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A19F08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009124E4(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(unsigned int *)(a1 + 16);
  if (*a2)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 20);
    CFNumberRef v8 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v4 + 320);
    uint64_t v9 = *(void *)(a1 + 8);
    v8(v9, v5, v7, a3);
  }
  else
  {
    for (uint64_t i = *(uint64_t **)(v4 + 168); i != *(uint64_t **)(v4 + 176); i += 2)
    {
      uint64_t v11 = *i;
      if (*(_DWORD *)(*i + 32) == v5)
      {
        char v13 = (std::__shared_weak_count *)i[1];
        if (v13) {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        long long v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v4 + 56) + 16))(*(void *)(v4 + 56), *(unsigned int *)(v11 + 36));
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v15) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Read failed with problem - invalidate file and read next pending files", (uint8_t *)&v15, 2u);
        }
        sub_1013B8BD8(v11, *(_DWORD *)(a1 + 20));
        if (v13) {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        *(void *)&long long v15 = _NSConcreteStackBlock;
        *((void *)&v15 + 1) = 0x40000000;
        uint64_t v16 = sub_1008FA63C;
        uint64_t v17 = &unk_101A18F00;
        uint64_t v18 = v4;
        sub_1013B8A74(v11, (uint64_t)&v15);
        if (v13)
        {
          sub_10004D2C8(v13);
          sub_10004D2C8(v13);
        }
        return;
      }
    }
    CFTypeID v12 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v15) = 136315138;
      *(void *)((char *)&v15 + 4) = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Missing sim info for slot: %s", (uint8_t *)&v15, 0xCu);
    }
  }
}

void sub_10091274C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10091277C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A19F78)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1009127BC()
{
  return &off_101A19F78;
}

uint64_t **sub_1009127C8(uint64_t **a1, int a2, _DWORD *a3)
{
  char v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        char v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        char v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = operator new(0x40uLL);
    v9[8] = *a3;
    *((void *)v9 + 7) = 0;
    *((void *)v9 + 6) = 0;
    *((void *)v9 + 5) = v9 + 12;
    sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t **sub_100912880(uint64_t **result, void *a2, void *a3)
{
  uint64_t v5 = result;
  if (result[2])
  {
    char v6 = *result;
    uint64_t v7 = result[1];
    void *result = (uint64_t *)(result + 1);
    _DWORD v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      int v8 = (uint64_t *)v6[1];
    }
    else {
      int v8 = v6;
    }
    long long v14 = result;
    long long v15 = v8;
    uint64_t v16 = v8;
    if (v8)
    {
      long long v15 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          *((_DWORD *)v8 + 7) = *((_DWORD *)v9 + 7);
          *((unsigned char *)v8 + 32) = *((unsigned char *)v9 + 32);
          sub_1001A0944(v5, (uint64_t)v8);
          int v8 = v15;
          uint64_t v16 = v15;
          if (v15) {
            long long v15 = sub_1000EA590((uint64_t)v15);
          }
          BOOL v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              BOOL v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              uint64_t v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          uint64_t v9 = a2;
        }
        while (a2 != a3);
      }
    }
    __n128 result = (uint64_t **)sub_1001A09B4((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      __n128 result = (uint64_t **)sub_1001A0A0C(v5, (void *)((char *)a2 + 28));
      CFTypeID v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          char v13 = v12;
          CFTypeID v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          char v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_1009129D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001A09B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1009129F0()
{
}

void *sub_100912A04(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A19F98;
  result[1] = v3;
  return result;
}

uint64_t sub_100912A4C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A19F98;
  a2[1] = v2;
  return result;
}

void sub_100912A78(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2[91])
  {
    int v3 = *a2;
    uint64_t v4 = v2[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "is";
      if (!v3) {
        uint64_t v5 = "is not";
      }
      LODWORD(v23) = 136315138;
      *(void *)((char *)&v23 + 4) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Baseband booted assertion %s granted for auth", (uint8_t *)&v23, 0xCu);
    }
    if (v3)
    {
      sub_1008F9CE0((uint64_t)v2);
      return;
    }
    char v6 = (std::__shared_weak_count *)v2[92];
    v2[91] = 0;
    v2[92] = 0;
    if (v6) {
      sub_10004D2C8(v6);
    }
    uint64_t v7 = (void **)v2[94];
    int v8 = (void **)v2[95];
    if (v8 == v7)
    {
      long long v15 = v2 + 98;
      int v8 = (void **)v2[94];
    }
    else
    {
      unint64_t v9 = v2[97];
      BOOL v10 = &v7[v9 >> 6];
      BOOL v11 = (char *)*v10 + 64 * (v9 & 0x3F);
      uint64_t v12 = *(uint64_t *)((char *)v7 + (((v2[98] + v9) >> 3) & 0x1FFFFFFFFFFFFFF8)) + 64 * ((v2[98] + v9) & 0x3F);
      if (v11 != (char *)v12)
      {
        do
        {
          *((void *)&v23 + 1) = 0;
          uint64_t v24 = 0;
          *(void *)&long long v23 = (char *)&v23 + 8;
          uint64_t v13 = *((void *)v11 + 7);
          if (!v13) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t, long long *))(*(void *)v13 + 48))(v13, &v23);
          sub_10026CF54((uint64_t)&v23, *((void **)&v23 + 1));
          v11 += 64;
          if (v11 - (unsigned char *)*v10 == 4096)
          {
            long long v14 = (char *)v10[1];
            ++v10;
            BOOL v11 = v14;
          }
        }
        while (v11 != (char *)v12);
        uint64_t v7 = (void **)v2[94];
        int v8 = (void **)v2[95];
      }
      long long v15 = v2 + 98;
      if (v8 == v7)
      {
        uint64_t v7 = v8;
      }
      else
      {
        unint64_t v16 = v2[97];
        uint64_t v17 = &v7[v16 >> 6];
        uint64_t v18 = (char *)*v17 + 64 * (v16 & 0x3F);
        uint64_t v19 = *(uint64_t *)((char *)v7 + (((v2[98] + v16) >> 3) & 0x1FFFFFFFFFFFFFF8)) + 64 * ((v2[98] + v16) & 0x3F);
        if (v18 != (char *)v19)
        {
          do
          {
            sub_100273F20((void *)v18 + 4);
            sub_10026CF54((uint64_t)(v18 + 8), *((void **)v18 + 2));
            v18 += 64;
            if (v18 - (unsigned char *)*v17 == 4096)
            {
              uint64_t v20 = (char *)v17[1];
              ++v17;
              uint64_t v18 = v20;
            }
          }
          while (v18 != (char *)v19);
          int v8 = (void **)v2[95];
          uint64_t v7 = (void **)v2[94];
        }
      }
    }
    void *v15 = 0;
    unint64_t v21 = (char *)v8 - (char *)v7;
    if (v21 >= 0x11)
    {
      do
      {
        operator delete(*v7);
        uint64_t v7 = (void **)(v2[94] + 8);
        v2[94] = v7;
        unint64_t v21 = v2[95] - (void)v7;
      }
      while (v21 > 0x10);
    }
    if (v21 >> 3 == 1)
    {
      uint64_t v22 = 32;
    }
    else
    {
      if (v21 >> 3 != 2) {
        return;
      }
      uint64_t v22 = 64;
    }
    v2[97] = v22;
  }
}

void sub_100912D24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100912D48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100912D88()
{
}

void *sub_100912D94(void *a1)
{
  *a1 = off_101A1A018;
  sub_100273F20(a1 + 7);
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100912DF0(void *a1)
{
  *a1 = off_101A1A018;
  sub_100273F20(a1 + 7);
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

void *sub_100912E6C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A1A018;
  sub_100913254((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100912EC0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100912ED4(uint64_t a1, void *a2)
{
  *a2 = off_101A1A018;
  return sub_100913254((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100912F00(uint64_t a1)
{
}

void sub_100912F08(void *a1)
{
  sub_1009132E8(a1 + 1);

  operator delete(a1);
}

void sub_100912F44(uint64_t a1, void *a2)
{
  int v3 = a2 + 1;
  uint64_t v4 = a2[1];
  long long v14 = (uint64_t *)*a2;
  uint64_t v15 = v4;
  uint64_t v5 = a2[2];
  uint64_t v16 = v5;
  if (v5)
  {
    *(void *)(v4 + 16) = &v15;
    *a2 = v3;
    void *v3 = 0;
    a2[2] = 0;
  }
  else
  {
    long long v14 = &v15;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 32);
  int v8 = **(NSObject ***)(v7 + 352);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = subscriber::asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Received response for auth for type %s", (uint8_t *)&buf, 0xCu);
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v5 = v16;
  }
  int v10 = *(_DWORD *)(v7 + 36);
  int v11 = *(_DWORD *)(a1 + 48);
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000;
  uint64_t v19 = sub_1008A4DCC;
  uint64_t v20 = &unk_101A14DB0;
  BOOL v23 = v5 != 0;
  int v21 = v11;
  int v22 = v10;
  sub_1008A4BEC((wis::MetricFactory *)0x800F0);
  sub_10026E7F8((uint64_t *)&buf, (uint64_t)&v14);
  uint64_t v12 = *(void *)(a1 + 80);
  if (v12)
  {
    (*(void (**)(uint64_t, long long *))(*(void *)v12 + 48))(v12, &buf);
    sub_10026CF54((uint64_t)&buf, *((void **)&buf + 1));
    uint64_t v13 = *(void *)(a1 + 24);
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    v17[0] = 0;
    v17[1] = 0;
    sub_10003E168(v17, (void *)(v6 + 8));
    operator new();
  }
  sub_10007B600();
}

void sub_1009131C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100913208(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100913248()
{
}

uint64_t sub_100913254(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  sub_10090DFD0(a1 + 48, a2 + 48);
  return a1;
}

void sub_1009132C4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 32);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009132E8(void *a1)
{
  sub_100273F20(a1 + 6);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

uint64_t *sub_100913340(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  int v8 = v1;
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v4 = v1[2];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(v3 + 728) = v2;
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 736);
  *(void *)(v3 + 736) = v4;
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (*(unsigned char *)(v3 + 800)) {
    *(unsigned char *)(v3 + 800) = 0;
  }
  sub_1008F9CE0(v3);
  sub_1000E1A60((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_1009133BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_1009133D8(void *a1)
{
  *a1 = off_101A1A098;
  sub_10090EC3C(a1 + 4);
  return a1;
}

void sub_10091341C(void *a1)
{
  *a1 = off_101A1A098;
  sub_10090EC3C(a1 + 4);

  operator delete();
}

char *sub_100913480(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = off_101A1A098;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *((_DWORD *)v2 + 6) = *(_DWORD *)(a1 + 24);
  sub_10090EBA4((uint64_t)(v2 + 32), a1 + 32);
  return v2;
}

void sub_1009134E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009134FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1A098;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return sub_10090EBA4(a2 + 32, a1 + 32);
}

void *sub_100913538(uint64_t a1)
{
  return sub_10090EC3C((void *)(a1 + 32));
}

void sub_100913540(void *a1)
{
  sub_10090EC3C(a1 + 4);

  operator delete(a1);
}

void sub_10091357C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v5 = *(void **)(a1 + 8);
  for (uint64_t i = (void *)v5[21]; i != (void *)v5[22]; i += 2)
  {
    uint64_t v7 = *i;
    if (*(_DWORD *)(*i + 36) == *(_DWORD *)(a1 + 20))
    {
      int v10 = (std::__shared_weak_count *)i[1];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(v7 + 32))
      {
        int v11 = **(NSObject ***)(v7 + 352);
        if (v4)
        {
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = subscriber::asString();
            uint64_t v13 = v4[1] - *v4;
            *(_DWORD *)uint64_t v15 = 136315394;
            *(void *)&v15[4] = v12;
            *(_WORD *)&v15[12] = 2048;
            *(void *)&v15[14] = v13;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Received data for file %s of length %lu", v15, 0x16u);
          }
        }
        else if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v15 = 136315138;
          *(void *)&v15[4] = subscriber::asString();
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Read error or no data for file %s", v15, 0xCu);
        }
        *(void *)uint64_t v15 = v4;
        *(void *)&v15[8] = v3;
        if (v3) {
          atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1008FB224(*(void *)(a1 + 56), 1);
      }
      else
      {
        long long v14 = **(NSObject ***)(v7 + 352);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v15 = 136315650;
          *(void *)&v15[4] = subscriber::asString();
          *(_WORD *)&v15[12] = 2080;
          *(void *)&v15[14] = subscriber::asString();
          __int16 v16 = 2080;
          uint64_t v17 = subscriber::asString();
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Original HW slot %s not same as current HW slot %s, discarding data for %s", v15, 0x20u);
        }
        *(void *)uint64_t v15 = 0;
        *(void *)&v15[8] = 0;
        sub_1008FB224(*(void *)(a1 + 56), 0);
      }
      uint64_t v9 = *(std::__shared_weak_count **)&v15[8];
      if (*(void *)&v15[8]) {
LABEL_24:
      }
        sub_10004D2C8(v9);
      if (v10) {
        sub_10004D2C8(v10);
      }
      goto LABEL_27;
    }
  }
  int v8 = v5[5];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint64_t v15 = 136315394;
    *(void *)&v15[4] = subscriber::asString();
    *(_WORD *)&v15[12] = 2080;
    *(void *)&v15[14] = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No valid SIM for instance (%s), discarding data for %s", v15, 0x16u);
  }
  *(void *)uint64_t v15 = 0;
  *(void *)&v15[8] = 0;
  sub_1008FB224(*(void *)(a1 + 56), 0);
  uint64_t v9 = *(std::__shared_weak_count **)&v15[8];
  if (*(void *)&v15[8])
  {
    int v10 = 0;
    goto LABEL_24;
  }
LABEL_27:
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100913870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009138CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10091390C()
{
}

void *sub_100913918(void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10091399C(void *a1)
{
  *a1 = off_101A1A128;
  sub_1008FDF70(a1 + 5);
  long long v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1009139F0(void *a1)
{
  *a1 = off_101A1A128;
  sub_1008FDF70(a1 + 5);
  long long v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

void *sub_100913A64(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  long long v2 = operator new(0x48uLL);
  *long long v2 = off_101A1A128;
  sub_100913CF4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100913AB8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100913ACC(uint64_t a1, void *a2)
{
  *a2 = off_101A1A128;
  return sub_100913CF4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100913AF8(uint64_t a1)
{
}

void sub_100913B00(void *a1)
{
  sub_100913D78(a1 + 1);

  operator delete(a1);
}

void sub_100913B3C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  if (v3)
  {
    uint64_t v12 = 0;
    v13[0] = 0;
    v13[1] = 0;
    sub_10005C928(&v12, *(const void **)v3, *(void *)(v3 + 8), *(void *)(v3 + 8) - *(void *)v3);
    uint64_t v5 = v13;
    char v14 = 1;
    uint64_t v6 = *(void *)(a1 + 64);
    if (!v6) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void **))(*(void *)v6 + 48))(v6, &v12);
    if (!v14) {
      goto LABEL_10;
    }
    uint64_t v7 = v12;
    if (!v12) {
      goto LABEL_10;
    }
LABEL_9:
    *uint64_t v5 = (uint64_t)v7;
    operator delete(v7);
    goto LABEL_10;
  }
  uint64_t v5 = &v10;
  LOBYTE(__p) = 0;
  char v11 = 0;
  uint64_t v8 = *(void *)(a1 + 64);
  if (!v8) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v8 + 48))(v8, &__p);
  if (v11)
  {
    uint64_t v7 = __p;
    if (__p) {
      goto LABEL_9;
    }
  }
LABEL_10:
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100913C58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100913CA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100913CE8()
{
}

uint64_t sub_100913CF4(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1003A10E0((void *)(a1 + 8), *(const void **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 1);
  sub_10090F628(a1 + 32, a2 + 32);
  return a1;
}

void sub_100913D5C(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_100913D78(void *a1)
{
  sub_1008FDF70(a1 + 4);
  long long v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
}

uint64_t sub_100913DC8(void *a1, uint64_t a2)
{
  uint64_t v4 = (char *)a1[1];
  uint64_t v5 = (char *)a1[2];
  uint64_t v6 = v5 - v4;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 16 * (v5 - v4) - 1;
  }
  unint64_t v8 = a1[4];
  if (v7 != a1[5] + v8) {
    goto LABEL_38;
  }
  BOOL v9 = v8 >= 0x80;
  unint64_t v10 = v8 - 128;
  if (v9)
  {
    a1[4] = v10;
    uint64_t v13 = *(void *)v4;
    char v11 = v4 + 8;
    uint64_t v12 = v13;
    a1[1] = v11;
    if (v5 == (char *)a1[3])
    {
      uint64_t v14 = (uint64_t)&v11[-*a1];
      if ((unint64_t)v11 <= *a1)
      {
        if (v5 == (char *)*a1) {
          unint64_t v41 = 1;
        }
        else {
          unint64_t v41 = (uint64_t)&v5[-*a1] >> 2;
        }
        uint64_t v42 = (char *)sub_100048350(v41);
        uint64_t v44 = &v42[8 * (v41 >> 2)];
        uint64_t v45 = (uint64_t *)a1[1];
        uint64_t v5 = v44;
        uint64_t v46 = a1[2] - (void)v45;
        if (v46)
        {
          uint64_t v5 = &v44[v46 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v47 = 8 * (v46 >> 3);
          uint64_t v48 = &v42[8 * (v41 >> 2)];
          do
          {
            uint64_t v49 = *v45++;
            *(void *)uint64_t v48 = v49;
            v48 += 8;
            v47 -= 8;
          }
          while (v47);
        }
        long long v50 = (char *)*a1;
        *a1 = v42;
        a1[1] = v44;
        a1[2] = v5;
        a1[3] = &v42[8 * v43];
        if (v50)
        {
          operator delete(v50);
          uint64_t v5 = (char *)a1[2];
        }
      }
      else
      {
        uint64_t v15 = v14 >> 3;
        BOOL v16 = v14 >> 3 < -1;
        uint64_t v17 = (v14 >> 3) + 2;
        if (v16) {
          uint64_t v18 = v17;
        }
        else {
          uint64_t v18 = v15 + 1;
        }
        uint64_t v19 = -(v18 >> 1);
        uint64_t v20 = v18 >> 1;
        int v21 = &v11[-8 * v20];
        int64_t v22 = v5 - v11;
        if (v5 != v11)
        {
          memmove(&v11[-8 * v20], v11, v5 - v11);
          uint64_t v5 = (char *)a1[1];
        }
        BOOL v23 = &v5[8 * v19];
        uint64_t v5 = &v21[v22];
        a1[1] = v23;
        a1[2] = &v21[v22];
      }
    }
    *(void *)uint64_t v5 = v12;
  }
  else
  {
    uint64_t v24 = v6 >> 3;
    long long v25 = (char *)a1[3];
    uint64_t v26 = (char *)*a1;
    uint64_t v27 = (uint64_t)&v25[-*a1];
    if (v6 >> 3 >= (unint64_t)(v27 >> 3))
    {
      uint64_t v30 = v27 >> 2;
      if (v25 == v26) {
        unint64_t v31 = 1;
      }
      else {
        unint64_t v31 = v30;
      }
      uint64_t v32 = (char *)sub_100048350(v31);
      uint64_t v34 = v33;
      uint64_t v35 = operator new(0x1000uLL);
      long long v36 = &v32[8 * v24];
      uint64_t v37 = &v32[8 * v34];
      if (v24 == v34)
      {
        uint64_t v38 = 8 * v24;
        if (v6 < 1)
        {
          uint64_t v76 = v35;
          uint64_t v77 = v38 >> 2;
          if (v5 == v4) {
            unint64_t v78 = 1;
          }
          else {
            unint64_t v78 = v77;
          }
          uint64_t v79 = (char *)sub_100048350(v78);
          long long v36 = &v79[8 * (v78 >> 2)];
          uint64_t v37 = &v79[8 * v80];
          if (v32) {
            operator delete(v32);
          }
          uint64_t v32 = v79;
          uint64_t v35 = v76;
        }
        else
        {
          uint64_t v39 = v38 >> 3;
          if (v39 >= -1) {
            unint64_t v40 = v39 + 1;
          }
          else {
            unint64_t v40 = v39 + 2;
          }
          v36 -= 8 * (v40 >> 1);
        }
      }
      *(void *)long long v36 = v35;
      uint64_t v5 = v36 + 8;
      for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
      {
        if (v36 == v32)
        {
          if (v5 >= v37)
          {
            if (v37 == v32) {
              unint64_t v86 = 1;
            }
            else {
              unint64_t v86 = (v37 - v32) >> 2;
            }
            uint64_t v87 = (char *)sub_100048350(v86);
            uint64_t v89 = v87;
            long long v36 = &v87[(2 * v86 + 6) & 0xFFFFFFFFFFFFFFF8];
            uint64_t v91 = v5 - v32;
            BOOL v90 = v5 == v32;
            uint64_t v5 = v36;
            if (!v90)
            {
              uint64_t v5 = &v36[v91 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v92 = 8 * (v91 >> 3);
              uint64_t v93 = v36;
              long long v94 = v32;
              do
              {
                uint64_t v95 = *(void *)v94;
                v94 += 8;
                *(void *)uint64_t v93 = v95;
                v93 += 8;
                v92 -= 8;
              }
              while (v92);
            }
            uint64_t v37 = &v87[8 * v88];
            if (v32) {
              operator delete(v32);
            }
            uint64_t v32 = v89;
          }
          else
          {
            uint64_t v82 = (v37 - v5) >> 3;
            if (v82 >= -1) {
              uint64_t v83 = v82 + 1;
            }
            else {
              uint64_t v83 = v82 + 2;
            }
            uint64_t v84 = v83 >> 1;
            long long v36 = &v32[8 * (v83 >> 1)];
            uint64_t v85 = v32;
            if (v5 != v32)
            {
              memmove(v36, v32, v5 - v32);
              uint64_t v85 = v5;
            }
            uint64_t v5 = &v85[8 * v84];
          }
        }
        uint64_t v96 = *(void *)(i - 8);
        *((void *)v36 - 1) = v96;
        v36 -= 8;
      }
      unsigned int v97 = (char *)*a1;
      *a1 = v32;
      a1[1] = v36;
      a1[2] = v5;
      a1[3] = v37;
      if (v97)
      {
        operator delete(v97);
        uint64_t v5 = (char *)a1[2];
      }
      goto LABEL_37;
    }
    uint64_t v28 = operator new(0x1000uLL);
    int v29 = v28;
    if (v25 == v5)
    {
      if (v4 == v26)
      {
        if (v5 == v4) {
          unint64_t v54 = 1;
        }
        else {
          unint64_t v54 = (v25 - v4) >> 2;
        }
        uint64_t v55 = 2 * v54;
        unsigned int v56 = (char *)sub_100048350(v54);
        uint64_t v4 = &v56[(v55 + 6) & 0xFFFFFFFFFFFFFFF8];
        int v58 = (uint64_t *)a1[1];
        unint64_t v59 = v4;
        uint64_t v60 = a1[2] - (void)v58;
        if (v60)
        {
          unint64_t v59 = &v4[v60 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v61 = 8 * (v60 >> 3);
          long long v62 = &v56[(v55 + 6) & 0xFFFFFFFFFFFFFFF8];
          do
          {
            uint64_t v63 = *v58++;
            *(void *)long long v62 = v63;
            v62 += 8;
            v61 -= 8;
          }
          while (v61);
        }
        uint64_t v64 = (char *)*a1;
        *a1 = v56;
        a1[1] = v4;
        a1[2] = v59;
        a1[3] = &v56[8 * v57];
        if (v64)
        {
          operator delete(v64);
          uint64_t v4 = (char *)a1[1];
        }
      }
      *((void *)v4 - 1) = v29;
      uint64_t v65 = (char *)a1[1];
      uint64_t v66 = (char *)a1[2];
      a1[1] = v65 - 8;
      uint64_t v67 = *((void *)v65 - 1);
      a1[1] = v65;
      if (v66 == (char *)a1[3])
      {
        uint64_t v68 = (uint64_t)&v65[-*a1];
        if ((unint64_t)v65 <= *a1)
        {
          if (v66 == (char *)*a1) {
            unint64_t v98 = 1;
          }
          else {
            unint64_t v98 = (uint64_t)&v66[-*a1] >> 2;
          }
          uint64_t v99 = (char *)sub_100048350(v98);
          uint64_t v101 = &v99[8 * (v98 >> 2)];
          uint64_t v102 = (uint64_t *)a1[1];
          uint64_t v66 = v101;
          uint64_t v103 = a1[2] - (void)v102;
          if (v103)
          {
            uint64_t v66 = &v101[v103 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v104 = 8 * (v103 >> 3);
            uint64_t v105 = &v99[8 * (v98 >> 2)];
            do
            {
              uint64_t v106 = *v102++;
              *(void *)uint64_t v105 = v106;
              v105 += 8;
              v104 -= 8;
            }
            while (v104);
          }
          char v107 = (char *)*a1;
          *a1 = v99;
          a1[1] = v101;
          a1[2] = v66;
          a1[3] = &v99[8 * v100];
          if (v107)
          {
            operator delete(v107);
            uint64_t v66 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v69 = v68 >> 3;
          BOOL v16 = v68 >> 3 < -1;
          uint64_t v70 = (v68 >> 3) + 2;
          if (v16) {
            uint64_t v71 = v70;
          }
          else {
            uint64_t v71 = v69 + 1;
          }
          uint64_t v72 = -(v71 >> 1);
          uint64_t v73 = v71 >> 1;
          uint64_t v74 = &v65[-8 * v73];
          int64_t v75 = v66 - v65;
          if (v66 != v65)
          {
            memmove(&v65[-8 * v73], v65, v66 - v65);
            uint64_t v65 = (char *)a1[1];
          }
          uint64_t v66 = &v74[v75];
          a1[1] = &v65[8 * v72];
          a1[2] = &v74[v75];
        }
      }
      *(void *)uint64_t v66 = v67;
    }
    else
    {
      *(void *)uint64_t v5 = v28;
    }
  }
  uint64_t v5 = (char *)(a1[2] + 8);
  a1[2] = v5;
LABEL_37:
  uint64_t v4 = (char *)a1[1];
LABEL_38:
  if (v5 == v4)
  {
    uint64_t v52 = 0;
  }
  else
  {
    unint64_t v51 = a1[5] + a1[4];
    uint64_t v52 = *(void *)&v4[(v51 >> 4) & 0xFFFFFFFFFFFFFF8] + 32 * (v51 & 0x7F);
  }
  uint64_t result = sub_1000DA470(v52, a2);
  ++a1[5];
  return result;
}

void sub_1009142A8(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

void *sub_1009142D4(void *a1)
{
  *a1 = off_101A1A1A8;
  sub_100060644(a1 + 9);
  long long v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_100914334(void *a1)
{
  *a1 = off_101A1A1A8;
  sub_100060644(a1 + 9);
  long long v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }

  operator delete();
}

void *sub_1009143B4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  long long v2 = operator new(0x68uLL);
  *long long v2 = off_101A1A1A8;
  sub_100914638((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100914408(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10091441C(uint64_t a1, void *a2)
{
  *a2 = off_101A1A1A8;
  return sub_100914638((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100914448(uint64_t a1)
{
}

void sub_100914450(void *a1)
{
  sub_1009146E4(a1 + 1);

  operator delete(a1);
}

void sub_10091448C(void *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = *(void *)(v2 + 104);
  uint64_t v4 = (std::__shared_weak_count *)a1[8];
  uint64_t v7 = a1[7];
  unint64_t v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = v2;
  sub_1000DFC90((uint64_t)v10, (uint64_t)(a1 + 9));
  uint64_t v12 = 0;
  uint64_t v5 = operator new(0x30uLL);
  uint64_t v6 = v9;
  *uint64_t v5 = off_101A1A218;
  v5[1] = v6;
  sub_100023950((uint64_t)(v5 + 2), (uint64_t)v10);
  uint64_t v12 = v5;
  (*(void (**)(uint64_t, void *, uint64_t *, void *))(*(void *)v3 + 120))(v3, a1 + 2, &v7, v11);
  sub_100060644(v11);
  sub_100060644(v10);
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_1009145B0(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100060644((uint64_t *)va);
  sub_100060644(v8);
  if (a3) {
    sub_10004D2C8(a3);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1009145EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10091462C()
{
}

uint64_t sub_100914638(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  long long v4 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = 0;
  uint64_t v5 = a1 + 24;
  *(_OWORD *)(a1 + 8) = v4;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_10005C928((void *)(a1 + 24), *(const void **)(a2 + 24), *(void *)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
  uint64_t v6 = *(void *)(a2 + 56);
  *(void *)(v5 + 24) = *(void *)(a2 + 48);
  *(void *)(v5 + 32) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 64, a2 + 64);
  return a1;
}

void sub_1009146BC(_Unwind_Exception *exception_object)
{
  long long v4 = *(std::__shared_weak_count **)(v1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009146E4(void *a1)
{
  sub_100060644(a1 + 8);
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }
}

void *sub_100914740(void *a1)
{
  *a1 = off_101A1A218;
  sub_100060644(a1 + 2);
  return a1;
}

void sub_100914784(void *a1)
{
  *a1 = off_101A1A218;
  sub_100060644(a1 + 2);

  operator delete();
}

void *sub_1009147E8(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A1A218;
  v2[1] = v3;
  sub_1000DFC90((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100914840(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100914854(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A1A218;
  a2[1] = v2;
  return sub_1000DFC90((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100914884(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 16));
}

void sub_10091488C(void *a1)
{
  sub_100060644(a1 + 2);

  operator delete(a1);
}

uint64_t sub_1009148C8(uint64_t a1, char *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1000607A8(a1 + 16, *a2);
  sub_10091495C(v2 + 912);

  return sub_1008FB388(v2);
}

uint64_t sub_100914910(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100914950()
{
}

void sub_10091495C(uint64_t a1)
{
  sub_10003B34C((void *)(*(void *)(*(void *)(a1 + 8) + ((*(void *)(a1 + 32) >> 4) & 0xFFFFFFFFFFFFFF8))
                         + 32 * (*(void *)(a1 + 32) & 0x7FLL)));
  int64x2_t v2 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_10144F900);
  *(int64x2_t *)(a1 + 32) = v2;
  if (v2.i64[0] >= 0x100uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 128;
  }
}

void *sub_1009149E0(void *a1)
{
  *a1 = off_101A1A2A8;
  sub_100060644(a1 + 12);
  int64x2_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = (void *)a1[4];
  if (v4)
  {
    a1[5] = v4;
    operator delete(v4);
  }
  return a1;
}

void sub_100914A4C(void *a1)
{
  *a1 = off_101A1A2A8;
  sub_100060644(a1 + 12);
  int64x2_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = (void *)a1[4];
  if (v4)
  {
    a1[5] = v4;
    operator delete(v4);
  }

  operator delete();
}

void *sub_100914AD8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int64x2_t v2 = operator new(0x80uLL);
  *int64x2_t v2 = off_101A1A2A8;
  sub_100914DA0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100914B2C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100914B40(uint64_t a1, void *a2)
{
  *a2 = off_101A1A2A8;
  return sub_100914DA0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100914B6C(uint64_t a1)
{
}

void sub_100914B74(void *a1)
{
  sub_100914E78(a1 + 1);

  operator delete(a1);
}

void sub_100914BB0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 104);
  long long v4 = *(std::__shared_weak_count **)(a1 + 64);
  uint64_t v11 = *(void *)(a1 + 56);
  uint64_t v12 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(unsigned __int8 *)(a1 + 72);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 88);
  uint64_t v9 = *(void *)(a1 + 80);
  unint64_t v10 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = v2;
  sub_1000DFC90((uint64_t)v14, a1 + 96);
  BOOL v16 = 0;
  uint64_t v7 = operator new(0x30uLL);
  uint64_t v8 = v13;
  *uint64_t v7 = off_101A1A318;
  v7[1] = v8;
  sub_100023950((uint64_t)(v7 + 2), (uint64_t)v14);
  BOOL v16 = v7;
  (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t *, void *))(*(void *)v3 + 128))(v3, a1 + 16, &v11, v5, &v9, v15);
  sub_100060644(v15);
  sub_100060644(v14);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_100914D0C(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_100060644((uint64_t *)va);
  sub_100060644(v10);
  if (a3) {
    sub_10004D2C8(a3);
  }
  if (a5) {
    sub_10004D2C8(a5);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100914D54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100914D94()
{
}

uint64_t sub_100914DA0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  long long v4 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = 0;
  uint64_t v5 = a1 + 24;
  *(_OWORD *)(a1 + 8) = v4;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_10005C928((void *)(a1 + 24), *(const void **)(a2 + 24), *(void *)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
  uint64_t v6 = *(void *)(a2 + 56);
  *(void *)(v5 + 24) = *(void *)(a2 + 48);
  *(void *)(v5 + 32) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  uint64_t v7 = *(void *)(a2 + 80);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a1 + 80) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 88, a2 + 88);
  return a1;
}

void sub_100914E44(_Unwind_Exception *exception_object)
{
  long long v4 = (std::__shared_weak_count *)v1[10];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)v1[7];
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *v2;
  if (*v2)
  {
    v1[4] = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

void sub_100914E78(void *a1)
{
  sub_100060644(a1 + 11);
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = (void *)a1[3];
  if (v4)
  {
    a1[4] = v4;
    operator delete(v4);
  }
}

void *sub_100914EE0(void *a1)
{
  *a1 = off_101A1A318;
  sub_100060644(a1 + 2);
  return a1;
}

void sub_100914F24(void *a1)
{
  *a1 = off_101A1A318;
  sub_100060644(a1 + 2);

  operator delete();
}

void *sub_100914F88(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A1A318;
  v2[1] = v3;
  sub_1000DFC90((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100914FE0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100914FF4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A1A318;
  a2[1] = v2;
  return sub_1000DFC90((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100915024(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 16));
}

void sub_10091502C(void *a1)
{
  sub_100060644(a1 + 2);

  operator delete(a1);
}

uint64_t sub_100915068(uint64_t a1, char *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1000607A8(a1 + 16, *a2);
  sub_10091495C(v2 + 912);

  return sub_1008FB388(v2);
}

uint64_t sub_1009150B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009150F0()
{
}

void *sub_1009150FC(void *a1)
{
  *a1 = off_101A1A3A8;
  sub_100060644(a1 + 7);
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_100915150(void *a1)
{
  *a1 = off_101A1A3A8;
  sub_100060644(a1 + 7);
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }

  operator delete();
}

void *sub_1009151C4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A1A3A8;
  sub_1009153EC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100915218(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10091522C(uint64_t a1, void *a2)
{
  *a2 = off_101A1A3A8;
  return sub_1009153EC((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100915258(uint64_t a1)
{
}

void sub_100915260(void *a1)
{
  sub_100915474(a1 + 1);

  operator delete(a1);
}

void *sub_10091529C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  sub_1000DFC90((uint64_t)v4, a1 + 56);
  uint64_t v6 = 0;
  uint64_t v1 = operator new(0x30uLL);
  *uint64_t v1 = off_101A1A418;
  v1[1] = v3;
  sub_100023950((uint64_t)(v1 + 2), (uint64_t)v4);
  uint64_t v6 = v1;
  subscriber::SimCommandDriver::sendSimReset();
  sub_100060644(v5);
  return sub_100060644(v4);
}

void sub_100915374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100060644((uint64_t *)va);
  sub_100060644(v6);
  _Unwind_Resume(a1);
}

uint64_t sub_1009153A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009153E0()
{
}

uint64_t sub_1009153EC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  long long v4 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = 0;
  uint64_t v5 = a1 + 24;
  *(_OWORD *)(a1 + 8) = v4;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_10005C928((void *)(a1 + 24), *(const void **)(a2 + 24), *(void *)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
  sub_1000DFC90(v5 + 24, a2 + 48);
  return a1;
}

void sub_100915458(_Unwind_Exception *exception_object)
{
  long long v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_100915474(void *a1)
{
  sub_100060644(a1 + 6);
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
}

void *sub_1009154C4(void *a1)
{
  *a1 = off_101A1A418;
  sub_100060644(a1 + 2);
  return a1;
}

void sub_100915508(void *a1)
{
  *a1 = off_101A1A418;
  sub_100060644(a1 + 2);

  operator delete();
}

void *sub_10091556C(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A1A418;
  v2[1] = v3;
  sub_1000DFC90((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_1009155C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009155D8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A1A418;
  a2[1] = v2;
  return sub_1000DFC90((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100915608(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 16));
}

void sub_100915610(void *a1)
{
  sub_100060644(a1 + 2);

  operator delete(a1);
}

uint64_t sub_10091564C(uint64_t a1, char *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1000607A8(a1 + 16, *a2);
  sub_10091495C(v2 + 912);

  return sub_1008FB388(v2);
}

uint64_t sub_100915694(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009156D4()
{
}

uint64_t *sub_1009156E0(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (!v5)
  {
    uint64_t v8 = a1 + 1;
LABEL_9:
    unint64_t v10 = *a3;
    uint64_t v11 = (uint64_t *)operator new(0x40uLL);
    uint64_t v12 = v11 + 4;
    if (*((char *)v10 + 23) < 0)
    {
      sub_10004FC84(v12, *(void **)v10, *((void *)v10 + 1));
    }
    else
    {
      long long v13 = *v10;
      void v11[6] = *((void *)v10 + 2);
      *(_OWORD *)uint64_t v12 = v13;
    }
    *((_WORD *)v11 + 28) = 0;
    uint64_t *v11 = 0;
    v11[1] = 0;
    void v11[2] = (uint64_t)v8;
    void *v6 = v11;
    uint64_t v14 = (uint64_t *)**a1;
    uint64_t v15 = v11;
    if (v14)
    {
      *a1 = v14;
      uint64_t v15 = *v6;
    }
    sub_100046C90(a1[1], v15);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return v11;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t **)v5;
      uint64_t v9 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      uint64_t v6 = v8;
      if (!*v8) {
        goto LABEL_9;
      }
    }
    if ((sub_100046FE8(v9, a2) & 0x80) == 0) {
      break;
    }
    uint64_t v6 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_9;
    }
  }
  uint64_t v11 = *v6;
  if (!*v6) {
    goto LABEL_9;
  }
  return v11;
}

void sub_1009157F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100915808(void *a1)
{
  *a1 = off_101A1A4A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100915854(void *a1)
{
  *a1 = off_101A1A4A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_1009158C0(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A1A4A8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100915924(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1A4A8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100915964(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100915974(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_1009159B4(uint64_t a1, _WORD *a2)
{
  if ((unsigned __int16)*a2 > 0xFFu)
  {
    long long v4 = *(void **)(a1 + 8);
    if (!*a2)
    {
      __p[0] = 0;
      __p[1] = 0;
      sub_10003E168(__p, v4 + 1);
      operator new();
    }
    uint64_t v5 = **(NSObject ***)(a1 + 16);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Cache is valid, try auto unlock", (uint8_t *)__p, 2u);
    }
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 32);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(unsigned int *)(v6 + 36);
    sub_1013B9F28(v6, (uint64_t)__p);
    (*(void (**)(void *, uint64_t, void **))(*v4 + 104))(v4, v8, __p);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
  else
  {
    uint64_t v3 = **(NSObject ***)(a1 + 16);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Do not know what to do ... so just do nothing", (uint8_t *)__p, 2u);
    }
  }
}

void sub_100915BA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100915BD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100915C14()
{
}

void sub_100915C20(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  for (uint64_t i = *(uint64_t **)(v2 + 168); ; i += 2)
  {
    if (i == *(uint64_t **)(v2 + 176))
    {
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      goto LABEL_8;
    }
    uint64_t v5 = *i;
    if (*(_DWORD *)(*i + 36) == v3) {
      break;
    }
  }
  uint64_t v6 = (std::__shared_weak_count *)i[1];
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = *((unsigned int *)v1 + 2);
  }
LABEL_8:
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
  if (v5)
  {
    char v10 = v7;
    if (*(unsigned char *)(v5 + 58))
    {
      sub_1013B85B4(v5, v8, v9);
      if (subscriber::isSimLocked())
      {
        if (*(unsigned char *)(v5 + 59))
        {
          uint64_t v20 = _os_activity_create((void *)&_mh_execute_header, "sim-pin-required", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
          state.opaque[0] = 0;
          state.opaque[1] = 0;
          os_activity_scope_enter(v20, &state);
          os_activity_scope_leave(&state);
          uint64_t v11 = *v10;
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(state.opaque[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I SIM PIN required: prompting UI #sim-pin", (uint8_t *)&state, 2u);
          }
          uint64_t v14 = *(void *)(v2 + 120);
          uint64_t v15 = *((unsigned int *)v1 + 2);
          uint64_t v16 = sub_1013B85B4(v5, v12, v13);
          (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v14 + 32))(v14, v15, v16, *(char *)(v5 + 59));
          int v17 = *((_DWORD *)v1 + 2);
          state.opaque[0] = (uint64_t)_NSConcreteStackBlock;
          state.opaque[1] = 0x40000000;
          int64_t v22 = sub_1008A436C;
          BOOL v23 = &unk_101A14D10;
          int v24 = v17;
          sub_1008A418C((wis::MetricFactory *)0x800A2);
          sub_100687EB8((void **)&v20);
          goto LABEL_22;
        }
        uint64_t v18 = *v10;
        if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_22;
        }
        LOWORD(state.opaque[0]) = 0;
        uint64_t v19 = "#I Zero PIN retry count";
      }
      else
      {
        uint64_t v18 = *v10;
        if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_22;
        }
        LOWORD(state.opaque[0]) = 0;
        uint64_t v19 = "#I SIM no longer locked";
      }
    }
    else
    {
      uint64_t v18 = *v7;
      if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_22;
      }
      LOWORD(state.opaque[0]) = 0;
      uint64_t v19 = "#I SIM is not Pin Protected";
    }
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&state, 2u);
  }
LABEL_22:
  if (v6) {
    sub_10004D2C8(v6);
  }
  operator delete();
}

void sub_100915EDC(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100687EB8((void **)va);
  if (v1) {
    sub_10004D2C8(v1);
  }
  operator delete();
}

void sub_100915F24(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  for (uint64_t i = *(uint64_t **)(v2 + 168); ; i += 2)
  {
    if (i == *(uint64_t **)(v2 + 176))
    {
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      goto LABEL_8;
    }
    uint64_t v5 = *i;
    if (*(_DWORD *)(*i + 36) == v3) {
      break;
    }
  }
  uint64_t v6 = (std::__shared_weak_count *)i[1];
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = *((unsigned int *)v1 + 2);
  }
LABEL_8:
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 16))(*(void *)(v2 + 56), v3);
  if (v5)
  {
    uint64_t v8 = v7;
    if (*(unsigned char *)(v5 + 58))
    {
      if (*(unsigned char *)(v5 + 60))
      {
        uint64_t v18 = _os_activity_create((void *)&_mh_execute_header, "sim-puk-required", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
        state.opaque[0] = 0;
        state.opaque[1] = 0;
        os_activity_scope_enter(v18, &state);
        os_activity_scope_leave(&state);
        unint64_t v9 = *v8;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(state.opaque[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I SIM PUK required: prompting UI #sim-pin", (uint8_t *)&state, 2u);
        }
        uint64_t v12 = *(void *)(v2 + 120);
        uint64_t v13 = *((unsigned int *)v1 + 2);
        uint64_t v14 = sub_1013B85B4(v5, v10, v11);
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v12 + 48))(v12, v13, v14, *(char *)(v5 + 60));
        int v15 = *((_DWORD *)v1 + 2);
        state.opaque[0] = (uint64_t)_NSConcreteStackBlock;
        state.opaque[1] = 0x40000000;
        uint64_t v20 = sub_1008A436C;
        int v21 = &unk_101A14D10;
        int v22 = v15;
        sub_1008A418C((wis::MetricFactory *)0x800A2);
        sub_100687EB8((void **)&v18);
        goto LABEL_19;
      }
      uint64_t v16 = *v7;
      if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      LOWORD(state.opaque[0]) = 0;
      int v17 = "#I Zero PUK retry count";
    }
    else
    {
      uint64_t v16 = *v7;
      if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      LOWORD(state.opaque[0]) = 0;
      int v17 = "#I SIM is not Pin Protected";
    }
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&state, 2u);
  }
LABEL_19:
  if (v6) {
    sub_10004D2C8(v6);
  }
  operator delete();
}

void sub_1009161A4(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100687EB8((void **)va);
  if (v1) {
    sub_10004D2C8(v1);
  }
  operator delete();
}

uint64_t sub_1009161EC(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    uint64_t v3 = (void *)(a1 + 16);
    if (v2[6] == *(void *)(a1 + 32))
    {
      long long v4 = (void *)v2[4];
      if (v4 == v2 + 5) {
        goto LABEL_24;
      }
      uint64_t v5 = (void *)*v3;
      while (1)
      {
        BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7)
          && *((unsigned __int8 *)v4 + 32) == *((unsigned __int8 *)v5 + 32);
        if (!v6) {
          break;
        }
        uint64_t v7 = (void *)v4[1];
        uint64_t v8 = v4;
        if (v7)
        {
          do
          {
            long long v4 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            long long v4 = (void *)v8[2];
            BOOL v6 = *v4 == (void)v8;
            uint64_t v8 = v4;
          }
          while (!v6);
        }
        unint64_t v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            uint64_t v10 = v9;
            unint64_t v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            uint64_t v10 = (void *)v5[2];
            BOOL v6 = *v10 == (void)v5;
            uint64_t v5 = v10;
          }
          while (!v6);
        }
        uint64_t v5 = v10;
        if (v4 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), v3);
    uint64_t v11 = v2[3];
    if (v11) {
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_100916320(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      BOOL v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100916398(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_1009163AC(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = (void *)a2[6];
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_1009163F8(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t sub_10091644C()
{
  v1[0] = xmmword_101508570;
  sub_100602B08((uint64_t)&qword_101B0E160, (int *)v1, 4);
  __cxa_atexit((void (*)(void *))sub_1008F1070, &qword_101B0E160, (void *)&_mh_execute_header);
  LODWORD(v1[0]) = 12;
  sub_100602B08((uint64_t)&qword_101B0E178, (int *)v1, 1);
  __cxa_atexit((void (*)(void *))sub_1008F1070, &qword_101B0E178, (void *)&_mh_execute_header);
  v1[0] = xmmword_101508580;
  sub_100602B08((uint64_t)&qword_101B0E190, (int *)v1, 4);
  __cxa_atexit((void (*)(void *))sub_1008F1070, &qword_101B0E190, (void *)&_mh_execute_header);
  v1[0] = xmmword_101508590;
  v1[1] = unk_1015085A0;
  void v1[2] = xmmword_1015085B0;
  v1[3] = unk_1015085C0;
  uint64_t v2 = 0x1F0000001BLL;
  sub_100602B08((uint64_t)&qword_101B0E1A8, (int *)v1, 18);
  return __cxa_atexit((void (*)(void *))sub_1008F1070, &qword_101B0E1A8, (void *)&_mh_execute_header);
}

uint64_t sub_1009165A4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    sub_10091722C(result);
    operator delete();
  }
  return result;
}

void sub_1009165E8(CFReadStreamRef *a1, __CFRunLoop *a2)
{
  os_log_t oslog = 0;
  long long v4 = (const char *)kCtLoggingSystemName;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, v4, LogGroupName);
  BOOL v6 = oslog;
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    CFReadStreamRef v7 = *a1;
    *(_DWORD *)long long buf = 134218240;
    CFReadStreamRef v13 = v7;
    __int16 v14 = 2048;
    int v15 = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I dispose stream %p from runloop %p", buf, 0x16u);
  }
  uint64_t v8 = *a1;
  if (*a1)
  {
    if (a2)
    {
      CFReadStreamUnscheduleFromRunLoop(v8, a2, kCFRunLoopCommonModes);
      unint64_t v9 = oslog;
      BOOL v10 = os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT);
      uint64_t v8 = *a1;
      if (v10)
      {
        *(_DWORD *)long long buf = 134218240;
        CFReadStreamRef v13 = v8;
        __int16 v14 = 2048;
        int v15 = a2;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Unscheduling stream %p from runloop %p", buf, 0x16u);
        uint64_t v8 = *a1;
      }
    }
    CFReadStreamSetClient(v8, 0, 0, 0);
    CFReadStreamClose(*a1);
    CFRelease(*a1);
    *a1 = 0;
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
}

void sub_100916774(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_100916790(CFDictionaryRef *a1@<X0>, int a2@<W1>, const void **a3@<X8>)
{
  os_log_t oslog = 0;
  BOOL v6 = (const char *)kCtLoggingSystemName;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, v6, LogGroupName);
  *a3 = 0;
  if (*a1) {
    uint64_t v8 = sub_100080778;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*a1, @"RATOverrides");
    CFArrayRef v10 = Value;
    if (Value)
    {
      CFTypeID v11 = CFGetTypeID(Value);
      if (v11 == CFArrayGetTypeID())
      {
        BOOL v12 = sub_100C936EC(v10, @"technology-mask");
        CFIndex Count = CFArrayGetCount(v10);
        if (Count >= 1)
        {
          CFIndex v14 = 0;
          while (1)
          {
            while (1)
            {
              CFDictionaryRef theDict = 0;
              long long __p = (void *)CFArrayGetValueAtIndex(v10, v14);
              sub_10004EFE4(&theDict, (CFTypeRef *)&__p);
              if (theDict) {
                int v15 = sub_100080778;
              }
              else {
                int v15 = 0;
              }
              if (!v15)
              {
                sub_100057D78((const void **)&theDict);
                goto LABEL_46;
              }
              CFNumberRef number = 0;
              long long __p = (void *)CFDictionaryGetValue(theDict, @"technology-mask");
              sub_1000842D0(&number, (CFTypeRef *)&__p);
              if (number ? sub_100081E58 : 0)
              {
                int valuePtr = 0;
                if (CFNumberGetValue(number, kCFNumberIntType, &valuePtr)) {
                  break;
                }
              }
LABEL_36:
              sub_1000570E8((const void **)&number);
              sub_100057D78((const void **)&theDict);
              if (++v14 >= Count) {
                goto LABEL_46;
              }
            }
            long long __p = 0;
            uint64_t v27 = 0;
            uint64_t v28 = 0;
            sub_100C99B64(valuePtr, v12, &__p);
            for (uint64_t i = __p; i != v27; ++i)
            {
              if (*i == a2) {
                goto LABEL_23;
              }
            }
            uint64_t i = v27;
LABEL_23:
            if (v27 == i) {
              goto LABEL_29;
            }
            long long v25 = 0;
            CFTypeRef v24 = CFDictionaryGetValue(theDict, @"configuration");
            sub_10004EFE4(&v25, &v24);
            if (v25 ? sub_100080778 : 0) {
              break;
            }
            int v21 = oslog;
            if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v24) = 0;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I configuration key is not an array ignoring this", (uint8_t *)&v24, 2u);
            }
            sub_100057D78(&v25);
            char v20 = 0;
            char v19 = 1;
LABEL_33:
            if (__p)
            {
              uint64_t v27 = __p;
              operator delete(__p);
            }
            if (v20) {
              goto LABEL_36;
            }
            sub_1000570E8((const void **)&number);
            sub_100057D78((const void **)&theDict);
            if (++v14 < Count) {
              char v22 = v19;
            }
            else {
              char v22 = 0;
            }
            if ((v22 & 1) == 0) {
              goto LABEL_46;
            }
          }
          sub_100058140(a3, &v25);
          sub_100057D78(&v25);
LABEL_29:
          char v19 = 0;
          char v20 = 1;
          goto LABEL_33;
        }
      }
    }
  }
  else
  {
    BOOL v23 = oslog;
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I cellular data plan settings is empty", (uint8_t *)&__p, 2u);
    }
  }
LABEL_46:
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
}

void sub_100916ABC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20,int a21,__int16 a22,char a23,char a24)
{
  sub_100057D78(v24);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a22);
  _Unwind_Resume(a1);
}

const void *sub_100916B20(Registry **a1, int a2)
{
  uint64_t v3 = 0;
  uint64_t v30 = 0;
  if (!a2) {
    goto LABEL_13;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    CFReadStreamRef v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v31 = v6;
  CFArrayRef v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v31);
  if (!v10)
  {
    uint64_t v12 = 0;
    goto LABEL_9;
  }
  uint64_t v12 = v10[3];
  CFTypeID v11 = (std::__shared_weak_count *)v10[4];
  if (!v11)
  {
LABEL_9:
    std::mutex::unlock(v5);
    CFTypeID v11 = 0;
    char v13 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
LABEL_10:
  (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v12 + 40))(&v28, v12, kCellularDataBundleId, @"EsimCellularDataPlanSettings", 0, 0);
  sub_10004EFE4(&v29, &v28);
  uint64_t v14 = (uint64_t)v30;
  uint64_t v30 = v29;
  uint64_t v31 = v14;
  int v29 = 0;
  sub_100057D78((const void **)&v31);
  sub_100057D78(&v29);
  sub_1000577C4(&v28);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  uint64_t v3 = v30;
LABEL_13:
  if (v3) {
    int v15 = sub_100080778;
  }
  else {
    int v15 = 0;
  }
  if (v15) {
    goto LABEL_28;
  }
  uint64_t v16 = (std::mutex *)Registry::getServiceMap(*a1);
  int v17 = v16;
  if (v18 < 0)
  {
    char v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  uint64_t v31 = v18;
  char v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&v31);
  if (!v22)
  {
    uint64_t v24 = 0;
    goto LABEL_24;
  }
  uint64_t v24 = v22[3];
  BOOL v23 = (std::__shared_weak_count *)v22[4];
  if (!v23)
  {
LABEL_24:
    std::mutex::unlock(v17);
    BOOL v23 = 0;
    char v25 = 1;
    goto LABEL_25;
  }
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v17);
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v23);
  char v25 = 0;
LABEL_25:
  (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v24 + 40))(&v28, v24, kCellularDataBundleId, @"CellularDataPlanSettings", 0, 0);
  sub_10004EFE4(&v29, &v28);
  uint64_t v26 = (uint64_t)v30;
  uint64_t v30 = v29;
  uint64_t v31 = v26;
  int v29 = 0;
  sub_100057D78((const void **)&v31);
  sub_100057D78(&v29);
  sub_1000577C4(&v28);
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  uint64_t v3 = v30;
LABEL_28:
  uint64_t v30 = 0;
  sub_100057D78(&v30);
  return v3;
}

void sub_100916DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11)
{
  sub_1000577C4(&a9);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  sub_100057D78(&a11);
  _Unwind_Resume(a1);
}

dispatch_source_t *sub_100916E34(dispatch_source_t *a1, dispatch_queue_t *a2, uint64_t a3, uint64_t a4, void **a5)
{
  *a1 = 0;
  CFArrayRef v10 = *a2;
  a1[1] = *a2;
  if (v10) {
    dispatch_retain(v10);
  }
  CFTypeID v11 = *a5;
  if (*a5) {
    CFTypeID v11 = _Block_copy(v11);
  }
  a1[2] = v11;
  *a1 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 1uLL, 0, *a2);
  os_log_t oslog = 0;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, kCtLoggingSystemName, LogGroupName);
  char v13 = oslog;
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *a1;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)long long buf = 134218496;
    uint64_t v24 = v14;
    __int16 v25 = 2048;
    CFAbsoluteTime v26 = Current;
    __int16 v27 = 2048;
    uint64_t v28 = a3;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Creating timer %p at %f to fire in another %llu milliseconds", buf, 0x20u);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
  uint64_t v16 = *a1;
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 0x40000000;
  uint64_t v21[2] = sub_100917128;
  v21[3] = &unk_101A1A628;
  void v21[4] = a1;
  dispatch_source_set_event_handler(v16, v21);
  int v17 = *a1;
  uint64_t v18 = 1000000 * a3;
  dispatch_time_t v19 = dispatch_time(0, v18);
  dispatch_source_set_timer(v17, v19, v18, 1000000000 * a4);
  dispatch_activate(*a1);
  return a1;
}

void sub_100917010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  uint64_t v8 = *(const void **)(v6 + 16);
  if (v8) {
    _Block_release(v8);
  }
  unsigned int v9 = *(NSObject **)(v6 + 8);
  if (v9) {
    dispatch_release(v9);
  }
  _Unwind_Resume(a1);
}

dispatch_source_t *sub_10091705C(dispatch_source_t *a1, NSObject **a2, uint64_t a3, const void **a4)
{
  CFReadStreamRef v7 = *a2;
  dispatch_queue_t v11 = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  if (*a4) {
    uint64_t v8 = _Block_copy(*a4);
  }
  else {
    uint64_t v8 = 0;
  }
  CFArrayRef v10 = v8;
  sub_100916E34(a1, &v11, a3, 5, &v10);
  if (v8) {
    _Block_release(v8);
  }
  if (v7) {
    dispatch_release(v7);
  }
  return a1;
}

void sub_100917100(_Unwind_Exception *exception_object)
{
  if (v2) {
    _Block_release(v2);
  }
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100917128(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  os_log_t oslog = 0;
  uint64_t v2 = (const char *)kCtLoggingSystemName;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, v2, LogGroupName);
  long long v4 = oslog;
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    dispatch_source_t v5 = *(dispatch_source_t *)v1;
    *(_DWORD *)long long buf = 134217984;
    dispatch_source_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Timer Fired %p", buf, 0xCu);
  }
  dispatch_source_cancel(*(dispatch_source_t *)v1);
  (*(void (**)(void))(*(void *)(v1 + 16) + 16))();
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
}

void sub_100917210(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10091722C(uint64_t a1)
{
  os_log_t oslog = 0;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, kCtLoggingSystemName, LogGroupName);
  uint64_t v3 = oslog;
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)dispatch_source_t v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I ~DataPlanDispatchTimer: Destroying timer", v8, 2u);
  }
  long long v4 = *(NSObject **)a1;
  if (!dispatch_source_testcancel(*(dispatch_source_t *)a1))
  {
    dispatch_source_cancel(v4);
    long long v4 = *(NSObject **)a1;
  }
  dispatch_release(v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
  dispatch_source_t v5 = *(const void **)(a1 + 16);
  if (v5) {
    _Block_release(v5);
  }
  uint64_t v6 = *(NSObject **)(a1 + 8);
  if (v6) {
    dispatch_release(v6);
  }
  return a1;
}

void sub_100917304(PB::Base *this)
{
  *(void *)this = &off_101A1A658;
  uint64_t v2 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  uint64_t v14 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  uint64_t v17 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }

  PB::Base::~Base(this);
}

void sub_100917658(PB::Base *a1)
{
  sub_100917304(a1);

  operator delete();
}

uint64_t sub_100917690(void *a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = a1[1];
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, this, "activateProfile");
  }
  uint64_t v6 = a1[2];
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, this, "deleteProfile");
  }
  uint64_t v7 = a1[3];
  if (v7) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, this, "deviceInfo");
  }
  uint64_t v8 = a1[4];
  if (v8) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "endSession");
  }
  uint64_t v9 = a1[5];
  if (v9) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, this, "fetchProfileNewProfileDetails");
  }
  uint64_t v10 = a1[6];
  if (v10) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v10 + 32))(v10, this, "fetchProfileResult");
  }
  uint64_t v11 = a1[7];
  if (v11) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v11 + 32))(v11, this, "fetchSubscriptionInfo");
  }
  uint64_t v12 = a1[8];
  if (v12) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v12 + 32))(v12, this, "genericTransferPayload");
  }
  uint64_t v13 = a1[9];
  if (v13) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v13 + 32))(v13, this, "pendingProfiles");
  }
  uint64_t v14 = a1[10];
  if (v14) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v14 + 32))(v14, this, "purchasePlan");
  }
  uint64_t v15 = a1[11];
  if (v15) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v15 + 32))(v15, this, "sendUserConsent");
  }
  uint64_t v16 = a1[12];
  if (v16) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v16 + 32))(v16, this, "startSession");
  }
  uint64_t v17 = a1[13];
  if (v17) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v17 + 32))(v17, this, "transferProfile");
  }
  uint64_t v18 = a1[14];
  if (v18) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v18 + 32))(v18, this, "updateProfile");
  }
  uint64_t v19 = a1[15];
  if (v19) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v19 + 32))(v19, this, "updateSubscriptionInfo");
  }
  uint64_t v20 = a1[16];
  if (v20) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v20 + 32))(v20, this, "vinylInfo");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100917A54(int a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_19;
        }
      }
LABEL_22:
      unsigned __int8 v18 = v10 & 7;
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v10 >> 3;
      switch((v10 >> 3))
      {
        case 1u:
          operator new();
        case 2u:
          operator new();
        case 3u:
          operator new();
        case 4u:
          operator new();
        case 5u:
          operator new();
        case 6u:
          operator new();
        case 7u:
          operator new();
        case 8u:
          operator new();
        case 9u:
          operator new();
        case 0xAu:
          operator new();
        case 0xBu:
          operator new();
        case 0xCu:
          operator new();
        case 0xDu:
          operator new();
        case 0xEu:
          operator new();
        case 0xFu:
          operator new();
        case 0x10u:
          operator new();
        default:
          break;
      }
LABEL_20:
      uint64_t result = PB::Reader::skip(this, v19, v18, 0);
      if (!result) {
        return result;
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)this + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_22;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13)
      {
LABEL_19:
        unsigned __int8 v18 = 0;
        LODWORD(v19) = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_1009183EC(uint64_t result, PB::Writer *this)
{
  unint64_t v3 = (void *)result;
  int v4 = *(const PB::Base **)(result + 128);
  if (v4) {
    uint64_t result = PB::Writer::writeSubmessage(this, v4, 1u);
  }
  uint64_t v5 = (const PB::Base *)v3[5];
  if (v5) {
    uint64_t result = PB::Writer::writeSubmessage(this, v5, 2u);
  }
  uint64_t v6 = (const PB::Base *)v3[6];
  if (v6) {
    uint64_t result = PB::Writer::writeSubmessage(this, v6, 3u);
  }
  uint64_t v7 = (const PB::Base *)v3[11];
  if (v7) {
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 4u);
  }
  char v8 = (const PB::Base *)v3[1];
  if (v8) {
    uint64_t result = PB::Writer::writeSubmessage(this, v8, 5u);
  }
  unsigned int v9 = (const PB::Base *)v3[2];
  if (v9) {
    uint64_t result = PB::Writer::writeSubmessage(this, v9, 6u);
  }
  unint64_t v10 = (const PB::Base *)v3[12];
  if (v10) {
    uint64_t result = PB::Writer::writeSubmessage(this, v10, 7u);
  }
  unint64_t v11 = (const PB::Base *)v3[4];
  if (v11) {
    uint64_t result = PB::Writer::writeSubmessage(this, v11, 8u);
  }
  char v12 = (const PB::Base *)v3[14];
  if (v12) {
    uint64_t result = PB::Writer::writeSubmessage(this, v12, 9u);
  }
  BOOL v13 = (const PB::Base *)v3[3];
  if (v13) {
    uint64_t result = PB::Writer::writeSubmessage(this, v13, 0xAu);
  }
  char v14 = (const PB::Base *)v3[13];
  if (v14) {
    uint64_t result = PB::Writer::writeSubmessage(this, v14, 0xBu);
  }
  unsigned int v15 = (const PB::Base *)v3[15];
  if (v15) {
    uint64_t result = PB::Writer::writeSubmessage(this, v15, 0xCu);
  }
  unint64_t v16 = (const PB::Base *)v3[7];
  if (v16) {
    uint64_t result = PB::Writer::writeSubmessage(this, v16, 0xDu);
  }
  char v17 = (const PB::Base *)v3[9];
  if (v17) {
    uint64_t result = PB::Writer::writeSubmessage(this, v17, 0xEu);
  }
  unsigned __int8 v18 = (const PB::Base *)v3[10];
  if (v18) {
    uint64_t result = PB::Writer::writeSubmessage(this, v18, 0xFu);
  }
  unint64_t v19 = (const PB::Base *)v3[8];
  if (v19)
  {
    return PB::Writer::writeSubmessage(this, v19, 0x10u);
  }
  return result;
}

uint64_t sub_100918568(uint64_t result)
{
  if (!*(void *)(result + 40)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918614(uint64_t result)
{
  if (!*(void *)(result + 48)) {
    operator new();
  }
  return result;
}

uint64_t sub_1009186C4(uint64_t result)
{
  if (!*(void *)(result + 88)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918770(uint64_t result)
{
  if (!*(void *)(result + 8)) {
    operator new();
  }
  return result;
}

uint64_t sub_10091881C(uint64_t result)
{
  if (!*(void *)(result + 16)) {
    operator new();
  }
  return result;
}

uint64_t sub_1009188C8(uint64_t result)
{
  if (!*(void *)(result + 96)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918974(uint64_t result)
{
  if (!*(void *)(result + 32)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918A20(uint64_t result)
{
  if (!*(void *)(result + 112)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918ACC(uint64_t result)
{
  if (!*(void *)(result + 24)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918B88(uint64_t result)
{
  if (!*(void *)(result + 104)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918C38(uint64_t result)
{
  if (!*(void *)(result + 120)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918CF0(uint64_t result)
{
  if (!*(void *)(result + 56)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918DA0(uint64_t result)
{
  if (!*(void *)(result + 72)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918E58(uint64_t result)
{
  if (!*(void *)(result + 80)) {
    operator new();
  }
  return result;
}

uint64_t sub_100918F04(uint64_t result)
{
  if (!*(void *)(result + 64)) {
    operator new();
  }
  return result;
}

void *sub_100918FC0(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  unint64_t v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  uint64_t v20 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  char v12 = "DATA.Connection.BootstrapRoamingInternetBypass.X";
  int v13 = *(_DWORD *)(*(void *)a3 + 52);
  if (v13 == 2) {
    char v12 = "DATA.Connection.BootstrapRoamingInternetBypass.2";
  }
  char v14 = "BootstrapRoamingInternetBypass.X";
  if (v13 == 2) {
    char v14 = "BootstrapRoamingInternetBypass.2";
  }
  if (v13 == 1) {
    unsigned int v15 = "DATA.Connection.BootstrapRoamingInternetBypass.1";
  }
  else {
    unsigned int v15 = v12;
  }
  if (v13 == 1) {
    unint64_t v16 = "BootstrapRoamingInternetBypass.1";
  }
  else {
    unint64_t v16 = v14;
  }
  sub_10129653C((uint64_t)a1, (uint64_t *)&off_101A1B108, &v19, a3, a4, &object, v15, (uint64_t)v16, a6);
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *a1 = off_101A1A6D0;
  a1[8] = off_101A1AC20;
  a1[9] = off_101A1AEB0;
  a1[10] = off_101A1B0A0;
  return a1;
}

void sub_10091914C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

void sub_100919178(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_101A1B108);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1009191A8(uint64_t a1)
{
  sub_101296BD8(a1 - 64, (uint64_t *)&off_101A1B108);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1009191DC(uint64_t a1)
{
  sub_101296BD8(a1 - 72, (uint64_t *)&off_101A1B108);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100919210(uint64_t a1)
{
  sub_101296BD8(a1 - 80, (uint64_t *)&off_101A1B108);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100919244(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_101A1B108);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_100919288(uint64_t a1)
{
}

void sub_100919290(uint64_t a1)
{
}

void sub_100919298(uint64_t a1)
{
}

uint64_t sub_1009192A0()
{
  return 0x1010000000101;
}

uint64_t sub_1009192B4()
{
  return 0x1010000000101;
}

uint64_t sub_1009192C8()
{
  return 0;
}

uint64_t sub_1009192D0()
{
  return 0;
}

uint64_t sub_1009192D8(PersonalitySpecificImpl *a1, uint64_t a2)
{
  uint64_t v3 = *((void *)a1 + 27);
  uint64_t v4 = PersonalitySpecificImpl::simSlot(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 272))(v3, v4);
  if (v5)
  {
    *(_DWORD *)a2 = 0;
    *(void *)(a2 + 8) = "";
    *(void *)(a2 + 16) = "";
    *(_DWORD *)(a2 + 24) = 0;
    *(unsigned char *)(a2 + 28) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    uint64_t v6 = *(std::__shared_weak_count **)(a2 + 48);
    *(void *)(a2 + 48) = 0;
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
  return v5;
}

uint64_t sub_10091936C(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  return 1;
}

uint64_t sub_100919378(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  return 1;
}

uint64_t sub_100919384(uint64_t a1, uint64_t a2)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 216) + 80))(&v4);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v4;
  *(void *)(a2 + 16) = v5;
  return 1;
}

uint64_t sub_100919400(uint64_t a1, uint64_t a2)
{
  return 1;
}

void sub_100919420(uint64_t *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_100058DB0(__p, "911");
  unint64_t v2 = a1[2];
  unint64_t v3 = a1[1];
  if (v3 >= v2)
  {
    unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v3 - *a1) >> 3);
    unint64_t v6 = v5 + 1;
    if (v5 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D8578();
    }
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v2 - *a1) >> 3);
    if (2 * v7 > v6) {
      unint64_t v6 = 2 * v7;
    }
    if (v7 >= 0x555555555555555) {
      unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v8 = v6;
    }
    unsigned int v56 = a1 + 2;
    if (v8) {
      unsigned int v9 = (char *)sub_10004812C((uint64_t)(a1 + 2), v8);
    }
    else {
      unsigned int v9 = 0;
    }
    unint64_t v10 = &v9[24 * v5];
    uint64_t v52 = v9;
    uint64_t v53 = v10;
    uint64_t v55 = &v9[24 * v8];
    long long v11 = *(_OWORD *)__p;
    *((void *)v10 + 2) = v51;
    *(_OWORD *)unint64_t v10 = v11;
    __p[1] = 0;
    uint64_t v51 = 0;
    __p[0] = 0;
    unint64_t v54 = v10 + 24;
    sub_100048204(a1, &v52);
    uint64_t v12 = a1[1];
    sub_100048174((uint64_t)&v52);
    int v13 = SHIBYTE(v51);
    a1[1] = v12;
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v4 = *(_OWORD *)__p;
    *(void *)(v3 + 16) = v51;
    *(_OWORD *)unint64_t v3 = v4;
    a1[1] = v3 + 24;
  }
  sub_100058DB0(__p, "112");
  unint64_t v15 = a1[1];
  unint64_t v14 = a1[2];
  if (v15 >= v14)
  {
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - *a1) >> 3);
    unint64_t v18 = v17 + 1;
    if (v17 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D8578();
    }
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - *a1) >> 3);
    if (2 * v19 > v18) {
      unint64_t v18 = 2 * v19;
    }
    if (v19 >= 0x555555555555555) {
      unint64_t v20 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v20 = v18;
    }
    unsigned int v56 = a1 + 2;
    if (v20) {
      unsigned int v21 = (char *)sub_10004812C((uint64_t)(a1 + 2), v20);
    }
    else {
      unsigned int v21 = 0;
    }
    char v22 = &v21[24 * v17];
    uint64_t v52 = v21;
    uint64_t v53 = v22;
    uint64_t v55 = &v21[24 * v20];
    long long v23 = *(_OWORD *)__p;
    *((void *)v22 + 2) = v51;
    *(_OWORD *)char v22 = v23;
    __p[1] = 0;
    uint64_t v51 = 0;
    __p[0] = 0;
    unint64_t v54 = v22 + 24;
    sub_100048204(a1, &v52);
    uint64_t v24 = a1[1];
    sub_100048174((uint64_t)&v52);
    int v25 = SHIBYTE(v51);
    a1[1] = v24;
    if (v25 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v16 = *(_OWORD *)__p;
    *(void *)(v15 + 16) = v51;
    *(_OWORD *)unint64_t v15 = v16;
    a1[1] = v15 + 24;
  }
  sub_100058DB0(__p, "*911");
  unint64_t v27 = a1[1];
  unint64_t v26 = a1[2];
  if (v27 >= v26)
  {
    unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - *a1) >> 3);
    unint64_t v30 = v29 + 1;
    if (v29 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D8578();
    }
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - *a1) >> 3);
    if (2 * v31 > v30) {
      unint64_t v30 = 2 * v31;
    }
    if (v31 >= 0x555555555555555) {
      unint64_t v32 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v32 = v30;
    }
    unsigned int v56 = a1 + 2;
    if (v32) {
      uint64_t v33 = (char *)sub_10004812C((uint64_t)(a1 + 2), v32);
    }
    else {
      uint64_t v33 = 0;
    }
    uint64_t v34 = &v33[24 * v29];
    uint64_t v52 = v33;
    uint64_t v53 = v34;
    uint64_t v55 = &v33[24 * v32];
    long long v35 = *(_OWORD *)__p;
    *((void *)v34 + 2) = v51;
    *(_OWORD *)uint64_t v34 = v35;
    __p[1] = 0;
    uint64_t v51 = 0;
    __p[0] = 0;
    unint64_t v54 = v34 + 24;
    sub_100048204(a1, &v52);
    uint64_t v36 = a1[1];
    sub_100048174((uint64_t)&v52);
    int v37 = SHIBYTE(v51);
    a1[1] = v36;
    if (v37 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v28 = *(_OWORD *)__p;
    *(void *)(v27 + 16) = v51;
    *(_OWORD *)unint64_t v27 = v28;
    a1[1] = v27 + 24;
  }
  sub_100058DB0(__p, "#911");
  unint64_t v39 = a1[1];
  unint64_t v38 = a1[2];
  if (v39 >= v38)
  {
    unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39 - *a1) >> 3);
    unint64_t v42 = v41 + 1;
    if (v41 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D8578();
    }
    unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v38 - *a1) >> 3);
    if (2 * v43 > v42) {
      unint64_t v42 = 2 * v43;
    }
    if (v43 >= 0x555555555555555) {
      unint64_t v44 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v44 = v42;
    }
    unsigned int v56 = a1 + 2;
    if (v44) {
      uint64_t v45 = (char *)sub_10004812C((uint64_t)(a1 + 2), v44);
    }
    else {
      uint64_t v45 = 0;
    }
    uint64_t v46 = &v45[24 * v41];
    uint64_t v52 = v45;
    uint64_t v53 = v46;
    uint64_t v55 = &v45[24 * v44];
    long long v47 = *(_OWORD *)__p;
    *((void *)v46 + 2) = v51;
    *(_OWORD *)uint64_t v46 = v47;
    __p[1] = 0;
    uint64_t v51 = 0;
    __p[0] = 0;
    unint64_t v54 = v46 + 24;
    sub_100048204(a1, &v52);
    uint64_t v48 = a1[1];
    sub_100048174((uint64_t)&v52);
    int v49 = SHIBYTE(v51);
    a1[1] = v48;
    if (v49 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v40 = *(_OWORD *)__p;
    *(void *)(v39 + 16) = v51;
    *(_OWORD *)unint64_t v39 = v40;
    a1[1] = v39 + 24;
  }
}

void sub_100919878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100047F64((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_1009198DC(uint64_t a1, void *a2, dispatch_object_t *a3, long long **a4, const char *a5, char *a6, void *a7, uint64_t a8)
{
  unint64_t v15 = (void *)(a1 + 8);
  long long v16 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v46, kCtLoggingSystemName, a6);
  if (v16)
  {
    dispatch_retain(v16);
    unint64_t v17 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    dispatch_retain(v16);
    dispatch_retain(v16);
    unint64_t v18 = dispatch_queue_create_with_target_V2(a5, v17, v16);
  }
  else
  {
    unint64_t v19 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    unint64_t v18 = dispatch_queue_create(a5, v19);
  }
  unint64_t v20 = v18;
  void *v15 = 0;
  v15[1] = 0;
  *(void *)(a1 + 24) = v18;
  if (v18) {
    dispatch_retain(v18);
  }
  *(void *)(a1 + 32) = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  if (v20) {
    dispatch_release(v20);
  }
  if (v16)
  {
    dispatch_release(v16);
    dispatch_release(v16);
    dispatch_release(v16);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v39, &v46);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v39);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v39);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v46);
  if (v16) {
    dispatch_release(v16);
  }
  unsigned int v21 = (capabilities::ct *)sub_10091EB50((uint64_t)v45, a8);
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v21) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v45);
  *(void *)a1 = off_101A1BE98;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  sub_1000302C0((char *)(a1 + 56), *a4, a4[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a4[1] - (char *)*a4) >> 3));
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 80) = a1 + 88;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  char v22 = (void *)(a1 + 128);
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = a5;
  *(void *)(a1 + 160) = *a2;
  uint64_t v23 = a2[1];
  *(void *)(a1 + 168) = v23;
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 176) = *a7;
  uint64_t v24 = a7[1];
  *(void *)(a1 + 184) = v24;
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 16), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, *(char **)(a1 + 152));
  int v25 = *(NSObject **)(a1 + 24);
  dispatch_object_t v42 = v25;
  if (v25) {
    dispatch_retain(v25);
  }
  dispatch_object_t object = 0;
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v42) {
    dispatch_release(v42);
  }
  if (v44 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 232) = a1 + 240;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 224) = 13;
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = 1;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = a1 + 304;
  sub_100058DB0(v39, "822");
  unint64_t v26 = *(void *)(a1 + 144);
  unint64_t v27 = *(void *)(a1 + 136);
  if (v27 >= v26)
  {
    unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - *v22) >> 3);
    unint64_t v30 = v29 + 1;
    if (v29 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D8578();
    }
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - *v22) >> 3);
    if (2 * v31 > v30) {
      unint64_t v30 = 2 * v31;
    }
    if (v31 >= 0x555555555555555) {
      unint64_t v32 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v32 = v30;
    }
    uint64_t v49 = a1 + 144;
    if (v32) {
      uint64_t v33 = (char *)sub_10004812C(a1 + 144, v32);
    }
    else {
      uint64_t v33 = 0;
    }
    uint64_t v34 = (os_log_s *)&v33[24 * v29];
    v46.var0 = v33;
    v46.var1.fRef = v34;
    uint64_t v48 = &v33[24 * v32];
    long long v35 = *(_OWORD *)v39;
    *((void *)v34 + 2) = v40;
    *(_OWORD *)uint64_t v34 = v35;
    v39[1] = 0;
    uint64_t v40 = 0;
    v39[0] = 0;
    long long v47 = (void *)((char *)v34 + 24);
    sub_100048204((uint64_t *)(a1 + 128), &v46);
    uint64_t v36 = *(void *)(a1 + 136);
    sub_100048174((uint64_t)&v46);
    int v37 = SHIBYTE(v40);
    *(void *)(a1 + 136) = v36;
    if (v37 < 0) {
      operator delete(v39[0]);
    }
  }
  else
  {
    long long v28 = *(_OWORD *)v39;
    *(void *)(v27 + 16) = v40;
    *(_OWORD *)unint64_t v27 = v28;
    *(void *)(a1 + 136) = v27 + 24;
  }
  return a1;
}

void sub_100919E0C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, dispatch_object_t object, dispatch_object_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
}

void sub_100919FB4(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  if (v4) {
    dispatch_release(v4);
  }
  JUMPOUT(0x100919FA4);
}

void *sub_100919FF0(uint64_t a1)
{
  sub_100703718(a1 + 32, *(char **)(a1 + 40));

  return sub_10091E864((void *)a1);
}

void sub_10091A030(uint64_t a1)
{
  *(void *)a1 = off_101A1BE98;
  unint64_t v2 = (void *)(a1 + 264);
  sub_100703718(a1 + 296, *(char **)(a1 + 304));
  sub_10091E864(v2);
  sub_1007035FC(a1 + 232, *(void **)(a1 + 240));
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 216);
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 200);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 184);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  unint64_t v6 = *(std::__shared_weak_count **)(a1 + 168);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v8 = (void **)(a1 + 128);
  sub_100047F64(&v8);
  sub_10091EC6C(a1 + 104, *(void **)(a1 + 112));
  sub_10091EC0C(a1 + 80, *(char **)(a1 + 88));
  uint64_t v8 = (void **)(a1 + 56);
  sub_100047F64(&v8);
  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  EmergencyNumbersInterface::~EmergencyNumbersInterface((EmergencyNumbersInterface *)a1);
}

void sub_10091A154(uint64_t a1, dispatch_object_t *a2)
{
  unint64_t v2 = (void *)(a1 + 8);
  unint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void sub_10091A24C(unint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 160));
  unint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  v15[0] = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, v15);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
LABEL_9:
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 216);
  *(void *)(a1 + 208) = v10;
  *(void *)(a1 + 216) = v9;
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_100058DB0(__p, "/cc/props/vowifi_provisioning_state");
  v15[0] = (unint64_t)off_101A1C0A8;
  v15[1] = a1 + 232;
  v15[2] = a1;
  uint64_t v16 = v15;
  ctu::RestModule::observeProperty();
  sub_10003F600(v15);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v12 = (unint64_t *)operator new(0x20uLL);
  *uint64_t v12 = (unint64_t)off_101A1C128;
  v12[1] = a1;
  void v12[2] = (unint64_t)sub_10091A480;
  v12[3] = 0;
  uint64_t v16 = v12;
  ctu::RestModule::observeEvent();
  sub_10003F600(v15);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  sub_10091A9DC(a1 + 256);
}

void sub_10091A434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10091A480(uint64_t a1)
{
  uint64_t v1 = a1;
  unint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Emergency Numbers (prioritized order): [Number, Category, SupportsSMS]", (uint8_t *)&buf, 2u);
  }
  subscriber::makeSimSlotRange();
  unint64_t v3 = v31;
  unint64_t v26 = v32;
  if (v31 != v32)
  {
    int v25 = v33;
    while ((v33(*v3) & 1) == 0)
    {
      if (++v3 == v32)
      {
        unint64_t v3 = v32;
        break;
      }
    }
    uint64_t v24 = v32;
    while (v3 != v24)
    {
      uint64_t v4 = *v3;
      unint64_t v27 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v4);
      for (unsigned int i = 0; i != 13; ++i)
      {
        long long __p = 0;
        unint64_t v29 = 0;
        uint64_t v30 = 0;
        sub_10091C610(v1, v4, i, &__p);
        uint64_t v6 = (CSIPhoneNumber *)__p;
        unsigned int v7 = v29;
        uint64_t v8 = *v27;
        BOOL v9 = os_log_type_enabled(*v27, OS_LOG_TYPE_DEFAULT);
        if (v6 == v7)
        {
          if (v9)
          {
            uint64_t v16 = asString();
            buf.var0 = 136315138;
            *(void *)&buf.var1 = v16;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: no numbers", (uint8_t *)&buf, 0xCu);
          }
        }
        else if (v9)
        {
          uint64_t v10 = v1;
          uint64_t v11 = asString();
          uint64_t v12 = (CSIPhoneNumber *)__p;
          uint64_t v13 = v29;
          memset(&v40, 0, sizeof(v40));
          if (__p != v29)
          {
            sub_100921164((std::string *)&buf, (CSIPhoneNumber *)__p);
            *(_OWORD *)&v40.__r_.__value_.__l.__data_ = *(_OWORD *)&buf.var0;
            v40.__r_.__value_.__r.__words[2] = buf.var2.__r_.__value_.var0.var1.__size_;
            while (1)
            {
              uint64_t v12 = (CSIPhoneNumber *)((char *)v12 + 136);
              if (v12 == v13) {
                break;
              }
              buf.var2.__r_.__value_.var0.var0.__data_[15] = 1;
              strcpy((char *)&buf, ",");
              std::string::append(&v40, (const std::string::value_type *)&buf, 1uLL);
              if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                operator delete(*(void **)&buf.var0);
              }
              sub_100921164((std::string *)&buf, v12);
              if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
                p_CSIPhoneNumber buf = (const std::string::value_type *)&buf;
              }
              else {
                p_CSIPhoneNumber buf = *(const std::string::value_type **)&buf.var0;
              }
              if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
                std::string::size_type data = buf.var2.__r_.__value_.var0.var0.__data_[15];
              }
              else {
                std::string::size_type data = (std::string::size_type)buf.var2.__r_.__value_.var0.var1.__data_;
              }
              std::string::append(&v40, p_buf, data);
              if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                operator delete(*(void **)&buf.var0);
              }
            }
          }
          uint64_t v17 = &v40;
          if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint64_t v17 = (std::string *)v40.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)unint64_t v41 = 136315394;
          uint64_t v42 = v11;
          __int16 v43 = 2080;
          char v44 = v17;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: %s", v41, 0x16u);
          uint64_t v1 = v10;
          if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v40.__r_.__value_.__l.__data_);
          }
        }
        *(void *)&buf.var0 = &__p;
        sub_100702C2C((void ***)&buf);
      }
      unint64_t v18 = *v27;
      if (os_log_type_enabled(*v27, OS_LOG_TYPE_DEFAULT))
      {
        sub_10091C800(&buf, v1, v4);
        CSIPhoneNumber::getFullNumber((uint64_t *)&__p, &buf);
        p_p = &__p;
        if (v30 < 0) {
          p_p = __p;
        }
        LODWORD(v40.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v40.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I fPreferredEmergencyNumber: %s", (uint8_t *)&v40, 0xCu);
        if (SHIBYTE(v30) < 0) {
          operator delete(__p);
        }
        if (v39 < 0) {
          operator delete(v38);
        }
        if (v37 < 0) {
          operator delete(v36);
        }
        if (v35 < 0) {
          operator delete(*(void **)&buf.var2.__r_.var0);
        }
        if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
          operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
        }
        unint64_t v18 = *v27;
      }
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = asString();
        buf.var0 = 136315138;
        *(void *)&buf.var1 = v20;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I fLastMatchedEmergencyNumListType: %s", (uint8_t *)&buf, 0xCu);
        unint64_t v18 = *v27;
      }
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        int v21 = sub_10091DE4C((void *)v1);
        char v22 = "false";
        if (v21) {
          char v22 = "true";
        }
        buf.var0 = 136315138;
        *(void *)&buf.var1 = v22;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Is current model: %s", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v23 = v3 + 1;
      unint64_t v3 = v26;
      if (v23 != v26)
      {
        unint64_t v3 = v23;
        while ((v25(*v3) & 1) == 0)
        {
          if (++v3 == v26)
          {
            unint64_t v3 = v26;
            break;
          }
        }
      }
    }
  }
}

void sub_10091A96C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
}

void sub_10091A9DC(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/subscription_info");
  v4[0] = off_101A1C1A8;
  v4[1] = a1;
  uint64_t v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10091AA90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10091AABC(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_10091AB98(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v26, *(Registry **)(a1 + 160));
  ctu::RestModule::connect();
  if (v27) {
    sub_10004D2C8(v27);
  }
  subscriber::makeSimSlotRange();
  char v3 = v23;
  unint64_t v2 = v24;
  if (v23 != v24)
  {
    uint64_t v4 = v25;
    while ((v25(*v3) & 1) == 0)
    {
      if (++v3 == v24)
      {
        char v3 = v24;
        break;
      }
    }
    uint64_t v5 = v24;
    while (v3 != v5)
    {
      uint64_t v6 = *v3;
      sub_10091AE64(a1, 8u, (long long **)(a1 + 56), v6);
      if (sub_10091B18C(a1, v7))
      {
        uint64_t v20 = 0;
        int v21 = 0;
        unint64_t v22 = 0;
        sub_100058DB0(__p, "822");
        uint64_t v8 = v21;
        if ((unint64_t)v21 >= v22)
        {
          unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v21 - v20) >> 3);
          unint64_t v11 = v10 + 1;
          if (v10 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_1000D8578();
          }
          if (0x5555555555555556 * ((uint64_t)(v22 - (void)v20) >> 3) > v11) {
            unint64_t v11 = 0x5555555555555556 * ((uint64_t)(v22 - (void)v20) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - (void)v20) >> 3) >= 0x555555555555555) {
            unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v12 = v11;
          }
          v28[4] = (void **)&v22;
          if (v12) {
            uint64_t v13 = (void **)sub_10004812C((uint64_t)&v22, v12);
          }
          else {
            uint64_t v13 = 0;
          }
          char v14 = &v13[3 * v10];
          v28[0] = v13;
          v28[1] = v14;
          void v28[3] = &v13[3 * v12];
          long long v15 = *(_OWORD *)__p;
          v14[2] = v19;
          *(_OWORD *)char v14 = v15;
          __p[1] = 0;
          unint64_t v19 = 0;
          __p[0] = 0;
          v28[2] = v14 + 3;
          sub_100048204((uint64_t *)&v20, v28);
          uint64_t v16 = v21;
          sub_100048174((uint64_t)v28);
          int v21 = v16;
          if (SHIBYTE(v19) < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          long long v9 = *(_OWORD *)__p;
          *((void *)v21 + 2) = v19;
          *uint64_t v8 = v9;
          int v21 = (char *)v8 + 24;
        }
        sub_10091AE64(a1, 0xAu, (long long **)&v20, v6);
        v28[0] = (void **)&v20;
        sub_100047F64(v28);
      }
      uint64_t v17 = v3 + 1;
      char v3 = v2;
      if (v17 != v2)
      {
        char v3 = v17;
        while ((v4(*v3) & 1) == 0)
        {
          if (++v3 == v2)
          {
            char v3 = v2;
            break;
          }
        }
      }
    }
  }
  sub_10091B394((void *)a1);
}

void sub_10091AE04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,char a23)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_10091AE64(uint64_t a1, unsigned int a2, long long **a3, uint64_t a4)
{
  uint64_t v21 = 0;
  unint64_t v22 = &v21;
  uint64_t v23 = 0x4002000000;
  uint64_t v24 = sub_10091CB68;
  int v25 = sub_10091CB84;
  v26[0] = 0;
  v26[1] = 0;
  uint64_t v27 = 0;
  sub_100058DB0(v26, "");
  uint64_t v8 = *a3;
  long long v9 = a3[1];
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  unint64_t v18 = sub_10091CB98;
  unint64_t v19 = &unk_101A1BF50;
  uint64_t v20 = &v21;
  while (v8 != v9)
  {
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)v8, *((void *)v8 + 1));
    }
    else
    {
      long long v10 = *v8;
      *(void *)&__p[16] = *((void *)v8 + 2);
      *(_OWORD *)long long __p = v10;
    }
    v18((uint64_t)v17, (const void **)__p);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v8 = (long long *)((char *)v8 + 24);
  }
  unint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a4);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v12 = v22 + 5;
    if (*((char *)v22 + 63) < 0) {
      unint64_t v12 = (void *)*v12;
    }
    uint64_t v13 = asString();
    *(_DWORD *)long long __p = 136315394;
    *(void *)&__p[4] = v12;
    *(_WORD *)&__p[12] = 2080;
    *(void *)&__p[14] = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Adding emergency numbers '%s' from %s", __p, 0x16u);
  }
  sub_10091CC90(a1, a4, a2);
  if (a2 == 11)
  {
    unsigned int v14 = 1;
    goto LABEL_17;
  }
  if (a2 == 1)
  {
    unsigned int v14 = 11;
LABEL_17:
    sub_10091CC90(a1, a4, v14);
  }
  uint64_t v16 = *a3;
  long long v15 = a3[1];
  *(void *)long long __p = _NSConcreteStackBlock;
  *(void *)&__p[8] = 0x40000000;
  *(void *)&__p[16] = sub_10091CD74;
  unint64_t v29 = &unk_101A1BF70;
  uint64_t v30 = a1;
  unsigned int v31 = a2;
  int v32 = a4;
  while (v16 != v15)
  {
    (*(void (**)(unsigned char *, long long *))&__p[16])(__p, v16);
    uint64_t v16 = (long long *)((char *)v16 + 24);
  }
  _Block_object_dispose(&v21, 8);
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[0]);
  }
}

void sub_10091B138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10091B18C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 160));
  uint64_t v4 = ServiceMap;
  unint64_t v6 = v5;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v6;
  long long v10 = sub_10004D37C(&v4[1].__m_.__sig, &v27);
  if (v10)
  {
    uint64_t v12 = v10[3];
    unint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v4);
  unint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  int v15 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  uint64_t v16 = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(a1 + 160));
  uint64_t v17 = v16;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unint64_t v18 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      unint64_t v5 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(v16);
  unint64_t v27 = v5;
  uint64_t v21 = sub_10004D37C(&v17[1].__m_.__sig, &v27);
  if (v21)
  {
    uint64_t v23 = v21[3];
    unint64_t v22 = (std::__shared_weak_count *)v21[4];
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      char v24 = 0;
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  std::mutex::unlock(v17);
  unint64_t v22 = 0;
  char v24 = 1;
LABEL_19:
  unsigned int v25 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 24))(v23);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  return v15 | v25;
}

void sub_10091B368(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10091B394(void *a1)
{
  char v2 = (std::__shared_weak_count *)a1[23];
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = a1[22];
      if (v5)
      {
        if (sub_10091DE4C(a1))
        {
          uint64_t v6 = a1[19];
          sub_10091DF14((uint64_t)a1, (uint64_t)v7);
          (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v5 + 16))(v5, v6, v7);
          sub_1007036B8((uint64_t)v7, v8);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10091B450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
  sub_1007036B8((uint64_t)&a10, a11);
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_10091B47C(uint64_t a1, dispatch_object_t *a2)
{
  char v2 = (void *)(a1 + 8);
  char v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

uint64_t sub_10091B574(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 192));
}

void sub_10091B57C(uint64_t a1@<X0>, unsigned __int8 a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  unsigned __int8 v10 = a2;
  int v9 = a3;
  v8[0] = a1;
  v8[1] = &v10;
  void v8[2] = &v9;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      sub_10091B750(a4, a1, v10);
      return;
    }
    BOOL v6 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v6 = 1;
  }
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  void v11[2] = sub_10091F758;
  void v11[3] = &unk_101A1C218;
  v11[4] = a1 + 8;
  void v11[5] = v8;
  uint64_t v12 = v11;
  unsigned int v7 = *(NSObject **)(a1 + 24);
  *(void *)(a4 + 128) = 0;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  if (v6)
  {
    CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)a4);
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    int v15 = sub_10091F774;
    uint64_t v16 = &unk_101A1C238;
    uint64_t v17 = a4;
    unint64_t v18 = &v12;
    dispatch_sync(v7, &block);
  }
  else
  {
    CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)a4);
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    int v15 = sub_10091F908;
    uint64_t v16 = &unk_101A1C258;
    uint64_t v17 = a4;
    unint64_t v18 = &v12;
    dispatch_async_and_wait(v7, &block);
  }
}

void sub_10091B750(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = (void *)a1;
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)a1);
  subscriber::makeSimSlotRange();
  std::string::size_type size = (unsigned int *)v85.__r_.__value_.__r.__words[0];
  BOOL v6 = v4;
  uint64_t v69 = a2;
  if (v85.__r_.__value_.__r.__words[0] == v85.__r_.__value_.__l.__size_) {
    goto LABEL_121;
  }
  while ((((uint64_t (*)(void))v85.__r_.__value_.__r.__words[2])(*size) & 1) == 0)
  {
    if (++size == (unsigned int *)v85.__r_.__value_.__l.__size_)
    {
      std::string::size_type size = (unsigned int *)v85.__r_.__value_.__l.__size_;
      break;
    }
  }
  std::string::size_type v60 = v85.__r_.__value_.__l.__size_;
  if (size == (unsigned int *)v85.__r_.__value_.__l.__size_)
  {
LABEL_121:
    int v42 = 0;
    int v71 = 0;
    int v66 = 0;
    int v77 = 13;
    goto LABEL_123;
  }
  long long v62 = (uint64_t (*)(void))v85.__r_.__value_.__r.__words[2];
  std::string::size_type v63 = v85.__r_.__value_.__l.__size_;
  int v66 = 0;
  int v71 = 0;
  uint64_t v76 = (std::string *)(v4 + 1);
  int64_t v75 = (std::string *)(v4 + 4);
  unsigned int v7 = size;
  uint64_t v73 = (std::string *)(v4 + 8);
  uint64_t v74 = v4 + 7;
  uint64_t v72 = (std::string *)(v4 + 11);
  uint64_t v8 = v4 + 14;
  int v77 = 13;
LABEL_7:
  uint64_t v61 = v7;
  unsigned int v65 = *v7;
  uint64_t v70 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48));
  int v9 = *v70;
  if (os_log_type_enabled(*v70, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = subscriber::asString();
    buf.var0 = 136446210;
    *(void *)&buf.var1 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Trying to find best matched local emergency number for %{public}s", (uint8_t *)&buf, 0xCu);
  }
  unsigned int v11 = 0;
  a2 = v69;
  while (1)
  {
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    uint64_t v84 = 0;
    unsigned int v78 = v11;
    sub_10091C610(a2, v65, v11, &v82);
    uint64_t v12 = (char *)v82;
    uint64_t v68 = v83;
    if (v82 != v83) {
      break;
    }
    *(void *)&buf.var0 = &v82;
    sub_100702C2C((void ***)&buf);
LABEL_112:
    unsigned int v11 = v78 + 1;
    if (v78 == 12)
    {
      unsigned int v7 = (unsigned int *)v63;
      if (v61 + 1 != (unsigned int *)v63)
      {
        std::string v40 = v61 + 1;
        while (1)
        {
          unint64_t v41 = v40;
          if (v62(*v40)) {
            break;
          }
          std::string v40 = v41 + 1;
          if (v41 + 1 == (unsigned int *)v63)
          {
            unsigned int v7 = (unsigned int *)v63;
            goto LABEL_119;
          }
        }
        unsigned int v7 = v41;
      }
LABEL_119:
      int v42 = 0;
      if (v7 == (unsigned int *)v60) {
        goto LABEL_123;
      }
      goto LABEL_7;
    }
  }
  char v64 = 0;
  do
  {
    uint64_t v99 = 0;
    long long v97 = 0u;
    long long v98 = 0u;
    long long v95 = 0u;
    long long v96 = 0u;
    long long v94 = 0u;
    memset(&buf, 0, sizeof(buf));
    sub_10009DB3C((uint64_t)&buf, (uint64_t)v12);
    if (a3)
    {
      uint64_t v14 = *(long long **)(v69 + 128);
      char v13 = *(long long **)(v69 + 136);
      while (1)
      {
        if (v14 == v13)
        {
          uint64_t v4 = v6;
          goto LABEL_90;
        }
        memset(&__s1, 0, 24);
        if (*((char *)v14 + 23) < 0)
        {
          sub_10004FC84(&__s1, *(void **)v14, *((void *)v14 + 1));
        }
        else
        {
          long long v15 = *v14;
          __s1.var2.__r_.__value_.var0.var1.__size_ = *((void *)v14 + 2);
          *(_OWORD *)&__s1.var0 = v15;
        }
        CSIPhoneNumber::getFullNumber((uint64_t *)&__p, &buf);
        if (v81 >= 0) {
          size_t v16 = HIBYTE(v81);
        }
        else {
          size_t v16 = __n;
        }
        std::string::size_type data = (char *)__s1.var2.__r_.__value_.var0.var0.__data_[15];
        if (__s1.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
          std::string::size_type data = __s1.var2.__r_.__value_.var0.var1.__data_;
        }
        if ((char *)v16 == data)
        {
          if (__s1.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
            p_s1 = &__s1;
          }
          else {
            p_s1 = *(CSIPhoneNumber **)&__s1.var0;
          }
          if (v81 < 0)
          {
            uint64_t v23 = __p;
            int v24 = memcmp(__p, p_s1, __n);
            operator delete(v23);
            if (v24) {
              goto LABEL_43;
            }
          }
          else if (HIBYTE(v81))
          {
            uint64_t v19 = 0;
            do
            {
              int v20 = *((unsigned __int8 *)&__p + v19);
              int v21 = *((unsigned __int8 *)&p_s1->var0 + v19);
            }
            while (v20 == v21 && HIBYTE(v81) - 1 != v19++);
            if (v20 != v21) {
              goto LABEL_43;
            }
          }
          unsigned int v25 = *v70;
          if (os_log_type_enabled(*v70, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p) = 0;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Testing so found default test number", (uint8_t *)&__p, 2u);
          }
          void *v6 = *(void *)&buf.var0;
          std::string::operator=(v76, (const std::string *)&buf.var2);
          std::string::operator=(v75, (const std::string *)&buf.var2.__r_.var0);
          *(_DWORD *)uint64_t v74 = DWORD2(v94);
          *((unsigned char *)v74 + 4) = BYTE12(v94);
          std::string::operator=(v73, (const std::string *)&v95);
          std::string::operator=(v72, (const std::string *)((char *)&v96 + 8));
          *(_OWORD *)uint64_t v8 = v98;
          *((unsigned char *)v8 + 16) = v99;
          int v71 = 1;
          int v77 = v78;
        }
        else if (v81 < 0)
        {
          operator delete(__p);
        }
LABEL_43:
        if (__s1.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
          operator delete(*(void **)&__s1.var0);
        }
        uint64_t v14 = (long long *)((char *)v14 + 24);
      }
    }
    long long __p = 0;
    size_t __n = 0;
    uint64_t v81 = 0;
    sub_10091C800(&__s1, v69, v65);
    CSIPhoneNumber::getFullNumber((uint64_t *)&__p, &__s1);
    if (SHIBYTE(v90) < 0) {
      operator delete(*((void **)&v89 + 1));
    }
    if (SBYTE7(v89) < 0) {
      operator delete(v88[0]);
    }
    if (SBYTE7(v87) < 0) {
      operator delete(*(void **)&__s1.var2.__r_.var0);
    }
    if (*((char *)&__s1.var2.__r_.__value_.var0.var1 + 23) < 0) {
      operator delete(__s1.var2.__r_.__value_.var0.var1.__data_);
    }
    CSIPhoneNumber::getFullNumber((uint64_t *)&__s1.var0, &buf);
    if (__s1.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
      uint64_t v26 = (char *)__s1.var2.__r_.__value_.var0.var0.__data_[15];
    }
    else {
      uint64_t v26 = __s1.var2.__r_.__value_.var0.var1.__data_;
    }
    size_t v27 = HIBYTE(v81);
    if (v81 < 0) {
      size_t v27 = __n;
    }
    if (v26 == (char *)v27)
    {
      if (v81 >= 0) {
        p_p = (unsigned __int8 *)&__p;
      }
      else {
        p_p = (unsigned __int8 *)__p;
      }
      if (__s1.var2.__r_.__value_.var0.var0.__data_[15] < 0)
      {
        uint64_t v33 = *(void **)&__s1.var0;
        int v34 = memcmp(*(const void **)&__s1.var0, p_p, (size_t)__s1.var2.__r_.__value_.var0.var1.__data_);
        operator delete(v33);
        if (!v34) {
          goto LABEL_81;
        }
      }
      else
      {
        if (!__s1.var2.__r_.__value_.var0.var0.__data_[15]) {
          goto LABEL_81;
        }
        uint64_t v29 = 0;
        do
        {
          int v30 = *((unsigned __int8 *)&__s1.var0 + v29);
          int v31 = p_p[v29];
        }
        while (v30 == v31 && __s1.var2.__r_.__value_.var0.var0.__data_[15] - 1 != v29++);
        if (v30 == v31)
        {
LABEL_81:
          char v37 = *v70;
          uint64_t v4 = v6;
          if (os_log_type_enabled(*v70, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v38 = asString();
            if (v81 >= 0) {
              char v39 = (char *)&__p;
            }
            else {
              char v39 = (char *)__p;
            }
            __s1.var0 = 136315394;
            *(void *)&__s1.var1 = v38;
            WORD2(__s1.var2.__r_.__value_.var0.var1.__data_) = 2080;
            *(char **)((char *)&__s1.var2.__r_.__value_.var0.var1.__data_ + 6) = v39;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Found a match to the preferred emergency number in %s! Using it! [%s]", (uint8_t *)&__s1, 0x16u);
          }
          void *v6 = *(void *)&buf.var0;
          std::string::operator=(v76, (const std::string *)&buf.var2);
          std::string::operator=(v75, (const std::string *)&buf.var2.__r_.var0);
          *(_DWORD *)uint64_t v74 = DWORD2(v94);
          *((unsigned char *)v74 + 4) = BYTE12(v94);
          std::string::operator=(v73, (const std::string *)&v95);
          std::string::operator=(v72, (const std::string *)((char *)&v96 + 8));
          int v36 = 11;
          char v35 = 1;
          char v64 = 1;
          goto LABEL_87;
        }
      }
    }
    else if (__s1.var2.__r_.__value_.var0.var0.__data_[15] < 0)
    {
      operator delete(*(void **)&__s1.var0);
    }
    if (v66)
    {
      char v35 = 0;
      int v36 = 0;
      int v66 = 1;
      uint64_t v4 = v6;
      goto LABEL_88;
    }
    uint64_t v4 = v6;
    if (CSIPhoneNumber::getEmergencyCategory(&buf) == 255)
    {
      void *v6 = *(void *)&buf.var0;
      std::string::operator=(v76, (const std::string *)&buf.var2);
      std::string::operator=(v75, (const std::string *)&buf.var2.__r_.var0);
      *(_DWORD *)uint64_t v74 = DWORD2(v94);
      *((unsigned char *)v74 + 4) = BYTE12(v94);
      std::string::operator=(v73, (const std::string *)&v95);
      std::string::operator=(v72, (const std::string *)((char *)&v96 + 8));
      char v35 = 0;
      int v36 = 0;
      int v66 = 1;
LABEL_87:
      *(_OWORD *)uint64_t v8 = v98;
      *((unsigned char *)v8 + 16) = v99;
      int v77 = v78;
      goto LABEL_88;
    }
    if (v71)
    {
      char v35 = 0;
      int v36 = 0;
      int v66 = 0;
      int v71 = 1;
    }
    else
    {
      if (!CSIPhoneNumber::getEmergencyCategory(&buf))
      {
        void *v6 = *(void *)&buf.var0;
        std::string::operator=(v76, (const std::string *)&buf.var2);
        std::string::operator=(v75, (const std::string *)&buf.var2.__r_.var0);
        *(_DWORD *)uint64_t v74 = DWORD2(v94);
        *((unsigned char *)v74 + 4) = BYTE12(v94);
        std::string::operator=(v73, (const std::string *)&v95);
        std::string::operator=(v72, (const std::string *)((char *)&v96 + 8));
        char v35 = 0;
        int v36 = 0;
        int v66 = 0;
        int v71 = 1;
        goto LABEL_87;
      }
      char v35 = 0;
      int v36 = 0;
      int v71 = 0;
      int v66 = 0;
    }
LABEL_88:
    if ((SHIBYTE(v81) & 0x80000000) == 0)
    {
      if (v35) {
        goto LABEL_91;
      }
LABEL_90:
      int v36 = 0;
      goto LABEL_91;
    }
    operator delete(__p);
    if ((v35 & 1) == 0) {
      goto LABEL_90;
    }
LABEL_91:
    if (SHIBYTE(v97) < 0) {
      operator delete(*((void **)&v96 + 1));
    }
    if (SBYTE7(v96) < 0) {
      operator delete((void *)v95);
    }
    if (SBYTE7(v94) < 0) {
      operator delete(*(void **)&buf.var2.__r_.var0);
    }
    if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
      operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
    }
    if (v36) {
      break;
    }
    v12 += 136;
  }
  while (v12 != v68);
  *(void *)&buf.var0 = &v82;
  sub_100702C2C((void ***)&buf);
  if ((v64 & 1) == 0)
  {
    a2 = v69;
    goto LABEL_112;
  }
  int v42 = 1;
  a2 = v69;
LABEL_123:
  uint64_t v43 = *(unsigned int *)(a2 + 256);
  uint64_t v99 = 0;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v94 = 0u;
  memset(&buf, 0, sizeof(buf));
  sub_10091C800(&buf, a2, v43);
  char v44 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    if (v42) {
      uint64_t v45 = "true";
    }
    else {
      uint64_t v45 = "false";
    }
    int EmergencyCategory = CSIPhoneNumber::getEmergencyCategory(&buf);
    int hasEmergencyCategorySet = CSIPhoneNumber::hasEmergencyCategorySet(&buf);
    __s1.var0 = 136315650;
    *(void *)&__s1.var1 = v45;
    WORD2(__s1.var2.__r_.__value_.var0.var1.__data_) = 1024;
    *(_DWORD *)((char *)&__s1.var2.__r_.__value_.var0.var1.__data_ + 6) = EmergencyCategory;
    WORD1(__s1.var2.__r_.__value_.var0.var1.__size_) = 1024;
    HIDWORD(__s1.var2.__r_.__value_.var0.var1.__size_) = hasEmergencyCategorySet;
    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Did we find preferred number in the list: %s. Category of the preferred number: %d. %d", (uint8_t *)&__s1, 0x18u);
  }
  if (v42)
  {
    int v48 = 1;
    goto LABEL_139;
  }
  if (CSIPhoneNumber::hasEmergencyCategorySet(&buf))
  {
    *uint64_t v4 = *(void *)&buf.var0;
    std::string::operator=((std::string *)(v4 + 1), (const std::string *)&buf.var2);
    std::string::operator=((std::string *)(v4 + 4), (const std::string *)&buf.var2.__r_.var0);
    *((_DWORD *)v4 + 14) = DWORD2(v94);
    *((unsigned char *)v4 + 60) = BYTE12(v94);
    std::string::operator=((std::string *)(v4 + 8), (const std::string *)&v95);
    std::string::operator=((std::string *)(v4 + 11), (const std::string *)((char *)&v96 + 8));
    *((_OWORD *)v4 + 7) = v98;
    *((unsigned char *)v4 + 128) = v99;
    int v48 = 1;
    unsigned int v49 = 8;
  }
  else if ((v66 | v71))
  {
LABEL_138:
    int v48 = 0;
LABEL_139:
    unsigned int v49 = v77;
  }
  else
  {
    long long v50 = *(NSObject **)(v69 + 40);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__s1.var0) = 0;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Did not match ALL or NONE category!", (uint8_t *)&__s1, 2u);
    }
    unsigned int v49 = 0;
    while (1)
    {
      memset(&v85, 0, sizeof(v85));
      sub_10091C610(v69, v43, v49, &v85);
      if (v85.__r_.__value_.__r.__words[0] != v85.__r_.__value_.__l.__size_) {
        break;
      }
      *(void *)&__s1.var0 = &v85;
      sub_100702C2C((void ***)&__s1);
      if (++v49 == 13) {
        goto LABEL_138;
      }
    }
    uint64_t v92 = 0;
    long long v90 = 0u;
    long long v91 = 0u;
    *(_OWORD *)uint64_t v88 = 0u;
    long long v89 = 0u;
    long long v87 = 0u;
    memset(&__s1, 0, sizeof(__s1));
    sub_10009DB3C((uint64_t)&__s1, (uint64_t)v85.__r_.__value_.__l.__data_);
    *uint64_t v4 = *(void *)&__s1.var0;
    std::string::operator=((std::string *)(v4 + 1), (const std::string *)&__s1.var2);
    std::string::operator=((std::string *)(v4 + 4), (const std::string *)&__s1.var2.__r_.var0);
    *((_DWORD *)v4 + 14) = DWORD2(v87);
    *((unsigned char *)v4 + 60) = BYTE12(v87);
    std::string::operator=((std::string *)(v4 + 8), (const std::string *)v88);
    std::string::operator=((std::string *)(v4 + 11), (const std::string *)((char *)&v89 + 8));
    *((_OWORD *)v4 + 7) = v91;
    *((unsigned char *)v4 + 128) = v92;
    if (SHIBYTE(v90) < 0) {
      operator delete(*((void **)&v89 + 1));
    }
    if (SBYTE7(v89) < 0) {
      operator delete(v88[0]);
    }
    if (SBYTE7(v87) < 0) {
      operator delete(*(void **)&__s1.var2.__r_.var0);
    }
    if (*((char *)&__s1.var2.__r_.__value_.var0.var1 + 23) < 0) {
      operator delete(__s1.var2.__r_.__value_.var0.var1.__data_);
    }
    *(void *)&__s1.var0 = &v85;
    sub_100702C2C((void ***)&__s1);
    int v48 = 0;
  }
  memset(&v85, 0, sizeof(v85));
  sub_100058DB0(&v85, "Unknown");
  if (!v48)
  {
    if (v66)
    {
      if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
      {
        v85.__r_.__value_.__l.__size_ = 12;
        uint64_t v52 = (std::string *)v85.__r_.__value_.__r.__words[0];
      }
      else
      {
        *((unsigned char *)&v85.__r_.__value_.__s + 23) = 12;
        uint64_t v52 = &v85;
      }
      LODWORD(v52->__r_.__value_.__r.__words[1]) = 1280065824;
      v52->__r_.__value_.__r.__words[0] = *(void *)"Category ALL";
      unint64_t v54 = &v52->__r_.__value_.__s.__data_[12];
    }
    else
    {
      if ((v71 & 1) == 0) {
        goto LABEL_165;
      }
      if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
      {
        v85.__r_.__value_.__l.__size_ = 13;
        uint64_t v53 = (std::string *)v85.__r_.__value_.__r.__words[0];
      }
      else
      {
        *((unsigned char *)&v85.__r_.__value_.__s + 23) = 13;
        uint64_t v53 = &v85;
      }
      qmemcpy(v53, "Category NONE", 13);
      unint64_t v54 = &v53->__r_.__value_.__s.__data_[13];
    }
    std::string::value_type *v54 = 0;
    goto LABEL_165;
  }
  if (CSIPhoneNumber::getTypeOfNumber((CSIPhoneNumber *)v4) == 1) {
    uint64_t v51 = "Whitelist";
  }
  else {
    uint64_t v51 = "Emergency";
  }
  sub_10003ED78(&v85, v51);
LABEL_165:
  *(_DWORD *)(v69 + 224) = v49;
  toCallMetricEmNumListType();
  CSIPhoneNumber::setMatchedEmMetricListType();
  uint64_t v55 = *(NSObject **)(v69 + 40);
  if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
  {
    CSIPhoneNumber::getFullNumber((uint64_t *)&v82, (CSIPhoneNumber *)v4);
    unsigned int v56 = v84 >= 0 ? &v82 : (void **)v82;
    uint64_t v57 = (v85.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v85
        : (std::string *)v85.__r_.__value_.__r.__words[0];
    int v58 = CSIPhoneNumber::getEmergencyCategory((CSIPhoneNumber *)v4);
    uint64_t v59 = asString();
    __s1.var0 = 136315906;
    *(void *)&__s1.var1 = v56;
    WORD2(__s1.var2.__r_.__value_.var0.var1.__data_) = 2080;
    *(char **)((char *)&__s1.var2.__r_.__value_.var0.var1.__data_ + 6) = (char *)v57;
    HIWORD(__s1.var2.__r_.__value_.var0.var1.__size_) = 1024;
    *((_DWORD *)&__s1.var2.__r_.__value_.var0.var1 + 4) = v58;
    *((_WORD *)&__s1.var2.__r_.__value_.var0.var1 + 10) = 2080;
    *(void *)((char *)&__s1.var2.__r_.__value_.var0.var1 + 22) = v59;
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Matched emergency number %s (%s) with category %d in emergency list %s", (uint8_t *)&__s1, 0x26u);
    if (SHIBYTE(v84) < 0) {
      operator delete(v82);
    }
  }
  if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v85.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v97) < 0) {
    operator delete(*((void **)&v96 + 1));
  }
  if (SBYTE7(v96) < 0) {
    operator delete((void *)v95);
  }
  if (SBYTE7(v94) < 0) {
    operator delete(*(void **)&buf.var2.__r_.var0);
  }
  if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
  }
}

void sub_10091C47C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *__p,uint64_t a49,int a50,__int16 a51,char a52,char a53,void **p_p,uint64_t a55,int a56,__int16 a57,char a58,char a59)
{
  p_p = &__p;
  sub_100702C2C(&p_p);
  sub_100087E24(v60 - 240);
  if (*(char *)(v59 + 111) < 0) {
    operator delete(*(void **)(v59 + 88));
  }
  if (*(char *)(v59 + 87) < 0) {
    operator delete(*(void **)(v59 + 64));
  }
  if (*(char *)(v59 + 55) < 0) {
    operator delete(*(void **)(v59 + 32));
  }
  if (*(char *)(v59 + 31) < 0) {
    operator delete(*(void **)(v59 + 8));
  }
  _Unwind_Resume(a1);
}

void sub_10091C610(uint64_t a1@<X0>, int a2@<W1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  uint64_t v7 = a1 + 88;
  uint64_t v6 = *(void *)(a1 + 88);
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v8 = a1 + 88;
  do
  {
    int v9 = *(_DWORD *)(v6 + 32);
    BOOL v10 = v9 < a2;
    if (v9 >= a2) {
      unsigned int v11 = (uint64_t *)v6;
    }
    else {
      unsigned int v11 = (uint64_t *)(v6 + 8);
    }
    if (!v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 == v7 || *(_DWORD *)(v8 + 32) > a2) {
LABEL_11:
  }
    uint64_t v8 = a1 + 88;
  uint64_t v12 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (v8 == v7)
  {
    os_log_t v18 = *v12;
    if (!os_log_type_enabled(*v12, OS_LOG_TYPE_ERROR))
    {
LABEL_20:
      *a4 = 0;
      a4[1] = 0;
      a4[2] = 0;
      return;
    }
    LOWORD(v23[0]) = 0;
    uint64_t v19 = "Em num list not found for this slot!";
    int v20 = v18;
    uint32_t v21 = 2;
LABEL_22:
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v19, (uint8_t *)v23, v21);
    goto LABEL_20;
  }
  uint64_t v13 = *(void *)(v8 + 40);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v8 + 48) - v13) >> 3) <= a3)
  {
    os_log_t v22 = *v12;
    if (!os_log_type_enabled(*v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    v23[0] = 67109120;
    v23[1] = a3;
    uint64_t v19 = "index : %u greater than the max length!!";
    int v20 = v22;
    uint32_t v21 = 8;
    goto LABEL_22;
  }
  uint64_t v14 = (uint64_t *)(v13 + 24 * a3);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  uint64_t v15 = *v14;
  uint64_t v16 = v14[1];
  unint64_t v17 = 0xF0F0F0F0F0F0F0F1 * ((v16 - *v14) >> 3);

  sub_10091E9F0(a4, v15, v16, v17);
}

void sub_10091C800(CSIPhoneNumber *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 112);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = a2 + 112;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < (int)a3;
    if (v6 >= (int)a3) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != a2 + 112 && *(_DWORD *)(v5 + 32) <= (int)a3)
  {
    sub_10009DB3C((uint64_t)a1, v5 + 40);
  }
  else
  {
LABEL_11:
    int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)BOOL v10 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "preferred numbers not found!", v10, 2u);
    }
    CSIPhoneNumber::CSIPhoneNumber(a1, "");
  }
}

uint64_t sub_10091C90C(uint64_t a1, unsigned int *a2, int a3, char a4)
{
  int v10 = a3;
  char v9 = a4;
  v8[0] = (unsigned int *)a1;
  v8[1] = (unsigned int *)&v10;
  void v8[2] = (unsigned int *)&v9;
  void v8[3] = a2;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_10091FA9C(v8);
    }
    BOOL v6 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v6 = 1;
  }
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  void v11[2] = sub_100920A58;
  void v11[3] = &unk_101A1C278;
  v11[4] = a1 + 8;
  void v11[5] = v8;
  uint64_t v12 = v11;
  BOOL v7 = *(NSObject **)(a1 + 24);
  char v18 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v6)
  {
    uint64_t v14 = sub_10005A2C8;
    uint64_t v15 = &unk_101A1C298;
    uint64_t v16 = &v18;
    unint64_t v17 = &v12;
    dispatch_sync(v7, block);
  }
  else
  {
    uint64_t v14 = sub_10005B02C;
    uint64_t v15 = &unk_101A1C2B8;
    uint64_t v16 = &v18;
    unint64_t v17 = &v12;
    dispatch_async_and_wait(v7, block);
  }
  return v18 != 0;
}

void sub_10091CA94(uint64_t a1, uint64_t a2, int a3)
{
  int v7 = a3;
  v6[0] = a2;
  v6[1] = a1;
  void v6[2] = (uint64_t)&v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      sub_100920A60(v6);
      return;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_100920FCC;
  block[3] = &unk_101A1C2F8;
  void block[4] = a1 + 8;
  void block[5] = v6;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  if (v4) {
    dispatch_sync(v5, block);
  }
  else {
    dispatch_async_and_wait(v5, block);
  }
}

__n128 sub_10091CB68(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10091CB84(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

void sub_10091CB98(uint64_t a1, const void **a2)
{
  if (*((char *)a2 + 23) >= 0) {
    size_t v4 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v4 = (size_t)a2[1];
  }
  std::string::size_type v10 = 0;
  uint64_t v11 = 0;
  long long __p = 0;
  sub_1000C140C((uint64_t)&__p, v4 + 1);
  if (v11 >= 0) {
    p_p = (char *)&__p;
  }
  else {
    p_p = (char *)__p;
  }
  if (v4)
  {
    if (*((char *)a2 + 23) >= 0) {
      BOOL v6 = a2;
    }
    else {
      BOOL v6 = *a2;
    }
    memmove(p_p, v6, v4);
  }
  *(_WORD *)&p_p[v4] = 59;
  if (v11 >= 0) {
    int v7 = (const std::string::value_type *)&__p;
  }
  else {
    int v7 = (const std::string::value_type *)__p;
  }
  if (v11 >= 0) {
    std::string::size_type v8 = HIBYTE(v11);
  }
  else {
    std::string::size_type v8 = v10;
  }
  std::string::append((std::string *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v7, v8);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p);
  }
}

void sub_10091CC74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10091CC90(uint64_t a1, int a2, unsigned int a3)
{
  int v20 = a2;
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t v3 = a1 + 88;
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v7 = v3 - 8;
    uint64_t v8 = v3;
    do
    {
      int v9 = *(_DWORD *)(v4 + 32);
      BOOL v10 = v9 < a2;
      if (v9 >= a2) {
        uint64_t v11 = (uint64_t *)v4;
      }
      else {
        uint64_t v11 = (uint64_t *)(v4 + 8);
      }
      if (!v10) {
        uint64_t v8 = v4;
      }
      uint64_t v4 = *v11;
    }
    while (*v11);
    if (v8 != v3 && *(_DWORD *)(v8 + 32) <= a2)
    {
      uint64_t v12 = sub_10091E6C8(v3 - 8, &v20);
      if (0xAAAAAAAAAAAAAAABLL * ((v12[1] - *v12) >> 3) > a3)
      {
        uint64_t v13 = sub_10091E6C8(v7, &v20);
        uint64_t v14 = 24 * a3;
        uint64_t v15 = *v13 + v14;
        uint64_t v18 = *(void *)(v15 + 8);
        unint64_t v17 = (void *)(v15 + 8);
        uint64_t v16 = v18;
        uint64_t v19 = *(void *)(*v13 + v14);
        while (v16 != v19)
        {
          v16 -= 136;
          sub_100702B04(v16);
        }
        void *v17 = v19;
      }
    }
  }
}

void sub_10091CD74(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned int v2 = *(_DWORD *)(a1 + 40);
  uint64_t v3 = *(unsigned int *)(a1 + 44);
  uint64_t v44 = 0;
  unint64_t v45 = 0;
  unint64_t v46 = 0;
  sub_10091C610(v1, v3, v2, &v44);
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  ctu::tokenize();
  memset(&__str, 0, sizeof(__str));
  uint64_t v4 = 0;
  if (MEMORY[0x17] < 0)
  {
    sub_10004FC84(&__str, MEMORY[0], MEMORY[8]);
    uint64_t v4 = v41;
  }
  else
  {
    std::string __str = MEMORY[0];
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v39 = 0;
  if (0xAAAAAAAAAAAAAAABLL * ((v42 - v4) >> 3) < 2)
  {
    sub_100058DB0(__dst, "");
  }
  else if (*(char *)(v4 + 47) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v4 + 24), *(void *)(v4 + 32));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)(v4 + 24);
    uint64_t v39 = *(void *)(v4 + 40);
  }
  v36[0] = 0;
  v36[1] = 0;
  uint64_t v37 = 0;
  if (0xAAAAAAAAAAAAAAABLL * ((v42 - v41) >> 3) < 3)
  {
    sub_100058DB0(v36, "0");
  }
  else if (*(char *)(v41 + 71) < 0)
  {
    sub_10004FC84(v36, *(void **)(v41 + 48), *(void *)(v41 + 56));
  }
  else
  {
    *(_OWORD *)int v36 = *(_OWORD *)(v41 + 48);
    uint64_t v37 = *(void *)(v41 + 64);
  }
  v34[0] = 0;
  v34[1] = 0;
  uint64_t v35 = 0;
  if (0xAAAAAAAAAAAAAAABLL * ((v42 - v41) >> 3) < 4)
  {
    sub_100058DB0(v34, "1");
  }
  else if (*(char *)(v41 + 95) < 0)
  {
    sub_10004FC84(v34, *(void **)(v41 + 72), *(void *)(v41 + 80));
  }
  else
  {
    *(_OWORD *)int v34 = *(_OWORD *)(v41 + 72);
    uint64_t v35 = *(void *)(v41 + 88);
  }
  v32[0] = 0;
  v32[1] = 0;
  uint64_t v33 = 0;
  if (0xAAAAAAAAAAAAAAABLL * ((v42 - v41) >> 3) < 5)
  {
    sub_100058DB0(v32, "0");
  }
  else if (*(char *)(v41 + 119) < 0)
  {
    sub_10004FC84(v32, *(void **)(v41 + 96), *(void *)(v41 + 104));
  }
  else
  {
    *(_OWORD *)int v32 = *(_OWORD *)(v41 + 96);
    uint64_t v33 = *(void *)(v41 + 112);
  }
  if (size >= 2)
  {
    p_str = &__str;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if (p_str->__r_.__value_.__s.__data_[0] == 34 && p_str->__r_.__value_.__s.__data_[size - 1] == 34)
    {
      memset(&__p, 0, 24);
      std::string::basic_string((std::string *)&__p, &__str, 1uLL, size - 2, (std::allocator<char> *)buf);
      std::string::operator=(&__str, (const std::string *)&__p);
      if (__p.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        operator delete(*(void **)&__p.var0);
      }
    }
  }
  if (v39 >= 0) {
    uint64_t v7 = __dst;
  }
  else {
    uint64_t v7 = (void **)__dst[0];
  }
  unsigned int v8 = atoi((const char *)v7);
  if (v37 >= 0) {
    int v9 = v36;
  }
  else {
    int v9 = (void **)v36[0];
  }
  int v10 = atoi((const char *)v9);
  if (v35 >= 0) {
    uint64_t v11 = v34;
  }
  else {
    uint64_t v11 = (void **)v34[0];
  }
  int v12 = atoi((const char *)v11);
  if (v33 >= 0) {
    uint64_t v13 = v32;
  }
  else {
    uint64_t v13 = (void **)v32[0];
  }
  int v14 = atoi((const char *)v13);
  uint64_t v31 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  *(_OWORD *)size_t v27 = 0u;
  *(_OWORD *)long long v28 = 0u;
  long long v26 = 0u;
  memset(&__p, 0, sizeof(__p));
  CSIPhoneNumber::CSIPhoneNumber();
  CSIPhoneNumber::setEmergencyCategory(&__p, v8);
  CSIPhoneNumber::setIsEmSMSTextSupported(&__p, v10 != 0);
  CSIPhoneNumber::setIsEmVoiceSupported(&__p, v12 != 0);
  CSIPhoneNumber::setIsListedAsEmergency(&__p, (v2 < 0xD) & (0x1802u >> v2));
  unint64_t v15 = v45;
  if (v45 >= v46)
  {
    uint64_t v16 = sub_10091E8E8(&v44, (uint64_t)&__p);
  }
  else
  {
    sub_10009DB3C(v45, (uint64_t)&__p);
    uint64_t v16 = v15 + 136;
  }
  unint64_t v45 = v16;
  unint64_t v17 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    int EmergencyCategory = CSIPhoneNumber::getEmergencyCategory(&__p);
    if (CSIPhoneNumber::getIsEmSMSTextSupported(&__p)) {
      uint64_t v19 = "true";
    }
    else {
      uint64_t v19 = "false";
    }
    int IsEmVoiceSupported = CSIPhoneNumber::getIsEmVoiceSupported(&__p);
    int IsListedAsEmergency = CSIPhoneNumber::getIsListedAsEmergency(&__p);
    *(_DWORD *)CSIPhoneNumber buf = 67110146;
    if (IsEmVoiceSupported) {
      os_log_t v22 = "true";
    }
    else {
      os_log_t v22 = "false";
    }
    *(_DWORD *)&uint8_t buf[4] = EmergencyCategory;
    if (IsListedAsEmergency) {
      uint64_t v23 = "true";
    }
    else {
      uint64_t v23 = "false";
    }
    *(_WORD *)unsigned int v49 = 2080;
    if (v14) {
      int v24 = "true";
    }
    else {
      int v24 = "false";
    }
    *(void *)&v49[2] = v19;
    *(_WORD *)&v49[10] = 2080;
    *(void *)&v49[12] = v22;
    __int16 v50 = 2080;
    uint64_t v51 = v23;
    __int16 v52 = 2080;
    uint64_t v53 = v24;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I categoryNumber: %d, smsTextSupported: %s emergencyVoiceSupported: %s, isListedAsEmergency: %s isTestNum: %s.", buf, 0x30u);
    uint64_t v16 = v45;
  }
  *(void *)CSIPhoneNumber buf = 0;
  *(void *)unsigned int v49 = 0;
  *(void *)&v49[8] = 0;
  sub_10091E9F0(buf, v44, v16, 0xF0F0F0F0F0F0F0F1 * ((v16 - v44) >> 3));
  sub_10091D4B8(v1, v3, v2, (uint64_t *)buf);
  long long v47 = buf;
  sub_100702C2C((void ***)&v47);
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[1]);
  }
  if (SHIBYTE(v28[0]) < 0) {
    operator delete(v27[0]);
  }
  if (SBYTE7(v26) < 0) {
    operator delete(*(void **)&__p.var2.__r_.var0);
  }
  if (*((char *)&__p.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(__p.var2.__r_.__value_.var0.var1.__data_);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(v32[0]);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(v34[0]);
  }
  if (SHIBYTE(v37) < 0) {
    operator delete(v36[0]);
  }
  if (SHIBYTE(v39) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  *(void *)&__p.var0 = &v41;
  sub_100047F64((void ***)&__p);
  *(void *)&__p.var0 = &v44;
  sub_100702C2C((void ***)&__p);
}

void sub_10091D380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a49 < 0) {
    operator delete(a44);
  }
  if (a56 < 0) {
    operator delete(a51);
  }
  if (*(char *)(v56 - 217) < 0) {
    operator delete(*(void **)(v56 - 240));
  }
  CSIPhoneNumber __p = (void *)(v56 - 216);
  sub_100047F64((void ***)&__p);
  CSIPhoneNumber __p = (void *)(v56 - 192);
  sub_100702C2C((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_10091D4B8(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  int v6 = a2;
  int v35 = a2;
  int v9 = (void *)(a1 + 88);
  uint64_t v8 = *(void *)(a1 + 88);
  int v10 = (void **)(a1 + 80);
  if (!v8) {
    goto LABEL_11;
  }
  uint64_t v11 = a1 + 88;
  do
  {
    int v12 = *(_DWORD *)(v8 + 32);
    BOOL v13 = v12 < (int)a2;
    if (v12 >= (int)a2) {
      int v14 = (uint64_t *)v8;
    }
    else {
      int v14 = (uint64_t *)(v8 + 8);
    }
    if (!v13) {
      uint64_t v11 = v8;
    }
    uint64_t v8 = *v14;
  }
  while (*v14);
  if ((void *)v11 != v9 && *(_DWORD *)(v11 + 32) <= (int)a2)
  {
    uint64_t v28 = *sub_10091E6C8(a1 + 80, &v35) + 24 * a3;
    if ((uint64_t *)v28 != a4) {
      sub_100702898(v28, *a4, a4[1], 0xF0F0F0F0F0F0F0F1 * ((a4[1] - *a4) >> 3));
    }
  }
  else
  {
LABEL_11:
    unint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CSIPhoneNumber buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a3;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I adding a new emergency list at index %u", buf, 8u);
    }
    int v32 = 0;
    uint64_t v33 = 0;
    int v34 = 0;
    *(void *)CSIPhoneNumber buf = &v32;
    uint64_t v16 = (char *)operator new(0x138uLL);
    unint64_t v17 = v16 + 312;
    int v34 = v16 + 312;
    *(_OWORD *)uint64_t v16 = 0u;
    *((_OWORD *)v16 + 1) = 0u;
    *((_OWORD *)v16 + 2) = 0u;
    *((_OWORD *)v16 + 3) = 0u;
    *((_OWORD *)v16 + 4) = 0u;
    *((_OWORD *)v16 + 5) = 0u;
    *((_OWORD *)v16 + 6) = 0u;
    *((_OWORD *)v16 + 7) = 0u;
    *((_OWORD *)v16 + 8) = 0u;
    *((_OWORD *)v16 + 9) = 0u;
    *((_OWORD *)v16 + 10) = 0u;
    *((_OWORD *)v16 + 11) = 0u;
    *((_OWORD *)v16 + 12) = 0u;
    *((_OWORD *)v16 + 13) = 0u;
    *((_OWORD *)v16 + 14) = 0u;
    *((_OWORD *)v16 + 15) = 0u;
    *((_OWORD *)v16 + 16) = 0u;
    *((_OWORD *)v16 + 17) = 0u;
    *((_OWORD *)v16 + 18) = 0u;
    *((void *)v16 + 38) = 0;
    uint64_t v18 = (uint64_t)&v16[24 * a3];
    int v32 = v16;
    uint64_t v33 = v16 + 312;
    if ((uint64_t *)v18 != a4)
    {
      sub_100702898(v18, *a4, a4[1], 0xF0F0F0F0F0F0F0F1 * ((a4[1] - *a4) >> 3));
      uint64_t v16 = v32;
      unint64_t v17 = v33;
    }
    long long v30 = 0;
    uint64_t v31 = 0;
    long long v29 = 0;
    int v36 = (void **)&v29;
    int64_t v19 = v17 - v16;
    if (v17 == v16)
    {
      uint32_t v21 = 0;
    }
    else
    {
      unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * (v19 >> 3);
      uint64_t v37 = 0;
      if (v20 >= 0xAAAAAAAAAAAAAABLL) {
        sub_10006A748();
      }
      long long v29 = operator new(v19);
      long long v30 = v29;
      uint64_t v31 = (char *)&v29[3 * v20];
      uint64_t v38 = v29;
      uint64_t v39 = v29;
      *(void *)CSIPhoneNumber buf = &v31;
      uint64_t v41 = &v38;
      uint64_t v42 = &v39;
      uint64_t v43 = 0;
      uint32_t v21 = v29;
      do
      {
        *uint32_t v21 = 0;
        v21[1] = 0;
        uint64_t v21[2] = 0;
        sub_10091E9F0(v21, *(void *)v16, *((void *)v16 + 1), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)v16 + 1) - *(void *)v16) >> 3));
        uint32_t v21 = v39 + 3;
        v39 += 3;
        v16 += 24;
      }
      while (v16 != v17);
      LOBYTE(v43) = 1;
      sub_10091EAEC((uint64_t)buf);
      long long v30 = v21;
    }
    uint64_t v22 = *v9;
    uint64_t v23 = v9;
    if (*v9)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v23 = (void *)v22;
          int v24 = *(_DWORD *)(v22 + 32);
          if (v24 <= v6) {
            break;
          }
          uint64_t v22 = *v23;
          int v9 = v23;
          if (!*v23) {
            goto LABEL_28;
          }
        }
        if (v24 >= v6) {
          break;
        }
        uint64_t v22 = v23[1];
        if (!v22)
        {
          int v9 = v23 + 1;
          goto LABEL_28;
        }
      }
    }
    else
    {
LABEL_28:
      unsigned int v25 = operator new(0x40uLL);
      v25[8] = v6;
      long long v26 = v31;
      *((void *)v25 + 5) = v29;
      *((void *)v25 + 6) = v21;
      *((void *)v25 + 7) = v26;
      long long v30 = 0;
      uint64_t v31 = 0;
      long long v29 = 0;
      *(void *)unsigned int v25 = 0;
      *((void *)v25 + 1) = 0;
      *((void *)v25 + 2) = v23;
      void *v9 = v25;
      size_t v27 = (void *)**v10;
      if (v27)
      {
        void *v10 = v27;
        unsigned int v25 = (_DWORD *)*v9;
      }
      sub_100046C90(*(uint64_t **)(a1 + 88), (uint64_t *)v25);
      ++*(void *)(a1 + 96);
    }
    *(void *)CSIPhoneNumber buf = &v29;
    sub_10091EA78((void ***)buf);
    *(void *)CSIPhoneNumber buf = &v32;
    sub_10091EA78((void ***)buf);
  }
}

void sub_10091D858(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
}

void sub_10091D8BC(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v9 = a1;
  int v10 = a2;
  if (!*(void *)(a1 + 32))
  {
    BOOL v7 = 1;
    goto LABEL_8;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v7 = *(void *)(a1 + 32) == 0;
LABEL_8:
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    void v11[2] = sub_100920FD4;
    void v11[3] = &unk_101A1C318;
    v11[4] = a1 + 8;
    void v11[5] = &v9;
    int v12 = v11;
    uint64_t v8 = *(NSObject **)(a1 + 24);
    *(void *)(a3 + 128) = 0;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    if (v7)
    {
      CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)a3);
      block = _NSConcreteStackBlock;
      uint64_t v14 = 0x40000000;
      unint64_t v15 = sub_10091F774;
      uint64_t v16 = &unk_101A1C238;
      uint64_t v17 = a3;
      uint64_t v18 = &v12;
      dispatch_sync(v8, &block);
    }
    else
    {
      CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)a3);
      block = _NSConcreteStackBlock;
      uint64_t v14 = 0x40000000;
      unint64_t v15 = sub_10091F908;
      uint64_t v16 = &unk_101A1C258;
      uint64_t v17 = a3;
      uint64_t v18 = &v12;
      dispatch_async_and_wait(v8, &block);
    }
    return;
  }
  int isValidSimSlot = subscriber::isValidSimSlot();
  int v6 = (unsigned int *)&v10;
  if (!isValidSimSlot) {
    int v6 = (unsigned int *)(a1 + 256);
  }
  sub_10091C800((CSIPhoneNumber *)a3, a1, *v6);
}

void sub_10091DAAC(uint64_t a1, uint64_t a2)
{
  memset(&v15, 0, sizeof(v15));
  if (!sub_10091B18C(a1, __stack_chk_guard)) {
    return;
  }
  uint64_t v14 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 208) + 96))(&v14);
  sub_100058DB0(v13, "822");
  ctu::cf::assign();
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = *(_OWORD *)v13;
  *(std::string::size_type *)((char *)&v15.__r_.__value_.__r.__words[1] + 7) = *(void *)&v13[15];
  char v4 = v13[23];
  memset(v13, 0, sizeof(v13));
  *((unsigned char *)&v15.__r_.__value_.__s + 23) = v4;
  uint64_t v5 = sub_100365D74();
  sub_100058DB0(&__p, "TestEmergencyNumber");
  BOOL v6 = sub_100226284(v5, (void **)&__p, &v15);
  BOOL v7 = v6;
  if ((SHIBYTE(v18) & 0x80000000) == 0)
  {
    if (!v6) {
      goto LABEL_10;
    }
LABEL_6:
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = &v15;
      if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v9 = (std::string *)v15.__r_.__value_.__r.__words[0];
      }
      LODWORD(__p) = 136446210;
      *(void *)((char *)&__p + 4) = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Adding %{public}s as emergency test number from persistent properties", (uint8_t *)&__p, 0xCu);
    }
    goto LABEL_10;
  }
  operator delete((void *)__p);
  if (v7) {
    goto LABEL_6;
  }
LABEL_10:
  unint64_t v10 = *(void *)(a1 + 136);
  if (v10 >= *(void *)(a1 + 144))
  {
    uint64_t v12 = sub_100048008((uint64_t *)(a1 + 128), (long long *)&v15);
  }
  else
  {
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(*(unsigned char **)(a1 + 136), v15.__r_.__value_.__l.__data_, v15.__r_.__value_.__l.__size_);
    }
    else
    {
      long long v11 = *(_OWORD *)&v15.__r_.__value_.__l.__data_;
      *(void *)(v10 + 16) = *((void *)&v15.__r_.__value_.__l + 2);
      *(_OWORD *)unint64_t v10 = v11;
    }
    uint64_t v12 = v10 + 24;
    *(void *)(a1 + 136) = v10 + 24;
  }
  *(void *)(a1 + 136) = v12;
  long long __p = 0uLL;
  uint64_t v18 = 0;
  *((void *)&__p + 1) = sub_100048008((uint64_t *)&__p, (long long *)&v15);
  sub_10091AE64(a1, 0xAu, (long long **)&__p, a2);
  p_p = (void **)&__p;
  sub_100047F64(&p_p);
  sub_1000577C4(&v14);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
}

void sub_10091DCF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  *(void *)(v28 + 136) = v29;
  sub_1000577C4(&a15);
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10091DD70(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

uint64_t sub_10091DE4C(void *a1)
{
  uint64_t v1 = (void *)a1[29];
  unsigned int v2 = a1 + 30;
  if (v1 == a1 + 30)
  {
    char v4 = 0;
    char v5 = 0;
  }
  else
  {
    char v4 = 0;
    while (1)
    {
      char v5 = (*(uint64_t (**)(void *, void *))(*a1 + 160))(a1, v1 + 7);
      if (v5) {
        break;
      }
      BOOL v6 = (void *)v1[1];
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          BOOL v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v7 = (void *)v1[2];
          BOOL v8 = *v7 == (void)v1;
          uint64_t v1 = v7;
        }
        while (!v8);
      }
      v4 |= v5 ^ 1;
      uint64_t v1 = v7;
      if (v7 == v2) {
        return v5 & 1 | ((v4 & 1) == 0);
      }
    }
    char v5 = 1;
  }
  return v5 & 1 | ((v4 & 1) == 0);
}

void sub_10091DF14(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  subscriber::makeSimSlotRange();
  unsigned int v2 = (unsigned int *)v93;
  uint64_t v84 = v94;
  if (v93 != v94)
  {
    uint64_t v83 = v95;
    while (1)
    {
      uint64_t v3 = v2;
      if (v95(*v2)) {
        break;
      }
      unsigned int v2 = v3 + 1;
      if (v3 + 1 == (unsigned int *)v94)
      {
        char v4 = v94;
        goto LABEL_7;
      }
    }
    char v4 = (int *)v3;
LABEL_7:
    char v5 = v94;
    uint64_t v79 = v94;
LABEL_8:
    if (v4 == v5) {
      return;
    }
    int v92 = 0;
    uint64_t v81 = v4;
    int v92 = *v4;
    long long v96 = &v92;
    BOOL v6 = sub_10008CC40((uint64_t **)a2, &v92, (uint64_t)&unk_10144E20E, &v96);
    unsigned int v7 = 0;
    uint64_t v82 = v6 + 5;
    unsigned int i = v6 + 7;
    std::string v85 = v6 + 7;
    long long v87 = v6;
    while (1)
    {
      long long v89 = 0;
      long long v90 = 0;
      uint64_t v91 = 0;
      sub_10091C610(a1, v92, v7, &v89);
      unint64_t v10 = v89;
      uint64_t v9 = v90;
      if ((char *)v90 - (char *)v89 >= 1)
      {
        uint64_t v11 = ((char *)v90 - (char *)v89) / 136;
        uint64_t v12 = v6[5];
        BOOL v13 = v6[6];
        uint64_t v14 = ((char *)v13 - (char *)v12) / 136;
        std::string v15 = &v12[17 * v14];
        if ((uint64_t)(0xF0F0F0F0F0F0F0F1 * (*i - v13)) >= v11)
        {
          if ((uint64_t)(0xF0F0F0F0F0F0F0F1 * (v13 - v15)) >= v11)
          {
            unint64_t v20 = &v89[17 * v11];
            uint64_t v23 = v6[6];
            BOOL v6 = v87;
LABEL_39:
            unsigned int v86 = v7;
            uint64_t v44 = &v23[-17 * v11];
            unint64_t v45 = v23;
            while (v44 < v13)
            {
              *unint64_t v45 = *v44;
              long long v46 = *(_OWORD *)(v44 + 1);
              v45[3] = v44[3];
              *(_OWORD *)(v45 + 1) = v46;
              v44[2] = 0;
              v44[3] = 0;
              v44[1] = 0;
              long long v47 = *((_OWORD *)v44 + 2);
              v45[6] = v44[6];
              *((_OWORD *)v45 + 2) = v47;
              v44[5] = 0;
              v44[6] = 0;
              v44[4] = 0;
              v45[7] = v44[7];
              long long v48 = *((_OWORD *)v44 + 4);
              v45[10] = v44[10];
              *((_OWORD *)v45 + 4) = v48;
              v44[9] = 0;
              v44[10] = 0;
              v44[8] = 0;
              long long v49 = *(_OWORD *)(v44 + 11);
              v45[13] = v44[13];
              *(_OWORD *)(v45 + 11) = v49;
              v44[12] = 0;
              v44[13] = 0;
              v44[11] = 0;
              long long v50 = *((_OWORD *)v44 + 7);
              *((unsigned char *)v45 + 128) = *((unsigned char *)v44 + 128);
              *((_OWORD *)v45 + 7) = v50;
              v45 += 17;
              v44 += 17;
            }
            uint64_t v51 = &v15[17 * v11];
            void v6[6] = v45;
            if (v23 != v51)
            {
              unint64_t v52 = 0;
              unint64_t v53 = 0xF0F0F0F0F0F0F0F1 * (v23 - v51);
              unint64_t v54 = &v12[17 * v53 + 17 * (((char *)v13 - (char *)v12) / 136)];
              uint64_t v55 = -136 * v53;
              do
              {
                uint64_t v56 = &v54[v52 / 8];
                uint64_t v57 = &v23[v52 / 8];
                v23[v52 / 8 - 17] = v54[v52 / 8 - 17];
                int v58 = (void **)&v23[v52 / 8 - 16];
                if (*((char *)&v23[v52 / 8 - 13] - 1) < 0) {
                  operator delete(*v58);
                }
                long long v59 = *((_OWORD *)v56 - 8);
                v23[v52 / 8 - 14] = *(v56 - 14);
                *(_OWORD *)int v58 = v59;
                *((unsigned char *)v56 - 105) = 0;
                *((unsigned char *)v56 - 128) = 0;
                uint64_t v60 = (void **)(v57 - 13);
                if (*((char *)v57 - 81) < 0) {
                  operator delete(*v60);
                }
                uint64_t v61 = v56 - 13;
                long long v62 = &v54[v52 / 8];
                long long v63 = *(_OWORD *)v61;
                *(v57 - 11) = v61[2];
                *(_OWORD *)uint64_t v60 = v63;
                *((unsigned char *)&v54[v52 / 8 - 10] - 1) = 0;
                *(unsigned char *)uint64_t v61 = 0;
                char v64 = &v23[v52 / 8];
                LOBYTE(v61) = *((unsigned char *)&v54[v52 / 8 - 9] - 4);
                *((_DWORD *)v64 - 20) = v54[v52 / 8 - 10];
                *((unsigned char *)v64 - 76) = (_BYTE)v61;
                unsigned int v65 = (void **)&v23[v52 / 8 - 9];
                if (*((char *)&v23[v52 / 8 - 6] - 1) < 0) {
                  operator delete(*v65);
                }
                long long v66 = *(_OWORD *)(v62 - 9);
                v23[v52 / 8 - 7] = *(v62 - 7);
                *(_OWORD *)unsigned int v65 = v66;
                *((unsigned char *)v62 - 49) = 0;
                *((unsigned char *)v62 - 72) = 0;
                uint64_t v67 = (void **)(v64 - 6);
                if (*((char *)v64 - 25) < 0) {
                  operator delete(*v67);
                }
                uint64_t v68 = &v54[v52 / 8];
                long long v69 = *(_OWORD *)&v54[v52 / 8 - 6];
                *(v64 - 4) = v54[v52 / 8 - 4];
                *(_OWORD *)uint64_t v67 = v69;
                *((unsigned char *)v68 - 25) = 0;
                *((unsigned char *)v68 - 48) = 0;
                uint64_t v70 = &v23[v52 / 8];
                long long v71 = *(_OWORD *)&v54[v52 / 8 - 3];
                *((unsigned char *)v70 - 8) = v54[v52 / 8 - 1];
                *(_OWORD *)(v70 - 3) = v71;
                v52 -= 136;
              }
              while (v55 != v52);
            }
            BOOL v6 = v87;
            unsigned int v7 = v86;
            for (unsigned int i = v85; v10 != v20; v15 = v74 + 6)
            {
              uint64_t v73 = *v10;
              uint64_t v72 = v10 + 1;
              uint64_t *v15 = v73;
              uint64_t v74 = v15 + 1;
              std::string::operator=((std::string *)v74, (const std::string *)v72);
              v72 += 3;
              v74 += 3;
              std::string::operator=((std::string *)v74, (const std::string *)v72);
              int v75 = *((_DWORD *)v72 + 6);
              *((unsigned char *)v74 + 28) = *((unsigned char *)v72 + 28);
              *((_DWORD *)v74 + 6) = v75;
              v72 += 4;
              v74 += 4;
              std::string::operator=((std::string *)v74, (const std::string *)v72);
              v72 += 3;
              v74 += 3;
              std::string::operator=((std::string *)v74, (const std::string *)v72);
              long long v76 = *(_OWORD *)(v72 + 3);
              *((unsigned char *)v74 + 40) = *((unsigned char *)v72 + 40);
              *(_OWORD *)(v74 + 3) = v76;
              unint64_t v10 = v72 + 6;
            }
            goto LABEL_55;
          }
          unint64_t v20 = &v89[v13 - v15];
          if (v20 == v90)
          {
            uint64_t v23 = v6[6];
          }
          else
          {
            unsigned int v21 = v7;
            uint64_t v22 = 0;
            do
            {
              sub_10009DB3C((uint64_t)&v13[v22], (uint64_t)&v20[v22]);
              v22 += 17;
            }
            while (&v20[v22] != v9);
            uint64_t v23 = &v13[v22];
            unsigned int v7 = v21;
            unsigned int i = v85;
          }
          v87[6] = v23;
          BOOL v6 = v87;
          if ((char *)v13 - (char *)v15 >= 1) {
            goto LABEL_39;
          }
        }
        else
        {
          unint64_t v16 = v14 + v11;
          if ((unint64_t)(v14 + v11) > 0x1E1E1E1E1E1E1E1) {
            sub_10006A748();
          }
          if (0xE1E1E1E1E1E1E1E2 * (*i - v12) > v16) {
            unint64_t v16 = 0xE1E1E1E1E1E1E1E2 * (*i - v12);
          }
          if (0xF0F0F0F0F0F0F0F1 * (*i - v12) >= 0xF0F0F0F0F0F0F0) {
            unint64_t v17 = 0x1E1E1E1E1E1E1E1;
          }
          else {
            unint64_t v17 = v16;
          }
          uint64_t v100 = i;
          if (v17)
          {
            uint64_t v18 = (int *)sub_100320E18((uint64_t)i, v17);
            unsigned int v19 = v7;
          }
          else
          {
            unsigned int v19 = v7;
            uint64_t v18 = 0;
          }
          uint64_t v24 = (uint64_t)&v18[34 * v14];
          long long v96 = v18;
          long long v97 = (int *)v24;
          uint64_t v98 = v24;
          uint64_t v99 = (uint64_t *)&v18[34 * v17];
          uint64_t v25 = v24 + 136 * v11;
          uint64_t v26 = 136 * v11;
          do
          {
            sub_10009DB3C(v24, (uint64_t)v10);
            v24 += 136;
            v10 += 17;
            v26 -= 136;
          }
          while (v26);
          uint64_t v98 = v25;
          size_t v27 = v97;
          uint64_t v28 = *v82;
          unsigned int v7 = v19;
          if (*v82 != v15)
          {
            uint64_t v29 = v15;
            do
            {
              uint64_t v30 = *(v29 - 17);
              v29 -= 17;
              *((void *)v27 - 17) = v30;
              v27 -= 34;
              long long v31 = *(_OWORD *)(v29 + 1);
              *((void *)v27 + 3) = v29[3];
              *(_OWORD *)(v27 + 2) = v31;
              void v29[2] = 0;
              v29[3] = 0;
              v29[1] = 0;
              long long v32 = *((_OWORD *)v29 + 2);
              *((void *)v27 + 6) = v29[6];
              *((_OWORD *)v27 + 2) = v32;
              void v29[5] = 0;
              v29[6] = 0;
              _DWORD v29[4] = 0;
              *((void *)v27 + 7) = v29[7];
              long long v33 = *((_OWORD *)v29 + 4);
              *((void *)v27 + 10) = v29[10];
              *((_OWORD *)v27 + 4) = v33;
              v29[9] = 0;
              v29[10] = 0;
              v29[8] = 0;
              long long v34 = *(_OWORD *)(v29 + 11);
              *((void *)v27 + 13) = v29[13];
              *(_OWORD *)(v27 + 22) = v34;
              v29[12] = 0;
              v29[13] = 0;
              v29[11] = 0;
              long long v35 = *((_OWORD *)v29 + 7);
              *((unsigned char *)v27 + 128) = *((unsigned char *)v29 + 128);
              *((_OWORD *)v27 + 7) = v35;
            }
            while (v29 != v28);
            uint64_t v25 = v98;
          }
          long long v97 = v27;
          int v36 = v6[6];
          if (v36 != v15)
          {
            do
            {
              *(void *)uint64_t v25 = *v15;
              long long v37 = *(_OWORD *)(v15 + 1);
              *(void *)(v25 + 24) = v15[3];
              *(_OWORD *)(v25 + 8) = v37;
              v15[2] = 0;
              unint64_t v15[3] = 0;
              v15[1] = 0;
              long long v38 = *((_OWORD *)v15 + 2);
              *(void *)(v25 + 48) = v15[6];
              *(_OWORD *)(v25 + 32) = v38;
              v15[5] = 0;
              v15[6] = 0;
              v15[4] = 0;
              *(void *)(v25 + 56) = v15[7];
              long long v39 = *((_OWORD *)v15 + 4);
              *(void *)(v25 + 80) = v15[10];
              *(_OWORD *)(v25 + 64) = v39;
              v15[9] = 0;
              v15[10] = 0;
              v15[8] = 0;
              long long v40 = *(_OWORD *)(v15 + 11);
              *(void *)(v25 + 104) = v15[13];
              *(_OWORD *)(v25 + 88) = v40;
              v15[12] = 0;
              v15[13] = 0;
              v15[11] = 0;
              long long v41 = *((_OWORD *)v15 + 7);
              *(unsigned char *)(v25 + 128) = *((unsigned char *)v15 + 128);
              *(_OWORD *)(v25 + 112) = v41;
              v25 += 136;
              v15 += 17;
            }
            while (v15 != v36);
            size_t v27 = v97;
            std::string v15 = v6[6];
          }
          uint64_t v42 = (int *)v6[5];
          void v6[5] = (uint64_t *)v27;
          void v6[6] = (uint64_t *)v25;
          uint64_t v43 = v6[7];
          v6[7] = v99;
          uint64_t v98 = (uint64_t)v15;
          uint64_t v99 = v43;
          long long v96 = v42;
          long long v97 = v42;
          sub_100704D54((uint64_t)&v96);
        }
      }
LABEL_55:
      long long v96 = (int *)&v89;
      sub_100702C2C((void ***)&v96);
      if (++v7 == 13)
      {
        char v4 = v84;
        if (v81 + 1 != v84)
        {
          int v77 = (unsigned int *)(v81 + 1);
          while (1)
          {
            unsigned int v78 = v77;
            if (v83(*v77)) {
              break;
            }
            int v77 = v78 + 1;
            if (v78 + 1 == (unsigned int *)v84)
            {
              char v4 = v84;
              goto LABEL_62;
            }
          }
          char v4 = (int *)v78;
        }
LABEL_62:
        char v5 = v79;
        goto LABEL_8;
      }
    }
  }
}

void sub_10091E644(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t *sub_10091E6C8(uint64_t a1, int *a2)
{
  unsigned int v2 = *(uint64_t **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    sub_1000C14F0("map::at:  key not found");
  int v3 = *a2;
  while (1)
  {
    while (1)
    {
      int v4 = *((_DWORD *)v2 + 8);
      if (v3 >= v4) {
        break;
      }
      unsigned int v2 = (uint64_t *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }
    if (v4 >= v3) {
      return v2 + 5;
    }
    unsigned int v2 = (uint64_t *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }
}

void sub_10091E720(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = (void *)(a1 + 8);
  void v3[4] = a1;
  sub_100921408((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, v2);
  operator new();
}

void sub_10091E854(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_10091E864(void *a1)
{
  unsigned int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10091E8E8(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xF0F0F0F0F0F0F0F1 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x1E1E1E1E1E1E1E1) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xF0F0F0F0F0F0F0F1 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xF0F0F0F0F0F0F0) {
    unint64_t v9 = 0x1E1E1E1E1E1E1E1;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)sub_100320E18(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  BOOL v13 = v10;
  uint64_t v14 = &v10[136 * v4];
  unint64_t v16 = &v10[136 * v9];
  sub_10009DB3C((uint64_t)v14, a2);
  std::string v15 = v14 + 136;
  sub_100704C84(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100704D54((uint64_t)&v13);
  return v11;
}

void sub_10091E9DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100704D54((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_10091E9F0(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    sub_1003A0BE0(result, a4);
    __n128 result = (void *)sub_100702A80((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_10091EA58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100702C2C(&a9);
  _Unwind_Resume(a1);
}

void sub_10091EA78(void ***a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        BOOL v6 = v4;
        sub_100702C2C(&v6);
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_10091EAEC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void ****)(a1 + 8);
    unint64_t v4 = **(void ****)(a1 + 16);
    while (v4 != v3)
    {
      v4 -= 3;
      unint64_t v5 = v4;
      sub_100702C2C(&v5);
    }
  }
  return a1;
}

uint64_t sub_10091EB50(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_10091EBEC()
{
}

uint64_t sub_10091EC00(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_10091EC0C(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_10091EC0C(a1, *(void *)a2);
    sub_10091EC0C(a1, *((void *)a2 + 1));
    unint64_t v4 = (void **)(a2 + 40);
    sub_10091EA78(&v4);
    operator delete(a2);
  }
}

void sub_10091EC6C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10091EC6C(a1, *a2);
    sub_10091EC6C(a1, a2[1]);
    sub_10091ECC8((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_10091ECC8(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0)
  {
    unsigned int v2 = *(void **)(a1 + 16);
    operator delete(v2);
  }
}

uint64_t *sub_10091ED40(void **a1)
{
  uint64_t v1 = *a1;
  BOOL v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  unint64_t v4 = v1[1];
  *(void *)CSIPhoneNumber buf = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v2 + 136))(v2, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  sub_100088C88((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_10091EE24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10091EE5C()
{
}

__n128 sub_10091EE70(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A1C0A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10091EEBC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1C0A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10091EEEC(uint64_t a1, xpc_object_t *a2)
{
  void (***v17)(uint64_t *__return_ptr, void, uint64_t);
  char v18;
  uint64_t v19;
  void **v20;
  void **v21;
  int v22;
  int v23;
  os_log_t *v24;
  NSObject *v25;
  uint64_t *v26;
  BOOL v27;
  void **v28;
  void *v29;
  uint64_t v31;
  std::__shared_weak_count *v32;
  uint8_t buf[8];

  uint64_t v3 = *(void **)(a1 + 8);
  unint64_t v4 = v3 + 1;
  unint64_t v5 = (void *)v3[1];
  uint64_t v28 = (void **)*v3;
  uint64_t v29 = v5;
  if (v3[2])
  {
    void v5[2] = &v29;
    void *v3 = v4;
    *unint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v28 = &v29;
  }
  sub_100A5892C((uint64_t)v3, a2, "PersonalityID", "State");
  uint64_t v7 = *(void *)(a1 + 16);
  unint64_t v8 = *(uint64_t **)(v7 + 232);
  if (v8 != (uint64_t *)(v7 + 240))
  {
    while (1)
    {
      long long v31 = 0;
      long long v32 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(v7 + 160));
      uint64_t v10 = ServiceMap;
      if (v11 < 0)
      {
        uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v13 = 5381;
        do
        {
          uint64_t v11 = v13;
          unsigned int v14 = *v12++;
          uint64_t v13 = (33 * v13) ^ v14;
        }
        while (v14);
      }
      std::mutex::lock(ServiceMap);
      *(void *)CSIPhoneNumber buf = v11;
      std::string v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
      if (!v15) {
        break;
      }
      unint64_t v17 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (!v16) {
        goto LABEL_12;
      }
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      uint64_t v18 = 0;
LABEL_13:
      (**v17)(&v31, v17, (uint64_t)(v8 + 4));
      if ((v18 & 1) == 0) {
        sub_10004D2C8(v16);
      }
      if (v31)
      {
        unsigned int v19 = *(unsigned int *)(v31 + 52);
        unint64_t v20 = sub_100046F68((uint64_t)&v28, (void **)v8 + 4);
        if (&v29 != (void **)v20)
        {
          unsigned int v21 = v20 + 7;
          if (*((_DWORD *)v20 + 14) != *((_DWORD *)v8 + 14)
            || *((unsigned __int8 *)v20 + 60) != *((unsigned __int8 *)v8 + 60)
            || (sub_1005A0BB8((unsigned __int8 *)v20 + 64, (unsigned __int8 *)v8 + 64) & 1) == 0)
          {
            uint64_t v22 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v7 + 160))(v7, v21);
            uint64_t v23 = sub_10091DE4C((void *)v7);
            uint64_t v24 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v7 + 48) + 16))(*(void *)(v7 + 48), v19);
            if (((v22 | v23 ^ 1) & 1) == 0)
            {
              uint64_t v25 = *v24;
              if (os_log_type_enabled(*v24, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)CSIPhoneNumber buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I VoWiFiProvState changed, making this model current. Sending emergency numbers update", buf, 2u);
              }
              (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 168))(v7, v19);
            }
          }
        }
      }
      if (v32) {
        sub_10004D2C8(v32);
      }
      uint64_t v26 = (uint64_t *)v8[1];
      if (v26)
      {
        do
        {
          BOOL v6 = v26;
          uint64_t v26 = (uint64_t *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          BOOL v6 = (uint64_t *)v8[2];
          size_t v27 = *v6 == (void)v8;
          unint64_t v8 = v6;
        }
        while (!v27);
      }
      unint64_t v8 = v6;
      if (v6 == (uint64_t *)(v7 + 240)) {
        goto LABEL_32;
      }
    }
    unint64_t v17 = 0;
LABEL_12:
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    uint64_t v18 = 1;
    goto LABEL_13;
  }
LABEL_32:
  sub_1007035FC((uint64_t)&v28, v29);
}

void sub_10091F1F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10091F244(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10091F284()
{
}

void sub_10091F294()
{
}

__n128 sub_10091F2A8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A1C128;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10091F2FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1C128;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10091F334(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10091F37C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10091F3BC()
{
}

void sub_10091F3CC()
{
}

void *sub_10091F3E0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A1C1A8;
  result[1] = v3;
  return result;
}

uint64_t sub_10091F428(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A1C1A8;
  a2[1] = v2;
  return result;
}

void sub_10091F454(uint64_t a1, SubscriptionInfo *a2, const object *a3)
{
}

uint64_t sub_10091F45C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10091F49C()
{
}

void sub_10091F4A8(_DWORD **a1, SubscriptionInfo *a2, const object *a3)
{
  uint64_t v3 = *a1;
  v5[0] = 0;
  v5[1] = 0;
  unint64_t v4 = v5;
  rest::read_rest_value((rest *)&v4, a2, a3);
  sub_10091F518(v3, &v4);
  sub_10030A9DC((uint64_t)&v4, v5[0]);
}

void sub_10091F500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

_DWORD *sub_10091F518(_DWORD *result, void *a2)
{
  void *result = 1;
  unint64_t v4 = (void *)*a2;
  uint64_t v2 = a2 + 1;
  uint64_t v3 = v4;
  if (v4 != v2)
  {
    while (1)
    {
      BOOL v5 = *((_DWORD *)v3 + 45) != 2 || *((unsigned char *)v3 + 208) == 0;
      BOOL v6 = v5 || *((unsigned char *)v3 + 209) == 0;
      BOOL v7 = !v6 && *((unsigned char *)v3 + 210) == 0;
      if (v7 && *((unsigned char *)v3 + 211) == 0) {
        break;
      }
      uint64_t v9 = (void *)v3[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v3[2];
          BOOL v5 = *v10 == (void)v3;
          uint64_t v3 = v10;
        }
        while (!v5);
      }
      uint64_t v3 = v10;
      if (v10 == v2) {
        return result;
      }
    }
    void *result = *((_DWORD *)v3 + 8);
  }
  return result;
}

void sub_10091F5A0(void **a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(*(void *)**a1 + 144))(**a1);
  operator delete();
}

void sub_10091F614()
{
}

uint64_t *sub_10091F640(void **a1)
{
  uint64_t v1 = *a1;
  BOOL v6 = a1;
  BOOL v7 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  unint64_t v4 = v1[1];
  *(void *)CSIPhoneNumber buf = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v2 + 152))(v2, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  sub_100088C88((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_10091F724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10091F758(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

void sub_10091F774(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 40) + 16))(&v16);
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)uint64_t v2 = v16;
  uint64_t v3 = (void **)(v2 + 8);
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v3);
  }
  long long v4 = v17;
  *(void *)(v2 + 24) = v18;
  *(_OWORD *)uint64_t v3 = v4;
  HIBYTE(v18) = 0;
  LOBYTE(v17) = 0;
  BOOL v5 = (void **)(v2 + 32);
  if (*(char *)(v2 + 55) < 0) {
    operator delete(*v5);
  }
  long long v6 = v19;
  *(void *)(v2 + 48) = v20;
  *(_OWORD *)BOOL v5 = v6;
  HIBYTE(v20) = 0;
  LOBYTE(v19) = 0;
  char v7 = v22;
  *(_DWORD *)(v2 + 56) = v21;
  *(unsigned char *)(v2 + 60) = v7;
  unint64_t v8 = (void **)(v2 + 64);
  if (*(char *)(v2 + 87) < 0) {
    operator delete(*v8);
  }
  long long v9 = __p;
  *(void *)(v2 + 80) = v24;
  *(_OWORD *)unint64_t v8 = v9;
  HIBYTE(v24) = 0;
  LOBYTE(__p) = 0;
  uint64_t v10 = (_OWORD *)(v2 + 88);
  if (*(char *)(v2 + 111) < 0)
  {
    operator delete(*(void **)(v2 + 88));
    int v13 = SHIBYTE(v24);
    long long v14 = v25;
    *(void *)(v2 + 104) = v26;
    _OWORD *v10 = v14;
    HIBYTE(v26) = 0;
    LOBYTE(v25) = 0;
    char v15 = v28;
    *(_OWORD *)(v2 + 112) = v27;
    *(unsigned char *)(v2 + 128) = v15;
    if (v13 < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    long long v11 = v25;
    *(void *)(v2 + 104) = v26;
    _OWORD *v10 = v11;
    HIBYTE(v26) = 0;
    LOBYTE(v25) = 0;
    char v12 = v28;
    *(_OWORD *)(v2 + 112) = v27;
    *(unsigned char *)(v2 + 128) = v12;
  }
  if (SHIBYTE(v20) < 0) {
    operator delete((void *)v19);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)v17);
  }
}

void sub_10091F908(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 40) + 16))(&v16);
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)uint64_t v2 = v16;
  uint64_t v3 = (void **)(v2 + 8);
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v3);
  }
  long long v4 = v17;
  *(void *)(v2 + 24) = v18;
  *(_OWORD *)uint64_t v3 = v4;
  HIBYTE(v18) = 0;
  LOBYTE(v17) = 0;
  BOOL v5 = (void **)(v2 + 32);
  if (*(char *)(v2 + 55) < 0) {
    operator delete(*v5);
  }
  long long v6 = v19;
  *(void *)(v2 + 48) = v20;
  *(_OWORD *)BOOL v5 = v6;
  HIBYTE(v20) = 0;
  LOBYTE(v19) = 0;
  char v7 = v22;
  *(_DWORD *)(v2 + 56) = v21;
  *(unsigned char *)(v2 + 60) = v7;
  unint64_t v8 = (void **)(v2 + 64);
  if (*(char *)(v2 + 87) < 0) {
    operator delete(*v8);
  }
  long long v9 = __p;
  *(void *)(v2 + 80) = v24;
  *(_OWORD *)unint64_t v8 = v9;
  HIBYTE(v24) = 0;
  LOBYTE(__p) = 0;
  uint64_t v10 = (_OWORD *)(v2 + 88);
  if (*(char *)(v2 + 111) < 0)
  {
    operator delete(*(void **)(v2 + 88));
    int v13 = SHIBYTE(v24);
    long long v14 = v25;
    *(void *)(v2 + 104) = v26;
    _OWORD *v10 = v14;
    HIBYTE(v26) = 0;
    LOBYTE(v25) = 0;
    char v15 = v28;
    *(_OWORD *)(v2 + 112) = v27;
    *(unsigned char *)(v2 + 128) = v15;
    if (v13 < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    long long v11 = v25;
    *(void *)(v2 + 104) = v26;
    _OWORD *v10 = v11;
    HIBYTE(v26) = 0;
    LOBYTE(v25) = 0;
    char v12 = v28;
    *(_OWORD *)(v2 + 112) = v27;
    *(unsigned char *)(v2 + 128) = v12;
  }
  if (SHIBYTE(v20) < 0) {
    operator delete((void *)v19);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)v17);
  }
}

uint64_t sub_10091FA9C(unsigned int **a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (uint64_t)*a1;
  uint64_t v104 = (os_log_t *)(*(uint64_t (**)(void, void))(**((void **)*a1 + 6) + 16))(*((void *)*a1 + 6), *a1[1]);
  unsigned int v3 = 0;
  uint64_t v105 = v1;
  do
  {
    if (v3 > 0xC || ((1 << v3) & 0x1802) == 0 || *(unsigned char *)v1[2])
    {
      uint64_t v113 = 0;
      uint64_t v114 = 0;
      uint64_t v115 = 0;
      sub_10091C610(v2, *v1[1], v3, &v113);
      uint64_t v4 = v113;
      uint64_t v5 = v114;
      while (1)
      {
        if (v4 == v5)
        {
          *(void *)&__dst.var0 = &v113;
          sub_100702C2C((void ***)&__dst);
          goto LABEL_119;
        }
        uint64_t v112 = 0;
        long long v110 = 0u;
        long long v111 = 0u;
        *(_OWORD *)char v108 = 0u;
        *(_OWORD *)long long __p = 0u;
        long long v107 = 0u;
        memset(&__dst, 0, sizeof(__dst));
        sub_10009DB3C((uint64_t)&__dst, v4);
        if ((CSIPhoneNumber::getIsEmVoiceSupported(&__dst) & 1) == 0)
        {
          long long v14 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            CSIPhoneNumber::getFullNumber((uint64_t *)v119, &__dst);
            char v15 = (v119[23] & 0x80u) == 0 ? v119 : *(uint8_t **)v119;
            *(_DWORD *)CSIPhoneNumber buf = 136446210;
            *(void *)&uint8_t buf[4] = v15;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Skipping SMS-only number: %{public}s", buf, 0xCu);
            if ((char)v119[23] < 0) {
              operator delete(*(void **)v119);
            }
          }
          int v16 = 9;
          goto LABEL_34;
        }
        long long v6 = (CSIPhoneNumber *)v1[3];
        CSIPhoneNumber::getFullNumber((uint64_t *)v119, v6);
        CSIPhoneNumber::getFullNumber((uint64_t *)buf, &__dst);
        uint64_t v7 = v119[23];
        uint8_t v8 = v119[23];
        if ((v119[23] & 0x80u) == 0) {
          uint64_t v9 = v119[23];
        }
        else {
          uint64_t v9 = *(void *)&v119[8];
        }
        uint64_t v10 = buf[23];
        int v11 = (char)buf[23];
        if ((buf[23] & 0x80u) != 0) {
          uint64_t v10 = *(void *)&buf[8];
        }
        if (v9 != v10) {
          goto LABEL_31;
        }
        if ((buf[23] & 0x80u) == 0) {
          char v12 = buf;
        }
        else {
          char v12 = *(uint8_t **)buf;
        }
        if ((char)v119[23] < 0)
        {
          if (memcmp(*(const void **)v119, v12, *(size_t *)&v119[8])) {
            goto LABEL_31;
          }
        }
        else if (v119[23])
        {
          int v13 = v119;
          while (*v13 == *v12)
          {
            ++v13;
            ++v12;
            if (!--v7) {
              goto LABEL_45;
            }
          }
LABEL_31:
          if (v11 < 0)
          {
            operator delete(*(void **)buf);
            if ((v119[23] & 0x80) == 0) {
              goto LABEL_33;
            }
          }
          else if ((v8 & 0x80) == 0)
          {
LABEL_33:
            int v16 = 0;
            uint64_t v1 = v105;
            goto LABEL_34;
          }
          operator delete(*(void **)v119);
          goto LABEL_33;
        }
LABEL_45:
        int TypeOfAddress = CSIPhoneNumber::getTypeOfAddress(v6);
        int v18 = CSIPhoneNumber::getTypeOfAddress(&__dst);
        uint64_t v1 = v105;
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        if ((char)v119[23] < 0) {
          operator delete(*(void **)v119);
        }
        if (TypeOfAddress != v18) {
          goto LABEL_117;
        }
        CFArrayRef v118 = 0;
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 208) + 32))(v119);
        sub_100044D6C(&v118, (CFTypeRef *)v119);
        sub_1000577C4((const void **)v119);
        if (v118) {
          long long v19 = sub_100083F10;
        }
        else {
          long long v19 = 0;
        }
        if (!v19) {
          goto LABEL_94;
        }
        CFIndex Count = CFArrayGetCount(v118);
        int v21 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v119 = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Found a skip list. Checking the number against the skip list.", v119, 2u);
        }
        if (Count < 1)
        {
LABEL_94:
          long long v37 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v119 = 0;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Found emergency number and it's not in exception list", v119, 2u);
          }
          sub_100044D00((const void **)&v118);
          long long v38 = *v104;
          if (os_log_type_enabled(*v104, OS_LOG_TYPE_DEFAULT))
          {
            CSIPhoneNumber::getFullNumber((uint64_t *)buf, (CSIPhoneNumber *)v1[3]);
            if ((buf[23] & 0x80u) == 0) {
              long long v39 = buf;
            }
            else {
              long long v39 = *(uint8_t **)buf;
            }
            CSIPhoneNumber::getFullNumber((uint64_t *)v116, &__dst);
            if (v117 >= 0) {
              long long v40 = v116;
            }
            else {
              long long v40 = (void **)v116[0];
            }
            int EmergencyCategory = CSIPhoneNumber::getEmergencyCategory(&__dst);
            uint64_t v42 = asString();
            *(_DWORD *)uint64_t v119 = 136315906;
            *(void *)&int v119[4] = v39;
            *(_WORD *)&v119[12] = 2080;
            *(void *)&v119[14] = v40;
            *(_WORD *)&v119[22] = 1024;
            LODWORD(v120[0]) = EmergencyCategory;
            WORD2(v120[0]) = 2080;
            *(void *)((char *)v120 + 6) = v42;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#N %s is an emergency number! Matched (Number, Category): '%s', '%d' from %slist", v119, 0x26u);
            if (v117 < 0) {
              operator delete(v116[0]);
            }
            uint64_t v1 = v105;
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
          }
          uint64_t v43 = (CSIPhoneNumber *)v1[3];
          unsigned int v44 = CSIPhoneNumber::getEmergencyCategory(&__dst);
          CSIPhoneNumber::setEmergencyCategory(v43, v44);
          CSIPhoneNumber::getTypeOfNumber(&__dst);
          CSIPhoneNumber::setTypeOfNumber();
          toCallMetricEmNumListType();
          CSIPhoneNumber::setMatchedEmMetricListType();
          int v16 = 1;
          goto LABEL_34;
        }
        CFIndex v22 = 0;
        char v23 = 0;
        do
        {
          CFArrayGetValueAtIndex(v118, v22);
          memset(buf, 0, sizeof(buf));
          sub_100058DB0(buf, "");
          ctu::cf::assign();
          CSIPhoneNumber::getFullNumber((uint64_t *)v119, &__dst);
          if ((v119[23] & 0x80u) == 0) {
            uint64_t v24 = v119[23];
          }
          else {
            uint64_t v24 = *(void *)&v119[8];
          }
          uint64_t v25 = buf[23];
          if ((buf[23] & 0x80u) != 0) {
            uint64_t v25 = *(void *)&buf[8];
          }
          if (v24 == v25)
          {
            if ((buf[23] & 0x80u) == 0) {
              uint64_t v26 = buf;
            }
            else {
              uint64_t v26 = *(uint8_t **)buf;
            }
            if ((v119[23] & 0x80) != 0)
            {
              long long v31 = *(void **)v119;
              int v32 = memcmp(*(const void **)v119, v26, *(size_t *)&v119[8]);
              operator delete(v31);
              if (v32) {
                goto LABEL_81;
              }
LABEL_80:
              char v23 = 1;
              goto LABEL_81;
            }
            if (!v119[23]) {
              goto LABEL_80;
            }
            uint64_t v27 = 0;
            do
            {
              int v28 = v119[v27];
              int v29 = v26[v27];
            }
            while (v28 == v29 && v119[23] - 1 != v27++);
            if (v28 == v29) {
              goto LABEL_80;
            }
          }
          else if ((v119[23] & 0x80) != 0)
          {
            operator delete(*(void **)v119);
          }
LABEL_81:
          long long v33 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            CSIPhoneNumber::getFullNumber((uint64_t *)v116, &__dst);
            long long v34 = v116;
            if (v117 < 0) {
              long long v34 = (void **)v116[0];
            }
            long long v35 = buf;
            if ((buf[23] & 0x80u) != 0) {
              long long v35 = *(uint8_t **)buf;
            }
            int v36 = "yes";
            if ((v23 & 1) == 0) {
              int v36 = "no";
            }
            *(_DWORD *)uint64_t v119 = 136315650;
            *(void *)&int v119[4] = v34;
            *(_WORD *)&v119[12] = 2080;
            *(void *)&v119[14] = v35;
            *(_WORD *)&v119[22] = 2080;
            v120[0] = v36;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Comparing original number [%s] vs. skip list: [%s]. Should we skip? [%s]", v119, 0x20u);
            if (v117 < 0) {
              operator delete(v116[0]);
            }
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          ++v22;
        }
        while (v22 != Count);
        uint64_t v1 = v105;
        if ((v23 & 1) == 0) {
          goto LABEL_94;
        }
        unint64_t v45 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        {
          CSIPhoneNumber::getFullNumber((uint64_t *)v119, &__dst);
          long long v46 = (v119[23] & 0x80u) == 0 ? v119 : *(uint8_t **)v119;
          *(_DWORD *)CSIPhoneNumber buf = 136315138;
          *(void *)&uint8_t buf[4] = v46;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I %s matched but it's part of the emergency number exception list, so skipping", buf, 0xCu);
          if ((char)v119[23] < 0) {
            operator delete(*(void **)v119);
          }
        }
        sub_100044D00((const void **)&v118);
LABEL_117:
        int v16 = 0;
LABEL_34:
        if (SHIBYTE(v110) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(__p[0]) < 0) {
          operator delete(v108[0]);
        }
        if (SBYTE7(v107) < 0) {
          operator delete(*(void **)&__dst.var2.__r_.var0);
        }
        if (*((char *)&__dst.var2.__r_.__value_.var0.var1 + 23) < 0) {
          operator delete(__dst.var2.__r_.__value_.var0.var1.__data_);
        }
        if (v16 != 9 && v16)
        {
          *(void *)&__dst.var0 = &v113;
          sub_100702C2C((void ***)&__dst);
          return 1;
        }
        v4 += 136;
      }
    }
    long long v47 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__dst.var0) = 0;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Skipping checking emergency numbers with normal setup", (uint8_t *)&__dst, 2u);
    }
LABEL_119:
    ++v3;
  }
  while (v3 != 13);
  uint64_t v50 = *(void *)(v2 + 304);
  uint64_t v51 = v1[1];
  if (!v50) {
    goto LABEL_176;
  }
  signed int v52 = *v51;
  uint64_t v53 = v2 + 304;
  do
  {
    int v54 = *(_DWORD *)(v50 + 32);
    BOOL v55 = v54 < v52;
    if (v54 >= v52) {
      uint64_t v56 = (uint64_t *)v50;
    }
    else {
      uint64_t v56 = (uint64_t *)(v50 + 8);
    }
    if (!v55) {
      uint64_t v53 = v50;
    }
    uint64_t v50 = *v56;
  }
  while (*v56);
  if (v53 == v2 + 304 || v52 < *(_DWORD *)(v53 + 32))
  {
LABEL_176:
    uint64_t v112 = 0;
    long long v110 = 0u;
    long long v111 = 0u;
    *(_OWORD *)char v108 = 0u;
    *(_OWORD *)long long __p = 0u;
    long long v107 = 0u;
    memset(&__dst, 0, sizeof(__dst));
    sub_10091C800(&__dst, v2, *v51);
    uint64_t v74 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
    {
      CSIPhoneNumber::getFullNumber((uint64_t *)v119, &__dst);
      int v75 = (char)v119[23];
      long long v76 = *(uint8_t **)v119;
      int v77 = CSIPhoneNumber::getEmergencyCategory(&__dst);
      unsigned int v78 = v119;
      if (v75 < 0) {
        unsigned int v78 = v76;
      }
      *(_DWORD *)CSIPhoneNumber buf = 136315394;
      *(void *)&uint8_t buf[4] = v78;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v77;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I Preferred emergency number is %s and has category %d", buf, 0x12u);
      if ((char)v119[23] < 0) {
        operator delete(*(void **)v119);
      }
    }
    CSIPhoneNumber::getFullNumber((uint64_t *)v119, &__dst);
    CSIPhoneNumber::getFullNumber((uint64_t *)buf, (CSIPhoneNumber *)v1[3]);
    uint8_t v79 = v119[23];
    if ((v119[23] & 0x80u) == 0) {
      uint64_t v80 = v119[23];
    }
    else {
      uint64_t v80 = *(void *)&v119[8];
    }
    uint64_t v81 = buf[23];
    int v82 = (char)buf[23];
    if ((buf[23] & 0x80u) != 0) {
      uint64_t v81 = *(void *)&buf[8];
    }
    if (v80 != v81)
    {
      BOOL v91 = 0;
      if (((char)buf[23] & 0x80000000) == 0) {
        goto LABEL_205;
      }
      goto LABEL_200;
    }
    if ((buf[23] & 0x80u) == 0) {
      uint64_t v83 = buf;
    }
    else {
      uint64_t v83 = *(uint8_t **)buf;
    }
    if ((char)v119[23] < 0)
    {
      BOOL v91 = memcmp(*(const void **)v119, v83, *(size_t *)&v119[8]) == 0;
    }
    else
    {
      if (!v119[23])
      {
        BOOL v91 = 1;
        if (((char)buf[23] & 0x80000000) == 0)
        {
LABEL_205:
          if ((v79 & 0x80) == 0)
          {
LABEL_206:
            if (!v91) {
              goto LABEL_214;
            }
            goto LABEL_207;
          }
LABEL_201:
          operator delete(*(void **)v119);
          if (!v91) {
            goto LABEL_214;
          }
LABEL_207:
          if (CSIPhoneNumber::hasEmergencyCategorySet(&__dst))
          {
            int v92 = *v104;
            if (os_log_type_enabled(*v104, OS_LOG_TYPE_DEFAULT))
            {
              CSIPhoneNumber::getFullNumber((uint64_t *)v119, &__dst);
              int v93 = (char)v119[23];
              long long v94 = *(uint8_t **)v119;
              int v95 = CSIPhoneNumber::getEmergencyCategory(&__dst);
              long long v96 = v119;
              if (v93 < 0) {
                long long v96 = v94;
              }
              *(_DWORD *)CSIPhoneNumber buf = 136315394;
              *(void *)&uint8_t buf[4] = v96;
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v95;
              _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I Matched with the preferred number (Number, Category): '%s', '%d'", buf, 0x12u);
              if ((char)v119[23] < 0) {
                operator delete(*(void **)v119);
              }
            }
            long long v97 = (CSIPhoneNumber *)v1[3];
            unsigned int v98 = CSIPhoneNumber::getEmergencyCategory(&__dst);
            CSIPhoneNumber::setEmergencyCategory(v97, v98);
            CSIPhoneNumber::setTypeOfNumber();
            CSIPhoneNumber::setMatchedEmMetricListType();
            uint64_t v48 = 1;
LABEL_221:
            if (SHIBYTE(v110) < 0) {
              operator delete(__p[1]);
            }
            if (SHIBYTE(__p[0]) < 0) {
              operator delete(v108[0]);
            }
            if (SBYTE7(v107) < 0) {
              operator delete(*(void **)&__dst.var2.__r_.var0);
            }
            if (*((char *)&__dst.var2.__r_.__value_.var0.var1 + 23) < 0) {
              operator delete(__dst.var2.__r_.__value_.var0.var1.__data_);
            }
            return v48;
          }
LABEL_214:
          uint64_t v99 = *(NSObject **)(v2 + 40);
          uint64_t v48 = 0;
          if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
          {
            CSIPhoneNumber::getFullNumber((uint64_t *)v119, (CSIPhoneNumber *)v1[3]);
            if ((v119[23] & 0x80u) == 0) {
              uint64_t v100 = v119;
            }
            else {
              uint64_t v100 = *(uint8_t **)v119;
            }
            *(_DWORD *)CSIPhoneNumber buf = 136315138;
            *(void *)&uint8_t buf[4] = v100;
            _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "#I %s is NOT an emergency number!", buf, 0xCu);
            if ((char)v119[23] < 0) {
              operator delete(*(void **)v119);
            }
            uint64_t v48 = 0;
          }
          goto LABEL_221;
        }
LABEL_200:
        operator delete(*(void **)buf);
        if ((v119[23] & 0x80) == 0) {
          goto LABEL_206;
        }
        goto LABEL_201;
      }
      uint64_t v84 = v119[23] - 1;
      std::string v85 = v119;
      do
      {
        int v87 = *v85++;
        int v86 = v87;
        int v89 = *v83++;
        int v88 = v89;
        BOOL v71 = v84-- != 0;
        char v90 = v71;
        BOOL v91 = v86 == v88;
      }
      while (v86 == v88 && (v90 & 1) != 0);
    }
    if ((v82 & 0x80000000) == 0) {
      goto LABEL_205;
    }
    goto LABEL_200;
  }
  memset(v119, 0, sizeof(v119));
  sub_100702CB0(v119, *(void *)(v53 + 40), *(void *)(v53 + 48), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v53 + 48) - *(void *)(v53 + 40)) >> 3));
  uint64_t v57 = *(long long **)v119;
  int v58 = *(long long **)&v119[8];
  if (*(void *)v119 == *(void *)&v119[8])
  {
LABEL_175:
    *(void *)&__dst.var0 = v119;
    sub_100702E5C((void ***)&__dst);
    uint64_t v51 = v1[1];
    goto LABEL_176;
  }
  while (1)
  {
    *(void *)&long long v107 = 0;
    memset(&__dst, 0, sizeof(__dst));
    if (*((char *)v57 + 23) < 0)
    {
      sub_10004FC84(&__dst, *(void **)v57, *((void *)v57 + 1));
    }
    else
    {
      long long v59 = *v57;
      __dst.var2.__r_.__value_.var0.var1.__size_ = *((void *)v57 + 2);
      *(_OWORD *)&__dst.var0 = v59;
    }
    if (*((char *)v57 + 47) < 0)
    {
      sub_10004FC84(&__dst.var2.__r_.__value_.var0.var0.__data_[16], *((void **)v57 + 3), *((void *)v57 + 4));
    }
    else
    {
      long long v60 = *(long long *)((char *)v57 + 24);
      __dst.var2.var0 = *((void *)v57 + 5);
      *((_OWORD *)&__dst.var2.__r_.__value_.var0.var1 + 1) = v60;
    }
    *(void *)&long long v107 = *((void *)v57 + 6);
    if ((v107 & 0xFF00000000) == 0) {
      goto LABEL_167;
    }
    CSIPhoneNumber::getFullNumber((uint64_t *)buf, (CSIPhoneNumber *)v1[3]);
    if (__dst.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
      std::string::size_type data = (char *)__dst.var2.__r_.__value_.var0.var0.__data_[15];
    }
    else {
      std::string::size_type data = __dst.var2.__r_.__value_.var0.var1.__data_;
    }
    long long v62 = (char *)buf[23];
    int v63 = (char)buf[23];
    if ((buf[23] & 0x80u) != 0) {
      long long v62 = *(char **)&buf[8];
    }
    if (data != v62)
    {
      BOOL v73 = 0;
      if (((char)buf[23] & 0x80000000) == 0) {
        goto LABEL_166;
      }
LABEL_163:
      operator delete(*(void **)buf);
      goto LABEL_166;
    }
    if ((buf[23] & 0x80u) == 0) {
      char v64 = buf;
    }
    else {
      char v64 = *(uint8_t **)buf;
    }
    if (__dst.var2.__r_.__value_.var0.var0.__data_[15] < 0)
    {
      BOOL v73 = memcmp(*(const void **)&__dst.var0, v64, (size_t)__dst.var2.__r_.__value_.var0.var1.__data_) == 0;
      goto LABEL_165;
    }
    if (__dst.var2.__r_.__value_.var0.var0.__data_[15])
    {
      uint64_t v65 = __dst.var2.__r_.__value_.var0.var0.__data_[15] - 1;
      p_dst = &__dst;
      do
      {
        int var0_low = LOBYTE(p_dst->var0);
        p_dst = (CSIPhoneNumber *)((char *)p_dst + 1);
        int v67 = var0_low;
        int v70 = *v64++;
        int v69 = v70;
        BOOL v71 = v65-- != 0;
        char v72 = v71;
        BOOL v73 = v67 == v69;
      }
      while (v67 == v69 && (v72 & 1) != 0);
LABEL_165:
      if (v63 < 0) {
        goto LABEL_163;
      }
      goto LABEL_166;
    }
    BOOL v73 = 1;
    if ((char)buf[23] < 0) {
      goto LABEL_163;
    }
LABEL_166:
    uint64_t v1 = v105;
    if (v73) {
      break;
    }
LABEL_167:
    if (SHIBYTE(__dst.var2.var0) < 0) {
      operator delete(*((void **)&__dst.var2.__r_.__value_.var0.var1 + 2));
    }
    if (__dst.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
      operator delete(*(void **)&__dst.var0);
    }
    uint64_t v57 = (long long *)((char *)v57 + 56);
    if (v57 == v58) {
      goto LABEL_175;
    }
  }
  unsigned int v101 = v107;
  uint64_t v102 = *v104;
  if (os_log_type_enabled(*v104, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v103 = &__dst;
    if (__dst.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
      uint64_t v103 = *(CSIPhoneNumber **)&__dst.var0;
    }
    *(_DWORD *)CSIPhoneNumber buf = 136315394;
    *(void *)&uint8_t buf[4] = v103;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v101;
    _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "#I Matched the number in the disambiguation list! (Number, Category): '%s', '%u'", buf, 0x12u);
  }
  CSIPhoneNumber::setEmergencyCategory((CSIPhoneNumber *)v105[3], v101);
  CSIPhoneNumber::setTypeOfNumber();
  CSIPhoneNumber::setMatchedEmMetricListType();
  if (SHIBYTE(__dst.var2.var0) < 0) {
    operator delete(*((void **)&__dst.var2.__r_.__value_.var0.var1 + 2));
  }
  if (__dst.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
    operator delete(*(void **)&__dst.var0);
  }
  *(void *)&__dst.var0 = v119;
  sub_100702E5C((void ***)&__dst);
  return 1;
}

void sub_1009208EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (*(char *)(v28 - 153) < 0) {
    operator delete(*(void **)(v28 - 176));
  }
  sub_100087E24((uint64_t)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_100920A58(uint64_t a1)
{
  return sub_10091FA9C(*(unsigned int ***)(a1 + 40));
}

void sub_100920A60(uint64_t *a1)
{
  unsigned int v3 = (char ***)*a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = (char **)(*a1 + 8);
  sub_100703778(*a1, *v4);
  signed int v5 = 0;
  NSObject *v3 = v4;
  v3[2] = 0;
  *uint64_t v4 = 0;
  do
  {
    uint64_t v20 = 0;
    int v21 = 0;
    uint64_t v22 = 0;
    sub_10091C610(v2, *(_DWORD *)a1[2], v5, &v20);
    long long v6 = v20;
    uint64_t v7 = v21;
    if (v21 != v20)
    {
      uint64_t v8 = *a1;
      uint64_t v10 = (uint64_t **)(*a1 + 8);
      uint64_t v9 = *v10;
      if (*v10)
      {
        do
        {
          while (1)
          {
            int v11 = (uint64_t **)v9;
            signed int v12 = *((_DWORD *)v9 + 8);
            if (v12 <= v5) {
              break;
            }
            uint64_t v9 = *v11;
            uint64_t v10 = v11;
            if (!*v11) {
              goto LABEL_12;
            }
          }
          if (v12 >= v5)
          {
            char v15 = v11;
            goto LABEL_15;
          }
          uint64_t v9 = v11[1];
        }
        while (v9);
        uint64_t v10 = v11 + 1;
      }
      else
      {
        int v11 = (uint64_t **)(*a1 + 8);
      }
LABEL_12:
      char v15 = operator new(0x40uLL);
      v15[8] = v5;
      *((void *)v15 + 6) = 0;
      *((void *)v15 + 7) = 0;
      *((void *)v15 + 5) = 0;
      *(void *)char v15 = 0;
      *((void *)v15 + 1) = 0;
      *((void *)v15 + 2) = v11;
      _OWORD *v10 = (uint64_t *)v15;
      uint64_t v13 = **(void **)v8;
      long long v14 = (uint64_t *)v15;
      if (v13)
      {
        *(void *)uint64_t v8 = v13;
        long long v14 = *v10;
      }
      sub_100046C90(*(uint64_t **)(v8 + 8), v14);
      ++*(void *)(v8 + 16);
      long long v6 = v20;
      uint64_t v7 = v21;
LABEL_15:
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 0x40000000;
      long long v17 = sub_100920C50;
      int v18 = &unk_101A1C2D8;
      long long v19 = (char *)(v15 + 10);
      while (v6 != v7)
      {
        v17((uint64_t)v16, v6);
        long long v6 = (CSIPhoneNumber *)((char *)v6 + 136);
      }
    }
    char v23 = &v20;
    sub_100702C2C((void ***)&v23);
    ++v5;
  }
  while (v5 != 13);
}

void sub_100920C30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void **a18)
{
  a18 = (void **)&a15;
  sub_100702C2C(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_100920C50(uint64_t a1, CSIPhoneNumber *a2)
{
  uint64_t v38 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)uint64_t v26 = 0u;
  memset(v25, 0, sizeof(v25));
  sub_10004DE24((uint64_t)v25);
  CSIPhoneNumber::getFullOriginalNumber((uint64_t *)&v39, a2);
  if (SHIBYTE(v41) >= 0) {
    uint64_t v4 = (void **)&v39;
  }
  else {
    uint64_t v4 = v39;
  }
  if (SHIBYTE(v41) >= 0) {
    uint64_t v5 = HIBYTE(v41);
  }
  else {
    uint64_t v5 = v40;
  }
  long long v6 = sub_10004B96C(v25, (uint64_t)v4, v5);
  LOBYTE(__p[0]) = 44;
  sub_10004B96C(v6, (uint64_t)__p, 1);
  CSIPhoneNumber::getEmergencyCategory(a2);
  uint64_t v7 = (void *)std::ostream::operator<<();
  LOBYTE(__p[0]) = 44;
  sub_10004B96C(v7, (uint64_t)__p, 1);
  CSIPhoneNumber::getIsEmSMSTextSupported(a2);
  uint64_t v8 = (void *)std::ostream::operator<<();
  LOBYTE(__p[0]) = 44;
  sub_10004B96C(v8, (uint64_t)__p, 1);
  CSIPhoneNumber::getIsEmVoiceSupported(a2);
  std::ostream::operator<<();
  if (SHIBYTE(v41) < 0) {
    operator delete(v39);
  }
  uint64_t v9 = *(uint64_t **)(a1 + 32);
  sub_10004BC98((uint64_t)v25 + 8, __p);
  unint64_t v10 = v9[2];
  unint64_t v11 = v9[1];
  if (v11 >= v10)
  {
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *v9) >> 3);
    unint64_t v14 = v13 + 1;
    if (v13 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D8578();
    }
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *v9) >> 3);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x555555555555555) {
      unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v16 = v14;
    }
    uint64_t v43 = v9 + 2;
    if (v16) {
      long long v17 = (void **)sub_10004812C((uint64_t)(v9 + 2), v16);
    }
    else {
      long long v17 = 0;
    }
    int v18 = (char *)&v17[3 * v13];
    long long v39 = v17;
    uint64_t v40 = (uint64_t)v18;
    uint64_t v42 = (char *)&v17[3 * v16];
    long long v19 = *(_OWORD *)__p;
    *((void *)v18 + 2) = v24;
    *(_OWORD *)int v18 = v19;
    __p[1] = 0;
    uint64_t v24 = 0;
    __p[0] = 0;
    long long v41 = v18 + 24;
    sub_100048204(v9, &v39);
    uint64_t v20 = v9[1];
    sub_100048174((uint64_t)&v39);
    int v21 = SHIBYTE(v24);
    v9[1] = v20;
    if (v21 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v12 = *(_OWORD *)__p;
    *(void *)(v11 + 16) = v24;
    *(_OWORD *)unint64_t v11 = v12;
    v9[1] = v11 + 24;
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100920F78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_100048174(v16 - 72);
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000C937C((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_100920FCC(uint64_t a1)
{
}

void sub_100920FD4(uint64_t a1@<X0>, CSIPhoneNumber *a2@<X8>)
{
  unsigned int v3 = *(uint64_t **)(a1 + 40);
  uint64_t v4 = *v3;
  uint64_t v5 = v3 + 1;
  int isValidSimSlot = subscriber::isValidSimSlot();
  uint64_t v7 = (uint64_t *)(v4 + 256);
  if (isValidSimSlot) {
    uint64_t v7 = v5;
  }
  uint64_t v8 = *(unsigned int *)v7;

  sub_10091C800(a2, v4, v8);
}

void sub_100921038(void ***a1)
{
  uint64_t v1 = **a1;
  subscriber::makeSimSlotRange();
  uint64_t v2 = v4;
  if (v4 != v5)
  {
    do
    {
      if (v6(*v2)) {
        goto LABEL_5;
      }
      ++v2;
    }
    while (v2 != v5);
    uint64_t v2 = v5;
LABEL_5:
    while (v2 != v5)
    {
      sub_10091DAAC((uint64_t)v1, *v2);
      unsigned int v3 = v2 + 1;
      uint64_t v2 = v5;
      if (v3 != v5)
      {
        uint64_t v2 = v3;
        do
        {
          if (v6(*v2)) {
            goto LABEL_5;
          }
          ++v2;
        }
        while (v2 != v5);
        uint64_t v2 = v5;
      }
    }
  }
  sub_10091B394(v1);
  operator delete();
}

void sub_10092112C()
{
}

void sub_100921164(std::string *a1, CSIPhoneNumber *this)
{
  CSIPhoneNumber::getFullNumber((uint64_t *)&v22, this);
  uint64_t v4 = std::string::insert(&v22, 0, "[", 1uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  long long v6 = std::string::append(&v23, ",", 1uLL);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  unsigned int EmergencyCategory = CSIPhoneNumber::getEmergencyCategory(this);
  std::to_string(&__p, EmergencyCategory);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  unint64_t v11 = std::string::append(&v24, (const std::string::value_type *)p_p, size);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  unint64_t v13 = std::string::append(&v25, ",", 1uLL);
  long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  int IsEmSMSTextSupported = CSIPhoneNumber::getIsEmSMSTextSupported(this);
  if (IsEmSMSTextSupported) {
    uint64_t v16 = "true";
  }
  else {
    uint64_t v16 = "false";
  }
  if (IsEmSMSTextSupported) {
    std::string::size_type v17 = 4;
  }
  else {
    std::string::size_type v17 = 5;
  }
  int v18 = std::string::append(&v26, v16, v17);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v27.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  uint64_t v20 = std::string::append(&v27, "]", 1uLL);
  *a1 = *v20;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
}

void sub_10092135C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (*(char *)(v40 - 41) < 0) {
    operator delete(*(void **)(v40 - 64));
  }
  if (*(char *)(v40 - 73) < 0) {
    operator delete(*(void **)(v40 - 96));
  }
  if (a40 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100921408(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    unsigned int v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100921488(void **a1)
{
  uint64_t v1 = *a1;
  signed int v52 = a1;
  uint64_t v53 = v1;
  uint64_t v50 = v1;
  uint64_t v2 = *v1;
  long long v62 = 0;
  uint64_t v63 = 0;
  uint64_t v51 = (void *)v2;
  uint64_t v61 = (uint64_t *)&v62;
  unsigned int v3 = (Registry **)(v2 + 160);
  subscriber::makeSimSlotRange();
  long long v5 = (char *)v58;
  uint64_t v4 = v59;
  if (v58 != (char **)v59)
  {
    long long v6 = v60;
    while ((v60(*(unsigned int *)v5) & 1) == 0)
    {
      v5 += 4;
      if (v5 == v59)
      {
        long long v5 = v59;
        break;
      }
    }
    uint64_t v8 = v59;
    if (v5 != v59)
    {
      while (1)
      {
        int v57 = 0;
        uint64_t v9 = *(unsigned int *)v5;
        int v57 = *(_DWORD *)v5;
        ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *v3);
        unint64_t v11 = ServiceMap;
        if (v12 < 0)
        {
          unint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v14 = 5381;
          do
          {
            uint64_t v12 = v14;
            unsigned int v15 = *v13++;
            uint64_t v14 = (33 * v14) ^ v15;
          }
          while (v15);
        }
        std::mutex::lock(ServiceMap);
        std::string __p = (void *)v12;
        uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&__p);
        if (!v16) {
          break;
        }
        uint64_t v18 = v16[3];
        std::string::size_type v17 = (std::__shared_weak_count *)v16[4];
        if (!v17) {
          goto LABEL_14;
        }
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
LABEL_15:
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 8))(&__p, v18, v9);
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        BOOL v20 = __p && !*((unsigned char *)__p + 49) && *((unsigned __int8 *)__p + 48) != 0;
        if (v55) {
          sub_10004D2C8(v55);
        }
        if (v20) {
          sub_10078C71C(&v61, &v57, &v57);
        }
        long long v7 = (uint64_t *)(v5 + 4);
        long long v5 = v4;
        if (v7 != (uint64_t *)v4)
        {
          long long v5 = (char *)v7;
          while ((v6(*(unsigned int *)v5) & 1) == 0)
          {
            v5 += 4;
            if (v5 == v4)
            {
              long long v5 = v4;
              break;
            }
          }
        }
        if (v5 == v8) {
          goto LABEL_31;
        }
      }
      uint64_t v18 = 0;
LABEL_14:
      std::mutex::unlock(v11);
      std::string::size_type v17 = 0;
      char v19 = 1;
      goto LABEL_15;
    }
  }
LABEL_31:
  long long v59 = 0;
  long long v60 = 0;
  int v58 = &v59;
  int v21 = (void *)v51[10];
  if (v21 != v51 + 11)
  {
    do
    {
      if (!v63) {
        goto LABEL_49;
      }
      std::string v22 = v62;
      if (v62)
      {
        int v23 = *((_DWORD *)v21 + 8);
        std::string v24 = &v62;
        do
        {
          std::string v25 = v22;
          std::string v26 = v24;
          int v27 = *((_DWORD *)v22 + 7);
          long long v28 = v22 + 1;
          if (v27 >= v23)
          {
            long long v28 = v25;
            std::string v24 = (void **)v25;
          }
          std::string v22 = (void *)*v28;
        }
        while (v22);
        if (v24 != &v62)
        {
          if (v27 < v23) {
            std::string v25 = v26;
          }
          if (v23 >= *((_DWORD *)v25 + 7))
          {
LABEL_49:
            long long v32 = (CSIPhoneNumber **)v21[5];
            long long v33 = (CSIPhoneNumber **)v21[6];
            while (v32 != v33)
            {
              long long v34 = *v32;
              long long v35 = v32[1];
              while (v34 != v35)
              {
                CSIPhoneNumber::getFullNumber((uint64_t *)&__p, v34);
                sub_1000EA6A0((uint64_t **)&v58, &__p, (uint64_t)&__p);
                if (v56 < 0) {
                  operator delete(__p);
                }
                long long v34 = (CSIPhoneNumber *)((char *)v34 + 136);
              }
              v32 += 3;
            }
          }
        }
      }
      long long v29 = (void *)v21[1];
      if (v29)
      {
        do
        {
          long long v30 = v29;
          long long v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          long long v30 = (void *)v21[2];
          BOOL v31 = *v30 == (void)v21;
          int v21 = v30;
        }
        while (!v31);
      }
      int v21 = v30;
    }
    while (v30 != v51 + 11);
  }
  long long v36 = (void *)v51[37];
  if (v36 != v51 + 38)
  {
    do
    {
      if (!v63) {
        goto LABEL_75;
      }
      long long v37 = v62;
      if (v62)
      {
        int v38 = *((_DWORD *)v36 + 8);
        long long v39 = &v62;
        do
        {
          uint64_t v40 = v37;
          long long v41 = v39;
          int v42 = *((_DWORD *)v37 + 7);
          uint64_t v43 = v37 + 1;
          if (v42 >= v38)
          {
            uint64_t v43 = v40;
            long long v39 = (void **)v40;
          }
          long long v37 = (void *)*v43;
        }
        while (v37);
        if (v39 != &v62)
        {
          if (v42 < v38) {
            uint64_t v40 = v41;
          }
          if (v38 >= *((_DWORD *)v40 + 7))
          {
LABEL_75:
            long long v46 = (void **)v36[5];
            long long v47 = (void **)v36[6];
            while (v46 != v47)
            {
              sub_100046BAC((uint64_t **)&v58, v46, (uint64_t)v46);
              v46 += 7;
            }
          }
        }
      }
      unsigned int v44 = (void *)v36[1];
      if (v44)
      {
        do
        {
          unint64_t v45 = v44;
          unsigned int v44 = (void *)*v44;
        }
        while (v44);
      }
      else
      {
        do
        {
          unint64_t v45 = (void *)v36[2];
          BOOL v31 = *v45 == (void)v36;
          long long v36 = v45;
        }
        while (!v31);
      }
      long long v36 = v45;
    }
    while (v45 != v51 + 38);
  }
  uint64_t v48 = v50[4];
  if (!v48) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, char ***))(*(void *)v48 + 48))(v48, &v58);
  sub_10005CD2C((uint64_t)&v58, v59);
  sub_1000346F8((uint64_t)&v61, v62);
  sub_10092196C((uint64_t *)&v53);
  return sub_100046B58((uint64_t *)&v52);
}

void sub_1009218EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,char a25,void *a26)
{
}

uint64_t *sub_10092196C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1005B1BA4((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

const char *sub_1009219BC(unsigned int a1)
{
  if (a1 > 0xA) {
    return "???";
  }
  else {
    return off_101A1C338[a1];
  }
}

const char *sub_1009219E0(unsigned int a1)
{
  if (a1 > 0xD) {
    return "???";
  }
  else {
    return off_101A1C390[a1];
  }
}

void sub_100921A04()
{
}

void sub_100921A5C()
{
}

void *sub_100921A80(void *a1)
{
  uint64_t v2 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "cp.ids.sub");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v5, &v4);
  ctu::OsLogLogger::OsLogLogger(v2, (const ctu::OsLogLogger *)v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  *a1 = &off_101A1C410;
  return a1;
}

void sub_100921B2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  CellularPlanIDSSubscriptionSelectorInterface::~CellularPlanIDSSubscriptionSelectorInterface(v2);
  _Unwind_Resume(a1);
}

void sub_100921B60(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 8) = 0;
  uint64_t v4 = (std::string *)(a2 + 8);
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = a2 + 8;
  id v24 = 0;
  uint64_t v18 = objc_opt_new();
  long long v5 = [v18 selectedSubscriptionsWithError:&v24];
  id v19 = v24;
  if (v5)
  {
    uint64_t v17 = a1;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    id v6 = v5;
    id v7 = [v6 countByEnumeratingWithState:&v20 objects:v28 count:16];
    if (v7)
    {
      uint64_t v8 = *(void *)v21;
      do
      {
        for (unsigned int i = 0; i != v7; unsigned int i = (char *)i + 1)
        {
          if (*(void *)v21 != v8) {
            objc_enumerationMutation(v6);
          }
          unint64_t v10 = *(void **)(*((void *)&v20 + 1) + 8 * i);
          if (v10)
          {
            unint64_t v11 = [*(id *)(*((void *)&v20 + 1) + 8 * i) labelID];
            BOOL v12 = [v11 length] == 0;

            if (!v12)
            {
              id v13 = [v10 labelID];
              __p.__r_.__value_.__r.__words[0] = (std::string::size_type)[v13 UTF8String];
              sub_100495908((uint64_t **)a2, &__p.__r_.__value_.__l.__data_);
            }
          }
        }
        id v7 = [v6 countByEnumeratingWithState:&v20 objects:v28 count:16];
      }
      while (v7);
    }

    uint64_t v14 = *(NSObject **)(v17 + 8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      sub_1000E8F34(*(std::string **)a2, v4, ",", 1uLL, &__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      int v27 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I current iMessage selection uuids: %s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  else
  {
    uint64_t v16 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__p.__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Something went wrong! %@", (uint8_t *)&__p, 0xCu);
    }
  }
}

void sub_100921DF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  sub_10005CD2C(v12, *(char **)(v12 + 8));
  _Unwind_Resume(a1);
}

void sub_100921E64(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000E8F34(*(std::string **)a2, (std::string *)(a2 + 8), ",", 1uLL, &__p);
    long long v5 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
       ? &__p
       : (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)CSIPhoneNumber buf = 136315138;
    long long v23 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I setting iMessage selection for uuids: %s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  id v6 = +[NSMutableArray array];
  unint64_t v10 = *(std::string **)a2;
  uint64_t v8 = (std::string *)(a2 + 8);
  uint64_t v9 = v10;
  if (v10 != v8)
  {
    *(void *)&long long v7 = 136315138;
    long long v20 = v7;
    do
    {
      p_std::string::size_type size = &v9[1].__r_.__value_.__l.__size_;
      uint64_t v12 = &v9[1].__r_.__value_.__l.__size_;
      if (v9[2].__r_.__value_.__s.__data_[7] < 0) {
        uint64_t v12 = (std::string::size_type *)*p_size;
      }
      id v13 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12, v20);
      uint64_t v14 = +[IDSPhoneSubscription phoneSubscriptionWithLabelID:v13];

      if (v14)
      {
        [v6 addObject:v14];
      }
      else
      {
        unsigned int v15 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          if (v9[2].__r_.__value_.__s.__data_[7] < 0) {
            p_std::string::size_type size = (std::string::size_type *)*p_size;
          }
          LODWORD(__p.__r_.__value_.__l.__data_) = v20;
          *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_size;
          _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "failed to instantiate IDSPhoneSubscription for uuid: %s", (uint8_t *)&__p, 0xCu);
        }
      }

      std::string::size_type size = (std::string *)v9->__r_.__value_.__l.__size_;
      if (size)
      {
        do
        {
          uint64_t v17 = size;
          std::string::size_type size = (std::string *)size->__r_.__value_.__r.__words[0];
        }
        while (size);
      }
      else
      {
        do
        {
          uint64_t v17 = (std::string *)v9->__r_.__value_.__r.__words[2];
          BOOL v18 = v17->__r_.__value_.__r.__words[0] == (void)v9;
          uint64_t v9 = v17;
        }
        while (!v18);
      }
      uint64_t v9 = v17;
    }
    while (v17 != v8);
  }
  id v19 = objc_opt_new();
  [v19 setSelectedSubscriptions:v6 withCompletion:&stru_101A1C450];
}

void sub_1009220AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1009220EC(id a1, NSArray *a2, NSError *a3)
{
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    long long v5 = a3;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "setSelectedSubscriptions completion, error: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_10092218C(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  CellularPlanIDSSubscriptionSelectorInterface::~CellularPlanIDSSubscriptionSelectorInterface((CellularPlanIDSSubscriptionSelectorInterface *)a1);
}

void sub_1009221C8(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  CellularPlanIDSSubscriptionSelectorInterface::~CellularPlanIDSSubscriptionSelectorInterface((CellularPlanIDSSubscriptionSelectorInterface *)a1);

  operator delete();
}

void sub_100922218(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100922280(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009222BC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009222F4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100922324(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100922368(int a1)
{
  xpc_object_t object = 0;
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t object = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t object = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  xpc_object_t object = v4;
LABEL_9:
  xpc_release(v3);
  long long v6 = 0uLL;
  uint64_t v8 = off_101A1C5A0;
  int v9 = a1;
  unint64_t v10 = &v8;
  __p[0] = 0;
  __p[1] = 0;
  operator new();
}

void sub_100922588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10092262C(Registry **a1, unsigned __int8 *a2, uint64_t a3)
{
  void (***v183)(void **__return_ptr, void, CSIPhoneNumber *);
  std::mutex *v184;
  std::mutex *v185;
  uint64_t v186;
  unsigned __int8 *v187;
  uint64_t v188;
  unsigned int v189;
  void *v190;
  std::__shared_weak_count *v191;
  uint64_t v192;
  char v193;
  const char *v194;
  char *v195;
  NSObject *v196;
  uint32_t v197;
  const char *v198;
  const char *v199;
  uint64_t v200;
  std::mutex *v203;
  std::mutex *v204;
  uint64_t v205;
  unsigned __int8 *v206;
  uint64_t v207;
  unsigned int v208;
  void *v209;
  std::__shared_weak_count *v210;
  uint64_t v211;
  char v212;
  const char *v213;
  char *v214;
  unsigned __int8 *v215;
  int v218;
  int v219;
  void *v221;
  void *v222;
  void *v223;
  const char *v224;
  const char *v225;
  void *v226;
  __CFString *v227;
  char *v228;
  __CFString *v229;
  const char *v230;
  const char *v231;
  const char *v232;
  unsigned int v233;
  unsigned int v234;
  __int16 v235;
  __CFString *v236;
  std::__shared_weak_count *v237;
  char v238;
  void *v239;
  std::__shared_weak_count *v240;
  uint64_t v241;
  __CFString *v242;
  std::__shared_weak_count *v243;
  void *v244;
  char v245;
  void *__p;
  char v247;
  CFTypeRef cf[2];
  int64_t v249;
  long long v250;
  int64_t v251;
  long long v252;
  int64_t size;
  BOOL *v254;
  CSIPhoneNumber buf[2];
  char __dst[1024];

  bzero(__dst, 0x400uLL);
  pthread_mutex_lock(&stru_101B0AC18);
  v254 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  long long v7 = ServiceMap;
  uint64_t v9 = v8;
  if (v8 < 0)
  {
    unint64_t v10 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&buf[0].var0 = v9;
  id v13 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v14 = 0;
  char v16 = 1;
LABEL_9:
  (*(void (**)(BOOL **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v15 + 96))(&v254, v15, a3, 1, @"AllowAKEYEditing", kCFBooleanTrue, 0);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  uint64_t v17 = v254;
  LOBYTE(buf[0].var0) = 1;
  if (v254)
  {
    CFTypeID v18 = CFGetTypeID(v254);
    if (v18 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, v17, v19);
    }
    if (!LOBYTE(buf[0].var0)) {
      goto LABEL_19;
    }
  }
  if (*(_DWORD *)a2 != 892478243 || *(_DWORD *)(a2 + 3) != 3748661)
  {
LABEL_19:
    v252 = 0uLL;
    std::string::size_type size = 0;
    long long v21 = (std::mutex *)Registry::getServiceMap(*a1);
    long long v22 = v21;
    uint64_t v23 = v8;
    if (v8 < 0)
    {
      id v24 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        uint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(v21);
    *(void *)&buf[0].var0 = v23;
    int v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)buf);
    if (v27)
    {
      uint64_t v29 = v27[3];
      long long v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    long long v28 = 0;
    char v30 = 1;
LABEL_36:
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v29 + 96))(&v250, v29, a3, 1, @"KeypadProvisioningNumber", 0, 0);
    memset(buf, 0, 24);
    ctu::cf::assign();
    v252 = *(_OWORD *)&buf[0].var0;
    std::string::size_type size = buf[0].var2.__r_.__value_.var0.var1.__size_;
    sub_1000577C4((const void **)&v250);
    if ((v30 & 1) == 0) {
      sub_10004D2C8(v28);
    }
    sub_100058DB0(buf, (char *)a2);
    if (size >= 0) {
      uint64_t v43 = (char *)HIBYTE(size);
    }
    else {
      uint64_t v43 = (char *)*((void *)&v252 + 1);
    }
    std::string::size_type data = (char *)buf[0].var2.__r_.__value_.var0.var0.__data_[15];
    int v45 = buf[0].var2.__r_.__value_.var0.var0.__data_[15];
    if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
      std::string::size_type data = buf[0].var2.__r_.__value_.var0.var1.__data_;
    }
    if (v43 == data)
    {
      if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
        long long v46 = buf;
      }
      else {
        long long v46 = *(CSIPhoneNumber **)&buf[0].var0;
      }
      if (size < 0)
      {
        BOOL v55 = memcmp((const void *)v252, v46, *((size_t *)&v252 + 1)) == 0;
        if ((v45 & 0x80000000) == 0) {
          goto LABEL_56;
        }
      }
      else if (HIBYTE(size))
      {
        uint64_t v47 = HIBYTE(size) - 1;
        uint64_t v48 = (unsigned __int8 *)&v252;
        do
        {
          int v50 = *v48++;
          int v49 = v50;
          int var0_low = LOBYTE(v46->var0);
          long long v46 = (CSIPhoneNumber *)((char *)v46 + 1);
          int v51 = var0_low;
          BOOL v53 = v47-- != 0;
          char v54 = v53;
          BOOL v55 = v49 == v51;
        }
        while (v49 == v51 && (v54 & 1) != 0);
        if ((buf[0].var2.__r_.__value_.var0.var0.__data_[15] & 0x80000000) == 0)
        {
LABEL_56:
          if (v55) {
            goto LABEL_57;
          }
          goto LABEL_68;
        }
      }
      else
      {
        BOOL v55 = 1;
        if ((buf[0].var2.__r_.__value_.var0.var0.__data_[15] & 0x80000000) == 0) {
          goto LABEL_56;
        }
      }
    }
    else
    {
      BOOL v55 = 0;
      if ((buf[0].var2.__r_.__value_.var0.var0.__data_[15] & 0x80000000) == 0) {
        goto LABEL_56;
      }
    }
    operator delete(*(void **)&buf[0].var0);
    if (v55)
    {
LABEL_57:
      LogGroupName = (const char *)sGetLogGroupName();
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, LogGroupName);
      int v57 = buf[0].var2.__r_.__value_.var0.var1.__data_;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled((os_log_t)v57, OS_LOG_TYPE_INFO))
      {
        LOWORD(buf[0].var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)v57, OS_LOG_TYPE_INFO, "User wants to change their MDN/MIN", (uint8_t *)buf, 2u);
      }
      int v58 = (std::mutex *)Registry::getServiceMap(*a1);
      long long v59 = v58;
      if (v60 < 0)
      {
        uint64_t v61 = (unsigned __int8 *)(v60 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v62 = 5381;
        do
        {
          uint64_t v60 = v62;
          unsigned int v63 = *v61++;
          uint64_t v62 = (33 * v62) ^ v63;
        }
        while (v63);
      }
      std::mutex::lock(v58);
      *(void *)&buf[0].var0 = v60;
      char v64 = sub_10004D37C(&v59[1].__m_.__sig, (unint64_t *)buf);
      if (v64)
      {
        uint64_t v66 = v64[3];
        uint64_t v65 = (std::__shared_weak_count *)v64[4];
        if (v65)
        {
          atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v59);
          atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v65);
          char v67 = 0;
          if (!v66) {
            goto LABEL_89;
          }
          goto LABEL_88;
        }
      }
      else
      {
        uint64_t v66 = 0;
      }
      std::mutex::unlock(v59);
      uint64_t v65 = 0;
      char v67 = 1;
      if (!v66)
      {
LABEL_89:
        if ((v67 & 1) == 0) {
          sub_10004D2C8(v65);
        }
        pthread_mutex_unlock(&stru_101B0AC18);
        uint64_t v88 = 1;
        goto LABEL_306;
      }
LABEL_88:
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v66 + 344))(v66, 0, 1);
      goto LABEL_89;
    }
LABEL_68:
    v250 = 0uLL;
    v251 = 0;
    uint64_t v68 = (std::mutex *)Registry::getServiceMap(*a1);
    int v69 = v68;
    uint64_t v70 = v8;
    if (v8 < 0)
    {
      BOOL v71 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v72 = 5381;
      do
      {
        uint64_t v70 = v72;
        unsigned int v73 = *v71++;
        uint64_t v72 = (33 * v72) ^ v73;
      }
      while (v73);
    }
    std::mutex::lock(v68);
    *(void *)&buf[0].var0 = v70;
    uint64_t v74 = sub_10004D37C(&v69[1].__m_.__sig, (unint64_t *)buf);
    if (v74)
    {
      uint64_t v76 = v74[3];
      int v75 = (std::__shared_weak_count *)v74[4];
      if (v75)
      {
        atomic_fetch_add_explicit(&v75->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v69);
        atomic_fetch_add_explicit(&v75->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v75);
        char v77 = 0;
        goto LABEL_78;
      }
    }
    else
    {
      uint64_t v76 = 0;
    }
    std::mutex::unlock(v69);
    int v75 = 0;
    char v77 = 1;
LABEL_78:
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v76 + 96))(cf, v76, a3, 1, @"OTANumber", 0, 0);
    memset(buf, 0, 24);
    ctu::cf::assign();
    v250 = *(_OWORD *)&buf[0].var0;
    v251 = buf[0].var2.__r_.__value_.var0.var1.__size_;
    sub_1000577C4(cf);
    if ((v77 & 1) == 0) {
      sub_10004D2C8(v75);
    }
    unsigned int v78 = (std::mutex *)Registry::getServiceMap(*a1);
    uint8_t v79 = v78;
    uint64_t v80 = v8;
    if (v8 < 0)
    {
      uint64_t v81 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v82 = 5381;
      do
      {
        uint64_t v80 = v82;
        unsigned int v83 = *v81++;
        uint64_t v82 = (33 * v82) ^ v83;
      }
      while (v83);
    }
    std::mutex::lock(v78);
    *(void *)&buf[0].var0 = v80;
    uint64_t v84 = sub_10004D37C(&v79[1].__m_.__sig, (unint64_t *)buf);
    if (v84)
    {
      uint64_t v86 = v84[3];
      std::string v85 = (std::__shared_weak_count *)v84[4];
      if (v85)
      {
        atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v79);
        atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v85);
        char v87 = 0;
        goto LABEL_94;
      }
    }
    else
    {
      uint64_t v86 = 0;
    }
    std::mutex::unlock(v79);
    std::string v85 = 0;
    char v87 = 1;
LABEL_94:
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v86 + 80))(cf, v86, a3, 1, @"SupportsSIMAPN", kCFBooleanFalse, 0);
    int v89 = (BOOL *)cf[0];
    LOBYTE(buf[0].var0) = 0;
    if (cf[0])
    {
      CFTypeID v90 = CFGetTypeID(cf[0]);
      if (v90 == CFBooleanGetTypeID()) {
        ctu::cf::assign((ctu::cf *)buf, v89, v91);
      }
      int v92 = LOBYTE(buf[0].var0);
    }
    else
    {
      int v92 = 0;
    }
    v234 = a3;
    sub_1000577C4(cf);
    if ((v87 & 1) == 0) {
      sub_10004D2C8(v85);
    }
    uint64_t v93 = HIBYTE(v251);
    int v94 = SHIBYTE(v251);
    size_t v95 = *((void *)&v250 + 1);
    if (v251 >= 0) {
      long long v96 = (char *)HIBYTE(v251);
    }
    else {
      long long v96 = (char *)*((void *)&v250 + 1);
    }
    if (!v96)
    {
      uint64_t v109 = (const char *)sGetLogGroupName();
      uint64_t v102 = v234;
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, v109);
      long long v110 = buf[0].var2.__r_.__value_.var0.var1.__data_;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (!os_log_type_enabled((os_log_t)v110, OS_LOG_TYPE_INFO)) {
        goto LABEL_144;
      }
      LOWORD(buf[0].var0) = 0;
      long long v111 = "serviceProvNum does not exist!";
LABEL_127:
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)v110, OS_LOG_TYPE_INFO, v111, (uint8_t *)buf, 2u);
      goto LABEL_144;
    }
    sub_100058DB0(buf, (char *)a2);
    long long v97 = (char *)buf[0].var2.__r_.__value_.var0.var0.__data_[15];
    int v98 = buf[0].var2.__r_.__value_.var0.var0.__data_[15];
    if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
      long long v97 = buf[0].var2.__r_.__value_.var0.var1.__data_;
    }
    if (v96 == v97)
    {
      if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
        uint64_t v99 = buf;
      }
      else {
        uint64_t v99 = *(CSIPhoneNumber **)&buf[0].var0;
      }
      if (v94 < 0)
      {
        BOOL v108 = memcmp((const void *)v250, v99, v95) == 0;
        uint64_t v102 = v234;
        goto LABEL_137;
      }
      if (v94)
      {
        uint64_t v100 = v93 - 1;
        unsigned int v101 = (unsigned __int8 *)&v250;
        uint64_t v102 = v234;
        do
        {
          int v104 = *v101++;
          int v103 = v104;
          int v106 = LOBYTE(v99->var0);
          uint64_t v99 = (CSIPhoneNumber *)((char *)v99 + 1);
          int v105 = v106;
          BOOL v53 = v100-- != 0;
          char v107 = v53;
          BOOL v108 = v103 == v105;
        }
        while (v103 == v105 && (v107 & 1) != 0);
LABEL_137:
        if ((v98 & 0x80000000) == 0)
        {
LABEL_138:
          if (v108)
          {
LABEL_139:
            if (v92)
            {
              uint64_t v113 = (const char *)sGetLogGroupName();
              ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, v113);
              uint64_t v114 = buf[0].var2.__r_.__value_.var0.var1.__data_;
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled((os_log_t)v114, OS_LOG_TYPE_INFO))
              {
                LOWORD(buf[0].var0) = 0;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)v114, OS_LOG_TYPE_INFO, "Device supports SIMAPN and OTANumber was dialed.", (uint8_t *)buf, 2u);
              }
              sub_100A6D61C(a1, v102);
              pthread_mutex_unlock(&stru_101B0AC18);
              uint64_t v88 = 1;
              if ((v94 & 0x80) == 0) {
                goto LABEL_306;
              }
              goto LABEL_305;
            }
LABEL_144:
            cf[0] = 0;
            cf[1] = 0;
            v249 = 0;
            uint64_t v115 = (std::mutex *)Registry::getServiceMap(*a1);
            char v116 = v115;
            if (v8 < 0)
            {
              char v117 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v118 = 5381;
              do
              {
                uint64_t v8 = v118;
                unsigned int v119 = *v117++;
                uint64_t v118 = (33 * v118) ^ v119;
              }
              while (v119);
            }
            std::mutex::lock(v115);
            *(void *)&buf[0].var0 = v8;
            char v120 = sub_10004D37C(&v116[1].__m_.__sig, (unint64_t *)buf);
            if (v120)
            {
              uint64_t v122 = v120[3];
              char v121 = (std::__shared_weak_count *)v120[4];
              if (v121)
              {
                atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v116);
                atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v121);
                char v123 = 0;
                goto LABEL_152;
              }
            }
            else
            {
              uint64_t v122 = 0;
            }
            std::mutex::unlock(v116);
            char v121 = 0;
            char v123 = 1;
LABEL_152:
            (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v122 + 96))(&v239, v122, v102, 1, @"ResetSIMProvisoning", 0, 0);
            memset(buf, 0, 24);
            ctu::cf::assign();
            *(_OWORD *)CFTypeRef cf = *(_OWORD *)&buf[0].var0;
            v249 = buf[0].var2.__r_.__value_.var0.var1.__size_;
            sub_1000577C4((const void **)&v239);
            if ((v123 & 1) == 0) {
              sub_10004D2C8(v121);
            }
            uint64_t v124 = HIBYTE(v249);
            CFTypeRef v125 = cf[1];
            if (v249 >= 0) {
              char v126 = (char *)HIBYTE(v249);
            }
            else {
              char v126 = (char *)cf[1];
            }
            if (!v126) {
              goto LABEL_175;
            }
            sub_100058DB0(buf, (char *)a2);
            char v127 = (char *)buf[0].var2.__r_.__value_.var0.var0.__data_[15];
            int v128 = buf[0].var2.__r_.__value_.var0.var0.__data_[15];
            if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
              char v127 = buf[0].var2.__r_.__value_.var0.var1.__data_;
            }
            if (v126 != v127)
            {
              BOOL v137 = 0;
              if ((buf[0].var2.__r_.__value_.var0.var0.__data_[15] & 0x80000000) == 0) {
                goto LABEL_205;
              }
              goto LABEL_174;
            }
            if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
              char v129 = buf;
            }
            else {
              char v129 = *(CSIPhoneNumber **)&buf[0].var0;
            }
            if ((v124 & 0x80) != 0)
            {
              BOOL v137 = memcmp(cf[0], v129, (size_t)v125) == 0;
            }
            else
            {
              if (!v124)
              {
                BOOL v137 = 1;
                if ((buf[0].var2.__r_.__value_.var0.var0.__data_[15] & 0x80000000) == 0)
                {
LABEL_205:
                  if (v137)
                  {
LABEL_206:
                    pthread_mutex_unlock(&stru_101B0AC18);
                    uint64_t v151 = (const char *)sGetLogGroupName();
                    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, v151);
                    long long v152 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                    if (os_log_type_enabled((os_log_t)v152, OS_LOG_TYPE_INFO))
                    {
                      LOWORD(buf[0].var0) = 0;
                      _os_log_impl((void *)&_mh_execute_header, (os_log_t)v152, OS_LOG_TYPE_INFO, "Device supports OMADM and CSIM reset was dialed - initiating CSIM reset", (uint8_t *)buf, 2u);
                    }
                    v236 = 0;
                    uint64_t v153 = (std::mutex *)Registry::getServiceMap(*a1);
                    uint64_t v154 = v153;
                    uint64_t v156 = v155;
                    if (v155 < 0)
                    {
                      xpc_object_t v157 = (unsigned __int8 *)(v155 & 0x7FFFFFFFFFFFFFFFLL);
                      uint64_t v158 = 5381;
                      do
                      {
                        uint64_t v156 = v158;
                        unsigned int v159 = *v157++;
                        uint64_t v158 = (33 * v158) ^ v159;
                      }
                      while (v159);
                    }
                    std::mutex::lock(v153);
                    *(void *)&buf[0].var0 = v156;
                    uint64_t v160 = sub_10004D37C(&v154[1].__m_.__sig, (unint64_t *)buf);
                    if (v160)
                    {
                      uint64_t v162 = v160[3];
                      char v161 = (std::__shared_weak_count *)v160[4];
                      if (v161)
                      {
                        atomic_fetch_add_explicit(&v161->__shared_owners_, 1uLL, memory_order_relaxed);
                        std::mutex::unlock(v154);
                        atomic_fetch_add_explicit(&v161->__shared_owners_, 1uLL, memory_order_relaxed);
                        sub_10004D2C8(v161);
                        char v163 = 0;
                        goto LABEL_216;
                      }
                    }
                    else
                    {
                      uint64_t v162 = 0;
                    }
                    std::mutex::unlock(v154);
                    char v161 = 0;
                    char v163 = 1;
LABEL_216:
                    uint64_t v164 = kOtaspLocalizationTable;
                    (*(void (**)(__CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v162 + 16))(&v236, v162, kOtaspLocalizationTable, @"Resetting Subscriber Settings", 1);
                    if ((v163 & 1) == 0) {
                      sub_10004D2C8(v161);
                    }
                    v242 = 0;
                    char v165 = (std::mutex *)Registry::getServiceMap(*a1);
                    char v166 = v165;
                    if (v155 < 0)
                    {
                      char v167 = (unsigned __int8 *)(v155 & 0x7FFFFFFFFFFFFFFFLL);
                      uint64_t v168 = 5381;
                      do
                      {
                        uint64_t v155 = v168;
                        unsigned int v169 = *v167++;
                        uint64_t v168 = (33 * v168) ^ v169;
                      }
                      while (v169);
                    }
                    std::mutex::lock(v165);
                    *(void *)&buf[0].var0 = v155;
                    char v170 = sub_10004D37C(&v166[1].__m_.__sig, (unint64_t *)buf);
                    if (v170)
                    {
                      uint64_t v172 = v170[3];
                      long long v171 = (std::__shared_weak_count *)v170[4];
                      if (v171)
                      {
                        atomic_fetch_add_explicit(&v171->__shared_owners_, 1uLL, memory_order_relaxed);
                        std::mutex::unlock(v166);
                        atomic_fetch_add_explicit(&v171->__shared_owners_, 1uLL, memory_order_relaxed);
                        sub_10004D2C8(v171);
                        char v173 = 0;
                        goto LABEL_226;
                      }
                    }
                    else
                    {
                      uint64_t v172 = 0;
                    }
                    std::mutex::unlock(v166);
                    long long v171 = 0;
                    char v173 = 1;
LABEL_226:
                    (*(void (**)(__CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v172 + 16))(&v242, v172, v164, @"OK", 1);
                    if ((v173 & 1) == 0) {
                      sub_10004D2C8(v171);
                    }
                    _CreateSimpleUserNotificationWithButton(0x78u, v236, &stru_101AC1B28, v242);
                    sub_100A6D454();
                    sub_100068A94(buf);
                    (*(void (**)(void, const char *, void))(**(void **)&buf[0].var0 + 144))(*(void *)&buf[0].var0, "CSIM reset", 0);
                    if (buf[0].var2.__r_.__value_.var0.var1.__data_) {
                      sub_10004D2C8((std::__shared_weak_count *)buf[0].var2.__r_.__value_.var0.var1.__data_);
                    }
                    memset(buf, 0, 24);
                    PersonalityIdFromSlotId();
                    long long v174 = (char *)buf[0].var2.__r_.__value_.var0.var0.__data_[15];
                    if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                      long long v174 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                    }
                    if (!v174) {
                      goto LABEL_264;
                    }
                    uint64_t v175 = (std::mutex *)Registry::getServiceMap(*a1);
                    uint64_t v176 = v175;
                    if (v177 < 0)
                    {
                      uint64_t v178 = (unsigned __int8 *)(v177 & 0x7FFFFFFFFFFFFFFFLL);
                      uint64_t v179 = 5381;
                      do
                      {
                        uint64_t v177 = v179;
                        unsigned int v180 = *v178++;
                        uint64_t v179 = (33 * v179) ^ v180;
                      }
                      while (v180);
                    }
                    std::mutex::lock(v175);
                    v239 = (void *)v177;
                    long long v181 = sub_10004D37C(&v176[1].__m_.__sig, (unint64_t *)&v239);
                    if (!v181)
                    {
                      std::mutex::unlock(v176);
                      goto LABEL_252;
                    }
                    v183 = (void (***)(void **__return_ptr, void, CSIPhoneNumber *))v181[3];
                    uint64_t v182 = (std::__shared_weak_count *)v181[4];
                    if (v182)
                    {
                      atomic_fetch_add_explicit(&v182->__shared_owners_, 1uLL, memory_order_relaxed);
                      std::mutex::unlock(v176);
                      atomic_fetch_add_explicit(&v182->__shared_owners_, 1uLL, memory_order_relaxed);
                      sub_10004D2C8(v182);
                      if (!v183) {
                        goto LABEL_251;
                      }
                    }
                    else
                    {
                      std::mutex::unlock(v176);
                      if (!v183) {
                        goto LABEL_252;
                      }
                    }
                    v239 = 0;
                    v240 = 0;
                    (**v183)(&v239, v183, buf);
                    if (v239)
                    {
                      (*(void (**)(void *, const char *))(*(void *)v239 + 552))(v239, "CSIM reset via _HandleManufacturerMMI");
                      (*(void (**)(void *, uint64_t))(*(void *)v239 + 376))(v239, 1);
                    }
                    if (v240) {
                      sub_10004D2C8(v240);
                    }
                    if (!v182)
                    {
LABEL_252:
                      uint64_t v184 = (std::mutex *)Registry::getServiceMap(*a1);
                      v185 = v184;
                      if (v186 < 0)
                      {
                        v187 = (unsigned __int8 *)(v186 & 0x7FFFFFFFFFFFFFFFLL);
                        v188 = 5381;
                        do
                        {
                          v186 = v188;
                          v189 = *v187++;
                          v188 = (33 * v188) ^ v189;
                        }
                        while (v189);
                      }
                      std::mutex::lock(v184);
                      v239 = (void *)v186;
                      v190 = sub_10004D37C(&v185[1].__m_.__sig, (unint64_t *)&v239);
                      if (v190)
                      {
                        v192 = v190[3];
                        v191 = (std::__shared_weak_count *)v190[4];
                        if (v191)
                        {
                          atomic_fetch_add_explicit(&v191->__shared_owners_, 1uLL, memory_order_relaxed);
                          std::mutex::unlock(v185);
                          atomic_fetch_add_explicit(&v191->__shared_owners_, 1uLL, memory_order_relaxed);
                          sub_10004D2C8(v191);
                          v193 = 0;
LABEL_260:
                          if (v192) {
                            (*(void (**)(uint64_t, CSIPhoneNumber *, uint64_t))(*(void *)v192 + 32))(v192, buf, 1);
                          }
                          if ((v193 & 1) == 0) {
                            sub_10004D2C8(v191);
                          }
LABEL_264:
                          if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                            operator delete(*(void **)&buf[0].var0);
                          }
                          sub_1000558F4((const void **)&v242);
                          sub_1000558F4((const void **)&v236);
                          goto LABEL_267;
                        }
                      }
                      else
                      {
                        v192 = 0;
                      }
                      std::mutex::unlock(v185);
                      v191 = 0;
                      v193 = 1;
                      goto LABEL_260;
                    }
LABEL_251:
                    sub_10004D2C8(v182);
                    goto LABEL_252;
                  }
LABEL_175:
                  char v138 = (const char *)sGetLogGroupName();
                  uint64_t v139 = (const char *)kCtLoggingSystemName;
                  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, v138);
                  char v140 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                  if (os_log_type_enabled((os_log_t)v140, OS_LOG_TYPE_INFO))
                  {
                    LOWORD(buf[0].var0) = 0;
                    _os_log_impl((void *)&_mh_execute_header, (os_log_t)v140, OS_LOG_TYPE_INFO, "ResetSIMProvisoning number does not exist!", (uint8_t *)buf, 2u);
                  }
                  uint64_t v141 = &qword_101B13000;
                  if (dword_101B13E54)
                  {
                    sub_10007FC70();
                    dword_101B13E54 = 0;
                  }
                  int v142 = *a2;
                  if (v142 != 35)
                  {
                    if (v142 != 42) {
                      goto LABEL_300;
                    }
                    int v143 = a2[1];
                    if (v143 == 42) {
                      unsigned int v144 = 3;
                    }
                    else {
                      unsigned int v144 = 2 * (v143 == 35);
                    }
LABEL_293:
                    if (v144 < 2) {
                      v200 = 1;
                    }
                    else {
                      v200 = 2;
                    }
                    if (*(_DWORD *)&a2[v200] != 892350517 || a2[v200 + 4] != 42) {
                      goto LABEL_300;
                    }
                    v233 = v144;
                    v203 = (std::mutex *)Registry::getServiceMap(*a1);
                    v204 = v203;
                    if (v205 < 0)
                    {
                      v206 = (unsigned __int8 *)(v205 & 0x7FFFFFFFFFFFFFFFLL);
                      v207 = 5381;
                      do
                      {
                        v205 = v207;
                        v208 = *v206++;
                        v207 = (33 * v207) ^ v208;
                      }
                      while (v208);
                    }
                    std::mutex::lock(v203);
                    *(void *)&buf[0].var0 = v205;
                    v209 = sub_10004D37C(&v204[1].__m_.__sig, (unint64_t *)buf);
                    if (v209)
                    {
                      v211 = v209[3];
                      v210 = (std::__shared_weak_count *)v209[4];
                      if (v210)
                      {
                        atomic_fetch_add_explicit(&v210->__shared_owners_, 1uLL, memory_order_relaxed);
                        std::mutex::unlock(v204);
                        atomic_fetch_add_explicit(&v210->__shared_owners_, 1uLL, memory_order_relaxed);
                        uint64_t v141 = &qword_101B13000;
                        sub_10004D2C8(v210);
                        v212 = 0;
                        goto LABEL_317;
                      }
                    }
                    else
                    {
                      v211 = 0;
                    }
                    std::mutex::unlock(v204);
                    v210 = 0;
                    v212 = 1;
LABEL_317:
                    if ((*(unsigned int (**)(uint64_t))(*(void *)v211 + 32))(v211))
                    {
                      v213 = (const char *)sGetLogGroupName();
                      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v139, v213);
                      v214 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                      if (os_log_type_enabled((os_log_t)v214, OS_LOG_TYPE_ERROR))
                      {
                        LOWORD(buf[0].var0) = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v214, OS_LOG_TYPE_ERROR, "Display is locked, not allowing a Manufacturer MMI code to be dialed at this time", (uint8_t *)buf, 2u);
                      }
                      pthread_mutex_unlock(&stru_101B0AC18);
                      if ((v212 & 1) == 0) {
                        sub_10004D2C8(v210);
                      }
                      goto LABEL_301;
                    }
                    if ((v212 & 1) == 0) {
                      sub_10004D2C8(v210);
                    }
                    v215 = &a2[v200 + 5];
                    if (*(_DWORD *)v215 == 942815287 && *(_DWORD *)(v215 + 3) == 2306872)
                    {
                      sub_10007FB40();
                      sub_100068A94(&v239);
                      v221 = v239;
                      sub_100058DB0(&__p, "User requested state dump");
                      RequestDumpStatePayload::RequestDumpStatePayload();
                      (*(void (**)(void *, CSIPhoneNumber *))(*(void *)v221 + 184))(v221, buf);
                      if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                        operator delete(*(void **)&buf[0].var0);
                      }
                      if (v247 < 0) {
                        operator delete(__p);
                      }
                      if (v240) {
                        sub_10004D2C8(v240);
                      }
                      *((_DWORD *)v141 + 917) |= 2u;
                      strlcpy(__dst, "Please add a description for this capture:", 0x400uLL);
                      sub_100058DB0(buf, __dst);
                      sub_10007FFB4(1, 1, (uint64_t)buf, v234);
                      if ((buf[0].var2.__r_.__value_.var0.var0.__data_[15] & 0x80000000) == 0) {
                        goto LABEL_398;
                      }
                      v222 = *(void **)&buf[0].var0;
LABEL_347:
                      operator delete(v222);
LABEL_398:
                      pthread_mutex_unlock(&stru_101B0AC18);
                      goto LABEL_267;
                    }
                    if (*(_DWORD *)v215 == 926300211 && *((_WORD *)v215 + 2) == 35)
                    {
                      sub_10007FB40();
                      sub_100068A94(&v239);
                      v223 = v239;
                      sub_100058DB0(&v244, "User requested state dump");
                      RequestDumpStatePayload::RequestDumpStatePayload();
                      (*(void (**)(void *, CSIPhoneNumber *))(*(void *)v223 + 184))(v223, buf);
                      if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                        operator delete(*(void **)&buf[0].var0);
                      }
                      if (v245 < 0) {
                        operator delete(v244);
                      }
                      if (v240) {
                        sub_10004D2C8(v240);
                      }
                      *((_DWORD *)v141 + 917) |= 2u;
                    }
                    else
                    {
                      if (!(*(_DWORD *)v215 ^ 0x23343732 | v215[4]))
                      {
                        if (v233 == 2)
                        {
                          sub_10007FB40();
                          sub_100922368(v234);
                        }
                        if (v233 <= 1)
                        {
                          sub_10007FB40();
                          sub_100068A94(&v239);
                          v226 = v239;
                          sub_100058DB0(buf, "CSILog");
                          (*(void (**)(void *, CSIPhoneNumber *, BOOL))(*(void *)v226 + 216))(v226, buf, v233 == 0);
                          if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                            operator delete(*(void **)&buf[0].var0);
                          }
                          if (v240) {
                            sub_10004D2C8(v240);
                          }
                          sub_100068A94(&v242);
                          v227 = v242;
                          sub_100058DB0(buf, "CSILog");
                          sub_100058DB0(&v239, "history");
                          if (v233) {
                            v228 = "-1";
                          }
                          else {
                            v228 = "512";
                          }
                          sub_100058DB0(&v236, v228);
                          (*((void (**)(__CFString *, CSIPhoneNumber *, void **, __CFString **))v227->isa + 28))(v227, buf, &v239, &v236);
                          if (v238 < 0) {
                            operator delete(v236);
                          }
                          if (SHIBYTE(v241) < 0) {
                            operator delete(v239);
                          }
                          if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                            operator delete(*(void **)&buf[0].var0);
                          }
                          if (v243) {
                            sub_10004D2C8(v243);
                          }
                          sub_100922368(v234);
                        }
                        goto LABEL_300;
                      }
                      v218 = *(_DWORD *)v215;
                      v219 = *(_DWORD *)(v215 + 3);
                      if (v218 != 909521975 || v219 != 2306870)
                      {
                        pthread_mutex_unlock(&stru_101B0AC18);
                        sub_100068A94(buf);
                        uint64_t v88 = (*(uint64_t (**)(void, void, unsigned __int8 *, void, uint64_t, int *))(**(void **)&buf[0].var0 + 336))(*(void *)&buf[0].var0, v234, a2, v233, v200 + 5, &dword_101B13E54);
                        if (buf[0].var2.__r_.__value_.var0.var1.__data_) {
                          sub_10004D2C8((std::__shared_weak_count *)buf[0].var2.__r_.__value_.var0.var1.__data_);
                        }
LABEL_302:
                        if (SHIBYTE(v249) < 0) {
                          operator delete((void *)cf[0]);
                        }
                        if ((v251 & 0x8000000000000000) == 0) {
                          goto LABEL_306;
                        }
LABEL_305:
                        operator delete((void *)v250);
LABEL_306:
                        if (SHIBYTE(size) < 0) {
                          operator delete((void *)v252);
                        }
                        goto LABEL_308;
                      }
                      if (v233 != 4)
                      {
                        if (v233 == 2)
                        {
                          sub_10007FB40();
                          v239 = 0;
                          v240 = 0;
                          v241 = 0;
                          memset(buf, 0, 32);
                          LOBYTE(v242) = 0;
                          v235 = 0;
                          __dst[0] = 0;
                          v236 = 0;
                          v237 = 0;
                          sub_100659D2C(*a1, &v236);
                          if (v236
                            && (*((unsigned int (**)(__CFString *, void, void **, CSIPhoneNumber *, __CFString **, char *, __int16 *))v236->isa
                                + 32))(v236, v234, &v239, buf, &v242, (char *)&v235 + 1, &v235))
                          {
                            v224 = (const char *)&v239;
                            if (v241 < 0) {
                              v224 = (const char *)v239;
                            }
                            v225 = (const char *)buf;
                            if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                              v225 = *(const char **)&buf[0].var0;
                            }
                            snprintf(__dst, 0x400uLL, "%s\n%s", v224, v225);
                          }
                          if (v237) {
                            sub_10004D2C8(v237);
                          }
                          if (__dst[0])
                          {
                            sub_100058DB0(&v236, __dst);
                            sub_10007FFB4(1, 0, (uint64_t)&v236, v234);
                            if (v238 < 0) {
                              operator delete(v236);
                            }
                          }
                          sub_10007FBD8();
                          if (buf[0].var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                            operator delete(*(void **)&buf[0].var0);
                          }
                          if ((SHIBYTE(v241) & 0x80000000) == 0) {
                            goto LABEL_398;
                          }
                          v222 = v239;
                          goto LABEL_347;
                        }
LABEL_300:
                        pthread_mutex_unlock(&stru_101B0AC18);
LABEL_301:
                        uint64_t v88 = 0;
                        goto LABEL_302;
                      }
                      sub_10007FB40();
                      v236 = 0;
                      v237 = 0;
                      sub_100659D2C(*a1, &v236);
                      v229 = v236;
                      if (v236)
                      {
                        sub_100058DB0(&v239, "");
                        CSIPhoneNumber::CSIPhoneNumber(buf, "");
                        (*((void (**)(__CFString *, void, void **, CSIPhoneNumber *))v229->isa + 34))(v229, v234, &v239, buf);
                        sub_100087E24((uint64_t)buf);
                        if (SHIBYTE(v241) < 0) {
                          operator delete(v239);
                        }
                      }
                      if (v237) {
                        sub_10004D2C8(v237);
                      }
                    }
                    sub_10007FBD8();
                    goto LABEL_398;
                  }
                  int v145 = a2[1];
                  if (v145 == 35)
                  {
                    unsigned int v144 = 4;
                    goto LABEL_293;
                  }
                  if (v145 == 42)
                  {
                    if (*(void *)a2 == 0x3335323236332A23 && *((_DWORD *)a2 + 2) == 590559538)
                    {
                      sub_10007FB40();
                      byte_101B0E1C0 = 1;
                      v194 = (const char *)sGetLogGroupName();
                      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v139, v194);
                      v195 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                      if (!os_log_type_enabled((os_log_t)v195, OS_LOG_TYPE_INFO)) {
                        goto LABEL_272;
                      }
                      LOWORD(buf[0].var0) = 0;
                      uint64_t v150 = "Unlocked AWD keycodes";
                      goto LABEL_270;
                    }
                    int v147 = a2[2];
                    if (v147 == 52)
                    {
                      if (a2[3] == 54 && a2[4] == 56 && a2[5] == 55 && a2[6] == 52 && a2[7] == 55 && a2[8] == 35)
                      {
                        sub_10007FB40();
                        if (byte_101B0E1C0 == 1)
                        {
                          v198 = (const char *)sGetLogGroupName();
                          ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v139, v198);
                          long long v149 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                          if (!os_log_type_enabled((os_log_t)v149, OS_LOG_TYPE_INFO)) {
                            goto LABEL_272;
                          }
                          buf[0].var0 = 136315138;
                          *(void *)&buf[0].var1 = "Uns";
                          uint64_t v150 = "%successfully loaded hotship profile through MMI";
                          goto LABEL_291;
                        }
                        v231 = (const char *)sGetLogGroupName();
                        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v139, v231);
                        v195 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                        if (!os_log_type_enabled((os_log_t)v195, OS_LOG_TYPE_INFO)) {
                          goto LABEL_272;
                        }
                        LOWORD(buf[0].var0) = 0;
                        uint64_t v150 = "Did not load hotship as AWD keycodes were not unlocked";
                        goto LABEL_270;
                      }
                    }
                    else if (v147 == 53)
                    {
                      if (a2[3] == 54 && a2[4] == 52 && a2[5] == 50 && a2[6] == 51 && a2[7] == 52 && a2[8] == 35)
                      {
                        sub_10007FB40();
                        if (byte_101B0E1C0 == 1)
                        {
                          v199 = (const char *)sGetLogGroupName();
                          ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v139, v199);
                          long long v149 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                          if (!os_log_type_enabled((os_log_t)v149, OS_LOG_TYPE_INFO)) {
                            goto LABEL_272;
                          }
                          buf[0].var0 = 136315138;
                          *(void *)&buf[0].var1 = "Uns";
                          uint64_t v150 = "%successfully logged configuration information through MMI";
                          goto LABEL_291;
                        }
                        v232 = (const char *)sGetLogGroupName();
                        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v139, v232);
                        v195 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                        if (!os_log_type_enabled((os_log_t)v195, OS_LOG_TYPE_INFO)) {
                          goto LABEL_272;
                        }
                        LOWORD(buf[0].var0) = 0;
                        uint64_t v150 = "Did not log AWD configurations as AWD keycodes were not unlocked";
                        goto LABEL_270;
                      }
                    }
                    else if (v147 == 55 {
                           && a2[3] == 56
                    }
                           && a2[4] == 50
                           && a2[5] == 54
                           && a2[6] == 52
                           && a2[7] == 56
                           && a2[8] == 35)
                    {
                      sub_10007FB40();
                      if (byte_101B0E1C0 == 1)
                      {
                        char v148 = (const char *)sGetLogGroupName();
                        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v139, v148);
                        long long v149 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                        if (os_log_type_enabled((os_log_t)v149, OS_LOG_TYPE_INFO))
                        {
                          buf[0].var0 = 136315138;
                          *(void *)&buf[0].var1 = "Uns";
                          uint64_t v150 = "%successfully forced an upload of AWD metrics through MMI";
LABEL_291:
                          v196 = v149;
                          v197 = 12;
                          goto LABEL_271;
                        }
LABEL_272:
                        sub_10007FBD8();
                        pthread_mutex_unlock(&stru_101B0AC18);
LABEL_267:
                        uint64_t v88 = 1;
                        goto LABEL_302;
                      }
                      v230 = (const char *)sGetLogGroupName();
                      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v139, v230);
                      v195 = buf[0].var2.__r_.__value_.var0.var1.__data_;
                      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                      if (!os_log_type_enabled((os_log_t)v195, OS_LOG_TYPE_INFO)) {
                        goto LABEL_272;
                      }
                      LOWORD(buf[0].var0) = 0;
                      uint64_t v150 = "Did not force an upload of AWD metrics as AWD keycodes were not unlocked";
LABEL_270:
                      v196 = v195;
                      v197 = 2;
LABEL_271:
                      _os_log_impl((void *)&_mh_execute_header, v196, OS_LOG_TYPE_INFO, v150, (uint8_t *)buf, v197);
                      goto LABEL_272;
                    }
                  }
                  unsigned int v144 = 1;
                  goto LABEL_293;
                }
LABEL_174:
                operator delete(*(void **)&buf[0].var0);
                if (v137) {
                  goto LABEL_206;
                }
                goto LABEL_175;
              }
              uint64_t v130 = v124 - 1;
              xpc_object_t v131 = cf;
              do
              {
                int v133 = *(unsigned __int8 *)v131;
                xpc_object_t v131 = (CFTypeRef *)((char *)v131 + 1);
                int v132 = v133;
                int v135 = LOBYTE(v129->var0);
                char v129 = (CSIPhoneNumber *)((char *)v129 + 1);
                int v134 = v135;
                BOOL v53 = v130-- != 0;
                char v136 = v53;
                BOOL v137 = v132 == v134;
              }
              while (v132 == v134 && (v136 & 1) != 0);
            }
            if ((v128 & 0x80000000) == 0) {
              goto LABEL_205;
            }
            goto LABEL_174;
          }
          goto LABEL_125;
        }
LABEL_124:
        operator delete(*(void **)&buf[0].var0);
        if (v108) {
          goto LABEL_139;
        }
LABEL_125:
        uint64_t v112 = (const char *)sGetLogGroupName();
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, v112);
        long long v110 = buf[0].var2.__r_.__value_.var0.var1.__data_;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (!os_log_type_enabled((os_log_t)v110, OS_LOG_TYPE_INFO)) {
          goto LABEL_144;
        }
        LOWORD(buf[0].var0) = 0;
        long long v111 = "serviceProvNum not found!";
        goto LABEL_127;
      }
      BOOL v108 = 1;
    }
    else
    {
      BOOL v108 = 0;
    }
    uint64_t v102 = v234;
    if ((buf[0].var2.__r_.__value_.var0.var0.__data_[15] & 0x80000000) == 0) {
      goto LABEL_138;
    }
    goto LABEL_124;
  }
  BOOL v31 = (const char *)sGetLogGroupName();
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, v31);
  long long v32 = buf[0].var2.__r_.__value_.var0.var1.__data_;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_INFO))
  {
    LOWORD(buf[0].var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)v32, OS_LOG_TYPE_INFO, "User wants to change AKEY", (uint8_t *)buf, 2u);
  }
  long long v33 = (std::mutex *)Registry::getServiceMap(*a1);
  long long v34 = v33;
  if (v35 < 0)
  {
    long long v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v37 = 5381;
    do
    {
      uint64_t v35 = v37;
      unsigned int v38 = *v36++;
      uint64_t v37 = (33 * v37) ^ v38;
    }
    while (v38);
  }
  std::mutex::lock(v33);
  *(void *)&buf[0].var0 = v35;
  long long v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)buf);
  if (v39)
  {
    uint64_t v41 = v39[3];
    uint64_t v40 = (std::__shared_weak_count *)v39[4];
    if (v40)
    {
      atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v34);
      atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v40);
      char v42 = 0;
      if (!v41) {
        goto LABEL_131;
      }
      goto LABEL_130;
    }
  }
  else
  {
    uint64_t v41 = 0;
  }
  std::mutex::unlock(v34);
  uint64_t v40 = 0;
  char v42 = 1;
  if (v41) {
LABEL_130:
  }
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v41 + 344))(v41, 1, 0);
LABEL_131:
  if ((v42 & 1) == 0) {
    sub_10004D2C8(v40);
  }
  pthread_mutex_unlock(&stru_101B0AC18);
  uint64_t v88 = 1;
LABEL_308:
  sub_1000577C4((const void **)&v254);
  return v88;
}

void sub_100924480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,const void *a47)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a39 < 0) {
    operator delete(*(void **)(v47 + 32));
  }
  if (a46 < 0) {
    operator delete(*(void **)(v47 + 64));
  }
  sub_1000577C4(&a47);
  _Unwind_Resume(a1);
}

BOOL sub_100924908(capabilities::ct *a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (v2 != 5) {
    return 0;
  }
  xpc_object_t v4 = v3 >= 0 ? (int *)a2 : *(int **)a2;
  int v5 = *v4;
  int v6 = *((unsigned __int8 *)v4 + 4);
  if (v5 != 925901610 || v6 != 35) {
    return 0;
  }
  std::string __p = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  capabilities::ct::SARValue((uint64_t *)&__p, a1);
  uint64_t v10 = HIBYTE(v14);
  char v11 = HIBYTE(v14);
  if (v14 < 0) {
    uint64_t v10 = v13;
  }
  BOOL v8 = v10 != 0;
  if (v10)
  {
    launchURL();
    char v11 = HIBYTE(v14);
  }
  if (v11 < 0) {
    operator delete(__p);
  }
  return v8;
}

void sub_1009249D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009249F0(uint64_t a1, xpc_object_t *a2)
{
  if (xpc_dictionary_get_count(*a2)) {
    sub_1000502D4(a1, (uint64_t)a2);
  }

  return xpc::auto_reply::deleter((xpc::auto_reply *)a2, v4);
}

void sub_100924A40(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1C540;
  sub_10004FD24(&a1[1].__shared_owners_);

  std::__shared_weak_count::~__shared_weak_count(a1);
}

void sub_100924A94(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1C540;
  sub_10004FD24(&a1[1].__shared_owners_);
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100924AFC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 32;
  }
  else
  {
    return 0;
  }
}

void sub_100924B40()
{
}

_DWORD *sub_100924B54(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = off_101A1C5A0;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_100924BA0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1C5A0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

void sub_100924BD0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  bzero(__str, 0x400uLL);
  v10[0] = 0;
  v10[1] = 0;
  uint64_t v11 = 0;
  v6[0] = v3;
  v6[1] = "kRadioTracePropertyValue";
  sub_100048BAC((uint64_t)v6, &object);
  xpc::dyn_cast_or_default((uint64_t *)__p, (xpc *)&object, (const object *)"", v4);
  *(_OWORD *)uint64_t v10 = *(_OWORD *)__p;
  uint64_t v11 = v9;
  HIBYTE(v9) = 0;
  LOBYTE(__p[0]) = 0;
  xpc_release(object);
  int v5 = v10;
  if (v11 < 0) {
    int v5 = (void **)v10[0];
  }
  snprintf(__str, 0x400uLL, "%s", (const char *)v5);
  sub_100058DB0(__p, __str);
  sub_10007FFB4(1, 0, (uint64_t)__p, *(_DWORD *)(a1 + 8));
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[0]);
  }
}

void sub_100924CFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100924D5C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100924D9C()
{
}

void *sub_100924DA8(void *a1, void *a2, NSObject **a3, void *a4, uint64_t a5, void *a6)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v20, kCtLoggingSystemName, "wea");
  *a1 = 0;
  a1[1] = 0;
  unsigned int v12 = *a3;
  a1[2] = *a3;
  if (v12) {
    dispatch_retain(v12);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v21, &v20);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v21);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v21);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  a1[5] = *a2;
  uint64_t v13 = a2[1];
  a1[6] = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = *a3;
  a1[7] = *a3;
  if (v14) {
    dispatch_retain(v14);
  }
  a1[8] = *a4;
  uint64_t v15 = a4[1];
  a1[9] = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100927274((uint64_t)(a1 + 10), a5);
  uint64_t v17 = *(void *)(*a4 + 16);
  char v16 = *(std::__shared_weak_count **)(*a4 + 24);
  if (v16)
  {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    a1[15] = *(void *)(v17 + 72);
    sub_10004D2C8(v16);
  }
  else
  {
    a1[15] = *(void *)(v17 + 72);
  }
  a1[16] = 0;
  a1[17] = 0;
  a1[18] = 0;
  a1[19] = *a6;
  uint64_t v18 = a6[1];
  a1[20] = v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100924F14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  uint64_t v15 = (std::__shared_weak_count *)v12[9];
  if (v15) {
    sub_10004D2C8(v15);
  }
  char v16 = v12[7];
  if (v16) {
    dispatch_release(v16);
  }
  uint64_t v17 = (std::__shared_weak_count *)v12[6];
  if (v17) {
    sub_10004D2C8(v17);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  sub_100087E88(v12);
  _Unwind_Resume(a1);
}

void *sub_100924F7C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[20];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = a1[18];
  a1[18] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[17];
  a1[17] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = a1[16];
  a1[16] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  sub_1009277A8((uint64_t)(a1 + 10));
  int v6 = (std::__shared_weak_count *)a1[9];
  if (v6) {
    sub_10004D2C8(v6);
  }
  long long v7 = a1[7];
  if (v7) {
    dispatch_release(v7);
  }
  BOOL v8 = (std::__shared_weak_count *)a1[6];
  if (v8) {
    sub_10004D2C8(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 4));

  return sub_100087E88(a1);
}

void *sub_100925080(void *result)
{
  uint64_t v1 = result[16];
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = result[4];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      sub_1010DDA90(__p);
      if (v6 >= 0) {
        uint64_t v4 = __p;
      }
      else {
        uint64_t v4 = (void **)__p[0];
      }
      *(_DWORD *)CSIPhoneNumber buf = 136446210;
      BOOL v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s Timer (Max Wait time) cancelled", buf, 0xCu);
      if (v6 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v1 = v2[16];
    }
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
    uint64_t result = (void *)v2[16];
    v2[16] = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

void sub_1009251BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 136);
  uint64_t v3 = *(NSObject **)(a1 + 32);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      sub_1010DDA90(__p);
      if (v8 >= 0) {
        uint64_t v5 = __p;
      }
      else {
        uint64_t v5 = (void **)__p[0];
      }
      *(_DWORD *)CSIPhoneNumber buf = 136446210;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s Timer (Geofence Timeout) cancelled", buf, 0xCu);
      if (v8 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v2 = *(void *)(a1 + 136);
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    uint64_t v6 = *(void *)(a1 + 136);
    *(void *)(a1 + 136) = 0;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
  }
  else if (v4)
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I GF timer is null. No actions required", (uint8_t *)__p, 2u);
  }
}

void sub_100925328(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 144);
  uint64_t v3 = *(NSObject **)(a1 + 32);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      sub_1010DDA90(__p);
      if (v8 >= 0) {
        uint64_t v5 = __p;
      }
      else {
        uint64_t v5 = (void **)__p[0];
      }
      *(_DWORD *)CSIPhoneNumber buf = 136446210;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s Timer (Alert-Active) cancelled", buf, 0xCu);
      if (v8 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v2 = *(void *)(a1 + 144);
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    uint64_t v6 = *(void *)(a1 + 144);
    *(void *)(a1 + 144) = 0;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
  }
  else if (v4)
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Alert Active timer is null. No actions required", (uint8_t *)__p, 2u);
  }
}

void sub_100925494(uint64_t *a1)
{
  uint64_t v25 = 0;
  unsigned int v26 = 0;
  Registry::getTimerService(&v25, (Registry *)a1[5]);
  if (v25)
  {
    uint64_t v2 = operator new(0x18uLL);
    char v30 = v2 + 3;
    BOOL v31 = (char *)(v2 + 3);
    *(_OWORD *)uint64_t v2 = *(_OWORD *)off_101A1C620;
    void v2[2] = @"GeofenceTimeoutInSec";
    *(void *)CSIPhoneNumber buf = v2;
    v27[0] = 0;
    sub_1007EC3B4((Registry **)a1[19], *(unsigned int *)(a1[8] + 156), 2, (uint64_t)buf, 0, 0, v32);
    sub_1000842D0(v27, (CFTypeRef *)v32);
    uint64_t v3 = sub_1000577C4((const void **)v32);
    if (v27[0]) {
      uint64_t v5 = sub_100081E58;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5)
    {
      *(_DWORD *)long long v32 = 0;
      ctu::cf::assign((ctu::cf *)v3, v27[0], v4);
      unsigned int v6 = *(_DWORD *)v32;
    }
    else
    {
      unsigned int v6 = 86400;
    }
    sub_1000570E8((const void **)v27);
    if (*(void *)buf)
    {
      char v30 = *(void **)buf;
      operator delete(*(void **)buf);
    }
    char v8 = (std::__shared_weak_count *)a1[1];
    if (!v8 || (uint64_t v9 = std::__shared_weak_count::lock(v8)) == 0) {
      sub_100088B9C();
    }
    uint64_t v10 = v9;
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v9);
    *(_OWORD *)int v27 = 0u;
    long long v28 = 0u;
    uint64_t v11 = (std::__shared_weak_count *)a1[1];
    if (!v11 || (uint64_t v12 = *a1, (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v14 = v13;
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v13);
    *((void *)&v28 + 1) = 0;
    uint64_t v15 = operator new(0x20uLL);
    void *v15 = off_101A1C6E0;
    v15[1] = a1;
    v15[2] = v12;
    unint64_t v15[3] = v14;
    *((void *)&v28 + 1) = v15;
    uint64_t v16 = v25;
    sub_100058DB0(__p, "Max wait time");
    *(_OWORD *)long long v32 = *(_OWORD *)__p;
    *(void *)&v32[16] = v23;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v23 = 0;
    sub_1000DA470((uint64_t)buf, (uint64_t)v27);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *, uint64_t, uint64_t, void, uint8_t *))(*(void *)v16 + 40))(&v24, v16, v32, 1, 1000000 * v6, 0, buf);
    sub_10003B34C(buf);
    if ((v32[23] & 0x80000000) != 0) {
      operator delete(*(void **)v32);
    }
    uint64_t v17 = v24;
    uint64_t v24 = 0;
    uint64_t v18 = a1[17];
    a1[17] = v17;
    if (v18)
    {
      (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
      uint64_t v19 = v24;
      uint64_t v24 = 0;
      if (v19) {
        (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
      }
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
    OsLogContext v20 = a1[4];
    if (a1[17])
    {
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        sub_1010DDA90(buf);
        long long v21 = SHIBYTE(v31) >= 0 ? buf : *(uint8_t **)buf;
        *(_DWORD *)long long v32 = 136446466;
        *(void *)&v32[4] = v21;
        *(_WORD *)&v32[12] = 2048;
        *(void *)&v32[14] = v6 / 0xE10uLL;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %{public}s Timer (Geofence Timeout) started for %lld hours", v32, 0x16u);
        if (SHIBYTE(v31) < 0) {
          operator delete(*(void **)buf);
        }
      }
    }
    else if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to create timer", buf, 2u);
    }
    sub_10003B34C(v27);
    std::__shared_weak_count::__release_weak(v10);
  }
  else
  {
    long long v7 = a1[4];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to get timer interface", buf, 2u);
    }
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
}

void sub_1009258A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  sub_10003B34C(&a18);
  std::__shared_weak_count::__release_weak(v23);
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(a1);
}

void sub_100925964(uint64_t *a1)
{
  uint64_t v35 = 0;
  long long v36 = 0;
  Registry::getTimerService(&v35, (Registry *)a1[5]);
  if (v35)
  {
    uint64_t v2 = (std::__shared_weak_count *)a1[1];
    if (!v2 || (uint64_t v3 = std::__shared_weak_count::lock(v2)) == 0) {
      sub_100088B9C();
    }
    CFNumberRef v4 = v3;
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
    long long v37 = 0u;
    long long v38 = 0u;
    uint64_t v5 = (std::__shared_weak_count *)a1[1];
    if (!v5 || (v6 = *a1, (long long v7 = std::__shared_weak_count::lock(v5)) == 0)) {
      sub_100088B9C();
    }
    char v8 = v7;
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v7);
    *((void *)&v38 + 1) = 0;
    uint64_t v9 = operator new(0x20uLL);
    void *v9 = off_101A1C760;
    v9[1] = a1;
    void v9[2] = v6;
    v9[3] = v8;
    *((void *)&v38 + 1) = v9;
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)a1[5]);
    uint64_t v11 = ServiceMap;
    if (v12 < 0)
    {
      uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)CSIPhoneNumber buf = v12;
    uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
    if (v16)
    {
      uint64_t v18 = (uint64_t (***)(void))v16[3];
      uint64_t v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
LABEL_16:
        char v21 = (**v18)(v18);
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        if (v21)
        {
          uint64_t v22 = 2700;
        }
        else
        {
          uint64_t v23 = operator new(0x18uLL);
          uint64_t v40 = v23 + 3;
          uint64_t v41 = (char *)(v23 + 3);
          *(_OWORD *)uint64_t v23 = *(_OWORD *)off_101A1C638;
          _DWORD v23[2] = @"AlertActiveTimeoutInSec";
          *(void *)CSIPhoneNumber buf = v23;
          *(void *)char v42 = 0;
          sub_1007EC3B4((Registry **)a1[19], 1, 2, (uint64_t)buf, 0, 0, &v34);
          sub_1000842D0(v42, &v34);
          sub_1000577C4(&v34);
          if (*(void *)v42) {
            uint64_t v25 = sub_100081E58;
          }
          else {
            uint64_t v25 = 0;
          }
          if (v25)
          {
            LODWORD(v34) = 0;
            ctu::cf::assign((ctu::cf *)&v34, *(unsigned int **)v42, v24);
            uint64_t v22 = v34;
          }
          else
          {
            uint64_t v22 = 600;
          }
          sub_1000570E8((const void **)v42);
          if (*(void *)buf)
          {
            uint64_t v40 = *(void **)buf;
            operator delete(*(void **)buf);
          }
        }
        uint64_t v26 = v35;
        sub_100058DB0(__p, "Max wait time");
        *(_OWORD *)char v42 = *(_OWORD *)__p;
        *(void *)&v42[16] = v33;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v33 = 0;
        sub_1000DA470((uint64_t)buf, (uint64_t)&v37);
        (*(void (**)(const void **__return_ptr, uint64_t, unsigned char *, uint64_t, uint64_t, void, uint8_t *))(*(void *)v26 + 40))(&v34, v26, v42, 1, 1000000 * v22, 0, buf);
        sub_10003B34C(buf);
        if ((v42[23] & 0x80000000) != 0) {
          operator delete(*(void **)v42);
        }
        uint64_t v27 = (uint64_t)v34;
        long long v34 = 0;
        uint64_t v28 = a1[18];
        a1[18] = v27;
        if (v28)
        {
          (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
          uint64_t v29 = v34;
          long long v34 = 0;
          if (v29) {
            (*(void (**)(const void *))(*(void *)v29 + 8))(v29);
          }
        }
        if (SHIBYTE(v33) < 0) {
          operator delete(__p[0]);
        }
        char v30 = a1[4];
        if (a1[18])
        {
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            sub_1010DDA90(buf);
            BOOL v31 = SHIBYTE(v41) >= 0 ? buf : *(uint8_t **)buf;
            *(_DWORD *)char v42 = 136446466;
            *(void *)&_DWORD v42[4] = v31;
            *(_WORD *)&v42[12] = 2048;
            *(void *)&v42[14] = v22;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %{public}s Timer (Alert-Active) started for %lld seconds", v42, 0x16u);
            if (SHIBYTE(v41) < 0) {
              operator delete(*(void **)buf);
            }
          }
        }
        else if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)CSIPhoneNumber buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Failed to create timer", buf, 2u);
        }
        sub_10003B34C(&v37);
        std::__shared_weak_count::__release_weak(v4);
        goto LABEL_45;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    uint64_t v17 = 0;
    char v19 = 1;
    goto LABEL_16;
  }
  OsLogContext v20 = a1[4];
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to get timer interface", buf, 2u);
  }
LABEL_45:
  if (v36) {
    sub_10004D2C8(v36);
  }
}

void sub_100925E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  sub_10003B34C(&a18);
  std::__shared_weak_count::__release_weak(v23);
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(a1);
}

void sub_100925F20()
{
}

void sub_100925F28(uint64_t a1)
{
  sub_100925494((uint64_t *)a1);
  sub_100925964((uint64_t *)a1);
  uint64_t v2 = (void *)(a1 + 96);
  while (1)
  {
    uint64_t v2 = (void *)*v2;
    if (!v2) {
      break;
    }
    if (!sub_100F8FF6C(v2[2]))
    {
      uint64_t v3 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        sub_1010DDA90(v35);
        int v4 = v36;
        uint64_t v5 = *(uint8_t **)v35;
        sub_100F900D8(v2[2], __p);
        uint64_t v6 = v35;
        if (v4 < 0) {
          uint64_t v6 = v5;
        }
        if ((SBYTE7(v34) & 0x80u) == 0) {
          long long v7 = __p;
        }
        else {
          long long v7 = (void **)__p[0];
        }
        *(_DWORD *)CSIPhoneNumber buf = 136446466;
        *(void *)&uint8_t buf[4] = v6;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v7;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s Timer (Max wait time) needed for (at least) - %s", buf, 0x16u);
        if (SBYTE7(v34) < 0) {
          operator delete(__p[0]);
        }
        if (v36 < 0) {
          operator delete(*(void **)v35);
        }
      }
      uint64_t v8 = *(void *)(a1 + 120);
      if (v8 == 255 || !v8) {
        *(void *)(a1 + 120) = 45;
      }
      uint64_t v31 = 0;
      long long v32 = 0;
      Registry::getTimerService(&v31, *(Registry **)(a1 + 40));
      if (v31)
      {
        uint64_t v9 = *(std::__shared_weak_count **)(a1 + 8);
        if (!v9 || (uint64_t v10 = std::__shared_weak_count::lock(v9)) == 0) {
          sub_100088B9C();
        }
        uint64_t v11 = v10;
        atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        *(_OWORD *)std::string __p = 0u;
        long long v34 = 0u;
        uint64_t v12 = *(std::__shared_weak_count **)(a1 + 8);
        if (!v12 || (uint64_t v13 = *(void *)a1, (v14 = std::__shared_weak_count::lock(v12)) == 0)) {
          sub_100088B9C();
        }
        unsigned int v15 = v14;
        atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        *((void *)&v34 + 1) = 0;
        uint64_t v16 = operator new(0x20uLL);
        *uint64_t v16 = off_101A1C660;
        v16[1] = a1;
        void v16[2] = v13;
        v16[3] = v15;
        *((void *)&v34 + 1) = v16;
        uint64_t v17 = v31;
        sub_100058DB0(v28, "Max wait time");
        uint64_t v18 = 1000000 * *(void *)(a1 + 120);
        *(_OWORD *)CSIPhoneNumber buf = *(_OWORD *)v28;
        *(void *)&uint8_t buf[16] = v29;
        v28[0] = 0;
        v28[1] = 0;
        uint64_t v29 = 0;
        sub_1000DA470((uint64_t)v35, (uint64_t)__p);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *, uint64_t, uint64_t, void, uint8_t *))(*(void *)v17 + 40))(&v30, v17, buf, 1, v18, 0, v35);
        sub_10003B34C(v35);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v19 = v30;
        uint64_t v30 = 0;
        uint64_t v20 = *(void *)(a1 + 128);
        *(void *)(a1 + 128) = v19;
        if (v20)
        {
          (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
          uint64_t v21 = v30;
          uint64_t v30 = 0;
          if (v21) {
            (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
          }
        }
        if (SHIBYTE(v29) < 0) {
          operator delete(v28[0]);
        }
        uint64_t v22 = *(NSObject **)(a1 + 32);
        if (*(void *)(a1 + 128))
        {
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            sub_1010DDA90(v35);
            if (v36 >= 0) {
              uint64_t v23 = v35;
            }
            else {
              uint64_t v23 = *(uint8_t **)v35;
            }
            uint64_t v24 = *(void *)(a1 + 120);
            *(_DWORD *)CSIPhoneNumber buf = 136446466;
            *(void *)&uint8_t buf[4] = v23;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v24;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %{public}s Timer (Max Wait Time) started for %lld seconds", buf, 0x16u);
            if (v36 < 0) {
              operator delete(*(void **)v35);
            }
          }
        }
        else if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v35 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to create timer", v35, 2u);
        }
        sub_10003B34C(__p);
        std::__shared_weak_count::__release_weak(v11);
      }
      else
      {
        uint64_t v27 = *(NSObject **)(a1 + 32);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v35 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Failed to get timer interface", v35, 2u);
        }
      }
      if (v32) {
        sub_10004D2C8(v32);
      }
      return;
    }
  }
  uint64_t v25 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    sub_1010DDA90(v35);
    uint64_t v26 = v36 >= 0 ? v35 : *(uint8_t **)v35;
    LODWORD(__p[0]) = 136446210;
    *(void **)((char *)__p + 4) = v26;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %{public}s Timer (Max wait time) not required...", (uint8_t *)__p, 0xCu);
    if (v36 < 0) {
      operator delete(*(void **)v35);
    }
  }
}

void sub_1009263E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  sub_10003B34C(&a18);
  std::__shared_weak_count::__release_weak(v27);
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100926480(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 144);
  if (v2 && !(*(unsigned int (**)(uint64_t))(*(void *)v2 + 24))(v2))
  {
    long long v7 = (void *)(a1 + 96);
    while (1)
    {
      long long v7 = (void *)*v7;
      if (!v7) {
        break;
      }
      if (sub_100F9047C(v7[2]))
      {
        uint64_t v8 = *(NSObject **)(a1 + 32);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          sub_1010DDA90(__p);
          int v9 = v14;
          uint64_t v10 = (void **)__p[0];
          sub_100F900D8(v7[2], buf);
          uint64_t v11 = __p;
          if (v9 < 0) {
            uint64_t v11 = v10;
          }
          if (v16 >= 0) {
            uint64_t v12 = buf;
          }
          else {
            uint64_t v12 = *(unsigned char **)buf;
          }
          *(_DWORD *)uint64_t v17 = 136446466;
          uint64_t v18 = v11;
          __int16 v19 = 2080;
          uint64_t v20 = v12;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %{public}s will be dispatched, triggered from - %s", v17, 0x16u);
          if (v16 < 0) {
            operator delete(*(void **)buf);
          }
          if (v14 < 0) {
            operator delete(__p[0]);
          }
        }
        return 1;
      }
    }
  }
  else
  {
    uint64_t v3 = *(NSObject **)(a1 + 32);
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v4) {
      return result;
    }
    sub_1010DDA90(__p);
    if (v14 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    *(_DWORD *)CSIPhoneNumber buf = 136446210;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s Alert is not active... Cannot dispatch", buf, 0xCu);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
  }
  return 0;
}

void sub_10092666C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100926690(void *a1)
{
  if (a1[13])
  {
    long long buf = 0uLL;
    unint64_t v48 = 0;
    for (unsigned int i = (void *)a1[12]; i; unsigned int i = (void *)*i)
    {
      sub_100F900D8(i[2], &v39);
      sub_100058DB0(v37, "<");
      if ((v38 & 0x80u) == 0) {
        uint64_t v2 = v37;
      }
      else {
        uint64_t v2 = (void **)v37[0];
      }
      if ((v38 & 0x80u) == 0) {
        std::string::size_type v3 = v38;
      }
      else {
        std::string::size_type v3 = (std::string::size_type)v37[1];
      }
      BOOL v4 = std::string::append(&v39, (const std::string::value_type *)v2, v3);
      long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
      v45.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v5;
      v4->__r_.__value_.__l.__size_ = 0;
      v4->__r_.__value_.__r.__words[2] = 0;
      v4->__r_.__value_.__r.__words[0] = 0;
      uint64_t v6 = i[3];
      if (v6) {
        uint64_t v7 = *(void *)(v6 + 8) + 1;
      }
      else {
        uint64_t v7 = 0;
      }
      std::to_string(&v36, v7);
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v8 = &v36;
      }
      else {
        uint64_t v8 = (std::string *)v36.__r_.__value_.__r.__words[0];
      }
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v36.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v36.__r_.__value_.__l.__size_;
      }
      uint64_t v10 = std::string::append(&v45, (const std::string::value_type *)v8, size);
      long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      sub_100058DB0(__p, ">");
      if ((v35 & 0x80u) == 0) {
        uint64_t v12 = __p;
      }
      else {
        uint64_t v12 = (void **)__p[0];
      }
      if ((v35 & 0x80u) == 0) {
        std::string::size_type v13 = v35;
      }
      else {
        std::string::size_type v13 = (std::string::size_type)__p[1];
      }
      char v14 = std::string::append(&v40, (const std::string::value_type *)v12, v13);
      std::string::size_type v15 = v14->__r_.__value_.__r.__words[0];
      v46[0] = v14->__r_.__value_.__l.__size_;
      *(void *)((char *)v46 + 7) = *(std::string::size_type *)((char *)&v14->__r_.__value_.__r.__words[1] + 7);
      char v16 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      uint64_t v17 = *((void *)&buf + 1);
      if (*((void *)&buf + 1) >= v48)
      {
        unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&buf + 1) - buf) >> 3);
        unint64_t v21 = v20 + 1;
        if (v20 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v48 - buf) >> 3) > v21) {
          unint64_t v21 = 0x5555555555555556 * ((uint64_t)(v48 - buf) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v48 - buf) >> 3) >= 0x555555555555555) {
          unint64_t v22 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v22 = v21;
        }
        unsigned int v44 = &v48;
        if (v22) {
          uint64_t v23 = (char *)sub_10004812C((uint64_t)&v48, v22);
        }
        else {
          uint64_t v23 = 0;
        }
        uint64_t v24 = (std::string::size_type *)&v23[24 * v20];
        v41[0] = v23;
        v41[1] = v24;
        uint64_t v43 = &v23[24 * v22];
        std::string::size_type v25 = v46[0];
        *uint64_t v24 = v15;
        v24[1] = v25;
        *(std::string::size_type *)((char *)v24 + 15) = *(void *)((char *)v46 + 7);
        *((unsigned char *)v24 + 23) = v16;
        v46[0] = 0;
        *(void *)((char *)v46 + 7) = 0;
        char v42 = v24 + 3;
        sub_100048204((uint64_t *)&buf, v41);
        uint64_t v19 = *((void *)&buf + 1);
        sub_100048174((uint64_t)v41);
      }
      else
      {
        uint64_t v18 = v46[0];
        **((void **)&buf + 1) = v15;
        *(void *)(v17 + 8) = v18;
        *(void *)(v17 + 15) = *(void *)((char *)v46 + 7);
        *(unsigned char *)(v17 + 23) = v16;
        v46[0] = 0;
        *(void *)((char *)v46 + 7) = 0;
        uint64_t v19 = v17 + 24;
      }
      *((void *)&buf + 1) = v19;
      if ((char)v35 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v40.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v36.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v45.__r_.__value_.__l.__data_);
      }
      if ((char)v38 < 0) {
        operator delete(v37[0]);
      }
      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v39.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v26 = a1[4];
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      sub_1010DDA90(v41);
      int v27 = SHIBYTE(v42);
      uint64_t v28 = (void **)v41[0];
      sub_100062B40((std::string *)buf, *((std::string **)&buf + 1), ", ", 2uLL, &v40);
      uint64_t v29 = v41;
      if (v27 < 0) {
        uint64_t v29 = v28;
      }
      if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v30 = &v40;
      }
      else {
        uint64_t v30 = (std::string *)v40.__r_.__value_.__r.__words[0];
      }
      LODWORD(v45.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)v45.__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
      WORD2(v45.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&v45.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v30;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %{public}s %{public}s", (uint8_t *)&v45, 0x16u);
      if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v40.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v42) < 0) {
        operator delete(v41[0]);
      }
    }
    v41[0] = &buf;
    sub_100047F64((void ***)v41);
  }
  else
  {
    uint64_t v31 = a1[4];
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      sub_1010DDA90(v41);
      long long v32 = SHIBYTE(v42) >= 0 ? v41 : (void **)v41[0];
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v32;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s <-- No associated shapes...", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(v42) < 0) {
        operator delete(v41[0]);
      }
    }
  }
}

void sub_100926AE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
}

void sub_100926BDC(void *a1)
{
  uint64_t v2 = a1[4];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_1010DDA90(__p);
    if (v5 >= 0) {
      std::string::size_type v3 = __p;
    }
    else {
      std::string::size_type v3 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %{public}s Releasing timers and shapes...", buf, 0xCu);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100925328((uint64_t)a1);
  sub_1009251BC((uint64_t)a1);
  sub_100925080(a1);
  sub_100926CD4((uint64_t)a1);
}

void sub_100926CD4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 96);
  if (v2)
  {
    while (1)
    {
      uint64_t v3 = v2[3];
      if (!v3)
      {
        BOOL v4 = *(NSObject **)(a1 + 32);
LABEL_20:
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          sub_100F900D8(v2[2], __p);
          if (v20 >= 0) {
            uint64_t v17 = __p;
          }
          else {
            uint64_t v17 = (void **)__p[0];
          }
          uint64_t v18 = v2[3];
          if (v18) {
            uint64_t v18 = *(void *)(v18 + 8) + 1;
          }
          *(_DWORD *)long long buf = 136446466;
          unint64_t v22 = v17;
          __int16 v23 = 2048;
          uint64_t v24 = v18;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %{public}s is in use: <%lu>...", buf, 0x16u);
          if (v20 < 0) {
            operator delete(__p[0]);
          }
        }
        goto LABEL_33;
      }
      BOOL v4 = *(NSObject **)(a1 + 32);
      if (*(void *)(v3 + 8)) {
        goto LABEL_20;
      }
      if (os_log_type_enabled(*(os_log_t *)(a1 + 32), OS_LOG_TYPE_DEFAULT))
      {
        sub_100F900D8(v2[2], __p);
        if (v20 >= 0) {
          char v5 = __p;
        }
        else {
          char v5 = (void **)__p[0];
        }
        uint64_t v6 = v2[3];
        if (v6) {
          uint64_t v6 = *(void *)(v6 + 8) + 1;
        }
        *(_DWORD *)long long buf = 136446466;
        unint64_t v22 = v5;
        __int16 v23 = 2048;
        uint64_t v24 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %{public}s will stop the geofence: <%lu>...", buf, 0x16u);
        if (v20 < 0) {
          operator delete(__p[0]);
        }
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 40));
      uint64_t v8 = ServiceMap;
      if (v9 < 0)
      {
        uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          uint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      __p[0] = (void *)v9;
      std::string::size_type v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
      if (!v13) {
        break;
      }
      uint64_t v14 = v13[3];
      std::string::size_type v15 = (std::__shared_weak_count *)v13[4];
      if (!v15) {
        goto LABEL_29;
      }
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v16 = 0;
      if (v14) {
        goto LABEL_30;
      }
LABEL_31:
      if ((v16 & 1) == 0) {
        sub_10004D2C8(v15);
      }
LABEL_33:
      uint64_t v2 = (void *)*v2;
      if (!v2) {
        goto LABEL_34;
      }
    }
    uint64_t v14 = 0;
LABEL_29:
    std::mutex::unlock(v8);
    std::string::size_type v15 = 0;
    char v16 = 1;
    if (!v14) {
      goto LABEL_31;
    }
LABEL_30:
    sub_100F902A8(v2[2]);
    goto LABEL_31;
  }
LABEL_34:
  sub_100928674(a1 + 80);
}

void sub_100926F68(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100926F98(uint64_t *a1)
{
  uint64_t v2 = a1[13];
  uint64_t v3 = a1[4];
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      sub_1010DDA90(__p);
      if (v8 >= 0) {
        char v5 = __p;
      }
      else {
        char v5 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s Refreshing...", buf, 0xCu);
      if (v8 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_100925328((uint64_t)a1);
    sub_100925964(a1);
    sub_1009251BC((uint64_t)a1);
    sub_100925494(a1);
  }
  else if (v4)
  {
    sub_1010DDA90(__p);
    uint64_t v6 = v8 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long buf = 136446210;
    uint64_t v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s Not Refreshing...", buf, 0xCu);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100927104(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 96);
  while (1)
  {
    uint64_t v2 = (void *)*v2;
    if (!v2) {
      break;
    }
    if (!sub_100F8FF6C(v2[2]))
    {
      uint64_t v3 = *(NSObject **)(a1 + 32);
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      __int16 v6 = 0;
      BOOL v4 = "#I Not all shapes monitoring";
      char v5 = (uint8_t *)&v6;
      goto LABEL_8;
    }
  }
  uint64_t v3 = *(NSObject **)(a1 + 32);
  if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
    return;
  }
  *(_WORD *)long long buf = 0;
  BOOL v4 = "#I All shapes monitoring";
  char v5 = buf;
LABEL_8:
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, v5, 2u);
}

void sub_1009271B0(void *a1)
{
  uint64_t v2 = a1 + 12;
  while (1)
  {
    uint64_t v2 = (void *)*v2;
    if (!v2) {
      break;
    }
    if (!sub_100F8FF6C(v2[2]))
    {
      uint64_t v3 = a1[4];
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Not all shapes monitoring", v5, 2u);
      }
      return;
    }
  }
  BOOL v4 = a1[4];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I All shapes ready...", buf, 2u);
  }
  sub_100925080(a1);
}

uint64_t sub_100927274(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_1001369F0(a1, *(void *)(a2 + 8));
  for (unsigned int i = *(void **)(a2 + 16); i; unsigned int i = (void *)*i)
    sub_1009272EC(a1, i + 2, i + 2);
  return a1;
}

void sub_1009272D4(_Unwind_Exception *a1)
{
  sub_1009277A8(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009272EC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  __int16 v6 = (void *)(a1 + 24);
  unint64_t v7 = sub_100927574(a1 + 24, a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v12 = v7;
      if (v7 >= v9) {
        unint64_t v12 = v7 % v9;
      }
    }
    else
    {
      unint64_t v12 = (v9 - 1) & v7;
    }
    std::string::size_type v13 = *(uint64_t ***)(*(void *)a1 + 8 * v12);
    if (v13)
    {
      for (unsigned int i = *v13; i; unsigned int i = (uint64_t *)*i)
      {
        unint64_t v15 = i[1];
        if (v15 == v8)
        {
          if (sub_1009275E8(a1 + 32, i + 2, a2)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v15 >= v9) {
              v15 %= v9;
            }
          }
          else
          {
            v15 &= v9 - 1;
          }
          if (v15 != v12) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  char v16 = (uint64_t *)(a1 + 16);
  unsigned int i = (uint64_t *)operator new(0x20uLL);
  *unsigned int i = 0;
  i[1] = v8;
  uint64_t v17 = a3[1];
  i[2] = *a3;
  i[3] = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v9 || (float)(v19 * (float)v9) < v18)
  {
    BOOL v20 = 1;
    if (v9 >= 3) {
      BOOL v20 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v9);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    sub_1001369F0(a1, v23);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v12 = v8 % v9;
      }
      else {
        unint64_t v12 = v8;
      }
    }
    else
    {
      unint64_t v12 = (v9 - 1) & v8;
    }
  }
  uint64_t v24 = *(void *)a1;
  std::string::size_type v25 = *(uint64_t **)(*(void *)a1 + 8 * v12);
  if (v25)
  {
    *unsigned int i = *v25;
LABEL_40:
    *std::string::size_type v25 = (uint64_t)i;
    goto LABEL_41;
  }
  *unsigned int i = *v16;
  *char v16 = (uint64_t)i;
  *(void *)(v24 + 8 * v12) = v16;
  if (*i)
  {
    unint64_t v26 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v26 >= v9) {
        v26 %= v9;
      }
    }
    else
    {
      v26 &= v9 - 1;
    }
    std::string::size_type v25 = (uint64_t *)(*(void *)a1 + 8 * v26);
    goto LABEL_40;
  }
LABEL_41:
  ++*v6;
  return i;
}

void sub_100927558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  sub_10092774C(v11, v10);
  _Unwind_Resume(a1);
}

unint64_t sub_100927574(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*(char *)(*a2 + 63) < 0)
  {
    sub_10004FC84(__p, *(void **)(v2 + 40), *(void *)(v2 + 48));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(v2 + 40);
    uint64_t v6 = *(void *)(v2 + 56);
  }
  unint64_t v3 = sub_100206390((uint64_t)&v7, (uint64_t)__p);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  return v3;
}

BOOL sub_1009275E8(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *a2;
  if (*(char *)(*a2 + 63) < 0)
  {
    sub_10004FC84(__s1, *(void **)(v4 + 40), *(void *)(v4 + 48));
  }
  else
  {
    *(_OWORD *)CSIPhoneNumber __s1 = *(_OWORD *)(v4 + 40);
    uint64_t v24 = *(void *)(v4 + 56);
  }
  uint64_t v5 = *a3;
  if (*(char *)(*a3 + 63) < 0)
  {
    sub_10004FC84(__p, *(void **)(v5 + 40), *(void *)(v5 + 48));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(v5 + 40);
    uint64_t v22 = *(void *)(v5 + 56);
  }
  char v6 = HIBYTE(v24);
  if (v24 >= 0) {
    char v7 = (void *)HIBYTE(v24);
  }
  else {
    char v7 = __s1[1];
  }
  unint64_t v8 = (void *)HIBYTE(v22);
  int v9 = SHIBYTE(v22);
  if (v22 < 0) {
    unint64_t v8 = __p[1];
  }
  if (v7 != v8)
  {
    BOOL v19 = 0;
    if ((SHIBYTE(v22) & 0x80000000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_32;
  }
  if (v22 >= 0) {
    uint8x8_t v10 = __p;
  }
  else {
    uint8x8_t v10 = (void **)__p[0];
  }
  if (SHIBYTE(v24) < 0)
  {
    BOOL v19 = memcmp(__s1[0], v10, (size_t)__s1[1]) == 0;
    goto LABEL_28;
  }
  if (HIBYTE(v24))
  {
    uint64_t v11 = HIBYTE(v24) - 1;
    unint64_t v12 = __s1;
    do
    {
      int v14 = *(unsigned __int8 *)v12;
      unint64_t v12 = (void **)((char *)v12 + 1);
      int v13 = v14;
      int v16 = *(unsigned __int8 *)v10;
      uint8x8_t v10 = (void **)((char *)v10 + 1);
      int v15 = v16;
      BOOL v18 = v11-- != 0;
      BOOL v19 = v13 == v15;
    }
    while (v13 == v15 && v18);
LABEL_28:
    if ((v9 & 0x80000000) == 0) {
      goto LABEL_29;
    }
LABEL_32:
    operator delete(__p[0]);
    if ((v24 & 0x8000000000000000) == 0) {
      return v19;
    }
LABEL_33:
    operator delete(__s1[0]);
    return v19;
  }
  BOOL v19 = 1;
  if (SHIBYTE(v22) < 0) {
    goto LABEL_32;
  }
LABEL_29:
  if (v6 < 0) {
    goto LABEL_33;
  }
  return v19;
}

void sub_100927730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10092774C(uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unint64_t v3 = (std::__shared_weak_count *)__p[3];
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t sub_1009277A8(uint64_t a1)
{
  sub_1009277E4(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1009277E4(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      unint64_t v3 = (void *)*v2;
      uint64_t v4 = (std::__shared_weak_count *)v2[3];
      if (v4) {
        sub_10004D2C8(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void *sub_10092782C(void *a1)
{
  *a1 = off_101A1C660;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100927878(void *a1)
{
  *a1 = off_101A1C660;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1009278E4(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A1C660;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100927948(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1C660;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100927988(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100927998(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1009279D8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      if (*(void *)(a1 + 16)) {
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100927A84(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100927AC4()
{
}

void sub_100927AD0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(*a1 + 40));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v4;
  unint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&__p);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (v10) {
        goto LABEL_12;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
  if (v10) {
    goto LABEL_12;
  }
LABEL_10:
  unint64_t v12 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to get Geofence Manager", (uint8_t *)&__p, 2u);
  }
LABEL_12:
  int v13 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    sub_1010DDA90(&__p);
    int v14 = v18 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)long long buf = 136315138;
    BOOL v20 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s Timer (Max Wait Time) expiry..", buf, 0xCu);
    if (v18 < 0) {
      operator delete(__p);
    }
  }
  int v15 = *(std::__shared_weak_count **)(v1 + 72);
  std::string __p = *(void **)(v1 + 64);
  uint64_t v17 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, void **))(*(void *)v10 + 40))(v10, &__p);
  if (v17) {
    sub_10004D2C8(v17);
  }
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }

  operator delete();
}

void sub_100927D18()
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

void *sub_100927D74(void *a1)
{
  *a1 = off_101A1C6E0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100927DC0(void *a1)
{
  *a1 = off_101A1C6E0;
  char v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100927E2C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A1C6E0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100927E90(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1C6E0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100927ED0(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100927EE0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100927F20(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      if (*(void *)(a1 + 16)) {
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100927FCC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10092800C()
{
}

void sub_100928018(uint64_t *a1)
{
  uint64_t v1 = *a1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(*a1 + 40));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v4;
  unint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&__p);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (v10) {
        goto LABEL_12;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
  if (v10) {
    goto LABEL_12;
  }
LABEL_10:
  unint64_t v12 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to get Geofence Manager", (uint8_t *)&__p, 2u);
  }
LABEL_12:
  int v13 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    sub_1010DDA90(&__p);
    int v14 = v18 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)long long buf = 136446210;
    BOOL v20 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %{public}s Timer (Geofence Timeout) expiry ..", buf, 0xCu);
    if (v18 < 0) {
      operator delete(__p);
    }
  }
  int v15 = *(std::__shared_weak_count **)(v1 + 72);
  std::string __p = *(void **)(v1 + 64);
  uint64_t v17 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, void **))(*(void *)v10 + 32))(v10, &__p);
  if (v17) {
    sub_10004D2C8(v17);
  }
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }

  operator delete();
}

void sub_100928260()
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

void *sub_1009282BC(void *a1)
{
  *a1 = off_101A1C760;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100928308(void *a1)
{
  *a1 = off_101A1C760;
  char v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100928374(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A1C760;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1009283D8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1C760;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100928418(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100928428(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100928468(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      if (*(void *)(a1 + 16)) {
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100928514(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100928554()
{
}

void sub_100928560(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(NSObject **)(*a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Timer (Alert-Active) expiry...", v5, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 144);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
    uint64_t v4 = *(void *)(v1 + 144);
    *(void *)(v1 + 144) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }

  operator delete();
}

void sub_100928650()
{
}

void sub_100928674(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_1009277E4(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void sub_1009286CC(uint64_t a1)
{
  *(void *)a1 = off_101A1C7E0;
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    uint64_t v4 = *(void **)(a1 + 32);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        void *v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 32);
    }
    *(void *)(a1 + 40) = v2;
    operator delete(v4);
  }
  sub_100110A40((void ***)(a1 + 24), 0);
  uint64_t v7 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v7) {
    sub_100206334(a1 + 16, v7);
  }
  sub_100110A40((void ***)(a1 + 8), 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_1009287B0(uint64_t a1)
{
  sub_1009286CC(a1);

  operator delete();
}

uint64_t sub_1009287E8(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = off_101A1C7E0;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(_DWORD *)(result + 60) = 0;
  *(_OWORD *)(result + 40) = 0u;
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(void *)(a2 + 24)) {
    operator new();
  }
  if (*(unsigned char *)(a2 + 60))
  {
    int v2 = *(_DWORD *)(a2 + 56);
    *(unsigned char *)(result + 60) |= 1u;
    *(_DWORD *)(result + 56) = v2;
  }
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (*(void *)(a2 + 32) != *(void *)(a2 + 40)) {
    operator new();
  }
  return result;
}

void sub_100928A6C(void *a1)
{
}

uint64_t sub_100928AC0(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  if (*(void *)(a1 + 16)) {
    PB::TextFormatter::format();
  }
  uint64_t v6 = *(const PB::Data **)(a1 + 24);
  if (v6) {
    PB::TextFormatter::format(this, "profileId", v6);
  }
  uint64_t v7 = *(uint64_t **)(a1 + 32);
  unint64_t v8 = *(uint64_t **)(a1 + 40);
  while (v7 != v8)
  {
    uint64_t v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, this, "selectableProfiles");
  }
  if (*(unsigned char *)(a1 + 60)) {
    PB::TextFormatter::format(this, "status", *(_DWORD *)(a1 + 56));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100928BC4(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_46:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_22:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        operator new();
      case 3u:
        *(unsigned char *)(a1 + 60) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 <= 0xFFFFFFFFFFFFFFF5 && v22 + 10 <= v23)
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          do
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              goto LABEL_45;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
          }
          while (!v14);
LABEL_41:
          LODWORD(v27) = 0;
          goto LABEL_45;
        }
        char v30 = 0;
        unsigned int v31 = 0;
        uint64_t v27 = 0;
        if (v23 <= v22) {
          unint64_t v23 = *((void *)this + 1);
        }
        break;
      case 4u:
        operator new();
      case 5u:
        operator new();
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v23 == v22)
      {
        LODWORD(v27) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_45;
      }
      unint64_t v32 = v22 + 1;
      char v33 = *(unsigned char *)(v24 + v22);
      *((void *)this + 1) = v32;
      v27 |= (unint64_t)(v33 & 0x7F) << v30;
      if ((v33 & 0x80) == 0) {
        break;
      }
      v30 += 7;
      unint64_t v22 = v32;
      BOOL v14 = v31++ > 8;
      if (v14) {
        goto LABEL_41;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v27) = 0;
    }
LABEL_45:
    *(_DWORD *)(a1 + 56) = v27;
    goto LABEL_46;
  }
  int v4 = 0;
  return v4 == 0;
}

void sub_100929080(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009290DC(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  uint64_t v5 = *(const PB::Data **)(v3 + 24);
  if (v5) {
    uint64_t result = PB::Writer::write(this, v5, 2u);
  }
  if (*(unsigned char *)(v3 + 60)) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 56), 3u);
  }
  if (*(void *)(v3 + 16)) {
    uint64_t result = PB::Writer::write();
  }
  uint64_t v7 = *(const PB::Base ***)(v3 + 32);
  uint64_t v6 = *(const PB::Base ***)(v3 + 40);
  while (v7 != v6)
  {
    uint64_t v8 = *v7++;
    uint64_t result = PB::Writer::writeSubmessage(this, v8, 5u);
  }
  return result;
}

uint64_t sub_10092917C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1009291F4((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1009291F4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v13[0] = a1;
  v13[1] = &v14;
  void v13[2] = &v15;
  v13[3] = 1;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    char v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v15 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v15;
  }
  sub_100929288((uint64_t)v13);
  return v11;
}

uint64_t sub_100929288(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100466070((void *)a1);
  }
  return a1;
}

void sub_1009292C0(os_log_t *a1@<X0>, Registry **a2@<X1>, uint64_t a3@<X2>, uint64_t **a4@<X3>, uint64_t a5@<X4>, NSObject **a6@<X5>, _OWORD *a7@<X8>)
{
  memset(&v47, 0, sizeof(v47));
  sub_100929CC8(&v47, a1, a2, a4);
  std::string::size_type v46 = 0;
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, v47.__r_.__value_.__l.__data_, v47.__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = v47;
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v49, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v49 = __dst;
  }
  v32.__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(__p, v49.__r_.__value_.__l.__data_, v49.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)&v49.__r_.__value_.__l.__data_;
    v44[0] = (void *)v49.__r_.__value_.__r.__words[2];
  }
  v33.__r_.__value_.__r.__words[0] = 0;
  if (ctu::cf::convert_copy())
  {
    std::string::size_type v12 = v32.__r_.__value_.__r.__words[0];
    v32.__r_.__value_.__r.__words[0] = v33.__r_.__value_.__r.__words[0];
    v48.__r_.__value_.__r.__words[0] = v12;
    sub_1000558F4((const void **)&v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44[0]) < 0) {
    operator delete(__p[0]);
  }
  std::string::size_type v46 = v32.__r_.__value_.__r.__words[0];
  v32.__r_.__value_.__r.__words[0] = 0;
  sub_1000558F4((const void **)&v32.__r_.__value_.__l.__data_);
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  memset(v44, 0, sizeof(v44));
  *(_OWORD *)std::string __p = 0u;
  (*(void (**)(void **__return_ptr))(**(void **)a3 + 32))(__p);
  std::string::size_type v42 = 0;
  if (SHIBYTE(v44[0]) < 0)
  {
    sub_10004FC84(&v41, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = *(_OWORD *)__p;
    v41.__r_.__value_.__r.__words[2] = (std::string::size_type)v44[0];
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v48, v41.__r_.__value_.__l.__data_, v41.__r_.__value_.__l.__size_);
  }
  else {
    std::string v48 = v41;
  }
  v31.__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v49, v48.__r_.__value_.__l.__data_, v48.__r_.__value_.__l.__size_);
  }
  else {
    std::string v49 = v48;
  }
  v32.__r_.__value_.__r.__words[0] = 0;
  if (ctu::cf::convert_copy())
  {
    std::string::size_type v13 = v31.__r_.__value_.__r.__words[0];
    v31.__r_.__value_.__r.__words[0] = v32.__r_.__value_.__r.__words[0];
    v33.__r_.__value_.__r.__words[0] = v13;
    sub_1000558F4((const void **)&v33.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  std::string::size_type v42 = v31.__r_.__value_.__r.__words[0];
  v31.__r_.__value_.__r.__words[0] = 0;
  sub_1000558F4((const void **)&v31.__r_.__value_.__l.__data_);
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  std::string::size_type v40 = 0;
  if (SHIBYTE(v44[3]) < 0) {
    sub_10004FC84(&v39, v44[1], (unint64_t)v44[2]);
  }
  else {
    std::string v39 = *(std::string *)&v44[1];
  }
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v48, v39.__r_.__value_.__l.__data_, v39.__r_.__value_.__l.__size_);
  }
  else {
    std::string v48 = v39;
  }
  v31.__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v49, v48.__r_.__value_.__l.__data_, v48.__r_.__value_.__l.__size_);
  }
  else {
    std::string v49 = v48;
  }
  v32.__r_.__value_.__r.__words[0] = 0;
  if (ctu::cf::convert_copy())
  {
    std::string::size_type v14 = v31.__r_.__value_.__r.__words[0];
    v31.__r_.__value_.__r.__words[0] = v32.__r_.__value_.__r.__words[0];
    v33.__r_.__value_.__r.__words[0] = v14;
    sub_1000558F4((const void **)&v33.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  std::string::size_type v40 = v31.__r_.__value_.__r.__words[0];
  v31.__r_.__value_.__r.__words[0] = 0;
  sub_1000558F4((const void **)&v31.__r_.__value_.__l.__data_);
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v39.__r_.__value_.__l.__data_);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  unsigned int v16 = ServiceMap;
  if ((v17 & 0x8000000000000000) != 0)
  {
    char v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      std::string::size_type v17 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(ServiceMap);
  v49.__r_.__value_.__r.__words[0] = v17;
  unint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)&v49);
  if (v21)
  {
    uint64_t v23 = v21[3];
    unint64_t v22 = (std::__shared_weak_count *)v21[4];
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v16);
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      char v24 = 0;
      goto LABEL_60;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  std::mutex::unlock(v16);
  unint64_t v22 = 0;
  char v24 = 1;
LABEL_60:
  CFStringRef theString = 0;
  uint64_t v25 = kDataUsageLocalizationTable;
  (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, std::string::size_type, uint64_t))(*(void *)v23 + 16))(&theString, v23, kDataUsageLocalizationTable, v42, 1);
  CFMutableStringRef v37 = 0;
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, theString);
  CFMutableStringRef v37 = MutableCopy;
  CFStringRef v27 = (const __CFString *)v46;
  v51.length = CFStringGetLength(MutableCopy);
  v51.location = 0;
  CFStringFindAndReplace(MutableCopy, @"%@", v27, v51, 0);
  std::string v36 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, std::string::size_type, uint64_t))(*(void *)v23 + 16))(&v36, v23, v25, v40, 1);
  unsigned __int8 v35 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v23 + 16))(&v35, v23, v25, @"OK", 1);
  long long v34 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v23 + 16))(&v34, v23, v25, @"SETTINGS", 1);
  memset(&v48, 0, sizeof(v48));
  memset(&v49, 0, sizeof(v49));
  ctu::cf::assign();
  std::string v48 = v49;
  memset(&v33, 0, sizeof(v33));
  memset(&v49, 0, sizeof(v49));
  ctu::cf::assign();
  std::string v33 = v49;
  memset(&v32, 0, sizeof(v32));
  memset(&v49, 0, sizeof(v49));
  ctu::cf::assign();
  std::string v32 = v49;
  memset(&v31, 0, sizeof(v31));
  memset(&v49, 0, sizeof(v49));
  ctu::cf::assign();
  std::string v31 = v49;
  unint64_t v28 = *a6;
  char v29 = operator new(0x78uLL);
  v29[1] = 0;
  void v29[2] = 0;
  *char v29 = off_1019AE920;
  uint64_t v30 = (uint64_t)(v29 + 3);
  dispatch_object_t v50 = v28;
  if (v28) {
    dispatch_retain(v28);
  }
  sub_1001D7B74(v30, (uint64_t)&v48, (uint64_t)&v33, (uint64_t)&v32, (uint64_t)&v31, &v50, a5);
  if (v50) {
    dispatch_release(v50);
  }
  v49.__r_.__value_.__r.__words[0] = (std::string::size_type)(v29 + 3);
  v49.__r_.__value_.__l.__size_ = (std::string::size_type)v29;
  sub_1000B3BC8((uint64_t)&v49, v29 + 4, v30);
  *a7 = *(_OWORD *)&v49.__r_.__value_.__l.__data_;
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v31.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  sub_1000558F4(&v34);
  sub_1000558F4(&v35);
  sub_1000558F4(&v36);
  sub_10028D988((const void **)&v37);
  sub_1000558F4((const void **)&theString);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  sub_1000558F4((const void **)&v40);
  sub_1000558F4((const void **)&v42);
  if (SHIBYTE(v44[3]) < 0) {
    operator delete(v44[1]);
  }
  if (SHIBYTE(v44[0]) < 0) {
    operator delete(__p[0]);
  }
  sub_1000558F4((const void **)&v46);
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v47.__r_.__value_.__l.__data_);
  }
}

void sub_100929A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,const void *a35,void *a36)
{
  sub_1000558F4(&a9);
  if (*(char *)(v37 - 121) < 0) {
    operator delete(*(void **)(v37 - 144));
  }
  if (a30 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a35);
  sub_1001085D8((uint64_t)&a36);
  sub_1000558F4((const void **)(v37 - 176));
  if (v36 < 0) {
    operator delete(*(void **)(v37 - 168));
  }
  _Unwind_Resume(a1);
}

void sub_100929CC8(std::string *a1, os_log_t *a2, Registry **a3, uint64_t **a4)
{
  uint64_t v8 = *a4;
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (a4[1] - v8);
  if (v10 != 1)
  {
    if (!v10)
    {
      a1->__r_.__value_.__r.__words[0] = 0;
      a1->__r_.__value_.__l.__size_ = 0;
      a1->__r_.__value_.__r.__words[2] = 0;
      return;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a3);
    std::string::size_type v12 = ServiceMap;
    if ((v13 & 0x8000000000000000) != 0)
    {
      std::string::size_type v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        std::string::size_type v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    buf.__r_.__value_.__r.__words[0] = v13;
    std::string::size_type v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&buf);
    if (v17)
    {
      uint64_t v19 = v17[3];
      char v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    char v18 = 0;
    char v20 = 1;
LABEL_15:
    unint64_t v21 = *a4;
    if ((char *)a4[1] - (char *)*a4 != 48)
    {
      memset(&buf, 0, sizeof(buf));
      sub_10092B054(&buf, a2, a3, v21);
      uint64_t v30 = (long long *)a4[1];
      std::string v31 = (long long *)(*a4 + 3);
      v64[1] = 0;
      int64_t v65 = 0;
      v64[0] = 0;
      sub_1000D92D4((char *)v64, v31, v30, 0xAAAAAAAAAAAAAAABLL * (((char *)v30 - (char *)v31) >> 3));
      int v32 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
      else {
        size_t size = buf.__r_.__value_.__l.__size_;
      }
      memset(&v63, 0, sizeof(v63));
      long long v34 = &v63;
      sub_1000C140C((uint64_t)&v63, size + 2);
      if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v34 = (std::string *)v63.__r_.__value_.__r.__words[0];
      }
      if (size)
      {
        if (v32 >= 0) {
          p_std::string buf = &buf;
        }
        else {
          p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        memmove(v34, p_buf, size);
      }
      strcpy((char *)v34 + size, ", ");
      sub_100929CC8(&__p, a2, a3, v64);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v37 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v37 = __p.__r_.__value_.__l.__size_;
      }
      unsigned __int8 v38 = std::string::append(&v63, (const std::string::value_type *)p_p, v37);
      *a1 = *v38;
      v38->__r_.__value_.__l.__size_ = 0;
      v38->__r_.__value_.__r.__words[2] = 0;
      v38->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
      v63.__r_.__value_.__r.__words[0] = (std::string::size_type)v64;
      sub_100047F64((void ***)&v63);
      if ((v32 & 0x80000000) == 0) {
        goto LABEL_104;
      }
      std::string v39 = (void *)buf.__r_.__value_.__r.__words[0];
      goto LABEL_103;
    }
    v64[0] = 0;
    v64[1] = 0;
    int64_t v65 = 0;
    sub_10092B054(v64, a2, a3, v21);
    memset(&v63, 0, sizeof(v63));
    sub_10092B054(&v63, a2, a3, *a4 + 3);
    std::string::size_type v22 = HIBYTE(v63.__r_.__value_.__r.__words[2]);
    int v23 = SHIBYTE(v63.__r_.__value_.__r.__words[2]);
    if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v22 = v63.__r_.__value_.__l.__size_;
    }
    char v24 = HIBYTE(v65);
    if (v22)
    {
      BOOL v25 = v65 < 0;
      if (v65 >= 0) {
        unsigned int v26 = (void *)HIBYTE(v65);
      }
      else {
        unsigned int v26 = v64[1];
      }
      if (!v26)
      {
        CFStringRef v27 = *a2;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v28 = *a4;
          if (*((char *)*a4 + 23) < 0) {
            unint64_t v28 = (uint64_t *)*v28;
          }
          char v29 = (std::string *)v63.__r_.__value_.__r.__words[0];
          if (v23 >= 0) {
            char v29 = &v63;
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v29;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Bundle %{public}s is localized empty, returning %{public}s", (uint8_t *)&buf, 0x16u);
        }
        *a1 = v63;
        memset(&v63, 0, sizeof(v63));
LABEL_99:
        if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v63.__r_.__value_.__l.__data_);
        }
        if ((SHIBYTE(v65) & 0x80000000) == 0) {
          goto LABEL_104;
        }
        std::string v39 = v64[0];
LABEL_103:
        operator delete(v39);
LABEL_104:
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        return;
      }
    }
    else
    {
      BOOL v25 = v65 < 0;
      std::string::size_type v40 = v64[1];
      if (v65 >= 0) {
        std::string::size_type v40 = (void *)HIBYTE(v65);
      }
      if (v40)
      {
        std::string v41 = *a2;
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          std::string::size_type v42 = *a4 + 3;
          if (*((char *)*a4 + 47) < 0) {
            std::string::size_type v42 = (void *)*v42;
          }
          uint64_t v43 = v64;
          if (v24 < 0) {
            uint64_t v43 = (void **)v64[0];
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v42;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v43;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Bundle %{public}s is localized empty, returning %{public}s", (uint8_t *)&buf, 0x16u);
        }
        *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)v64;
        a1->__r_.__value_.__r.__words[2] = v65;
        v64[1] = 0;
        int64_t v65 = 0;
        v64[0] = 0;
        goto LABEL_99;
      }
    }
    unsigned int v44 = *a2;
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      std::string v45 = (void **)v64[0];
      if (!v25) {
        std::string v45 = v64;
      }
      std::string::size_type v46 = (std::string *)v63.__r_.__value_.__r.__words[0];
      if (v23 >= 0) {
        std::string::size_type v46 = &v63;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v45;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v46;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Returning %{public}s & %{public}s", (uint8_t *)&buf, 0x16u);
    }
    uint64_t v62 = 0;
    (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v19 + 16))(&v62, v19, kDataUsageLocalizationTable, @"&", 1);
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string __p = buf;
    if (v65 >= 0) {
      size_t v47 = HIBYTE(v65);
    }
    else {
      size_t v47 = (size_t)v64[1];
    }
    memset(&v59, 0, sizeof(v59));
    std::string v48 = &v59;
    sub_1000C140C((uint64_t)&v59, v47 + 1);
    if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string v48 = (std::string *)v59.__r_.__value_.__r.__words[0];
    }
    if (v47)
    {
      if (v65 >= 0) {
        std::string v49 = v64;
      }
      else {
        std::string v49 = (void **)v64[0];
      }
      memmove(v48, v49, v47);
    }
    *(_WORD *)((char *)&v48->__r_.__value_.__l.__data_ + v47) = 32;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      dispatch_object_t v50 = &__p;
    }
    else {
      dispatch_object_t v50 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v51 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v51 = __p.__r_.__value_.__l.__size_;
    }
    signed int v52 = std::string::append(&v59, (const std::string::value_type *)v50, v51);
    long long v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v60.__r_.__value_.__r.__words[2] = v52->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0;
    v52->__r_.__value_.__r.__words[2] = 0;
    v52->__r_.__value_.__r.__words[0] = 0;
    char v54 = std::string::append(&v60, " ", 1uLL);
    long long v55 = *(_OWORD *)&v54->__r_.__value_.__l.__data_;
    buf.__r_.__value_.__r.__words[2] = v54->__r_.__value_.__r.__words[2];
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v55;
    v54->__r_.__value_.__l.__size_ = 0;
    v54->__r_.__value_.__r.__words[2] = 0;
    v54->__r_.__value_.__r.__words[0] = 0;
    if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v56 = &v63;
    }
    else {
      char v56 = (std::string *)v63.__r_.__value_.__r.__words[0];
    }
    if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v57 = HIBYTE(v63.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v57 = v63.__r_.__value_.__l.__size_;
    }
    int v58 = std::string::append(&buf, (const std::string::value_type *)v56, v57);
    *a1 = *v58;
    v58->__r_.__value_.__l.__size_ = 0;
    v58->__r_.__value_.__r.__words[2] = 0;
    v58->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v60.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v59.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_1000558F4(&v62);
    goto LABEL_99;
  }

  sub_10092B054(a1, a2, a3, v8);
}

void sub_10092A3D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,const void *a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (*(char *)(v44 - 105) < 0) {
    operator delete(*(void **)(v44 - 128));
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  sub_1000558F4(&a30);
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if ((v43 & 1) == 0) {
    sub_10004D2C8(v42);
  }
  _Unwind_Resume(a1);
}

void sub_10092A4F8(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x10092A4F0);
}

void sub_10092A508(os_log_t *a1@<X0>, Registry **a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t **a5@<X4>, dispatch_object_t *a6@<X5>, uint64_t a7@<X6>, _OWORD *a8@<X8>)
{
  memset(&v61, 0, sizeof(v61));
  sub_100929CC8(&v61, a1, a2, a5);
  CFStringRef v60 = 0;
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__p, v61.__r_.__value_.__l.__data_, v61.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v61;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else
  {
    long long __dst = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    v64[0] = *((void *)&__p.__r_.__value_.__l + 2);
  }
  v48[0] = 0;
  if (SHIBYTE(v64[0]) < 0)
  {
    sub_10004FC84(&v65, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v65 = __dst;
    v66[0] = v64[0];
  }
  v50[0] = 0;
  if (ctu::cf::convert_copy())
  {
    std::string::size_type v14 = v48[0];
    v48[0] = v50[0];
    v67[0] = v14;
    sub_1000558F4(v67);
  }
  if (SHIBYTE(v66[0]) < 0) {
    operator delete((void *)v65);
  }
  CFStringRef v60 = (const __CFString *)v48[0];
  v48[0] = 0;
  sub_1000558F4((const void **)v48);
  if (SHIBYTE(v64[0]) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  int v58 = 0;
  v67[0] = 0;
  *(void *)&long long __dst = 0;
  if (ctu::cf::convert_copy((ctu::cf *)&__dst, (const __CFString **)"ALLOW_DATA_FOR_APP_NAME", (const char *)0x8000100, kCFAllocatorDefault, v15))
  {
    unsigned int v16 = v67[0];
    v67[0] = (const void *)__dst;
    *(void *)&long long v65 = v16;
    sub_1000558F4((const void **)&v65);
  }
  int v58 = v67[0];
  v67[0] = 0;
  sub_1000558F4(v67);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  char v18 = ServiceMap;
  if (v19 < 0)
  {
    char v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v65 = v19;
  int v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&v65);
  std::string v39 = a8;
  std::string::size_type v40 = a6;
  if (v23)
  {
    int v24 = a4;
    uint64_t v25 = a7;
    uint64_t v27 = v23[3];
    unsigned int v26 = (std::__shared_weak_count *)v23[4];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v18);
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      unsigned __int8 v38 = v26;
      sub_10004D2C8(v26);
      char v28 = 0;
      a7 = v25;
      a4 = v24;
      goto LABEL_29;
    }
    a7 = v25;
    a4 = v24;
  }
  else
  {
    uint64_t v27 = 0;
  }
  std::mutex::unlock(v18);
  unsigned __int8 v38 = 0;
  char v28 = 1;
LABEL_29:
  CFStringRef theString = 0;
  uint64_t v29 = kDataUsageLocalizationTable;
  (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const void *, uint64_t))(*(void *)v27 + 16))(&theString, v27, kDataUsageLocalizationTable, v58, 1);
  CFMutableStringRef v56 = 0;
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, theString);
  CFMutableStringRef v56 = MutableCopy;
  CFStringRef v31 = v60;
  v69.length = CFStringGetLength(MutableCopy);
  v69.location = 0;
  CFStringFindAndReplace(MutableCopy, @"%@", v31, v69, 0);
  long long v55 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v27 + 16))(&v55, v27, v29, @"FUNCTIONALITY_WILL_NOT_WORK_ON_DATA_OFF", 1);
  CFStringRef v32 = sub_10092AEE0(*a2, a3);
  CFStringRef v33 = sub_10092AEE0(*a2, SHIDWORD(a3));
  CFStringRef v34 = sub_10092AEE0(*a2, a4);
  char v54 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v27 + 16))(&v54, v27, v29, v32, 1);
  long long v53 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v27 + 16))(&v53, v27, v29, v33, 1);
  signed int v52 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v27 + 16))(&v52, v27, v29, v34, 1);
  v50[0] = 0;
  v50[1] = 0;
  uint64_t v51 = 0;
  long long v65 = 0uLL;
  v66[0] = 0;
  ctu::cf::assign();
  *(_OWORD *)dispatch_object_t v50 = v65;
  uint64_t v51 = v66[0];
  v48[0] = 0;
  v48[1] = 0;
  uint64_t v49 = 0;
  long long v65 = 0uLL;
  v66[0] = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string v48 = v65;
  uint64_t v49 = v66[0];
  long long v65 = 0uLL;
  v66[0] = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string::size_type v46 = v65;
  uint64_t v47 = v66[0];
  long long v65 = 0uLL;
  v66[0] = 0;
  ctu::cf::assign();
  *(_OWORD *)uint64_t v44 = v65;
  uint64_t v45 = v66[0];
  long long v65 = 0uLL;
  v66[0] = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string::size_type v42 = v65;
  uint64_t v43 = v66[0];
  *(void *)&long long __dst = a3;
  DWORD2(__dst) = a4;
  sub_10092B500((uint64_t)v64, a7);
  unsigned __int8 v35 = operator new(0x80uLL);
  v35[1] = 0;
  v35[2] = 0;
  *unsigned __int8 v35 = off_101A1C830;
  dispatch_object_t v62 = *v40;
  if (v62) {
    dispatch_retain(v62);
  }
  *(void *)&long long v65 = __dst;
  DWORD2(v65) = DWORD2(__dst);
  sub_10092B500((uint64_t)v66, (uint64_t)v64);
  uint64_t v68 = 0;
  char v36 = operator new(0x38uLL);
  uint64_t v37 = v65;
  *char v36 = off_101A1C880;
  v36[1] = v37;
  *((_DWORD *)v36 + 4) = DWORD2(v65);
  sub_10092B500((uint64_t)(v36 + 3), (uint64_t)v66);
  uint64_t v68 = v36;
  sub_1001D7F24((uint64_t)(v35 + 3), (uint64_t)v50, (uint64_t)v48, (uint64_t)v46, (uint64_t)v44, (uint64_t)v42, &v62, (uint64_t)v67);
  sub_1000DA3EC(v67);
  sub_1000EADC8(v66);
  if (v62) {
    dispatch_release(v62);
  }
  *(void *)&long long v41 = v35 + 3;
  *((void *)&v41 + 1) = v35;
  sub_1000B3BC8((uint64_t)&v41, v35 + 4, (uint64_t)(v35 + 3));
  *std::string v39 = v41;
  long long v41 = 0uLL;
  sub_1000EADC8(v64);
  if (SHIBYTE(v43) < 0) {
    operator delete(v42[0]);
  }
  if (SHIBYTE(v45) < 0) {
    operator delete(v44[0]);
  }
  if (SHIBYTE(v47) < 0) {
    operator delete(v46[0]);
  }
  if (SHIBYTE(v49) < 0) {
    operator delete(v48[0]);
  }
  if (SHIBYTE(v51) < 0) {
    operator delete(v50[0]);
  }
  sub_1000558F4(&v52);
  sub_1000558F4(&v53);
  sub_1000558F4(&v54);
  sub_1000558F4(&v55);
  sub_10028D988((const void **)&v56);
  sub_1000558F4((const void **)&theString);
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v38);
  }
  sub_1000558F4(&v58);
  sub_1000558F4((const void **)&v60);
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v61.__r_.__value_.__l.__data_);
  }
}

void sub_10092AC44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,const void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  sub_1000558F4(&a27);
  if (*(char *)(v47 - 201) < 0) {
    operator delete(*(void **)(v47 - 224));
  }
  if (a46 < 0) {
    operator delete(__p);
  }
  if (v46 < 0) {
    operator delete(*(void **)(v47 - 256));
  }
  _Unwind_Resume(a1);
}

void sub_10092AEC4()
{
}

void sub_10092AED8()
{
}

CFStringRef sub_10092AEE0(Registry *a1, int a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1);
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, &v17);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 72))(v11);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (a2)
  {
    if (a2 != 1)
    {
      if (a2 == 2) {
        return @"DONT_ALLOW";
      }
      else {
        return 0;
      }
    }
    CFStringRef v15 = @"WIFI_ONLY";
    CFStringRef v16 = @"WLAN_ONLY";
  }
  else
  {
    CFStringRef v15 = @"WIFI_AND_CELLULAR";
    CFStringRef v16 = @"WLAN_AND_CELLULAR";
  }
  if (v13) {
    return v16;
  }
  else {
    return v15;
  }
}

void sub_10092B038(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10092B054(void *a1, os_log_t *a2, Registry **a3, uint64_t *a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a3);
  char v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v10;
  std::string::size_type v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (!v14)
  {
    std::mutex::unlock(v9);
    goto LABEL_9;
  }
  uint64_t v16 = v14[3];
  CFStringRef v15 = (std::__shared_weak_count *)v14[4];
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v9);
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
    if (!v16)
    {
      sub_10004D2C8(v15);
LABEL_9:
      unint64_t v17 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)a4 + 23) >= 0) {
          CFStringRef v33 = a4;
        }
        else {
          CFStringRef v33 = (uint64_t *)*a4;
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v33;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not get SBServicesInterface for localized application name for %{public}s", buf, 0xCu);
      }
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
      return;
    }
  }
  else
  {
    std::mutex::unlock(v9);
    if (!v16) {
      goto LABEL_9;
    }
  }
  CFStringRef theString = 0;
  (*(void (**)(CFStringRef *__return_ptr, uint64_t, uint64_t *))(*(void *)v16 + 40))(&theString, v16, a4);
  if (theString) {
    char v18 = sub_1000810B8;
  }
  else {
    char v18 = 0;
  }
  if (v18 && CFStringGetLength(theString) >= 1)
  {
    uint64_t v19 = (std::mutex *)Registry::getServiceMap(*a3);
    char v20 = v19;
    if (v21 < 0)
    {
      unsigned int v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v23 = 5381;
      do
      {
        uint64_t v21 = v23;
        unsigned int v24 = *v22++;
        uint64_t v23 = (33 * v23) ^ v24;
      }
      while (v24);
    }
    std::mutex::lock(v19);
    *(void *)std::string buf = v21;
    uint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
    if (v25)
    {
      uint64_t v27 = v25[3];
      unsigned int v26 = (std::__shared_weak_count *)v25[4];
      if (v26)
      {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v26);
        char v28 = 0;
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v27 = 0;
    }
    std::mutex::unlock(v20);
    unsigned int v26 = 0;
    char v28 = 1;
LABEL_29:
    CFStringRef v36 = 0;
    (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v27 + 16))(&v36, v27, kDataUsageLocalizationTable, @"QUOTED_STRING_TEMPLATE", 0);
    CFStringRef v30 = v36;
    if (v36) {
      CFStringRef v31 = sub_1000810B8;
    }
    else {
      CFStringRef v31 = 0;
    }
    if (!v31)
    {
      *(void *)std::string buf = @"%@";
      sub_100013168((const void **)&v36, (CFTypeRef *)buf);
      CFStringRef v30 = v36;
    }
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, v30);
    CFStringRef v32 = theString;
    v40.length = CFStringGetLength(MutableCopy);
    v40.location = 0;
    CFStringFindAndReplace(MutableCopy, @"%@", v32, v40, 0);
    memset(buf, 0, sizeof(buf));
    uint64_t v39 = 0;
    ctu::cf::assign();
    *(_OWORD *)a1 = *(_OWORD *)buf;
    a1[2] = v39;
    sub_10028D988((const void **)&MutableCopy);
    sub_1000558F4((const void **)&v36);
    if ((v28 & 1) == 0) {
      sub_10004D2C8(v26);
    }
    sub_1000558F4((const void **)&theString);
    if (!v15) {
      return;
    }
LABEL_25:
    sub_10004D2C8(v15);
    return;
  }
  sub_1000558F4((const void **)&theString);
  uint64_t v29 = *a2;
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a4 + 23) >= 0) {
      CFStringRef v34 = a4;
    }
    else {
      CFStringRef v34 = (uint64_t *)*a4;
    }
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v34;
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Localized application name for bundle %{public}s is empty!", buf, 0xCu);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (v15) {
    goto LABEL_25;
  }
}

void sub_10092B464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, const void *a12, const void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  sub_1000558F4(&a12);
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  sub_1000558F4(&a13);
  if (v19) {
    sub_10004D2C8(v19);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10092B500(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_10092B598(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A1C830;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10092B5B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1C830;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10092B60C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_10092B634(void *a1)
{
  *a1 = off_101A1C880;
  sub_1000EADC8(a1 + 3);
  return a1;
}

void sub_10092B678(void *a1)
{
  *a1 = off_101A1C880;
  sub_1000EADC8(a1 + 3);

  operator delete();
}

void *sub_10092B6DC(uint64_t a1)
{
  char v2 = operator new(0x38uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *char v2 = off_101A1C880;
  v2[1] = v3;
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
  sub_10092B500((uint64_t)(v2 + 3), a1 + 24);
  return v2;
}

void sub_10092B740(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10092B754(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1C880;
  uint64_t v2 = *(void *)(a1 + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(void *)(a2 + 8) = v2;
  return sub_10092B500(a2 + 24, a1 + 24);
}

void *sub_10092B790(uint64_t a1)
{
  return sub_1000EADC8((void *)(a1 + 24));
}

void sub_10092B798(void *a1)
{
  sub_1000EADC8(a1 + 3);

  operator delete(a1);
}

uint64_t sub_10092B7D4(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  switch(v2)
  {
    case 1:
      uint64_t v3 = (int *)(a1 + 8);
      goto LABEL_7;
    case 3:
      uint64_t v3 = (int *)(a1 + 16);
      goto LABEL_7;
    case 2:
      uint64_t v3 = (int *)(a1 + 12);
LABEL_7:
      int v4 = *v3;
      goto LABEL_9;
  }
  int v4 = 3;
LABEL_9:
  uint64_t v5 = *(void *)(a1 + 48);
  int v7 = v4;
  if (!v5) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)v5 + 48))(v5, &v7);
}

uint64_t sub_10092B864(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10092B8A4()
{
}

void *sub_10092B8B0(void *a1, void *a2, uint64_t a3)
{
  *a1 = off_101AB2248;
  uint64_t v5 = a1 + 1;
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  v8[0] = *a2;
  v8[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10132B1BC(v5, v8);
  if (v6) {
    sub_10004D2C8(v6);
  }
  *a1 = off_101A1C900;
  sub_1008B0378((uint64_t)(a1 + 4), a3);
  a1[152] = *(void *)(a3 + 1184);
  return a1;
}

void sub_10092B960(_Unwind_Exception *exception_object)
{
  if (*(void *)(v1 + 16)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10092B988(uint64_t a1, os_log_t *a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v8 = 0;
  if (!*(unsigned char *)(a1 + 88))
  {
    int v4 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v10 = "Config.xml";
      uint64_t v5 = "#I No version information of %s xml";
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 0xCu);
    }
    return 1;
  }
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2 <= 0)
  {
    int v4 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v10 = "Config.xml";
      uint64_t v5 = "#I Invalid validity of %s xml";
      goto LABEL_9;
    }
    return 1;
  }
  BOOL v3 = sub_10132B248(a1 + 8, v2, (uint64_t)__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  return v3;
}

void sub_10092BAB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10092BAD0(uint64_t a1)
{
  *(void *)a1 = off_101A1C900;
  sub_10020F4D8(a1 + 752);
  if (*(unsigned char *)(a1 + 744)) {
    sub_10005CD2C(a1 + 720, *(char **)(a1 + 728));
  }
  if (*(unsigned char *)(a1 + 680)) {
    sub_10020F650(a1 + 152);
  }
  sub_10020F7A4(a1 + 96);
  if (*(unsigned char *)(a1 + 64) && *(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10092BB68(uint64_t a1)
{
  *(void *)a1 = off_101A1C900;
  sub_10020F4D8(a1 + 752);
  if (*(unsigned char *)(a1 + 744)) {
    sub_10005CD2C(a1 + 720, *(char **)(a1 + 728));
  }
  if (*(unsigned char *)(a1 + 680)) {
    sub_10020F650(a1 + 152);
  }
  sub_10020F7A4(a1 + 96);
  if (*(unsigned char *)(a1 + 64) && *(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void sub_10092BC20(uint64_t a1, unsigned int a2, int a3, const char *a4, void **a5, void **a6, BOOL a7, BOOL a8)
{
  BOOL v9 = a7;
  uint64_t v10 = a6;
  uint64_t v11 = a5;
  uint64_t v12 = (void **)a4;
  uint64_t v15 = a1;
  if (!a2 || a2 == 3) {
    goto LABEL_86;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 80));
  char v20 = ServiceMap;
  if (v21 < 0)
  {
    unsigned int v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v21;
  uint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
  BOOL v9 = a7;
  if (v25)
  {
    unsigned int v26 = (std::__shared_weak_count *)v25[4];
    uint64_t v49 = v25[3];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v9 = a7;
      sub_10004D2C8(v26);
      char v47 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v49 = 0;
  }
  std::mutex::unlock(v20);
  unsigned int v26 = 0;
  char v47 = 1;
LABEL_11:
  uint64_t v10 = a6;
  uint64_t v27 = *(NSObject **)(a1 + 40);
  uint64_t v11 = a5;
  if (!v49)
  {
    uint64_t v12 = (void **)a4;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Invalid Analytics Interface. Not submitting metric.", buf, 2u);
    }
    goto LABEL_84;
  }
  uint64_t v12 = (void **)a4;
  if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = asString();
    if (a4[23] >= 0) {
      uint64_t v29 = a4;
    }
    else {
      uint64_t v29 = *(const char **)a4;
    }
    if (*((char *)v11 + 23) >= 0) {
      CFStringRef v30 = v11;
    }
    else {
      CFStringRef v30 = *v11;
    }
    if (*((char *)v10 + 23) >= 0) {
      CFStringRef v31 = v10;
    }
    else {
      CFStringRef v31 = *v10;
    }
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = v28;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v29;
    *(_WORD *)&unsigned char buf[22] = 2082;
    *(void *)&unsigned char buf[24] = v30;
    LOWORD(v109[0]) = 2082;
    *(void *)((char *)v109 + 2) = v31;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Filling metric details on bundle update info %s, %{public}s, %{public}s, %{public}s", buf, 0x2Au);
  }
  xpc_object_t v107 = 0;
  xpc_object_t v32 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v33 = v32;
  if (v32)
  {
    xpc_object_t v107 = v32;
  }
  else
  {
    xpc_object_t v33 = xpc_null_create();
    xpc_object_t v107 = v33;
    if (!v33)
    {
      xpc_object_t v34 = xpc_null_create();
      xpc_object_t v33 = 0;
      goto LABEL_32;
    }
  }
  if (xpc_get_type(v33) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v34 = xpc_null_create();
LABEL_32:
    xpc_object_t v107 = v34;
    goto LABEL_33;
  }
  xpc_retain(v33);
LABEL_33:
  xpc_release(v33);
  if (*((char *)v11 + 23) >= 0) {
    unsigned __int8 v35 = (const char *)v11;
  }
  else {
    unsigned __int8 v35 = (const char *)*v11;
  }
  xpc_object_t v105 = xpc_string_create(v35);
  if (!v105) {
    xpc_object_t v105 = xpc_null_create();
  }
  *(void *)std::string buf = &v107;
  *(void *)&uint8_t buf[8] = "bundle_file_name";
  sub_100035E70((uint64_t)buf, &v105, &v106);
  xpc_release(v106);
  xpc_object_t v106 = 0;
  xpc_release(v105);
  xpc_object_t v105 = 0;
  if (a4[23] >= 0) {
    CFStringRef v36 = a4;
  }
  else {
    CFStringRef v36 = *(const char **)a4;
  }
  xpc_object_t v103 = xpc_string_create(v36);
  if (!v103) {
    xpc_object_t v103 = xpc_null_create();
  }
  *(void *)std::string buf = &v107;
  *(void *)&uint8_t buf[8] = "bundle_name";
  sub_100035E70((uint64_t)buf, &v103, &v104);
  xpc_release(v104);
  xpc_object_t v104 = 0;
  xpc_release(v103);
  xpc_object_t v103 = 0;
  if (*((char *)v10 + 23) >= 0) {
    uint64_t v37 = (const char *)v10;
  }
  else {
    uint64_t v37 = (const char *)*v10;
  }
  xpc_object_t v101 = xpc_string_create(v37);
  if (!v101) {
    xpc_object_t v101 = xpc_null_create();
  }
  *(void *)std::string buf = &v107;
  *(void *)&uint8_t buf[8] = "bundle_version";
  sub_100035E70((uint64_t)buf, &v101, &v102);
  xpc_release(v102);
  xpc_object_t v102 = 0;
  xpc_release(v101);
  xpc_object_t v101 = 0;
  xpc_object_t object = xpc_BOOL_create(v9);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  *(void *)std::string buf = &v107;
  *(void *)&uint8_t buf[8] = "is_mandatory";
  sub_100035E70((uint64_t)buf, &object, &v100);
  xpc_release(v100);
  xpc_object_t v100 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  if ((a3 - 2) > 2) {
    int64_t v38 = 1;
  }
  else {
    int64_t v38 = qword_10150BFD0[(char)(a3 - 2)];
  }
  xpc_object_t v97 = xpc_int64_create(v38);
  if (!v97) {
    xpc_object_t v97 = xpc_null_create();
  }
  *(void *)std::string buf = &v107;
  *(void *)&uint8_t buf[8] = "bundle_type";
  sub_100035E70((uint64_t)buf, &v97, &v98);
  xpc_release(v98);
  xpc_object_t v98 = 0;
  xpc_release(v97);
  xpc_object_t v97 = 0;
  xpc_object_t v95 = xpc_BOOL_create(a8);
  if (!v95) {
    xpc_object_t v95 = xpc_null_create();
  }
  *(void *)std::string buf = &v107;
  *(void *)&uint8_t buf[8] = "is_buddy_active";
  sub_100035E70((uint64_t)buf, &v95, &v96);
  xpc_release(v96);
  xpc_object_t v96 = 0;
  xpc_release(v95);
  xpc_object_t v95 = 0;
  memset(buf, 0, 24);
  sub_10092C92C(buf, a2);
  if ((buf[23] & 0x80u) == 0) {
    uint64_t v39 = buf;
  }
  else {
    uint64_t v39 = *(uint8_t **)buf;
  }
  xpc_object_t v93 = xpc_string_create((const char *)v39);
  if (!v93) {
    xpc_object_t v93 = xpc_null_create();
  }
  CFBooleanRef v91 = &v107;
  int v92 = "result";
  sub_100035E70((uint64_t)&v91, &v93, &v94);
  xpc_release(v94);
  xpc_object_t v94 = 0;
  xpc_release(v93);
  xpc_object_t v93 = 0;
  uint64_t v40 = buf[23];
  if ((buf[23] & 0x80u) != 0) {
    uint64_t v40 = *(void *)&buf[8];
  }
  if (v40 == 6)
  {
    long long v41 = buf;
    if ((buf[23] & 0x80u) != 0) {
      long long v41 = *(uint8_t **)buf;
    }
    int v42 = *(_DWORD *)v41;
    int v43 = *((unsigned __int16 *)v41 + 2);
    if (v42 == 1818845510 && v43 == 25701)
    {
      if (a2 - 1 > 6) {
        int64_t v45 = 1;
      }
      else {
        int64_t v45 = qword_10150BFE8[(char)(a2 - 1)];
      }
      xpc_object_t v89 = xpc_int64_create(v45);
      if (!v89) {
        xpc_object_t v89 = xpc_null_create();
      }
      CFBooleanRef v91 = &v107;
      int v92 = "failureReason";
      sub_100035E70((uint64_t)&v91, &v89, &v90);
      xpc_release(v90);
      xpc_object_t v90 = 0;
      xpc_release(v89);
      xpc_object_t v89 = 0;
    }
  }
  xpc_object_t v88 = v107;
  if (v107) {
    xpc_retain(v107);
  }
  else {
    xpc_object_t v88 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v49 + 16))(v49, "commCenterBundleInstallDetails", &v88);
  xpc_release(v88);
  xpc_object_t v88 = 0;
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(v107);
LABEL_84:
  uint64_t v15 = a1;
  if ((v47 & 1) == 0) {
    sub_10004D2C8(v26);
  }
LABEL_86:
  uint64_t v110 = 0;
  memset(v109, 0, sizeof(v109));
  memset(buf, 0, sizeof(buf));
  buf[0] = a3;
  if (*((char *)v12 + 23) < 0)
  {
    sub_10004FC84(&buf[8], *v12, (unint64_t)v12[1]);
  }
  else
  {
    *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v12;
    *(void *)&unsigned char buf[24] = v12[2];
  }
  if (*((char *)v11 + 23) < 0)
  {
    sub_10004FC84(v109, *v11, (unint64_t)v11[1]);
  }
  else
  {
    v109[0] = *(_OWORD *)v11;
    *(void *)&v109[1] = v11[2];
  }
  if (*((char *)v10 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)&v109[1] + 8, *v10, (unint64_t)v10[1]);
  }
  else
  {
    *(_OWORD *)((char *)&v109[1] + 8) = *(_OWORD *)v10;
    *((void *)&v109[2] + 1) = v10[2];
  }
  uint64_t v110 = v15;
  if (a2 <= 7)
  {
    if (((1 << a2) & 0xC6) != 0)
    {
      uint64_t v72 = _NSConcreteStackBlock;
      uint64_t v73 = 1174405120;
      uint64_t v74 = sub_10092CA38;
      int v75 = &unk_101A1C960;
      uint64_t v76 = v15;
      char v85 = a2;
      uint8_t v77 = buf[0];
      char v46 = (void **)&v78;
      if ((char)buf[31] < 0)
      {
        sub_10004FC84(&v78, *(void **)&buf[8], *(unint64_t *)&buf[16]);
      }
      else
      {
        long long v78 = *(_OWORD *)&buf[8];
        uint64_t v79 = *(void *)&buf[24];
      }
      if (SBYTE7(v109[1]) < 0)
      {
        sub_10004FC84(&v80, *(void **)&v109[0], *((unint64_t *)&v109[0] + 1));
      }
      else
      {
        long long v80 = v109[0];
        uint64_t v81 = *(void *)&v109[1];
      }
      if (SHIBYTE(v109[2]) < 0)
      {
        sub_10004FC84(&__p, *((void **)&v109[1] + 1), *(unint64_t *)&v109[2]);
      }
      else
      {
        long long __p = *(_OWORD *)((char *)&v109[1] + 8);
        uint64_t v83 = *((void *)&v109[2] + 1);
      }
      uint64_t v84 = v110;
      BOOL v86 = v9;
      BOOL v87 = a8;
      sub_100527F38((wis::MetricFactory *)0x800DE);
      if (SHIBYTE(v83) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v81) < 0) {
        operator delete((void *)v80);
      }
      if (SHIBYTE(v79) < 0) {
LABEL_115:
      }
        operator delete(*v46);
    }
    else if (a2 == 4)
    {
      v61[0] = _NSConcreteStackBlock;
      v61[1] = 1174405120;
      v61[2] = sub_10092D10C;
      v61[3] = &unk_101A1C990;
      uint8_t v62 = buf[0];
      char v46 = (void **)&v63;
      if ((char)buf[31] < 0)
      {
        sub_10004FC84(&v63, *(void **)&buf[8], *(unint64_t *)&buf[16]);
      }
      else
      {
        long long v63 = *(_OWORD *)&buf[8];
        uint64_t v64 = *(void *)&buf[24];
      }
      if (SBYTE7(v109[1]) < 0)
      {
        sub_10004FC84(&v65, *(void **)&v109[0], *((unint64_t *)&v109[0] + 1));
      }
      else
      {
        long long v65 = v109[0];
        uint64_t v66 = *(void *)&v109[1];
      }
      if (SHIBYTE(v109[2]) < 0)
      {
        sub_10004FC84(&v67, *((void **)&v109[1] + 1), *(unint64_t *)&v109[2]);
      }
      else
      {
        long long v67 = *(_OWORD *)((char *)&v109[1] + 8);
        uint64_t v68 = *((void *)&v109[2] + 1);
      }
      uint64_t v69 = v110;
      BOOL v70 = v9;
      BOOL v71 = a8;
      sub_10092CF1C((wis::MetricFactory *)v61);
      if (SHIBYTE(v68) < 0) {
        operator delete((void *)v67);
      }
      if (SHIBYTE(v66) < 0) {
        operator delete((void *)v65);
      }
      if (SHIBYTE(v64) < 0) {
        goto LABEL_115;
      }
    }
    else if (a2 == 5)
    {
      v51[0] = _NSConcreteStackBlock;
      v51[1] = 1174405120;
      void v51[2] = sub_10092D41C;
      v51[3] = &unk_101A1C9C0;
      uint8_t v52 = buf[0];
      char v46 = (void **)&v53;
      if ((char)buf[31] < 0)
      {
        sub_10004FC84(&v53, *(void **)&buf[8], *(unint64_t *)&buf[16]);
      }
      else
      {
        long long v53 = *(_OWORD *)&buf[8];
        uint64_t v54 = *(void *)&buf[24];
      }
      if (SBYTE7(v109[1]) < 0)
      {
        sub_10004FC84(&v55, *(void **)&v109[0], *((unint64_t *)&v109[0] + 1));
      }
      else
      {
        long long v55 = v109[0];
        uint64_t v56 = *(void *)&v109[1];
      }
      if (SHIBYTE(v109[2]) < 0)
      {
        sub_10004FC84(&v57, *((void **)&v109[1] + 1), *(unint64_t *)&v109[2]);
      }
      else
      {
        long long v57 = *(_OWORD *)((char *)&v109[1] + 8);
        uint64_t v58 = *((void *)&v109[2] + 1);
      }
      uint64_t v59 = v110;
      BOOL v60 = a8;
      sub_10092D22C((wis::MetricFactory *)v51);
      if (SHIBYTE(v58) < 0) {
        operator delete((void *)v57);
      }
      if (SHIBYTE(v56) < 0) {
        operator delete((void *)v55);
      }
      if (SHIBYTE(v54) < 0) {
        goto LABEL_115;
      }
    }
  }
  if (SHIBYTE(v109[2]) < 0) {
    operator delete(*((void **)&v109[1] + 1));
  }
  if (SBYTE7(v109[1]) < 0) {
    operator delete(*(void **)&v109[0]);
  }
  if ((char)buf[31] < 0) {
    operator delete(*(void **)&buf[8]);
  }
}

void sub_10092C738(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_10092C92C(void *a1, unsigned int a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t result = sub_100058DB0(a1, "");
  if (a2 <= 7)
  {
    if (((1 << a2) & 0xC6) != 0)
    {
      if (*((char *)result + 23) < 0)
      {
        result[1] = 6;
        uint64_t result = (void *)*result;
      }
      else
      {
        *((unsigned char *)result + 23) = 6;
      }
      *((_WORD *)result + 2) = 25701;
      *(_DWORD *)uint64_t result = 1818845510;
      uint64_t result = (void *)((char *)result + 6);
    }
    else if (a2 == 4)
    {
      if (*((char *)result + 23) < 0)
      {
        result[1] = 9;
        uint64_t result = (void *)*result;
      }
      else
      {
        *((unsigned char *)result + 23) = 9;
      }
      *((unsigned char *)result + 8) = 100;
      void *result = *(void *)"Installed";
      uint64_t result = (void *)((char *)result + 9);
    }
    else
    {
      if (a2 != 5) {
        return result;
      }
      if (*((char *)result + 23) < 0)
      {
        result[1] = 8;
        uint64_t result = (void *)*result;
      }
      else
      {
        *((unsigned char *)result + 23) = 8;
      }
      *result++ = 0x64656E696C636544;
    }
    *(unsigned char *)uint64_t result = 0;
  }
  return result;
}

std::string *sub_10092CA38(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(_DWORD *)(a2 + 28);
  uint64_t v6 = *(int *)(a2 + 24);
  if ((int)v6 >= v5)
  {
    if (v5 == *(_DWORD *)(a2 + 32))
    {
      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 16), v5 + 1);
      int v5 = *(_DWORD *)(a2 + 28);
    }
    *(_DWORD *)(a2 + 28) = v5 + 1;
    sub_100528594();
  }
  uint64_t v7 = *(void *)(a2 + 16);
  *(_DWORD *)(a2 + 24) = v6 + 1;
  uint64_t v8 = *(void *)(v7 + 8 * v6);
  BOOL v9 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = 136315138;
    uint64_t v17 = asString();
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Submitting metric on update failure with failure reason: %s", (uint8_t *)&v16, 0xCu);
  }
  uint64_t result = sub_10092CBA4((unsigned __int8 *)(a1 + 40), v8);
  unsigned int v12 = *(unsigned __int8 *)(a1 + 128) - 1;
  if (v12 > 6) {
    int v13 = 1;
  }
  else {
    int v13 = dword_10150BFB0[(char)v12];
  }
  int v14 = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a2 + 40) = v13;
  *(unsigned char *)(a2 + 44) = *(unsigned char *)(a1 + 129);
  char v15 = *(unsigned char *)(a1 + 130);
  *(_DWORD *)(a2 + 52) = v14 | 0x1C;
  *(unsigned char *)(a2 + 45) = v15;
  return result;
}

std::string *sub_10092CBA4(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*((void *)a1 + 10) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = asString();
    uint64_t v6 = a1 + 8;
    if ((char)a1[31] < 0) {
      uint64_t v6 = (void *)*v6;
    }
    uint64_t v7 = a1 + 32;
    if ((char)a1[55] < 0) {
      uint64_t v7 = (void *)*v7;
    }
    uint64_t v8 = a1 + 56;
    if ((char)a1[79] < 0) {
      uint64_t v8 = (void *)*v8;
    }
    int v16 = 136446978;
    uint64_t v17 = v5;
    __int16 v18 = 2082;
    uint64_t v19 = v6;
    __int16 v20 = 2082;
    uint64_t v21 = v7;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Filling metric details on bundle update info %{public}s, %{public}s, %{public}s, %{public}s", (uint8_t *)&v16, 0x2Au);
  }
  unsigned int v9 = *a1 - 2;
  if (v9 > 2) {
    int v10 = 1;
  }
  else {
    int v10 = dword_10150C020[(char)v9];
  }
  int v11 = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 32) = v10;
  *(_DWORD *)(a2 + 40) = v11 | 3;
  unsigned int v12 = *(std::string **)(a2 + 8);
  if (v12 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v12, (const std::string *)(a1 + 8));
  *(_DWORD *)(a2 + 40) |= 4u;
  int v13 = *(std::string **)(a2 + 16);
  if (v13 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v13, (const std::string *)(a1 + 32));
  *(_DWORD *)(a2 + 40) |= 8u;
  int v14 = *(std::string **)(a2 + 24);
  if (v14 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  return std::string::operator=(v14, (const std::string *)(a1 + 56));
}

uint64_t sub_10092CDA8(uint64_t a1, uint64_t a2)
{
  return sub_10092CDB4(a1 + 40, a2 + 40);
}

uint64_t sub_10092CDB4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  uint64_t v6 = (unsigned char *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)uint64_t v6 = v7;
  }
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  return a1;
}

void sub_10092CE80(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10092CEB4(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 48);
    operator delete(v2);
  }
}

void sub_10092CF1C(wis::MetricFactory *a1)
{
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v2 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x800DDu);
  if (v2)
  {
    BOOL v3 = (wis::MetricContainer *)v2;
    long long v4 = sub_10001C8F4(8);
    uint64_t v6 = *v4;
    long long v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      operator new();
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
    wis::MetricContainer::~MetricContainer(v3);
    operator delete();
  }
}

void sub_10092D088(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

std::string *sub_10092D10C(unsigned __int8 *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 28);
  uint64_t v5 = *(int *)(a2 + 24);
  if ((int)v5 >= v4)
  {
    if (v4 == *(_DWORD *)(a2 + 32))
    {
      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 16), v4 + 1);
      int v4 = *(_DWORD *)(a2 + 28);
    }
    *(_DWORD *)(a2 + 28) = v4 + 1;
    sub_100528594();
  }
  uint64_t v6 = *(void *)(a2 + 16);
  *(_DWORD *)(a2 + 24) = v5 + 1;
  uint64_t result = sub_10092CBA4(a1 + 32, *(void *)(v6 + 8 * v5));
  int v8 = *(_DWORD *)(a2 + 48);
  *(unsigned char *)(a2 + 40) = a1[120];
  unsigned __int8 v9 = a1[121];
  *(_DWORD *)(a2 + 48) = v8 | 0xC;
  *(unsigned char *)(a2 + 41) = v9;
  return result;
}

uint64_t sub_10092D1B8(uint64_t a1, uint64_t a2)
{
  return sub_10092CDB4(a1 + 32, a2 + 32);
}

void sub_10092D1C4(uint64_t a1)
{
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

void sub_10092D22C(wis::MetricFactory *a1)
{
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v2 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x800DFu);
  if (v2)
  {
    BOOL v3 = (wis::MetricContainer *)v2;
    int v4 = sub_10001C8F4(8);
    uint64_t v6 = *v4;
    uint64_t v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      operator new();
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
    wis::MetricContainer::~MetricContainer(v3);
    operator delete();
  }
}

void sub_10092D398(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

std::string *sub_10092D41C(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 28);
  uint64_t v5 = *(int *)(a2 + 24);
  if ((int)v5 >= v4)
  {
    if (v4 == *(_DWORD *)(a2 + 32))
    {
      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 16), v4 + 1);
      int v4 = *(_DWORD *)(a2 + 28);
    }
    *(_DWORD *)(a2 + 28) = v4 + 1;
    sub_100528594();
  }
  uint64_t v6 = *(void *)(a2 + 16);
  *(_DWORD *)(a2 + 24) = v5 + 1;
  uint64_t result = sub_10092CBA4((unsigned __int8 *)(a1 + 32), *(void *)(v6 + 8 * v5));
  char v8 = *(unsigned char *)(a1 + 120);
  *(_DWORD *)(a2 + 48) |= 4u;
  *(unsigned char *)(a2 + 40) = v8;
  return result;
}

void sub_10092D4C0(uint64_t a1, unsigned int a2, int a3, void **a4, void **a5, void **a6, BOOL a7, BOOL a8)
{
  BOOL v9 = a7;
  if (a2 < 4 || a2 == 6) {
    goto LABEL_88;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 80));
  uint64_t v17 = ServiceMap;
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v18;
  __int16 v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)buf);
  BOOL v9 = a7;
  if (v22)
  {
    uint64_t v23 = (std::__shared_weak_count *)v22[4];
    uint64_t v45 = v22[3];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v9 = a7;
      sub_10004D2C8(v23);
      char v44 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v45 = 0;
  }
  std::mutex::unlock(v17);
  uint64_t v23 = 0;
  char v44 = 1;
LABEL_11:
  unsigned int v24 = *(NSObject **)(a1 + 40);
  if (!v45)
  {
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid Analytics Interface. Not submitting metric.", buf, 2u);
    }
    goto LABEL_86;
  }
  if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = asString();
    if (*((char *)a4 + 23) >= 0) {
      unsigned int v26 = a4;
    }
    else {
      unsigned int v26 = *a4;
    }
    if (*((char *)a5 + 23) >= 0) {
      uint64_t v27 = a5;
    }
    else {
      uint64_t v27 = *a5;
    }
    if (*((char *)a6 + 23) >= 0) {
      uint64_t v28 = a6;
    }
    else {
      uint64_t v28 = *a6;
    }
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = v25;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v26;
    *(_WORD *)&unsigned char buf[22] = 2082;
    *(void *)&unsigned char buf[24] = v27;
    LOWORD(v107[0]) = 2082;
    *(void *)((char *)v107 + 2) = v28;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Filling metric details on bundle update info %s, %{public}s, %{public}s, %{public}s", buf, 0x2Au);
  }
  xpc_object_t v105 = 0;
  xpc_object_t v29 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v30 = v29;
  if (v29)
  {
    xpc_object_t v105 = v29;
  }
  else
  {
    xpc_object_t v30 = xpc_null_create();
    xpc_object_t v105 = v30;
    if (!v30)
    {
      xpc_object_t v31 = xpc_null_create();
      xpc_object_t v30 = 0;
      goto LABEL_32;
    }
  }
  if (xpc_get_type(v30) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v31 = xpc_null_create();
LABEL_32:
    xpc_object_t v105 = v31;
    goto LABEL_33;
  }
  xpc_retain(v30);
LABEL_33:
  xpc_release(v30);
  if (*((char *)a5 + 23) >= 0) {
    xpc_object_t v32 = (const char *)a5;
  }
  else {
    xpc_object_t v32 = (const char *)*a5;
  }
  xpc_object_t v103 = xpc_string_create(v32);
  if (!v103) {
    xpc_object_t v103 = xpc_null_create();
  }
  *(void *)std::string buf = &v105;
  *(void *)&uint8_t buf[8] = "bundle_file_name";
  sub_100035E70((uint64_t)buf, &v103, &v104);
  xpc_release(v104);
  xpc_object_t v104 = 0;
  xpc_release(v103);
  xpc_object_t v103 = 0;
  if (*((char *)a4 + 23) >= 0) {
    xpc_object_t v33 = (const char *)a4;
  }
  else {
    xpc_object_t v33 = (const char *)*a4;
  }
  xpc_object_t v101 = xpc_string_create(v33);
  if (!v101) {
    xpc_object_t v101 = xpc_null_create();
  }
  *(void *)std::string buf = &v105;
  *(void *)&uint8_t buf[8] = "bundle_name";
  sub_100035E70((uint64_t)buf, &v101, &v102);
  xpc_release(v102);
  xpc_object_t v102 = 0;
  xpc_release(v101);
  xpc_object_t v101 = 0;
  if (*((char *)a6 + 23) >= 0) {
    xpc_object_t v34 = (const char *)a6;
  }
  else {
    xpc_object_t v34 = (const char *)*a6;
  }
  xpc_object_t v99 = xpc_string_create(v34);
  if (!v99) {
    xpc_object_t v99 = xpc_null_create();
  }
  *(void *)std::string buf = &v105;
  *(void *)&uint8_t buf[8] = "bundle_version";
  sub_100035E70((uint64_t)buf, &v99, &v100);
  xpc_release(v100);
  xpc_object_t v100 = 0;
  xpc_release(v99);
  xpc_object_t v99 = 0;
  xpc_object_t object = xpc_BOOL_create(v9);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  *(void *)std::string buf = &v105;
  *(void *)&uint8_t buf[8] = "is_mandatory";
  sub_100035E70((uint64_t)buf, &object, &v98);
  xpc_release(v98);
  xpc_object_t v98 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  if ((a3 - 2) > 2) {
    int64_t v35 = 1;
  }
  else {
    int64_t v35 = qword_10150BFD0[(char)(a3 - 2)];
  }
  xpc_object_t v95 = xpc_int64_create(v35);
  if (!v95) {
    xpc_object_t v95 = xpc_null_create();
  }
  *(void *)std::string buf = &v105;
  *(void *)&uint8_t buf[8] = "bundle_type";
  sub_100035E70((uint64_t)buf, &v95, &v96);
  xpc_release(v96);
  xpc_object_t v96 = 0;
  xpc_release(v95);
  xpc_object_t v95 = 0;
  memset(buf, 0, 24);
  sub_10092C92C(buf, a2);
  if ((buf[23] & 0x80u) == 0) {
    CFStringRef v36 = buf;
  }
  else {
    CFStringRef v36 = *(uint8_t **)buf;
  }
  xpc_object_t v93 = xpc_string_create((const char *)v36);
  BOOL v9 = a7;
  if (!v93) {
    xpc_object_t v93 = xpc_null_create();
  }
  CFBooleanRef v91 = &v105;
  int v92 = "result";
  sub_100035E70((uint64_t)&v91, &v93, &v94);
  xpc_release(v94);
  xpc_object_t v94 = 0;
  xpc_release(v93);
  xpc_object_t v93 = 0;
  uint64_t v37 = buf[23];
  if ((buf[23] & 0x80u) != 0) {
    uint64_t v37 = *(void *)&buf[8];
  }
  if (v37 == 6)
  {
    int64_t v38 = buf;
    if ((buf[23] & 0x80u) != 0) {
      int64_t v38 = *(uint8_t **)buf;
    }
    int v39 = *(_DWORD *)v38;
    int v40 = *((unsigned __int16 *)v38 + 2);
    if (v39 == 1818845510 && v40 == 25701)
    {
      if (a2 - 1 > 6) {
        int64_t v42 = 1;
      }
      else {
        int64_t v42 = qword_10150BFE8[(char)(a2 - 1)];
      }
      xpc_object_t v89 = xpc_int64_create(v42);
      if (!v89) {
        xpc_object_t v89 = xpc_null_create();
      }
      CFBooleanRef v91 = &v105;
      int v92 = "failureReason";
      sub_100035E70((uint64_t)&v91, &v89, &v90);
      xpc_release(v90);
      xpc_object_t v90 = 0;
      xpc_release(v89);
      xpc_object_t v89 = 0;
    }
  }
  xpc_object_t v87 = xpc_BOOL_create(1);
  if (!v87) {
    xpc_object_t v87 = xpc_null_create();
  }
  CFBooleanRef v91 = &v105;
  int v92 = "is_desktop_host";
  sub_100035E70((uint64_t)&v91, &v87, &v88);
  xpc_release(v88);
  xpc_object_t v88 = 0;
  xpc_release(v87);
  xpc_object_t v87 = 0;
  xpc_object_t v85 = xpc_BOOL_create(a8);
  if (!v85) {
    xpc_object_t v85 = xpc_null_create();
  }
  CFBooleanRef v91 = &v105;
  int v92 = "is_store_activation_mode_enabled_on_desktop";
  sub_100035E70((uint64_t)&v91, &v85, &v86);
  xpc_release(v86);
  xpc_object_t v86 = 0;
  xpc_release(v85);
  xpc_object_t v84 = v105;
  xpc_object_t v85 = 0;
  if (v105) {
    xpc_retain(v105);
  }
  else {
    xpc_object_t v84 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v45 + 16))(v45, "commCenterBundleInstallDetails", &v84);
  xpc_release(v84);
  xpc_object_t v84 = 0;
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(v105);
LABEL_86:
  if ((v44 & 1) == 0) {
    sub_10004D2C8(v23);
  }
LABEL_88:
  uint64_t v108 = 0;
  memset(v107, 0, sizeof(v107));
  memset(buf, 0, sizeof(buf));
  buf[0] = a3;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(&buf[8], *a4, (unint64_t)a4[1]);
  }
  else
  {
    *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)a4;
    *(void *)&unsigned char buf[24] = a4[2];
  }
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(v107, *a5, (unint64_t)a5[1]);
  }
  else
  {
    v107[0] = *(_OWORD *)a5;
    *(void *)&v107[1] = a5[2];
  }
  if (*((char *)a6 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)&v107[1] + 8, *a6, (unint64_t)a6[1]);
  }
  else
  {
    *(_OWORD *)((char *)&v107[1] + 8) = *(_OWORD *)a6;
    *((void *)&v107[2] + 1) = a6[2];
  }
  uint64_t v108 = a1;
  switch(a2)
  {
    case 4u:
      v57[0] = _NSConcreteStackBlock;
      v57[1] = 1174405120;
      v57[2] = sub_10092E6B0;
      v57[3] = &unk_101A1CA20;
      uint8_t v58 = buf[0];
      int v43 = (void **)&v59;
      if ((char)buf[31] < 0)
      {
        sub_10004FC84(&v59, *(void **)&buf[8], *(unint64_t *)&buf[16]);
      }
      else
      {
        long long v59 = *(_OWORD *)&buf[8];
        uint64_t v60 = *(void *)&buf[24];
      }
      if (SBYTE7(v107[1]) < 0)
      {
        sub_10004FC84(&v61, *(void **)&v107[0], *((unint64_t *)&v107[0] + 1));
      }
      else
      {
        long long v61 = v107[0];
        uint64_t v62 = *(void *)&v107[1];
      }
      if (SHIBYTE(v107[2]) < 0)
      {
        sub_10004FC84(&v63, *((void **)&v107[1] + 1), *(unint64_t *)&v107[2]);
      }
      else
      {
        long long v63 = *(_OWORD *)((char *)&v107[1] + 8);
        uint64_t v64 = *((void *)&v107[2] + 1);
      }
      uint64_t v65 = v108;
      BOOL v66 = a8;
      BOOL v67 = v9;
      sub_10092CF1C((wis::MetricFactory *)v57);
      if (SHIBYTE(v64) < 0) {
        operator delete((void *)v63);
      }
      if (SHIBYTE(v62) < 0) {
        operator delete((void *)v61);
      }
      if (SHIBYTE(v60) < 0) {
        goto LABEL_137;
      }
      break;
    case 5u:
      v47[0] = _NSConcreteStackBlock;
      v47[1] = 1174405120;
      v47[2] = sub_10092E7DC;
      v47[3] = &unk_101A1CA50;
      uint8_t v48 = buf[0];
      int v43 = (void **)&v49;
      if ((char)buf[31] < 0)
      {
        sub_10004FC84(&v49, *(void **)&buf[8], *(unint64_t *)&buf[16]);
      }
      else
      {
        long long v49 = *(_OWORD *)&buf[8];
        uint64_t v50 = *(void *)&buf[24];
      }
      if (SBYTE7(v107[1]) < 0)
      {
        sub_10004FC84(&v51, *(void **)&v107[0], *((unint64_t *)&v107[0] + 1));
      }
      else
      {
        long long v51 = v107[0];
        uint64_t v52 = *(void *)&v107[1];
      }
      if (SHIBYTE(v107[2]) < 0)
      {
        sub_10004FC84(&__p, *((void **)&v107[1] + 1), *(unint64_t *)&v107[2]);
      }
      else
      {
        long long __p = *(_OWORD *)((char *)&v107[1] + 8);
        uint64_t v54 = *((void *)&v107[2] + 1);
      }
      uint64_t v55 = v108;
      BOOL v56 = a8;
      sub_10092D22C((wis::MetricFactory *)v47);
      if (SHIBYTE(v54) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v52) < 0) {
        operator delete((void *)v51);
      }
      if (SHIBYTE(v50) < 0) {
        goto LABEL_137;
      }
      break;
    case 7u:
      uint64_t v68 = _NSConcreteStackBlock;
      uint64_t v69 = 1174405120;
      BOOL v70 = sub_10092E1EC;
      BOOL v71 = &unk_101A1C9F0;
      uint64_t v72 = a1;
      char v81 = 7;
      uint8_t v73 = buf[0];
      int v43 = (void **)&v74;
      if ((char)buf[31] < 0)
      {
        sub_10004FC84(&v74, *(void **)&buf[8], *(unint64_t *)&buf[16]);
      }
      else
      {
        long long v74 = *(_OWORD *)&buf[8];
        uint64_t v75 = *(void *)&buf[24];
      }
      if (SBYTE7(v107[1]) < 0)
      {
        sub_10004FC84(&v76, *(void **)&v107[0], *((unint64_t *)&v107[0] + 1));
      }
      else
      {
        long long v76 = v107[0];
        uint64_t v77 = *(void *)&v107[1];
      }
      if (SHIBYTE(v107[2]) < 0)
      {
        sub_10004FC84(&v78, *((void **)&v107[1] + 1), *(unint64_t *)&v107[2]);
      }
      else
      {
        long long v78 = *(_OWORD *)((char *)&v107[1] + 8);
        uint64_t v79 = *((void *)&v107[2] + 1);
      }
      uint64_t v80 = v108;
      BOOL v82 = a8;
      BOOL v83 = v9;
      sub_100527F38((wis::MetricFactory *)0x800DE);
      if (SHIBYTE(v79) < 0) {
        operator delete((void *)v78);
      }
      if (SHIBYTE(v77) < 0) {
        operator delete((void *)v76);
      }
      if (SHIBYTE(v75) < 0) {
LABEL_137:
      }
        operator delete(*v43);
      break;
  }
  if (SHIBYTE(v107[2]) < 0) {
    operator delete(*((void **)&v107[1] + 1));
  }
  if (SBYTE7(v107[1]) < 0) {
    operator delete(*(void **)&v107[0]);
  }
  if ((char)buf[31] < 0) {
    operator delete(*(void **)&buf[8]);
  }
}

void sub_10092DFE8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10092E1B4()
{
  if (*(char *)(v0 - 137) < 0) {
    operator delete(*(void **)(v0 - 160));
  }
  if (*(char *)(v0 - 161) < 0) {
    operator delete(*(void **)(v0 - 184));
  }
  JUMPOUT(0x10092E1ACLL);
}

void sub_10092E1E4()
{
}

std::string *sub_10092E1EC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(_DWORD *)(a2 + 28);
  uint64_t v6 = *(int *)(a2 + 24);
  if ((int)v6 >= v5)
  {
    if (v5 == *(_DWORD *)(a2 + 32))
    {
      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 16), v5 + 1);
      int v5 = *(_DWORD *)(a2 + 28);
    }
    *(_DWORD *)(a2 + 28) = v5 + 1;
    sub_100528594();
  }
  uint64_t v7 = *(void *)(a2 + 16);
  *(_DWORD *)(a2 + 24) = v6 + 1;
  uint64_t v8 = *(void *)(v7 + 8 * v6);
  BOOL v9 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 136315138;
    uint64_t v15 = asString();
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Submitting metric on desktop update failure with failure reason: %s", (uint8_t *)&v14, 0xCu);
  }
  uint64_t result = sub_10092E338((unsigned __int8 *)(a1 + 40), v8);
  int v12 = *(_DWORD *)(a2 + 52);
  *(unsigned char *)(a2 + 46) = 1;
  *(unsigned char *)(a2 + 47) = *(unsigned char *)(a1 + 129);
  char v13 = *(unsigned char *)(a1 + 130);
  *(_DWORD *)(a2 + 52) = v12 | 0x64;
  *(unsigned char *)(a2 + 44) = v13;
  return result;
}

std::string *sub_10092E338(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*((void *)a1 + 10) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = asString();
    uint64_t v6 = a1 + 8;
    if ((char)a1[31] < 0) {
      uint64_t v6 = (void *)*v6;
    }
    uint64_t v7 = a1 + 32;
    if ((char)a1[55] < 0) {
      uint64_t v7 = (void *)*v7;
    }
    uint64_t v8 = a1 + 56;
    if ((char)a1[79] < 0) {
      uint64_t v8 = (void *)*v8;
    }
    int v16 = 136446978;
    uint64_t v17 = v5;
    __int16 v18 = 2082;
    uint64_t v19 = v6;
    __int16 v20 = 2082;
    unsigned int v21 = v7;
    __int16 v22 = 2082;
    uint64_t v23 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Filling metric details on bundle update info %{public}s, %{public}s, %{public}s, %{public}s", (uint8_t *)&v16, 0x2Au);
  }
  unsigned int v9 = *a1 - 2;
  if (v9 > 2) {
    int v10 = 1;
  }
  else {
    int v10 = dword_10150C020[(char)v9];
  }
  int v11 = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 32) = v10;
  *(_DWORD *)(a2 + 40) = v11 | 3;
  int v12 = *(std::string **)(a2 + 8);
  if (v12 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v12, (const std::string *)(a1 + 8));
  *(_DWORD *)(a2 + 40) |= 4u;
  char v13 = *(std::string **)(a2 + 16);
  if (v13 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v13, (const std::string *)(a1 + 32));
  *(_DWORD *)(a2 + 40) |= 8u;
  int v14 = *(std::string **)(a2 + 24);
  if (v14 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  return std::string::operator=(v14, (const std::string *)(a1 + 56));
}

uint64_t sub_10092E53C(uint64_t a1, uint64_t a2)
{
  return sub_10092E548(a1 + 40, a2 + 40);
}

uint64_t sub_10092E548(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  uint64_t v6 = (unsigned char *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)uint64_t v6 = v7;
  }
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  return a1;
}

void sub_10092E614(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10092E648(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 48);
    operator delete(v2);
  }
}

std::string *sub_10092E6B0(unsigned __int8 *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 28);
  uint64_t v5 = *(int *)(a2 + 24);
  if ((int)v5 >= v4)
  {
    if (v4 == *(_DWORD *)(a2 + 32))
    {
      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 16), v4 + 1);
      int v4 = *(_DWORD *)(a2 + 28);
    }
    *(_DWORD *)(a2 + 28) = v4 + 1;
    sub_100528594();
  }
  uint64_t v6 = *(void *)(a2 + 16);
  *(_DWORD *)(a2 + 24) = v5 + 1;
  uint64_t result = sub_10092E338(a1 + 32, *(void *)(v6 + 8 * v5));
  int v8 = *(_DWORD *)(a2 + 48);
  *(unsigned char *)(a2 + 42) = 1;
  *(unsigned char *)(a2 + 43) = a1[120];
  unsigned __int8 v9 = a1[121];
  *(_DWORD *)(a2 + 48) = v8 | 0x34;
  *(unsigned char *)(a2 + 40) = v9;
  return result;
}

uint64_t sub_10092E768(uint64_t a1, uint64_t a2)
{
  return sub_10092E548(a1 + 32, a2 + 32);
}

void sub_10092E774(uint64_t a1)
{
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

std::string *sub_10092E7DC(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 28);
  uint64_t v5 = *(int *)(a2 + 24);
  if ((int)v5 >= v4)
  {
    if (v4 == *(_DWORD *)(a2 + 32))
    {
      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 16), v4 + 1);
      int v4 = *(_DWORD *)(a2 + 28);
    }
    *(_DWORD *)(a2 + 28) = v4 + 1;
    sub_100528594();
  }
  uint64_t v6 = *(void *)(a2 + 16);
  *(_DWORD *)(a2 + 24) = v5 + 1;
  uint64_t result = sub_10092E338((unsigned __int8 *)(a1 + 32), *(void *)(v6 + 8 * v5));
  int v8 = *(_DWORD *)(a2 + 48);
  *(unsigned char *)(a2 + 41) = 1;
  char v9 = *(unsigned char *)(a1 + 120);
  *(_DWORD *)(a2 + 48) = v8 | 0x18;
  *(unsigned char *)(a2 + 42) = v9;
  return result;
}

const char *sub_10092E888(int a1)
{
  uint64_t v1 = "lazuli.msg.ctr.?";
  if (a1 == 2) {
    uint64_t v1 = "lazuli.msg.ctr.2";
  }
  if (a1 == 1) {
    return "lazuli.msg.ctr.1";
  }
  else {
    return v1;
  }
}

void sub_10092E8B4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Powering on", buf, 2u);
  }
  sub_100058DB0(__p, "/cc/props/lazuli_client_state");
  BOOL v3 = (uint8_t *)operator new(0x28uLL);
  *(void *)BOOL v3 = off_101A1CE90;
  *((void *)v3 + 1) = a1 + 136;
  *((void *)v3 + 2) = a1;
  *((void *)v3 + 3) = sub_10092EC90;
  *((void *)v3 + 4) = 0;
  char v13 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/lazuli_registration_initializer");
  int v4 = (uint8_t *)operator new(0x28uLL);
  *(void *)int v4 = off_101A1CF10;
  *((void *)v4 + 1) = a1 + 184;
  *((void *)v4 + 2) = a1;
  *((void *)v4 + 3) = sub_10092EF68;
  *((void *)v4 + 4) = 0;
  char v13 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/lazuli_provisioning_initializer");
  uint64_t v5 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v5 = off_101A1CF90;
  *((void *)v5 + 1) = a1 + 208;
  *((void *)v5 + 2) = a1;
  *((void *)v5 + 3) = sub_10092F038;
  *((void *)v5 + 4) = 0;
  char v13 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/lazuli_registration_state");
  uint64_t v6 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v6 = off_101A1D010;
  *((void *)v6 + 1) = a1 + 312;
  *((void *)v6 + 2) = a1;
  *((void *)v6 + 3) = sub_10092F108;
  *((void *)v6 + 4) = 0;
  char v13 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/lazuli_messaging_information");
  *(void *)std::string buf = off_101A1D090;
  uint64_t v12 = a1 + 232;
  char v13 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/lazuli_info_ready");
  *(void *)std::string buf = off_101A1D110;
  uint64_t v12 = a1 + 160;
  char v13 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  if ((ctu::RestModule::isConnected((ctu::RestModule *)(a1 + 64)) & 1) == 0)
  {
    Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(a1 + 80));
    ctu::RestModule::connect();
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
}

void sub_10092EC28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10092EC90(uint64_t a1, void *a2)
{
  uint64_t v4 = a1 + 136;
  uint64_t v5 = *(void ***)(a1 + 136);
  uint64_t v6 = (void **)(a1 + 144);
  if (v5 != (void **)(a1 + 144))
  {
    do
    {
      uint64_t v7 = SlotIdFromPersonalityId();
      if (isReal())
      {
        if (*((unsigned char *)v5 + 56))
        {
          int v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            char v9 = (void *)*((unsigned __int8 *)v5 + 55);
            BOOL v10 = (char)v9 < 0;
            if ((char)v9 < 0) {
              char v9 = v5[5];
            }
            if (v10) {
              int v11 = (const char *)v5[4];
            }
            else {
              int v11 = (const char *)(v5 + 4);
            }
            BOOL v12 = v9 == 0;
            char v13 = "<invalid>";
            if (!v12) {
              char v13 = v11;
            }
            *(_DWORD *)std::string buf = 136315138;
            uint64_t v28 = v13;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Adding IMS delegate: %s", buf, 0xCu);
          }
          sub_10093127C(a1, (uint64_t)(v5 + 4));
        }
        else
        {
          sub_100931798(a1, v5 + 4);
        }
      }
      int v14 = (void **)v5[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          int v14 = (void **)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void **)v5[2];
          BOOL v12 = *v15 == v5;
          uint64_t v5 = v15;
        }
        while (!v12);
      }
      uint64_t v5 = v15;
    }
    while (v15 != v6);
  }
  __int16 v18 = (void *)*a2;
  int v16 = a2 + 1;
  uint64_t v17 = v18;
  if (v18 != v16)
  {
    do
    {
      if (v6 == sub_100046F68(v4, (void **)v17 + 4))
      {
        uint64_t v19 = SlotIdFromPersonalityId();
        __int16 v20 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v19);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = *((unsigned __int8 *)v17 + 55);
          BOOL v22 = (v21 & 0x80u) != 0;
          if ((v21 & 0x80u) != 0) {
            uint64_t v21 = v17[5];
          }
          if (v22) {
            uint64_t v23 = (const char *)v17[4];
          }
          else {
            uint64_t v23 = (const char *)(v17 + 4);
          }
          BOOL v12 = v21 == 0;
          unsigned int v24 = "<invalid>";
          if (!v12) {
            unsigned int v24 = v23;
          }
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v28 = v24;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Removing IMS delegate: personality removed from: %s", buf, 0xCu);
        }
        sub_100931798(a1, (void **)v17 + 4);
      }
      uint64_t v25 = (void *)v17[1];
      if (v25)
      {
        do
        {
          unsigned int v26 = v25;
          uint64_t v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          unsigned int v26 = (void *)v17[2];
          BOOL v12 = *v26 == (void)v17;
          uint64_t v17 = v26;
        }
        while (!v12);
      }
      uint64_t v17 = v26;
    }
    while (v26 != v16);
  }
}

void sub_10092EF68(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a1 + 184);
  BOOL v3 = (unsigned __int8 *)(a1 + 192);
  if (v2 != (unsigned __int8 *)(a1 + 192))
  {
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      uint64_t v7 = *((unsigned int *)v2 + 8);
      int v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          int v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_15;
      }
      if ((sub_1007ACBA8((unsigned __int8 *)v8 + 40, v2 + 40) & 1) == 0) {
        break;
      }
LABEL_16:
      BOOL v12 = (unsigned __int8 *)*((void *)v2 + 1);
      if (v12)
      {
        do
        {
          char v13 = v12;
          BOOL v12 = *(unsigned __int8 **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          char v13 = (unsigned __int8 *)*((void *)v2 + 2);
          BOOL v14 = *(void *)v13 == (void)v2;
          uint64_t v2 = v13;
        }
        while (!v14);
      }
      uint64_t v2 = v13;
      if (v13 == v3) {
        return;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 8);
LABEL_15:
    sub_10092F4E8(a1, v7);
    goto LABEL_16;
  }
}

void sub_10092F038(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a1 + 208);
  BOOL v3 = (unsigned __int8 *)(a1 + 216);
  if (v2 != (unsigned __int8 *)(a1 + 216))
  {
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      uint64_t v7 = *((unsigned int *)v2 + 8);
      int v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          int v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_15;
      }
      if (!sub_1007ABCE8((unsigned __int8 *)v8 + 40, v2 + 40)) {
        break;
      }
LABEL_16:
      BOOL v12 = (unsigned __int8 *)*((void *)v2 + 1);
      if (v12)
      {
        do
        {
          char v13 = v12;
          BOOL v12 = *(unsigned __int8 **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          char v13 = (unsigned __int8 *)*((void *)v2 + 2);
          BOOL v14 = *(void *)v13 == (void)v2;
          uint64_t v2 = v13;
        }
        while (!v14);
      }
      uint64_t v2 = v13;
      if (v13 == v3) {
        return;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 8);
LABEL_15:
    sub_10092F4E8(a1, v7);
    goto LABEL_16;
  }
}

void sub_10092F108(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 328))
  {
    BOOL v3 = (unsigned __int8 *)(a2 + 1);
    uint64_t v4 = (unsigned __int8 *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v5 = *(unsigned __int8 **)(a1 + 312);
    while (sub_10001D294(v4 + 32, v5 + 32) && sub_10047161C((uint64_t)(v4 + 56), (uint64_t)(v5 + 56)))
    {
      uint64_t v6 = (unsigned __int8 *)*((void *)v4 + 1);
      uint64_t v7 = v4;
      if (v6)
      {
        do
        {
          uint64_t v4 = v6;
          uint64_t v6 = *(unsigned __int8 **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v4 = (unsigned __int8 *)*((void *)v7 + 2);
          BOOL v8 = *(void *)v4 == (void)v7;
          uint64_t v7 = v4;
        }
        while (!v8);
      }
      int v9 = (unsigned __int8 *)*((void *)v5 + 1);
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          int v9 = *(unsigned __int8 **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v10 = (unsigned __int8 *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v8);
      }
      uint64_t v5 = v10;
      if (v4 == v3) {
        return;
      }
    }
  }
  int v11 = *(void **)(a1 + 312);
  if (v11 != (void *)(a1 + 320))
  {
    do
    {
      if (*((_DWORD *)v11 + 14) == 1) {
        sub_10093127C(a1, (uint64_t)(v11 + 4));
      }
      BOOL v12 = (void *)v11[1];
      if (v12)
      {
        do
        {
          char v13 = v12;
          BOOL v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          char v13 = (void *)v11[2];
          BOOL v8 = *v13 == (void)v11;
          int v11 = v13;
        }
        while (!v8);
      }
      int v11 = v13;
    }
    while (v13 != (void *)(a1 + 320));
  }
}

void sub_10092F244(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  if (a2 == 3)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Erasing model for all slots", buf, 2u);
    }
    if (*(void *)(a1 + 128))
    {
      uint64_t v7 = *(void *)(a1 + 120);
      uint64_t v6 = (void *)(a1 + 120);
      BOOL v8 = (void *)*(v6 - 1);
      *(v6 - 1) = v6;
      *(void *)(v7 + 16) = 0;
      void *v6 = 0;
      v6[1] = 0;
      if (v8[1]) {
        int v9 = (void *)v8[1];
      }
      else {
        int v9 = v8;
      }
      if (v9)
      {
        BOOL v10 = (void *)v9[2];
        if (v10)
        {
          int v11 = (void *)*v10;
          if ((void *)*v10 == v9)
          {
            void *v10 = 0;
            while (1)
            {
              uint64_t v17 = (void *)v10[1];
              if (!v17) {
                break;
              }
              do
              {
                BOOL v10 = v17;
                uint64_t v17 = (void *)*v17;
              }
              while (v17);
            }
          }
          else
          {
            for (v10[1] = 0; v11; int v11 = (void *)v10[1])
            {
              do
              {
                BOOL v10 = v11;
                int v11 = (void *)*v11;
              }
              while (v11);
            }
          }
          sub_1001FEC70(v9);
          for (uint64_t i = (void *)v10[2]; i; uint64_t i = (void *)i[2])
            BOOL v10 = i;
          int v9 = v10;
        }
      }
      sub_1001FEC70(v9);
    }
  }
  else
  {
    *(void *)std::string buf = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    PersonalityIdFromSlotId();
    char v13 = (uint64_t **)(a1 + 112);
    BOOL v14 = sub_100046F68(a1 + 112, (void **)buf);
    if ((void **)(a1 + 120) != v14)
    {
      uint64_t v15 = (uint64_t *)v14;
      int v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v18[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Erasing model", (uint8_t *)v18, 2u);
      }
      sub_1000F5B04(v13, v15);
      sub_1001FEC1C((uint64_t)(v15 + 4));
      operator delete(v15);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_10092F460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10092F47C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Shut down complete", v4, 2u);
  }
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 64));
}

void sub_10092F4E8(uint64_t a1, uint64_t a2)
{
  v24[0] = 0;
  v24[1] = 0;
  uint64_t v25 = 0;
  PersonalityIdFromSlotId();
  uint64_t v4 = sub_100046F68(a1 + 112, v24);
  if ((void **)(a1 + 120) == v4)
  {
    int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    *(_WORD *)std::string buf = 0;
    BOOL v12 = "#I Bailing out, no models";
    goto LABEL_16;
  }
  uint64_t v5 = *(void *)(a1 + 216);
  if (v5)
  {
    uint64_t v6 = v4;
    uint64_t v7 = a1 + 216;
    do
    {
      int v8 = *(_DWORD *)(v5 + 32);
      BOOL v9 = v8 < (int)a2;
      if (v8 >= (int)a2) {
        BOOL v10 = (uint64_t *)v5;
      }
      else {
        BOOL v10 = (uint64_t *)(v5 + 8);
      }
      if (!v9) {
        uint64_t v7 = v5;
      }
      uint64_t v5 = *v10;
    }
    while (*v10);
    if (v7 != a1 + 216 && *(_DWORD *)(v7 + 32) <= (int)a2)
    {
      uint64_t v13 = *(void *)(a1 + 192);
      long long v22 = 0u;
      memset(&__p, 0, sizeof(__p));
      *(_OWORD *)std::string buf = 0u;
      *(_OWORD *)uint64_t v21 = 0u;
      if (!v13) {
        goto LABEL_30;
      }
      uint64_t v14 = a1 + 192;
      do
      {
        int v15 = *(_DWORD *)(v13 + 32);
        BOOL v16 = v15 < (int)a2;
        if (v15 >= (int)a2) {
          uint64_t v17 = (uint64_t *)v13;
        }
        else {
          uint64_t v17 = (uint64_t *)(v13 + 8);
        }
        if (!v16) {
          uint64_t v14 = v13;
        }
        uint64_t v13 = *v17;
      }
      while (*v17);
      if (v14 != a1 + 192 && *(_DWORD *)(v14 + 32) <= (int)a2)
      {
        std::string::operator=((std::string *)buf, (const std::string *)(v14 + 296));
      }
      else
      {
LABEL_30:
        __int16 v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v19 = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Registration information not available", v19, 2u);
        }
      }
      std::string::operator=((std::string *)&v21[1], (const std::string *)(v7 + 112));
      std::string::operator=(&__p, (const std::string *)(v7 + 40));
      sub_100D65150((std::string *)v6[7], (const std::string *)buf);
    }
  }
  int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    BOOL v12 = "#I Provisioning information not available";
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
  }
LABEL_17:
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
}

void sub_10092F780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1001F78F8((uint64_t)va);
  if (*(char *)(v3 - 33) < 0) {
    operator delete(*(void **)(v3 - 56));
  }
  _Unwind_Resume(a1);
}

BOOL sub_10092F7B4(uint64_t a1)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v10 = 0;
  PersonalityIdFromSlotId();
  uint64_t v2 = *(unsigned __int8 **)(a1 + 312);
  uint64_t v3 = (unsigned __int8 *)(a1 + 320);
  if (v2 == v3)
  {
LABEL_9:
    BOOL v7 = 0;
  }
  else
  {
    while (!sub_10001D294((unsigned __int8 *)__p, v2 + 32))
    {
      uint64_t v4 = (unsigned __int8 *)*((void *)v2 + 1);
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = *(unsigned __int8 **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (unsigned __int8 *)*((void *)v2 + 2);
          BOOL v6 = *(void *)v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
      if (v5 == v3) {
        goto LABEL_9;
      }
    }
    BOOL v7 = *((_DWORD *)v2 + 14) == 1;
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_10092F870(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 360);
  *(void *)(a1 + 352) = v3;
  *(void *)(a1 + 360) = v2;
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_10092F89C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  PersonalityIdFromSlotId();
  uint64_t v10 = sub_100046F68((uint64_t)(a2 + 14), &v45);
  if (a2 + 15 == v10)
  {
    BOOL v12 = a2[5];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = HIBYTE(v47);
      if (v47 < 0) {
        uint64_t v30 = v46;
      }
      xpc_object_t v31 = (const char *)&v45;
      if (v47 < 0) {
        xpc_object_t v31 = (const char *)v45;
      }
      if (v30) {
        xpc_object_t v32 = v31;
      }
      else {
        xpc_object_t v32 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v32;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Not model found for sending disposition notification: %s", buf, 0xCu);
    }
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 208) = 0;
  }
  else
  {
    int v11 = v10;
    *(_OWORD *)int v43 = 0u;
    long long v44 = 0u;
    sub_10092FF38((uint64_t)v43, (uint64_t)a2, a3);
    if (BYTE8(v44))
    {
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v42 = 0;
      if (SBYTE7(v44) < 0)
      {
        sub_10004FC84(__dst, v43[0], (unint64_t)v43[1]);
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)v43;
        uint64_t v42 = v44;
      }
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v40 = 0;
      memset(buf, 0, sizeof(buf));
      uint64_t v49 = 0;
      sub_100CC7114(__p, (uint64_t)buf);
      uint64_t v14 = *(unsigned __int8 *)(a5 + 47);
      if ((v14 & 0x80u) != 0) {
        uint64_t v14 = *(void *)(a5 + 32);
      }
      if (v14)
      {
        int v15 = a2[5];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Using client provided focus", buf, 2u);
        }
        sub_100CC7114(buf, a5 + 24);
      }
      else
      {
        sub_100CC7114(buf, a5);
      }
      if (SHIBYTE(v40) < 0) {
        operator delete(__p[0]);
      }
      *(_OWORD *)std::string __p = *(_OWORD *)buf;
      uint64_t v40 = v49;
      uint64_t v17 = v11[7];
      BOOL v16 = (std::__shared_weak_count *)v11[8];
      if (v16) {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v17)
      {
        uint64_t v38 = 0;
        *(_OWORD *)CFStringRef v36 = 0u;
        long long v37 = 0u;
        __int16 v18 = (std::__shared_weak_count *)a2[11];
        xpc_object_t v34 = (Registry *)a2[10];
        int64_t v35 = v18;
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_10055FEB8(&v34, buf);
        sub_100CC89EC(v36, (uint64_t)buf);
        if (SHIBYTE(v49) < 0) {
          operator delete(*(void **)buf);
        }
        if (v35) {
          sub_10004D2C8(v35);
        }
        uint64_t v19 = a2[30];
        if (!v19) {
          goto LABEL_39;
        }
        uint64_t v20 = a2 + 30;
        do
        {
          int v21 = *(_DWORD *)(v19 + 32);
          BOOL v22 = v21 < (int)a3;
          if (v21 >= (int)a3) {
            uint64_t v23 = (uint64_t *)v19;
          }
          else {
            uint64_t v23 = (uint64_t *)(v19 + 8);
          }
          if (!v22) {
            uint64_t v20 = (void *)v19;
          }
          uint64_t v19 = *v23;
        }
        while (*v23);
        if (v20 != a2 + 30 && *((_DWORD *)v20 + 8) <= (int)a3) {
          char v24 = *((unsigned char *)v20 + 40) != 0;
        }
        else {
LABEL_39:
        }
          char v24 = 0;
        memset(v33, 0, sizeof(v33));
        sub_100CC8F14(v33, (long long *)__p, a4, (uint64_t)__dst, (uint64_t)v36, v24);
        uint64_t v25 = *(unsigned __int8 *)(a5 + 71);
        if ((v25 & 0x80u) != 0) {
          uint64_t v25 = *(void *)(a5 + 56);
        }
        if (v25)
        {
          unsigned int v26 = (const std::string *)(a5 + 48);
          uint64_t v27 = a2[5];
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Using client provided conversation ID", buf, 2u);
          }
          sub_100093B44((std::string *)((char *)&v33[6] + 8), v26);
        }
        sub_100937F90((uint64_t)buf, (uint64_t)v33);
        *(void *)std::string buf = off_101A4E5F8;
        if (SHIBYTE(v33[11]) < 0)
        {
          sub_10004FC84(&__src, *((void **)&v33[10] + 1), *(unint64_t *)&v33[11]);
        }
        else
        {
          long long __src = *(_OWORD *)((char *)&v33[10] + 8);
          uint64_t v51 = *((void *)&v33[11] + 1);
        }
        *(void *)&long long v52 = v17;
        *((void *)&v52 + 1) = v16;
        if (v16) {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100937F90(a1, (uint64_t)buf);
        *(void *)a1 = off_101A4E5F8;
        xpc_object_t v29 = (unsigned char *)(a1 + 168);
        if (SHIBYTE(v51) < 0)
        {
          sub_10004FC84(v29, (void *)__src, *((unint64_t *)&__src + 1));
        }
        else
        {
          *(_OWORD *)xpc_object_t v29 = __src;
          *(void *)(a1 + 184) = v51;
        }
        *(_OWORD *)(a1 + 192) = v52;
        long long v52 = 0uLL;
        *(unsigned char *)(a1 + 208) = 1;
        sub_100CC90D0((uint64_t)buf);
        sub_100CC90D0((uint64_t)v33);
        if (SBYTE7(v37) < 0) {
          operator delete(v36[0]);
        }
      }
      else
      {
        uint64_t v28 = a2[5];
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Invalid model when sending group message", buf, 2u);
        }
        *(unsigned char *)a1 = 0;
        *(unsigned char *)(a1 + 208) = 0;
      }
      if (v16) {
        sub_10004D2C8(v16);
      }
      if (SHIBYTE(v40) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v42) < 0) {
        operator delete(__dst[0]);
      }
    }
    else
    {
      uint64_t v13 = a2[5];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid phone number when sending transaction", buf, 2u);
      }
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 208) = 0;
    }
    if (BYTE8(v44) && SBYTE7(v44) < 0) {
      operator delete(v43[0]);
    }
  }
  if (SHIBYTE(v47) < 0) {
    operator delete(v45);
  }
}

void sub_10092FE2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  sub_100CC8BDC(v72);
  sub_100930150((uint64_t)&a72);
  sub_100CC90D0((uint64_t)&a9);
  if (a40 < 0) {
    operator delete(__p);
  }
  if (v73) {
    sub_10004D2C8(v73);
  }
  if (a49 < 0) {
    operator delete(a44);
  }
  if (a56 < 0) {
    operator delete(a51);
  }
  if (a64 && a63 < 0) {
    operator delete(a58);
  }
  if (a71 < 0) {
    operator delete(a66);
  }
  _Unwind_Resume(a1);
}

void sub_10092FF38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 216);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a2 + 216;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < (int)a3;
    if (v7 >= (int)a3) {
      BOOL v9 = (uint64_t *)v5;
    }
    else {
      BOOL v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != a2 + 216 && *(_DWORD *)(v6 + 32) <= (int)a3)
  {
    memset(buf, 0, sizeof(buf));
    uint64_t v17 = 0;
    if (*(char *)(v6 + 135) < 0)
    {
      sub_10004FC84(buf, *(void **)(v6 + 112), *(void *)(v6 + 120));
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)(v6 + 112);
      uint64_t v17 = *(void *)(v6 + 128);
    }
    uint64_t v11 = HIBYTE(v17);
    if (v17 < 0) {
      uint64_t v11 = *(void *)&buf[8];
    }
    if (v11)
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v15 = 0;
      sub_100CC85C0(__p, (uint64_t)buf);
      if (SHIBYTE(v15) < 0)
      {
        sub_10004FC84((unsigned char *)a1, __p[0], (unint64_t)__p[1]);
        int v13 = SHIBYTE(v15);
        *(unsigned char *)(a1 + 24) = 1;
        if (v13 < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        *(_OWORD *)a1 = *(_OWORD *)__p;
        *(void *)(a1 + 16) = v15;
        *(unsigned char *)(a1 + 24) = 1;
      }
    }
    else
    {
      BOOL v12 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid phone number when sending transaction", (uint8_t *)__p, 2u);
      }
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 24) = 0;
    }
    if (SHIBYTE(v17) < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
LABEL_11:
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to retrieve phone number", buf, 2u);
    }
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
}

void sub_10093011C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100930150(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 200);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_100CC90D0(a1);
}

void sub_100930190(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  PersonalityIdFromSlotId();
  uint64_t v10 = sub_100046F68((uint64_t)(a2 + 14), &v40);
  if (a2 + 15 == v10)
  {
    BOOL v12 = a2[5];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v25 = HIBYTE(v42);
      if (v42 < 0) {
        uint64_t v25 = v41;
      }
      unsigned int v26 = (const char *)&v40;
      if (v42 < 0) {
        unsigned int v26 = (const char *)v40;
      }
      if (v25) {
        uint64_t v27 = v26;
      }
      else {
        uint64_t v27 = "<invalid>";
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v27;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Not model found for sending disposition notification: %s", (uint8_t *)__p, 0xCu);
    }
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 208) = 0;
  }
  else
  {
    uint64_t v11 = v10;
    *(_OWORD *)uint64_t v38 = 0u;
    long long v39 = 0u;
    sub_10092FF38((uint64_t)v38, (uint64_t)a2, a3);
    if (BYTE8(v39))
    {
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v37 = 0;
      if (SBYTE7(v39) < 0)
      {
        sub_10004FC84(__dst, v38[0], (unint64_t)v38[1]);
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)v38;
        uint64_t v37 = v39;
      }
      v34[0] = 0;
      v34[1] = 0;
      uint64_t v35 = 0;
      sub_100CC7114(v34, a4);
      uint64_t v33 = 0;
      *(_OWORD *)xpc_object_t v31 = 0u;
      long long v32 = 0u;
      uint64_t v14 = (std::__shared_weak_count *)a2[11];
      xpc_object_t v29 = (Registry *)a2[10];
      uint64_t v30 = v14;
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_10055FEB8(&v29, __p);
      sub_100CC89EC(v31, (uint64_t)__p);
      if (v44 < 0) {
        operator delete(__p[0]);
      }
      if (v30) {
        sub_10004D2C8(v30);
      }
      uint64_t v17 = a2[30];
      BOOL v16 = a2 + 30;
      uint64_t v15 = v17;
      if (!v17) {
        goto LABEL_27;
      }
      __int16 v18 = v16;
      do
      {
        int v19 = *(_DWORD *)(v15 + 32);
        BOOL v20 = v19 < (int)a3;
        if (v19 >= (int)a3) {
          int v21 = (uint64_t *)v15;
        }
        else {
          int v21 = (uint64_t *)(v15 + 8);
        }
        if (!v20) {
          __int16 v18 = (void *)v15;
        }
        uint64_t v15 = *v21;
      }
      while (*v21);
      if (v18 != v16 && *((_DWORD *)v18 + 8) <= (int)a3) {
        char v22 = *((unsigned char *)v18 + 40) != 0;
      }
      else {
LABEL_27:
      }
        char v22 = 0;
      memset(v28, 0, sizeof(v28));
      sub_100CC7114(__p, a4);
      sub_100CC8CB8(v28, (uint64_t)__dst, (long long *)__p, a5, (uint64_t)v31, v22);
      if (v44 < 0) {
        operator delete(__p[0]);
      }
      sub_100937F90((uint64_t)__p, (uint64_t)v28);
      __p[0] = off_101A4E5D8;
      if (SHIBYTE(v28[11]) < 0)
      {
        sub_10004FC84(&__src, *((void **)&v28[10] + 1), *(unint64_t *)&v28[11]);
      }
      else
      {
        long long __src = *(_OWORD *)((char *)&v28[10] + 8);
        uint64_t v46 = *((void *)&v28[11] + 1);
      }
      *(void *)&long long v47 = v11[7];
      uint64_t v23 = (atomic_ullong *)v11[8];
      *((void *)&v47 + 1) = v23;
      if (v23) {
        atomic_fetch_add_explicit(v23 + 1, 1uLL, memory_order_relaxed);
      }
      sub_100937F90(a1, (uint64_t)__p);
      *(void *)a1 = off_101A4E5D8;
      char v24 = (unsigned char *)(a1 + 168);
      if (SHIBYTE(v46) < 0)
      {
        sub_10004FC84(v24, (void *)__src, *((unint64_t *)&__src + 1));
      }
      else
      {
        *(_OWORD *)char v24 = __src;
        *(void *)(a1 + 184) = v46;
      }
      *(_OWORD *)(a1 + 192) = v47;
      long long v47 = 0uLL;
      *(unsigned char *)(a1 + 208) = 1;
      sub_100CC8E78((uint64_t)__p);
      sub_100CC8E78((uint64_t)v28);
      if (SBYTE7(v32) < 0) {
        operator delete(v31[0]);
      }
      if (SHIBYTE(v35) < 0) {
        operator delete(v34[0]);
      }
      if (SHIBYTE(v37) < 0) {
        operator delete(__dst[0]);
      }
    }
    else
    {
      int v13 = a2[5];
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid phone number when sending transaction", (uint8_t *)__p, 2u);
      }
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 208) = 0;
    }
    if (BYTE8(v39) && SBYTE7(v39) < 0) {
      operator delete(v38[0]);
    }
  }
  if (SHIBYTE(v42) < 0) {
    operator delete(v40);
  }
}

void sub_1009305C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,char a62,uint64_t a63)
{
  sub_100CC8BDC(v70);
  sub_1009306D0((uint64_t)&a70);
  sub_100CC8E78((uint64_t)&a9);
  if (a40 < 0) {
    operator delete(__p);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  if (a62 && a61 < 0) {
    operator delete(a56);
  }
  if (a69 < 0) {
    operator delete(a64);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1009306D0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 200);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_100CC8E78(a1);
}

void sub_100930710(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v8 = *(void *)(a2 + 240);
  if (v8)
  {
    uint64_t v11 = a2 + 240;
    do
    {
      int v12 = *(_DWORD *)(v8 + 32);
      BOOL v13 = v12 < (int)a3;
      if (v12 >= (int)a3) {
        uint64_t v14 = (uint64_t *)v8;
      }
      else {
        uint64_t v14 = (uint64_t *)(v8 + 8);
      }
      if (!v13) {
        uint64_t v11 = v8;
      }
      uint64_t v8 = *v14;
    }
    while (*v14);
    if (v11 != a2 + 240 && *(_DWORD *)(v11 + 32) <= (int)a3)
    {
      uint64_t v16 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
      uint64_t v68 = 0;
      long long v67 = 0u;
      memset(v66, 0, sizeof(v66));
      uint64_t v45 = (os_log_t *)v16;
      if (*(char *)(v11 + 95) < 0)
      {
        sub_10004FC84(__str, *(void **)(v11 + 72), *(void *)(v11 + 80));
      }
      else
      {
        *(_OWORD *)std::string __str = *(_OWORD *)(v11 + 72);
        *(void *)&__str[16] = *(void *)(v11 + 88);
      }
      char v73 = 0;
      char v74 = 0;
      uint64_t v77 = 0;
      std::string __p = 0;
      uint64_t v76 = 0;
      uint64_t v71 = 0;
      *(void *)&__str[24] = 0;
      uint64_t v70 = 0;
      char v72 = 0;
      sub_100930190((uint64_t)v66, (void *)a2, a3, (uint64_t)__str, a4);
      if (SHIBYTE(v77) < 0) {
        operator delete(__p);
      }
      if (v74)
      {
        *(void *)std::string buf = &v73;
        sub_100047F64((void ***)buf);
      }
      if (SHIBYTE(v71) < 0) {
        operator delete(*(void **)&__str[24]);
      }
      if ((__str[23] & 0x80000000) != 0) {
        operator delete(*(void **)__str);
      }
      if (!(_BYTE)v68)
      {
        uint64_t v17 = *v45;
        if (os_log_type_enabled(*v45, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string __str = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to determine model while sending one to many text", __str, 2u);
        }
        *(unsigned char *)a1 = 0;
        *(unsigned char *)(a1 + 232) = 0;
        goto LABEL_75;
      }
      long long v65 = 0u;
      memset(v64, 0, sizeof(v64));
      sub_100938114((uint64_t)v64, (uint64_t)v66);
      long long v65 = v67;
      if (*((void *)&v67 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v67 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a2);
      if (__str[24])
      {
        std::string::operator=((std::string *)((char *)v64 + 8), (const std::string *)__str);
      }
      else
      {
        __int16 v18 = *v45;
        if (!os_log_type_enabled(*v45, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_38;
        }
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", buf, 2u);
      }
      if (__str[24] && (__str[23] & 0x80000000) != 0) {
        operator delete(*(void **)__str);
      }
LABEL_38:
      *(_OWORD *)uint64_t v62 = 0u;
      long long v63 = 0u;
      sub_10092FF38((uint64_t)v62, a2, a3);
      if (!BYTE8(v63))
      {
        uint64_t v42 = *v45;
        if (os_log_type_enabled(*v45, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string __str = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Invalid phone number when sending transaction", __str, 2u);
        }
        *(unsigned char *)a1 = 0;
        *(unsigned char *)(a1 + 232) = 0;
        goto LABEL_69;
      }
      int64x2_t v60 = 0uLL;
      v61[0] = 0;
      uint64_t v19 = *a5;
      uint64_t v20 = a5[1];
      if (*a5 != v20)
      {
        do
        {
          sub_100CC7114(buf, v19);
          int v21 = (_OWORD *)v60.i64[1];
          if (v60.i64[1] >= v61[0])
          {
            unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v60.i64[1] - v60.i64[0]) >> 3);
            unint64_t v24 = v23 + 1;
            if (v23 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_100938198();
            }
            if (0x5555555555555556 * ((v61[0] - v60.i64[0]) >> 3) > v24) {
              unint64_t v24 = 0x5555555555555556 * ((v61[0] - v60.i64[0]) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v61[0] - v60.i64[0]) >> 3) >= 0x555555555555555) {
              unint64_t v25 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v25 = v24;
            }
            uint64_t v70 = v61;
            if (v25) {
              unsigned int v26 = (char *)sub_10004812C((uint64_t)v61, v25);
            }
            else {
              unsigned int v26 = 0;
            }
            uint64_t v27 = &v26[24 * v23];
            *(void *)std::string __str = v26;
            *(void *)&__str[8] = v27;
            *(void *)&__str[24] = &v26[24 * v25];
            long long v28 = *(_OWORD *)buf;
            *((void *)v27 + 2) = v47;
            *(_OWORD *)uint64_t v27 = v28;
            *(void *)&long long v47 = 0;
            memset(buf, 0, sizeof(buf));
            xpc_object_t v29 = v27 + 24;
            *(void *)&__str[16] = v27 + 24;
            uint64_t v30 = v60.i64[1];
            uint64_t v31 = v60.i64[0];
            uint64_t v32 = *(void *)&__str[8];
            if (v60.i64[1] == v60.i64[0])
            {
              int64x2_t v34 = vdupq_n_s64(v60.u64[1]);
            }
            else
            {
              do
              {
                long long v33 = *(_OWORD *)(v30 - 24);
                *(void *)(v32 - 8) = *(void *)(v30 - 8);
                *(_OWORD *)(v32 - 24) = v33;
                v32 -= 24;
                *(void *)(v30 - 16) = 0;
                *(void *)(v30 - 8) = 0;
                *(void *)(v30 - 24) = 0;
                v30 -= 24;
              }
              while (v30 != v31);
              int64x2_t v34 = v60;
              xpc_object_t v29 = *(char **)&__str[16];
            }
            v60.i64[0] = v32;
            v60.i64[1] = (uint64_t)v29;
            *(int64x2_t *)&__str[8] = v34;
            uint64_t v35 = v61[0];
            v61[0] = *(void *)&__str[24];
            *(void *)&__str[24] = v35;
            *(void *)std::string __str = v34.i64[0];
            sub_10060190C((uint64_t)__str);
            v60.i64[1] = (uint64_t)v29;
            if (SBYTE7(v47) < 0) {
              operator delete(*(void **)buf);
            }
          }
          else
          {
            long long v22 = *(_OWORD *)buf;
            *(void *)(v60.i64[1] + 16) = v47;
            *int v21 = v22;
            v60.i64[1] = (uint64_t)v21 + 24;
          }
          v19 += 112;
        }
        while (v19 != v20);
      }
      unint64_t v36 = *(void *)(v11 + 56);
      if (v36)
      {
        int64x2_t v37 = v60;
        if (v60.i64[0] != v60.i64[1] && 0xAAAAAAAAAAAAAAABLL * ((v60.i64[1] - v60.i64[0]) >> 3) <= v36)
        {
          int v44 = *(_DWORD *)(v11 + 64);
          uint64_t v59 = 0;
          long long v57 = 0u;
          long long v58 = 0u;
          long long v55 = 0u;
          long long v56 = 0u;
          long long v53 = 0u;
          long long v54 = 0u;
          long long v51 = 0u;
          long long v52 = 0u;
          long long v49 = 0u;
          long long v50 = 0u;
          long long v47 = 0u;
          long long v48 = 0u;
          *(_OWORD *)std::string buf = 0u;
          if (!BYTE8(v63)) {
            sub_10016C840();
          }
          sub_100CC7114(__str, v11 + 72);
          sub_100CC91B0((uint64_t)buf, (uint64_t)v62, (long long *)__str, (long long **)&v60, a4, (uint64_t)&v64[3] + 8, v44 == 2);
          if ((__str[23] & 0x80000000) != 0) {
            operator delete(*(void **)__str);
          }
          sub_1009381B0((uint64_t)__str, (uint64_t)buf);
          long long v78 = v65;
          if (*((void *)&v65 + 1)) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v65 + 1) + 8), 1uLL, memory_order_relaxed);
          }
          sub_100938454(a1, (uint64_t)__str);
          *(_OWORD *)(a1 + 216) = v78;
          long long v78 = 0uLL;
          *(unsigned char *)(a1 + 232) = 1;
          sub_1009310B0((uint64_t)__str);
          sub_100CC93B8((uint64_t)buf);
          goto LABEL_68;
        }
        os_log_t v38 = *v45;
        if (os_log_type_enabled(*v45, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string __str = 134217984;
          *(void *)&__str[4] = 0xAAAAAAAAAAAAAAABLL * ((v37.i64[1] - v37.i64[0]) >> 3);
          long long v39 = "Invalid number of recepients: %zu";
          uint64_t v40 = v38;
          uint32_t v41 = 12;
LABEL_83:
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, v39, __str, v41);
        }
      }
      else
      {
        os_log_t v43 = *v45;
        if (os_log_type_enabled(*v45, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string __str = 0;
          long long v39 = "Invalid OneToMany max size";
          uint64_t v40 = v43;
          uint32_t v41 = 2;
          goto LABEL_83;
        }
      }
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 232) = 0;
LABEL_68:
      *(void *)std::string __str = &v60;
      sub_100047F64((void ***)__str);
LABEL_69:
      if (BYTE8(v63) && SBYTE7(v63) < 0) {
        operator delete(v62[0]);
      }
      if (*((void *)&v65 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v65 + 1));
      }
      sub_100CC8E78((uint64_t)v64);
LABEL_75:
      sub_100938528((uint64_t)v66);
      return;
    }
  }
  uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string __str = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Device cannot send 1-to-many message", __str, 2u);
  }
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 232) = 0;
}

void sub_100930E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,int a45,__int16 a46,char a47,char a48,char a49,int a50,__int16 a51)
{
  a11 = (uint64_t)&a39;
  sub_100047F64((void ***)&a11);
  if (a49)
  {
    if (a48 < 0) {
      operator delete(__p);
    }
  }
  sub_1009306D0((uint64_t)&a51);
  sub_100938528((uint64_t)&STACK[0x200]);
  _Unwind_Resume(a1);
}

void sub_100930F70(uint64_t a1, uint64_t a2)
{
  v10[0] = 0;
  v10[1] = 0;
  uint64_t v11 = 0;
  PersonalityIdFromSlotId();
  uint64_t v4 = sub_100046F68(a2 + 160, v10);
  if ((void **)(a2 + 168) != v4)
  {
    uint64_t v5 = (uint64_t)v4[19];
    uint64_t v6 = v4[20];
    while ((void *)v5 != v6)
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v9 = 0;
      sub_100CC85C0(__p, v5);
      if (sub_100CC801C(__p))
      {
        if (SHIBYTE(v9) < 0)
        {
          sub_10004FC84((unsigned char *)a1, __p[0], (unint64_t)__p[1]);
          int v7 = SHIBYTE(v9);
          *(unsigned char *)(a1 + 24) = 1;
          if (v7 < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          *(_OWORD *)a1 = *(_OWORD *)__p;
          *(void *)(a1 + 16) = v9;
          *(unsigned char *)(a1 + 24) = 1;
        }
        goto LABEL_9;
      }
      if (SHIBYTE(v9) < 0) {
        operator delete(__p[0]);
      }
      v5 += 24;
    }
  }
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
LABEL_9:
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[0]);
  }
}

void sub_100931078(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009310B0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 224);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_100CC93B8(a1);
}

void sub_1009310F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  PersonalityIdFromSlotId();
  if ((void **)(a1 + 120) != sub_100046F68(a1 + 112, &__p))
  {
    uint64_t v7 = *sub_100046ED4(a1 + 112, buf, &__p);
    if (v7) {
      sub_100D59908(*(void *)(v7 + 56), a3, a4);
    }
    sub_1000C14F0("map::at:  key not found");
  }
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    uint64_t v9 = HIBYTE(v15);
    if (v15 < 0) {
      uint64_t v9 = v14;
    }
    p_p = (const char *)&__p;
    if (v15 < 0) {
      p_p = (const char *)__p;
    }
    BOOL v11 = v9 == 0;
    uint64_t v12 = *(void *)(a1 + 128);
    if (v11) {
      p_p = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v17 = p_p;
    __int16 v18 = 2048;
    uint64_t v19 = v12;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Not handling geo push: missing personality %s, map-size: %lu", buf, 0x16u);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
}

void sub_100931258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void sub_10093127C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t **)(a1 + 112);
  uint64_t v5 = (uint64_t *)sub_100046F68(a1 + 112, (void **)a2);
  uint64_t v6 = SlotIdFromPersonalityId();
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
  uint64_t v8 = v7;
  uint64_t v9 = a1 + 120;
  if ((uint64_t *)(a1 + 120) != v5)
  {
    if (*(_DWORD *)(v5[7] + 88) == v6) {
      goto LABEL_66;
    }
    uint64_t v10 = (uint64_t)(v5 + 4);
    BOOL v11 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
      BOOL v13 = (v12 & 0x80u) != 0;
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(a2 + 8);
      }
      if (v13) {
        uint64_t v14 = *(const char **)a2;
      }
      else {
        uint64_t v14 = (const char *)a2;
      }
      if (v12) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v15;
      uint64_t v9 = a1 + 120;
      uint64_t v10 = (uint64_t)(v5 + 4);
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Erasing messaging model for personality: %s at slot: %s", buf, 0x16u);
    }
    sub_1000F5B04(v4, v5);
    sub_1001FEC1C(v10);
    operator delete(v5);
  }
  uint64_t v16 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = *(unsigned __int8 *)(a2 + 23);
    BOOL v18 = (v17 & 0x80u) != 0;
    if ((v17 & 0x80u) != 0) {
      uint64_t v17 = *(void *)(a2 + 8);
    }
    if (v18) {
      uint64_t v19 = *(const char **)a2;
    }
    else {
      uint64_t v19 = (const char *)a2;
    }
    if (v17) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Creating messaging model for personality: %s", buf, 0xCu);
  }
  int v21 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v21 || (uint64_t v22 = *(void *)(a1 + 8), (v23 = std::__shared_weak_count::lock(v21)) == 0)) {
    sub_100088B9C();
  }
  unint64_t v24 = v23;
  atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v23);
  long long v52 = 0;
  long long v50 = 0u;
  *(_OWORD *)long long v51 = 0u;
  memset(buf, 0, sizeof(buf));
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(buf, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)a2;
    *(void *)&uint8_t buf[16] = *(void *)(a2 + 16);
  }
  uint64_t v25 = *(void *)(a1 + 344);
  *(void *)&unsigned char buf[24] = *(void *)(a1 + 336);
  *(void *)&long long v50 = v25;
  if (v25) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)&v50 + 1) = 0;
  v51[0] = 0;
  unsigned int v26 = std::__shared_weak_count::lock(v24);
  if (v26)
  {
    uint64_t v27 = v26;
    uint64_t v28 = v22 + 56;
    atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    xpc_object_t v29 = v51[0];
    if (!v22) {
      uint64_t v28 = 0;
    }
    *((void *)&v50 + 1) = v28;
    v51[0] = v27;
    if (v29) {
      std::__shared_weak_count::__release_weak(v29);
    }
    sub_10004D2C8(v27);
  }
  else
  {
    uint64_t v30 = v51[0];
    *((void *)&v50 + 1) = 0;
    v51[0] = 0;
    if (v30) {
      std::__shared_weak_count::__release_weak(v30);
    }
  }
  uint64_t v31 = *(std::__shared_weak_count **)(a1 + 360);
  v51[1] = *(std::__shared_weak_count **)(a1 + 352);
  long long v52 = v31;
  if (v31) {
    atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v32 = *(void *)(a1 + 96);
  long long v33 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v33;
  if (v33) {
    dispatch_retain(v33);
  }
  int64x2_t v34 = *(std::__shared_weak_count **)(a1 + 88);
  uint64_t v42 = *(void *)(a1 + 80);
  os_log_t v43 = v34;
  if (v34) {
    atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, dispatch_object_t *, uint64_t *, uint8_t *))(*(void *)v32 + 16))(&v45, v32, &object, &v42, buf);
  uint64_t v48 = 0;
  uint64_t v35 = (uint64_t **)sub_100046ED4((uint64_t)v4, &v48, (void **)a2);
  unint64_t v36 = *v35;
  if (!*v35)
  {
    int64x2_t v37 = v35;
    uint64_t v47 = 0;
    unint64_t v36 = (uint64_t *)operator new(0x48uLL);
    v46[0] = v36;
    v46[1] = v9;
    os_log_t v38 = v36 + 4;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v38, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)os_log_t v38 = *(_OWORD *)a2;
      v36[6] = *(void *)(a2 + 16);
    }
    v36[7] = 0;
    v36[8] = 0;
    LOBYTE(v47) = 1;
    sub_100046C38(v4, v48, v37, v36);
    v46[0] = 0;
    sub_1001FEBC4((uint64_t)v46);
  }
  long long v39 = v45;
  long long v45 = 0uLL;
  uint64_t v40 = (std::__shared_weak_count *)v36[8];
  *(_OWORD *)(v36 + 7) = v39;
  if (v40)
  {
    sub_10004D2C8(v40);
    if (*((void *)&v45 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v45 + 1));
    }
  }
  if (v43) {
    sub_10004D2C8(v43);
  }
  if (object) {
    dispatch_release(object);
  }
  sub_10092F4E8(a1, v6);
  if (v52) {
    std::__shared_weak_count::__release_weak(v52);
  }
  if (v51[0]) {
    std::__shared_weak_count::__release_weak(v51[0]);
  }
  if ((void)v50) {
    sub_10004D2C8((std::__shared_weak_count *)v50);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  std::__shared_weak_count::__release_weak(v24);
LABEL_66:
  uint64_t v41 = *sub_100046ED4((uint64_t)v4, buf, (void **)a2);
  if (!v41) {
    sub_1000C14F0("map::at:  key not found");
  }
  sub_100D537C8(*(void *)(v41 + 56));
}

void sub_100931728(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object, uint64_t a13, std::__shared_weak_count *a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  sub_1001FEBC4((uint64_t)&a15);
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (object) {
    dispatch_release(object);
  }
  sub_100938568((uint64_t)&a19);
  std::__shared_weak_count::__release_weak(v19);
  _Unwind_Resume(a1);
}

void sub_100931798(uint64_t a1, void **a2)
{
  uint64_t v3 = sub_100046F68(a1 + 112, a2);
  if ((void **)(a1 + 120) != v3)
  {
    uint64_t v4 = (uint64_t)v3[7];
    sub_100D53DE4(v4);
  }
}

void sub_1009317EC(void *a1, uint64_t a2, uint64_t a3)
{
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  PersonalityIdFromSlotId();
  uint64_t v6 = sub_100046F68(a2 + 112, &__p);
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
  if ((void **)(a2 + 120) == v6)
  {
    uint64_t v9 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = HIBYTE(v15);
      if (v15 < 0) {
        uint64_t v10 = v14;
      }
      p_p = (const char *)&__p;
      if (v15 < 0) {
        p_p = (const char *)__p;
      }
      if (v10) {
        uint64_t v12 = p_p;
      }
      else {
        uint64_t v12 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v17 = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to retrieve message: Couldn't find personality in messaging model: %s", buf, 0xCu);
    }
    *a1 = 0;
    a1[1] = 0;
  }
  else
  {
    uint64_t v8 = (atomic_ullong *)v6[8];
    *a1 = v6[7];
    a1[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit(v8 + 1, 1uLL, memory_order_relaxed);
    }
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
}

void sub_100931958(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_10093197C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)xpc_object_t v29 = 0u;
    sub_100930190((uint64_t)v29, (void *)a1, a2, a3, a4);
    if ((_BYTE)v42)
    {
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)uint64_t v16 = 0u;
      sub_100938114((uint64_t)v16, (uint64_t)v29);
      long long v28 = v41;
      if (*((void *)&v41 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)uint64_t v14 = 0u;
      sub_100930F70((uint64_t)__p, a1);
      if (LOBYTE(v14[1]))
      {
        std::string::operator=((std::string *)&v16[8], (const std::string *)__p);
      }
      else
      {
        BOOL v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", buf, 2u);
        }
      }
      if (LOBYTE(v14[1]))
      {
        if (SHIBYTE(v14[0]) < 0) {
          operator delete(__p[0]);
        }
      }
      sub_100D551EC(v28, a3);
    }
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to determine model while sending text", v16, 2u);
    }
    unsigned int v9 = 3;
    sub_100938528((uint64_t)v29);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)xpc_object_t v29 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", v29, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100931DC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1009306D0((uint64_t)&a24);
  sub_100938528((uint64_t)&a50);
  _Unwind_Resume(a1);
}

unint64_t sub_100931E50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)xpc_object_t v29 = 0u;
    sub_100930190((uint64_t)v29, (void *)a1, a2, a3, a4);
    if ((_BYTE)v42)
    {
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)uint64_t v16 = 0u;
      sub_100938114((uint64_t)v16, (uint64_t)v29);
      long long v28 = v41;
      if (*((void *)&v41 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)uint64_t v14 = 0u;
      sub_100930F70((uint64_t)__p, a1);
      if (LOBYTE(v14[1]))
      {
        std::string::operator=((std::string *)&v16[8], (const std::string *)__p);
      }
      else
      {
        BOOL v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", buf, 2u);
        }
      }
      if (LOBYTE(v14[1]))
      {
        if (SHIBYTE(v14[0]) < 0) {
          operator delete(__p[0]);
        }
      }
      sub_100D551EC(v28, a3);
    }
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while sending file transfer information", v16, 2u);
    }
    unsigned int v9 = 3;
    sub_100938528((uint64_t)v29);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)xpc_object_t v29 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", v29, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_10093226C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_1009306D0((uint64_t)&a27);
  sub_100938528((uint64_t)&a53);
  _Unwind_Resume(a1);
}

unint64_t sub_1009322EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)xpc_object_t v29 = 0u;
    sub_100930190((uint64_t)v29, (void *)a1, a2, a3, a4);
    if ((_BYTE)v42)
    {
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)uint64_t v16 = 0u;
      sub_100938114((uint64_t)v16, (uint64_t)v29);
      long long v28 = v41;
      if (*((void *)&v41 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)uint64_t v14 = 0u;
      sub_100930F70((uint64_t)__p, a1);
      if (LOBYTE(v14[1]))
      {
        std::string::operator=((std::string *)&v16[8], (const std::string *)__p);
      }
      else
      {
        BOOL v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", buf, 2u);
        }
      }
      if (LOBYTE(v14[1]))
      {
        if (SHIBYTE(v14[0]) < 0) {
          operator delete(__p[0]);
        }
      }
      sub_100D551EC(v28, a3);
    }
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while sending geolocation", v16, 2u);
    }
    unsigned int v9 = 3;
    sub_100938528((uint64_t)v29);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)xpc_object_t v29 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", v29, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100932714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_1009306D0((uint64_t)&a27);
  sub_100938528((uint64_t)&a53);
  _Unwind_Resume(a1);
}

unint64_t sub_100932794(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v41 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_100930190((uint64_t)buf, (void *)a1, a2, a3, a4);
    if ((_BYTE)v41)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      sub_100938114((uint64_t)v15, (uint64_t)buf);
      long long v27 = v40;
      if (*((void *)&v40 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        BOOL v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D60810();
    }
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while sending response for suggested reply", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938528((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100932A60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_1009306D0((uint64_t)&a19);
  sub_100938528((uint64_t)&a47);
  _Unwind_Resume(a1);
}

unint64_t sub_100932AB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v41 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_100930190((uint64_t)buf, (void *)a1, a2, a3, a4);
    if ((_BYTE)v41)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      sub_100938114((uint64_t)v15, (uint64_t)buf);
      long long v27 = v40;
      if (*((void *)&v40 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        BOOL v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D608D8();
    }
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while sending response for suggested action", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938528((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100932D7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_1009306D0((uint64_t)&a19);
  sub_100938528((uint64_t)&a47);
  _Unwind_Resume(a1);
}

unint64_t sub_100932DCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    long long v51 = 0u;
    long long v52 = 0u;
    memset(v50, 0, sizeof(v50));
    long long v48 = 0u;
    long long v49 = 0u;
    long long __dst = 0u;
    if (*(char *)(a3 + 31) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a3 + 8), *(void *)(a3 + 16));
    }
    else
    {
      long long __dst = *(_OWORD *)(a3 + 8);
      *(void *)&long long v48 = *(void *)(a3 + 24);
    }
    *((void *)&v48 + 1) = 0;
    long long v49 = 0uLL;
    LOBYTE(v50[0]) = *(unsigned char *)a3;
    BYTE8(v50[0]) = 0;
    LOBYTE(v51) = 0;
    long long v52 = 0uLL;
    *((void *)&v51 + 1) = 0;
    v45[0] = 0;
    v45[1] = 0;
    uint64_t v46 = 0;
    sub_100561B00((uint64_t)v45);
    uint64_t v44 = 0;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_100930190((uint64_t)buf, (void *)a1, a2, (uint64_t)&__dst, (uint64_t)v45);
    if ((_BYTE)v44)
    {
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      *(_OWORD *)long long v18 = 0u;
      sub_100938114((uint64_t)v18, (uint64_t)buf);
      long long v30 = v43;
      if (*((void *)&v43 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v43 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v18[8], (const std::string *)__str);
      }
      else
      {
        BOOL v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long v16 = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v16, 2u);
        }
      }
      if (__str[24] && (__str[23] & 0x80000000) != 0) {
        operator delete(*(void **)__str);
      }
      unint64_t v14 = sub_100D631E8(v30, (uint64_t)v18, a3, a4);
      unsigned int v11 = v14;
      unint64_t v10 = v14 & 0xFFFFFFFF00000000;
      unint64_t v9 = v14 & 0xFFFFFF0000000000;
      if (*((void *)&v30 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v30 + 1));
      }
      sub_100CC8E78((uint64_t)v18);
    }
    else
    {
      uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v18 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid configuration while reporting spam", v18, 2u);
      }
      unint64_t v9 = 0;
      unint64_t v10 = (unint64_t)&_mh_execute_header;
      unsigned int v11 = 3;
    }
    sub_100938528((uint64_t)buf);
    if (SHIBYTE(v46) < 0) {
      operator delete(v45[0]);
    }
    if (SHIBYTE(v52) < 0) {
      operator delete(*((void **)&v51 + 1));
    }
    if ((_BYTE)v51)
    {
      *(void *)std::string buf = (char *)v50 + 8;
      sub_100047F64((void ***)buf);
    }
    if (SHIBYTE(v49) < 0) {
      operator delete(*((void **)&v48 + 1));
    }
    if (SBYTE7(v48) < 0) {
      operator delete((void *)__dst);
    }
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unint64_t v9 = 0;
    unint64_t v10 = (unint64_t)&_mh_execute_header;
    unsigned int v11 = 1;
  }
  return v10 & 0xFF00000000 | v11 | v9 & 0xFFFFFF0000000000;
}

void sub_100933164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17 && a16 < 0) {
    operator delete(__p);
  }
  sub_1009306D0((uint64_t)&a19);
  sub_100938528((uint64_t)&a47);
  if (*(char *)(v47 - 161) < 0) {
    operator delete(*(void **)(v47 - 184));
  }
  sub_10016FEBC(v47 - 160);
  _Unwind_Resume(a1);
}

void sub_1009331DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = *(void *)(a1 + 336);
  if (v6)
  {
    if (*(unsigned char *)(a3 + 48))
    {
      sub_1001789C8(__dst, (long long *)a3);
      __dst[112] = 1;
      sub_1001F7214((uint64_t)v15, a4);
      (*(void (**)(uint64_t, uint64_t, char *, unsigned char *))(*(void *)v6 + 104))(v6, a2, __dst, v15);
      if (v18 && v17 < 0) {
        operator delete(__p);
      }
      sub_100179564((uint64_t)__dst);
      uint64_t v6 = *(void *)(a1 + 336);
    }
    sub_1001789C8(v14, (long long *)a3);
    v14[112] = 1;
    sub_1001F7214((uint64_t)v10, a4);
    (*(void (**)(uint64_t, uint64_t, char *, unsigned char *))(*(void *)v6 + 112))(v6, a2, v14, v10);
    if (v13)
    {
      if (v12 < 0) {
        operator delete(v11);
      }
    }
    sub_100179564((uint64_t)v14);
  }
  else
  {
    unint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Dropping spam report response. Notification sender has disappeared", buf, 2u);
    }
  }
}

void sub_10093338C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,char a46)
{
  uint64_t v48 = v46 - 184;
  if (a46)
  {
    if (a44 < 0)
    {
      operator delete(__p);
      uint64_t v48 = v46 - 184;
    }
  }
  sub_100179564(v48);
  _Unwind_Resume(a1);
}

void sub_1009333F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
}

void sub_1009333FC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  uint64_t v12 = 0;
  char v13 = 0;
  sub_1009317EC(&v12, a1, a2);
  uint64_t v8 = v12;
  if (v12)
  {
    bzero(buf, 0x300uLL);
    sub_100D611DC(v8, a3, buf);
    if (v17)
    {
      *a4 = 0;
      a4[760] = 0;
      sub_100458A3C((uint64_t)a4, (uint64_t)buf);
      a4[760] = 1;
    }
    else
    {
      unint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a3 + 23) >= 0) {
          uint64_t v11 = a3;
        }
        else {
          uint64_t v11 = *(void *)a3;
        }
        *(_DWORD *)unint64_t v14 = 136446210;
        uint64_t v15 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Message has disappeared: %{public}s", v14, 0xCu);
      }
      *a4 = 0;
      a4[760] = 0;
    }
    sub_100455FA0((uint64_t)buf);
  }
  else
  {
    unint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to determine model while retrieving message", buf, 2u);
    }
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (!v8)
  {
    *a4 = 0;
    a4[760] = 0;
  }
}

void sub_1009335E4(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100455FA0((uint64_t)va);
  if (a3) {
    sub_10004D2C8(a3);
  }
  _Unwind_Resume(a1);
}

void sub_100933618(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v9 = 0;
  unint64_t v10 = 0;
  sub_1009317EC(&v9, a1, a2);
  uint64_t v6 = v9;
  if (v9)
  {
    sub_100D63184(v9, (uint64_t)a3);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to determine model while retrieving all incoming message IDs", v8, 2u);
    }
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (!v6)
  {
    *a3 = 0;
    a3[24] = 0;
  }
}

void sub_100933700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_10093371C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_1009317EC(&v11, a1, a2);
  if (v11)
  {
    sub_10112FC7C(*(void *)(v11 + 232), a3);
    uint64_t v6 = 0;
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v10 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to determine model while acknowledging incoming messages", v10, 2u);
    }
    uint64_t v7 = &_mh_execute_header;
    uint64_t v6 = 5;
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  return (unint64_t)v7 | v6;
}

void sub_10093380C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_100933828(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v41 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_100930190((uint64_t)buf, (void *)a1, a2, a3, a4);
    if ((_BYTE)v41)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      sub_100938114((uint64_t)v15, (uint64_t)buf);
      long long v27 = v40;
      if (*((void *)&v40 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D60748();
    }
    unint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to determine model while sending composing indicator", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938528((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100933AF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_1009306D0((uint64_t)&a19);
  sub_100938528((uint64_t)&a47);
  _Unwind_Resume(a1);
}

unint64_t sub_100933B44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)long long v29 = 0u;
    sub_100930190((uint64_t)v29, (void *)a1, a2, a3, a4);
    if ((_BYTE)v42)
    {
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)long long v16 = 0u;
      sub_100938114((uint64_t)v16, (uint64_t)v29);
      long long v28 = v41;
      if (*((void *)&v41 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)unint64_t v14 = 0u;
      sub_100930F70((uint64_t)__p, a1);
      if (LOBYTE(v14[1]))
      {
        std::string::operator=((std::string *)&v16[8], (const std::string *)__p);
      }
      else
      {
        uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", buf, 2u);
        }
      }
      if (LOBYTE(v14[1]))
      {
        if (SHIBYTE(v14[0]) < 0) {
          operator delete(__p[0]);
        }
      }
      sub_100D551EC(v28, a3);
    }
    unint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v16 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while sending disposition notification", v16, 2u);
    }
    unsigned int v9 = 3;
    sub_100938528((uint64_t)v29);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v29 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", v29, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100933ED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
}

uint64_t sub_100933F38(uint64_t a1, uint64_t a2)
{
  if (sub_10092F7B4(a1)) {
    return 0x100000004;
  }
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Device not IMS registered", v6, 2u);
  }
  return 0x100000001;
}

unint64_t sub_100933FE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v41 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_100930190((uint64_t)buf, (void *)a1, a2, a3, a4);
    if ((_BYTE)v41)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      sub_100938114((uint64_t)v15, (uint64_t)buf);
      long long v27 = v40;
      if (*((void *)&v40 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D609A0();
    }
    unint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while sending device action", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938528((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_1009342B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_1009306D0((uint64_t)&a19);
  sub_100938528((uint64_t)&a47);
  _Unwind_Resume(a1);
}

unint64_t sub_100934304(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v41 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_100930190((uint64_t)buf, (void *)a1, a2, a3, a4);
    if ((_BYTE)v41)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      sub_100938114((uint64_t)v15, (uint64_t)buf);
      long long v27 = v40;
      if (*((void *)&v40 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D60A68();
    }
    unint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while sending revoke", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938528((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_1009345CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_1009306D0((uint64_t)&a19);
  sub_100938528((uint64_t)&a47);
  _Unwind_Resume(a1);
}

uint64_t sub_10093461C(uint64_t a1, uint64_t a2)
{
  if (sub_10092F7B4(a1)) {
    return 0x100000004;
  }
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Device not IMS registered", v6, 2u);
  }
  return 0x100000001;
}

unint64_t sub_1009346CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_10092F89C((uint64_t)buf, (void *)a1, a2, a5, a3);
    if ((_BYTE)v42)
    {
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)long long v16 = 0u;
      sub_1009385C0((uint64_t)v16, (uint64_t)buf);
      long long v28 = v41;
      if (*((void *)&v41 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v16[8], (const std::string *)__str);
      }
      else
      {
        uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unint64_t v14 = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v14, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D60CC8();
    }
    uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v16 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid configuration while sending text to group chat", v16, 2u);
    }
    unsigned int v10 = 3;
    sub_100938644((uint64_t)buf);
  }
  else
  {
    unsigned int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v10 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v10;
}

void sub_1009349A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_100930150((uint64_t)&a19);
  sub_100938644((uint64_t)&a47);
  _Unwind_Resume(a1);
}

unint64_t sub_1009349F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v41 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_10092F89C((uint64_t)buf, (void *)a1, a2, a4, a3);
    if ((_BYTE)v41)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      sub_1009385C0((uint64_t)v15, (uint64_t)buf);
      long long v27 = v40;
      if (*((void *)&v40 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D60B30();
    }
    unsigned int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while sending text to group chat", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938644((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100934CC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_100930150((uint64_t)&a19);
  sub_100938644((uint64_t)&a47);
  _Unwind_Resume(a1);
}

unint64_t sub_100934D14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v41 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_10092F89C((uint64_t)buf, (void *)a1, a2, a4, a3);
    if ((_BYTE)v41)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      sub_1009385C0((uint64_t)v15, (uint64_t)buf);
      long long v27 = v40;
      if (*((void *)&v40 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D60BFC();
    }
    unsigned int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while sending geolocation to group chat", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938644((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100934FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_100930150((uint64_t)&a19);
  sub_100938644((uint64_t)&a47);
  _Unwind_Resume(a1);
}

unint64_t sub_100935040(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v41 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_10092F89C((uint64_t)buf, (void *)a1, a2, a4, a3);
    if ((_BYTE)v41)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      sub_1009385C0((uint64_t)v15, (uint64_t)buf);
      long long v27 = v40;
      if (*((void *)&v40 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D60DA4();
    }
    unsigned int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while sending file transfer information to group chat", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938644((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_10093530C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_100930150((uint64_t)&a19);
  sub_100938644((uint64_t)&a47);
  _Unwind_Resume(a1);
}

unint64_t sub_10093535C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v44 = 0;
    long long v45 = 0;
    sub_1009317EC(&v44, a1, a2);
    uint64_t v8 = v44;
    if (v44)
    {
      long long v42 = 0u;
      long long v43 = 0u;
      sub_10092FF38((uint64_t)&v42, a1, a2);
      if (BYTE8(v43))
      {
        *(_OWORD *)std::string __p = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v34 = 0u;
        long long v35 = 0u;
        long long v32 = 0u;
        long long v33 = 0u;
        long long v30 = 0u;
        long long v31 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        *(_OWORD *)std::string buf = 0u;
        long long v23 = 0u;
        sub_1002B2188((uint64_t)buf, a3);
        if (SBYTE7(v43) < 0)
        {
          sub_10004FC84(&v19, (void *)v42, *((unint64_t *)&v42 + 1));
        }
        else
        {
          long long v19 = v42;
          uint64_t v20 = v43;
        }
        int v16 = -1;
        int v21 = -1;
        if (SBYTE7(v41) < 0)
        {
          operator delete(__p[0]);
          int v16 = v21;
        }
        *(_OWORD *)std::string __p = v19;
        *(void *)&long long v41 = v20;
        DWORD2(v41) = v16;
        unint64_t v17 = sub_100D5E23C(v8, (uint64_t)buf, a4);
        unsigned __int8 v13 = v17;
        int v11 = v17 & 0xFFFFFF00;
        unint64_t v12 = v17 & 0xFFFFFFFF00000000;
        unint64_t v10 = v17 & 0xFFFFFF0000000000;
        sub_1002B26E8((uint64_t)buf);
      }
      else
      {
        uint64_t v15 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid phone number while creating Group Chat", buf, 2u);
        }
        unint64_t v10 = 0;
        unint64_t v12 = 0;
        unsigned __int8 v13 = 0;
        int v11 = 0;
      }
      if (BYTE8(v43) && SBYTE7(v43) < 0) {
        operator delete((void *)v42);
      }
    }
    else
    {
      unint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid configuration while creating group chat", buf, 2u);
      }
      unint64_t v10 = 0;
      int v11 = 0;
      unint64_t v12 = (unint64_t)&_mh_execute_header;
      unsigned __int8 v13 = 3;
    }
    if (v45) {
      sub_10004D2C8(v45);
    }
  }
  else
  {
    unsigned int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unint64_t v10 = 0;
    int v11 = 0;
    unint64_t v12 = (unint64_t)&_mh_execute_header;
    unsigned __int8 v13 = 1;
  }
  return v12 & 0xFF00000000 | v10 & 0xFFFFFF0000000000 | v13 | v11 & 0xFFFFFF00;
}

void sub_100935634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1002B26E8((uint64_t)va);
  if (*(unsigned char *)(v5 - 72) && *(char *)(v5 - 73) < 0) {
    operator delete(*(void **)(v5 - 96));
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v5 - 56);
  if (v7) {
    sub_10004D2C8(v7);
  }
  _Unwind_Resume(a1);
}

unint64_t sub_100935684(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)std::string buf = 0u;
    if (*(char *)(a5 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a5;
      *(void *)&long long v17 = *(void *)(a5 + 16);
    }
    sub_10092F89C((uint64_t)buf, (void *)a1, a2, (uint64_t)__p, a3);
    if (SBYTE7(v17) < 0) {
      operator delete(__p[0]);
    }
    if ((_BYTE)v42)
    {
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)std::string __p = 0u;
      sub_1009385C0((uint64_t)__p, (uint64_t)buf);
      long long v28 = v41;
      if (*((void *)&v41 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&__p[1], (const std::string *)__str);
      }
      else
      {
        unint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unint64_t v14 = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v14, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D5EF28();
    }
    int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid configuration while adding participants to group chat", (uint8_t *)__p, 2u);
    }
    unsigned int v10 = 3;
    sub_100938644((uint64_t)buf);
  }
  else
  {
    unsigned int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v10 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v10;
}

void sub_10093598C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_100930150((uint64_t)&a19);
  sub_100938644((uint64_t)&a47);
  _Unwind_Resume(a1);
}

void sub_1009359DC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x1009359D4);
}

unint64_t sub_1009359F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)std::string buf = 0u;
    if (*(char *)(a5 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a5;
      *(void *)&long long v17 = *(void *)(a5 + 16);
    }
    sub_10092F89C((uint64_t)buf, (void *)a1, a2, (uint64_t)__p, a3);
    if (SBYTE7(v17) < 0) {
      operator delete(__p[0]);
    }
    if ((_BYTE)v42)
    {
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)std::string __p = 0u;
      sub_1009385C0((uint64_t)__p, (uint64_t)buf);
      long long v28 = v41;
      if (*((void *)&v41 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&__p[1], (const std::string *)__str);
      }
      else
      {
        unint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unint64_t v14 = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v14, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D5F584();
    }
    int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid configuration while adding participants to group chat", (uint8_t *)__p, 2u);
    }
    unsigned int v10 = 3;
    sub_100938644((uint64_t)buf);
  }
  else
  {
    unsigned int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v10 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v10;
}

void sub_100935CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_100930150((uint64_t)&a19);
  sub_100938644((uint64_t)&a47);
  _Unwind_Resume(a1);
}

void sub_100935D4C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100935D44);
}

unint64_t sub_100935D64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)std::string buf = 0u;
    if (*(char *)(a5 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a5;
      *(void *)&long long v17 = *(void *)(a5 + 16);
    }
    sub_10092F89C((uint64_t)buf, (void *)a1, a2, (uint64_t)__p, a3);
    if (SBYTE7(v17) < 0) {
      operator delete(__p[0]);
    }
    if ((_BYTE)v42)
    {
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)std::string __p = 0u;
      sub_1009385C0((uint64_t)__p, (uint64_t)buf);
      long long v28 = v41;
      if (*((void *)&v41 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v41 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&__p[1], (const std::string *)__str);
      }
      else
      {
        unint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unint64_t v14 = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v14, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D5FBE0();
    }
    int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid configuration while adding participants to group chat", (uint8_t *)__p, 2u);
    }
    unsigned int v10 = 3;
    sub_100938644((uint64_t)buf);
  }
  else
  {
    unsigned int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v10 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v10;
}

void sub_10093606C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_100930150((uint64_t)&a19);
  sub_100938644((uint64_t)&a47);
  _Unwind_Resume(a1);
}

void sub_1009360BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x1009360B4);
}

unint64_t sub_1009360D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v43 = 0;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    *(_OWORD *)std::string buf = 0u;
    if (*(char *)(a5 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a5;
      *(void *)&long long v18 = *(void *)(a5 + 16);
    }
    sub_10092F89C((uint64_t)buf, (void *)a1, a2, (uint64_t)__p, a3);
    if (SBYTE7(v18) < 0) {
      operator delete(__p[0]);
    }
    if ((_BYTE)v43)
    {
      long long v28 = 0u;
      long long v29 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      *(_OWORD *)std::string __p = 0u;
      sub_1009385C0((uint64_t)__p, (uint64_t)buf);
      long long v29 = v42;
      if (*((void *)&v42 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v42 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&__p[1], (const std::string *)__str);
      }
      else
      {
        unsigned __int8 v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v15 = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v15, 2u);
        }
      }
      if (__str[24] && (__str[23] & 0x80000000) != 0) {
        operator delete(*(void **)__str);
      }
      if (*((void *)&v29 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v29 + 1));
      }
      sub_100CC90D0((uint64_t)__p);
      uint64_t v11 = 0;
      unsigned int v10 = 0;
    }
    else
    {
      unint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid configuration while adding participants to group chat", (uint8_t *)__p, 2u);
      }
      unsigned int v10 = &_mh_execute_header;
      uint64_t v11 = 3;
    }
    sub_100938644((uint64_t)buf);
  }
  else
  {
    unsigned int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v10 = &_mh_execute_header;
    uint64_t v11 = 1;
  }
  return (unint64_t)v10 & (unint64_t)&_mh_execute_header | v11;
}

void sub_1009363B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_100930150((uint64_t)&a19);
  sub_100938644((uint64_t)&a47);
  _Unwind_Resume(a1);
}

void sub_1009363FC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x1009363F4);
}

unint64_t sub_100936414(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    uint64_t v41 = 0;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    *(_OWORD *)std::string buf = 0u;
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a4;
      *(void *)&long long v16 = *(void *)(a4 + 16);
    }
    sub_10092F89C((uint64_t)buf, (void *)a1, a2, (uint64_t)__p, a3);
    if (SBYTE7(v16) < 0) {
      operator delete(__p[0]);
    }
    if ((_BYTE)v41)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)std::string __p = 0u;
      sub_1009385C0((uint64_t)__p, (uint64_t)buf);
      long long v27 = v40;
      if (*((void *)&v40 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&__p[1], (const std::string *)__str);
      }
      else
      {
        uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unsigned __int8 v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D600A8();
    }
    unsigned int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid configuration while adding participants to group chat", (uint8_t *)__p, 2u);
    }
    unsigned int v9 = 3;
    sub_100938644((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100936714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_100930150((uint64_t)&a19);
  sub_100938644((uint64_t)&a47);
  _Unwind_Resume(a1);
}

void sub_100936764(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x10093675CLL);
}

void sub_10093677C(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  std::string __p = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  PersonalityIdFromSlotId();
  uint64_t v7 = sub_100046F68(a1 + 112, &__p);
  if ((void **)(a1 + 120) == v7 || (uint64_t v8 = v7[7]) == 0)
  {
    unint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = HIBYTE(v18);
      if (v18 < 0) {
        uint64_t v13 = v17;
      }
      p_p = (const char *)&__p;
      if (v18 < 0) {
        p_p = (const char *)__p;
      }
      if (v13) {
        uint64_t v15 = p_p;
      }
      else {
        uint64_t v15 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315138;
      long long v20 = v15;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Not model found for handling group data management: %s", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v9 = v8[38];
    unsigned int v10 = (os_log_t *)(*(uint64_t (**)(void, void))(*(void *)v8[5] + 16))(v8[5], *((unsigned int *)v8 + 22));
    if (a4) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = 0x100000003;
    }
    sub_1002B1D90(v9, a3, v11, v10);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(__p);
  }
}

void sub_1009368F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100936914(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
}

unint64_t sub_10093691C(uint64_t a1, uint64_t a2, const void **a3)
{
  if (sub_10092F7B4(a1))
  {
    std::string __p = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    PersonalityIdFromSlotId();
    uint64_t v6 = sub_100046F68(a1 + 112, &__p);
    if ((void **)(a1 + 120) == v6 || (uint64_t v7 = (uint64_t)v6[7]) == 0)
    {
      unint64_t v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        uint64_t v16 = HIBYTE(v21);
        if (v21 < 0) {
          uint64_t v16 = v20;
        }
        p_p = (const char *)&__p;
        if (v21 < 0) {
          p_p = (const char *)__p;
        }
        if (v16) {
          uint64_t v18 = p_p;
        }
        else {
          uint64_t v18 = "<invalid>";
        }
        *(_DWORD *)std::string buf = 136315138;
        long long v23 = v18;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Not model found while deleting chat: %s", buf, 0xCu);
      }
      unint64_t v12 = 0;
      unint64_t v11 = 0;
      unsigned __int8 v9 = 0;
      int v10 = 0;
    }
    else
    {
      uint64_t v8 = sub_100D646E0(v7, a3);
      unsigned __int8 v9 = v8;
      int v10 = v8 & 0xFFFFFF00;
      unint64_t v11 = v8 & 0xFFFFFFFF00000000;
      unint64_t v12 = v8 & 0xFFFFFF0000000000;
    }
    if (SHIBYTE(v21) < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Device not IMS registered", (uint8_t *)&__p, 2u);
    }
    unint64_t v12 = 0;
    int v10 = 0;
    unint64_t v11 = (unint64_t)&_mh_execute_header;
    unsigned __int8 v9 = 1;
  }
  return v11 & 0xFF00000000 | v12 & 0xFFFFFF0000000000 | v9 | v10 & 0xFFFFFF00;
}

void sub_100936B0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_100936B30(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_100930710((uint64_t)buf, a1, a2, a4, a3);
    if (BYTE8(v44))
    {
      uint64_t v29 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      long long v16 = 0u;
      sub_100938684((uint64_t)v15, (uint64_t)buf);
      *((void *)&v28 + 1) = *((void *)&v43 + 1);
      uint64_t v29 = v44;
      if ((void)v44) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        unint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D60E70();
    }
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Bailing out", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938758((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100936E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_1009310B0((uint64_t)&a19);
  sub_100938758((uint64_t)&a51);
  _Unwind_Resume(a1);
}

unint64_t sub_100936E50(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_100930710((uint64_t)buf, a1, a2, a4, a3);
    if (BYTE8(v44))
    {
      uint64_t v29 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      long long v16 = 0u;
      sub_100938684((uint64_t)v15, (uint64_t)buf);
      *((void *)&v28 + 1) = *((void *)&v43 + 1);
      uint64_t v29 = v44;
      if ((void)v44) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        unint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D60F38();
    }
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Bailing out", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938758((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100937120(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_1009310B0((uint64_t)&a19);
  sub_100938758((uint64_t)&a51);
  _Unwind_Resume(a1);
}

unint64_t sub_100937170(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (sub_10092F7B4(a1))
  {
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_100930710((uint64_t)buf, a1, a2, a4, a3);
    if (BYTE8(v44))
    {
      uint64_t v29 = 0;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      long long v16 = 0u;
      sub_100938684((uint64_t)v15, (uint64_t)buf);
      *((void *)&v28 + 1) = *((void *)&v43 + 1);
      uint64_t v29 = v44;
      if ((void)v44) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
      }
      memset(__str, 0, sizeof(__str));
      sub_100930F70((uint64_t)__str, a1);
      if (__str[24])
      {
        std::string::operator=((std::string *)&v15[8], (const std::string *)__str);
      }
      else
      {
        unint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Falling back to trusted MSISDN rather than public identity", v13, 2u);
        }
      }
      if (__str[24])
      {
        if ((__str[23] & 0x80000000) != 0) {
          operator delete(*(void **)__str);
        }
      }
      sub_100D61000();
    }
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Bailing out", v15, 2u);
    }
    unsigned int v9 = 3;
    sub_100938758((uint64_t)buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Device not IMS registered", buf, 2u);
    }
    unsigned int v9 = 1;
  }
  return (unint64_t)&_mh_execute_header & 0xFF00000000 | v9;
}

void sub_100937440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  sub_1009310B0((uint64_t)&a19);
  sub_100938758((uint64_t)&a51);
  _Unwind_Resume(a1);
}

void sub_100937490(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 112);
  uint64_t v3 = (void *)(a1 + 120);
  if (v2 != (void *)(a1 + 120))
  {
    do
    {
      uint64_t v4 = SlotIdFromPersonalityId();
      uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I === Messaging dump ===", (uint8_t *)&__p, 2u);
      }
      sub_100D5410C(v2[7]);
      uint64_t v6 = (void *)v2[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v2[2];
          BOOL v8 = *v7 == (void)v2;
          uint64_t v2 = v7;
        }
        while (!v8);
      }
      uint64_t v2 = v7;
    }
    while (v7 != v3);
  }
  unsigned int v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 392)) {
      int v10 = "held";
    }
    else {
      int v10 = "not held";
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I power assertion : %{public}s", (uint8_t *)&__p, 0xCu);
  }
  if (*(void *)(a1 + 392) || *(void *)(a1 + 384))
  {
    unint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      sub_1000E8F34(*(std::string **)(a1 + 368), (std::string *)(a1 + 376), ",", 1uLL, &__p);
      unint64_t v12 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)std::string buf = 136446210;
      long long v16 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I \theld by : %{public}s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I === === ===", (uint8_t *)&__p, 2u);
  }
}

void sub_100937708(uint64_t a1, uint64_t a2)
{
  sub_100046BAC((uint64_t **)(a1 + 368), (void **)a2, a2);
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *(void *)a2;
    }
    LODWORD(v22) = 136446210;
    *(void *)((char *)&v22 + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Added messageID %{public}s to power assertion list", (uint8_t *)&v22, 0xCu);
    uint64_t v4 = *(NSObject **)(a1 + 40);
  }
  uint64_t v6 = *(void *)(a1 + 392);
  BOOL v7 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v7)
    {
      LOWORD(v22) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Incoming Lazuli message. Power assertion already held", (uint8_t *)&v22, 2u);
    }
    return;
  }
  if (v7)
  {
    LOWORD(v22) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Incoming Lazuli message. Taking power assertion", (uint8_t *)&v22, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(a1 + 80));
  int v10 = ServiceMap;
  if (v11 < 0)
  {
    unint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v22 = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v22);
  if (v15)
  {
    uint64_t v17 = v15[3];
    long long v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      if (!v17) {
        goto LABEL_17;
      }
LABEL_21:
      (*(void (**)(long long *__return_ptr, uint64_t, const char *, uint64_t))(*(void *)v17 + 8))(&v22, v17, "com.apple.ct.lazuliIncoming", 15);
      long long v20 = v22;
      long long v22 = 0uLL;
      long long v21 = *(std::__shared_weak_count **)(a1 + 400);
      *(_OWORD *)(a1 + 392) = v20;
      if (v21)
      {
        sub_10004D2C8(v21);
        if (*((void *)&v22 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v22 + 1));
        }
      }
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  long long v16 = 0;
  char v18 = 1;
  if (v17) {
    goto LABEL_21;
  }
LABEL_17:
  long long v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v22) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Missing power interface", (uint8_t *)&v22, 2u);
  }
LABEL_24:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
}

void sub_100937990(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009379C0(uint64_t a1, uint64_t a2)
{
}

void sub_1009379C8(void *a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t **)(a1 + 46);
  if (sub_10010E128((uint64_t)(a1 + 46), (void **)a2))
  {
    sub_1000E9358(v4, (void **)a2);
    uint64_t v5 = a1[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v6 = (void *)a2;
      }
      else {
        uint64_t v6 = *(void **)a2;
      }
      int v11 = 136446210;
      unint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Removed messageID %{public}s from power assertion list", (uint8_t *)&v11, 0xCu);
    }
    if (a1[49])
    {
      BOOL v7 = (void *)a1[48];
      BOOL v8 = a1[5];
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      if (v7)
      {
        if (v9)
        {
          int v11 = 134217984;
          unint64_t v12 = v7;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Power assertion still being held while %zu messages are being processed", (uint8_t *)&v11, 0xCu);
        }
      }
      else
      {
        if (v9)
        {
          LOWORD(v11) = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Releasing power assertion for incoming Lazuli message", (uint8_t *)&v11, 2u);
        }
        int v10 = (std::__shared_weak_count *)a1[50];
        a1[49] = 0;
        a1[50] = 0;
        if (v10) {
          sub_10004D2C8(v10);
        }
      }
    }
  }
}

void sub_100937B38(uint64_t a1, uint64_t a2)
{
}

void sub_100937B40(uint64_t a1)
{
  char v2 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v3 = (Registry **)(a1 + 80);
  sub_100562274(v3, (uint64_t)__p);
  *(_OWORD *)unsigned int v14 = *(_OWORD *)__p;
  uint64_t v15 = v13;
  __p[1] = 0;
  uint64_t v13 = 0;
  __p[0] = 0;
  ctu::path_join_impl();
  ctu::path_join_impl();
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v13 = 0;
  sub_100562274(v3, (uint64_t)buf);
  *(_OWORD *)std::string __p = *(_OWORD *)buf;
  uint64_t v13 = *(void *)&buf[16];
  memset(buf, 0, sizeof(buf));
  ctu::path_join_impl();
  ctu::path_join_impl();
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v10 = 0;
  int v11 = 0;
  Registry::getFileSystemInterface(&v10, *v3);
  if (v10)
  {
    if ((*(unsigned int (**)(uint64_t, void **))(*(void *)v10 + 88))(v10, v14))
    {
      uint64_t v4 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v10 + 112))(v10, v14);
      uint64_t v5 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = v14;
        if (v15 < 0) {
          uint64_t v6 = (void **)v14[0];
        }
        *(_DWORD *)std::string buf = 136446466;
        *(void *)&uint8_t buf[4] = v6;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v4;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Erased folder: [%{public}s] [status: %zu]", buf, 0x16u);
      }
    }
    if ((*(unsigned int (**)(uint64_t, void **))(*(void *)v10 + 88))(v10, __p))
    {
      uint64_t v7 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v10 + 112))(v10, __p);
      BOOL v8 = *v2;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v9 = v14;
        if (v15 < 0) {
          BOOL v9 = (void **)v14[0];
        }
        *(_DWORD *)std::string buf = 136446466;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Erased folder: [%{public}s] [status: %zu]", buf, 0x16u);
      }
    }
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
}

void sub_100937E70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100937F14(uint64_t a1)
{
  sub_100938798(a1);

  operator delete();
}

uint64_t sub_100937F4C(uint64_t a1)
{
  return sub_100938798(a1 - 56);
}

void sub_100937F54(uint64_t a1)
{
  sub_100938798(a1 - 56);

  operator delete();
}

uint64_t sub_100937F90(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_101A4E5B8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v6;
  }
  uint64_t v7 = *(void *)(a2 + 80);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(void *)(a1 + 80) = v7;
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
  sub_1000593FC(a1 + 104, (long long *)(a2 + 104));
  sub_1000593FC(a1 + 136, (long long *)(a2 + 136));
  return a1;
}

void sub_1009380A8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100938114(uint64_t a1, uint64_t a2)
{
  long long v4 = (void *)sub_100937F90(a1, a2);
  *long long v4 = off_101A4E5D8;
  long long v5 = v4 + 21;
  if (*(char *)(a2 + 191) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 168), *(void *)(a2 + 176));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 168);
    void v5[2] = *(void *)(a2 + 184);
    *(_OWORD *)long long v5 = v6;
  }
  return a1;
}

void sub_100938184(_Unwind_Exception *a1)
{
  sub_100CC8BDC(v1);
  _Unwind_Resume(a1);
}

void sub_100938198()
{
}

uint64_t sub_1009381B0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100937F90(a1, a2);
  *(void *)uint64_t v4 = off_101A4E618;
  if (*(char *)(a2 + 191) < 0)
  {
    sub_10004FC84((unsigned char *)(v4 + 168), *(void **)(a2 + 168), *(void *)(a2 + 176));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 168);
    *(void *)(v4 + 184) = *(void *)(a2 + 184);
    *(_OWORD *)(v4 + 168) = v5;
  }
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  sub_100938284((char *)(a1 + 192), *(long long **)(a2 + 192), *(long long **)(a2 + 200), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 200) - *(void *)(a2 + 192)) >> 3));
  return a1;
}

void sub_100938258(_Unwind_Exception *a1)
{
  sub_100CC8BDC(v1);
  _Unwind_Resume(a1);
}

char *sub_100938284(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_10093830C(result, a4);
    uint64_t result = sub_100938360((uint64_t)(v6 + 16), a2, a3, *((char **)v6 + 1));
    *((void *)v6 + 1) = result;
  }
  return result;
}

void sub_1009382EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100047F64(&a9);
  _Unwind_Resume(a1);
}

char *sub_10093830C(void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_100938198();
  }
  uint64_t result = (char *)sub_10004812C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

char *sub_100938360(uint64_t a1, long long *a2, long long *a3, char *__dst)
{
  uint64_t v4 = __dst;
  int v11 = __dst;
  unint64_t v12 = __dst;
  v9[0] = a1;
  v9[1] = &v11;
  void v9[2] = &v12;
  uint64_t v10 = 0;
  if (a2 != a3)
  {
    long long v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_10004FC84(v4, *(void **)v6, *((void *)v6 + 1));
        uint64_t v4 = v12;
      }
      else
      {
        long long v7 = *v6;
        *((void *)v4 + 2) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v4 = v7;
      }
      long long v6 = (long long *)((char *)v6 + 24);
      v4 += 24;
      unint64_t v12 = v4;
    }
    while (v6 != a3);
  }
  LOBYTE(v10) = 1;
  sub_10093841C((uint64_t)v9);
  return v4;
}

void sub_100938408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10093841C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1000D8AD4(a1);
  }
  return a1;
}

uint64_t sub_100938454(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100937F90(a1, a2);
  *(void *)uint64_t v4 = off_101A4E618;
  if (*(char *)(a2 + 191) < 0)
  {
    sub_10004FC84((unsigned char *)(v4 + 168), *(void **)(a2 + 168), *(void *)(a2 + 176));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 168);
    *(void *)(v4 + 184) = *(void *)(a2 + 184);
    *(_OWORD *)(v4 + 168) = v5;
  }
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  sub_100938284((char *)(a1 + 192), *(long long **)(a2 + 192), *(long long **)(a2 + 200), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 200) - *(void *)(a2 + 192)) >> 3));
  return a1;
}

void sub_1009384FC(_Unwind_Exception *a1)
{
  sub_100CC8BDC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100938528(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 208))
  {
    char v2 = *(std::__shared_weak_count **)(a1 + 200);
    if (v2) {
      sub_10004D2C8(v2);
    }
    sub_100CC8E78(a1);
  }
  return a1;
}

uint64_t sub_100938568(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1009385C0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)sub_100937F90(a1, a2);
  *uint64_t v4 = off_101A4E5F8;
  long long v5 = v4 + 21;
  if (*(char *)(a2 + 191) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 168), *(void *)(a2 + 176));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 168);
    void v5[2] = *(void *)(a2 + 184);
    *(_OWORD *)long long v5 = v6;
  }
  return a1;
}

void sub_100938630(_Unwind_Exception *a1)
{
  sub_100CC8BDC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100938644(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 208))
  {
    char v2 = *(std::__shared_weak_count **)(a1 + 200);
    if (v2) {
      sub_10004D2C8(v2);
    }
    sub_100CC90D0(a1);
  }
  return a1;
}

uint64_t sub_100938684(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100937F90(a1, a2);
  *(void *)uint64_t v4 = off_101A4E618;
  if (*(char *)(a2 + 191) < 0)
  {
    sub_10004FC84((unsigned char *)(v4 + 168), *(void **)(a2 + 168), *(void *)(a2 + 176));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 168);
    *(void *)(v4 + 184) = *(void *)(a2 + 184);
    *(_OWORD *)(v4 + 168) = v5;
  }
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  sub_100938284((char *)(a1 + 192), *(long long **)(a2 + 192), *(long long **)(a2 + 200), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 200) - *(void *)(a2 + 192)) >> 3));
  return a1;
}

void sub_10093872C(_Unwind_Exception *a1)
{
  sub_100CC8BDC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100938758(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 232))
  {
    char v2 = *(std::__shared_weak_count **)(a1 + 224);
    if (v2) {
      sub_10004D2C8(v2);
    }
    sub_100CC93B8(a1);
  }
  return a1;
}

uint64_t sub_100938798(uint64_t a1)
{
  *(void *)a1 = off_101A1CA90;
  *(void *)(a1 + 56) = off_101A1CBF8;
  char v2 = *(std::__shared_weak_count **)(a1 + 400);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10005CD2C(a1 + 368, *(char **)(a1 + 376));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 360);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 344);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10005CD2C(a1 + 312, *(char **)(a1 + 320));
  sub_1001F6F58(a1 + 288, *(void **)(a1 + 296));
  sub_1004E9278((void *)(a1 + 256));
  sub_10021D564(a1 + 232, *(char **)(a1 + 240));
  sub_1001F7124(a1 + 208, *(void **)(a1 + 216));
  sub_1001F701C(a1 + 184, *(void **)(a1 + 192));
  sub_1007322F4(a1 + 160, *(void **)(a1 + 168));
  sub_10005CD2C(a1 + 136, *(char **)(a1 + 144));
  sub_1001FEC70(*(void **)(a1 + 120));
  long long v5 = *(std::__shared_weak_count **)(a1 + 104);
  if (v5) {
    sub_10004D2C8(v5);
  }
  long long v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6) {
    sub_10004D2C8(v6);
  }
  long long v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7) {
    sub_10004D2C8(v7);
  }
  LazuliLifetimeInterface::~LazuliLifetimeInterface((LazuliLifetimeInterface *)a1);
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100938900(dispatch_object_t *a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x1B0uLL);
  sub_10093898C(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;

  sub_1000B3BC8((uint64_t)a4, v8 + 4, (uint64_t)(v8 + 3));
}

void sub_100938978(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10093898C(void *a1, dispatch_object_t *a2, uint64_t *a3, uint64_t *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A1CD20;
  sub_100938A84(a1 + 3, a2, a3, a4);
  return a1;
}

void sub_1009389D4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1009389E8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A1CD20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100938A08(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1CD20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100938A5C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 48))();
}

uint64_t *sub_100938A84(uint64_t *a1, dispatch_object_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v6 = *a3;
  long long v7 = (std::__shared_weak_count *)a3[1];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *a4;
  uint64_t v8 = (std::__shared_weak_count *)a4[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = v6;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = operator new(0x20uLL);
  v10[1] = 0;
  uint64_t v10[2] = 0;
  void *v10 = off_101A1CD70;
  v10[3] = off_101A1CDC0;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "lazuli.msg.ctr");
  a1[1] = 0;
  a1[2] = 0;
  int v11 = *a2;
  a1[3] = (uint64_t)*a2;
  if (v11) {
    dispatch_retain(v11);
  }
  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v20, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v20);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v20);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  v20[0] = off_101999E18;
  v20[1] = sub_10092E888;
  void v20[3] = v20;
  a1[6] = 0;
  if ((capabilities::ct::supportsGemini(v12) & 1) == 0) {
    operator new();
  }
  if (!a1[6]) {
    operator new();
  }
  sub_10008863C(v20);
  *a1 = (uint64_t)off_101A1CA90;
  a1[7] = (uint64_t)off_101A1CBF8;
  sub_100058DB0(&__p, "lazuli.msg.ctr");
  long long v19 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  ctu::RestModule::RestModule();
  if (v19) {
    dispatch_release(v19);
  }
  if (v22 < 0) {
    operator delete(__p.var0);
  }
  a1[10] = v18;
  a1[11] = (uint64_t)v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  a1[18] = 0;
  a1[17] = (uint64_t)(a1 + 18);
  a1[12] = (uint64_t)(v10 + 3);
  a1[13] = (uint64_t)v10;
  a1[16] = 0;
  a1[15] = 0;
  a1[14] = (uint64_t)(a1 + 15);
  a1[19] = 0;
  a1[21] = 0;
  a1[20] = (uint64_t)(a1 + 21);
  a1[22] = 0;
  DefaultLazuliRegistrationInitializerMap = GetDefaultLazuliRegistrationInitializerMap();
  sub_1001FE2D0(a1 + 23, (uint64_t)DefaultLazuliRegistrationInitializerMap);
  DefaultLazuliProvisioningInitializerMap = GetDefaultLazuliProvisioningInitializerMap();
  sub_1001FDE4C(a1 + 26, (uint64_t)DefaultLazuliProvisioningInitializerMap);
  DefaultLazuliMessagingInformationMap = GetDefaultLazuliMessagingInformationMap();
  sub_1004EE488(a1 + 29, (uint64_t)DefaultLazuliMessagingInformationMap);
  DefaultLazuliChatBotInformationMap = GetDefaultLazuliChatBotInformationMap();
  sub_1004E9620((uint64_t)(a1 + 32), (uint64_t)DefaultLazuliChatBotInformationMap);
  a1[39] = (uint64_t)(a1 + 40);
  a1[40] = 0;
  a1[41] = 0;
  a1[42] = v9;
  a1[43] = (uint64_t)v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  a1[44] = 0;
  a1[45] = 0;
  a1[46] = (uint64_t)(a1 + 47);
  a1[47] = 0;
  a1[49] = 0;
  a1[50] = 0;
  a1[48] = 0;
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
  return a1;
}

void sub_100938EC8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, uint64_t a10, uint64_t a11, dispatch_object_t object, dispatch_object_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

void sub_1009390C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A1CD70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009390E8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1CD70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10093913C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100939168()
{
}

void sub_10093917C(uint64_t a1, NSObject **a2, uint64_t *a3, long long *a4)
{
  uint64_t v7 = *a3;
  uint64_t v6 = a3[1];
  uint64_t v8 = operator new(0x198uLL);
  v8[1] = 0;
  void v8[2] = 0;
  *uint64_t v8 = off_101A1CE00;
  v9[0] = v7;
  v9[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100D53078((uint64_t)(v8 + 3), a2, v9, a4);
}

void sub_10093928C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v12);
  _Unwind_Resume(a1);
}

void sub_1009392B0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A1CE00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009392D0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1CE00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100939324(uint64_t a1)
{
  sub_10093947C(a1 + 384, *(void **)(a1 + 392));
  unint64_t v12 = (void **)(a1 + 360);
  sub_10005CBF0(&v12);
  char v2 = *(std::__shared_weak_count **)(a1 + 352);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 336);
  if (v3) {
    sub_10004D2C8(v3);
  }
  unint64_t v12 = (void **)(a1 + 304);
  sub_10005CBF0(&v12);
  unint64_t v12 = (void **)(a1 + 280);
  sub_10005CBF0(&v12);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 272);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10093957C((uint64_t *)(a1 + 256), 0);
  long long v5 = *(std::__shared_weak_count **)(a1 + 248);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 232);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 216);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 200);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 104);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v10 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 56));
  return sub_100087E88((void *)(a1 + 24));
}

void sub_10093947C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10093947C(a1, *a2);
    sub_10093947C(a1, a2[1]);
    sub_1009394D8((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t sub_1009394D8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176) && *(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(unsigned char *)(a1 + 136) && *(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  uint64_t v3 = (void **)(a1 + 88);
  sub_100047F64(&v3);
  if (*(unsigned char *)(a1 + 80) && *(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_10093957C(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_1009395CC(result);
    operator delete();
  }
  return result;
}

void sub_1009395CC(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 128);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 112);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1004EC6A0(a1 + 80, *(void **)(a1 + 88));
  sub_1004EC6A0(a1 + 56, *(void **)(a1 + 64));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)a1);
}

void sub_10093967C()
{
}

uint64_t sub_100939690(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_1009396A0()
{
}

__n128 sub_1009396B4(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_101A1CE90;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100939708(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1CE90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100939740(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100256368((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100939800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100939818(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100939858()
{
}

void sub_100939868()
{
}

__n128 sub_10093987C(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_101A1CF10;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009398D0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1CF10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100939908(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1001FF71C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1001F701C((uint64_t)&v9, v10);
}

void sub_1009399C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009399E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100939A20()
{
}

void sub_100939A30()
{
}

__n128 sub_100939A44(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_101A1CF90;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100939A98(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1CF90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100939AD0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1001FFE94((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1001F7124((uint64_t)&v9, v10);
}

void sub_100939B90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100939BA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100939BE8()
{
}

void sub_100939BF8()
{
}

__n128 sub_100939C0C(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_101A1D010;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100939C60(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A1D010;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100939C98(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1002430C8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100939D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100939D70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100939DB0()
{
}

void sub_100939DC0()
{
}

void *sub_100939DD4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A1D090;
  result[1] = v3;
  return result;
}

uint64_t sub_100939E1C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A1D090;
  a2[1] = v2;
  return result;
}

void sub_100939E48(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  uint64_t v4 = (uint64_t **)(v2 + 8);
  sub_10021D564(v2, *(char **)(v2 + 8));
  *(void *)uint64_t v2 = v2 + 8;
  *(void *)(v2 + 16) = 0;
  *(void *)(v2 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v20, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v19, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v21; ; uint64_t i = ++v21)
    {
      if (i == v19[1] && v20 == v19[0])
      {
        xpc_release(v20);
        xpc_release(v20);
        goto LABEL_47;
      }
      xpc_object_t v18 = 0;
      object[0] = &v20;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v18);
      if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_45:
      xpc_release(v18);
    }
    memset(object, 0, sizeof(object));
    xpc_object_t v7 = v18;
    if (v18)
    {
      xpc_retain(v18);
      xpc_object_t v25 = v7;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v25 = v7;
      if (!v7)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v7;
LABEL_27:
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        char v22 = &v25;
        long long v23 = "first";
        sub_100048BAC((uint64_t)&v22, v24);
        xpc_type_t type = xpc_get_type(*(xpc_object_t *)v24);
        if (type == (xpc_type_t)&_xpc_type_string)
        {
          int v26 = (int)object[0];
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v26, v24, v10);
          LODWORD(object[0]) = v26;
        }
        else if (type == (xpc_type_t)&_xpc_type_BOOL {
               || type == (xpc_type_t)&_xpc_type_int64
        }
               || type == (xpc_type_t)&_xpc_type_uint64)
        {
          LODWORD(object[0]) = xpc::dyn_cast_or_default((xpc *)v24, 0, (uint64_t)v10);
        }
        xpc_release(*(xpc_object_t *)v24);
        char v22 = &v25;
        long long v23 = "second";
        sub_100048BAC((uint64_t)&v22, v24);
        read_rest_value((uint64_t)&object[1], (void **)v24);
        xpc_release(*(xpc_object_t *)v24);
        xpc_object_t v8 = v25;
      }
      xpc_release(v8);
      xpc_release(v7);
      int v11 = (int)object[0];
      unint64_t v12 = *v4;
      uint64_t v13 = (uint64_t **)(v2 + 8);
      unsigned int v14 = (uint64_t **)(v2 + 8);
      if (*v4)
      {
        while (1)
        {
          while (1)
          {
            unsigned int v14 = (uint64_t **)v12;
            int v15 = *((_DWORD *)v12 + 8);
            if (v15 <= SLODWORD(object[0])) {
              break;
            }
            unint64_t v12 = *v14;
            uint64_t v13 = v14;
            if (!*v14) {
              goto LABEL_42;
            }
          }
          if (v15 >= SLODWORD(object[0])) {
            break;
          }
          unint64_t v12 = v14[1];
          if (!v12)
          {
            uint64_t v13 = v14 + 1;
            goto LABEL_42;
          }
        }
      }
      else
      {
LABEL_42:
        long long v16 = (char *)operator new(0x60uLL);
        *((_DWORD *)v16 + 8) = v11;
        *(_OWORD *)(v16 + 40) = *(_OWORD *)&object[1];
        *(_OWORD *)(v16 + 52) = *(_OWORD *)((char *)&object[2] + 4);
        *(_OWORD *)(v16 + 72) = *(_OWORD *)&object[5];
        *((xpc_object_t *)v16 + 11) = object[7];
        memset(&object[5], 0, 24);
        sub_100046C38((uint64_t **)v2, (uint64_t)v14, v13, (uint64_t *)v16);
      }
      if (SHIBYTE(object[7]) < 0) {
        operator delete(object[5]);
      }
      goto LABEL_45;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_26:
    xpc_object_t v25 = v8;
    goto LABEL_27;
  }
LABEL_47:
  xpc_release(v3);
}

void sub_10093A21C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, xpc_object_t a20,xpc_object_t a21,uint64_t a22,xpc_object_t a23)
{
  xpc_release(object);
  xpc_release(a23);
  xpc_release(v23);
  _Unwind_Resume(a1);
}

uint64_t sub_10093A30C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10093A34C()
{
}

void sub_10093A35C()
{
}

void *sub_10093A370(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A1D110;
  result[1] = v3;
  return result;
}

uint64_t sub_10093A3B8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A1D110;
  a2[1] = v2;
  return result;
}

void sub_10093A3E4(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_10093A3EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10093A42C()
{
}

void sub_10093A438(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1007322F4(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v21, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v20, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v22; i != v20[1] || v21 != v20[0]; uint64_t i = ++v22)
    {
      xpc_object_t v19 = 0;
      object[0] = &v21;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v19);
      if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v18 = 0;
        long long v16 = 0u;
        long long v17 = 0u;
        long long v15 = 0u;
        long long v13 = 0u;
        long long v14 = 0u;
        long long v11 = 0u;
        long long v12 = 0u;
        long long v9 = 0u;
        long long v10 = 0u;
        *(_OWORD *)dispatch_object_t object = 0u;
        long long v8 = 0u;
        xpc_object_t v6 = v19;
        if (v19) {
          xpc_retain(v19);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_10093A6F4((uint64_t)object, &v6);
        xpc_release(v6);
        sub_10093A83C((uint64_t **)a1, object, (long long *)object);
        sub_1007320C0((uint64_t)object);
      }
      xpc_release(v19);
    }
    xpc_release(v21);
    xpc_release(v21);
  }
  xpc_release(v3);
}

void sub_10093A658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 64));
  xpc_release(v11);
  _Unwind_Resume(a1);
}

void sub_10093A6F4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v7 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v7 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v4 = &v7;
    uint64_t v5 = "first";
    sub_100048BAC((uint64_t)&v4, &object);
    read_rest_value();
    xpc_release(object);
    uint64_t v4 = &v7;
    uint64_t v5 = "second";
    sub_100048BAC((uint64_t)&v4, &object);
    sub_100594AD8(a1 + 24, &object);
    xpc_release(object);
    xpc_object_t v3 = v7;
  }
  xpc_release(v3);
}

void sub_10093A7E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12)
{
}

char *sub_10093A83C(uint64_t **a1, void **a2, long long *a3)
{
  uint64_t v10 = 0;
  uint64_t v5 = (char **)sub_100046ED4((uint64_t)a1, &v10, a2);
  xpc_object_t v6 = *v5;
  if (!*v5)
  {
    xpc_object_t v7 = (uint64_t **)v5;
    memset(v9, 0, sizeof(v9));
    sub_10093A8DC((uint64_t)a1, a3, v9);
    sub_100046C38(a1, v10, v7, (uint64_t *)v9[0]);
    xpc_object_t v6 = v9[0];
    v9[0] = 0;
    sub_100732068((uint64_t)v9, 0);
  }
  return v6;
}

char *sub_10093A8DC@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, char **a3@<X8>)
{
  uint64_t v5 = (char *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  xpc_object_t v6 = (char *)operator new(0xD8uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = sub_10093A950(v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10093A938(_Unwind_Exception *a1)
{
  sub_100732068(v1, 0);
  _Unwind_Resume(a1);
}

char *sub_10093A950(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  long long v5 = *(long long *)((char *)a2 + 24);
  *((void *)__dst + 5) = *((void *)a2 + 5);
  *(_OWORD *)(__dst + 24) = v5;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 3) = 0;
  long long v6 = a2[3];
  *((void *)__dst + 8) = *((void *)a2 + 8);
  *((_OWORD *)__dst + 3) = v6;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  *((void *)a2 + 6) = 0;
  long long v7 = *(long long *)((char *)a2 + 72);
  *((void *)__dst + 11) = *((void *)a2 + 11);
  *(_OWORD *)(__dst + 72) = v7;
  *((void *)a2 + 10) = 0;
  *((void *)a2 + 11) = 0;
  *((void *)a2 + 9) = 0;
  long long v8 = a2[6];
  *((void *)__dst + 14) = *((void *)a2 + 14);
  *((_OWORD *)__dst + 6) = v8;
  *((void *)a2 + 12) = 0;
  *((void *)a2 + 13) = 0;
  *((void *)a2 + 14) = 0;
  *((void *)__dst + 15) = 0;
  *((void *)__dst + 16) = 0;
  *((void *)__dst + 17) = 0;
  *(_OWORD *)(__dst + 120) = *(long long *)((char *)a2 + 120);
  *((void *)__dst + 17) = *((void *)a2 + 17);
  *((void *)a2 + 15) = 0;
  *((void *)a2 + 16) = 0;
  *((void *)a2 + 17) = 0;
  *((void *)__dst + 18) = 0;
  *((void *)__dst + 19) = 0;
  *((void *)__dst + 20) = 0;
  *((_OWORD *)__dst + 9) = a2[9];
  *((void *)__dst + 20) = *((void *)a2 + 20);
  *((void *)a2 + 19) = 0;
  *((void *)a2 + 20) = 0;
  *((void *)a2 + 18) = 0;
  *((_DWORD *)__dst + 42) = *((_DWORD *)a2 + 42);
  *((void *)__dst + 22) = 0;
  *((void *)__dst + 22) = *((void *)a2 + 22);
  *((void *)a2 + 22) = 0;
  return __dst;
}

const char *sub_10093AA58(unsigned int a1)
{
  if (a1 > 0x13) {
    return "???";
  }
  else {
    return off_101A1D180[a1];
  }
}

const char *sub_10093AA7C(int a1)
{
  __n128 result = "kFakeEmergencyStart";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      __n128 result = "kEmergencyStart";
      break;
    case 2:
      __n128 result = "kEmergencyMessage";
      break;
    case 3:
      __n128 result = "kEmergencyLocationUpdate";
      break;
    case 4:
      __n128 result = "kFindMyMessage";
      break;
    case 5:
      __n128 result = "kFakeRoadsideStart";
      break;
    case 6:
      __n128 result = "kRoadsideStart";
      break;
    case 7:
      __n128 result = "kRoadsideMessage";
      break;
    case 8:
      __n128 result = "kRoadsideLocationUpdate";
      break;
    case 9:
      __n128 result = "kCarrierPigeonMessage";
      break;
    case 10:
      __n128 result = "kCarrierPigeonIMessageLiteMessage";
      break;
    case 11:
      __n128 result = "kCarrierPigeonFetchMessage";
      break;
    case 12:
      __n128 result = "kSatSmsStartMessage";
      break;
    case 13:
      __n128 result = "kSatSmsMessage";
      break;
    default:
      long long v4 = "kUnknown";
      if (a1 != 63) {
        long long v4 = "???";
      }
      if (a1 == 62) {
        __n128 result = "kErrorMessage";
      }
      else {
        __n128 result = v4;
      }
      break;
  }
  return result;
}

BOOL isMandatoryDisabledVoLTE(int a1)
{
  if (a1 == 1) {
    uint64_t v1 = "DisableVoLTE_slot1";
  }
  else {
    uint64_t v1 = "DisableVoLTE_slot2";
  }
  int v7 = 0;
  uint64_t v2 = sub_100365D74();
  sub_100058DB0(__p, v1);
  BOOL v3 = sub_10072A8A0(v2, __p, &v7);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return v3;
}

void sub_10093AC30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void mandatoryDisableVoLTE(Registry **a1, uint64_t a2, int a3)
{
  if (a2 == 1) {
    char v6 = "DisableVoLTE_slot1";
  }
  else {
    char v6 = "DisableVoLTE_slot2";
  }
  int v21 = 1;
  uint64_t v7 = sub_100365D74();
  sub_100058DB0(&__p, v6);
  int v8 = sub_10072A8A0(v7, (void **)&__p.__r_.__value_.__l.__data_, &v21);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v8 != a3)
  {
    long long v9 = (uint64_t **)sub_100365D74();
    sub_100058DB0(&__p, v6);
    if (a3) {
      sub_1006560E0(v9, &__p, &v21);
    }
    else {
      sub_1003660FC(v9, (void **)&__p.__r_.__value_.__l.__data_);
    }
    uint64_t v10 = (uint64_t *)SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((v10 & 0x80000000) != 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *a1);
    uint64_t v12 = ServiceMap;
    if ((v13 & 0x8000000000000000) != 0)
    {
      long long v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        std::string::size_type v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    __p.__r_.__value_.__r.__words[0] = v13;
    long long v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&__p);
    if (!v17)
    {
      std::mutex::unlock(v12);
      return;
    }
    uint64_t v19 = v17[3];
    uint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      if (!v19)
      {
LABEL_26:
        sub_10004D2C8(v18);
        return;
      }
    }
    else
    {
      std::mutex::unlock(v12);
      if (!v19) {
        return;
      }
    }
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v19 + 8))(&__p, v19, a2);
    if (__p.__r_.__value_.__r.__words[0]) {
      (*(void (**)(std::string::size_type, uint64_t))(*(void *)__p.__r_.__value_.__l.__data_ + 64))(__p.__r_.__value_.__r.__words[0], 2);
    }
    if (__p.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
    }
    if (v18) {
      goto LABEL_26;
    }
  }
}

void sub_10093AE50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, std::__shared_weak_count *a10, int a11, __int16 a12, char a13, char a14)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void VoLteControl::create()
{
}

void sub_10093AF88(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t VoLteControl::VoLteControl(uint64_t a1, void *a2, NSObject **a3, void *a4, uint64_t a5)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v18, kCtLoggingSystemName, "ps.vol");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v10 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v19, &v18);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  *(void *)a1 = off_101A1D230;
  *(void *)(a1 + 48) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 56) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 72) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 80) = a5;
  sub_100058DB0(&__p, "VoLteControl");
  std::string::size_type v13 = *(NSObject **)(a1 + 24);
  uint64_t v15 = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  ctu::RestModule::RestModule();
  if (v15) {
    dispatch_release(v15);
  }
  if (v17 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 160) = a1 + 168;
  *(_DWORD *)(a1 + 152) = 1;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 184) = a1 + 192;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 208) = a1 + 216;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 232) = a1 + 240;
  *(void *)(a1 + 256) = a1 + 264;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(unsigned char *)(a1 + 292) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(unsigned char *)(a1 + 284) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  MCCAndMNC::MCCAndMNC((MCCAndMNC *)(a1 + 312));
  *(_WORD *)(a1 + 376) = 0;
  sub_10024F9A0(a1 + 384, a2, *(_DWORD *)(*(void *)*a4 + 52));
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  return a1;
}

void sub_10093B220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, void *a11, uint64_t a12, dispatch_object_t object, dispatch_object_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,char a23)
{
  sub_10013C44C(v26);
  sub_10003FB28(v25, *(void **)(v23 + 264));
  sub_1000346F8(v24, *(void **)(v23 + 240));
  sub_1000346F8(v31, *(void **)(v23 + 216));
  sub_1000346F8(v30, *(void **)(v23 + 192));
  sub_100087F94(v29, *(void **)(v23 + 168));
  sub_10005CD2C(v28, *(char **)(v23 + 136));
  sub_10026CF54(v27, *(void **)(v23 + 112));
  long long v33 = *(std::__shared_weak_count **)(v23 + 96);
  if (v33) {
    sub_10004D2C8(v33);
  }
  long long v34 = *(std::__shared_weak_count **)(v23 + 72);
  if (v34) {
    sub_10004D2C8(v34);
  }
  long long v35 = *(std::__shared_weak_count **)(v23 + 56);
  if (v35) {
    sub_10004D2C8(v35);
  }
  ctu::OsLogLogger::~OsLogLogger(a10);
  sub_100087E88(a11);
  _Unwind_Resume(a1);
}

uint64_t sub_10093B324(uint64_t a1)
{
  *(void *)a1 = off_101A1D230;
  int v2 = *(std::__shared_weak_count **)(a1 + 424);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10024FA8C((ctu::OsLogLogger *)(a1 + 384));
  if (*(char *)(a1 + 375) < 0) {
    operator delete(*(void **)(a1 + 352));
  }
  if (*(char *)(a1 + 343) < 0) {
    operator delete(*(void **)(a1 + 320));
  }
  sub_10003FB28(a1 + 256, *(void **)(a1 + 264));
  sub_1000346F8(a1 + 232, *(void **)(a1 + 240));
  sub_1000346F8(a1 + 208, *(void **)(a1 + 216));
  sub_1000346F8(a1 + 184, *(void **)(a1 + 192));
  sub_100087F94(a1 + 160, *(void **)(a1 + 168));
  sub_10005CD2C(a1 + 128, *(char **)(a1 + 136));
  sub_10026CF54(a1 + 104, *(void **)(a1 + 112));
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 96);
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10093B428(uint64_t a1)
{
  sub_10093B324(a1);

  operator delete();
}

uint64_t sub_10093B460(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 88));
}

BOOL sub_10093B468(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v4;
    __int16 v112 = 2080;
    uint64_t v113 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sinitializing", buf, 0x16u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 48));
  char v6 = ServiceMap;
  if (v7 < 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
LABEL_11:
  long long v14 = *(std::__shared_weak_count **)(a1 + 424);
  *(void *)(a1 + 416) = v13;
  *(void *)(a1 + 424) = v12;
  if (v14) {
    sub_10004D2C8(v14);
  }
  int v110 = 0;
  uint64_t v15 = sub_100365D74();
  sub_100058DB0(buf, "kEnableIMSUserPreference");
  BOOL v16 = sub_1004421D8(v15, (void **)buf, &v110);
  BOOL v17 = v16;
  if (v114 < 0)
  {
    operator delete(*(void **)buf);
    if (!v17) {
      goto LABEL_31;
    }
  }
  else if (!v16)
  {
    goto LABEL_31;
  }
  OsLogContext v18 = (uint64_t **)sub_100365D74();
  sub_100058DB0(buf, "kEnableIMSUserPreference");
  sub_1003660FC(v18, (void **)buf);
  uint64_t v19 = (uint64_t *)v114;
  if ((v19 & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  xpc_object_t v20 = (std::mutex *)Registry::getServiceMap(v19, *(Registry **)(a1 + 48));
  int v21 = v20;
  if (v22 < 0)
  {
    uint64_t v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v24 = 5381;
    do
    {
      uint64_t v22 = v24;
      unsigned int v25 = *v23++;
      uint64_t v24 = (33 * v24) ^ v25;
    }
    while (v25);
  }
  std::mutex::lock(v20);
  *(void *)std::string buf = v22;
  uint64_t v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)buf);
  if (!v26)
  {
    uint64_t v28 = 0;
    goto LABEL_26;
  }
  uint64_t v28 = v26[3];
  uint64_t v27 = (std::__shared_weak_count *)v26[4];
  if (!v27)
  {
LABEL_26:
    std::mutex::unlock(v21);
    uint64_t v27 = 0;
    char v29 = 1;
    goto LABEL_27;
  }
  atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v21);
  atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v27);
  char v29 = 0;
LABEL_27:
  uint64_t v30 = **(void **)(a1 + 64);
  __p[0] = 0;
  *(_DWORD *)std::string buf = v110;
  CFNumberRef v31 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
  if (v31)
  {
    long long v32 = __p[0];
    __p[0] = v31;
    *(void *)std::string buf = v32;
    sub_1000570E8((const void **)buf);
  }
  uint64_t v109 = __p[0];
  __p[0] = 0;
  sub_1000570E8((const void **)__p);
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void *, void, void, uint64_t, void))(*(void *)v28 + 48))(v28, v30 + 24, @"VoLTEUserPreference", v109, kPhoneServicesWalletDomain, 0, 1, 0);
  sub_1000570E8((const void **)&v109);
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v27);
  }
LABEL_31:
  LOBYTE(__p[0]) = 0;
  uint64_t v33 = sub_100365D74();
  sub_100058DB0(buf, "VoLTEBlockedByNetwork");
  BOOL v34 = sub_1002260B0(v33, (void **)buf, (BOOL *)__p);
  BOOL v35 = v34;
  if (v114 < 0)
  {
    operator delete(*(void **)buf);
    if (!v35) {
      goto LABEL_47;
    }
  }
  else if (!v34)
  {
    goto LABEL_47;
  }
  long long v36 = (uint64_t **)sub_100365D74();
  sub_100058DB0(buf, "VoLTEBlockedByNetwork");
  sub_1003660FC(v36, (void **)buf);
  long long v37 = (uint64_t *)v114;
  if ((v37 & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  long long v38 = (std::mutex *)Registry::getServiceMap(v37, *(Registry **)(a1 + 48));
  long long v39 = v38;
  if (v40 < 0)
  {
    long long v41 = (unsigned __int8 *)(v40 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v42 = 5381;
    do
    {
      uint64_t v40 = v42;
      unsigned int v43 = *v41++;
      uint64_t v42 = (33 * v42) ^ v43;
    }
    while (v43);
  }
  std::mutex::lock(v38);
  *(void *)std::string buf = v40;
  long long v44 = sub_10004D37C(&v39[1].__m_.__sig, (unint64_t *)buf);
  if (v44)
  {
    uint64_t v46 = v44[3];
    long long v45 = (std::__shared_weak_count *)v44[4];
    if (v45)
    {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v39);
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v45);
      char v47 = 0;
      goto LABEL_45;
    }
  }
  else
  {
    uint64_t v46 = 0;
  }
  std::mutex::unlock(v39);
  long long v45 = 0;
  char v47 = 1;
LABEL_45:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v46 + 16))(v46, **(void **)(a1 + 64) + 24, @"VoLTEBlockedByNetwork", kCFBooleanTrue, kPhoneServicesWalletDomain, 0, 1, 0);
  if ((v47 & 1) == 0) {
    sub_10004D2C8(v45);
  }
LABEL_47:
  LOBYTE(v109) = 0;
  uint64_t v48 = sub_100365D74();
  sub_100058DB0(buf, "VoLTENetworkSeen");
  BOOL v49 = sub_1002260B0(v48, (void **)buf, (BOOL *)&v109);
  BOOL v50 = v49;
  if (v114 < 0)
  {
    operator delete(*(void **)buf);
    if (!v50) {
      goto LABEL_63;
    }
  }
  else if (!v49)
  {
    goto LABEL_63;
  }
  long long v51 = (uint64_t **)sub_100365D74();
  sub_100058DB0(buf, "VoLTENetworkSeen");
  sub_1003660FC(v51, (void **)buf);
  long long v52 = (uint64_t *)v114;
  if ((v52 & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  long long v53 = (std::mutex *)Registry::getServiceMap(v52, *(Registry **)(a1 + 48));
  long long v54 = v53;
  if (v55 < 0)
  {
    long long v56 = (unsigned __int8 *)(v55 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v57 = 5381;
    do
    {
      uint64_t v55 = v57;
      unsigned int v58 = *v56++;
      uint64_t v57 = (33 * v57) ^ v58;
    }
    while (v58);
  }
  std::mutex::lock(v53);
  *(void *)std::string buf = v55;
  uint64_t v59 = sub_10004D37C(&v54[1].__m_.__sig, (unint64_t *)buf);
  if (v59)
  {
    uint64_t v61 = v59[3];
    int64x2_t v60 = (std::__shared_weak_count *)v59[4];
    if (v60)
    {
      atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v54);
      atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v60);
      char v62 = 0;
      goto LABEL_61;
    }
  }
  else
  {
    uint64_t v61 = 0;
  }
  std::mutex::unlock(v54);
  int64x2_t v60 = 0;
  char v62 = 1;
LABEL_61:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v61 + 16))(v61, **(void **)(a1 + 64) + 24, @"VoLTENetworkSeen", kCFBooleanTrue, kPhoneServicesWalletDomain, 0, 1, 0);
  if ((v62 & 1) == 0) {
    sub_10004D2C8(v60);
  }
LABEL_63:
  Registry::createRestModuleOneTimeUseConnection(&v105, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v106) {
    sub_10004D2C8(v106);
  }
  long long v63 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v63 || (uint64_t v64 = *(void *)(a1 + 8), (v65 = std::__shared_weak_count::lock(v63)) == 0)) {
    sub_100088B9C();
  }
  BOOL v66 = v65;
  atomic_fetch_add_explicit(&v65->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v65);
  sub_100058DB0(__p, "/cc/props/ims_voice_support");
  long long v67 = operator new(0x28uLL);
  void *v67 = off_101A1D458;
  v67[1] = a1 + 128;
  v67[2] = a1;
  v67[3] = v64;
  v67[4] = v66;
  uint64_t v115 = v67;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v108 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v68 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v68 || (uint64_t v69 = *(void *)(a1 + 8), (v70 = std::__shared_weak_count::lock(v68)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v71 = v70;
  atomic_fetch_add_explicit(&v70->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v70);
  sub_100058DB0(__p, "/cc/events/cs_voice_support_changed");
  char v72 = operator new(0x20uLL);
  *char v72 = off_101A1D4D8;
  v72[1] = a1;
  v72[2] = v69;
  v72[3] = v71;
  uint64_t v115 = v72;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v108 < 0) {
    operator delete(__p[0]);
  }
  char v73 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v73 || (uint64_t v74 = *(void *)(a1 + 8), (v75 = std::__shared_weak_count::lock(v73)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v76 = v75;
  atomic_fetch_add_explicit(&v75->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v75);
  sub_100058DB0(__p, "/cc/props/reg_serving_network");
  uint64_t v77 = operator new(0x28uLL);
  *uint64_t v77 = off_101A1D558;
  v77[1] = a1 + 256;
  v77[2] = a1;
  v77[3] = v74;
  _DWORD v77[4] = v76;
  uint64_t v115 = v77;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v108 < 0) {
    operator delete(__p[0]);
  }
  long long v78 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v78 || (uint64_t v79 = *(void *)(a1 + 8), (v80 = std::__shared_weak_count::lock(v78)) == 0)) {
    sub_100088B9C();
  }
  char v81 = v80;
  atomic_fetch_add_explicit(&v80->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v80);
  sub_100058DB0(__p, "/cc/props/airplane_mode");
  BOOL v82 = operator new(0x28uLL);
  *BOOL v82 = off_101A1D5D8;
  v82[1] = a1 + 280;
  v82[2] = a1;
  v82[3] = v79;
  _DWORD v82[4] = v81;
  uint64_t v115 = v82;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v108 < 0) {
    operator delete(__p[0]);
  }
  BOOL v83 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v83 || (uint64_t v84 = *(void *)(a1 + 8), (v85 = std::__shared_weak_count::lock(v83)) == 0)) {
    sub_100088B9C();
  }
  xpc_object_t v86 = v85;
  atomic_fetch_add_explicit(&v85->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v85);
  sub_100058DB0(__p, "cc/props/ims_preference_states");
  xpc_object_t v87 = operator new(0x28uLL);
  *xpc_object_t v87 = off_101A1D658;
  v87[1] = a1 + 104;
  v87[2] = a1;
  v87[3] = v84;
  _DWORD v87[4] = v86;
  uint64_t v115 = v87;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v108 < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t v88 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v88 || (v89 = *(void *)(a1 + 8), (xpc_object_t v90 = std::__shared_weak_count::lock(v88)) == 0)) {
    sub_100088B9C();
  }
  CFBooleanRef v91 = v90;
  atomic_fetch_add_explicit(&v90->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v90);
  sub_100058DB0(__p, "/cc/props/current_data_slot");
  int v92 = operator new(0x28uLL);
  void *v92 = off_101A1D6D8;
  v92[1] = a1 + 152;
  v92[2] = a1;
  v92[3] = v89;
  v92[4] = v91;
  uint64_t v115 = v92;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v108 < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t v93 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v93 || (v94 = *(void *)(a1 + 8), (xpc_object_t v95 = std::__shared_weak_count::lock(v93)) == 0)) {
    sub_100088B9C();
  }
  xpc_object_t v96 = v95;
  atomic_fetch_add_explicit(&v95->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v95);
  sub_100058DB0(__p, "/cc/props/operator_bundles");
  xpc_object_t v97 = operator new(0x28uLL);
  *xpc_object_t v97 = off_101A1D758;
  v97[1] = a1 + 160;
  v97[2] = a1;
  v97[3] = v94;
  v97[4] = v96;
  uint64_t v115 = v97;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v108 < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t v98 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v98 || (uint64_t v99 = *(void *)(a1 + 8), (v100 = std::__shared_weak_count::lock(v98)) == 0)) {
    sub_100088B9C();
  }
  xpc_object_t v101 = v100;
  atomic_fetch_add_explicit(&v100->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v100);
  sub_100058DB0(__p, "/cc/props/in_home_countries_definite");
  xpc_object_t v102 = operator new(0x28uLL);
  *xpc_object_t v102 = off_101A1D7D8;
  v102[1] = a1 + 184;
  v102[2] = a1;
  v102[3] = v99;
  _DWORD v102[4] = v101;
  uint64_t v115 = v102;
  ctu::RestModule::observeProperty();
  xpc_object_t v103 = (capabilities::ct *)sub_10003F600(buf);
  if (v108 < 0) {
    operator delete(__p[0]);
  }
  if (capabilities::ct::supportsVoiceCall(v103))
  {
    sub_10093C120(a1 + 208);
    sub_10093C200(a1 + 232);
  }
  sub_10093C2E0(a1);
  sub_10093C5C8(a1);
  BOOL result = sub_10093D1CC(a1);
  *(unsigned char *)(a1 + 292) = result;
  return result;
}

void sub_10093BFF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  _Unwind_Resume(exception_object);
}

void sub_10093C120(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/carrier_blocks_calls_over_cs");
  v4[0] = off_101A1D858;
  v4[1] = a1;
  uint64_t v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10093C1D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10093C200(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/operator_blocks_calls_over_cs");
  v4[0] = off_101A1D8D8;
  v4[1] = a1;
  uint64_t v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10093C2B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

const void **sub_10093C2E0(uint64_t a1)
{
  int v2 = (uint64_t *)__stack_chk_guard;
  *(_DWORD *)(a1 + 296) = 0;
  uint64_t v23 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(a1 + 48));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    char v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unsigned int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unsigned int v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v11 + 64))(&v22, v11, **(void **)(a1 + 64) + 24, @"VoLTEUserPreference", kPhoneServicesWalletDomain, 0, 1);
  sub_1000842D0(&v23, &v22);
  sub_1000577C4(&v22);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (v23) {
    long long v14 = sub_100081E58;
  }
  else {
    long long v14 = 0;
  }
  if (v14)
  {
    *(_DWORD *)std::string buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v23, v13);
    int v15 = *(_DWORD *)buf;
    if (*(int *)buf > 0)
    {
      int v16 = 2;
LABEL_22:
      *(_DWORD *)(a1 + 296) = v16;
      return sub_1000570E8((const void **)&v23);
    }
    int v17 = sub_10093CED4(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 416));
    int v18 = -v15;
    if (v17 <= -v15)
    {
      int v16 = 1;
      goto LABEL_22;
    }
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v20;
      __int16 v25 = 2080;
      uint64_t v26 = " ";
      __int16 v27 = 1024;
      int v28 = v18;
      __int16 v29 = 1024;
      int v30 = v17;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Switch: user preference has ver:%d vs current:%d, force reset to default", buf, 0x22u);
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 96))(a1);
  }
  return sub_1000570E8((const void **)&v23);
}

void sub_10093C574(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_10093C5C8(uint64_t a1)
{
  if (capabilities::ct::supportsVoLTE((capabilities::ct *)a1))
  {
    *(void *)std::string buf = 0;
    (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 416) + 96))(&v13);
    sub_1000057AC(buf, &v13);
    sub_1000577C4(&v13);
    LOBYTE(v13) = 0;
    ctu::cf::assign((ctu::cf *)&v13, *(BOOL **)buf, v2);
    int v3 = (_BYTE)v13 != 0;
    sub_100062778((const void **)buf);
    goto LABEL_7;
  }
  if (*(unsigned char *)(a1 + 281))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    int v3 = 0;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v5;
    __int16 v15 = 2080;
    int v16 = " ";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sDevice does not support VoLTE", buf, 0x16u);
  }
  int v3 = 0;
LABEL_7:
  int v6 = *(unsigned __int8 *)(a1 + 281);
  if (v6 != v3)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      int v9 = *(unsigned __int8 *)(a1 + 281);
      unsigned int v10 = "true";
      *(_DWORD *)std::string buf = 136315906;
      if (v9) {
        uint64_t v11 = "true";
      }
      else {
        uint64_t v11 = "false";
      }
      *(void *)&uint8_t buf[4] = v8;
      int v16 = " ";
      __int16 v15 = 2080;
      if (!v3) {
        unsigned int v10 = "false";
      }
      __int16 v17 = 2080;
      int v18 = v11;
      __int16 v19 = 2080;
      uint64_t v20 = v10;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%sSupports VoLTE capability is changing from %s to %s", buf, 0x2Au);
    }
    *(unsigned char *)(a1 + 281) = v3;
  }
  return v6 != v3;
}

void sub_10093C7EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10093C818(uint64_t a1)
{
  CFBooleanRef v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sstarted", (uint8_t *)&v5, 0x16u);
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, 0, 1);
}

void VoLteControl::sHandleMigrationForAll(Registry **a1, uint64_t a2, int a3)
{
  os_log_t oslog = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, kCtLoggingSystemName, "ps.vol");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, &buf);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  int v5 = oslog;
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Migrator has called to re-evaluate the saved VoLTE Switch state", (uint8_t *)&buf, 2u);
    int v5 = oslog;
  }
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    __int16 v7 = "false";
    if (a3) {
      __int16 v7 = "true";
    }
    LODWORD(buf.var0) = 136315138;
    *(char **)((char *)&buf.var0 + 4) = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Is from a different device: %s", (uint8_t *)&buf, 0xCu);
  }
  if (a3)
  {
    int v8 = capabilities::ct::latestAndGreatestDevice((capabilities::ct *)v6);
    int v9 = oslog;
    if (v8)
    {
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I VoLTE Switch: Restoring on latest and greatest from other device, force reset to default if OFF", (uint8_t *)&buf, 2u);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *a1);
      char v12 = ServiceMap;
      if (v13 < 0)
      {
        long long v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v15 = 5381;
        do
        {
          uint64_t v13 = v15;
          unsigned int v16 = *v14++;
          uint64_t v15 = (33 * v15) ^ v16;
        }
        while (v16);
      }
      std::mutex::lock(ServiceMap);
      buf.var0 = (char *)v13;
      __int16 v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&buf);
      if (v17)
      {
        uint64_t v19 = v17[3];
        int v18 = (std::__shared_weak_count *)v17[4];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v12);
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v18);
          char v30 = 0;
LABEL_22:
          buf.var0 = 0;
          buf.var1.fRef = 0;
          uint64_t v36 = 0;
          (*(void (**)(OsLogContext *__return_ptr, uint64_t, void))(*(void *)v19 + 80))(&buf, v19, 0);
          var0 = buf.var0;
          fRef = buf.var1.fRef;
          if (buf.var0 != (char *)buf.var1.fRef)
          {
            uint64_t v22 = kPhoneServicesWalletDomain;
            do
            {
              CFNumberRef v31 = 0;
              (*(void (**)(unsigned char *__return_ptr, uint64_t, char *, const __CFString *, uint64_t, void, uint64_t))(*(void *)v19 + 64))(v34, v19, var0, @"VoLTEUserPreference", v22, 0, 1);
              sub_1000842D0(&v31, (CFTypeRef *)v34);
              sub_1000577C4((const void **)v34);
              if (v31) {
                uint64_t v24 = sub_100081E58;
              }
              else {
                uint64_t v24 = 0;
              }
              if (v24)
              {
                int v33 = 0;
                ctu::cf::assign((ctu::cf *)&v33, v31, v23);
                if (v33 <= 0)
                {
                  __int16 v25 = oslog;
                  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v26 = var0[23];
                    BOOL v27 = (v26 & 0x80u) != 0;
                    if ((v26 & 0x80u) != 0) {
                      uint64_t v26 = *((void *)var0 + 1);
                    }
                    if (v27) {
                      int v28 = *(char **)var0;
                    }
                    else {
                      int v28 = var0;
                    }
                    if (v26) {
                      __int16 v29 = v28;
                    }
                    else {
                      __int16 v29 = "<invalid>";
                    }
                    *(_DWORD *)BOOL v34 = 136315138;
                    *(void *)&void v34[4] = v29;
                    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I VoLTE Switch: reset %s VoLTE state to default", v34, 0xCu);
                  }
                  (*(void (**)(uint64_t, char *, const __CFString *, uint64_t, void, uint64_t))(*(void *)v19 + 72))(v19, var0, @"VoLTEUserPreference", v22, 0, 1);
                }
              }
              sub_1000570E8((const void **)&v31);
              var0 += 24;
            }
            while (var0 != (char *)fRef);
          }
          *(void *)BOOL v34 = &buf;
          sub_100047F64((void ***)v34);
          if ((v30 & 1) == 0) {
            sub_10004D2C8(v18);
          }
          goto LABEL_43;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v12);
      int v18 = 0;
      char v30 = 1;
      goto LABEL_22;
    }
  }
  else
  {
    int v9 = oslog;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I VoLTE Switch: migration don't cause VoLTE switch update", (uint8_t *)&buf, 2u);
  }
LABEL_43:
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
}

void sub_10093CD50(_Unwind_Exception *a1, uint64_t a2, int a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  if ((a4 & 1) == 0) {
    sub_10004D2C8(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10093CDE0(uint64_t a1)
{
  CFBooleanRef v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    int v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Switch: review provisioning on migration", (uint8_t *)&v5, 0x16u);
  }
  sub_10093C2E0(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

unint64_t sub_10093CED4(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, void, void, void))(*(void *)a2 + 96))(&cf, a2, a1, 1, kCFEnableLTEAfterUpgrade, 0, 0);
  if (cf) {
    CFBooleanRef v2 = sub_100080934;
  }
  else {
    CFBooleanRef v2 = 0;
  }
  if (!v2) {
    goto LABEL_12;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  CFTypeID TypeID = CFNumberGetTypeID();
  unint64_t v5 = (unint64_t)cf;
  if (v3 != TypeID)
  {
    unsigned __int8 v12 = 0;
    if (!cf) {
      goto LABEL_13;
    }
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v12, (BOOL *)v5, v9);
      unint64_t v5 = v12;
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  unsigned int v13 = 0;
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v13, (int *)v5, v7);
      unint64_t v5 = v13;
      goto LABEL_13;
    }
LABEL_12:
    unint64_t v5 = 0;
  }
LABEL_13:
  sub_1000577C4(&cf);
  return v5;
}

void sub_10093CFF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_10093D00C(uint64_t a1)
{
  CFBooleanRef BOOLean = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 416) + 96))(&v13);
  sub_1000057AC(&BOOLean, &v13);
  sub_1000577C4(&v13);
  if (BOOLean) {
    CFBooleanRef v2 = sub_100084B4C;
  }
  else {
    CFBooleanRef v2 = 0;
  }
  if (v2) {
    LODWORD(v2) = CFBooleanGetValue(BOOLean) == 1 && *(unsigned char *)(a1 + 412) == 0;
  }
  uint64_t v3 = *(void *)(a1 + 192);
  if (!v3) {
    goto LABEL_21;
  }
  int v4 = *(_DWORD *)(**(void **)(a1 + 64) + 52);
  uint64_t v5 = a1 + 192;
  do
  {
    int v6 = *(_DWORD *)(v3 + 28);
    BOOL v7 = v6 < v4;
    if (v6 >= v4) {
      CFTypeID v8 = (uint64_t *)v3;
    }
    else {
      CFTypeID v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == a1 + 192)
  {
LABEL_21:
    int v9 = (int)v2;
  }
  else
  {
    int v9 = (int)v2;
    if (v4 >= *(_DWORD *)(v5 + 28))
    {
      if (*(unsigned char *)(v5 + 32)) {
        int v9 = (int)v2;
      }
      else {
        int v9 = 1;
      }
    }
  }
  if (v2) {
    int v10 = 256;
  }
  else {
    int v10 = 0;
  }
  uint64_t v11 = v10 | v9;
  sub_100062778((const void **)&BOOLean);
  return v11;
}

void sub_10093D158(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_10093D17C(uint64_t a1)
{
  BOOL result = sub_10004D710();
  if (result)
  {
    int v3 = *(_DWORD *)(**(void **)(a1 + 64) + 52);
    return isMandatoryDisabledVoLTE(v3);
  }
  return result;
}

BOOL sub_10093D1CC(uint64_t a1)
{
  unsigned __int16 v2 = sub_10093D00C(a1);
  char v3 = v2;
  BOOL v4 = sub_10093D644(a1, v2 > 0xFFu);
  if (sub_10093D17C(a1))
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    BOOL v4 = 0;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = v6;
      __int16 v30 = 2080;
      CFNumberRef v31 = " ";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Switch: mandatory disabled", buf, 0x16u);
      return 0;
    }
  }
  else if (*(unsigned char *)(a1 + 284) || VoLteControl::operatorBlocksCallsOverCS((VoLteControl *)a1))
  {
    BOOL v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = v8;
      __int16 v30 = 2080;
      CFNumberRef v31 = " ";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Switch: Non-CS operator observed, value defaults to ON", buf, 0x16u);
    }
    return 1;
  }
  else if (v3 && (int v10 = *(_DWORD *)(a1 + 296)) != 0)
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v13 = *(int *)(a1 + 296);
      if (v13 > 2) {
        long long v14 = (char *)&unk_10161656E;
      }
      else {
        long long v14 = off_101A1D9B8[v13];
      }
      *(_DWORD *)OsLogContext buf = 136315650;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v30 = 2080;
      CFNumberRef v31 = " ";
      __int16 v32 = 2080;
      int v33 = v14;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Switch: Using manual preference %s", buf, 0x20u);
      int v10 = *(_DWORD *)(a1 + 296);
    }
    return v10 == 2;
  }
  else
  {
    __int16 v15 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 80) + 400))(*(void *)(a1 + 80), 0);
    unsigned int v16 = operator new(0x18uLL);
    *(_OWORD *)unsigned int v16 = *(_OWORD *)off_101A1D2F8;
    void v16[2] = @"EnableVoLTEWithVoWiFi";
    std::string __p = v16;
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 416) + 104))(buf);
    __int16 v17 = *(BOOL **)buf;
    unsigned __int8 v28 = 0;
    if (*(void *)buf)
    {
      CFTypeID v18 = CFGetTypeID(*(CFTypeRef *)buf);
      if (v18 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)&v28, v17, v19);
        LODWORD(v17) = v28;
      }
      else
      {
        LODWORD(v17) = 0;
      }
    }
    sub_1000577C4((const void **)buf);
    if ((_BYTE)v15) {
      BOOL v20 = (v15 & 0xFF00) == 0;
    }
    else {
      BOOL v20 = 1;
    }
    if (v20 || v17 == 0)
    {
      uint64_t v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
        *(_DWORD *)OsLogContext buf = 136315650;
        *(void *)&uint8_t buf[4] = v23;
        __int16 v30 = 2080;
        CFNumberRef v31 = " ";
        __int16 v32 = 1024;
        LODWORD(v33) = v4;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Switch: Using carrier default %d", buf, 0x1Cu);
      }
    }
    else
    {
      uint64_t v24 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
        *(_DWORD *)OsLogContext buf = 136315394;
        *(void *)&uint8_t buf[4] = v26;
        __int16 v30 = 2080;
        CFNumberRef v31 = " ";
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Switch: Enable VoLTE along with VoWiFi", buf, 0x16u);
      }
      BOOL v4 = 1;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  return v4;
}

void sub_10093D610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10093D644(uint64_t a1, int a2)
{
  BOOL v4 = operator new(0x18uLL);
  uint64_t v13 = v4 + 3;
  long long v14 = (char *)(v4 + 3);
  *(_OWORD *)BOOL v4 = *(_OWORD *)off_101A1D310;
  void v4[2] = @"EnableVolteByDefault";
  std::string __p = v4;
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 416) + 104))(&cf);
  uint64_t v5 = (BOOL *)cf;
  unsigned __int8 v15 = a2 ^ 1;
  if (cf && (CFTypeID v6 = CFGetTypeID(cf), v6 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v15, v5, v7);
    int v8 = v15;
    sub_1000577C4(&cf);
    if (v8)
    {
LABEL_4:
      BOOL v9 = 1;
      goto LABEL_7;
    }
  }
  else
  {
    sub_1000577C4(&cf);
    if (!a2) {
      goto LABEL_4;
    }
  }
  BOOL v9 = *(unsigned char *)(a1 + 412) != 0;
LABEL_7:
  if (__p)
  {
    uint64_t v13 = __p;
    operator delete(__p);
  }
  return v9;
}

void sub_10093D764(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL VoLteControl::operatorBlocksCallsOverCS(VoLteControl *this)
{
  uint64_t v1 = (char *)*((void *)this + 30);
  if (!v1) {
    return 0;
  }
  int v2 = *(_DWORD *)(**((void **)this + 8) + 52);
  char v3 = (char *)this + 240;
  do
  {
    int v4 = *((_DWORD *)v1 + 7);
    BOOL v5 = v4 < v2;
    if (v4 >= v2) {
      CFTypeID v6 = (char **)v1;
    }
    else {
      CFTypeID v6 = (char **)(v1 + 8);
    }
    if (!v5) {
      char v3 = v1;
    }
    uint64_t v1 = *v6;
  }
  while (*v6);
  return v3 != (char *)this + 240 && v2 >= *((_DWORD *)v3 + 7) && v3[32] != 0;
}

uint64_t sub_10093D7F4(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)unsigned int v16 = 136315394;
    *(void *)&uint8_t v16[4] = v4;
    __int16 v17 = 2080;
    CFTypeID v18 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Switch: Reset", v16, 0x16u);
  }
  *(_DWORD *)(a1 + 296) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 48));
  CFTypeID v6 = ServiceMap;
  if (v7 < 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)unsigned int v16 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)v16);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_11:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v13 + 72))(v13, **(void **)(a1 + 64) + 24, @"VoLTEUserPreference", kPhoneServicesWalletDomain, 0, 1);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

void sub_10093D9E8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10093DA18(VoLteControl *this, int a2)
{
  if (a2) {
    int v2 = 2;
  }
  else {
    int v2 = 1;
  }
  if (*((_DWORD *)this + 74) == v2) {
    return;
  }
  if ((a2 & 1) == 0 && (*((unsigned char *)this + 284) || VoLteControl::operatorBlocksCallsOverCS(this)))
  {
    uint64_t v9 = *((void *)this + 5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = PersonalityInfo::logPrefix(**((PersonalityInfo ***)this + 8));
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = v10;
      __int16 v31 = 2080;
      __int16 v32 = " ";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Switch: CS calls are blocked for the current or recent operator, prevent VoLTE preference set", buf, 0x16u);
    }
    return;
  }
  BOOL v5 = *((void *)this + 5);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = PersonalityInfo::logPrefix(**((PersonalityInfo ***)this + 8));
    uint64_t v7 = *((int *)this + 74);
    if (v7 > 2) {
      int v8 = (char *)&unk_10161656E;
    }
    else {
      int v8 = off_101A1D9B8[v7];
    }
    uint64_t v11 = "Disabled";
    *(_DWORD *)OsLogContext buf = 136315906;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v32 = " ";
    __int16 v31 = 2080;
    if (a2) {
      uint64_t v11 = "Enabled";
    }
    __int16 v33 = 2080;
    BOOL v34 = v8;
    __int16 v35 = 2080;
    uint64_t v36 = v11;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Switch: changed user preference from %s to %s", buf, 0x2Au);
  }
  int v12 = sub_10093CED4(*(unsigned int *)(**((void **)this + 8) + 52), *((void *)this + 52));
  if (a2) {
    int v13 = v12 + 1;
  }
  else {
    int v13 = -v12;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)-v12, *((Registry **)this + 6));
  unsigned __int8 v15 = ServiceMap;
  if (v16 < 0)
  {
    __int16 v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  *(void *)OsLogContext buf = v16;
  BOOL v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
  if (!v20)
  {
    uint64_t v22 = 0;
    goto LABEL_27;
  }
  uint64_t v22 = v20[3];
  int v21 = (std::__shared_weak_count *)v20[4];
  if (!v21)
  {
LABEL_27:
    std::mutex::unlock(v15);
    int v21 = 0;
    char v23 = 1;
    goto LABEL_28;
  }
  atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v15);
  atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v21);
  char v23 = 0;
LABEL_28:
  uint64_t v24 = **((void **)this + 8);
  CFNumberRef v29 = 0;
  *(_DWORD *)OsLogContext buf = v13;
  CFNumberRef v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
  if (v25)
  {
    CFNumberRef v26 = v29;
    CFNumberRef v29 = v25;
    *(void *)OsLogContext buf = v26;
    sub_1000570E8((const void **)buf);
  }
  CFNumberRef v27 = v29;
  CFNumberRef v28 = v29;
  CFNumberRef v29 = 0;
  sub_1000570E8((const void **)&v29);
  (*(void (**)(uint64_t, uint64_t, const __CFString *, CFNumberRef, void, void, uint64_t, void, CFNumberRef))(*(void *)v22 + 48))(v22, v24 + 24, @"VoLTEUserPreference", v27, kPhoneServicesWalletDomain, 0, 1, 0, v28);
  sub_1000570E8((const void **)&v28);
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  *((_DWORD *)this + 74) = v2;
  (*(void (**)(VoLteControl *, uint64_t, void))(*(void *)this + 104))(this, 1, 0);
  sub_10093DDC0((uint64_t)this);
}

void sub_10093DD7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000570E8(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_10093DDC0(uint64_t a1)
{
  if (*(unsigned char *)(**(void **)(a1 + 64) + 48))
  {
    (*(void (**)(unsigned char *__return_ptr))(*(void *)a1 + 56))(buf);
    int v2 = buf[2];
    char v3 = sub_100057D78((const void **)&buf[8]);
    if (v2)
    {
      BOOL v4 = *(_DWORD *)(a1 + 300) == 2;
      BOOL v5 = *(PersonalityInfo ***)(a1 + 64);
      uint64_t v6 = *v5;
      switch(*((_DWORD *)*v5 + 13))
      {
        case 0:
        case 3:
          uint64_t v7 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            uint64_t v8 = PersonalityInfo::logPrefix(v6);
            *(_DWORD *)OsLogContext buf = 136315394;
            *(void *)&uint8_t buf[4] = v8;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "#E %s%sPhoneServices is broken!", buf, 0x16u);
          }
          break;
        case 1:
          *(void *)OsLogContext buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 0x40000000;
          *(void *)&uint8_t buf[16] = sub_1009446D4;
          uint64_t v18 = &unk_101A1D948;
          BOOL v19 = v4;
          int v20 = 1;
          SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
          char v10 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x800EDu);
          if (v10)
          {
            uint64_t v11 = sub_10001C8F4(8);
            uint64_t v13 = *v11;
            int v12 = (std::__shared_weak_count *)v11[1];
            if (v12) {
              atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v13) {
              operator new();
            }
            goto LABEL_16;
          }
          return;
        case 2:
          *(void *)OsLogContext buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 0x40000000;
          *(void *)&uint8_t buf[16] = sub_10094471C;
          uint64_t v18 = &unk_101A1D968;
          BOOL v19 = v4;
          int v20 = 2;
          char v14 = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
          char v10 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(v14, 0x80118u);
          if (v10)
          {
            unsigned __int8 v15 = sub_10001C8F4(8);
            uint64_t v16 = *v15;
            int v12 = (std::__shared_weak_count *)v15[1];
            if (v12) {
              atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v16) {
              operator new();
            }
LABEL_16:
            if (v12) {
              sub_10004D2C8(v12);
            }
            if (v10)
            {
              wis::MetricContainer::~MetricContainer(v10);
              operator delete();
            }
          }
          return;
        default:
          return;
      }
    }
  }
}

void sub_10093E1A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

BOOL sub_10093E25C(uint64_t a1)
{
  return *(_DWORD *)(a1 + 300) == 2;
}

unint64_t sub_10093E26C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 296) | ((unint64_t)*(unsigned __int8 *)(a1 + 292) << 32);
}

uint64_t sub_10093E27C(uint64_t result)
{
  if (*(unsigned char *)(**(void **)(result + 64) + 48)) {
    phoneservices::submitSwitchAnalytics();
  }
  return result;
}

unsigned char *sub_10093E2AC(unsigned char *result, char a2)
{
  if ((a2 & 1) == 0)
  {
    result[377] = 0;
    result[284] = 0;
    if (result[283]) {
      result[283] = 0;
    }
  }
  return result;
}

uint64_t sub_10093E2D0(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%spersonality config changed", (uint8_t *)&v5, 0x16u);
  }
  sub_10093C2E0(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

uint64_t sub_10093E3C4(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%spersonal wallet changed", (uint8_t *)&v5, 0x16u);
  }
  sub_10093C2E0(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

void sub_10093E4B8(uint64_t a1, int a2)
{
  if (!a2 || sub_100940280(a1, __stack_chk_guard)) {
    return;
  }
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)uint64_t v18 = 136315394;
    *(void *)&void v18[4] = v5;
    __int16 v19 = 2080;
    int v20 = " ";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%sCurrent network supports IMS, from now on VoLTE provisioning/switch allowed", v18, 0x16u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 48));
  __int16 v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v18 = v8;
  int v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v18);
  if (!v12)
  {
    uint64_t v14 = 0;
    goto LABEL_12;
  }
  uint64_t v14 = v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13)
  {
LABEL_12:
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
LABEL_13:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v14 + 16))(v14, **(void **)(a1 + 64) + 24, @"VoLTENetworkSeen", kCFBooleanTrue, kPhoneServicesWalletDomain, 0, 1, 0);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)uint64_t v18 = 136315394;
    *(void *)&void v18[4] = v17;
    __int16 v19 = 2080;
    int v20 = " ";
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE network seen", v18, 0x16u);
  }
}

void sub_10093E6FC(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10093E72C@<W0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  void (***v11)(uint64_t *__return_ptr, void, uint64_t);
  char v12;
  const void *Value;
  CFTypeID v14;
  CFBooleanRef v15;
  BOOL v16;
  CFTypeRef cf;
  unint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  char v23;

  int v21 = 0;
  uint64_t v22 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 48));
  BOOL v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __int16 v19 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v19);
  if (v9)
  {
    unsigned int v11 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      int v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    unsigned int v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  int v12 = 1;
LABEL_9:
  (**v11)(&v21, v11, **(void **)(a1 + 64) + 24);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (v21)
  {
    __int16 v19 = 0;
    int v20 = 0;
    (*(void (**)(unint64_t *__return_ptr))(*(void *)v21 + 64))(&v19);
    if (v19)
    {
      CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v19 + 64), @"EnableVolteWhileEntitlementStatusIsUnknown");
      CFTypeRef cf = Value;
      if (Value && (CFRetain(Value), v23 = 0, uint64_t v14 = CFGetTypeID(cf), v14 == CFBooleanGetTypeID()))
      {
        ctu::cf::assign((ctu::cf *)&v23, (BOOL *)cf, v15);
        uint64_t v16 = v23 != 0;
      }
      else
      {
        uint64_t v16 = 0;
      }
      sub_1000577C4(&cf);
    }
    else
    {
      uint64_t v16 = 0;
    }
    if (v20) {
      sub_10004D2C8(v20);
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
  return v16;
}

void sub_10093E91C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(a1);
}

void sub_10093E95C()
{
  if (v0) {
    JUMPOUT(0x10093E954);
  }
  JUMPOUT(0x10093E94CLL);
}

BOOL sub_10093E96C(uint64_t a1)
{
  return !*(unsigned char *)(a1 + 377)
      && !sub_10093E9B8(a1)
      && *(unsigned char *)(a1 + 292)
      && !sub_10093EB7C(a1, (uint64_t *)*(unsigned __int8 *)(a1 + 292));
}

BOOL sub_10093E9B8(uint64_t a1)
{
  CFBooleanRef BOOLean = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    unint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v4;
  unsigned int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v17);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v10 + 24))(&v15, v10, **(void **)(a1 + 64) + 24, @"VoLTEBlockedByNetwork", kPhoneServicesWalletDomain, 0, 1);
  sub_1000057AC(&BOOLean, &v15);
  sub_1000577C4(&v15);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (BOOLean) {
    int v12 = sub_100084B4C;
  }
  else {
    int v12 = 0;
  }
  if (v12) {
    BOOL v13 = CFBooleanGetValue(BOOLean) != 0;
  }
  else {
    BOOL v13 = 0;
  }
  sub_100062778((const void **)&BOOLean);
  return v13;
}

void sub_10093EB40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_10093EB7C@<W0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  void (***v11)(unint64_t *__return_ptr, void, uint64_t);
  char v12;
  uint64_t *v13;
  const void *Value;
  BOOL *v15;
  CFTypeID v16;
  CFBooleanRef v17;
  uint64_t *v18;
  BOOL v19;
  std::mutex *v20;
  std::mutex *v21;
  unint64_t v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unsigned int v25;
  void *v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  char v29;
  uint64_t (*v30)(uint64_t);
  CFDictionaryRef *v32;
  std::__shared_weak_count *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  char v36;
  CFTypeRef cf;

  BOOL v34 = 0;
  __int16 v35 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 48));
  unint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __int16 v32 = (CFDictionaryRef *)v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v32);
  if (v9)
  {
    char v11 = (void (***)(unint64_t *__return_ptr, void, uint64_t))v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      int v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    char v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  int v12 = 1;
LABEL_9:
  (**v11)(&v34, v11, **(void **)(a1 + 64) + 24);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (!v34)
  {
    LOBYTE(v15) = 0;
    goto LABEL_23;
  }
  __int16 v32 = 0;
  __int16 v33 = 0;
  (*(void (**)(CFDictionaryRef **__return_ptr))(*(void *)v34 + 64))(&v32);
  BOOL v13 = (uint64_t *)v32;
  if (!v32)
  {
    LOBYTE(v15) = 0;
    goto LABEL_21;
  }
  CFArrayRef Value = CFDictionaryGetValue(v32[8], @"DoNotLinkVoLteSwitchVisibilityToVoPS");
  CFTypeRef cf = Value;
  if (!Value) {
    goto LABEL_19;
  }
  CFRetain(Value);
  char v15 = (BOOL *)cf;
  uint64_t v36 = 0;
  if (cf)
  {
    uint64_t v16 = CFGetTypeID(cf);
    if (v16 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v36, v15, v17);
      LOBYTE(v15) = v36 != 0;
      goto LABEL_20;
    }
LABEL_19:
    LOBYTE(v15) = 0;
  }
LABEL_20:
  sub_1000577C4(&cf);
LABEL_21:
  if (v33) {
    sub_10004D2C8(v33);
  }
LABEL_23:
  if (v35) {
    sub_10004D2C8(v35);
  }
  if ((v15 & 1) != 0 || sub_100940280(a1, v13)) {
    return 0;
  }
  __int16 v32 = 0;
  int v20 = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)(a1 + 48));
  int v21 = v20;
  if ((v22 & 0x8000000000000000) != 0)
  {
    char v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v24 = 5381;
    do
    {
      uint64_t v22 = v24;
      CFNumberRef v25 = *v23++;
      uint64_t v24 = (33 * v24) ^ v25;
    }
    while (v25);
  }
  std::mutex::lock(v20);
  BOOL v34 = v22;
  CFNumberRef v26 = sub_10004D37C(&v21[1].__m_.__sig, &v34);
  if (!v26)
  {
    CFNumberRef v28 = 0;
    goto LABEL_35;
  }
  CFNumberRef v28 = v26[3];
  CFNumberRef v27 = (std::__shared_weak_count *)v26[4];
  if (!v27)
  {
LABEL_35:
    std::mutex::unlock(v21);
    CFNumberRef v27 = 0;
    CFNumberRef v29 = 1;
    goto LABEL_36;
  }
  atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v21);
  atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v27);
  CFNumberRef v29 = 0;
LABEL_36:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v28 + 64))(&cf, v28, **(void **)(a1 + 64) + 24, @"VoLTEUserPreference", kPhoneServicesWalletDomain, 0, 1);
  sub_1000842D0(&v32, &cf);
  sub_1000577C4(&cf);
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  if (v32) {
    __int16 v30 = sub_100081E58;
  }
  else {
    __int16 v30 = 0;
  }
  __int16 v19 = v30 == 0;
  sub_1000570E8((const void **)&v32);
  return v19;
}

void sub_10093EEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1000577C4((const void **)va);
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v6);
  }
  _Unwind_Resume(a1);
}

void sub_10093EF28(uint64_t a1)
{
  void (***v12)(unsigned char *__return_ptr, void, uint64_t);
  char v13;
  uint64_t v14;
  unint64_t v15;
  unsigned char buf[22];

  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)OsLogContext buf = 136315394;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sAttempt VoLTE provisioning >>>", buf, 0x16u);
  }
  *(unsigned char *)(a1 + 376) = 1;
  uint64_t v14 = 64;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)0x40, *(Registry **)(a1 + 48));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    char v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  char v15 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
  if (v10)
  {
    int v12 = (void (***)(unsigned char *__return_ptr, void, uint64_t))v10[3];
    char v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      BOOL v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    int v12 = 0;
  }
  std::mutex::unlock(v5);
  char v11 = 0;
  BOOL v13 = 1;
LABEL_11:
  (**v12)(buf, v12, **(void **)(a1 + 64) + 24);
  (*(void (**)(void, void, uint64_t *))(**(void **)buf + 280))(*(void *)buf, 0, &v14);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  *(unsigned char *)(a1 + 377) = 1;
}

void sub_10093F12C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10093F170(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sRefresh entitlement cache", (uint8_t *)&v5, 0x16u);
  }
  *(unsigned char *)(a1 + 377) = 0;
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

uint64_t VoLteControl::handleEntitlementUpdate(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)OsLogContext buf = 136315394;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v85 = 2080;
    xpc_object_t v86 = " ";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sEvaluating Entitlements Change Update", buf, 0x16u);
    uint64_t v6 = *(NSObject **)(a1 + 40);
  }
  unsigned int v8 = *(_DWORD *)(a1 + 308);
  BOOL v9 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v9)
    {
      uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      if ((a3 - 1) > 5) {
        char v11 = "???";
      }
      else {
        char v11 = off_101A1D988[a3 - 1];
      }
      *(_DWORD *)OsLogContext buf = 136315650;
      *(void *)&uint8_t buf[4] = v10;
      __int16 v85 = 2080;
      xpc_object_t v86 = " ";
      __int16 v87 = 2080;
      xpc_object_t v88 = v11;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE entitlement supported and is %s", buf, 0x20u);
    }
    switch(a3)
    {
      case 1:
        unsigned int v8 = 4;
        break;
      case 2:
        sub_10093FD8C(a1);
        unsigned int v8 = 3;
        break;
      case 3:
      case 4:
        unsigned int v8 = 2;
        break;
      case 5:
        unsigned int v8 = 5;
        break;
      case 6:
        sub_10093FF88(a1);
        unsigned int v8 = 6;
        break;
      default:
        break;
    }
  }
  else
  {
    if (v9)
    {
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v85 = 2080;
      xpc_object_t v86 = " ";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE entitlement is not supported", buf, 0x16u);
    }
    unsigned int v8 = 1;
  }
  int v13 = *(_DWORD *)(a1 + 308);
  if (v13 != v8)
  {
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v16 = *(int *)(a1 + 308);
      if (v16 > 6) {
        unint64_t v17 = "???";
      }
      else {
        unint64_t v17 = off_101A1D9D0[v16];
      }
      if (v8 > 6) {
        uint64_t v18 = "???";
      }
      else {
        uint64_t v18 = off_101A1D9D0[v8];
      }
      *(_DWORD *)OsLogContext buf = 136315906;
      *(void *)&uint8_t buf[4] = v15;
      __int16 v85 = 2080;
      xpc_object_t v86 = " ";
      __int16 v87 = 2080;
      xpc_object_t v88 = v17;
      __int16 v89 = 2080;
      xpc_object_t v90 = v18;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE entitlement support has changed from %s to %s", buf, 0x2Au);
      int v13 = *(_DWORD *)(a1 + 308);
    }
    if (v8 - 4 > 2) {
      goto LABEL_88;
    }
    if (v13 != 3) {
      goto LABEL_88;
    }
    sub_10093FF88(a1);
    if (!*(unsigned char *)(a1 + 292)) {
      goto LABEL_88;
    }
    CFStringRef v82 = 0;
    CFStringRef format = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    int v20 = ServiceMap;
    uint64_t v22 = v21;
    if (v21 < 0)
    {
      char v23 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v24 = 5381;
      do
      {
        uint64_t v22 = v24;
        unsigned int v25 = *v23++;
        uint64_t v24 = (33 * v24) ^ v25;
      }
      while (v25);
    }
    std::mutex::lock(ServiceMap);
    *(void *)OsLogContext buf = v22;
    CFNumberRef v26 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
    if (v26)
    {
      uint64_t v28 = v26[3];
      CFNumberRef v27 = (std::__shared_weak_count *)v26[4];
      if (v27)
      {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v27);
        char v29 = 0;
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v28 = 0;
    }
    std::mutex::unlock(v20);
    CFNumberRef v27 = 0;
    char v29 = 1;
LABEL_38:
    uint64_t v30 = kAlertDialogLocalizationTable;
    (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v28 + 16))(&v81, v28, kAlertDialogLocalizationTable, @"CALLS_TURNED_OFF", 1);
    CFStringRef v31 = format;
    CFStringRef format = v81;
    *(void *)OsLogContext buf = v31;
    CFStringRef v81 = 0;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&v81);
    if ((v29 & 1) == 0) {
      sub_10004D2C8(v27);
    }
    __int16 v32 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    __int16 v33 = v32;
    uint64_t v34 = v21;
    if (v21 < 0)
    {
      __int16 v35 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v36 = 5381;
      do
      {
        uint64_t v34 = v36;
        unsigned int v37 = *v35++;
        uint64_t v36 = (33 * v36) ^ v37;
      }
      while (v37);
    }
    std::mutex::lock(v32);
    *(void *)OsLogContext buf = v34;
    long long v38 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)buf);
    if (v38)
    {
      uint64_t v40 = v38[3];
      long long v39 = (std::__shared_weak_count *)v38[4];
      if (v39)
      {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v33);
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v39);
        char v41 = 0;
        goto LABEL_48;
      }
    }
    else
    {
      uint64_t v40 = 0;
    }
    std::mutex::unlock(v33);
    long long v39 = 0;
    char v41 = 1;
LABEL_48:
    (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v40 + 16))(&v81, v40, v30, @"TO_ENABLE_CALLS_CONTACT_CARRIER", 1);
    *(void *)OsLogContext buf = v82;
    CFStringRef v42 = v81;
    CFStringRef v81 = 0;
    CFStringRef v82 = v42;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&v81);
    if ((v41 & 1) == 0) {
      sub_10004D2C8(v39);
    }
    CFStringRef v81 = 0;
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 416) + 80))(buf);
    sub_100056248(&v81, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (v81) {
      unsigned int v43 = sub_1000810B8;
    }
    else {
      unsigned int v43 = 0;
    }
    if (!v43)
    {
      long long v54 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v55 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
        *(_DWORD *)OsLogContext buf = 136315394;
        *(void *)&uint8_t buf[4] = v55;
        __int16 v85 = 2080;
        xpc_object_t v86 = " ";
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#W %s%sNo carrier name in the carrier bundle", buf, 0x16u);
      }
      goto LABEL_87;
    }
    long long v44 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    long long v45 = v44;
    uint64_t v46 = v21;
    if (v21 < 0)
    {
      char v47 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v48 = 5381;
      do
      {
        uint64_t v46 = v48;
        unsigned int v49 = *v47++;
        uint64_t v48 = (33 * v48) ^ v49;
      }
      while (v49);
    }
    std::mutex::lock(v44);
    *(void *)OsLogContext buf = v46;
    BOOL v50 = sub_10004D37C(&v45[1].__m_.__sig, (unint64_t *)buf);
    if (v50)
    {
      uint64_t v52 = v50[3];
      long long v51 = (std::__shared_weak_count *)v50[4];
      if (v51)
      {
        atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v45);
        atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v51);
        char v53 = 0;
        goto LABEL_64;
      }
    }
    else
    {
      uint64_t v52 = 0;
    }
    std::mutex::unlock(v45);
    long long v51 = 0;
    char v53 = 1;
LABEL_64:
    (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v52 + 16))(&v80, v52, kCarriersLocalizationTable, v81, 1);
    *(void *)OsLogContext buf = v81;
    CFStringRef v56 = v80;
    CFStringRef v80 = 0;
    CFStringRef v81 = v56;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&v80);
    if ((v53 & 1) == 0) {
      sub_10004D2C8(v51);
    }
    CFStringRef v80 = 0;
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 416) + 96))(buf);
    sub_100056248(&v80, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    CFStringRef v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, v82, v81, v80);
    uint64_t v77 = 0;
    CFStringRef v78 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, format, v80);
    uint64_t v57 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    unsigned int v58 = v57;
    if (v21 < 0)
    {
      uint64_t v59 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v60 = 5381;
      do
      {
        uint64_t v21 = v60;
        unsigned int v61 = *v59++;
        uint64_t v60 = (33 * v60) ^ v61;
      }
      while (v61);
    }
    std::mutex::lock(v57);
    *(void *)OsLogContext buf = v21;
    char v62 = sub_10004D37C(&v58[1].__m_.__sig, (unint64_t *)buf);
    if (v62)
    {
      uint64_t v64 = v62[3];
      long long v63 = (std::__shared_weak_count *)v62[4];
      if (v63)
      {
        atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v58);
        atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v63);
        char v65 = 0;
        goto LABEL_74;
      }
    }
    else
    {
      uint64_t v64 = 0;
    }
    std::mutex::unlock(v58);
    long long v63 = 0;
    char v65 = 1;
LABEL_74:
    (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v64 + 16))(&v77, v64, kDataUsageLocalizationTable, @"OK", 1);
    if ((v65 & 1) == 0) {
      sub_10004D2C8(v63);
    }
    BOOL v66 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    long long v67 = v66;
    if (v68 < 0)
    {
      uint64_t v69 = (unsigned __int8 *)(v68 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v70 = 5381;
      do
      {
        uint64_t v68 = v70;
        unsigned int v71 = *v69++;
        uint64_t v70 = (33 * v70) ^ v71;
      }
      while (v71);
    }
    std::mutex::lock(v66);
    *(void *)OsLogContext buf = v68;
    char v72 = sub_10004D37C(&v67[1].__m_.__sig, (unint64_t *)buf);
    if (v72)
    {
      uint64_t v74 = v72[3];
      char v73 = (std::__shared_weak_count *)v72[4];
      if (v73)
      {
        atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v67);
        atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v73);
        char v75 = 0;
LABEL_84:
        (*(void (**)(uint64_t, CFStringRef, CFStringRef, const void *))(*(void *)v74 + 32))(v74, v78, v79, v77);
        if ((v75 & 1) == 0) {
          sub_10004D2C8(v73);
        }
        sub_1000558F4(&v77);
        sub_1000558F4((const void **)&v78);
        sub_1000558F4((const void **)&v79);
        sub_1000558F4((const void **)&v80);
LABEL_87:
        sub_1000558F4((const void **)&v81);
        sub_1000558F4((const void **)&v82);
        sub_1000558F4((const void **)&format);
LABEL_88:
        *(_DWORD *)(a1 + 308) = v8;
        return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
      }
    }
    else
    {
      uint64_t v74 = 0;
    }
    std::mutex::unlock(v67);
    char v73 = 0;
    char v75 = 1;
    goto LABEL_84;
  }
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

void sub_10093FC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  BOOL v9 = va_arg(va1, const void *);
  va_copy(va2, va1);
  char v11 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)va2);
  _Unwind_Resume(a1);
}

void sub_10093FD8C(uint64_t a1)
{
  if (!sub_10093E9B8(a1)) {
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v14 = v4;
  unsigned int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)v14);
  if (!v8)
  {
    uint64_t v10 = 0;
    goto LABEL_9;
  }
  uint64_t v10 = v8[3];
  BOOL v9 = (std::__shared_weak_count *)v8[4];
  if (!v9)
  {
LABEL_9:
    std::mutex::unlock(v3);
    BOOL v9 = 0;
    char v11 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
LABEL_10:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v10 + 32))(v10, **(void **)(a1 + 64) + 24, @"VoLTEBlockedByNetwork", kPhoneServicesWalletDomain, 0, 1);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)uint64_t v14 = 136315394;
    *(void *)&uint8_t v14[4] = v13;
    __int16 v15 = 2080;
    uint64_t v16 = " ";
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE 'blocked by network' removed", v14, 0x16u);
  }
}

void sub_10093FF54(_Unwind_Exception *exception_object)
{
}

void sub_10093FF88(uint64_t a1)
{
  int v2 = operator new(0x18uLL);
  *(_OWORD *)int v2 = *(_OWORD *)off_101A1D328;
  void v2[2] = @"DisableVolteSwitchOnIncompatibleState";
  std::string __p = v2;
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 416) + 104))(cf);
  uint64_t v3 = *(BOOL **)cf;
  unsigned __int8 v20 = 0;
  if (!*(void *)cf)
  {
    sub_1000577C4((const void **)cf);
    goto LABEL_18;
  }
  CFTypeID v4 = CFGetTypeID(*(CFTypeRef *)cf);
  if (v4 == CFBooleanGetTypeID()) {
    ctu::cf::assign((ctu::cf *)&v20, v3, v5);
  }
  int v6 = v20;
  sub_1000577C4((const void **)cf);
  if (v6)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    unsigned int v8 = ServiceMap;
    if (v9 < 0)
    {
      uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    *(void *)CFTypeRef cf = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)cf);
    if (v13)
    {
      uint64_t v15 = v13[3];
      uint64_t v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_14:
        (*(void (**)(uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v15 + 16))(v15, **(void **)(a1 + 64) + 24, @"VoLTEBlockedByNetwork", kCFBooleanTrue, kPhoneServicesWalletDomain, 0, 1, 0);
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        unint64_t v17 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
          *(_DWORD *)CFTypeRef cf = 136315394;
          *(void *)&cf[4] = v18;
          __int16 v22 = 2080;
          char v23 = " ";
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE blocked by network", cf, 0x16u);
        }
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    goto LABEL_14;
  }
LABEL_18:
  if (__p) {
    operator delete(__p);
  }
}

void sub_100940228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100940280@<W0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  CFBooleanRef BOOLean = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 48));
  CFTypeID v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v18);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v11 + 24))(&v16, v11, **(void **)(a1 + 64) + 24, @"VoLTENetworkSeen", kPhoneServicesWalletDomain, 0, 1);
  sub_1000057AC(&BOOLean, &v16);
  sub_1000577C4(&v16);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (BOOLean) {
    uint64_t v13 = sub_100084B4C;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13) {
    BOOL v14 = CFBooleanGetValue(BOOLean) != 0;
  }
  else {
    BOOL v14 = 0;
  }
  sub_100062778((const void **)&BOOLean);
  return v14;
}

void sub_100940408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100940444@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  CFMutableDictionaryRef theDict = 0;
  int v4 = *(_DWORD *)(a1 + 304);
  if ((v4 - 2) < 2)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFBooleanRef v11 = theDict;
      CFMutableDictionaryRef theDict = Mutable;
      CFBooleanRef BOOLean = v11;
      sub_10005717C((const void **)&BOOLean);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCanChangeSetting, kCFBooleanTrue);
    char v9 = 1;
    char v7 = 1;
    char v8 = 1;
  }
  else if (v4 == 4)
  {
    char v12 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v12)
    {
      CFBooleanRef v13 = theDict;
      CFMutableDictionaryRef theDict = v12;
      CFBooleanRef BOOLean = v13;
      sub_10005717C((const void **)&BOOLean);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCanChangeSettingEnableStillProvisioning, kCFBooleanTrue);
    char v8 = 0;
    char v9 = 1;
    char v7 = 1;
  }
  else if (v4 == 5)
  {
    unint64_t v5 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v5)
    {
      CFBooleanRef v6 = theDict;
      CFMutableDictionaryRef theDict = v5;
      CFBooleanRef BOOLean = v6;
      sub_10005717C((const void **)&BOOLean);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCannotChangeSettingNeedToCallCarrier, kCFBooleanTrue);
    char v7 = 0;
    char v8 = 0;
    char v9 = 1;
  }
  else
  {
    char v9 = 0;
    char v7 = 0;
    char v8 = 0;
  }
  if (!sub_10121F67C())
  {
    CFBooleanRef BOOLean = 0;
    (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 416) + 96))(&v15);
    sub_1000057AC(&BOOLean, &v15);
    sub_1000577C4(&v15);
    if (*(_DWORD *)(a1 + 152) != *(_DWORD *)(**(void **)(a1 + 64) + 52) && CFBooleanGetValue(BOOLean)) {
      char v9 = 0;
    }
    sub_100062778((const void **)&BOOLean);
  }
  *(unsigned char *)a2 = v9;
  *(unsigned char *)(a2 + 1) = v7;
  *(unsigned char *)(a2 + 2) = v8;
  sub_10004EFE4((void *)(a2 + 8), (CFTypeRef *)&theDict);
  return sub_10005717C((const void **)&theDict);
}

void sub_1009406AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  int v4 = va_arg(va1, const void *);
  sub_100062778((const void **)va1);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1009406E4@<X0>(_DWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = 0;
  CFBooleanRef v6 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 56))(&v5);
  *(unsigned char *)a2 = a1[75] == 2;
  sub_100058198((const void **)(a2 + 8), &v6);
  return sub_100057D78(&v6);
}

void sub_100940774(uint64_t a1, int a2)
{
  int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v6 = asStringBool(a2);
    uint64_t v7 = *(int *)(a1 + 304);
    if (v7 > 5) {
      char v8 = "???";
    }
    else {
      char v8 = off_101A1DA08[v7];
    }
    uint64_t v9 = *(int *)(a1 + 308);
    if (v9 > 6) {
      uint64_t v10 = "???";
    }
    else {
      uint64_t v10 = off_101A1D9D0[v9];
    }
    int v20 = 136316162;
    uint64_t v21 = v5;
    __int16 v22 = 2080;
    char v23 = " ";
    __int16 v24 = 2080;
    uint64_t v25 = v6;
    __int16 v26 = 2080;
    CFNumberRef v27 = v8;
    __int16 v28 = 2080;
    char v29 = v10;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%ssetEnabled(%s): Current 'volte can set' status: %s, and lte entitlement support: %s", (uint8_t *)&v20, 0x34u);
  }
  sub_10093FD8C(a1);
  unsigned int v11 = *(_DWORD *)(a1 + 304);
  BOOL v12 = v11 > 5;
  int v13 = (1 << v11) & 0x23;
  if (v12 || v13 == 0)
  {
    uint64_t v15 = (uint64_t *)*(unsigned int *)(a1 + 308);
    switch((int)v15)
    {
      case 1:
      case 3:
      case 5:
        goto LABEL_15;
      case 2:
        if (sub_10093E72C(a1, v15)) {
LABEL_15:
        }
          sub_10093DA18((VoLteControl *)a1, a2);
        goto LABEL_16;
      case 4:
        if (*(unsigned char *)(a1 + 376))
        {
          char v16 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
            int v20 = 136315394;
            uint64_t v21 = v17;
            __int16 v22 = 2080;
            char v23 = " ";
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%sSet entitlement is already in progress, no need to issue another request", (uint8_t *)&v20, 0x16u);
          }
        }
        else
        {
          sub_10093DA18((VoLteControl *)a1, a2);
          if (a2)
          {
            sub_10093EF28(a1);
          }
          else
          {
            unint64_t v18 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
              int v20 = 136315394;
              uint64_t v21 = v19;
              __int16 v22 = 2080;
              char v23 = " ";
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%sUser has chosen to disable VoLTE, not triggering set entitlement", (uint8_t *)&v20, 0x16u);
            }
          }
LABEL_16:
          (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, 1, 0);
        }
        break;
      default:
        goto LABEL_16;
    }
  }
}

void sub_100940A5C(uint64_t a1, int a2, char a3)
{
  BOOL v6 = sub_10093C5C8(a1);
  uint64_t v7 = (uint64_t *)*(unsigned __int8 *)(a1 + 281);
  if (*(unsigned char *)(a1 + 281))
  {
    switch(*(_DWORD *)(a1 + 308))
    {
      case 0:
        int v8 = 0;
        break;
      case 1:
      case 3:
        goto LABEL_11;
      case 2:
      case 5:
        if (sub_10093E72C(a1, v7)) {
          int v8 = 2;
        }
        else {
          int v8 = 1;
        }
        break;
      case 4:
        if (!sub_10093E72C(a1, v7) || !*(unsigned char *)(a1 + 376) && !sub_10093E96C(a1)) {
          goto LABEL_12;
        }
LABEL_11:
        int v8 = 2;
        break;
      case 6:
        goto LABEL_12;
      default:
        int v8 = *(_DWORD *)(a1 + 288);
        break;
    }
  }
  else
  {
LABEL_12:
    int v8 = 1;
  }
  int v59 = *(_DWORD *)(a1 + 288);
  if (v59 != v8)
  {
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)OsLogContext buf = 136315906;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v64 = 2080;
      uint64_t v65 = asString();
      __int16 v66 = 2080;
      uint64_t v67 = asString();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE Network support is changing from %s to %s", buf, 0x2Au);
    }
    *(_DWORD *)(a1 + 288) = v8;
  }
  int v60 = v8;
  if (*(unsigned char *)(a1 + 281))
  {
    unsigned int v11 = (uint64_t *)*(unsigned int *)(a1 + 308);
    int v12 = 4;
    unsigned int v13 = 2;
    switch((int)v11)
    {
      case 1:
      case 3:
        goto LABEL_33;
      case 2:
        if (!sub_10093E72C(a1, v11)) {
          goto LABEL_20;
        }
        goto LABEL_33;
      case 4:
        unsigned int v11 = (uint64_t *)*(unsigned __int8 *)(a1 + 376);
        if (!*(unsigned char *)(a1 + 376))
        {
          if (sub_10093E96C(a1))
          {
            *(unsigned char *)(a1 + 377) = 1;
            sub_10093EF28(a1);
          }
          else
          {
            int v12 = 3;
          }
        }
        goto LABEL_29;
      case 5:
        goto LABEL_29;
      case 6:
LABEL_20:
        int v12 = 5;
        goto LABEL_29;
      default:
        unsigned int v13 = *(_DWORD *)(a1 + 304);
        unsigned int v11 = (uint64_t *)(v13 - 3);
        if (v11 >= 3)
        {
          if (v13 != 2) {
            goto LABEL_42;
          }
        }
        else
        {
          int v12 = *(_DWORD *)(a1 + 304);
LABEL_29:
          unsigned int v13 = v12;
          if (sub_10093EB7C(a1, v11))
          {
            BOOL v14 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
              *(_DWORD *)OsLogContext buf = 136315394;
              *(void *)&uint8_t buf[4] = v15;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE switch is hidden since VoLTE network was not ever seen", buf, 0x16u);
            }
            unsigned int v13 = 1;
          }
        }
LABEL_33:
        if (!sub_10093D00C(a1))
        {
          char v16 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
            *(_DWORD *)OsLogContext buf = 136315394;
            *(void *)&uint8_t buf[4] = v17;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%sEither VoLTE switch support is not present or it is set to false", buf, 0x16u);
          }
          unsigned int v13 = 1;
        }
        if (!*(unsigned char *)(a1 + 284) && !VoLteControl::operatorBlocksCallsOverCS((VoLteControl *)a1)) {
          goto LABEL_42;
        }
        unint64_t v18 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
          *(_DWORD *)OsLogContext buf = 136315394;
          *(void *)&uint8_t buf[4] = v19;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%sCurrent operator does not allow switching VoLTE preference", buf, 0x16u);
        }
        break;
    }
  }
  unsigned int v13 = 1;
LABEL_42:
  int v20 = *(_DWORD *)(a1 + 304);
  if (v20 != v13)
  {
    uint64_t v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v23 = *(int *)(a1 + 304);
      if (v23 > 5) {
        __int16 v24 = "???";
      }
      else {
        __int16 v24 = off_101A1DA08[v23];
      }
      if (v13 > 5) {
        uint64_t v25 = "???";
      }
      else {
        uint64_t v25 = off_101A1DA08[v13];
      }
      *(_DWORD *)OsLogContext buf = 136315906;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v64 = 2080;
      uint64_t v65 = (uint64_t)v24;
      __int16 v66 = 2080;
      uint64_t v67 = (uint64_t)v25;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%sSupports lte switch is changing from %s to %s", buf, 0x2Au);
    }
    *(_DWORD *)(a1 + 304) = v13;
  }
  int v26 = *(unsigned __int8 *)(a1 + 292);
  int v27 = sub_10093D1CC(a1);
  *(unsigned char *)(a1 + 292) = v27;
  BOOL v28 = v26 != v27;
  char v62 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v29, *(Registry **)(a1 + 48));
  CFStringRef v31 = ServiceMap;
  if (v32 < 0)
  {
    __int16 v33 = (unsigned __int8 *)(v32 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v34 = 5381;
    do
    {
      uint64_t v32 = v34;
      unsigned int v35 = *v33++;
      uint64_t v34 = (33 * v34) ^ v35;
    }
    while (v35);
  }
  std::mutex::lock(ServiceMap);
  *(void *)OsLogContext buf = v32;
  uint64_t v36 = sub_10004D37C(&v31[1].__m_.__sig, (unint64_t *)buf);
  if (v36)
  {
    uint64_t v38 = v36[3];
    unsigned int v37 = (std::__shared_weak_count *)v36[4];
    if (v37)
    {
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v31);
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v37);
      char v39 = 0;
      goto LABEL_60;
    }
  }
  else
  {
    uint64_t v38 = 0;
  }
  std::mutex::unlock(v31);
  unsigned int v37 = 0;
  char v39 = 1;
LABEL_60:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v38 + 96))(&v61, v38, *(unsigned int *)(**(void **)(a1 + 64) + 52), 1, @"PrefersGWForLimitedService", 0, 0);
  sub_1000057AC(&v62, &v61);
  sub_1000577C4(&v61);
  if ((v39 & 1) == 0) {
    sub_10004D2C8(v37);
  }
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v62, v40);
  if (!buf[0]) {
    goto LABEL_91;
  }
  char v41 = *(NSObject **)(a1 + 40);
  BOOL v42 = os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT);
  if (v42)
  {
    uint64_t v43 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)OsLogContext buf = 136315394;
    *(void *)&uint8_t buf[4] = v43;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I %s%sAU carrier detected", buf, 0x16u);
  }
  if (capabilities::ct::getBasebandBootStrategy((capabilities::ct *)v42) == 2)
  {
LABEL_91:
    if (!*(unsigned char *)(**(void **)(a1 + 64) + 48)) {
      goto LABEL_74;
    }
  }
  int v44 = *(_DWORD *)(a1 + 288);
  if (v44)
  {
    if (v44 == 2) {
      int v45 = 2;
    }
    else {
      int v45 = 1;
    }
    if (*(unsigned char *)(a1 + 292)) {
      int v46 = v45;
    }
    else {
      int v46 = 1;
    }
  }
  else
  {
LABEL_74:
    int v46 = 0;
  }
  if (v46 != *(_DWORD *)(a1 + 300))
  {
    char v47 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v48 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v49 = asString();
      *(_DWORD *)OsLogContext buf = 136315650;
      *(void *)&uint8_t buf[4] = v48;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v64 = 2080;
      uint64_t v65 = v49;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s%sVoLTE feature re-evaluated to %s", buf, 0x20u);
    }
    *(_DWORD *)(a1 + 300) = v46;
    BOOL v28 = 1;
  }
  sub_100062778((const void **)&v62);
  char v50 = v20 != v13 || v28;
  if (v59 != v60) {
    char v50 = 1;
  }
  char v51 = v50 | v6;
  sub_100A2FD3C(*(void *)(a1 + 80), 2, a2);
  if ((v51 & 1) != 0 || (a3 & 1) != 0 || a2)
  {
    char v52 = *(unsigned char *)(a1 + 281);
    int v53 = *(_DWORD *)(a1 + 296);
    char v54 = *(unsigned char *)(a1 + 292);
    BOOL v55 = *(_DWORD *)(a1 + 288) == 2;
    int v56 = *(_DWORD *)(a1 + 300);
    uint64_t v57 = *(void *)(a1 + 80);
    unsigned int v58 = (char *)operator new(0x30uLL);
    *((void *)v58 + 1) = 0;
    *((void *)v58 + 2) = 0;
    *(void *)unsigned int v58 = off_1019DD770;
    *(_WORD *)(v58 + 25) = 0;
    v58[27] = 0;
    *((_DWORD *)v58 + 7) = v53;
    v58[32] = v54;
    *(_WORD *)(v58 + 33) = 0;
    v58[35] = 0;
    v58[36] = v55;
    *(_WORD *)(v58 + 37) = 0;
    v58[39] = 0;
    *((_DWORD *)v58 + 10) = v56;
    *(void *)&uint8_t buf[8] = v58;
    v58[24] = v52;
    *(void *)OsLogContext buf = v58 + 24;
    sub_100A321D8(v57, 2, (uint64_t **)buf);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
}

void sub_100941254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1009412F0(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v4 = **(void **)(a1 + 64);
    uint64_t v7 = *(const char **)(v4 + 24);
    uint64_t v5 = (const char *)(v4 + 24);
    BOOL v6 = v7;
    uint64_t v8 = *((unsigned __int8 *)v5 + 23);
    int v9 = (char)v8;
    if ((v8 & 0x80u) != 0) {
      uint64_t v8 = *((void *)v5 + 1);
    }
    if (v9 < 0) {
      uint64_t v5 = v6;
    }
    if (!v8) {
      uint64_t v5 = "<invalid>";
    }
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v3;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = (uint64_t)v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s== dump VoLteControl '%s'", buf, 0x20u);
  }
  uint64_t v10 = *(void *)(a1 + 112);
  uint64_t v11 = **(void **)(a1 + 64);
  if (!v10) {
    goto LABEL_19;
  }
  int v12 = *(_DWORD *)(v11 + 52);
  uint64_t v13 = a1 + 112;
  do
  {
    int v14 = *(_DWORD *)(v10 + 32);
    BOOL v15 = v14 < v12;
    if (v14 >= v12) {
      char v16 = (uint64_t *)v10;
    }
    else {
      char v16 = (uint64_t *)(v10 + 8);
    }
    if (!v15) {
      uint64_t v13 = v10;
    }
    uint64_t v10 = *v16;
  }
  while (*v16);
  if (v13 != a1 + 112 && v12 >= *(_DWORD *)(v13 + 32)) {
    BOOL v17 = *(unsigned char *)(v13 + 64) & 1;
  }
  else {
LABEL_19:
  }
    BOOL v17 = 0;
  sub_100046F68(a1 + 128, (void **)(v11 + 24));
  uint64_t v19 = a1 + 192;
  uint64_t v18 = *(void *)(a1 + 192);
  int v20 = *(PersonalityInfo ***)(a1 + 64);
  if (!v18) {
    goto LABEL_30;
  }
  int v21 = *((_DWORD *)*v20 + 13);
  uint64_t v22 = a1 + 192;
  do
  {
    int v23 = *(_DWORD *)(v18 + 28);
    BOOL v24 = v23 < v21;
    if (v23 >= v21) {
      uint64_t v25 = (uint64_t *)v18;
    }
    else {
      uint64_t v25 = (uint64_t *)(v18 + 8);
    }
    if (!v24) {
      uint64_t v22 = v18;
    }
    uint64_t v18 = *v25;
  }
  while (*v25);
  if (v22 == v19 || v21 < *(_DWORD *)(v22 + 28)) {
LABEL_30:
  }
    uint64_t v22 = a1 + 192;
  int v26 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = PersonalityInfo::logPrefix(*v20);
    uint64_t v28 = asStringBool(*(unsigned char *)(a1 + 281));
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v27;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v28;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sCarrier support: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v29 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v30 = asString();
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v29;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v30;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sAccount/Network support: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v31 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v32 = asStringBool(*(unsigned char *)(a1 + 292));
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v31;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v32;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sActual VoLTE switch state: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v34 = *(int *)(a1 + 296);
    if (v34 > 2) {
      unsigned int v35 = (char *)&unk_10161656E;
    }
    else {
      unsigned int v35 = off_101A1D9B8[v34];
    }
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v33;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = (uint64_t)v35;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sUser preference: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v36 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v37 = *(int *)(a1 + 308);
    if (v37 > 6) {
      uint64_t v38 = "???";
    }
    else {
      uint64_t v38 = off_101A1D9D0[v37];
    }
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v36;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = (uint64_t)v38;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sEntitlement support: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v39 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v40 = asStringBool(v17);
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v39;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v40;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%svoiceImsPrefServiceMask: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v41 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v42 = asString();
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v41;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v42;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sImsVoiceSupportOnLte: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v43 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v44 = *(int *)(a1 + 304);
    if (v44 > 5) {
      int v45 = "???";
    }
    else {
      int v45 = off_101A1DA08[v44];
    }
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v43;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = (uint64_t)v45;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sCanSet state: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v46 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    if (v22 == v19) {
      char v47 = "unknown";
    }
    else {
      char v47 = (const char *)asStringBool(*(unsigned char *)(v22 + 32));
    }
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v46;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = (uint64_t)v47;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sInHomeCountry: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v48 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v49 = asStringBool(*(unsigned char *)(a1 + 284));
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v48;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v49;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sNonCS network seen: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v50 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    if (*(unsigned char *)(a1 + 283)) {
      char v51 = (const char *)asStringBool(*(unsigned char *)(a1 + 282));
    }
    else {
      char v51 = "unknown";
    }
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v50;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = (uint64_t)v51;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sCurrent VoCs Support: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v52 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    MCCAndMNC::getStringValue((uint64_t *)__p, (MCCAndMNC *)(a1 + 312));
    if (v68 >= 0) {
      int v53 = __p;
    }
    else {
      int v53 = (void **)__p[0];
    }
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v52;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = (uint64_t)v53;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sServingPlmn: %s", buf, 0x20u);
    if (v68 < 0) {
      operator delete(__p[0]);
    }
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v54 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v55 = asString();
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v54;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v55;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sFinal capability state: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v56 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v57 = asStringBool(*(unsigned char *)(a1 + 376));
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v56;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v57;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sfVolteSetEntitlementInProgress: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v58 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v59 = asStringBool(*(unsigned char *)(a1 + 377));
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v58;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v59;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sfVolteSetEntitlementAttempted: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v60 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    BOOL v61 = (unsigned __int16)sub_10093D00C(a1) > 0xFFu;
    BOOL v62 = sub_10093D644(a1, v61);
    uint64_t v63 = asStringBool(v62);
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v60;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v63;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sEnableVolteByDefault: %s", buf, 0x20u);
    int v26 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v64 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    BOOL v65 = sub_10093D17C(a1);
    uint64_t v66 = asStringBool(v65);
    *(_DWORD *)OsLogContext buf = 136315650;
    uint64_t v70 = v64;
    __int16 v71 = 2080;
    char v72 = " ";
    __int16 v73 = 2080;
    uint64_t v74 = v66;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sMandatoryDisabled: %s", buf, 0x20u);
  }
}

uint64_t sub_100941DC0()
{
  return 0;
}

void sub_100941DC8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100941E94(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100941F6C);
  __cxa_rethrow();
}

void sub_100941EBC(_Unwind_Exception *a1)
{
}

void sub_100941ED4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100941F0C(uint64_t a1)
{
}

uint64_t sub_100941F28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100941F6C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *sub_100941F98(void *a1)
{
  *a1 = off_101A1D458;
  int v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100941FE4(void *a1)
{
  *a1 = off_101A1D458;
  char v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100942050(uint64_t a1)
{
  BOOL result = (char *)operator new(0x28uLL);
  *(void *)BOOL result = off_101A1D458;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1009420B4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1D458;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009420F4(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100942104(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100942144(uint64_t *a1, xpc_object_t *a2)
{
  sub_100942358(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      BOOL v6 = v5;
      if (a1[3])
      {
        uint64_t v7 = sub_100046F68(v4 + 128, (void **)(**(void **)(v4 + 64) + 24));
        if ((void **)(v4 + 136) != v7)
        {
          int v8 = *((_DWORD *)v7 + 14);
          int v9 = *(NSObject **)(v4 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v4 + 64));
            int v11 = 136315650;
            uint64_t v12 = v10;
            __int16 v13 = 2080;
            int v14 = " ";
            __int16 v15 = 2080;
            uint64_t v16 = asString();
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sIms Voice Support on LTE changed to %s", (uint8_t *)&v11, 0x20u);
          }
          if (v8)
          {
            sub_10093E4B8(v4, v8 == 1);
            (*(void (**)(uint64_t, void, void))(*(void *)v4 + 104))(v4, 0, 0);
          }
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1009422F8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10094230C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10094234C()
{
}

void sub_100942358(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_10005CD2C(a1, *(char **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v11, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v10, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v12; i != v10[1] || v11 != v10[0]; uint64_t i = ++v12)
    {
      xpc_object_t v9 = 0;
      object[0] = &v11;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v9);
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
      {
        *(_OWORD *)xpc_object_t object = 0u;
        long long v8 = 0u;
        xpc_object_t v6 = v9;
        if (v9) {
          xpc_retain(v9);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_100942600((uint64_t)object, &v6);
        xpc_release(v6);
        sub_1009427B4((uint64_t **)a1, object, (uint64_t)object);
        if (SBYTE7(v8) < 0) {
          operator delete(object[0]);
        }
      }
      xpc_release(v9);
    }
    xpc_release(v11);
    xpc_release(v11);
  }
  xpc_release(v3);
}

void sub_10094255C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, xpc_object_t a19, xpc_object_t a20)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v21 - 48));
  xpc_release(v20);
  _Unwind_Resume(a1);
}

void sub_100942600(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    uint64_t v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    read_rest_value();
    xpc_release(object);
    xpc_object_t v6 = &v9;
    uint64_t v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *(_DWORD *)(a1 + 24);
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *(_DWORD *)(a1 + 24) = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *(_DWORD *)(a1 + 24) = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_100942760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, xpc_object_t object)
{
}

uint64_t *sub_1009427B4(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v8, a2);
  BOOL result = *v5;
  if (!*v5)
  {
    memset(v7, 0, sizeof(v7));
    sub_100942840((uint64_t)a1, a3, v7);
    sub_100046C38(a1, v8, v5, v7[0]);
    return v7[0];
  }
  return result;
}

unsigned char *sub_100942840@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  xpc_object_t v6 = a3 + 1;
  uint64_t v7 = (char *)operator new(0x40uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  BOOL result = v7 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    BOOL result = sub_10004FC84(result, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)BOOL result = *(_OWORD *)a2;
    *((void *)v7 + 6) = *(void *)(a2 + 16);
  }
  *((_DWORD *)v7 + 14) = *(_DWORD *)(a2 + 24);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1009428D8(_Unwind_Exception *a1)
{
  *char v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

void *sub_1009428F4(void *a1)
{
  *a1 = off_101A1D4D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100942940(void *a1)
{
  *a1 = off_101A1D4D8;
  char v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1009429AC(uint64_t a1)
{
  BOOL result = (char *)operator new(0x20uLL);
  *(void *)BOOL result = off_101A1D4D8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100942A10(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1D4D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100942A50(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100942A60(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100942AA0(void *a1, xpc_object_t *a2)
{
  uint64_t v19 = 0;
  sub_100034810((int *)&v19, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    uint64_t v4 = a1[1];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      xpc_object_t v6 = v5;
      if (a1[2])
      {
        uint64_t v7 = **(PersonalityInfo ***)(v4 + 64);
        if (*((_DWORD *)v7 + 13) == v19)
        {
          int v8 = BYTE4(v19);
          if (!*(unsigned char *)(v4 + 283) || *(unsigned __int8 *)(v4 + 282) != BYTE4(v19))
          {
            int v10 = *(NSObject **)(v4 + 40);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v11 = PersonalityInfo::logPrefix(v7);
              if (*(unsigned char *)(v4 + 283)) {
                uint64_t v12 = (const char *)asStringBool(*(unsigned char *)(v4 + 282));
              }
              else {
                uint64_t v12 = "<unknown>";
              }
              uint64_t v13 = asStringBool(v8 != 0);
              *(_DWORD *)OsLogContext buf = 136315906;
              uint64_t v21 = v11;
              __int16 v22 = 2080;
              int v23 = " ";
              __int16 v24 = 2080;
              uint64_t v25 = v12;
              __int16 v26 = 2080;
              uint64_t v27 = v13;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%scs_voice_support_changed: %s -> %s", buf, 0x2Au);
            }
            BOOL v14 = v8 == 0;
            *(_WORD *)(v4 + 282) = v8 | 0x100;
            if (*(unsigned char *)(v4 + 284) || v8)
            {
              if (!*(unsigned char *)(v4 + 284)) {
                BOOL v14 = 1;
              }
              if (!v14)
              {
                BOOL v17 = *(NSObject **)(v4 + 40);
                if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v4 + 64));
                  *(_DWORD *)OsLogContext buf = 136315394;
                  uint64_t v21 = v18;
                  __int16 v22 = 2080;
                  int v23 = " ";
                  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%sNonCS operator was seen recently - Keep dynamic VoLTE support allowed", buf, 0x16u);
                }
              }
            }
            else
            {
              __int16 v15 = *(NSObject **)(v4 + 40);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v4 + 64));
                *(_DWORD *)OsLogContext buf = 136315394;
                uint64_t v21 = v16;
                __int16 v22 = 2080;
                int v23 = " ";
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%sNonCS operator observed - Allow dynamic VoLTE support", buf, 0x16u);
              }
              *(unsigned char *)(v4 + 284) = 1;
            }
            (*(void (**)(uint64_t, void, void))(*(void *)v4 + 104))(v4, 0, 0);
          }
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100942D44(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100942D60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100942DA0()
{
}

void *sub_100942DAC(void *a1)
{
  *a1 = off_101A1D558;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100942DF8(void *a1)
{
  *a1 = off_101A1D558;
  char v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100942E64(uint64_t a1)
{
  BOOL result = (char *)operator new(0x28uLL);
  *(void *)BOOL result = off_101A1D558;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100942EC8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1D558;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100942F08(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100942F18(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100942F58(uint64_t *a1, xpc_object_t *a2)
{
  sub_1005BF770(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      xpc_object_t v6 = v5;
      if (a1[3])
      {
        uint64_t v7 = *(void *)(v4 + 264);
        if (v7)
        {
          int v8 = **(PersonalityInfo ***)(v4 + 64);
          int v9 = *((_DWORD *)v8 + 13);
          uint64_t v10 = v4 + 264;
          do
          {
            int v11 = *(_DWORD *)(v7 + 32);
            BOOL v12 = v11 < v9;
            if (v11 >= v9) {
              uint64_t v13 = (uint64_t *)v7;
            }
            else {
              uint64_t v13 = (uint64_t *)(v7 + 8);
            }
            if (!v12) {
              uint64_t v10 = v7;
            }
            uint64_t v7 = *v13;
          }
          while (*v13);
          if (v10 != v4 + 264 && v9 >= *(_DWORD *)(v10 + 32))
          {
            BOOL v14 = *(NSObject **)(v4 + 40);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v15 = PersonalityInfo::logPrefix(v8);
              MCCAndMNC::getMcc(&v24, (MCCAndMNC *)(v10 + 40));
              int IntValue = MCC::getIntValue((MCC *)&v24);
              MCCAndMNC::getMnc(v22, (MCCAndMNC *)(v10 + 40));
              int IntegerWidth = MNC::getIntegerWidth((MNC *)v22);
              MCCAndMNC::getMnc(v20, (MCCAndMNC *)(v10 + 40));
              int v18 = MCC::getIntValue((MCC *)v20);
              *(_DWORD *)OsLogContext buf = 136316162;
              *(void *)uint64_t v28 = v15;
              *(_WORD *)&v28[8] = 2080;
              *(void *)&v28[10] = " ";
              __int16 v29 = 1024;
              int v30 = IntValue;
              __int16 v31 = 1024;
              int v32 = IntegerWidth;
              __int16 v33 = 1024;
              int v34 = v18;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sServingNetwork: PLMN: %03d-%0.*d - reset dynamic VoLTE support", buf, 0x28u);
              if (v21 < 0) {
                operator delete((void *)v20[1]);
              }
              if (v23 < 0) {
                operator delete((void *)v22[1]);
              }
              if (v26 < 0) {
                operator delete(v25);
              }
            }
            MCCAndMNC::getMcc((uint64_t *)buf, (MCCAndMNC *)(v10 + 40));
            if (MCC::valid((MCC *)buf))
            {
              MCCAndMNC::getMnc(&v24, (MCCAndMNC *)(v10 + 40));
              if (MCC::valid((MCC *)&v24)) {
                int v19 = MCCAndMNC::operator!=();
              }
              else {
                int v19 = 0;
              }
              if (v26 < 0) {
                operator delete(v25);
              }
            }
            else
            {
              int v19 = 0;
            }
            if (SBYTE1(v32) < 0) {
              operator delete(*(void **)&v28[4]);
            }
            if (v19)
            {
              *(unsigned char *)(v4 + 284) = 0;
              if (*(unsigned char *)(v4 + 283)) {
                *(unsigned char *)(v4 + 283) = 0;
              }
              MCC::operator=();
              MCC::operator=();
              (*(void (**)(uint64_t, void, void))(*(void *)v4 + 104))(v4, 0, 0);
            }
          }
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100943248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v36);
  _Unwind_Resume(a1);
}

uint64_t sub_1009432DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10094331C()
{
}

void *sub_100943328(void *a1)
{
  *a1 = off_101A1D5D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100943374(void *a1)
{
  *a1 = off_101A1D5D8;
  char v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1009433E0(uint64_t a1)
{
  BOOL result = (char *)operator new(0x28uLL);
  *(void *)BOOL result = off_101A1D5D8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100943444(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1D5D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100943484(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100943494(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1009434D4(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v5 = (std::__shared_weak_count *)a1[4];
  if (v5)
  {
    uint64_t v6 = a1[2];
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      int v8 = v7;
      if (a1[3] && *(unsigned char *)(v6 + 280) && *(unsigned char *)(v6 + 284))
      {
        int v9 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v6 + 64));
          int v11 = 136315394;
          uint64_t v12 = v10;
          __int16 v13 = 2080;
          BOOL v14 = " ";
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sRadio disabled - Reset dynamic VoLTE support", (uint8_t *)&v11, 0x16u);
        }
        *(unsigned char *)(v6 + 284) = 0;
        if (*(unsigned char *)(v6 + 283)) {
          *(unsigned char *)(v6 + 283) = 0;
        }
        (*(void (**)(uint64_t, void, void))(*(void *)v6 + 104))(v6, 0, 0);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10094365C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100943670(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009436B0()
{
}

void *sub_1009436BC(void *a1)
{
  *a1 = off_101A1D658;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100943708(void *a1)
{
  *a1 = off_101A1D658;
  char v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100943774(uint64_t a1)
{
  BOOL result = (char *)operator new(0x28uLL);
  *(void *)BOOL result = off_101A1D658;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1009437D8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1D658;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100943818(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100943828(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100943868(uint64_t *a1, xpc_object_t *a2)
{
  sub_10072E934(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[3])
      {
        uint64_t v7 = *(void *)(v4 + 112);
        if (v7)
        {
          int v8 = *(_DWORD *)(**(void **)(v4 + 64) + 52);
          uint64_t v9 = v4 + 112;
          do
          {
            int v10 = *(_DWORD *)(v7 + 32);
            BOOL v11 = v10 < v8;
            if (v10 >= v8) {
              uint64_t v12 = (uint64_t *)v7;
            }
            else {
              uint64_t v12 = (uint64_t *)(v7 + 8);
            }
            if (!v11) {
              uint64_t v9 = v7;
            }
            uint64_t v7 = *v12;
          }
          while (*v12);
          if (v9 != v4 + 112 && v8 >= *(_DWORD *)(v9 + 32))
          {
            std::string __p = 0;
            BOOL v14 = 0;
            uint64_t v15 = 0;
            sub_1003FB56C(&__p, *(const void **)(v9 + 40), *(void *)(v9 + 48), (uint64_t)(*(void *)(v9 + 48) - *(void *)(v9 + 40)) >> 2);
            sub_10093E4B8(v4, *(_DWORD *)(v9 + 64) & 1);
            (*(void (**)(uint64_t, void, void))(*(void *)v4 + 104))(v4, 0, 0);
            if (__p)
            {
              BOOL v14 = __p;
              operator delete(__p);
            }
          }
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100943980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_1009439AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009439EC()
{
}

void *sub_1009439F8(void *a1)
{
  *a1 = off_101A1D6D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100943A44(void *a1)
{
  *a1 = off_101A1D6D8;
  char v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100943AB0(uint64_t a1)
{
  BOOL result = (char *)operator new(0x28uLL);
  *(void *)BOOL result = off_101A1D6D8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100943B14(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1D6D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100943B54(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100943B64(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100943BA4(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    *uint64_t v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (std::__shared_weak_count *)a1[4];
  if (v9)
  {
    uint64_t v10 = a1[2];
    BOOL v11 = std::__shared_weak_count::lock(v9);
    if (v11)
    {
      uint64_t v12 = v11;
      if (a1[3])
      {
        if (*(_DWORD *)(**(void **)(v10 + 64) + 52) == *(_DWORD *)(v10 + 152)) {
          (*(void (**)(uint64_t, void, void))(*(void *)v10 + 104))(v10, 0, 0);
        }
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_100943CBC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100943CD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100943D10()
{
}

void *sub_100943D1C(void *a1)
{
  *a1 = off_101A1D758;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100943D68(void *a1)
{
  *a1 = off_101A1D758;
  char v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100943DD4(uint64_t a1)
{
  BOOL result = (char *)operator new(0x28uLL);
  *(void *)BOOL result = off_101A1D758;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100943E38(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1D758;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100943E78(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100943E88(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100943EC8(uint64_t *a1, xpc_object_t *a2)
{
  sub_10008AAD8(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[3])
      {
        uint64_t v7 = *(void *)(v4 + 168);
        if (v7)
        {
          int v8 = *(_DWORD *)(**(void **)(v4 + 64) + 52);
          uint64_t v9 = v4 + 168;
          do
          {
            int v10 = *(_DWORD *)(v7 + 32);
            BOOL v11 = v10 < v8;
            if (v10 >= v8) {
              uint64_t v12 = (uint64_t *)v7;
            }
            else {
              uint64_t v12 = (uint64_t *)(v7 + 8);
            }
            if (!v11) {
              uint64_t v9 = v7;
            }
            uint64_t v7 = *v12;
          }
          while (*v12);
          if (v9 != v4 + 168 && v8 >= *(_DWORD *)(v9 + 32) && *(unsigned char *)(v9 + 40)) {
            (*(void (**)(uint64_t, void, void))(*(void *)v4 + 104))(v4, 0, 0);
          }
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100943FC0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100943FD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100944014()
{
}

void *sub_100944020(void *a1)
{
  *a1 = off_101A1D7D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10094406C(void *a1)
{
  *a1 = off_101A1D7D8;
  char v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1009440D8(uint64_t a1)
{
  BOOL result = (char *)operator new(0x28uLL);
  *(void *)BOOL result = off_101A1D7D8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10094413C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A1D7D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10094417C(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10094418C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1009441CC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v40 = (void **)*v3;
  uint64_t v41 = v5;
  if (v3[2])
  {
    void v5[2] = &v41;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v40 = &v41;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (std::__shared_weak_count *)a1[4];
  if (v6)
  {
    uint64_t v7 = a1[2];
    int v8 = std::__shared_weak_count::lock(v6);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[3])
      {
        uint64_t v11 = v7 + 192;
        uint64_t v10 = *(void *)(v7 + 192);
        uint64_t v12 = **(PersonalityInfo ***)(v7 + 64);
        int v13 = *((_DWORD *)v12 + 13);
        if (!v10) {
          goto LABEL_17;
        }
        uint64_t v14 = v7 + 192;
        uint64_t v15 = *(void *)(v7 + 192);
        do
        {
          int v16 = *(_DWORD *)(v15 + 28);
          BOOL v17 = v16 < v13;
          if (v16 >= v13) {
            int v18 = (uint64_t *)v15;
          }
          else {
            int v18 = (uint64_t *)(v15 + 8);
          }
          if (!v17) {
            uint64_t v14 = v15;
          }
          uint64_t v15 = *v18;
        }
        while (*v18);
        if (v14 != v11 && *(_DWORD *)(v14 + 28) <= v13)
        {
          uint64_t v25 = v41;
          if (v41)
          {
            char v26 = &v41;
            do
            {
              uint64_t v27 = v25;
              uint64_t v28 = v26;
              int v29 = *((_DWORD *)v25 + 7);
              int v30 = v25 + 1;
              if (v29 >= v13)
              {
                int v30 = v27;
                char v26 = (void **)v27;
              }
              uint64_t v25 = (void *)*v30;
            }
            while (v25);
            if (v26 != &v41)
            {
              __int16 v31 = v29 >= v13 ? v27 : v28;
              if (*((_DWORD *)v31 + 7) <= v13)
              {
                int v32 = *(unsigned __int8 *)(v14 + 32);
                if (v29 < v13) {
                  uint64_t v27 = v28;
                }
                if (v32 == *((unsigned __int8 *)v27 + 32)) {
                  goto LABEL_57;
                }
              }
            }
          }
        }
        else
        {
LABEL_17:
          int v19 = v41;
          if (!v41) {
            goto LABEL_57;
          }
          int v20 = &v41;
          do
          {
            char v21 = v19;
            __int16 v22 = v20;
            int v23 = *((_DWORD *)v19 + 7);
            uint64_t v24 = v19 + 1;
            if (v23 >= v13)
            {
              uint64_t v24 = v21;
              int v20 = (void **)v21;
            }
            int v19 = (void *)*v24;
          }
          while (v19);
          if (v20 == &v41) {
            goto LABEL_57;
          }
          if (v23 < v13) {
            char v21 = v22;
          }
          if (*((_DWORD *)v21 + 7) > v13) {
            goto LABEL_57;
          }
        }
        if (!v10) {
          goto LABEL_50;
        }
        uint64_t v33 = v7 + 192;
        do
        {
          int v34 = *(_DWORD *)(v10 + 28);
          BOOL v35 = v34 < v13;
          if (v34 >= v13) {
            uint64_t v36 = (uint64_t *)v10;
          }
          else {
            uint64_t v36 = (uint64_t *)(v10 + 8);
          }
          if (!v35) {
            uint64_t v33 = v10;
          }
          uint64_t v10 = *v36;
        }
        while (*v36);
        if (v33 == v11 || v13 < *(_DWORD *)(v33 + 28)) {
LABEL_50:
        }
          uint64_t v33 = v7 + 192;
        uint64_t v37 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = PersonalityInfo::logPrefix(v12);
          if (v33 == v11) {
            uint64_t v39 = "unknown";
          }
          else {
            uint64_t v39 = (const char *)asStringBool(*(unsigned char *)(v33 + 32));
          }
          *(_DWORD *)OsLogContext buf = 136315650;
          uint64_t v44 = v38;
          __int16 v45 = 2080;
          uint64_t v46 = " ";
          __int16 v47 = 2080;
          uint64_t v48 = v39;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s%sInHomeCountry changed to %s", buf, 0x20u);
        }
        (*(void (**)(uint64_t, void, void))(*(void *)v7 + 104))(v7, 0, 0);
      }
LABEL_57:
      sub_10004D2C8(v9);
    }
  }
  sub_1000346F8((uint64_t)&v40, v41);
}

void sub_1009444A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_10004D2C8(v11);
  sub_1000346F8((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_1009444C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100944508()
{
}

void sub_100944518()
{
}

void *sub_10094452C(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A1D858;
  result[1] = v3;
  return result;
}

uint64_t sub_100944574(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A1D858;
  a2[1] = v2;
  return result;
}

void sub_1009445A0(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1009445A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009445E8()
{
}

void sub_1009445F8()
{
}

void *sub_10094460C(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A1D8D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100944654(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A1D8D8;
  a2[1] = v2;
  return result;
}

void sub_100944680(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100944688(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009446C8()
{
}

uint64_t sub_1009446D4(uint64_t a1, _DWORD *a2)
{
  a2[7] |= 2u;
  a2[4] = *(_DWORD *)(a1 + 32);
  uint64_t result = subscriber::simSlotAsInstance();
  a2[7] |= 4u;
  a2[5] = result;
  return result;
}

uint64_t sub_10094471C(uint64_t a1, _DWORD *a2)
{
  a2[7] |= 2u;
  a2[4] = *(_DWORD *)(a1 + 32);
  uint64_t result = subscriber::simSlotAsInstance();
  a2[7] |= 4u;
  a2[5] = result;
  return result;
}

void sub_100944764(Registry **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  int v4 = a2;
  *a3 = 0;
  a3[1] = 0;
  sub_100944A14(a1, &v4, a3);
  sub_100BD1D80(*a3);
}

void sub_1009447B4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009447CC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[22];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = a1[21];
      if (v5)
      {
        uint64_t v6 = (std::__shared_weak_count *)a1[3];
        if (!v6 || (uint64_t v7 = a1[2], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v9 = v7;
        uint64_t v10 = v8;
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v5 + 16))(v5, &v9);
        if (v10) {
          sub_10004D2C8(v10);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100944878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_1009448A0(uint64_t a1)
{
  *(void *)a1 = off_101A1DA48;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)a1 = off_1019F9E38;
  uint64_t v3 = *(void **)(a1 + 136);
  if (v3)
  {
    *(void *)(a1 + 144) = v3;
    operator delete(v3);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  int v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  LinkQualityMetricModelInterface::~LinkQualityMetricModelInterface((LinkQualityMetricModelInterface *)a1);
}

void sub_100944950(uint64_t a1)
{
  *(void *)a1 = off_101A1DA48;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)a1 = off_1019F9E38;
  uint64_t v3 = *(void **)(a1 + 136);
  if (v3)
  {
    *(void *)(a1 + 144) = v3;
    operator delete(v3);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  int v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  LinkQualityMetricModelInterface::~LinkQualityMetricModelInterface((LinkQualityMetricModelInterface *)a1);

  operator delete();
}

void sub_100944A14(Registry **a1@<X1>, int *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0xD0uLL);
  sub_100944A90(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 5, (uint64_t)(v6 + 3));
}

void sub_100944A7C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100944A90(void *a1, Registry **a2, int *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A1DAE0;
  uint64_t v4 = (uint64_t)(a1 + 3);
  uint64_t v5 = "reg.lqm.data.???";
  int v6 = *a3;
  if (v6 == 2) {
    uint64_t v5 = "reg.lqm.data.2";
  }
  uint64_t v7 = "LinkQualityMetricModel.???";
  if (v6 == 2) {
    uint64_t v7 = "LinkQualityMetricModel.2";
  }
  if (v6 == 1) {
    int v8 = "reg.lqm.data.1";
  }
  else {
    int v8 = (char *)v5;
  }
  if (v6 == 1) {
    uint64_t v9 = "LinkQualityMetricModel.1";
  }
  else {
    uint64_t v9 = v7;
  }
  sub_1006C172C(v4, a2, v6, v8, (uint64_t)v9);
  a1[3] = off_101A1DA48;
  a1[24] = 0;
  a1[25] = 0;
  return a1;
}

void sub_100944B44(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100944B58(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A1DAE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100944B78(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1DAE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100944BCC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t getFileConfigurationKeyNameForType(int a1, unsigned int a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0E1C8, memory_order_acquire) & 1) == 0)
  {
    int v13 = a1;
    unsigned int v14 = a2;
    int v15 = __cxa_guard_acquire(&qword_101B0E1C8);
    a2 = v14;
    int v16 = v15;
    a1 = v13;
    if (v16)
    {
      long long v25 = unk_101A1DB70;
      long long v26 = unk_101A1DB80;
      long long v27 = unk_101A1DB90;
      long long v21 = unk_101A1DB30;
      long long v22 = unk_101A1DB40;
      long long v23 = unk_101A1DB50;
      long long v24 = unk_101A1DB60;
      sub_10094E5DC(&qword_101B0E1D8, (unsigned __int8 *)&v21, 7);
      __cxa_atexit((void (*)(void *))sub_100944F0C, &qword_101B0E1D8, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0E1C8);
      a2 = v14;
      a1 = v13;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0E1D0, memory_order_acquire) & 1) == 0)
  {
    int v17 = a1;
    unsigned int v18 = a2;
    int v19 = __cxa_guard_acquire(&qword_101B0E1D0);
    a2 = v18;
    int v20 = v19;
    a1 = v17;
    if (v20)
    {
      long long v25 = unk_101A1DBE0;
      long long v26 = unk_101A1DBF0;
      long long v27 = unk_101A1DC00;
      long long v21 = unk_101A1DBA0;
      long long v22 = unk_101A1DBB0;
      long long v23 = unk_101A1DBC0;
      long long v24 = unk_101A1DBD0;
      sub_10094E5DC(&qword_101B0E1F0, (unsigned __int8 *)&v21, 7);
      __cxa_atexit((void (*)(void *))sub_100944F0C, &qword_101B0E1F0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101B0E1D0);
      a2 = v18;
      a1 = v17;
    }
  }
  if (a1 == 2)
  {
    uint64_t v8 = qword_101B0E1F8;
    if (!qword_101B0E1F8) {
      return 0;
    }
    uint64_t v3 = &qword_101B0E1F8;
    uint64_t v4 = &qword_101B0E1F8;
    do
    {
      unsigned int v9 = *(unsigned __int8 *)(v8 + 32);
      BOOL v10 = v9 >= a2;
      if (v9 >= a2) {
        uint64_t v11 = (uint64_t *)v8;
      }
      else {
        uint64_t v11 = (uint64_t *)(v8 + 8);
      }
      if (v10) {
        uint64_t v4 = (uint64_t *)v8;
      }
      uint64_t v8 = *v11;
    }
    while (*v11);
  }
  else
  {
    if (a1 != 1) {
      return 0;
    }
    uint64_t v2 = qword_101B0E1E0;
    if (!qword_101B0E1E0) {
      return 0;
    }
    uint64_t v3 = &qword_101B0E1E0;
    uint64_t v4 = &qword_101B0E1E0;
    do
    {
      unsigned int v5 = *(unsigned __int8 *)(v2 + 32);
      BOOL v6 = v5 >= a2;
      if (v5 >= a2) {
        uint64_t v7 = (uint64_t *)v2;
      }
      else {
        uint64_t v7 = (uint64_t *)(v2 + 8);
      }
      if (v6) {
        uint64_t v4 = (uint64_t *)v2;
      }
      uint64_t v2 = *v7;
    }
    while (*v7);
  }
  if (v4 == v3 || *((unsigned __int8 *)v4 + 32) > a2) {
    return 0;
  }
  return v4[5];
}

void sub_100944EE4(_Unwind_Exception *a1)
{
}

uint64_t sub_100944F0C(uint64_t a1)
{
  return a1;
}

void sub_100944F38(void *a1)
{
  *a1 = &off_101A1DC20;
  operator new();
}

void sub_100944FE0()
{
}

void sub_100945004(void *a1)
{
  *a1 = &off_101A1DC20;
  operator new();
}

void sub_1009450A8()
{
}

void sub_1009450CC()
{
}

void sub_10094528C()
{
}

void sub_1009452B8(uint64_t a1)
{
  uint64_t v2 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asString(*(unsigned __int8 *)(a1 + 84));
    uint64_t v4 = asString();
    int v5 = *(unsigned __int8 *)(a1 + 85);
    int v9 = 136315650;
    uint64_t v10 = v3;
    if (v5) {
      BOOL v6 = "true";
    }
    else {
      BOOL v6 = "false";
    }
    __int16 v11 = 2080;
    uint64_t v12 = v4;
    __int16 v13 = 2080;
    unsigned int v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s Format: %s, OTA config: %s", (uint8_t *)&v9, 0x20u);
    uint64_t v2 = **(NSObject ***)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = asString(*(unsigned __int8 *)(a1 + 84));
    uint64_t v8 = *(void *)(a1 + 88);
    int v9 = 136315394;
    uint64_t v10 = v7;
    __int16 v11 = 2112;
    uint64_t v12 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s Config: %@", (uint8_t *)&v9, 0x16u);
  }
}

uint64_t sub_100945408(uint64_t a1)
{
  *(void *)a1 = &off_101A1DC20;
  sub_100057D78((const void **)(a1 + 88));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10094E754((void *)(a1 + 16));
  sub_100119D1C((ctu::OsLogLogger **)(a1 + 8), 0);
  return a1;
}

void sub_100945480(const void **a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  if (*(unsigned char *)(a2 + 85))
  {
    BOOL v6 = (uint64_t *)operator new(0x10uLL);
    int v29 = v6 + 2;
    int v30 = v6 + 2;
    uint64_t *v6 = @"OTAActivation";
    v6[1] = a3;
    std::string __p = v6;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v6 + 2, *(Registry **)(a2 + 64));
    uint64_t v8 = ServiceMap;
    if (v9 < 0)
    {
      uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    __int16 v31 = (const void *)v9;
    __int16 v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v31);
    if (v13)
    {
      uint64_t v15 = v13[3];
      unsigned int v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_16:
        (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, void **, void, void))(*(void *)v15 + 88))(&v27, v15, *(unsigned int *)(a2 + 80), 1, &__p, 0, 0);
        if (&v27 != a1)
        {
          __int16 v31 = *a1;
          *a1 = v27;
          long long v27 = 0;
          sub_1000577C4(&v31);
        }
        sub_1000577C4(&v27);
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        if (__p)
        {
          int v29 = __p;
          operator delete(__p);
        }
        return;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    unsigned int v14 = 0;
    char v16 = 1;
    goto LABEL_16;
  }
  int v17 = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(a2 + 85), *(Registry **)(a2 + 64));
  unsigned int v18 = v17;
  if (v19 < 0)
  {
    int v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v19 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(v17);
  std::string __p = (void *)v19;
  long long v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&__p);
  if (!v23)
  {
    uint64_t v25 = 0;
    goto LABEL_23;
  }
  uint64_t v25 = v23[3];
  long long v24 = (std::__shared_weak_count *)v23[4];
  if (!v24)
  {
LABEL_23:
    std::mutex::unlock(v18);
    long long v24 = 0;
    char v26 = 1;
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v18);
  atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v24);
  char v26 = 0;
LABEL_24:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, uint64_t, void, void))(*(void *)v25 + 80))(&v31, v25, *(unsigned int *)(a2 + 80), 1, a3, 0, 0);
  if (&v31 != a1)
  {
    std::string __p = (void *)*a1;
    *a1 = v31;
    __int16 v31 = 0;
    sub_1000577C4((const void **)&__p);
  }
  sub_1000577C4(&v31);
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
}

void sub_100945730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  sub_1000577C4(v12);
  _Unwind_Resume(a1);
}

void sub_100945790(Registry *this@<X1>, void *a2@<X0>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, this);
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v8;
  unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, &v16);
  if (!v12)
  {
    uint64_t v13 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    char v14 = 0;
    char v15 = 1;
    if (!v13) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v13 = v12[3];
  char v14 = (std::__shared_weak_count *)v12[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v15 = 0;
  if (v13) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t, void, const CFStringRef, const CFStringRef))(*(void *)v13 + 40))(v13, a3, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
LABEL_11:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (!v13) {
    *a2 = 0;
  }
}

void sub_1009458DC(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009458FC(uint64_t a1)
{
  sub_100945408(a1);

  operator delete();
}

uint64_t sub_100945934(uint64_t a1)
{
  *(void *)a1 = off_101A1E390;
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }

  return sub_100945408(a1);
}

void sub_100945998(uint64_t a1)
{
  sub_100945934(a1);

  operator delete();
}

void sub_1009459D4(uint64_t a1)
{
  sub_100945934(a1);

  operator delete();
}

void sub_100945A10(uint64_t a1)
{
  sub_100945934(a1);

  operator delete();
}

const void **sub_100945A48@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::string::value_type v137 = 0;
  int v135 = 0;
  char v136 = 0;
  int v132 = 0;
  size_t v133 = 0;
  uint64_t v134 = 0;
  v147.__r_.__value_.__r.__words[0] = (std::string::size_type)&v136;
  v147.__r_.__value_.__l.__size_ = (std::string::size_type)&v135;
  v147.__r_.__value_.__r.__words[2] = (std::string::size_type)&v132;
  char v148 = &v137;
  uint64_t v4 = (uint64_t *)capabilities::ct::supportsDERFileFormat((capabilities::ct *)a1);
  int v5 = *(Registry **)(a1 + 64);
  if (!v4)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v4, v5);
    unsigned int v18 = ServiceMap;
    std::string::size_type v20 = v19;
    if (v19 < 0)
    {
      uint64_t v21 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        std::string::size_type v20 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(ServiceMap);
    __dst.__r_.__value_.__r.__words[0] = v20;
    long long v24 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&__dst);
    if (v24)
    {
      uint64_t v26 = v24[3];
      uint64_t v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v25 = 0;
    char v27 = 1;
LABEL_31:
    (*(void (**)(std::string *__return_ptr, uint64_t, void))(*(void *)v26 + 128))(&v130, v26, *(unsigned int *)(a1 + 80));
    v145[0] = off_101A1DFF0;
    v145[1] = a1;
    v145[3] = v145;
    int v42 = sub_100946D58((uint64_t)&v147, @"PRIFileName", @"PriVersion", 1, &v130, (uint64_t)v145);
    sub_10094EC1C(v145);
    if (SHIBYTE(v130.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v130.__r_.__value_.__l.__data_);
      if (v27)
      {
LABEL_34:
        int v29 = **(NSObject ***)(a1 + 8);
        BOOL v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
        if (v42)
        {
          if (!v30) {
            goto LABEL_100;
          }
          LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
          int v32 = "#I Found XML PRI files in the Carrier Bundle";
          goto LABEL_99;
        }
        if (!v30) {
          goto LABEL_64;
        }
        uint64_t v44 = (std::mutex *)Registry::getServiceMap(v43, *(Registry **)(a1 + 64));
        __int16 v45 = v44;
        if (v19 < 0)
        {
          uint64_t v46 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v47 = 5381;
          do
          {
            uint64_t v19 = v47;
            unsigned int v48 = *v46++;
            uint64_t v47 = (33 * v47) ^ v48;
          }
          while (v48);
        }
        std::mutex::lock(v44);
        uint64_t v126 = v19;
        uint64_t v49 = sub_10004D37C(&v45[1].__m_.__sig, (unint64_t *)&v126);
        if (v49)
        {
          uint64_t v50 = v49[3];
          uint64_t v39 = (std::__shared_weak_count *)v49[4];
          if (v39)
          {
            atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v45);
            atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v39);
            char v41 = 0;
LABEL_56:
            (*(void (**)(std::string *__return_ptr, uint64_t, void))(*(void *)v50 + 128))(&__dst, v50, *(unsigned int *)(a1 + 80));
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              p_dst = &__dst;
            }
            else {
              p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)OsLogContext buf = 136446210;
            *(void *)&uint8_t buf[4] = p_dst;
            uint64_t v52 = "#N Did not find XML PRI files in the Carrier Bundle: %{public}s";
            goto LABEL_60;
          }
        }
        else
        {
          uint64_t v50 = 0;
        }
        std::mutex::unlock(v45);
        uint64_t v39 = 0;
        char v41 = 1;
        goto LABEL_56;
      }
    }
    else if (v27)
    {
      goto LABEL_34;
    }
    sub_10004D2C8(v25);
    goto LABEL_34;
  }
  BOOL v6 = (std::mutex *)Registry::getServiceMap(v4, v5);
  uint64_t v7 = v6;
  std::string::size_type v9 = v8;
  if (v8 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      std::string::size_type v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(v6);
  __dst.__r_.__value_.__r.__words[0] = v9;
  uint64_t v13 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&__dst);
  if (v13)
  {
    uint64_t v15 = v13[3];
    char v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v7);
  char v14 = 0;
  char v16 = 1;
LABEL_16:
  (*(void (**)(std::string *__return_ptr, uint64_t, void))(*(void *)v15 + 128))(&__p, v15, *(unsigned int *)(a1 + 80));
  v146[0] = off_101A1DFF0;
  v146[1] = a1;
  v146[3] = v146;
  int v28 = sub_100946D58((uint64_t)&v147, @"DerPriFileName", @"DerPriFileVersion", 2, &__p, (uint64_t)v146);
  sub_10094EC1C(v146);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v16) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if ((v16 & 1) == 0) {
LABEL_18:
  }
    sub_10004D2C8(v14);
LABEL_19:
  int v29 = **(NSObject ***)(a1 + 8);
  BOOL v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
  if (v28)
  {
    if (!v30) {
      goto LABEL_100;
    }
    LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
    int v32 = "#I Found DER PRI files in the Carrier Bundle";
    goto LABEL_99;
  }
  if (v30)
  {
    uint64_t v33 = (std::mutex *)Registry::getServiceMap(v31, *(Registry **)(a1 + 64));
    int v34 = v33;
    if (v8 < 0)
    {
      BOOL v35 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v36 = 5381;
      do
      {
        uint64_t v8 = v36;
        unsigned int v37 = *v35++;
        uint64_t v36 = (33 * v36) ^ v37;
      }
      while (v37);
    }
    std::mutex::lock(v33);
    uint64_t v126 = v8;
    uint64_t v38 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)&v126);
    if (v38)
    {
      uint64_t v40 = v38[3];
      uint64_t v39 = (std::__shared_weak_count *)v38[4];
      if (v39)
      {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v34);
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v39);
        char v41 = 0;
LABEL_50:
        (*(void (**)(std::string *__return_ptr, uint64_t, void))(*(void *)v40 + 128))(&__dst, v40, *(unsigned int *)(a1 + 80));
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v51 = &__dst;
        }
        else {
          char v51 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)OsLogContext buf = 136446210;
        *(void *)&uint8_t buf[4] = v51;
        uint64_t v52 = "#N Did not find DER PRI files in the Carrier Bundle: %{public}s";
LABEL_60:
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v52, buf, 0xCu);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if ((v41 & 1) == 0) {
          sub_10004D2C8(v39);
        }
        goto LABEL_64;
      }
    }
    else
    {
      uint64_t v40 = 0;
    }
    std::mutex::unlock(v34);
    uint64_t v39 = 0;
    char v41 = 1;
    goto LABEL_50;
  }
LABEL_64:
  uint64_t v54 = (uint64_t *)capabilities::ct::supportsDERFileFormat((capabilities::ct *)v30);
  uint64_t v55 = *(Registry **)(a1 + 64);
  if (v54)
  {
    uint64_t v56 = (std::mutex *)Registry::getServiceMap(v54, v55);
    uint64_t v57 = v56;
    if ((v58 & 0x8000000000000000) != 0)
    {
      uint64_t v59 = (unsigned __int8 *)(v58 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v60 = 5381;
      do
      {
        std::string::size_type v58 = v60;
        unsigned int v61 = *v59++;
        uint64_t v60 = (33 * v60) ^ v61;
      }
      while (v61);
    }
    std::mutex::lock(v56);
    __dst.__r_.__value_.__r.__words[0] = v58;
    BOOL v62 = sub_10004D37C(&v57[1].__m_.__sig, (unint64_t *)&__dst);
    if (v62)
    {
      uint64_t v64 = v62[3];
      uint64_t v63 = (std::__shared_weak_count *)v62[4];
      if (v63)
      {
        atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v57);
        atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v63);
        char v65 = 0;
        goto LABEL_79;
      }
    }
    else
    {
      uint64_t v64 = 0;
    }
    std::mutex::unlock(v57);
    uint64_t v63 = 0;
    char v65 = 1;
LABEL_79:
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v64 + 152))(&v129, v64);
    v144[0] = off_101A1E080;
    v144[1] = a1;
    v144[3] = v144;
    int v76 = sub_100946D58((uint64_t)&v147, @"DerPriFileName", @"DerPriFileVersion", 2, &v129, (uint64_t)v144);
    sub_10094EC1C(v144);
    if (SHIBYTE(v129.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v129.__r_.__value_.__l.__data_);
    }
    if ((v65 & 1) == 0) {
      sub_10004D2C8(v63);
    }
    int v29 = **(NSObject ***)(a1 + 8);
    BOOL v77 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
    if (v76)
    {
      if (!v77) {
        goto LABEL_100;
      }
      LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
      int v32 = "#I Found DER PRI files in the Default Bundle";
    }
    else
    {
      if (!v77) {
        goto LABEL_100;
      }
      LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
      int v32 = "#N Did not find DER PRI files in the Default Bundle";
    }
    goto LABEL_99;
  }
  uint64_t v66 = (std::mutex *)Registry::getServiceMap(v54, v55);
  uint64_t v67 = v66;
  if ((v68 & 0x8000000000000000) != 0)
  {
    uint64_t v69 = (unsigned __int8 *)(v68 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v70 = 5381;
    do
    {
      std::string::size_type v68 = v70;
      unsigned int v71 = *v69++;
      uint64_t v70 = (33 * v70) ^ v71;
    }
    while (v71);
  }
  std::mutex::lock(v66);
  __dst.__r_.__value_.__r.__words[0] = v68;
  char v72 = sub_10004D37C(&v67[1].__m_.__sig, (unint64_t *)&__dst);
  if (v72)
  {
    uint64_t v74 = v72[3];
    __int16 v73 = (std::__shared_weak_count *)v72[4];
    if (v73)
    {
      atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v67);
      atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v73);
      char v75 = 0;
      goto LABEL_90;
    }
  }
  else
  {
    uint64_t v74 = 0;
  }
  std::mutex::unlock(v67);
  __int16 v73 = 0;
  char v75 = 1;
LABEL_90:
  (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v74 + 152))(&v128, v74);
  v143[0] = off_101A1E080;
  v143[1] = a1;
  v143[3] = v143;
  int v78 = sub_100946D58((uint64_t)&v147, @"PRIFileName", @"PriVersion", 1, &v128, (uint64_t)v143);
  sub_10094EC1C(v143);
  if (SHIBYTE(v128.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v128.__r_.__value_.__l.__data_);
  }
  if ((v75 & 1) == 0) {
    sub_10004D2C8(v73);
  }
  int v29 = **(NSObject ***)(a1 + 8);
  BOOL v79 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
  if (v78)
  {
    if (!v79) {
      goto LABEL_100;
    }
    LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
    int v32 = "#I Found XML PRI files in the Default Bundle";
  }
  else
  {
    if (!v79) {
      goto LABEL_100;
    }
    LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
    int v32 = "#N Did not find XML PRI files in the Default Bundle";
  }
LABEL_99:
  _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v32, (uint8_t *)&__dst, 2u);
LABEL_100:
  if (v136) {
    CFStringRef v80 = sub_1000810B8;
  }
  else {
    CFStringRef v80 = 0;
  }
  if (v80)
  {
    if (v135 ? sub_1000810B8 : 0)
    {
      uint64_t v126 = 0;
      char v127 = 0;
      Registry::getFileSystemInterface(&v126, *(Registry **)(a1 + 64));
      memset(buf, 0, sizeof(buf));
      int64_t v142 = 0;
      if (v134 >= 0) {
        size_t v82 = HIBYTE(v134);
      }
      else {
        size_t v82 = v133;
      }
      memset(&v147, 0, sizeof(v147));
      BOOL v83 = &v147;
      sub_1000C140C((uint64_t)&v147, v82 + 1);
      if ((v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        BOOL v83 = (std::string *)v147.__r_.__value_.__r.__words[0];
      }
      if (v82)
      {
        if (v134 >= 0) {
          uint64_t v84 = &v132;
        }
        else {
          uint64_t v84 = v132;
        }
        memmove(v83, v84, v82);
      }
      *(_WORD *)((char *)&v83->__r_.__value_.__l.__data_ + v82) = 47;
      char v140 = v135;
      sub_1000292E0((uint64_t)&__dst);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        __int16 v85 = &__dst;
      }
      else {
        __int16 v85 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __dst.__r_.__value_.__l.__size_;
      }
      __int16 v87 = std::string::append(&v147, (const std::string::value_type *)v85, size);
      long long v88 = *(_OWORD *)&v87->__r_.__value_.__l.__data_;
      int64_t v142 = v87->__r_.__value_.__r.__words[2];
      *(_OWORD *)OsLogContext buf = v88;
      v87->__r_.__value_.__l.__size_ = 0;
      v87->__r_.__value_.__r.__words[2] = 0;
      v87->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v147.__r_.__value_.__l.__data_);
      }
      char v89 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v126 + 88))(v126, buf);
      xpc_object_t v90 = **(NSObject ***)(a1 + 8);
      BOOL v91 = os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT);
      if ((v89 & 1) == 0)
      {
        if (v91)
        {
          uint64_t v94 = buf;
          if (v142 < 0) {
            uint64_t v94 = *(uint8_t **)buf;
          }
          LODWORD(v147.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)v147.__r_.__value_.__r.__words + 4) = (std::string::size_type)v94;
          _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#N PRI file %{public}s does not exist", (uint8_t *)&v147, 0xCu);
        }
        goto LABEL_204;
      }
      if (v91)
      {
        char v140 = v135;
        sub_1000292E0((uint64_t)&v147);
        int v92 = (v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v147
            : (std::string *)v147.__r_.__value_.__r.__words[0];
        LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v92;
        _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#I PRI file name: %s", (uint8_t *)&__dst, 0xCu);
        if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v147.__r_.__value_.__l.__data_);
        }
      }
      xpc_object_t value = 0;
      (*(void (**)(std::string *__return_ptr))(*(void *)v126 + 136))(&v124);
      if (SHIBYTE(v124.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, v124.__r_.__value_.__l.__data_, v124.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = v124;
      }
      char v138 = 0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v147, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else {
        std::string v147 = __dst;
      }
      uint64_t v139 = 0;
      if (ctu::cf::convert_copy())
      {
        xpc_object_t v95 = v138;
        char v138 = v139;
        char v140 = v95;
        sub_1000558F4((const void **)&v140);
      }
      if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v147.__r_.__value_.__l.__data_);
      }
      xpc_object_t value = v138;
      char v138 = 0;
      sub_1000558F4((const void **)&v138);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v124.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v124.__r_.__value_.__l.__data_);
      }
      xpc_object_t v96 = **(NSObject ***)(a1 + 8);
      if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
      {
        char v140 = value;
        sub_1000292E0((uint64_t)&v147);
        xpc_object_t v98 = (v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v147
            : (std::string *)v147.__r_.__value_.__r.__words[0];
        LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v98;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "#I PRI file bundle directory: %{public}s", (uint8_t *)&__dst, 0xCu);
        xpc_object_t v97 = (uint64_t *)SHIBYTE(v147.__r_.__value_.__r.__words[2]);
        if ((v97 & 0x80000000) != 0) {
          operator delete(v147.__r_.__value_.__l.__data_);
        }
      }
      uint64_t v99 = (std::mutex *)Registry::getServiceMap(v97, *(Registry **)(a1 + 64));
      xpc_object_t v100 = v99;
      if ((v101 & 0x8000000000000000) != 0)
      {
        xpc_object_t v102 = (unsigned __int8 *)(v101 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v103 = 5381;
        do
        {
          std::string::size_type v101 = v103;
          unsigned int v104 = *v102++;
          uint64_t v103 = (33 * v103) ^ v104;
        }
        while (v104);
      }
      std::mutex::lock(v99);
      v147.__r_.__value_.__r.__words[0] = v101;
      uint64_t v105 = sub_10004D37C(&v100[1].__m_.__sig, (unint64_t *)&v147);
      if (v105)
      {
        uint64_t v107 = v105[3];
        xpc_object_t v106 = (std::__shared_weak_count *)v105[4];
        if (v106)
        {
          atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v100);
          atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v106);
          char v108 = 0;
LABEL_169:
          uint64_t v139 = 0;
          if (v134 >= 0) {
            uint64_t v109 = &v132;
          }
          else {
            uint64_t v109 = v132;
          }
          int v110 = (void *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v107 + 24))(v107, v109);
          uint64_t v139 = v110;
          long long v111 = **(NSObject ***)(a1 + 8);
          if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
          {
            char v140 = v110;
            sub_1000292E0((uint64_t)&v147);
            __int16 v112 = (v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                 ? &v147
                 : (std::string *)v147.__r_.__value_.__r.__words[0];
            LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
            *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v112;
            _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I PRI file bundle ID: %{public}s", (uint8_t *)&__dst, 0xCu);
            if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v147.__r_.__value_.__l.__data_);
            }
          }
          char v138 = 0;
          if (v134 >= 0) {
            uint64_t v113 = &v132;
          }
          else {
            uint64_t v113 = v132;
          }
          char v114 = (void *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v107 + 40))(v107, v113);
          char v138 = v114;
          uint64_t v115 = **(NSObject ***)(a1 + 8);
          if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
          {
            char v140 = v114;
            sub_1000292E0((uint64_t)&v147);
            char v116 = (v147.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                 ? &v147
                 : (std::string *)v147.__r_.__value_.__r.__words[0];
            LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
            *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v116;
            _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "#I PRI file bundle version: %{public}s", (uint8_t *)&__dst, 0xCu);
            if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v147.__r_.__value_.__l.__data_);
            }
          }
          __dst.__r_.__value_.__r.__words[0] = 0;
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (Mutable)
          {
            std::string::size_type v118 = __dst.__r_.__value_.__r.__words[0];
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
            v147.__r_.__value_.__r.__words[0] = v118;
            sub_10005717C((const void **)&v147.__r_.__value_.__l.__data_);
          }
          CFDictionarySetValue((CFMutableDictionaryRef)__dst.__r_.__value_.__l.__data_, @"kPRIBundleDir", value);
          CFDictionarySetValue((CFMutableDictionaryRef)__dst.__r_.__value_.__l.__data_, @"kPRIFileName", v135);
          CFDictionarySetValue((CFMutableDictionaryRef)__dst.__r_.__value_.__l.__data_, @"kPRIFileVersion", v136);
          if (v139) {
            unsigned int v119 = sub_1000810B8;
          }
          else {
            unsigned int v119 = 0;
          }
          if (v119) {
            CFDictionarySetValue((CFMutableDictionaryRef)__dst.__r_.__value_.__l.__data_, @"kPRIFileBundleID", v139);
          }
          if (v138) {
            char v120 = sub_1000810B8;
          }
          else {
            char v120 = 0;
          }
          if (v120) {
            CFDictionarySetValue((CFMutableDictionaryRef)__dst.__r_.__value_.__l.__data_, @"kPRIFileBundleVersion", v138);
          }
          char v121 = *(os_log_t **)(a1 + 8);
          sub_10004EFE4(&v123, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
          sub_100946E94(v121, (uint64_t)"PRI configuration", (const __CFDictionary **)&v123);
          sub_100057D78(&v123);
          v147.__r_.__value_.__r.__words[0] = __dst.__r_.__value_.__r.__words[0];
          if (__dst.__r_.__value_.__r.__words[0]) {
            CFRetain(__dst.__r_.__value_.__l.__data_);
          }
          v147.__r_.__value_.__s.__data_[8] = v137;
          sub_100946FE4((uint64_t)a2, (uint64_t)&v147);
          sub_10005717C((const void **)&v147.__r_.__value_.__l.__data_);
          sub_10005717C((const void **)&__dst.__r_.__value_.__l.__data_);
          sub_1000558F4((const void **)&v138);
          sub_1000558F4((const void **)&v139);
          if ((v108 & 1) == 0) {
            sub_10004D2C8(v106);
          }
          sub_1000558F4((const void **)&value);
LABEL_204:
          if (SHIBYTE(v142) < 0) {
            operator delete(*(void **)buf);
          }
          if (v127) {
            sub_10004D2C8(v127);
          }
          goto LABEL_208;
        }
      }
      else
      {
        uint64_t v107 = 0;
      }
      std::mutex::unlock(v100);
      xpc_object_t v106 = 0;
      char v108 = 1;
      goto LABEL_169;
    }
  }
  xpc_object_t v93 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v147.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#N No PRI available to send", (uint8_t *)&v147, 2u);
  }
LABEL_208:
  if (SHIBYTE(v134) < 0) {
    operator delete(v132);
  }
  sub_1000558F4((const void **)&v135);
  return sub_1000558F4((const void **)&v136);
}

void sub_100946AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,const void *a37,const void *a38,uint64_t a39,const void *a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  sub_1000558F4(&a40);
  if (*(char *)(v49 - 89) < 0) {
    operator delete(*(void **)(v49 - 112));
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  sub_1000558F4(&a37);
  sub_1000558F4(&a38);
  if (*(unsigned char *)(v48 + 16)) {
    sub_100057D78((const void **)v48);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100946D58(uint64_t a1, uint64_t a2, uint64_t a3, char a4, const std::string *a5, uint64_t a6)
{
  sub_10094E3F0((uint64_t)&v18, *(void *)(a6 + 24), a3);
  uint64_t v11 = *(const void ***)a1;
  if (*(const void ***)a1 != &v18)
  {
    unsigned int v12 = *v11;
    uint64_t *v11 = 0;
    uint64_t v19 = v12;
    uint64_t *v11 = v18;
    unsigned int v18 = 0;
    sub_1000558F4(&v19);
  }
  sub_1000558F4(&v18);
  sub_10094E3F0((uint64_t)&v18, *(void *)(a6 + 24), a2);
  uint64_t v13 = *(const void ***)(a1 + 8);
  if (v13 != &v18)
  {
    char v14 = *v13;
    *uint64_t v13 = 0;
    uint64_t v19 = v14;
    *uint64_t v13 = v18;
    unsigned int v18 = 0;
    sub_1000558F4(&v19);
  }
  sub_1000558F4(&v18);
  if (**(void **)a1) {
    uint64_t v15 = sub_1000810B8;
  }
  else {
    uint64_t v15 = 0;
  }
  if (!v15) {
    return 0;
  }
  if (!(**(void **)(a1 + 8) ? sub_1000810B8 : 0)) {
    return 0;
  }
  std::string::operator=(*(std::string **)(a1 + 16), a5);
  **(unsigned char **)(a1 + 24) = a4;
  return 1;
}

void sub_100946E94(os_log_t *a1, uint64_t a2, const __CFDictionary **a3)
{
  BOOL v6 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&buf, 0xCu);
  }
  CFDictionaryRef v7 = *a3;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_10094E44C;
  void v8[3] = &unk_101A1DF98;
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000;
  uint64_t v11 = sub_10094E518;
  unsigned int v12 = &unk_101A1DFC0;
  uint64_t v13 = v8;
  v8[4] = a1;
  context = &buf;
  CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)sub_10094E5C0, &context);
}

uint64_t sub_100946FE4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    sub_10004EFE4(&v6, (CFTypeRef *)a2);
    if (&v6 != (const void **)a1)
    {
      uint64_t v4 = *(const void **)a1;
      *(void *)a1 = v6;
      BOOL v6 = 0;
      CFDictionaryRef v7 = v4;
      sub_100057D78(&v7);
    }
    sub_100057D78(&v6);
    *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  }
  else
  {
    sub_10004EFE4((void *)a1, (CFTypeRef *)a2);
    *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void sub_100947084(uint64_t a1, uint64_t a2)
{
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPRIBundleDir");
  if (Value)
  {
    int v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFStringGetTypeID()) {
      CFDictionaryRef v7 = v5;
    }
    else {
      CFDictionaryRef v7 = 0;
    }
  }
  else
  {
    CFDictionaryRef v7 = 0;
  }
  uint64_t v36 = v7;
  uint64_t v8 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPRIFileName");
  if (v8)
  {
    std::string::size_type v9 = v8;
    CFTypeID v10 = CFGetTypeID(v8);
    if (v10 == CFStringGetTypeID()) {
      uint64_t v11 = v9;
    }
    else {
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  BOOL v35 = v11;
  unsigned int v12 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPRIFileVersion");
  if (v12)
  {
    uint64_t v13 = v12;
    CFTypeID v14 = CFGetTypeID(v12);
    if (v14 == CFStringGetTypeID()) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = 0;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  char v16 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPRIFileBundleID");
  if (v16)
  {
    int v17 = v16;
    CFTypeID v18 = CFGetTypeID(v16);
    if (v18 == CFStringGetTypeID()) {
      uint64_t v19 = v17;
    }
    else {
      uint64_t v19 = 0;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  int v34 = v19;
  std::string::size_type v20 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPRIFileBundleVersion");
  if (v20)
  {
    CFTypeID v21 = CFGetTypeID(v20);
    BOOL v22 = v21 == CFStringGetTypeID();
    if (!v7)
    {
LABEL_35:
      uint64_t v26 = **(NSObject ***)(a1 + 8);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I The contents of PRI file config dictionary is not correct", buf, 2u);
      }
      return;
    }
  }
  else
  {
    BOOL v22 = 0;
    if (!v7) {
      goto LABEL_35;
    }
  }
  if (!v11 || !v15 || !v19 || !v22) {
    goto LABEL_35;
  }
  *(void *)long long buf = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  sub_1000292E0((uint64_t)buf);
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v30 = 0;
  sub_1000292E0((uint64_t)v29);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v28 = 0;
  sub_1000292E0((uint64_t)__p);
  int v23 = *(_DWORD *)(a1 + 80);
  char v24 = *(unsigned char *)(a1 + 84);
  char v25 = *(unsigned char *)(a1 + 96);
  sub_1000DFC90((uint64_t)v37, a2);
  sub_100947370(*(void *)(a1 + 40), v23, v24, (uint64_t)buf, (uint64_t)v29, (uint64_t)__p, v25);
  sub_100060644(v37);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[0]);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_10094730C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100947370(uint64_t a1, int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  int v10 = a2;
  char v9 = a3;
  char v8 = a7;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *, char *, uint64_t, uint64_t, uint64_t, char *))(*(void *)a1 + 48))(a1, &v10, &v9, a4, a5, a6, &v8);
}

BOOL sub_1009473D0(uint64_t a1)
{
  char v33 = 0;
  uint64_t v2 = (const void **)(a1 + 88);
  if (*(void *)(a1 + 88)) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFTypeRef cf = 0;
    uint64_t FileConfigurationKeyNameForType = getFileConfigurationKeyNameForType(*(_DWORD *)(a1 + 80), *(unsigned __int8 *)(a1 + 84));
    sub_100945790(*(Registry **)(a1 + 64), buf, FileConfigurationKeyNameForType, v5);
    sub_10004EFE4(&cf, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (cf) {
      CFTypeID v6 = sub_100080778;
    }
    else {
      CFTypeID v6 = 0;
    }
    CFDictionaryRef v7 = *(os_log_t **)(a1 + 8);
    if (v6)
    {
      CFTypeRef v31 = cf;
      if (cf) {
        CFRetain(cf);
      }
      sub_100946E94(v7, (uint64_t)"Cached PRI file configuration", (const __CFDictionary **)&v31);
      sub_100057D78(&v31);
      char v8 = *(os_log_t **)(a1 + 8);
      sub_100058198(&v30, v2);
      sub_100946E94(v8, (uint64_t)"Intended PRI file configuration", (const __CFDictionary **)&v30);
      sub_100057D78(&v30);
      if (CFEqual(cf, *v2))
      {
        char v9 = **(NSObject ***)(a1 + 8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Cached PRI file configuration is same as the one intended to be pushed, bailing out", buf, 2u);
        }
        goto LABEL_40;
      }
      CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"kPRIFileBundleID");
      uint64_t v15 = CFDictionaryGetValue((CFDictionaryRef)*v2, @"kPRIFileBundleID");
      if (!Value || !v15 || CFEqual(Value, v15))
      {
        char v16 = **(NSObject ***)(a1 + 8);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Cached PRI file configuration is different than the one intended, checking the version number", buf, 2u);
        }
        v26[0] = 0;
        v26[1] = 0;
        CFDictionaryRef v17 = (const __CFDictionary *)cf;
        CFDictionaryRef theDict = (CFDictionaryRef)cf;
        if (cf)
        {
          CFRetain(cf);
          CFDictionaryRef v17 = theDict;
        }
        CFTypeID v18 = CFDictionaryGetValue(v17, @"kPRIFileVersion");
        if (v18 && (CFTypeID v19 = CFGetTypeID(v18), v19 == CFStringGetTypeID()))
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v35 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = *(_OWORD *)buf;
          uint64_t v29 = v35;
        }
        else
        {
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v29 = 0;
        }
        sub_1013BBA8C();
      }
      std::string::size_type v20 = **(NSObject ***)(a1 + 8);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v35 = 0;
        ctu::cf::assign();
        uint64_t v29 = v35;
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        int v21 = SHIBYTE(v35);
        BOOL v22 = *(void ***)buf;
        memset(buf, 0, sizeof(buf));
        uint64_t v35 = 0;
        ctu::cf::assign();
        int v23 = __p;
        if (v21 < 0) {
          int v23 = v22;
        }
        *(_OWORD *)uint64_t v26 = *(_OWORD *)buf;
        uint64_t v27 = v35;
        char v24 = v26;
        if (v35 < 0) {
          char v24 = *(void ***)buf;
        }
        int v36 = 136446466;
        *(void *)unsigned int v37 = v23;
        __int16 v38 = 2082;
        uint64_t v39 = v24;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I PRI bundle ID mismatch between cached (%{public}s) and intended (%{public}s)", (uint8_t *)&v36, 0x16u);
        if (SHIBYTE(v27) < 0) {
          operator delete(v26[0]);
        }
        if (SHIBYTE(v29) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      uint64_t v13 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#N No cached PRI file configuration", buf, 2u);
      }
    }
    char v33 = 1;
LABEL_40:
    sub_100057D78(&cf);
    return v33 != 0;
  }
  int v10 = **(NSObject ***)(a1 + 8);
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  BOOL result = 0;
  if (v11)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E No valid pri config?", buf, 2u);
    return 0;
  }
  return result;
}

void sub_100947ADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,const void *a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (v36 < 0) {
    operator delete(v35);
  }
  sub_100057D78(&a28);
  _Unwind_Resume(a1);
}

BOOL sub_100947BF8(unsigned char **a1, uint64_t a2, int a3, int a4)
{
  if (a3 != a4)
  {
    char v8 = **((void **)*a1 + 1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136315650;
      uint64_t v11 = a2;
      __int16 v12 = 1024;
      int v13 = a3;
      __int16 v14 = 1024;
      int v15 = a4;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N %s version mismatch between cache (%d) and bundle (%d)", (uint8_t *)&v10, 0x18u);
    }
    *a1[1] = 1;
  }
  return a3 == a4;
}

const void **sub_100947CE8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (uint64_t *)__stack_chk_guard;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  CFArrayRef theArray = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 64));
  CFTypeID v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    char v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      std::string::size_type v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  __dst.__r_.__value_.__r.__words[0] = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&__dst);
  if (v11)
  {
    uint64_t v13 = v11[3];
    __int16 v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  __int16 v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v13 + 80))(&buf, v13, *(unsigned int *)(a1 + 80), 1, @"EFSFiles", 0, 0);
  sub_100044D6C(&theArray, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&buf.__r_.__value_.__l.__data_);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (theArray) {
    int v15 = sub_100083F10;
  }
  else {
    int v15 = 0;
  }
  if (v15)
  {
    if (CFArrayGetCount(theArray))
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
      CFDictionaryRef v17 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeID v18 = CFGetTypeID(ValueAtIndex);
        if (v18 == CFDictionaryGetTypeID())
        {
          CFIndex Count = CFDictionaryGetCount(v17);
          keys = 0;
          xpc_object_t v86 = 0;
          uint64_t v87 = 0;
          __dst.__r_.__value_.__r.__words[0] = 0;
          sub_10039E2FC(&keys, Count, &__dst);
          values = 0;
          BOOL v83 = 0;
          uint64_t v84 = 0;
          __dst.__r_.__value_.__r.__words[0] = 0;
          sub_10039E2FC(&values, Count, &__dst);
          CFDictionaryGetKeysAndValues(v17, (const void **)keys, (const void **)values);
          std::string::size_type v20 = *keys;
          if (*keys)
          {
            CFTypeID v21 = CFGetTypeID(*keys);
            if (v21 == CFStringGetTypeID()) {
              BOOL v22 = v20;
            }
            else {
              BOOL v22 = 0;
            }
          }
          else
          {
            BOOL v22 = 0;
          }
          CFStringRef v81 = v22;
          int v23 = values;
          char v24 = *values;
          if (!*values)
          {
LABEL_123:
            BOOL v83 = v23;
            operator delete(v23);
LABEL_124:
            if (keys)
            {
              xpc_object_t v86 = keys;
              operator delete(keys);
            }
            return sub_100044D00((const void **)&theArray);
          }
          CFTypeID v25 = CFGetTypeID(*values);
          if (v25 != CFStringGetTypeID() || !v22)
          {
LABEL_122:
            int v23 = values;
            if (!values) {
              goto LABEL_124;
            }
            goto LABEL_123;
          }
          int v78 = 0;
          size_t v79 = 0;
          uint64_t v80 = 0;
          uint64_t v27 = (std::mutex *)Registry::getServiceMap(v26, *(Registry **)(a1 + 64));
          uint64_t v28 = v27;
          if ((v29 & 0x8000000000000000) != 0)
          {
            uint64_t v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v31 = 5381;
            do
            {
              std::string::size_type v29 = v31;
              unsigned int v32 = *v30++;
              uint64_t v31 = (33 * v31) ^ v32;
            }
            while (v32);
          }
          std::mutex::lock(v27);
          __dst.__r_.__value_.__r.__words[0] = v29;
          char v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)&__dst);
          if (v33)
          {
            uint64_t v35 = v33[3];
            int v34 = (std::__shared_weak_count *)v33[4];
            if (v34)
            {
              atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v28);
              atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v34);
              char v36 = 0;
              goto LABEL_34;
            }
          }
          else
          {
            uint64_t v35 = 0;
          }
          std::mutex::unlock(v28);
          int v34 = 0;
          char v36 = 1;
LABEL_34:
          (*(void (**)(void **__return_ptr, uint64_t, void))(*(void *)v35 + 128))(&v78, v35, *(unsigned int *)(a1 + 80));
          if ((v36 & 1) == 0) {
            sub_10004D2C8(v34);
          }
          v76[0] = 0;
          v76[1] = 0;
          int64_t v77 = 0;
          if (v80 >= 0) {
            size_t v37 = HIBYTE(v80);
          }
          else {
            size_t v37 = v79;
          }
          memset(&__dst, 0, sizeof(__dst));
          p_dst = &__dst;
          sub_1000C140C((uint64_t)&__dst, v37 + 1);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
          }
          if (v37)
          {
            if (v80 >= 0) {
              uint64_t v39 = &v78;
            }
            else {
              uint64_t v39 = v78;
            }
            memmove(p_dst, v39, v37);
          }
          *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v37) = 47;
          sub_1000292E0((uint64_t)&buf);
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_std::string buf = &buf;
          }
          else {
            p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = buf.__r_.__value_.__l.__size_;
          }
          int v42 = std::string::append(&__dst, (const std::string::value_type *)p_buf, size);
          long long v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
          int64_t v77 = v42->__r_.__value_.__r.__words[2];
          *(_OWORD *)int v76 = v43;
          v42->__r_.__value_.__l.__size_ = 0;
          v42->__r_.__value_.__r.__words[2] = 0;
          v42->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          uint64_t v74 = 0;
          char v75 = 0;
          Registry::getFileSystemInterface(&v74, *(Registry **)(a1 + 64));
          if (((*(uint64_t (**)(uint64_t, void **))(*(void *)v74 + 88))(v74, v76) & 1) == 0)
          {
            uint64_t v44 = **(NSObject ***)(a1 + 8);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v45 = v76;
              if (v77 < 0) {
                __int16 v45 = (void **)v76[0];
              }
              LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
              *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v45;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#N EFS file %{public}s does not exist", (uint8_t *)&__dst, 0xCu);
            }
            goto LABEL_116;
          }
          xpc_object_t value = 0;
          (*(void (**)(std::string *__return_ptr))(*(void *)v74 + 136))(&__p);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&buf, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
          else {
            std::string buf = __p;
          }
          char v89 = 0;
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__dst, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = buf;
          }
          xpc_object_t v90 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v46 = v89;
            char v89 = v90;
            BOOL v91 = v46;
            sub_1000558F4((const void **)&v91);
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          xpc_object_t value = v89;
          char v89 = 0;
          sub_1000558F4((const void **)&v89);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          uint64_t v47 = **(NSObject ***)(a1 + 8);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            BOOL v91 = value;
            sub_1000292E0((uint64_t)&__dst);
            uint64_t v49 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? &__dst
                : (std::string *)__dst.__r_.__value_.__r.__words[0];
            LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v49;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I EFS file bundle directory: %{public}s", (uint8_t *)&buf, 0xCu);
            uint64_t v48 = (uint64_t *)SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
            if ((v48 & 0x80000000) != 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
          }
          uint64_t v50 = (std::mutex *)Registry::getServiceMap(v48, *(Registry **)(a1 + 64));
          char v51 = v50;
          if ((v52 & 0x8000000000000000) != 0)
          {
            int v53 = (unsigned __int8 *)(v52 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v54 = 5381;
            do
            {
              std::string::size_type v52 = v54;
              unsigned int v55 = *v53++;
              uint64_t v54 = (33 * v54) ^ v55;
            }
            while (v55);
          }
          std::mutex::lock(v50);
          __dst.__r_.__value_.__r.__words[0] = v52;
          uint64_t v56 = sub_10004D37C(&v51[1].__m_.__sig, (unint64_t *)&__dst);
          if (v56)
          {
            uint64_t v58 = v56[3];
            uint64_t v57 = (std::__shared_weak_count *)v56[4];
            if (v57)
            {
              atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v51);
              atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v57);
              char v59 = 0;
LABEL_89:
              xpc_object_t v90 = 0;
              if (v80 >= 0) {
                uint64_t v60 = &v78;
              }
              else {
                uint64_t v60 = v78;
              }
              unsigned int v61 = (void *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v58 + 24))(v58, v60);
              xpc_object_t v90 = v61;
              BOOL v62 = **(NSObject ***)(a1 + 8);
              if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
              {
                BOOL v91 = v61;
                sub_1000292E0((uint64_t)&__dst);
                uint64_t v63 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                    ? &__dst
                    : (std::string *)__dst.__r_.__value_.__r.__words[0];
                LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v63;
                _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I EFS file bundle ID: %{public}s", (uint8_t *)&buf, 0xCu);
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__dst.__r_.__value_.__l.__data_);
                }
              }
              char v89 = 0;
              if (v80 >= 0) {
                uint64_t v64 = &v78;
              }
              else {
                uint64_t v64 = v78;
              }
              char v65 = (void *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v58 + 40))(v58, v64);
              char v89 = v65;
              uint64_t v66 = **(NSObject ***)(a1 + 8);
              if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
              {
                BOOL v91 = v65;
                sub_1000292E0((uint64_t)&__dst);
                uint64_t v67 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                    ? &__dst
                    : (std::string *)__dst.__r_.__value_.__r.__words[0];
                LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v67;
                _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I EFS file bundle version: %{public}s", (uint8_t *)&buf, 0xCu);
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__dst.__r_.__value_.__l.__data_);
                }
              }
              buf.__r_.__value_.__r.__words[0] = 0;
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (Mutable)
              {
                std::string::size_type v69 = buf.__r_.__value_.__r.__words[0];
                buf.__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
                __dst.__r_.__value_.__r.__words[0] = v69;
                sub_10005717C((const void **)&__dst.__r_.__value_.__l.__data_);
              }
              CFDictionarySetValue((CFMutableDictionaryRef)buf.__r_.__value_.__l.__data_, @"kEFSBundleDir", value);
              CFDictionarySetValue((CFMutableDictionaryRef)buf.__r_.__value_.__l.__data_, @"kEFSFileName", v81);
              CFDictionarySetValue((CFMutableDictionaryRef)buf.__r_.__value_.__l.__data_, @"kEFSFilePath", v24);
              CFDictionarySetValue((CFMutableDictionaryRef)buf.__r_.__value_.__l.__data_, @"kEFSFileBundleID", v90);
              CFDictionarySetValue((CFMutableDictionaryRef)buf.__r_.__value_.__l.__data_, @"kEFSFileBundleVersion", v89);
              uint64_t v70 = **(NSObject ***)(a1 + 8);
              if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(__dst.__r_.__value_.__l.__data_) = 138543362;
                *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = buf.__r_.__value_.__r.__words[0];
                _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I EFS configuration: %{public}@", (uint8_t *)&__dst, 0xCu);
              }
              __dst.__r_.__value_.__r.__words[0] = buf.__r_.__value_.__r.__words[0];
              if (buf.__r_.__value_.__r.__words[0]) {
                CFRetain(buf.__r_.__value_.__l.__data_);
              }
              __dst.__r_.__value_.__s.__data_[8] = 0;
              sub_100946FE4((uint64_t)a2, (uint64_t)&__dst);
              sub_10005717C((const void **)&__dst.__r_.__value_.__l.__data_);
              sub_10005717C((const void **)&buf.__r_.__value_.__l.__data_);
              sub_1000558F4((const void **)&v89);
              sub_1000558F4((const void **)&v90);
              if ((v59 & 1) == 0) {
                sub_10004D2C8(v57);
              }
              sub_1000558F4((const void **)&value);
LABEL_116:
              if (v75) {
                sub_10004D2C8(v75);
              }
              if (SHIBYTE(v77) < 0) {
                operator delete(v76[0]);
              }
              if (SHIBYTE(v80) < 0) {
                operator delete(v78);
              }
              goto LABEL_122;
            }
          }
          else
          {
            uint64_t v58 = 0;
          }
          std::mutex::unlock(v51);
          uint64_t v57 = 0;
          char v59 = 1;
          goto LABEL_89;
        }
      }
    }
  }
  return sub_100044D00((const void **)&theArray);
}

void sub_100948714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,const void *a38,const void *a39,__int16 a40,char a41,char a42)
{
  sub_1000558F4(&a39);
  if (*(char *)(v43 - 137) < 0) {
    operator delete(*(void **)(v43 - 160));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a32) {
    operator delete(a32);
  }
  if (a35) {
    operator delete(a35);
  }
  sub_100044D00(&a38);
  if (*(unsigned char *)(v42 + 16)) {
    sub_100057D78((const void **)v42);
  }
  _Unwind_Resume(a1);
}

void sub_100948910(uint64_t a1, uint64_t a2)
{
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kEFSBundleDir");
  if (Value)
  {
    int v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFStringGetTypeID()) {
      std::string::size_type v7 = v5;
    }
    else {
      std::string::size_type v7 = 0;
    }
  }
  else
  {
    std::string::size_type v7 = 0;
  }
  uint64_t v35 = v7;
  char v8 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kEFSFileName");
  if (v8)
  {
    uint64_t v9 = v8;
    CFTypeID v10 = CFGetTypeID(v8);
    if (v10 == CFStringGetTypeID()) {
      uint64_t v11 = v9;
    }
    else {
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  int v34 = v11;
  __int16 v12 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kEFSFilePath");
  if (v12)
  {
    uint64_t v13 = v12;
    CFTypeID v14 = CFGetTypeID(v12);
    if (v14 == CFStringGetTypeID()) {
      int v15 = v13;
    }
    else {
      int v15 = 0;
    }
  }
  else
  {
    int v15 = 0;
  }
  char v33 = v15;
  char v16 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kEFSFileBundleID");
  if (v16)
  {
    CFDictionaryRef v17 = v16;
    CFTypeID v18 = CFGetTypeID(v16);
    if (v18 == CFStringGetTypeID()) {
      CFTypeID v19 = v17;
    }
    else {
      CFTypeID v19 = 0;
    }
  }
  else
  {
    CFTypeID v19 = 0;
  }
  std::string::size_type v20 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kEFSFileBundleVersion");
  if (v20)
  {
    CFTypeID v21 = CFGetTypeID(v20);
    BOOL v22 = v21 == CFStringGetTypeID();
    if (!v7)
    {
LABEL_35:
      CFTypeID v25 = **(NSObject ***)(a1 + 8);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I The contents of EFS file config dictionary is not correct", buf, 2u);
      }
      return;
    }
  }
  else
  {
    BOOL v22 = 0;
    if (!v7) {
      goto LABEL_35;
    }
  }
  if (!v11 || !v15 || !v19 || !v22) {
    goto LABEL_35;
  }
  *(void *)std::string buf = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  sub_1000292E0((uint64_t)buf);
  v28[0] = 0;
  v28[1] = 0;
  uint64_t v29 = 0;
  sub_1000292E0((uint64_t)v28);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v27 = 0;
  sub_1000292E0((uint64_t)__p);
  int v23 = *(_DWORD *)(a1 + 80);
  char v24 = *(unsigned char *)(a1 + 96);
  sub_1000DFC90((uint64_t)v36, a2);
  sub_100947370(*(void *)(a1 + 40), v23, 5, (uint64_t)buf, (uint64_t)v28, (uint64_t)__p, v24);
  sub_100060644(v36);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100948B94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100948BF8(uint64_t a1)
{
  if (*(void *)(a1 + 88)) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    CFTypeID v18 = 0;
    uint64_t FileConfigurationKeyNameForType = getFileConfigurationKeyNameForType(*(_DWORD *)(a1 + 80), *(unsigned __int8 *)(a1 + 84));
    sub_100945790(*(Registry **)(a1 + 64), buf, FileConfigurationKeyNameForType, v4);
    sub_10004EFE4(&v18, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    int v5 = v18;
    if (v18) {
      CFTypeID v6 = sub_100080778;
    }
    else {
      CFTypeID v6 = 0;
    }
    std::string::size_type v7 = **(NSObject ***)(a1 + 8);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v8)
      {
        uint64_t v9 = *(void *)(a1 + 88);
        *(_DWORD *)std::string buf = 138412546;
        std::string::size_type v20 = v5;
        __int16 v21 = 2112;
        uint64_t v22 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Cached EFS file configuration %@, intended %@", buf, 0x16u);
        int v5 = v18;
      }
      int v10 = CFEqual(v5, *(CFTypeRef *)(a1 + 88));
      uint64_t v11 = **(NSObject ***)(a1 + 8);
      BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
      if (v10)
      {
        if (v12)
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Cached EFS file configuration is same as the one intended to be pushed, bailing out", buf, 2u);
        }
        uint64_t v13 = 0;
        goto LABEL_23;
      }
      if (v12)
      {
        *(_WORD *)std::string buf = 0;
        int v15 = "#I Cached EFS file configuration is different than the one intended, checking the version number";
        char v16 = v11;
        goto LABEL_21;
      }
    }
    else if (v8)
    {
      *(_WORD *)std::string buf = 0;
      int v15 = "#I No cached EFS file configuration";
      char v16 = v7;
LABEL_21:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, 2u);
    }
    uint64_t v13 = 1;
LABEL_23:
    sub_100057D78(&v18);
    return v13;
  }
  CFTypeID v14 = **(NSObject ***)(a1 + 8);
  uint64_t v13 = 0;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I No valid efs config?", buf, 2u);
    return 0;
  }
  return v13;
}

void sub_100948E30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100948E5C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  CFMutableDictionaryRef theDict = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v5 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v5;
    sub_10005717C((const void **)&__dst.__r_.__value_.__l.__data_);
  }
  int64_t v77 = 0;
  sub_100945480((const void **)&__dst.__r_.__value_.__l.__data_, a1, @"PRLFileName");
  sub_100056248(&v77, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&__dst.__r_.__value_.__l.__data_);
  CFTypeID v6 = v77;
  if (v77) {
    std::string::size_type v7 = sub_1000810B8;
  }
  else {
    std::string::size_type v7 = 0;
  }
  BOOL v8 = **(NSObject ***)(a1 + 8);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v9)
    {
      uint64_t v74 = v6;
      sub_1000292E0((uint64_t)&__dst);
      uint64_t v11 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__dst
          : (std::string *)__dst.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I PRL file in carrier bundle: %{public}s", (uint8_t *)&buf, 0xCu);
      int v10 = (uint64_t *)SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
      if ((v10 & 0x80000000) != 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v74 = 0;
    size_t v75 = 0;
    uint64_t v76 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 64));
    uint64_t v13 = ServiceMap;
    if ((v14 & 0x8000000000000000) != 0)
    {
      int v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        std::string::size_type v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    __dst.__r_.__value_.__r.__words[0] = v14;
    CFTypeID v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&__dst);
    if (v18)
    {
      uint64_t v20 = v18[3];
      CFTypeID v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    CFTypeID v19 = 0;
    char v21 = 1;
LABEL_23:
    (*(void (**)(void **__return_ptr, uint64_t, void))(*(void *)v20 + 128))(&v74, v20, *(unsigned int *)(a1 + 80));
    if ((v21 & 1) == 0) {
      sub_10004D2C8(v19);
    }
    v72[0] = 0;
    v72[1] = 0;
    int64_t v73 = 0;
    if (v76 >= 0) {
      size_t v22 = HIBYTE(v76);
    }
    else {
      size_t v22 = v75;
    }
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    sub_1000C140C((uint64_t)&__dst, v22 + 1);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    if (v22)
    {
      if (v76 >= 0) {
        char v24 = &v74;
      }
      else {
        char v24 = v74;
      }
      memmove(p_dst, v24, v22);
    }
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v22) = 47;
    uint64_t v70 = v77;
    sub_1000292E0((uint64_t)&buf);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string buf = &buf;
    }
    else {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = buf.__r_.__value_.__l.__size_;
    }
    uint64_t v27 = std::string::append(&__dst, (const std::string::value_type *)p_buf, size);
    long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
    int64_t v73 = v27->__r_.__value_.__r.__words[2];
    *(_OWORD *)char v72 = v28;
    v27->__r_.__value_.__l.__size_ = 0;
    v27->__r_.__value_.__r.__words[2] = 0;
    v27->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    uint64_t v70 = 0;
    unsigned int v71 = 0;
    Registry::getFileSystemInterface((uint64_t *)&v70, *(Registry **)(a1 + 64));
    if (((*(uint64_t (**)(const void *, void **))(*(void *)v70 + 88))(v70, v72) & 1) == 0)
    {
      uint64_t v31 = **(NSObject ***)(a1 + 8);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v32 = v72;
        if (v73 < 0) {
          uint64_t v32 = (void **)v72[0];
        }
        LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#N PRL file %{public}s does not exist", (uint8_t *)&__dst, 0xCu);
      }
      goto LABEL_141;
    }
    CFDictionarySetValue(theDict, @"kPRLFileName", v77);
    uint64_t v29 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v81 = v77;
      sub_1000292E0((uint64_t)&__dst);
      uint64_t v30 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__dst
          : (std::string *)__dst.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I PRL file name: %{public}s", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    xpc_object_t value = 0;
    (*(void (**)(std::string *__return_ptr))(*(void *)v70 + 136))(&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = __p;
    }
    size_t v79 = 0;
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = buf;
    }
    uint64_t v80 = 0;
    if (ctu::cf::convert_copy())
    {
      char v33 = v79;
      size_t v79 = v80;
      CFStringRef v81 = v33;
      sub_1000558F4((const void **)&v81);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    xpc_object_t value = v79;
    size_t v79 = 0;
    sub_1000558F4((const void **)&v79);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    int v34 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v81 = value;
      sub_1000292E0((uint64_t)&__dst);
      uint64_t v35 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__dst
          : (std::string *)__dst.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v35;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I PRL file bundle directory: %{public}s", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    CFDictionarySetValue(theDict, @"kPRLBundleDir", value);
    size_t v37 = (std::mutex *)Registry::getServiceMap(v36, *(Registry **)(a1 + 64));
    __int16 v38 = v37;
    if ((v39 & 0x8000000000000000) != 0)
    {
      uint64_t v40 = (unsigned __int8 *)(v39 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v41 = 5381;
      do
      {
        std::string::size_type v39 = v41;
        unsigned int v42 = *v40++;
        uint64_t v41 = (33 * v41) ^ v42;
      }
      while (v42);
    }
    std::mutex::lock(v37);
    __dst.__r_.__value_.__r.__words[0] = v39;
    uint64_t v43 = sub_10004D37C(&v38[1].__m_.__sig, (unint64_t *)&__dst);
    if (v43)
    {
      uint64_t v45 = v43[3];
      uint64_t v44 = (std::__shared_weak_count *)v43[4];
      if (v44)
      {
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v38);
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v44);
        char v46 = 0;
        goto LABEL_84;
      }
    }
    else
    {
      uint64_t v45 = 0;
    }
    std::mutex::unlock(v38);
    uint64_t v44 = 0;
    char v46 = 1;
LABEL_84:
    uint64_t v67 = 0;
    if (v76 >= 0) {
      uint64_t v47 = &v74;
    }
    else {
      uint64_t v47 = v74;
    }
    uint64_t v48 = (const void *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v45 + 24))(v45, v47);
    uint64_t v67 = v48;
    uint64_t v49 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v81 = (void *)v48;
      sub_1000292E0((uint64_t)&__dst);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v50 = &__dst;
      }
      else {
        uint64_t v50 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v50;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I PRL file bundle ID: %{public}s", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      uint64_t v48 = v67;
    }
    CFDictionarySetValue(theDict, @"kPRLFileBundleID", v48);
    uint64_t v66 = 0;
    if (v76 >= 0) {
      char v51 = &v74;
    }
    else {
      char v51 = v74;
    }
    std::string::size_type v52 = (const void *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v45 + 40))(v45, v51);
    uint64_t v66 = v52;
    int v53 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v81 = (void *)v52;
      sub_1000292E0((uint64_t)&__dst);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v54 = &__dst;
      }
      else {
        uint64_t v54 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v54;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I PRL file bundle version: %{public}s", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      std::string::size_type v52 = v66;
    }
    CFDictionarySetValue(theDict, @"kPRLFileBundleVersion", v52);
    char v65 = 0;
    sub_100945480((const void **)&__dst.__r_.__value_.__l.__data_, a1, @"PrlName");
    sub_1000842D0(&v65, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
    sub_1000577C4((const void **)&__dst.__r_.__value_.__l.__data_);
    if (v65) {
      unsigned int v55 = sub_100081E58;
    }
    else {
      unsigned int v55 = 0;
    }
    if (v55) {
      CFDictionarySetValue(theDict, @"kPRLFileVersion", v65);
    }
    uint64_t v64 = 0;
    sub_100945480((const void **)&__dst.__r_.__value_.__l.__data_, a1, @"PrlPushFlag");
    sub_1000057AC(&v64, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
    sub_1000577C4((const void **)&__dst.__r_.__value_.__l.__data_);
    if (v64) {
      uint64_t v56 = sub_100084B4C;
    }
    else {
      uint64_t v56 = 0;
    }
    if (v56) {
      CFDictionarySetValue(theDict, @"kPRLMandatoryPushFlag", v64);
    }
    uint64_t v57 = (void **)(a1 + 104);
    if (*(char *)(a1 + 127) < 0)
    {
      unint64_t v58 = *(void *)(a1 + 112);
      if (v58)
      {
        uint64_t v63 = 0;
        sub_10004FC84(&v62, *v57, v58);
        goto LABEL_119;
      }
    }
    else if (*(unsigned char *)(a1 + 127))
    {
      *(_OWORD *)&v62.__r_.__value_.__l.__data_ = *(_OWORD *)v57;
      v62.__r_.__value_.__r.__words[2] = *(void *)(a1 + 120);
      uint64_t v63 = 0;
LABEL_119:
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&buf, v62.__r_.__value_.__l.__data_, v62.__r_.__value_.__l.__size_);
      }
      else {
        std::string buf = v62;
      }
      size_t v79 = 0;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = buf;
      }
      uint64_t v80 = 0;
      if (ctu::cf::convert_copy())
      {
        char v59 = v79;
        size_t v79 = v80;
        CFStringRef v81 = v59;
        sub_1000558F4((const void **)&v81);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      uint64_t v63 = v79;
      size_t v79 = 0;
      sub_1000558F4((const void **)&v79);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v62.__r_.__value_.__l.__data_);
      }
      CFDictionarySetValue(theDict, @"kPushFilePath", v63);
      sub_1000558F4((const void **)&v63);
    }
    uint64_t v60 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(__dst.__r_.__value_.__l.__data_) = 138543362;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)theDict;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I PRL configuration: %{public}@", (uint8_t *)&__dst, 0xCu);
    }
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)theDict;
    if (theDict) {
      CFRetain(theDict);
    }
    __dst.__r_.__value_.__s.__data_[8] = 0;
    sub_100946FE4((uint64_t)a2, (uint64_t)&__dst);
    sub_10005717C((const void **)&__dst.__r_.__value_.__l.__data_);
    sub_100062778((const void **)&v64);
    sub_1000570E8((const void **)&v65);
    sub_1000558F4(&v66);
    sub_1000558F4(&v67);
    if ((v46 & 1) == 0) {
      sub_10004D2C8(v44);
    }
    sub_1000558F4((const void **)&value);
LABEL_141:
    if (v71) {
      sub_10004D2C8(v71);
    }
    if (SHIBYTE(v73) < 0) {
      operator delete(v72[0]);
    }
    if (SHIBYTE(v76) < 0) {
      operator delete(v74);
    }
    goto LABEL_147;
  }
  if (v9)
  {
    LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I No PRL file in the carrier bundle", (uint8_t *)&__dst, 2u);
  }
LABEL_147:
  sub_1000558F4((const void **)&v77);
  return sub_10005717C((const void **)&theDict);
}

void sub_1009499CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, const void *a19, const void *a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,const void *a27,uint64_t a28,std::__shared_weak_count *a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,const void *a43,const void *a44)
{
  sub_1000558F4((const void **)(v47 - 168));
  if (*(char *)(v47 - 121) < 0) {
    operator delete(*(void **)(v47 - 144));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100062778(&a17);
  sub_1000570E8(&a18);
  sub_1000558F4(&a19);
  sub_1000558F4(&a20);
  if ((v46 & 1) == 0) {
    sub_10004D2C8(v45);
  }
  sub_1000558F4(&a27);
  if (a29) {
    sub_10004D2C8(a29);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  sub_1000558F4(&a43);
  sub_10005717C(&a44);
  if (*(unsigned char *)(v44 + 16)) {
    sub_100057D78((const void **)v44);
  }
  _Unwind_Resume(a1);
}

void sub_100949C24(uint64_t a1, uint64_t a2)
{
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPushFilePath");
  if (Value && (CFMutableDictionaryRef v5 = Value, v6 = CFGetTypeID(Value), v6 == CFStringGetTypeID()))
  {
    v36[0] = &off_101A0BD40;
    v36[1] = v5;
    *(void *)std::string buf = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    sub_1000292E0((uint64_t)&__p);
    sub_1007ED5A8((uint64_t)&__p, buf);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p);
    }
    std::string __p = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    sub_1000292E0((uint64_t)&v27);
    sub_1007ED50C((uint64_t)&v27, &__p);
    if (SHIBYTE(v29) < 0) {
      operator delete(v27);
    }
    int v7 = *(_DWORD *)(a1 + 80);
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    char v8 = *(unsigned char *)(a1 + 96);
    sub_1000DFC90((uint64_t)v38, a2);
    sub_100947370(*(void *)(a1 + 40), v7, 2, (uint64_t)buf, (uint64_t)&__p, (uint64_t)&v27, v8);
    sub_100060644(v38);
    if (SHIBYTE(v29) < 0) {
      operator delete(v27);
    }
    if (SHIBYTE(v32) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(*(void **)buf);
    }
    FileSystemInterface::~FileSystemInterface((FileSystemInterface *)v36);
  }
  else
  {
    BOOL v9 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPRLBundleDir");
    if (v9)
    {
      int v10 = v9;
      CFTypeID v11 = CFGetTypeID(v9);
      if (v11 == CFStringGetTypeID()) {
        BOOL v12 = v10;
      }
      else {
        BOOL v12 = 0;
      }
    }
    else
    {
      BOOL v12 = 0;
    }
    v36[0] = v12;
    uint64_t v13 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPRLFileName");
    if (v13)
    {
      std::string::size_type v14 = v13;
      CFTypeID v15 = CFGetTypeID(v13);
      if (v15 == CFStringGetTypeID()) {
        uint64_t v16 = v14;
      }
      else {
        uint64_t v16 = 0;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    unsigned int v17 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPRLFileBundleID");
    if (v17)
    {
      CFTypeID v18 = v17;
      CFTypeID v19 = CFGetTypeID(v17);
      if (v19 == CFStringGetTypeID()) {
        uint64_t v20 = v18;
      }
      else {
        uint64_t v20 = 0;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    char v21 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPRLFileBundleVersion");
    if (v21 && (CFTypeID v22 = CFGetTypeID(v21), TypeID = CFStringGetTypeID(), v12) && v16 && v20 && v22 == TypeID)
    {
      *(void *)std::string buf = 0;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      sub_1000292E0((uint64_t)buf);
      std::string __p = 0;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      sub_1000292E0((uint64_t)&__p);
      int v24 = *(_DWORD *)(a1 + 80);
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      char v25 = *(unsigned char *)(a1 + 96);
      sub_1000DFC90((uint64_t)v37, a2);
      sub_100947370(*(void *)(a1 + 40), v24, 2, (uint64_t)buf, (uint64_t)&__p, (uint64_t)&v27, v25);
      sub_100060644(v37);
      if (SHIBYTE(v29) < 0) {
        operator delete(v27);
      }
      if (SHIBYTE(v32) < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v35) < 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      uint64_t v26 = **(NSObject ***)(a1 + 8);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I The contents of PRL file config dictionary is not correct", buf, 2u);
      }
    }
  }
}

void sub_100949F80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10094A064(uint64_t a1)
{
  if (*(void *)(a1 + 88)) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    char v25 = 0;
    uint64_t FileConfigurationKeyNameForType = getFileConfigurationKeyNameForType(*(_DWORD *)(a1 + 80), *(unsigned __int8 *)(a1 + 84));
    sub_100945790(*(Registry **)(a1 + 64), buf, FileConfigurationKeyNameForType, v4);
    sub_10004EFE4(&v25, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    CFMutableDictionaryRef v5 = v25;
    if (v25) {
      CFTypeID v6 = sub_100080778;
    }
    else {
      CFTypeID v6 = 0;
    }
    int v7 = **(NSObject ***)(a1 + 8);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v8)
      {
        uint64_t v9 = *(void *)(a1 + 88);
        *(_DWORD *)std::string buf = 138412546;
        uint64_t v27 = v5;
        __int16 v28 = 2112;
        uint64_t v29 = v9;
        int v10 = "#I Cached PRL file configuration %@, intended %@";
        CFTypeID v11 = v7;
        uint32_t v12 = 22;
LABEL_15:
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
      }
    }
    else if (v8)
    {
      *(_WORD *)std::string buf = 0;
      int v10 = "#I No cached PRL file configuration";
      CFTypeID v11 = v7;
      uint32_t v12 = 2;
      goto LABEL_15;
    }
    CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPRLMandatoryPushFlag");
    uint64_t v16 = Value;
    if (Value && (CFTypeID v17 = CFGetTypeID(Value), v17 == CFBooleanGetTypeID()))
    {
      int v18 = CFEqual(v16, kCFBooleanFalse);
      CFTypeID v19 = **(NSObject ***)(a1 + 8);
      BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
      if (!v18)
      {
        if (v20)
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Mandatory PRL push flag is true, pushing PRL", buf, 2u);
        }
        uint64_t v14 = 1;
        goto LABEL_25;
      }
      if (!v20) {
        goto LABEL_24;
      }
      *(_WORD *)std::string buf = 0;
      char v21 = "#I Mandatory PRL push flag is false, not pushing PRL";
      CFTypeID v22 = v19;
    }
    else
    {
      int v23 = **(NSObject ***)(a1 + 8);
      uint64_t v14 = 0;
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
LABEL_25:
        sub_100057D78(&v25);
        return v14;
      }
      *(_WORD *)std::string buf = 0;
      char v21 = "#I Did not find mandatory PRL push flag in bundle, not pushing PRL";
      CFTypeID v22 = v23;
    }
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v21, buf, 2u);
LABEL_24:
    uint64_t v14 = 0;
    goto LABEL_25;
  }
  uint64_t v13 = **(NSObject ***)(a1 + 8);
  uint64_t v14 = 0;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I No valid PRL config?", buf, 2u);
    return 0;
  }
  return v14;
}

void sub_10094A314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_10094A340@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v66 = 0;
  sub_100945480((const void **)&__dst.__r_.__value_.__l.__data_, a1, @"DMUFileName");
  sub_100056248(&v66, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&__dst.__r_.__value_.__l.__data_);
  memset(&__p, 0, sizeof(__p));
  uint64_t v4 = v66;
  if (v66) {
    CFMutableDictionaryRef v5 = sub_1000810B8;
  }
  else {
    CFMutableDictionaryRef v5 = 0;
  }
  CFTypeID v6 = **(NSObject ***)(a1 + 8);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      v63[0] = v4;
      sub_1000292E0((uint64_t)&__dst);
      uint64_t v9 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &__dst
         : (std::string *)__dst.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I DMU file in carrier bundle: %{public}s", (uint8_t *)&buf, 0xCu);
      BOOL v8 = (uint64_t *)SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
      if ((v8 & 0x80000000) != 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(a1 + 64));
    CFTypeID v11 = ServiceMap;
    if ((v12 & 0x8000000000000000) != 0)
    {
      uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        std::string::size_type v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    buf.__r_.__value_.__r.__words[0] = v12;
    uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&buf);
    if (v16)
    {
      uint64_t v18 = v16[3];
      CFTypeID v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    CFTypeID v17 = 0;
    char v19 = 1;
LABEL_22:
    (*(void (**)(std::string *__return_ptr, uint64_t, void))(*(void *)v18 + 128))(&__dst, v18, *(unsigned int *)(a1 + 80));
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = __dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
    __dst.__r_.__value_.__s.__data_[0] = 0;
    if ((v19 & 1) == 0) {
      sub_10004D2C8(v17);
    }
    v63[0] = 0;
    v63[1] = 0;
    int64_t v64 = 0;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    sub_1000C140C((uint64_t)&__dst, size + 1);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(p_dst, p_p, size);
    }
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + size) = 47;
    unsigned int v61 = v66;
    sub_1000292E0((uint64_t)&buf);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string buf = &buf;
    }
    else {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v25 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v25 = buf.__r_.__value_.__l.__size_;
    }
    uint64_t v26 = std::string::append(&__dst, (const std::string::value_type *)p_buf, v25);
    long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    int64_t v64 = v26->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v63 = v27;
    v26->__r_.__value_.__l.__size_ = 0;
    v26->__r_.__value_.__r.__words[2] = 0;
    v26->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    unsigned int v61 = 0;
    std::string v62 = 0;
    Registry::getFileSystemInterface((uint64_t *)&v61, *(Registry **)(a1 + 64));
    char v28 = (*(uint64_t (**)(void *, void **))(*(void *)v61 + 88))(v61, v63);
    uint64_t v29 = **(NSObject ***)(a1 + 8);
    BOOL v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
    if ((v28 & 1) == 0)
    {
      if (v30)
      {
        uint64_t v32 = v63;
        if (v64 < 0) {
          uint64_t v32 = (void **)v63[0];
        }
        LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v32;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I DMU file %{public}s does not exist", (uint8_t *)&__dst, 0xCu);
      }
      int v20 = 2;
      goto LABEL_113;
    }
    if (v30)
    {
      std::string::size_type v69 = v66;
      sub_1000292E0((uint64_t)&__dst);
      uint64_t v31 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__dst
          : (std::string *)__dst.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v31;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I DMU file name: %{public}s", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    xpc_object_t value = 0;
    (*(void (**)(std::string *__return_ptr))(*(void *)v61 + 136))(&v59);
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, v59.__r_.__value_.__l.__data_, v59.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = v59;
    }
    uint64_t v67 = 0;
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = buf;
    }
    std::string::size_type v68 = 0;
    if (ctu::cf::convert_copy())
    {
      char v33 = v67;
      uint64_t v67 = v68;
      std::string::size_type v69 = v33;
      sub_1000558F4((const void **)&v69);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    xpc_object_t value = v67;
    uint64_t v67 = 0;
    sub_1000558F4((const void **)&v67);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v59.__r_.__value_.__l.__data_);
    }
    uint64_t v34 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v69 = value;
      sub_1000292E0((uint64_t)&__dst);
      char v36 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__dst
          : (std::string *)__dst.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I DMU file bundle directory: %{public}s", (uint8_t *)&buf, 0xCu);
      uint64_t v35 = (uint64_t *)SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
      if ((v35 & 0x80000000) != 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    size_t v37 = (std::mutex *)Registry::getServiceMap(v35, *(Registry **)(a1 + 64));
    __int16 v38 = v37;
    if ((v39 & 0x8000000000000000) != 0)
    {
      uint64_t v40 = (unsigned __int8 *)(v39 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v41 = 5381;
      do
      {
        std::string::size_type v39 = v41;
        unsigned int v42 = *v40++;
        uint64_t v41 = (33 * v41) ^ v42;
      }
      while (v42);
    }
    std::mutex::lock(v37);
    __dst.__r_.__value_.__r.__words[0] = v39;
    uint64_t v43 = sub_10004D37C(&v38[1].__m_.__sig, (unint64_t *)&__dst);
    if (v43)
    {
      uint64_t v45 = v43[3];
      uint64_t v44 = (std::__shared_weak_count *)v43[4];
      if (v44)
      {
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v38);
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v44);
        char v46 = 0;
LABEL_86:
        std::string::size_type v68 = 0;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v47 = &__p;
        }
        else {
          uint64_t v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        uint64_t v48 = (void *)(*(uint64_t (**)(uint64_t, std::string *))(*(void *)v45 + 24))(v45, v47);
        std::string::size_type v68 = v48;
        uint64_t v49 = **(NSObject ***)(a1 + 8);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
        {
          std::string::size_type v69 = v48;
          sub_1000292E0((uint64_t)&__dst);
          uint64_t v50 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &__dst
              : (std::string *)__dst.__r_.__value_.__r.__words[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v50;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I DMU file bundle ID: %{public}s", (uint8_t *)&buf, 0xCu);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
        }
        uint64_t v67 = 0;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v51 = &__p;
        }
        else {
          char v51 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        std::string::size_type v52 = (void *)(*(uint64_t (**)(uint64_t, std::string *))(*(void *)v45 + 40))(v45, v51);
        uint64_t v67 = v52;
        int v53 = **(NSObject ***)(a1 + 8);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          std::string::size_type v69 = v52;
          sub_1000292E0((uint64_t)&__dst);
          uint64_t v54 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &__dst
              : (std::string *)__dst.__r_.__value_.__r.__words[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v54;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I DMU file bundle version: %{public}s", (uint8_t *)&buf, 0xCu);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
        }
        buf.__r_.__value_.__r.__words[0] = 0;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          std::string::size_type v56 = buf.__r_.__value_.__r.__words[0];
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
          __dst.__r_.__value_.__r.__words[0] = v56;
          sub_10005717C((const void **)&__dst.__r_.__value_.__l.__data_);
        }
        CFDictionarySetValue((CFMutableDictionaryRef)buf.__r_.__value_.__l.__data_, @"kDMUBundleDir", value);
        CFDictionarySetValue((CFMutableDictionaryRef)buf.__r_.__value_.__l.__data_, @"kDMUFileName", v66);
        CFDictionarySetValue((CFMutableDictionaryRef)buf.__r_.__value_.__l.__data_, @"kDMUFileBundleID", v68);
        CFDictionarySetValue((CFMutableDictionaryRef)buf.__r_.__value_.__l.__data_, @"kDMUFileBundleVersion", v67);
        uint64_t v57 = **(NSObject ***)(a1 + 8);
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(__dst.__r_.__value_.__l.__data_) = 138543362;
          *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = buf.__r_.__value_.__r.__words[0];
          _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I DMU configuration: %{public}@", (uint8_t *)&__dst, 0xCu);
        }
        __dst.__r_.__value_.__r.__words[0] = buf.__r_.__value_.__r.__words[0];
        if (buf.__r_.__value_.__r.__words[0]) {
          CFRetain(buf.__r_.__value_.__l.__data_);
        }
        __dst.__r_.__value_.__s.__data_[8] = 0;
        sub_100946FE4(a2, (uint64_t)&__dst);
        sub_10005717C((const void **)&__dst.__r_.__value_.__l.__data_);
        sub_10005717C((const void **)&buf.__r_.__value_.__l.__data_);
        sub_1000558F4((const void **)&v67);
        sub_1000558F4((const void **)&v68);
        if ((v46 & 1) == 0) {
          sub_10004D2C8(v44);
        }
        sub_1000558F4((const void **)&value);
        int v20 = 0;
LABEL_113:
        if (v62) {
          sub_10004D2C8(v62);
        }
        if (SHIBYTE(v64) < 0) {
          operator delete(v63[0]);
        }
        goto LABEL_117;
      }
    }
    else
    {
      uint64_t v45 = 0;
    }
    std::mutex::unlock(v38);
    uint64_t v44 = 0;
    char v46 = 1;
    goto LABEL_86;
  }
  if (v7)
  {
    LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I No DMU file in the carrier bundle", (uint8_t *)&__dst, 2u);
  }
  int v20 = 1;
LABEL_117:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  BOOL result = sub_1000558F4((const void **)&v66);
  if ((v20 | 2) != 2 && v5)
  {
    if (*(unsigned char *)(a2 + 16)) {
      return sub_100057D78((const void **)a2);
    }
  }
  return result;
}

void sub_10094AD04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,const void *a32,const void *a33,__int16 a34,char a35,char a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  sub_1000558F4(&a33);
  if (a43 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  sub_1000558F4(&a32);
  if (*(unsigned char *)(v43 + 16)) {
    sub_100057D78((const void **)v43);
  }
  _Unwind_Resume(a1);
}

void sub_10094AEA4(uint64_t a1, uint64_t a2)
{
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kDMUBundleDir");
  if (Value)
  {
    CFMutableDictionaryRef v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFStringGetTypeID()) {
      BOOL v7 = v5;
    }
    else {
      BOOL v7 = 0;
    }
  }
  else
  {
    BOOL v7 = 0;
  }
  BOOL v30 = v7;
  BOOL v8 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kDMUFileName");
  if (v8)
  {
    uint64_t v9 = v8;
    CFTypeID v10 = CFGetTypeID(v8);
    if (v10 == CFStringGetTypeID()) {
      CFTypeID v11 = v9;
    }
    else {
      CFTypeID v11 = 0;
    }
  }
  else
  {
    CFTypeID v11 = 0;
  }
  uint64_t v29 = v11;
  std::string::size_type v12 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kDMUFileBundleID");
  if (v12)
  {
    uint64_t v13 = v12;
    CFTypeID v14 = CFGetTypeID(v12);
    if (v14 == CFStringGetTypeID()) {
      unsigned int v15 = v13;
    }
    else {
      unsigned int v15 = 0;
    }
  }
  else
  {
    unsigned int v15 = 0;
  }
  uint64_t v16 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kDMUFileBundleVersion");
  if (v16 && (CFTypeID v17 = CFGetTypeID(v16), TypeID = CFStringGetTypeID(), v7) && v11 && v15 && v17 == TypeID)
  {
    *(void *)std::string buf = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    sub_1000292E0((uint64_t)buf);
    v24[0] = 0;
    v24[1] = 0;
    uint64_t v25 = 0;
    sub_1000292E0((uint64_t)v24);
    int v19 = *(_DWORD *)(a1 + 80);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v23 = 0;
    char v20 = *(unsigned char *)(a1 + 96);
    sub_1000DFC90((uint64_t)v31, a2);
    sub_100947370(*(void *)(a1 + 40), v19, 7, (uint64_t)buf, (uint64_t)v24, (uint64_t)__p, v20);
    sub_100060644(v31);
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[0]);
    }
    if (SHIBYTE(v28) < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    char v21 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I The contents of PRI file config dictionary is not correct", buf, 2u);
    }
  }
}

void sub_10094B0C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10094B124(uint64_t a1)
{
  if (*(void *)(a1 + 88)) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    uint64_t v18 = 0;
    uint64_t FileConfigurationKeyNameForType = getFileConfigurationKeyNameForType(*(_DWORD *)(a1 + 80), *(unsigned __int8 *)(a1 + 84));
    sub_100945790(*(Registry **)(a1 + 64), buf, FileConfigurationKeyNameForType, v4);
    sub_10004EFE4(&v18, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    CFMutableDictionaryRef v5 = v18;
    if (v18) {
      CFTypeID v6 = sub_100080778;
    }
    else {
      CFTypeID v6 = 0;
    }
    BOOL v7 = **(NSObject ***)(a1 + 8);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v8)
      {
        uint64_t v9 = *(void *)(a1 + 88);
        *(_DWORD *)std::string buf = 138412546;
        char v20 = v5;
        __int16 v21 = 2112;
        uint64_t v22 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Cached DMU file configuration %@, intended %@", buf, 0x16u);
        CFMutableDictionaryRef v5 = v18;
      }
      int v10 = CFEqual(v5, *(CFTypeRef *)(a1 + 88));
      CFTypeID v11 = **(NSObject ***)(a1 + 8);
      BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
      if (v10)
      {
        if (v12)
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Cached DMU file configuration is same as the one intended to be pushed, bailing out", buf, 2u);
        }
        uint64_t v13 = 0;
        goto LABEL_23;
      }
      if (v12)
      {
        *(_WORD *)std::string buf = 0;
        unsigned int v15 = "#I Cached DMU file configuration is different than the one intended, checking the version number";
        uint64_t v16 = v11;
        goto LABEL_21;
      }
    }
    else if (v8)
    {
      *(_WORD *)std::string buf = 0;
      unsigned int v15 = "#I No cached DMU file configuration";
      uint64_t v16 = v7;
LABEL_21:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, 2u);
    }
    uint64_t v13 = 1;
LABEL_23:
    sub_100057D78(&v18);
    return v13;
  }
  CFTypeID v14 = **(NSObject ***)(a1 + 8);
  uint64_t v13 = 0;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I No valid dmu config?", buf, 2u);
    return 0;
  }
  return v13;
}

void sub_10094B35C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_10094B388@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  CFTypeRef cf = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFTypeRef v5 = cf;
    CFTypeRef cf = Mutable;
    *(void *)std::string buf = v5;
    sub_10005717C((const void **)buf);
  }
  CFTypeID v6 = (__CFDictionary *)cf;
  BOOL v7 = (_OWORD *)(a1 + 104);
  if (*(char *)(a1 + 127) < 0)
  {
    sub_10004FC84(v12, *(void **)(a1 + 104), *(void *)(a1 + 112));
  }
  else
  {
    *(_OWORD *)BOOL v12 = *v7;
    uint64_t v13 = *(void *)(a1 + 120);
  }
  if (SHIBYTE(v13) < 0)
  {
    sub_10004FC84(__p, v12[0], (unint64_t)v12[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v12;
    uint64_t v18 = v13;
  }
  uint64_t v16 = 0;
  if (SHIBYTE(v18) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    uint64_t v22 = v18;
  }
  int v19 = 0;
  if (ctu::cf::convert_copy())
  {
    BOOL v8 = v16;
    uint64_t v16 = v19;
    char v20 = v8;
    sub_1000558F4(&v20);
  }
  if (SHIBYTE(v22) < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v9 = v16;
  CFTypeID v14 = v16;
  uint64_t v16 = 0;
  sub_1000558F4(&v16);
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[0]);
  }
  CFDictionarySetValue(v6, @"kPushFilePath", v9);
  sub_1000558F4(&v14);
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
  int v10 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 127) < 0) {
      BOOL v7 = *(_OWORD **)v7;
    }
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I PRL with file path %{public}s needs a file push", buf, 0xCu);
  }
  *(void *)std::string buf = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint8_t buf[8] = 0;
  sub_100946FE4((uint64_t)a2, (uint64_t)buf);
  sub_10005717C((const void **)buf);
  return sub_10005717C(&cf);
}

void sub_10094B5E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  sub_1000558F4(&a18);
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10005717C(&a17);
  if (*(unsigned char *)(v24 + 16)) {
    sub_100057D78((const void **)v24);
  }
  _Unwind_Resume(a1);
}

void sub_10094B688(uint64_t a1, uint64_t a2)
{
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kPushFilePath");
  if (Value)
  {
    CFTypeRef v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFStringGetTypeID())
    {
      v16[0] = &off_101A0BD40;
      v16[1] = v5;
      v14[0] = 0;
      v14[1] = 0;
      uint64_t v15 = 0;
      sub_1000292E0((uint64_t)__p);
      sub_1007ED5A8((uint64_t)__p, v14);
      if (SHIBYTE(v13) < 0) {
        operator delete(__p[0]);
      }
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v13 = 0;
      sub_1000292E0((uint64_t)v10);
      sub_1007ED50C((uint64_t)v10, __p);
      if (SHIBYTE(v11) < 0) {
        operator delete(v10[0]);
      }
      int v7 = *(_DWORD *)(a1 + 80);
      char v8 = *(unsigned char *)(a1 + 84);
      v10[0] = 0;
      v10[1] = 0;
      uint64_t v11 = 0;
      char v9 = *(unsigned char *)(a1 + 96);
      sub_1000DFC90((uint64_t)v17, a2);
      sub_100947370(*(void *)(a1 + 40), v7, v8, (uint64_t)v14, (uint64_t)__p, (uint64_t)v10, v9);
      sub_100060644(v17);
      if (SHIBYTE(v11) < 0) {
        operator delete(v10[0]);
      }
      if (SHIBYTE(v13) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v15) < 0) {
        operator delete(v14[0]);
      }
      FileSystemInterface::~FileSystemInterface((FileSystemInterface *)v16);
    }
  }
}

void sub_10094B828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&a27);
  _Unwind_Resume(a1);
}

const void **sub_10094B8B4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v86[1] = 0;
  CFMutableDictionaryRef theDict = 0;
  __int16 v85 = 0;
  v86[0] = 0;
  BOOL v83 = 0;
  v84[0] = 0;
  v84[1] = 0;
  if (capabilities::ct::supportsDERFileFormat((capabilities::ct *)a1)
    && (BOOL v4 = sub_10094C660(a1, @"DerGriFileName", @"DerGriFileVersion", 1, 2, (uint64_t)&v83)))
  {
    BOOL v5 = 1;
  }
  else
  {
    BOOL v4 = sub_10094C660(a1, @"GRIFileName", @"GRIVersion", 1, 1, (uint64_t)&v83);
    BOOL v5 = v4;
  }
  if (capabilities::ct::supportsDERFileFormat((capabilities::ct *)v4)
    && sub_10094C660(a1, @"DerGriFileName", @"DerGriFileVersion", 4, 2, (uint64_t)&v85))
  {
    BOOL v6 = 1;
    goto LABEL_9;
  }
  BOOL v6 = sub_10094C660(a1, @"GRIFileName", @"GRIVersion", 4, 1, (uint64_t)&v85);
  if (v5 || v6)
  {
LABEL_9:
    if (v5 && v6) {
      BOOL v5 = _CompareBundleVersionStrings(v84[0], v86[0]) != -1;
    }
    memset(&__p, 0, sizeof(__p));
    size_t v79 = 0;
    uint64_t v80 = 0;
    uint64_t v81 = 0;
    int v7 = **(NSObject ***)(a1 + 8);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (v8)
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Choosing GRI file inside the carrier bundle", (uint8_t *)&buf, 2u);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 64));
      uint64_t v11 = ServiceMap;
      if ((v12 & 0x8000000000000000) != 0)
      {
        uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          std::string::size_type v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      __dst.__r_.__value_.__r.__words[0] = v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&__dst);
      if (v16)
      {
        uint64_t v18 = v16[3];
        CFTypeID v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
LABEL_32:
          (*(void (**)(std::string *__return_ptr, uint64_t, void))(*(void *)v18 + 128))(&buf, v18, *(unsigned int *)(a1 + 80));
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          std::string __p = buf;
          *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
          buf.__r_.__value_.__s.__data_[0] = 0;
          if ((v19 & 1) == 0) {
            sub_10004D2C8(v17);
          }
          uint64_t v31 = &v83;
          goto LABEL_44;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      CFTypeID v17 = 0;
      char v19 = 1;
      goto LABEL_32;
    }
    if (v8)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Choosing GRI file inside the default bundle", (uint8_t *)&buf, 2u);
    }
    __int16 v21 = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 64));
    uint64_t v22 = v21;
    if ((v23 & 0x8000000000000000) != 0)
    {
      uint64_t v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        std::string::size_type v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(v21);
    __dst.__r_.__value_.__r.__words[0] = v23;
    uint64_t v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)&__dst);
    if (v27)
    {
      uint64_t v29 = v27[3];
      uint64_t v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
LABEL_39:
        (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v29 + 152))(&buf, v29);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        std::string __p = buf;
        *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
        buf.__r_.__value_.__s.__data_[0] = 0;
        if ((v30 & 1) == 0) {
          sub_10004D2C8(v28);
        }
        uint64_t v31 = &v85;
LABEL_44:
        sub_100083EB8((const void **)&v79, v31);
        sub_100083EB8((const void **)&v80, v31 + 1);
        LOBYTE(v81) = *((unsigned char *)v31 + 16);
        v77[0] = 0;
        v77[1] = 0;
        int64_t v78 = 0;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          size_t size = __p.__r_.__value_.__l.__size_;
        }
        memset(&buf, 0, sizeof(buf));
        p_std::string buf = &buf;
        sub_1000C140C((uint64_t)&buf, size + 1);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        if (size)
        {
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          memmove(p_buf, p_p, size);
        }
        *(_WORD *)((char *)&p_buf->__r_.__value_.__l.__data_ + size) = 47;
        size_t v75 = v79;
        sub_1000292E0((uint64_t)&__dst);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_dst = &__dst;
        }
        else {
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v36 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v36 = __dst.__r_.__value_.__l.__size_;
        }
        size_t v37 = std::string::append(&buf, (const std::string::value_type *)p_dst, v36);
        long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
        int64_t v78 = v37->__r_.__value_.__r.__words[2];
        *(_OWORD *)int64_t v77 = v38;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        v37->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        size_t v75 = 0;
        uint64_t v76 = 0;
        Registry::getFileSystemInterface((uint64_t *)&v75, *(Registry **)(a1 + 64));
        char v39 = (*(uint64_t (**)(void *, void **))(*(void *)v75 + 88))(v75, v77);
        uint64_t v40 = **(NSObject ***)(a1 + 8);
        BOOL v41 = os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
        if ((v39 & 1) == 0)
        {
          if (v41)
          {
            uint64_t v43 = v77;
            if (v78 < 0) {
              uint64_t v43 = (void **)v77[0];
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v43;
            _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#N GRI file %{public}s does not exist", (uint8_t *)&buf, 0xCu);
          }
          goto LABEL_138;
        }
        if (v41)
        {
          xpc_object_t v90 = v79;
          sub_1000292E0((uint64_t)&buf);
          unsigned int v42 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &buf
              : (std::string *)buf.__r_.__value_.__r.__words[0];
          LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v42;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I GRI file name: %{public}s", (uint8_t *)&__dst, 0xCu);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
        xpc_object_t value = 0;
        (*(void (**)(std::string *__return_ptr))(*(void *)v75 + 136))(&v73);
        if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, v73.__r_.__value_.__l.__data_, v73.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v73;
        }
        long long v88 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          std::string buf = __dst;
        }
        char v89 = 0;
        if (ctu::cf::convert_copy())
        {
          uint64_t v44 = v88;
          long long v88 = v89;
          xpc_object_t v90 = v44;
          sub_1000558F4((const void **)&v90);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        xpc_object_t value = v88;
        long long v88 = 0;
        sub_1000558F4((const void **)&v88);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v73.__r_.__value_.__l.__data_);
        }
        uint64_t v45 = **(NSObject ***)(a1 + 8);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        {
          xpc_object_t v90 = value;
          sub_1000292E0((uint64_t)&buf);
          uint64_t v47 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &buf
              : (std::string *)buf.__r_.__value_.__r.__words[0];
          LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v47;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I GRI file bundle directory: %{public}s", (uint8_t *)&__dst, 0xCu);
          char v46 = (uint64_t *)SHIBYTE(buf.__r_.__value_.__r.__words[2]);
          if ((v46 & 0x80000000) != 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
        uint64_t v48 = (std::mutex *)Registry::getServiceMap(v46, *(Registry **)(a1 + 64));
        uint64_t v49 = v48;
        if ((v50 & 0x8000000000000000) != 0)
        {
          char v51 = (unsigned __int8 *)(v50 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v52 = 5381;
          do
          {
            std::string::size_type v50 = v52;
            unsigned int v53 = *v51++;
            uint64_t v52 = (33 * v52) ^ v53;
          }
          while (v53);
        }
        std::mutex::lock(v48);
        buf.__r_.__value_.__r.__words[0] = v50;
        uint64_t v54 = sub_10004D37C(&v49[1].__m_.__sig, (unint64_t *)&buf);
        if (v54)
        {
          uint64_t v56 = v54[3];
          unsigned int v55 = (std::__shared_weak_count *)v54[4];
          if (v55)
          {
            atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v49);
            atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v55);
            char v57 = 0;
LABEL_103:
            char v89 = 0;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v58 = &__p;
            }
            else {
              unint64_t v58 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            std::string v59 = (void *)(*(uint64_t (**)(uint64_t, std::string *))(*(void *)v56 + 24))(v56, v58);
            char v89 = v59;
            uint64_t v60 = **(NSObject ***)(a1 + 8);
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
            {
              xpc_object_t v90 = v59;
              sub_1000292E0((uint64_t)&buf);
              unsigned int v61 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                  ? &buf
                  : (std::string *)buf.__r_.__value_.__r.__words[0];
              LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
              *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v61;
              _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I GRI file bundle ID: %{public}s", (uint8_t *)&__dst, 0xCu);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
            }
            long long v88 = 0;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string v62 = &__p;
            }
            else {
              std::string v62 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            uint64_t v63 = (void *)(*(uint64_t (**)(uint64_t, std::string *))(*(void *)v56 + 40))(v56, v62);
            long long v88 = v63;
            int64_t v64 = **(NSObject ***)(a1 + 8);
            if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
            {
              xpc_object_t v90 = v63;
              sub_1000292E0((uint64_t)&buf);
              char v65 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                  ? &buf
                  : (std::string *)buf.__r_.__value_.__r.__words[0];
              LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
              *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v65;
              _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I GRI file bundle version: %{public}s", (uint8_t *)&__dst, 0xCu);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
            }
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (Mutable)
            {
              CFMutableDictionaryRef v67 = theDict;
              CFMutableDictionaryRef theDict = Mutable;
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v67;
              sub_10005717C((const void **)&buf.__r_.__value_.__l.__data_);
            }
            CFDictionarySetValue(theDict, @"kGRIBundleDir", value);
            CFDictionarySetValue(theDict, @"kGRIFileName", v79);
            CFDictionarySetValue(theDict, @"kGRIFileVersion", v80);
            if (v89) {
              std::string::size_type v68 = sub_1000810B8;
            }
            else {
              std::string::size_type v68 = 0;
            }
            if (v68) {
              CFDictionarySetValue(theDict, @"kGRIFileBundleID", v89);
            }
            if (v88) {
              std::string::size_type v69 = sub_1000810B8;
            }
            else {
              std::string::size_type v69 = 0;
            }
            if (v69) {
              CFDictionarySetValue(theDict, @"kGRIFileBundleVersion", v88);
            }
            uint64_t v70 = *(os_log_t **)(a1 + 8);
            sub_10004EFE4(&v72, (CFTypeRef *)&theDict);
            sub_100946E94(v70, (uint64_t)"GRI configuration", (const __CFDictionary **)&v72);
            sub_100057D78(&v72);
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)theDict;
            if (theDict) {
              CFRetain(theDict);
            }
            buf.__r_.__value_.__s.__data_[8] = v81;
            sub_100946FE4((uint64_t)a2, (uint64_t)&buf);
            sub_10005717C((const void **)&buf.__r_.__value_.__l.__data_);
            sub_1000558F4((const void **)&v88);
            sub_1000558F4((const void **)&v89);
            if ((v57 & 1) == 0) {
              sub_10004D2C8(v55);
            }
            sub_1000558F4((const void **)&value);
LABEL_138:
            if (v76) {
              sub_10004D2C8(v76);
            }
            if (SHIBYTE(v78) < 0) {
              operator delete(v77[0]);
            }
            sub_1000558F4((const void **)&v80);
            sub_1000558F4((const void **)&v79);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            goto LABEL_144;
          }
        }
        else
        {
          uint64_t v56 = 0;
        }
        std::mutex::unlock(v49);
        unsigned int v55 = 0;
        char v57 = 1;
        goto LABEL_103;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    uint64_t v28 = 0;
    char v30 = 1;
    goto LABEL_39;
  }
  char v20 = **(NSObject ***)(a1 + 8);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I No GRI file in carrier or default bundles", (uint8_t *)&buf, 2u);
  }
LABEL_144:
  sub_1000558F4((const void **)v84);
  sub_1000558F4(&v83);
  sub_1000558F4((const void **)v86);
  sub_1000558F4(&v85);
  return sub_10005717C((const void **)&theDict);
}

void sub_10094C484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,const void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,const void *a36,uint64_t a37,uint64_t a38,const void *a39,uint64_t a40,uint64_t a41,const void *a42)
{
  sub_1000558F4((const void **)(v43 - 184));
  if (*(char *)(v43 - 137) < 0) {
    operator delete(*(void **)(v43 - 160));
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  sub_1000558F4((const void **)&a27);
  sub_1000558F4(&a26);
  if (a34 < 0) {
    operator delete(a29);
  }
  sub_1000558F4((const void **)&a37);
  sub_1000558F4(&a36);
  sub_1000558F4((const void **)&a40);
  sub_1000558F4(&a39);
  sub_10005717C(&a42);
  if (*(unsigned char *)(v42 + 16)) {
    sub_100057D78((const void **)v42);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10094C660(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 64));
  uint64_t v13 = ServiceMap;
  uint64_t v15 = v14;
  if (v14 < 0)
  {
    uint64_t v16 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v15;
  char v19 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
  if (v19)
  {
    uint64_t v21 = v19[3];
    char v20 = (std::__shared_weak_count *)v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v22 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v13);
  char v20 = 0;
  char v22 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, uint64_t, void, void))(*(void *)v21 + 80))(&v42, v21, *(unsigned int *)(a1 + 80), a4, a2, 0, 0);
  sub_100056248(&cf, &v42);
  sub_1000577C4(&v42);
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  if (cf) {
    std::string::size_type v23 = (uint64_t *)sub_1000810B8;
  }
  else {
    std::string::size_type v23 = 0;
  }
  if (!v23)
  {
    BOOL v33 = 0;
    goto LABEL_40;
  }
  CFTypeRef v40 = 0;
  uint64_t v24 = (std::mutex *)Registry::getServiceMap(v23, *(Registry **)(a1 + 64));
  uint64_t v25 = v24;
  if (v14 < 0)
  {
    unsigned int v26 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v14 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(v24);
  *(void *)std::string buf = v14;
  uint64_t v29 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
  if (!v29)
  {
    uint64_t v31 = 0;
    goto LABEL_23;
  }
  uint64_t v31 = v29[3];
  char v30 = (std::__shared_weak_count *)v29[4];
  if (!v30)
  {
LABEL_23:
    std::mutex::unlock(v25);
    char v30 = 0;
    char v32 = 1;
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v25);
  atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v30);
  char v32 = 0;
LABEL_24:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, uint64_t, void, void))(*(void *)v31 + 80))(&v42, v31, *(unsigned int *)(a1 + 80), a4, a3, 0, 0);
  sub_100056248(&v40, &v42);
  sub_1000577C4(&v42);
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  if (v40) {
    uint64_t v34 = sub_1000810B8;
  }
  else {
    uint64_t v34 = 0;
  }
  BOOL v33 = v34 != 0;
  if (v34)
  {
    uint64_t v35 = **(NSObject ***)(a1 + 8);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v36 = asString();
      uint64_t v37 = asString();
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v36;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v37;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Extracted GRI info of format %s from %s", buf, 0x16u);
    }
    CFTypeRef v38 = cf;
    *(void *)std::string buf = cf;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)&uint8_t buf[8] = v40;
    if (v40) {
      CFRetain(v40);
    }
    uint8_t buf[16] = a5;
    if (buf != (unsigned char *)a6)
    {
      uint64_t v42 = *(const void **)a6;
      *(void *)std::string buf = 0;
      *(void *)a6 = v38;
      sub_1000558F4(&v42);
      uint64_t v42 = *(const void **)(a6 + 8);
      *(void *)(a6 + 8) = *(void *)&buf[8];
      *(void *)&uint8_t buf[8] = 0;
      sub_1000558F4(&v42);
      a5 = buf[16];
    }
    *(unsigned char *)(a6 + 16) = a5;
    sub_1000558F4((const void **)&buf[8]);
    sub_1000558F4((const void **)buf);
  }
  sub_1000558F4(&v40);
LABEL_40:
  sub_1000558F4(&cf);
  return v33;
}

void sub_10094CA7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10094CB04(uint64_t a1, uint64_t a2)
{
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kGRIBundleDir");
  if (Value)
  {
    BOOL v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFStringGetTypeID()) {
      int v7 = v5;
    }
    else {
      int v7 = 0;
    }
  }
  else
  {
    int v7 = 0;
  }
  uint64_t v35 = v7;
  BOOL v8 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kGRIFileName");
  if (v8)
  {
    char v9 = v8;
    CFTypeID v10 = CFGetTypeID(v8);
    if (v10 == CFStringGetTypeID()) {
      uint64_t v11 = v9;
    }
    else {
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  uint64_t v34 = v11;
  std::string::size_type v12 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kGRIFileVersion");
  if (v12)
  {
    uint64_t v13 = v12;
    CFTypeID v14 = CFGetTypeID(v12);
    if (v14 == CFStringGetTypeID()) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = 0;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v16 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kGRIFileBundleID");
  if (v16)
  {
    uint64_t v17 = v16;
    CFTypeID v18 = CFGetTypeID(v16);
    if (v18 == CFStringGetTypeID()) {
      char v19 = v17;
    }
    else {
      char v19 = 0;
    }
  }
  else
  {
    char v19 = 0;
  }
  BOOL v33 = v19;
  char v20 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kGRIFileBundleVersion");
  if (v20)
  {
    CFTypeID v21 = CFGetTypeID(v20);
    BOOL v22 = v21 == CFStringGetTypeID();
    if (!v7)
    {
LABEL_35:
      uint64_t v25 = **(NSObject ***)(a1 + 8);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I The contents of GRI file config dictionary is not correct", buf, 2u);
      }
      return;
    }
  }
  else
  {
    BOOL v22 = 0;
    if (!v7) {
      goto LABEL_35;
    }
  }
  if (!v11 || !v15 || !v19 || !v22) {
    goto LABEL_35;
  }
  *(void *)std::string buf = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  sub_1000292E0((uint64_t)buf);
  v28[0] = 0;
  v28[1] = 0;
  uint64_t v29 = 0;
  sub_1000292E0((uint64_t)v28);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v27 = 0;
  sub_1000292E0((uint64_t)__p);
  int v23 = *(_DWORD *)(a1 + 80);
  char v24 = *(unsigned char *)(a1 + 96);
  sub_1000DFC90((uint64_t)v36, a2);
  sub_100947370(*(void *)(a1 + 40), v23, 6, (uint64_t)buf, (uint64_t)v28, (uint64_t)__p, v24);
  sub_100060644(v36);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_10094CD88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10094CDEC(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 88);
  if (*(void *)(a1 + 88)) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFTypeRef cf = 0;
    uint64_t FileConfigurationKeyNameForType = getFileConfigurationKeyNameForType(*(_DWORD *)(a1 + 80), *(unsigned __int8 *)(a1 + 84));
    sub_100945790(*(Registry **)(a1 + 64), buf, FileConfigurationKeyNameForType, v5);
    sub_10004EFE4(&cf, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (cf) {
      CFTypeID v6 = sub_100080778;
    }
    else {
      CFTypeID v6 = 0;
    }
    int v7 = *(os_log_t **)(a1 + 8);
    if (v6)
    {
      CFTypeRef v36 = cf;
      if (cf) {
        CFRetain(cf);
      }
      sub_100946E94(v7, (uint64_t)"Cached GRI file configuration", (const __CFDictionary **)&v36);
      sub_100057D78(&v36);
      BOOL v8 = *(os_log_t **)(a1 + 8);
      sub_100058198(&v35, v2);
      sub_100946E94(v8, (uint64_t)"Intended GRI file configuration", (const __CFDictionary **)&v35);
      sub_100057D78(&v35);
      if (CFEqual(cf, *v2))
      {
        char v9 = **(NSObject ***)(a1 + 8);
        BOOL v10 = 0;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Cached GRI file configuration is same as the one intended to be pushed, bailing out", buf, 2u);
          BOOL v10 = 0;
        }
        goto LABEL_19;
      }
      CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"kGRIFileBundleID");
      uint64_t v15 = CFDictionaryGetValue((CFDictionaryRef)*v2, @"kGRIFileBundleID");
      if (!Value || !v15 || CFEqual(Value, v15))
      {
        uint64_t v16 = **(NSObject ***)(a1 + 8);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Cached GRI file configuration is different than the one intended, checking the version number", buf, 2u);
        }
        CFStringRef v17 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"kGRIFileVersion");
        CFStringRef v18 = v17;
        if (v17)
        {
          CFTypeID v19 = CFGetTypeID(v17);
          if (v19 != CFStringGetTypeID()) {
            CFStringRef v18 = 0;
          }
        }
        CFStringRef v20 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)*v2, @"kGRIFileVersion");
        CFStringRef v21 = v20;
        if (v20)
        {
          CFTypeID v22 = CFGetTypeID(v20);
          if (v22 == CFStringGetTypeID()) {
            CFStringRef v23 = v21;
          }
          else {
            CFStringRef v23 = 0;
          }
        }
        else
        {
          CFStringRef v23 = 0;
        }
        __p[0] = (void *)v23;
        uint64_t v24 = _CompareBundleVersionStrings(v23, v18);
        uint64_t v25 = **(NSObject ***)(a1 + 8);
        BOOL v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
        BOOL v10 = v24 == 1;
        if (v24 == 1)
        {
          if (v26)
          {
            sub_1000292E0((uint64_t)buf);
            uint64_t v27 = v39 >= 0 ? buf : *(uint8_t **)buf;
            *(_DWORD *)CFTypeRef v40 = 136446210;
            *(void *)&v40[4] = v27;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Newer GRI file is available with version %{public}s, need GRI push", v40, 0xCu);
            if (SHIBYTE(v39) < 0) {
              operator delete(*(void **)buf);
            }
          }
        }
        else if (v26)
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Baseband already has the newest version, no need GRI file push", buf, 2u);
        }
        goto LABEL_19;
      }
      unsigned int v28 = **(NSObject ***)(a1 + 8);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v39 = 0;
        ctu::cf::assign();
        uint64_t v41 = v39;
        *(_OWORD *)CFTypeRef v40 = *(_OWORD *)buf;
        int v29 = SHIBYTE(v39);
        char v30 = *(uint8_t **)buf;
        memset(buf, 0, sizeof(buf));
        uint64_t v39 = 0;
        ctu::cf::assign();
        uint64_t v31 = v40;
        if (v29 < 0) {
          uint64_t v31 = v30;
        }
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v34 = v39;
        uint64_t v32 = __p;
        if (v39 < 0) {
          uint64_t v32 = *(void ***)buf;
        }
        *(_DWORD *)uint64_t v42 = 136446466;
        uint64_t v43 = v31;
        __int16 v44 = 2082;
        uint64_t v45 = v32;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I GRI bundle ID mismatch between cached (%{public}s) and intended (%{public}s)", v42, 0x16u);
        if (SHIBYTE(v34) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v41) < 0) {
          operator delete(*(void **)v40);
        }
      }
    }
    else
    {
      std::string::size_type v12 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I No cached GRI file configuration", buf, 2u);
      }
    }
    BOOL v10 = 1;
LABEL_19:
    sub_100057D78(&cf);
    return v10;
  }
  uint64_t v11 = **(NSObject ***)(a1 + 8);
  BOOL v10 = 0;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I No GRI file config present", buf, 2u);
    return 0;
  }
  return v10;
}

void sub_10094D2AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (v25 < 0) {
    operator delete(v24);
  }
  sub_100057D78(&a18);
  _Unwind_Resume(a1);
}

void *sub_10094D350(uint64_t a1, uint64_t a2)
{
  CFArrayRef Value = (BOOL *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"EnableIMSISwitch");
  BOOL v5 = Value;
  unsigned __int8 v11 = 0;
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v11, v5, v7);
      LODWORD(v5) = v11;
    }
    else
    {
      LODWORD(v5) = 0;
    }
  }
  uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 128);
  sub_1000DFC90((uint64_t)v12, a2);
  CFTypeID v14 = 0;
  char v9 = operator new(0x28uLL);
  void *v9 = off_101A1E100;
  sub_100023950((uint64_t)(v9 + 1), (uint64_t)v12);
  CFTypeID v14 = v9;
  (*(void (**)(uint64_t, BOOL, void *))(*(void *)v8 + 80))(v8, v5 != 0, v13);
  sub_100060644(v13);
  return sub_100060644(v12);
}

void sub_10094D490(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_100060644((uint64_t *)va1);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10094D4BC(uint64_t a1)
{
  CFTypeRef cf1 = 0;
  uint64_t FileConfigurationKeyNameForType = getFileConfigurationKeyNameForType(*(_DWORD *)(a1 + 80), *(unsigned __int8 *)(a1 + 84));
  sub_100945790(*(Registry **)(a1 + 64), &v10, FileConfigurationKeyNameForType, v3);
  sub_1000057AC(&cf1, &v10);
  sub_1000577C4(&v10);
  if (cf1) {
    BOOL v4 = sub_100084B4C;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
LABEL_11:
    uint64_t v8 = 1;
    goto LABEL_12;
  }
  int v5 = CFEqual(cf1, *(CFTypeRef *)(a1 + 88));
  uint64_t v6 = **(NSObject ***)(a1 + 8);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (!v5)
  {
    if (v7)
    {
      LOWORD(v10) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Cached IMSI Switch configuration is different than the one intended, checking the version number", (uint8_t *)&v10, 2u);
    }
    goto LABEL_11;
  }
  if (v7)
  {
    LOWORD(v10) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Cached IMSI Switch configuration is same as the one intended to be pushed, bailing out", (uint8_t *)&v10, 2u);
  }
  uint64_t v8 = 0;
LABEL_12:
  sub_100062778(&cf1);
  return v8;
}

void sub_10094D5CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_10094D5F0(uint64_t a1, uint64_t a2)
{
  CFArrayRef Value = (BOOL *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"AllowsMultiplePDNConnectionsToSameAPN");
  int v5 = Value;
  unsigned __int8 v11 = 0;
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v11, v5, v7);
      LODWORD(v5) = v11;
    }
    else
    {
      LODWORD(v5) = 0;
    }
  }
  uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 128);
  sub_1000DFC90((uint64_t)v12, a2);
  CFTypeID v14 = 0;
  char v9 = operator new(0x28uLL);
  void *v9 = off_101A1E180;
  sub_100023950((uint64_t)(v9 + 1), (uint64_t)v12);
  CFTypeID v14 = v9;
  (*(void (**)(uint64_t, BOOL, void *))(*(void *)v8 + 88))(v8, v5 != 0, v13);
  sub_100060644(v13);
  return sub_100060644(v12);
}

void sub_10094D730(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_100060644((uint64_t *)va1);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10094D75C(uint64_t a1)
{
  CFTypeRef cf1 = 0;
  uint64_t FileConfigurationKeyNameForType = getFileConfigurationKeyNameForType(*(_DWORD *)(a1 + 80), *(unsigned __int8 *)(a1 + 84));
  sub_100945790(*(Registry **)(a1 + 64), &v10, FileConfigurationKeyNameForType, v3);
  sub_1000057AC(&cf1, &v10);
  sub_1000577C4(&v10);
  if (cf1) {
    BOOL v4 = sub_100084B4C;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
LABEL_11:
    uint64_t v8 = 1;
    goto LABEL_12;
  }
  int v5 = CFEqual(cf1, *(CFTypeRef *)(a1 + 88));
  uint64_t v6 = **(NSObject ***)(a1 + 8);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (!v5)
  {
    if (v7)
    {
      LOWORD(v10) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Cached Multi PDN configuration is different than the one intended, checking the version number", (uint8_t *)&v10, 2u);
    }
    goto LABEL_11;
  }
  if (v7)
  {
    LOWORD(v10) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Cached Multi PDN configuration is same as the one intended to be pushed, bailing out", (uint8_t *)&v10, 2u);
  }
  uint64_t v8 = 0;
LABEL_12:
  sub_100062778(&cf1);
  return v8;
}

void sub_10094D86C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_10094D890@<X0>(void *a1@<X8>)
{
  CFTypeRef cf = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFTypeRef v3 = cf;
    CFTypeRef cf = Mutable;
    CFTypeRef v5 = v3;
    sub_10005717C(&v5);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  CFTypeRef v5 = cf;
  if (cf) {
    CFRetain(cf);
  }
  char v6 = 0;
  sub_100946FE4((uint64_t)a1, (uint64_t)&v5);
  sub_10005717C(&v5);
  return sub_10005717C(&cf);
}

void sub_10094D934(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  BOOL v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  sub_10005717C((const void **)va);
  if (*(unsigned char *)(v2 + 16)) {
    sub_100057D78((const void **)v2);
  }
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

void *sub_10094D968(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 568);
  uint64_t v3 = *(unsigned int *)(a1 + 80);
  int v4 = *(unsigned __int8 *)(a1 + 97);
  sub_1000DFC90((uint64_t)v8, a2);
  BOOL v10 = 0;
  CFTypeRef v5 = operator new(0x30uLL);
  *CFTypeRef v5 = off_101A1E200;
  v5[1] = a1;
  sub_100023950((uint64_t)(v5 + 2), (uint64_t)v8);
  BOOL v10 = v5;
  (*(void (**)(uint64_t, uint64_t, BOOL, void *))(*(void *)v2 + 72))(v2, v3, v4 != 0, v9);
  sub_10003B34C(v9);
  return sub_100060644(v8);
}

void sub_10094DA70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10003B34C((uint64_t *)va);
  sub_100060644(v6);
  _Unwind_Resume(a1);
}

uint64_t sub_10094DA9C(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 568);
  if (v2
    && ((*(uint64_t (**)(uint64_t, void, void))(*(void *)v2 + 16))(v2, *(unsigned int *)(a1 + 80), *(unsigned __int8 *)(a1 + 97)) & 1) != 0)
  {
    return 1;
  }
  int v4 = **(NSObject ***)(a1 + 8);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v5)
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Cached ATTACH_APN configuration is same as the one intended to be pushed, bailing out", v6, 2u);
    return 0;
  }
  return result;
}

const void **sub_10094DB54@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  xpc_object_t value = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 64));
  int v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  CFMutableDictionaryRef v17 = (CFMutableDictionaryRef)v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v17);
  if (v9)
  {
    unsigned __int8 v11 = (CarrierSettingsInterface *)v9[3];
    BOOL v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    unsigned __int8 v11 = 0;
  }
  std::mutex::unlock(v4);
  BOOL v10 = 0;
  char v12 = 1;
LABEL_9:
  CarrierSettingsInterface::CopyValueFromActiveBundleForKeyWithDefault((uint64_t *)&theDict, v11, @"EnableIMSISwitch", kCFBooleanFalse);
  sub_1000057AC(&value, (CFTypeRef *)&theDict);
  sub_1000577C4((const void **)&theDict);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  CFMutableDictionaryRef theDict = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v14 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    CFMutableDictionaryRef v17 = v14;
    sub_10005717C((const void **)&v17);
  }
  if (value) {
    uint64_t v15 = sub_100084B4C;
  }
  else {
    uint64_t v15 = 0;
  }
  if (v15) {
    CFDictionarySetValue(theDict, @"EnableIMSISwitch", value);
  }
  CFMutableDictionaryRef v17 = theDict;
  if (theDict) {
    CFRetain(theDict);
  }
  char v18 = 0;
  sub_100946FE4((uint64_t)a2, (uint64_t)&v17);
  sub_10005717C((const void **)&v17);
  sub_10005717C((const void **)&theDict);
  return sub_100062778((const void **)&value);
}

void sub_10094DD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11, const void *a12)
{
  sub_10005717C(&a9);
  sub_10005717C(&a11);
  sub_100062778(&a12);
  if (*(unsigned char *)(v12 + 16)) {
    sub_100057D78((const void **)v12);
  }
  _Unwind_Resume(a1);
}

const void **sub_10094DD88@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  xpc_object_t value = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 64));
  int v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  CFMutableDictionaryRef v17 = (CFMutableDictionaryRef)v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v17);
  if (v9)
  {
    unsigned __int8 v11 = (CarrierSettingsInterface *)v9[3];
    BOOL v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    unsigned __int8 v11 = 0;
  }
  std::mutex::unlock(v4);
  BOOL v10 = 0;
  char v12 = 1;
LABEL_9:
  CarrierSettingsInterface::CopyValueFromActiveBundleForKeyWithDefault((uint64_t *)&theDict, v11, @"AllowsMultiplePDNConnectionsToSameAPN", kCFBooleanFalse);
  sub_1000057AC(&value, (CFTypeRef *)&theDict);
  sub_1000577C4((const void **)&theDict);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  CFMutableDictionaryRef theDict = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v14 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    CFMutableDictionaryRef v17 = v14;
    sub_10005717C((const void **)&v17);
  }
  if (value) {
    uint64_t v15 = sub_100084B4C;
  }
  else {
    uint64_t v15 = 0;
  }
  if (v15) {
    CFDictionarySetValue(theDict, @"AllowsMultiplePDNConnectionsToSameAPN", value);
  }
  CFMutableDictionaryRef v17 = theDict;
  if (theDict) {
    CFRetain(theDict);
  }
  char v18 = 0;
  sub_100946FE4((uint64_t)a2, (uint64_t)&v17);
  sub_10005717C((const void **)&v17);
  sub_10005717C((const void **)&theDict);
  return sub_100062778((const void **)&value);
}

void sub_10094DF50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11, const void *a12)
{
  sub_10005717C(&a9);
  sub_10005717C(&a11);
  sub_100062778(&a12);
  if (*(unsigned char *)(v12 + 16)) {
    sub_100057D78((const void **)v12);
  }
  _Unwind_Resume(a1);
}

void *sub_10094DFBC(void (***a1)(void, void *), uint64_t a2)
{
  sub_1000DFC90((uint64_t)v5, a2);
  uint64_t v6 = a1;
  unsigned int v8 = 0;
  uint64_t v3 = operator new(0x30uLL);
  void *v3 = off_101A1E280;
  sub_100023950((uint64_t)(v3 + 1), (uint64_t)v5);
  void v3[5] = v6;
  unsigned int v8 = v3;
  (**a1)(a1, v7);
  sub_100060644(v7);
  return sub_100060644(v5);
}

void sub_10094E0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
}

void sub_10094E0DC(uint64_t a1)
{
  sub_100945408(a1);

  operator delete();
}

uint64_t sub_10094E114(uint64_t a1)
{
  *(void *)a1 = off_101A1E300;
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }

  return sub_100945408(a1);
}

void sub_10094E174(uint64_t a1)
{
  *(void *)a1 = off_101A1E300;
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  sub_100945408(a1);

  operator delete();
}

void sub_10094E1EC(uint64_t a1)
{
  sub_100945408(a1);

  operator delete();
}

void sub_10094E228(uint64_t a1)
{
  sub_100945408(a1);

  operator delete();
}

uint64_t sub_10094E260()
{
  return 1;
}

uint64_t sub_10094E268(uint64_t a1)
{
  *(void *)a1 = off_101A1E390;
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }

  return sub_100945408(a1);
}

void sub_10094E2C8(uint64_t a1)
{
  *(void *)a1 = off_101A1E390;
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  sub_100945408(a1);

  operator delete();
}

void sub_10094E340(uint64_t a1)
{
  sub_100945408(a1);

  operator delete();
}

void sub_10094E37C(uint64_t a1)
{
  sub_100945408(a1);

  operator delete();
}

void sub_10094E3B8(uint64_t a1)
{
  sub_100945408(a1);

  operator delete();
}

uint64_t sub_10094E3F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  if (!a2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a2 + 48))(a2, &v4);
}

void sub_10094E44C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = (uint64_t *)*a2;
    }
    uint64_t v7 = *a3;
    int v8 = 136315394;
    char v9 = v6;
    __int16 v10 = 2112;
    uint64_t v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s = %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_10094E518(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  long long v8 = 0uLL;
  uint64_t v9 = 0;
  ctu::cf::assign();
  uint64_t v7 = 0;
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v5 = *(void (**)(uint64_t, void **, long long *))(v4 + 16);
  *(void *)&long long v8 = a3;
  v5(v4, __p, &v8);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10094E590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10094E5C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 16))();
}

uint64_t **sub_10094E5DC(uint64_t **a1, unsigned __int8 *a2, uint64_t a3)
{
  a1[1] = 0;
  uint64_t v4 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  if (a3)
  {
    uint64_t v5 = a2;
    uint64_t v6 = 0;
    uint64_t v7 = &a2[16 * a3];
    long long v8 = a1 + 1;
    while (1)
    {
      uint64_t v9 = v4;
      if (v8 == (uint64_t **)v4) {
        break;
      }
      __int16 v10 = v6;
      uint64_t v11 = v4;
      if (v6)
      {
        do
        {
          uint64_t v9 = v10;
          __int16 v10 = (uint64_t *)v10[1];
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v9 = (uint64_t *)v11[2];
          BOOL v12 = *v9 == (void)v11;
          uint64_t v11 = v9;
        }
        while (v12);
      }
      unsigned int v13 = *v5;
      if (*((unsigned __int8 *)v9 + 32) < v13) {
        break;
      }
      uint64_t v15 = v4;
      CFMutableDictionaryRef v14 = v4;
      if (!v6) {
        goto LABEL_25;
      }
      uint64_t v16 = v6;
      while (1)
      {
        while (1)
        {
          CFMutableDictionaryRef v14 = v16;
          unsigned int v17 = *((unsigned __int8 *)v16 + 32);
          if (v17 <= v13) {
            break;
          }
          uint64_t v16 = (uint64_t *)*v14;
          uint64_t v15 = v14;
          if (!*v14) {
            goto LABEL_25;
          }
        }
        if (v17 >= v13) {
          break;
        }
        uint64_t v16 = (uint64_t *)v14[1];
        if (!v16)
        {
          uint64_t v15 = v14 + 1;
          goto LABEL_25;
        }
      }
LABEL_28:
      v5 += 16;
      if (v5 == v7) {
        return a1;
      }
      long long v8 = (uint64_t **)*a1;
      uint64_t v6 = a1[1];
    }
    if (v6) {
      CFMutableDictionaryRef v14 = v9;
    }
    else {
      CFMutableDictionaryRef v14 = v4;
    }
    if (v6) {
      uint64_t v15 = v9 + 1;
    }
    else {
      uint64_t v15 = v4;
    }
    if (*v15) {
      goto LABEL_28;
    }
LABEL_25:
    char v18 = operator new(0x30uLL);
    v18[2] = *(_OWORD *)v5;
    *(void *)char v18 = 0;
    *((void *)v18 + 1) = 0;
    *((void *)v18 + 2) = v14;
    uint64_t *v15 = (uint64_t)v18;
    CFTypeID v19 = (uint64_t *)**a1;
    if (v19)
    {
      *a1 = v19;
      char v18 = (_OWORD *)*v15;
    }
    sub_100046C90(a1[1], (uint64_t *)v18);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    goto LABEL_28;
  }
  return a1;
}

void sub_10094E740(_Unwind_Exception *a1)
{
  sub_10005D144(v1);
  _Unwind_Resume(a1);
}

void *sub_10094E754(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10094E7D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_10094E870(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_10094EAD8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10094EAE8()
{
}

void *sub_10094EAFC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A1DFF0;
  result[1] = v3;
  return result;
}

uint64_t sub_10094EB44(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A1DFF0;
  a2[1] = v2;
  return result;
}

const void **sub_10094EB70@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  sub_100945480(&v5, *(void *)(a1 + 8), *a2);
  sub_100056248(a3, &v5);
  return sub_1000577C4(&v5);
}

void sub_10094EBBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10094EBD0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10094EC10()
{
}

void *sub_10094EC1C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10094ECA4()
{
}

void *sub_10094ECB8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A1E080;
  result[1] = v3;
  return result;
}

uint64_t sub_10094ED00(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A1E080;
  a2[1] = v2;
  return result;
}

const void **sub_10094ED2C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a1 + 8);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(v5 + 64));
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v8;
  BOOL v12 = sub_10004D37C(&v7[1].__m_.__sig, &v18);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, uint64_t, void, void))(*(void *)v14 + 80))(&v17, v14, *(unsigned int *)(v5 + 80), 4, v4, 0, 0);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  sub_100056248(a3, &v17);
  return sub_1000577C4(&v17);
}

void sub_10094EE6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_10094EE98(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10094EED8()
{
}

void *sub_10094EEE4(void *a1)
{
  *a1 = off_101A1E100;
  sub_100060644(a1 + 1);
  return a1;
}

void sub_10094EF28(void *a1)
{
  *a1 = off_101A1E100;
  sub_100060644(a1 + 1);

  operator delete();
}

void *sub_10094EF8C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A1E100;
  sub_1000DFC90((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10094EFE0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10094EFF4(uint64_t a1, void *a2)
{
  *a2 = off_101A1E100;
  return sub_1000DFC90((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_10094F020(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 8));
}

void sub_10094F028(void *a1)
{
  sub_100060644(a1 + 1);

  operator delete(a1);
}

uint64_t sub_10094F064(uint64_t a1, char *a2)
{
  return sub_1000607A8(a1 + 8, *a2);
}

uint64_t sub_10094F070(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10094F0B0()
{
}

void *sub_10094F0BC(void *a1)
{
  *a1 = off_101A1E180;
  sub_100060644(a1 + 1);
  return a1;
}

void sub_10094F100(void *a1)
{
  *a1 = off_101A1E180;
  sub_100060644(a1 + 1);

  operator delete();
}

void *sub_10094F164(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A1E180;
  sub_1000DFC90((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10094F1B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10094F1CC(uint64_t a1, void *a2)
{
  *a2 = off_101A1E180;
  return sub_1000DFC90((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_10094F1F8(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 8));
}

void sub_10094F200(void *a1)
{
  sub_100060644(a1 + 1);

  operator delete(a1);
}

uint64_t sub_10094F23C(uint64_t a1, char *a2)
{
  return sub_1000607A8(a1 + 8, *a2);
}

uint64_t sub_10094F248(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10094F288()
{
}

void *sub_10094F294(void *a1)
{
  *a1 = off_101A1E200;
  sub_100060644(a1 + 2);
  return a1;
}

void sub_10094F2D8(void *a1)
{
  *a1 = off_101A1E200;
  sub_100060644(a1 + 2);

  operator delete();
}

void *sub_10094F33C(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A1E200;
  v2[1] = v3;
  sub_1000DFC90((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_10094F394(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10094F3A8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_101A1E200;
  a2[1] = v2;
  return sub_1000DFC90((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_10094F3D8(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 16));
}

void sub_10094F3E0(void *a1)
{
  sub_100060644(a1 + 2);

  operator delete(a1);
}

void sub_10094F41C(uint64_t a1)
{
  sub_1000DFC90((uint64_t)v1, a1 + 16);
  operator new();
}

void sub_10094F4E4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10094F4F0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10094F530()
{
}

void **sub_10094F53C(void *a1)
{
  uint64_t v2 = a1;
  sub_1000607A8((uint64_t)a1, 1);
  return sub_1002BFA38(&v2);
}

void sub_10094F574(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002BFA38((void **)va);
  _Unwind_Resume(a1);
}

void *sub_10094F588(void *a1)
{
  *a1 = off_101A1E280;
  sub_100060644(a1 + 1);
  return a1;
}

void sub_10094F5CC(void *a1)
{
  *a1 = off_101A1E280;
  sub_100060644(a1 + 1);

  operator delete();
}

void *sub_10094F630(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = operator new(0x30uLL);
  void *v3 = off_101A1E280;
  sub_1000DFC90((uint64_t)(v3 + 1), v2);
  void v3[5] = *(void *)(a1 + 40);
  return v3;
}

void sub_10094F698(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10094F6AC(uint64_t a1, void *a2)
{
  *a2 = off_101A1E280;
  uint64_t result = sub_1000DFC90((uint64_t)(a2 + 1), a1 + 8);
  a2[5] = *(void *)(a1 + 40);
  return result;
}

void *sub_10094F700(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 8));
}

void sub_10094F708(void *a1)
{
  sub_100060644(a1 + 1);

  operator delete(a1);
}

uint64_t sub_10094F744(uint64_t a1, char *a2)
{
  return sub_1000607A8(a1 + 8, *a2);
}

uint64_t sub_10094F750(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10094F790()
{
}

uint64_t sub_10094F79C(void **a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0E208, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0E208))
  {
    sub_100058DB0(v8, "urn:service:sos.police");
    char v9 = 1;
    sub_100058DB0(v10, "urn:service:sos.ambulance");
    char v11 = 2;
    sub_100058DB0(v12, "urn:service:sos.fire");
    char v13 = 4;
    sub_100058DB0(v14, "urn:service:sos.marine");
    char v15 = 8;
    sub_100058DB0(v16, "urn:service:sos.mountain");
    char v17 = 16;
    sub_10094FA18((uint64_t)v8, 5);
    for (uint64_t i = 0; i != -20; i -= 4)
    {
      if (SHIBYTE(v16[i + 2]) < 0) {
        operator delete((void *)v16[i]);
      }
    }
    __cxa_atexit((void (*)(void *))sub_10094F9EC, &qword_101B0E210, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0E208);
  }
  uint64_t v2 = qword_101B0E218;
  if (!qword_101B0E218) {
    return 0;
  }
  uint64_t v3 = &qword_101B0E218;
  do
  {
    char v4 = sub_100046FE8((void *)(v2 + 32), a1);
    if (v4 >= 0) {
      uint64_t v5 = (uint64_t *)v2;
    }
    else {
      uint64_t v5 = (uint64_t *)(v2 + 8);
    }
    if (v4 >= 0) {
      uint64_t v3 = (uint64_t *)v2;
    }
    uint64_t v2 = *v5;
  }
  while (*v5);
  if (v3 == &qword_101B0E218 || (sub_100046FE8(a1, (void **)v3 + 4) & 0x80) != 0) {
    return 0;
  }
  else {
    return *((unsigned __int8 *)v3 + 56);
  }
}

void sub_10094F974(_Unwind_Exception *a1)
{
  uint64_t v3 = 0;
  while (1)
  {
    if (*(char *)(v1 + v3 + 151) < 0) {
      operator delete(*(void **)(v1 + v3 + 128));
    }
    v3 -= 32;
    if (v3 == -160)
    {
      __cxa_guard_abort(&qword_101B0E208);
      _Unwind_Resume(a1);
    }
  }
}

uint64_t sub_10094F9EC(uint64_t a1)
{
  return a1;
}

uint64_t sub_10094FA18(uint64_t result, uint64_t a2)
{
  qword_101B0E220 = 0;
  qword_101B0E218 = 0;
  qword_101B0E210 = (uint64_t)&qword_101B0E218;
  if (a2)
  {
    uint64_t v2 = result;
    uint64_t v3 = 0;
    uint64_t v4 = result + 32 * a2;
    uint64_t v5 = &qword_101B0E218;
    while (1)
    {
      if (v5 == &qword_101B0E218)
      {
        uint64_t v6 = &qword_101B0E218;
      }
      else
      {
        if (v3)
        {
          do
          {
            uint64_t v6 = (uint64_t *)v3;
            uint64_t v3 = *(void *)(v3 + 8);
          }
          while (v3);
        }
        else
        {
          uint64_t v7 = &qword_101B0E218;
          do
          {
            uint64_t v6 = (uint64_t *)v7[2];
            BOOL v8 = *v6 == (void)v7;
            uint64_t v7 = v6;
          }
          while (v8);
        }
        uint64_t result = sub_100046FE8(v6 + 4, (void **)v2);
        uint64_t v3 = qword_101B0E218;
        if ((result & 0x80) == 0)
        {
          if (qword_101B0E218)
          {
            char v9 = &qword_101B0E218;
            do
            {
              while (1)
              {
                uint64_t v6 = (uint64_t *)v3;
                uint64_t v10 = (void *)(v3 + 32);
                if ((sub_100046FE8((void *)v2, (void **)(v3 + 32)) & 0x80) == 0) {
                  break;
                }
                uint64_t v3 = *v6;
                char v9 = v6;
                if (!*v6) {
                  goto LABEL_24;
                }
              }
              uint64_t result = sub_100046FE8(v10, (void **)v2);
              if ((result & 0x80) == 0) {
                goto LABEL_21;
              }
              char v9 = v6 + 1;
              uint64_t v3 = v6[1];
            }
            while (v3);
          }
          else
          {
LABEL_23:
            char v9 = &qword_101B0E218;
            uint64_t v6 = &qword_101B0E218;
          }
LABEL_24:
          char v11 = (char *)operator new(0x40uLL);
          BOOL v12 = v11 + 32;
          if (*(char *)(v2 + 23) < 0)
          {
            sub_10004FC84(v12, *(void **)v2, *(void *)(v2 + 8));
          }
          else
          {
            long long v13 = *(_OWORD *)v2;
            *((void *)v11 + 6) = *(void *)(v2 + 16);
            *(_OWORD *)BOOL v12 = v13;
          }
          v11[56] = *(unsigned char *)(v2 + 24);
          *(void *)char v11 = 0;
          *((void *)v11 + 1) = 0;
          *((void *)v11 + 2) = v6;
          uint64_t *v9 = (uint64_t)v11;
          if (*(void *)qword_101B0E210)
          {
            qword_101B0E210 = *(void *)qword_101B0E210;
            char v11 = (char *)*v9;
          }
          uint64_t result = (uint64_t)sub_100046C90((uint64_t *)qword_101B0E218, (uint64_t *)v11);
          ++qword_101B0E220;
          goto LABEL_30;
        }
      }
      if (!v3) {
        goto LABEL_23;
      }
      char v9 = v6 + 1;
LABEL_21:
      if (!*v9) {
        goto LABEL_24;
      }
LABEL_30:
      v2 += 32;
      if (v2 == v4) {
        return result;
      }
      uint64_t v5 = (uint64_t *)qword_101B0E210;
      uint64_t v3 = qword_101B0E218;
    }
  }
  return result;
}

void sub_10094FBD4(_Unwind_Exception *a1)
{
  operator delete(v1);
  sub_1000DA2E4(*(char **)(v2 + 536));
  _Unwind_Resume(a1);
}

uint64_t sub_10094FBF8()
{
  return _MGGetBoolAnswer(@"wapi");
}

uint64_t sub_10094FC04()
{
  return _MGGetBoolAnswer(@"green-tea");
}

BOOL sub_10094FC10()
{
  CFTypeRef cf2 = 0;
  uint64_t v3 = MGCopyAnswer();
  sub_100225AE0(&cf2, (CFTypeRef *)&v3);
  if (cf2) {
    char v0 = sub_1000810B8;
  }
  else {
    char v0 = 0;
  }
  if (v0) {
    BOOL v1 = CFEqual(@"NonUI", cf2) != 0;
  }
  else {
    BOOL v1 = 0;
  }
  sub_1000558F4(&cf2);
  return v1;
}

void sub_10094FCA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_10094FCB4@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

void *sub_10094FCFC@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

void *sub_10094FD44@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

void *sub_10094FD8C@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

void *sub_10094FDD4@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

void *sub_10094FE1C@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

void *sub_10094FE64@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

void *sub_10094FEAC@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

void *sub_10094FEF4@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

void *sub_10094FF3C@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

void *sub_10094FF84@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_1000171E8(a1, (CFTypeRef *)&v3);
}

void *sub_10094FFCC@<X0>(void *a1@<X8>)
{
  uint64_t v3 = MGCopyAnswer();
  return sub_100225AE0(a1, (CFTypeRef *)&v3);
}

uint64_t sub_100950018()
{
  return _MGGetBoolAnswer(@"AirplaneMode");
}

uint64_t sub_100950024@<X0>(void *a1@<X1>, uint64_t *a2@<X8>)
{
  if (*a1) {
    uint64_t v3 = sub_100083F10;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3) {
    uint64_t result = MGCopyMultipleAnswers();
  }
  else {
    uint64_t result = 0;
  }
  *a2 = result;
  return result;
}

uint64_t sub_100950078(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_1000F0058((uint64_t)v7, a5);
  uint64_t v5 = MGRegisterForUpdates();
  sub_10003B34C(v7);
  return v5;
}

void sub_100950154(_Unwind_Exception *a1)
{
  sub_10003B34C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100950170(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  if (!v1) {
    sub_10007B600();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

uint64_t sub_1009501C0(uint64_t a1, uint64_t a2)
{
  return _MGCancelNotifications(a2);
}

void sub_1009501C8(Registry **a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    BOOL v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  v64[0] = (void **)v7;
  char v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)v64);
  if (!v11)
  {
    std::mutex::unlock(v6);
    goto LABEL_9;
  }
  uint64_t v12 = v11[3];
  long long v13 = (std::__shared_weak_count *)v11[4];
  if (!v13)
  {
    std::mutex::unlock(v6);
    if (v12) {
      goto LABEL_11;
    }
LABEL_9:
    *a3 = 0u;
    a3[1] = 0u;
    return;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  if (!v12)
  {
    *a3 = 0u;
    a3[1] = 0u;
    goto LABEL_90;
  }
LABEL_11:
  uint64_t v63 = 0;
  (*(void (**)(void ***__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v12 + 96))(v64, v12, a2, 1, @"ManagedHours", 0, 0);
  sub_10004EFE4(&v63, (CFTypeRef *)v64);
  sub_1000577C4((const void **)v64);
  if (v63) {
    uint64_t v14 = sub_100080778;
  }
  else {
    uint64_t v14 = 0;
  }
  if (!v14)
  {
    *a3 = 0u;
    a3[1] = 0u;
    sub_100057D78((const void **)&v63);
    if (!v13) {
      return;
    }
    goto LABEL_90;
  }
  uint64_t v42 = v63;
  long long v61 = 0u;
  long long v62 = 0u;
  id v15 = [v42 objectForKeyedSubscript:@"ExpirationDate"];
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && [v15 length])
  {
    uint64_t v16 = objc_opt_new();
    id v17 = [v16 dateFromString:v15];
    *(void *)&v52[0] = v17;
    if (v17) {
      CFRetain(v17);
    }
  }
  else
  {
    *(void *)&v52[0] = 0;
  }

  v64[0] = *((void ***)&v62 + 1);
  *((void *)&v62 + 1) = *(void *)&v52[0];
  *(void *)&v52[0] = 0;
  sub_10007CA64((const void **)v64);
  sub_10007CA64((const void **)v52);

  uint64_t v43 = [v42 objectForKeyedSubscript:@"TimeWindows"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    long long v59 = 0uLL;
    long long v60 = 0uLL;
    long long v57 = 0uLL;
    long long v58 = 0uLL;
    id obj = v43;
    id v46 = [obj countByEnumeratingWithState:&v57 objects:v66 count:16];
    if (v46)
    {
      uint64_t v45 = *(void *)v58;
      do
      {
        for (uint64_t i = 0; i != v46; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v58 != v45) {
            objc_enumerationMutation(obj);
          }
          std::string::size_type v50 = *(void **)(*((void *)&v57 + 1) + 8 * i);
          uint64_t v49 = objc_msgSend(obj, "objectForKeyedSubscript:");
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            long long v55 = 0u;
            long long v56 = 0u;
            long long v53 = 0u;
            long long v54 = 0u;
            id v18 = v49;
            id v19 = [v18 countByEnumeratingWithState:&v53 objects:v65 count:16];
            if (v19)
            {
              uint64_t v20 = *(void *)v54;
              do
              {
                CFStringRef v21 = 0;
                do
                {
                  if (*(void *)v54 != v20) {
                    objc_enumerationMutation(v18);
                  }
                  CFTypeID v22 = *(void **)(*((void *)&v53 + 1) + 8 * (void)v21);
                  objc_opt_class();
                  if (objc_opt_isKindOfClass())
                  {
                    memset(v52, 0, sizeof(v52));
                    DWORD2(v52[1]) = 7;
                    CFStringRef v23 = [v22 objectForKeyedSubscript:@"StartTime"];
                    sub_100950B80(&v51, a1, v23);
                    v64[0] = *((void ***)&v52[0] + 1);
                    *((void *)&v52[0] + 1) = v51;
                    char v51 = 0;
                    sub_10007CA64((const void **)v64);
                    sub_10007CA64(&v51);

                    uint64_t v24 = [v22 objectForKeyedSubscript:@"EndTime"];
                    sub_100950B80(&v51, a1, v24);
                    v64[0] = *(void ***)&v52[1];
                    *(void *)&v52[1] = v51;
                    char v51 = 0;
                    sub_10007CA64((const void **)v64);
                    sub_10007CA64(&v51);

                    if (*((void *)&v52[0] + 1)) {
                      int v25 = sub_1001908E4;
                    }
                    else {
                      int v25 = 0;
                    }
                    if (v25)
                    {
                      if (*(void *)&v52[1] ? sub_1001908E4 : 0)
                      {
                        id v27 = [v22 objectForKeyedSubscript:@"WindowType"];
                        objc_opt_class();
                        if (objc_opt_isKindOfClass())
                        {
                          if ([v27 isEqualToString:@"DiscountedRate"])
                          {
                            int v28 = 1;
                          }
                          else if ([v27 isEqualToString:@"OffPeak"])
                          {
                            int v28 = 2;
                          }
                          else if ([v27 isEqualToString:@"DiscountedRateAndOffPeak"])
                          {
                            int v28 = 3;
                          }
                          else
                          {
                            int v28 = 0;
                          }
                        }
                        else
                        {
                          int v28 = 0;
                        }

                        LODWORD(v52[0]) = v28;
                        id v29 = v50;
                        objc_opt_class();
                        if (objc_opt_isKindOfClass())
                        {
                          if ([v29 isEqualToString:@"Sunday"])
                          {
                            int v30 = 0;
                          }
                          else if ([v29 isEqualToString:@"Monday"])
                          {
                            int v30 = 1;
                          }
                          else if ([v29 isEqualToString:@"Tuesday"])
                          {
                            int v30 = 2;
                          }
                          else if ([v29 isEqualToString:@"Wednesday"])
                          {
                            int v30 = 3;
                          }
                          else if ([v29 isEqualToString:@"Thursday"])
                          {
                            int v30 = 4;
                          }
                          else if ([v29 isEqualToString:@"Friday"])
                          {
                            int v30 = 5;
                          }
                          else if ([v29 isEqualToString:@"Saturday"])
                          {
                            int v30 = 6;
                          }
                          else
                          {
                            int v30 = 7;
                          }
                        }
                        else
                        {
                          int v30 = 7;
                        }

                        DWORD2(v52[1]) = v30;
                        uint64_t v31 = *((void *)&v61 + 1);
                        if (*((void *)&v61 + 1) >= (unint64_t)v62)
                        {
                          uint64_t v33 = (uint64_t)(*((void *)&v61 + 1) - v61) >> 5;
                          unint64_t v34 = v33 + 1;
                          if ((unint64_t)(v33 + 1) >> 59) {
                            sub_10006A748();
                          }
                          uint64_t v35 = v62 - v61;
                          if ((uint64_t)(v62 - v61) >> 4 > v34) {
                            unint64_t v34 = v35 >> 4;
                          }
                          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFE0) {
                            unint64_t v36 = 0x7FFFFFFFFFFFFFFLL;
                          }
                          else {
                            unint64_t v36 = v34;
                          }
                          void v64[4] = (void **)&v62;
                          uint64_t v37 = (void **)sub_1000F5A68((uint64_t)&v62, v36);
                          CFTypeRef v38 = &v37[4 * v33];
                          v64[0] = v37;
                          v64[1] = v38;
                          v64[3] = &v37[4 * v39];
                          *(_DWORD *)CFTypeRef v38 = v52[0];
                          v38[1] = 0;
                          v38[1] = (void *)*((void *)&v52[0] + 1);
                          *((void *)&v52[0] + 1) = 0;
                          void v38[2] = 0;
                          void v38[2] = *(void **)&v52[1];
                          *(void *)&v52[1] = 0;
                          *((_DWORD *)v38 + 6) = DWORD2(v52[1]);
                          v64[2] = v38 + 4;
                          sub_1009511BC((uint64_t *)&v61, v64);
                          uint64_t v32 = *((void *)&v61 + 1);
                          sub_100951364((uint64_t)v64);
                        }
                        else
                        {
                          **((_DWORD **)&v61 + 1) = v52[0];
                          *(_OWORD *)(v31 + 8) = 0u;
                          *(void *)(v31 + 8) = *((void *)&v52[0] + 1);
                          *(void *)(v31 + 16) = *(void *)&v52[1];
                          *(_OWORD *)((char *)v52 + 8) = 0u;
                          *(_DWORD *)(v31 + 24) = v30;
                          uint64_t v32 = v31 + 32;
                        }
                        *((void *)&v61 + 1) = v32;
                      }
                    }
                    sub_10007CA64((const void **)&v52[1]);
                    sub_10007CA64((const void **)v52 + 1);
                  }
                  CFStringRef v21 = (char *)v21 + 1;
                }
                while (v19 != v21);
                id v40 = [v18 countByEnumeratingWithState:&v53 objects:v65 count:16];
                id v19 = v40;
              }
              while (v40);
            }
          }
        }
        id v46 = [obj countByEnumeratingWithState:&v57 objects:v66 count:16];
      }
      while (v46);
    }

    *a3 = v61;
    long long v41 = v62;
    long long v62 = 0uLL;
    long long v61 = 0uLL;
    a3[1] = v41;
  }
  else
  {
    *a3 = 0uLL;
    a3[1] = 0uLL;
  }

  sub_10007CA64((const void **)&v62 + 1);
  v64[0] = (void **)&v61;
  sub_10061B228(v64);

  sub_100057D78((const void **)&v63);
  if (v13) {
LABEL_90:
  }
    sub_10004D2C8(v13);
}

void sub_100950A1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48,int a49,__int16 a50,char a51,char a52)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100950B80(void *a1, Registry **a2, void *a3)
{
  id v5 = a3;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && [v5 length])
  {
    uint64_t v6 = objc_opt_new();
    [v6 setFormatOptions:1632];
    uint64_t v7 = [v6 dateFromString:v5];
    uint64_t v9 = v7;
    if (v7)
    {
      *a1 = v7;
      CFRetain(v7);
LABEL_18:

      goto LABEL_19;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *a2);
    char v11 = ServiceMap;
    if (v12 < 0)
    {
      long long v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v20 = (const void *)v12;
    uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v20);
    if (v16)
    {
      uint64_t v18 = v16[3];
      id v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
        if (!v18) {
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    id v17 = 0;
    char v19 = 1;
    if (!v18)
    {
LABEL_12:
      *a1 = 0;
      if (v19) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
LABEL_16:
    [v6 setFormatOptions:544];
    (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v18 + 104))(&v20, v18);
    [v6 setTimeZone:v20];
    sub_1005653C4(&v20);
    sub_1000C1674(a1, [v6 dateFromString:v5]);
    if (v19) {
      goto LABEL_18;
    }
LABEL_17:
    sub_10004D2C8(v17);
    goto LABEL_18;
  }
  *a1 = 0;
LABEL_19:
}

void sub_100950D68(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100950DC4(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 24)) {
    uint64_t v2 = sub_1001908E4;
  }
  else {
    uint64_t v2 = 0;
  }
  if (!v2) {
    return 1;
  }
  CFDateRef theDate = 0;
  getCurrentDate();
  double AbsoluteTime = CFDateGetAbsoluteTime(0);
  BOOL v5 = AbsoluteTime < CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 24));
  sub_10007CA64((const void **)&theDate);
  return v5;
}

void sub_100950E50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10007CA64((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t (**sub_100950E64(uint64_t a1, int a2, const void **a3, unsigned int a4))(void, void, void, void, void)
{
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)a1 = a2;
  sub_100602120((const void **)(a1 + 8), a3);
  *(unsigned char *)(a1 + 16) = 1;
  uint64_t v6 = (void (**)(uint64_t, uint64_t, _OWORD *, void, void))(a1 + 24);
  v9[1] = (uint64_t (*)(void, void, void, void, void))a4;
  v9[0] = (uint64_t (*)(void, void, void, void, void))sub_10095164C;
  if (v9 != (uint64_t (**)(void, void, void, void, void))(a1 + 24))
  {
    uint64_t v7 = *v6;
    if (*v6)
    {
      memset(v10, 0, sizeof(v10));
      v7(2, a1 + 24, v10, 0, 0);
      v9[0](2, v9, a1 + 24, 0, 0);
      (*(void (**)(uint64_t, _OWORD *, uint64_t (**)(void, void, void, void, void), void, void))&v10[0])(2, v10, v9, 0, 0);
      sub_100146540((uint64_t (**)(void, void, void, void, void))v10);
    }
    else
    {
      *(_DWORD *)(a1 + 32) = a4;
      *(void *)(a1 + 24) = sub_10095164C;
      v9[0] = 0;
    }
  }
  return sub_100146540(v9);
}

void sub_100950FA0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100950FAC(uint64_t *a1@<X0>, int64x2_t *a2@<X8>)
{
  unint64_t v13 = 0;
  int64x2_t v3 = 0uLL;
  int64x2_t v12 = 0u;
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  if (*a1 == v5)
  {
    unint64_t v10 = 0;
  }
  else
  {
    do
    {
      if ((*(_DWORD *)v4 & 0xFFFFFFFD) == 1)
      {
        sub_100950E64((uint64_t)&v14, *(_DWORD *)(v4 + 24), (const void **)(v4 + 8), 0);
        uint64_t v6 = v12.i64[1];
        if (v12.i64[1] >= v13)
        {
          uint64_t v7 = sub_1009513F8(&v12, (uint64_t)&v14);
        }
        else
        {
          *(_DWORD *)v12.i64[1] = v14;
          *(void *)(v6 + 8) = 0;
          *(void *)(v6 + 8) = v15;
          unsigned int v15 = 0;
          *(unsigned char *)(v6 + 16) = v16;
          sub_1009515A0((void *)(v6 + 24), v17);
          uint64_t v7 = (char *)(v6 + 56);
        }
        v12.i64[1] = (uint64_t)v7;
        sub_100146540((uint64_t (**)(void, void, void, void, void))v17);
        sub_10007CA64(&v15);
        sub_100950E64((uint64_t)&v14, *(_DWORD *)(v4 + 24), (const void **)(v4 + 16), 1u);
        uint64_t v8 = v12.i64[1];
        if (v12.i64[1] >= v13)
        {
          uint64_t v9 = sub_1009513F8(&v12, (uint64_t)&v14);
        }
        else
        {
          *(_DWORD *)v12.i64[1] = v14;
          *(void *)(v8 + 8) = 0;
          *(void *)(v8 + 8) = v15;
          unsigned int v15 = 0;
          *(unsigned char *)(v8 + 16) = v16;
          sub_1009515A0((void *)(v8 + 24), v17);
          uint64_t v9 = (char *)(v8 + 56);
        }
        v12.i64[1] = (uint64_t)v9;
        sub_100146540((uint64_t (**)(void, void, void, void, void))v17);
        sub_10007CA64(&v15);
      }
      v4 += 32;
    }
    while (v4 != v5);
    int64x2_t v3 = v12;
    unint64_t v10 = v13;
  }
  int64x2_t v12 = 0uLL;
  unint64_t v13 = 0;
  *a2 = v3;
  a2[1].i64[0] = v10;
  memset(v11, 0, sizeof(v11));
  uint64_t v14 = (int64x2_t *)v11;
  sub_100146490((void ***)&v14);
  uint64_t v14 = &v12;
  sub_100146490((void ***)&v14);
}

void sub_100951180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  sub_100146540(v18);
  sub_10007CA64(v17);
  a17 = (void **)&a13;
  sub_100146490(&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_1009511BC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100951234((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100951234(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v13 = a6;
  *((void *)&v13 + 1) = a7;
  long long v12 = v13;
  v11[0] = a1;
  v11[1] = &v12;
  void v11[2] = &v13;
  void v11[3] = 1;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      int v8 = *(_DWORD *)(a3 - 32);
      a3 -= 32;
      *(_DWORD *)(v7 - 32) = v8;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 24) = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 16) = *(void *)(a3 + 16);
      *(void *)(a3 + 16) = 0;
      *(_DWORD *)(v7 - 8) = *(_DWORD *)(a3 + 24);
      uint64_t v7 = *((void *)&v13 + 1) - 32;
      *((void *)&v13 + 1) -= 32;
    }
    while (a3 != a5);
    uint64_t v9 = v13;
  }
  sub_1009512E4((uint64_t)v11);
  return v9;
}

uint64_t sub_1009512E4(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10095131C((const void **)a1);
  }
  return a1;
}

const void **sub_10095131C(const void **result)
{
  uint64_t v1 = *((void *)result[2] + 1);
  uint64_t v2 = *((void *)result[1] + 1);
  while (v1 != v2)
  {
    sub_10007CA64((const void **)(v1 + 16));
    uint64_t result = sub_10007CA64((const void **)(v1 + 8));
    v1 += 32;
  }
  return result;
}

uint64_t sub_100951364(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

const void **sub_10095139C(const void **result, const void **a2)
{
  uint64_t v2 = (const void **)result[2];
  if (v2 != a2)
  {
    uint64_t v4 = result;
    do
    {
      void v4[2] = v2 - 4;
      sub_10007CA64(v2 - 2);
      uint64_t result = sub_10007CA64(v2 - 3);
      uint64_t v2 = (const void **)v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

char *sub_1009513F8(int64x2_t *a1, uint64_t a2)
{
  uint64_t v2 = 0x6DB6DB6DB6DB6DB7 * ((a1->i64[1] - a1->i64[0]) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x492492492492492) {
    sub_10006A748();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[1].i64[0] - a1->i64[0]) >> 3) > v3) {
    unint64_t v3 = 0xDB6DB6DB6DB6DB6ELL * ((a1[1].i64[0] - a1->i64[0]) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[1].i64[0] - a1->i64[0]) >> 3)) >= 0x249249249249249) {
    unint64_t v6 = 0x492492492492492;
  }
  else {
    unint64_t v6 = v3;
  }
  CFStringRef v21 = a1 + 1;
  if (v6)
  {
    if (v6 > 0x492492492492492) {
      sub_10006A7CC();
    }
    uint64_t v7 = (char *)operator new(56 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  int v8 = &v7[56 * v2];
  uint64_t v9 = &v7[56 * v6];
  uint64_t v20 = v9;
  *(_DWORD *)int v8 = *(_DWORD *)a2;
  *((void *)v8 + 1) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint8_t v8[16] = *(unsigned char *)(a2 + 16);
  sub_1009515A0((void *)v8 + 3, (void (**)(uint64_t))(a2 + 24));
  unint64_t v10 = v8 + 56;
  v19.i64[1] = (uint64_t)(v8 + 56);
  uint64_t v12 = a1->i64[0];
  unint64_t v11 = a1->u64[1];
  if (v11 == a1->i64[0])
  {
    int64x2_t v15 = vdupq_n_s64(v11);
  }
  else
  {
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = &v8[v13];
      *((_DWORD *)v14 - 14) = *(_DWORD *)(v11 + v13 - 56);
      *((void *)v14 - 6) = 0;
      *((void *)v14 - 6) = *(void *)(v11 + v13 - 48);
      *(void *)(v11 + v13 - 48) = 0;
      *(v14 - 40) = *(unsigned char *)(v11 + v13 - 40);
      sub_1009515A0(&v8[v13 - 32], (void (**)(uint64_t))(v11 + v13 - 32));
      v13 -= 56;
    }
    while (v11 + v13 != v12);
    int64x2_t v15 = *a1;
    v8 += v13;
    unint64_t v10 = (char *)v19.i64[1];
    uint64_t v9 = v20;
  }
  a1->i64[0] = (uint64_t)v8;
  a1->i64[1] = (uint64_t)v10;
  int64x2_t v19 = v15;
  char v16 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v9;
  uint64_t v20 = v16;
  uint64_t v18 = v15.i64[0];
  sub_1009515E8((uint64_t)&v18);
  return v10;
}

void *sub_1009515A0(void *a1, void (**a2)(uint64_t))
{
  *a1 = 0;
  a1[1] = 0;
  if (*a2) {
    (*a2)(2);
  }
  return a1;
}

uint64_t sub_1009515E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;
    sub_100146540((uint64_t (**)(void, void, void, void, void))(i - 32));
    sub_10007CA64((const void **)(i - 48));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

_UNKNOWN **sub_10095164C(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v5 = a1;
  switch(v5)
  {
    case 1:
      uint64_t result = 0;
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
      *(void *)a3 = sub_10095164C;
      break;
    case 2:
      uint64_t result = 0;
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
      *(void *)a3 = sub_10095164C;
      goto LABEL_5;
    case 3:
      if (a4) {
      else
      }
        BOOL v8 = a5 == &unk_1014FD5AC;
      if (v8) {
        uint64_t result = (_UNKNOWN **)(a2 + 8);
      }
      else {
        uint64_t result = 0;
      }
      break;
    case 4:
      return result;
    default:
      uint64_t result = 0;
LABEL_5:
      *(void *)a2 = 0;
      break;
  }
  return result;
}

void sub_100951884()
{
}

void sub_1009519AC()
{
}

void sub_100951D18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100951F24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100952154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100952348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_10095253C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1009526B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10095281C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100952A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_100952B7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *sub_100952E7C(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = sub_1001577CC(result, a4);
    uint64_t v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_100952ED4(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

id sub_100952EF0(uint64_t a1)
{
  uint64_t v1 = *(uint64_t ***)(a1 + 32);
  id v2 = objc_alloc((Class)CLLocationManager);
  unint64_t v3 = +[NSBundle bundleWithIdentifier:*v1[1]];
  id v4 = [v2 initWithEffectiveBundle:v3 delegate:**v1 onQueue:*(void *)(**v1 + 32)];
  uint64_t v5 = **v1;
  unint64_t v6 = *(void **)(v5 + 16);
  *(void *)(v5 + 16) = v4;

  objc_msgSend(*(id *)(**v1 + 16), "setDelegate:");
  if (*(_DWORD *)v1[2] == 1) {
    uint64_t v7 = &CLLocationDistanceMax;
  }
  else {
    uint64_t v7 = &kCLDistanceFilterNone;
  }
  [*(id *)(**v1 + 16) setDistanceFilter:*v7];
  uint64_t v8 = *(int *)v1[3];
  if (v8 >= 7) {
    uint64_t v9 = &kCLLocationAccuracyNearestTenMeters;
  }
  else {
    uint64_t v9 = (const CLLocationAccuracy *)*(&off_101A1E490 + v8);
  }
  double v10 = *v9;
  unint64_t v11 = *(void **)(**v1 + 16);

  return [v11 setDesiredAccuracy:v10];
}

void sub_100953000(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id **sub_100953010(id **result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {

    operator delete();
  }
  return result;
}

id **sub_100953068(uint64_t a1)
{
  uint64_t v18 = (id *)a1;
  if (*(void *)(*(void *)a1 + 24))
  {
    double v3 = *(double *)(a1 + 8);
    double v2 = *(double *)(a1 + 16);
    double v4 = *(double *)(a1 + 24);
    id v5 = objc_alloc((Class)CLCircularRegion);
    CLLocationCoordinate2D v6 = CLLocationCoordinate2DMake(v3, v2);
    id v7 = objc_msgSend(v5, "initWithCenter:radius:identifier:", *(void *)(a1 + 32), v6.latitude, v6.longitude, v4);
    BOOL v8 = v3 < -90.0 || v3 > 90.0;
    if (v8)
    {
      uint64_t v9 = **(NSObject ***)(*(void *)a1 + 8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid latitude", buf, 2u);
      }
    }
    if (v2 > 180.0 || v2 < -180.0)
    {
      double v10 = **(NSObject ***)(*(void *)a1 + 8);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid longitude", buf, 2u);
      }
      LOBYTE(v8) = 1;
    }
    if (v4 <= 0.0)
    {
      uint64_t v13 = **(NSObject ***)(*(void *)a1 + 8);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid radius", buf, 2u);
      }
    }
    else
    {
      BOOL v11 = !v8;
      if (!v7) {
        BOOL v11 = 0;
      }
      if (v11)
      {
        [v7 setEmergency:0];
        [*(id *)(*(void *)a1 + 16) startMonitoringForRegion:v7];
LABEL_26:

        return sub_100953010(&v18);
      }
    }
    uint64_t v14 = *(void **)a1;
    int64x2_t v15 = **(NSObject ***)(*(void *)a1 + 8);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to setup Circular geofence", buf, 2u);
      uint64_t v14 = *(void **)a1;
    }
    char v16 = (void (***)(void, uint8_t *))v14[3];
    sub_100058DB0(buf, (char *)[*(id *)(a1 + 32) UTF8String]);
    (**v16)(v16, buf);
    if (v20 < 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_26;
  }
  uint64_t v12 = **(NSObject ***)(*(void *)a1 + 8);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Delegate not found", buf, 2u);
  }
  return sub_100953010(&v18);
}

void sub_100953354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }

  sub_100953010(&a10);
  _Unwind_Resume(a1);
}

void sub_100953390(uint64_t a1)
{
  double v2 = *(uint64_t **)(a1 + 40);
  if (*(void *)(*v2 + 24))
  {
    id v3 = objc_alloc_init((Class)NSMutableArray);
    id v5 = (double *)v2[1];
    double v4 = (double *)v2[2];
    if (v4 == v5)
    {
      int64x2_t v15 = **(NSObject ***)(*v2 + 8);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid input array of 0 size...", (uint8_t *)__p, 2u);
      }
      uint64_t v12 = 0;
    }
    else
    {
      do
      {
        CLLocationDegrees v6 = *v5;
        CLLocationDegrees v7 = v5[1];
        id v8 = objc_alloc((Class)_CLVertex);
        CLLocationCoordinate2D v9 = CLLocationCoordinate2DMake(v6, v7);
        id v10 = objc_msgSend(v8, "initWithCoordinate:", v9.latitude, v9.longitude);
        [v3 addObject:v10];

        v5 += 2;
      }
      while (v5 != v4);
      id v11 = [objc_alloc((Class)_CLPolygonalRegion) initWithVertices:v3 identifier:v2[4]];
      uint64_t v12 = v11;
      if (v11)
      {
        [v11 setEmergency:0];
        [*(id *)(*v2 + 16) startMonitoringForRegion:v12];
        id v13 = v12;
      }
      else
      {
        uint64_t v16 = *v2;
        id v17 = **(NSObject ***)(*v2 + 8);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to setup Polygonal geofence", (uint8_t *)__p, 2u);
          uint64_t v16 = *v2;
        }
        uint64_t v18 = *(void (****)(void, void **))(v16 + 24);
        sub_100058DB0(__p, (char *)[ (id) v2[4] UTF8String]);
        (**v18)(v18, __p);
        if (v22 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  else
  {
    uint64_t v14 = **(NSObject ***)(*v2 + 8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Delegate not found", (uint8_t *)__p, 2u);
    }
    uint64_t v12 = 0;
  }
  int64x2_t v19 = *(void ***)(a1 + 32);
  char v20 = *v19;
  uint64_t *v19 = v12;
}

void sub_1009535F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

id **sub_10095363C(uint64_t a1)
{
  id v3 = (id *)a1;
  if (*(void *)(*(void *)a1 + 16))
  {
    [*(id *)(*(void *)a1 + 16) stopMonitoringForRegion:*(void *)(a1 + 8)];
  }
  else
  {
    uint64_t v1 = **(NSObject ***)(*(void *)a1 + 8);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Failed to get location manager...", buf, 2u);
    }
  }
  return sub_10003B50C(&v3);
}

void sub_1009536CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B50C((id **)va);
  _Unwind_Resume(a1);
}

id **sub_1009536E0(id *a1)
{
  int64x2_t v15 = a1;
  double v2 = [*((id *)*a1 + 2) monitoredRegions];
  uint64_t v14 = v2;
  if (v2)
  {
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    id v3 = v2;
    id v4 = [v3 countByEnumeratingWithState:&v16 objects:v22 count:16];
    if (v4)
    {
      uint64_t v5 = *(void *)v17;
      do
      {
        for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v17 != v5) {
            objc_enumerationMutation(v3);
          }
          id v7 = *(id *)(*((void *)&v16 + 1) + 8 * i);
          if (v7)
          {
            id v8 = (id *)*a1;
            CLLocationCoordinate2D v9 = **((void **)*a1 + 1);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 138412290;
              id v21 = v7;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Stopping monitoring for: %@", buf, 0xCu);
              id v8 = (id *)*a1;
            }
            [v8[2] stopMonitoringForRegion:v7];
          }
        }
        id v4 = [v3 countByEnumeratingWithState:&v16 objects:v22 count:16];
      }
      while (v4);
    }

    id v10 = **((void **)*a1 + 1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      id v11 = "#I Resetted Monitored Regions";
      uint64_t v12 = buf;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v11, v12, 2u);
    }
  }
  else
  {
    id v10 = **((void **)*a1 + 1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v22 = 0;
      id v11 = "#I No actively monitored regions...";
      uint64_t v12 = v22;
      goto LABEL_17;
    }
  }

  return sub_1001217C8(&v15);
}

void sub_100953900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);

  sub_1001217C8((id **)va);
  _Unwind_Resume(a1);
}

id **sub_100953940(id *a1)
{
  uint64_t v5 = a1;
  id v1 = *a1;
  double v2 = (void *)*((void *)*a1 + 2);
  if (v2)
  {
    [v2 requestLocation];
  }
  else
  {
    id v3 = **((void **)v1 + 1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to get location manager...", buf, 2u);
    }
  }
  return sub_1001217C8(&v5);
}

void sub_1009539C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001217C8((id **)va);
  _Unwind_Resume(a1);
}

void sub_1009539DC()
{
}

void sub_100953A04(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0E228, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0E228))
  {
    sub_10095400C((uint64_t)xmmword_101B0E230, ", \t\n", 0, 0);
    __cxa_atexit((void (*)(void *))sub_100953D88, xmmword_101B0E230, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0E228);
  }
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  sub_1009540A4((uint64_t)&v32, a1, xmmword_101B0E230);
  sub_100953DCC((uint64_t)&v32, (char *)v23);
  sub_100953EC0((uint64_t)&v32, (char *)&v14);
  while (!v20)
  {
    if (!v29) {
      goto LABEL_34;
    }
LABEL_9:
    int v13 = 0;
    unint64_t v4 = (unint64_t)v30[1];
    if ((v31 & 0x80u) == 0) {
      uint64_t v5 = v30;
    }
    else {
      uint64_t v5 = (void **)v30[0];
    }
    if ((v31 & 0x80u) == 0) {
      unint64_t v4 = v31;
    }
    if (!v4)
    {
LABEL_33:
      uint64_t v12 = std::bad_cast::bad_cast(&v37);
      v37.__vftable = (std::bad_cast_vtbl *)&off_1019A4B10;
      sub_100158D10((uint64_t)v12);
    }
    int v45 = 0;
    int v6 = *(unsigned __int8 *)v5;
    if (v6 == 45 || (id v7 = v5, v6 == 43))
    {
      if ((v31 & 0x80u) != 0) {
        id v7 = (void **)((char *)v30[0] + 1);
      }
      else {
        id v7 = (void **)((char *)v30 + 1);
      }
    }
    v40[0] = 0;
    int v41 = 1;
    uint64_t v42 = &v45;
    uint64_t v43 = v7;
    __int16 v44 = (char *)v5 + v4;
    char v8 = sub_1007E8D8C((uint64_t)v40);
    int v9 = v45;
    if (v6 == 45)
    {
      if (v45 < 0x80000001) {
        char v10 = v8;
      }
      else {
        char v10 = 0;
      }
      if ((v10 & 1) == 0) {
        goto LABEL_33;
      }
      int v9 = -v45;
    }
    else
    {
      if (v45 >= 0) {
        char v11 = v8;
      }
      else {
        char v11 = 0;
      }
      if ((v11 & 1) == 0) {
        goto LABEL_33;
      }
    }
    int v13 = v9;
    if (v9 >= 1) {
      sub_10078C71C((uint64_t **)a2, &v13, &v13);
    }
    sub_1009545B0((uint64_t)v23);
  }
  if (!v29) {
    __assert_rtn("dereference", "token_iterator.hpp", 59, "valid_");
  }
  if (v18 != v27 || v19 != v28) {
    goto LABEL_9;
  }
LABEL_34:
  if (v22 < 0) {
    operator delete(__p);
  }
  if (v17 < 0) {
    operator delete(v16);
  }
  if (v15 < 0) {
    operator delete(v14);
  }
  if ((char)v31 < 0) {
    operator delete(v30[0]);
  }
  if (v26 < 0) {
    operator delete(v25);
  }
  if (v24 < 0) {
    operator delete(v23[0]);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(*((void **)&v34 + 1));
  }
  if (SBYTE7(v34) < 0) {
    operator delete((void *)v33);
  }
}

void sub_100953D24()
{
}

void sub_100953D3C()
{
}

void sub_100953D44()
{
}

void sub_100953D4C()
{
}

void sub_100953D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  sub_100953FB8((uint64_t)&a11);
  sub_100953FB8((uint64_t)&a25);
  sub_10008AF64((uint64_t)&a39);
  sub_1000346F8(v39, *(void **)(v39 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100953D88(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100953DCC(uint64_t a1@<X0>, char *a2@<X8>)
{
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)unint64_t v4 = *(_OWORD *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
  }
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 56);
  }
  uint64_t v8 = *(void *)(a1 + 64);
  char v9 = *(unsigned char *)(a1 + 72);
  sub_10095418C(a2, (long long *)v4, *(void *)a1, *(void *)(a1 + 8));
  if (SHIBYTE(v7) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v5) < 0) {
    operator delete(v4[0]);
  }
}

void sub_100953E94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100953EC0(uint64_t a1@<X0>, char *a2@<X8>)
{
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)unint64_t v4 = *(_OWORD *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
  }
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 56);
  }
  uint64_t v8 = *(void *)(a1 + 64);
  char v9 = *(unsigned char *)(a1 + 72);
  sub_10095418C(a2, (long long *)v4, *(void *)(a1 + 8), *(void *)(a1 + 8));
  if (SHIBYTE(v7) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v5) < 0) {
    operator delete(v4[0]);
  }
}

void sub_100953F8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100953FB8(uint64_t a1)
{
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_10095400C(uint64_t a1, char *a2, char *a3, int a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_100058DB0((void *)(a1 + 24), a2);
  *(_WORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = a4;
  *(unsigned char *)(a1 + 56) = 0;
  if (a3) {
    sub_10003ED78((std::string *)a1, a3);
  }
  return a1;
}

void sub_100954070(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009540A4(uint64_t a1, uint64_t *a2, long long *a3)
{
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = (uint64_t *)*a2;
  }
  *(void *)a1 = v5;
  uint64_t v6 = *((unsigned __int8 *)a2 + 23);
  if ((v6 & 0x80u) == 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = (uint64_t *)*a2;
  }
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = a2[1];
  }
  *(void *)(a1 + 8) = (char *)v7 + v6;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v8 = *a3;
    *(void *)(a1 + 32) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 16) = v8;
  }
  char v9 = (unsigned char *)(a1 + 40);
  if (*((char *)a3 + 47) < 0)
  {
    sub_10004FC84(v9, *((void **)a3 + 3), *((void *)a3 + 4));
  }
  else
  {
    long long v10 = *(long long *)((char *)a3 + 24);
    *(void *)(a1 + 56) = *((void *)a3 + 5);
    *(_OWORD *)char v9 = v10;
  }
  uint64_t v11 = *((void *)a3 + 6);
  *(unsigned char *)(a1 + 72) = *((unsigned char *)a3 + 56);
  *(void *)(a1 + 64) = v11;
  return a1;
}

void sub_100954170(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

char *sub_10095418C(char *__dst, long long *a2, uint64_t a3, uint64_t a4)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v8 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v8;
  }
  char v9 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(v9, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v10 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)char v9 = v10;
  }
  uint64_t v11 = *((void *)a2 + 6);
  __dst[56] = *((unsigned char *)a2 + 56);
  *((void *)__dst + 6) = v11;
  *((void *)__dst + 8) = a3;
  *((void *)__dst + 9) = a4;
  __dst[80] = 0;
  *((void *)__dst + 11) = 0;
  *((void *)__dst + 12) = 0;
  *((void *)__dst + 13) = 0;
  sub_100954280((uint64_t)__dst);
  return __dst;
}

void sub_100954244(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100954280(uint64_t result)
{
  if (!*(unsigned char *)(result + 80))
  {
    uint64_t v1 = result;
    double v2 = *(std::string::value_type **)(result + 72);
    if (*(std::string::value_type **)(result + 64) == v2) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = sub_1009542D0(result, (std::string::value_type **)(result + 64), v2, (std::string *)(result + 88));
    }
    *(unsigned char *)(v1 + 80) = result;
  }
  return result;
}

uint64_t sub_1009542D0(uint64_t a1, std::string::value_type **a2, std::string::value_type *a3, std::string *this)
{
  long long v8 = *a2;
  if (*(_DWORD *)(a1 + 52)) {
    goto LABEL_2;
  }
  if (v8 == a3) {
    return 0;
  }
  while (1)
  {
    BOOL v9 = sub_1009544B4(a1, *v8);
    long long v8 = *a2;
    if (!v9) {
      break;
    }
    *a2 = ++v8;
    if (v8 == a3)
    {
      long long v8 = a3;
      break;
    }
  }
  if (*(_DWORD *)(a1 + 52))
  {
LABEL_2:
    if (v8 != a3)
    {
      if (sub_100954534(a1, *v8))
      {
        if (*(unsigned char *)(a1 + 56))
        {
          ++*a2;
          *(unsigned char *)(a1 + 56) = 0;
LABEL_25:
          sub_10006E5EC(this, v8, *a2, *a2 - v8);
          return 1;
        }
      }
      else if (*(unsigned char *)(a1 + 56) || !sub_1009544B4(a1, **a2))
      {
        BOOL v13 = sub_1009544B4(a1, **a2);
        uint64_t v14 = *a2;
        if (v13)
        {
          *a2 = ++v14;
          long long v8 = v14;
        }
        while (v14 != a3 && !sub_1009544B4(a1, *v14) && !sub_100954534(a1, **a2))
        {
          uint64_t v14 = *a2 + 1;
          *a2 = v14;
        }
      }
      *(unsigned char *)(a1 + 56) = 1;
      goto LABEL_25;
    }
    if (!*(unsigned char *)(a1 + 56))
    {
      uint64_t v12 = 1;
      *(unsigned char *)(a1 + 56) = 1;
      sub_10006E5EC(this, a3, a3, 0);
      return v12;
    }
  }
  else if (v8 != a3)
  {
    BOOL v10 = sub_100954534(a1, *v8);
    uint64_t v11 = *a2;
    if (v10)
    {
      *a2 = v11 + 1;
    }
    else
    {
      while (v11 != a3 && !sub_1009544B4(a1, *v11) && !sub_100954534(a1, **a2))
      {
        uint64_t v11 = *a2 + 1;
        *a2 = v11;
      }
    }
    goto LABEL_25;
  }
  return 0;
}

BOOL sub_1009544B4(uint64_t a1, __darwin_ct_rune_t a2)
{
  if (*(char *)(a1 + 47) < 0)
  {
    if (*(void *)(a1 + 32)) {
      goto LABEL_3;
    }
  }
  else if (*(unsigned char *)(a1 + 47))
  {
LABEL_3:
    BOOL v2 = std::string::find((const std::string *)(a1 + 24), a2, 0) == -1;
    return !v2;
  }
  if (!*(unsigned char *)(a1 + 49)) {
    return 0;
  }
  if (a2 < 0) {
    __uint32_t v3 = __maskrune(a2, 0x4000uLL);
  }
  else {
    __uint32_t v3 = _DefaultRuneLocale.__runetype[a2] & 0x4000;
  }
  BOOL v2 = v3 == 0;
  return !v2;
}

BOOL sub_100954534(uint64_t a1, __darwin_ct_rune_t a2)
{
  if (*(char *)(a1 + 23) < 0)
  {
    if (*(void *)(a1 + 8)) {
      goto LABEL_3;
    }
  }
  else if (*(unsigned char *)(a1 + 23))
  {
LABEL_3:
    BOOL v2 = std::string::find((const std::string *)a1, a2, 0) == -1;
    return !v2;
  }
  if (!*(unsigned char *)(a1 + 48)) {
    return 0;
  }
  if (a2 < 0) {
    __uint32_t v3 = __maskrune(a2, 0x2000uLL);
  }
  else {
    __uint32_t v3 = _DefaultRuneLocale.__runetype[a2] & 0x2000;
  }
  BOOL v2 = v3 == 0;
  return !v2;
}

uint64_t sub_1009545B0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 80)) {
    __assert_rtn("increment", "token_iterator.hpp", 54, "valid_");
  }
  uint64_t result = sub_1009542D0(a1, (std::string::value_type **)(a1 + 64), *(std::string::value_type **)(a1 + 72), (std::string *)(a1 + 88));
  *(unsigned char *)(a1 + 80) = result;
  return result;
}

void sub_10095460C(void *a1@<X0>, void *a2@<X8>)
{
  id v3 = a1;
  *a2 = 0;
  a2[1] = 0;
  operator new();
}

void sub_100954690(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1009546A0(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v2 = a2;
  operator new();
}

void sub_100954724(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100954818((id **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100954740(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100954778(uint64_t result)
{
  uint64_t v1 = *(id **)(result + 24);
  if (v1)
  {

    operator delete();
  }
  return result;
}

uint64_t sub_1009547D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

id **sub_100954818(id **result, id *a2)
{
  uint64_t v2 = *result;
  void *result = a2;
  if (v2)
  {

    operator delete();
  }
  return result;
}

void *sub_100954878@<X0>(uint64_t *a1@<X1>, dispatch_object_t *a2@<X2>, uint64_t *a3@<X3>, void *a4@<X8>)
{
  long long v8 = operator new(0x20uLL);
  uint64_t result = sub_1009548EC(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1009548D8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1009548EC(void *a1, uint64_t *a2, dispatch_object_t *a3, uint64_t *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A1E550;
  sub_1009549C8(a1 + 3, a2, a3, a4);
  return a1;
}

void sub_100954934(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100954948(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A1E550;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100954968(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1E550;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1009549BC(uint64_t a1)
{
}

void *sub_1009549C8(void *a1, uint64_t *a2, dispatch_object_t *a3, uint64_t *a4)
{
  uint64_t v7 = *a2;
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v8 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  uint64_t v9 = *a4;
  BOOL v10 = [NetworkReachability alloc];
  uint64_t v13 = v7;
  uint64_t v14 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_object_t object = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  *a1 = [(NetworkReachability *)v10 initWithRegistry:&v13 andQueue:&object andLogger:v9];
  if (object) {
    dispatch_release(object);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v8) {
    dispatch_release(v8);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  return a1;
}

void sub_100954AAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12)
  {
    sub_10004D2C8(a12);
    if (!v13)
    {
LABEL_5:
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }
  else if (!v13)
  {
    goto LABEL_5;
  }
  dispatch_release(v13);
  if (!v12) {
LABEL_7:
  }
    _Unwind_Resume(exception_object);
LABEL_6:
  sub_10004D2C8(v12);
  goto LABEL_7;
}

void *sub_100954B00@<X0>(void *a1@<X8>)
{
  uint64_t result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  void *result = off_101A1E5E8;
  result[3] = &off_101A1EB68;
  *a1 = result + 3;
  a1[1] = result;
  return result;
}

void sub_100954B70(MobileActivationFactoryInterface *a1)
{
  MobileActivationFactoryInterface::~MobileActivationFactoryInterface(a1);

  operator delete();
}

void sub_100954BA8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A1E5E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100954BC8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1E5E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100954C1C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t MMSDataContextController::MMSDataContextController(uint64_t a1, dispatch_object_t *a2, void *a3, int a4, void *a5)
{
  uint64_t v9 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v20, kCtLoggingSystemName, "msg.mms.dcc");
  if (v9)
  {
    dispatch_retain(v9);
    BOOL v10 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    dispatch_retain(v9);
    dispatch_retain(v9);
    uint64_t v11 = dispatch_queue_create_with_target_V2("msg.mms.dcc", v10, v9);
  }
  else
  {
    uint64_t v12 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    uint64_t v11 = dispatch_queue_create("msg.mms.dcc", v12);
  }
  uint64_t v13 = v11;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  *(void *)(a1 + 32) = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  if (v13) {
    dispatch_release(v13);
  }
  if (v9)
  {
    dispatch_release(v9);
    dispatch_release(v9);
    dispatch_release(v9);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v18, &v20);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v18);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v18);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  if (v9) {
    dispatch_release(v9);
  }
  v19[0] = off_101999E18;
  v19[1] = sub_100955050;
  uint64_t v19[3] = v19;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v14) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v19);
  *(void *)a1 = off_101A1E638;
  *(_DWORD *)(a1 + 56) = a4;
  *(void *)(a1 + 64) = *a3;
  uint64_t v15 = a3[1];
  *(void *)(a1 + 72) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 80) = *a5;
  uint64_t v16 = a5[1];
  *(void *)(a1 + 88) = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  return a1;
}

void sub_100954F88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

const char *sub_100955050(int a1)
{
  uint64_t v1 = "msg.mms.dcc.?";
  if (a1 == 2) {
    uint64_t v1 = "msg.mms.dcc.2";
  }
  if (a1 == 1) {
    return "msg.mms.dcc.1";
  }
  else {
    return v1;
  }
}

void MMSDataContextController::create()
{
}

void sub_100955184(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    sub_10004D2C8(v2);
    if (!v1)
    {
LABEL_3:
      if (v3) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  dispatch_release(v1);
  if (v3) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

void sub_1009551D0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 56));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Attempting to activate data context", buf, 2u);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100955318(uint64_t a1)
{
  uint64_t v2 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 56));
  int v3 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 112);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Data context activation cycle running with total time: %lld", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 112);
  if (v6 >= 120)
  {
    uint64_t v7 = *v2;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Gave up on data context to become active after %lld seconds", (uint8_t *)&buf, 0xCu);
    }
    (*(void (**)(void, void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), *(unsigned int *)(a1 + 56));
    sub_1009551D0(a1);
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 64));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&buf);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_17:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_13;
    }
LABEL_18:
    uint64_t v19 = *(unsigned int *)(a1 + 56);
    sub_100058DB0(__p, "( CommCenter) Activating PDP context");
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v16 + 80))(v16, v19, 4, 1, __p, 0, 0);
    if (v32 < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_20;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_17;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (v16) {
    goto LABEL_18;
  }
LABEL_13:
  uint64_t v18 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Data service interface is null, failing all messages", (uint8_t *)&buf, 2u);
  }
  (*(void (**)(void, void))(**(void **)(a1 + 80) + 24))(*(void *)(a1 + 80), *(unsigned int *)(a1 + 56));
LABEL_20:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (v16)
  {
    Registry::getTimerService((uint64_t *)&buf, *(Registry **)(a1 + 64));
    uint64_t v20 = buf;
    sub_100058DB0(v28, "Data context wait timer");
    id v21 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v21;
    if (v21) {
      dispatch_retain(v21);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_1009557E4;
    aBlock[3] = &unk_101A1E668;
    aBlock[4] = a1;
    void aBlock[5] = v2;
    char v26 = _Block_copy(aBlock);
    sub_100118A44(v20, (uint64_t)v28, 0, 60000000, &object, &v26);
    uint64_t v22 = v30;
    uint64_t v30 = 0;
    uint64_t v23 = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = v22;
    if (v23)
    {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
      uint64_t v24 = v30;
      uint64_t v30 = 0;
      if (v24) {
        (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
      }
    }
    if (v26) {
      _Block_release(v26);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v29 < 0) {
      operator delete(v28[0]);
    }
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
  }
}

void sub_100955750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *aBlock, dispatch_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009557E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t result = *(void *)(v2 + 96);
  if (result)
  {
    *(void *)(v2 + 96) = 0;
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    unint64_t v4 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Data context activation wait finished, trying again", v5, 2u);
    }
    sub_1009558C0(v2);
    (*(void (**)(void, void, void))(**(void **)(v2 + 80) + 32))(*(void *)(v2 + 80), *(unsigned int *)(v2 + 56), *(void *)(v2 + 112));
    return sub_100955318(v2);
  }
  return result;
}

void sub_1009558C0(uint64_t a1)
{
  Registry::getTimerService((uint64_t *)&v2, *(Registry **)(a1 + 64));
  *(void *)(a1 + 112) = ((**v2)(v2) - *(void *)(a1 + 104)) / 1000000000;
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100955950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100955968(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100955A48(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100955B28(uint64_t a1)
{
  return *(void *)(a1 + 96) != 0;
}

MMSDataContextControllerInterface *sub_100955B38(MMSDataContextControllerInterface *this)
{
  *(void *)this = off_101A1E638;
  uint64_t v2 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  int v3 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v3) {
    sub_10004D2C8(v3);
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  MMSDataContextControllerInterface::~MMSDataContextControllerInterface(this);
  ctu::OsLogLogger::~OsLogLogger((MMSDataContextControllerInterface *)((char *)this + 40));
  sub_100087E88((void *)this + 1);
  return this;
}

void sub_100955C0C(MMSDataContextControllerInterface *this)
{
  *(void *)this = off_101A1E638;
  uint64_t v2 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  int v3 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v3) {
    sub_10004D2C8(v3);
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  MMSDataContextControllerInterface::~MMSDataContextControllerInterface(this);
  ctu::OsLogLogger::~OsLogLogger((MMSDataContextControllerInterface *)((char *)this + 40));
  sub_100087E88((void *)this + 1);

  operator delete();
}

void sub_100955D04()
{
}

uint64_t sub_100955D18(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100955D24(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100955DF0(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100955EC8);
  __cxa_rethrow();
}

void sub_100955E18(_Unwind_Exception *a1)
{
}

void sub_100955E30(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100955E68(uint64_t a1)
{
}

uint64_t sub_100955E84(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100955EC8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void sub_100955EF4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(void *)(v1 + 96);
  *(void *)(v1 + 96) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  Registry::getTimerService((uint64_t *)&v3, *(Registry **)(v1 + 64));
  *(void *)(v1 + 104) = (**v3)(v3);
  if (v4) {
    sub_10004D2C8(v4);
  }
  *(void *)(v1 + 112) = 0;
  sub_1009558C0(v1);
  sub_100955318(v1);
  operator delete();
}

void sub_100955FCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

void sub_10095600C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), *(unsigned int *)(v1 + 56));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Ending data context activation cycle", buf, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 96);
  *(void *)(v1 + 96) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  operator delete();
}

void sub_1009560FC()
{
}

void sub_100956128(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), *(unsigned int *)(v1 + 56));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Restarting data context activation cycle", buf, 2u);
  }
  sub_1009551D0(v1);
}

void sub_1009561F0()
{
}

void sub_10095621C(void **a1@<X8>)
{
  memset(__len, 0, sizeof(__len));
  uint64_t v5 = 0;
  int v4 = 0;
  sub_100072958(-2, (uint64_t)&__len[1], (uint64_t)__len, (uint64_t)&v5, (uint64_t)&v4);
  if (v2)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  else
  {
    if (v5) {
      sub_100072654(v5);
    }
    uint64_t v3 = *(void *)&__len[1];
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    if (v3)
    {
      sub_10008E4E8(a1, __len[0]);
      if (__len[0]) {
        memmove(*a1, *(const void **)&__len[1], __len[0]);
      }
      sub_100072654(*(uint64_t *)&__len[1]);
    }
  }
}

void sub_1009562C0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009562DC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A1E818;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009562FC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A1E818;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100956350(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10095637C(MachineIdProviderInterface *a1)
{
  MachineIdProviderInterface::~MachineIdProviderInterface(a1);

  operator delete();
}

void sub_100956664(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100956944(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100956C48(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100956F28(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10095717C(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10095741C(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1009576DC(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10095795C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100957C04(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100957EC4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100958160(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1009583F8(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1009586B4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100958978(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1009589D0(uint64_t a1)
{
  return a1;
}

void sub_1009589FC(uint64_t a1)
{
  operator delete();
}

void *sub_100958A48(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  *int v2 = off_101A1E8A8;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100958AA0(uint64_t a1, void *a2)
{
  *a2 = off_101A1E8A8;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100958AE8(uint64_t a1)
{
}

void sub_100958AF0(id *a1)
{
  operator delete(a1);
}

void sub_100958B2C(uint64_t a1, unsigned __int16 *a2)
{
  if (*a2 >= 0x100u)
  {
    char v3 = *(void (**)(void))(*(void *)(a1 + 8) + 16);
    v3();
  }
  else
  {
    id v4 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
    (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  }
}

void sub_100958BFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100958C10(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A1E918)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100958C50()
{
  return &off_101A1E918;
}

uint64_t sub_100958C5C(uint64_t a1)
{
  return a1;
}

void sub_100958C88(uint64_t a1)
{
  operator delete();
}

void *sub_100958CD4(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  *int v2 = off_101A1E938;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100958D2C(uint64_t a1, void *a2)
{
  *a2 = off_101A1E938;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100958D74(uint64_t a1)
{
}

void sub_100958D7C(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100958DB8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100958DD0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A1E998)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100958E10()
{
  return &off_101A1E998;
}

const void **sub_100958E1C@<X0>(uint64_t a1@<X0>, int a2@<W1>, __CFDictionary **a3@<X8>)
{
  *a3 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *a3 = Mutable;
  CFMutableDictionaryRef v7 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  long long v58 = v7;
  uint64_t v8 = *(void *)(a1 + 16);
  *(void *)&long long __dst = 0;
  *(void *)&long long valuePtr = v8;
  CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v9)
  {
    uint64_t v10 = __dst;
    *(void *)&long long __dst = v9;
    *(void *)&long long valuePtr = v10;
    sub_1000570E8((const void **)&valuePtr);
  }
  char v65 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_1000570E8((const void **)&__dst);
  CFDictionarySetValue(v7, @"deltaRxbytes", v65);
  sub_1000570E8(&v65);
  uint64_t v11 = *(void *)(a1 + 24);
  *(void *)&long long __dst = 0;
  *(void *)&long long valuePtr = v11;
  CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v12)
  {
    uint64_t v13 = __dst;
    *(void *)&long long __dst = v12;
    *(void *)&long long valuePtr = v13;
    sub_1000570E8((const void **)&valuePtr);
  }
  char v65 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_1000570E8((const void **)&__dst);
  CFDictionarySetValue(v58, @"deltaTxbytes", v65);
  sub_1000570E8(&v65);
  int v14 = *(_DWORD *)(a1 + 32);
  *(void *)&long long __dst = 0;
  LODWORD(valuePtr) = v14;
  CFNumberRef v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v15)
  {
    uint64_t v16 = __dst;
    *(void *)&long long __dst = v15;
    *(void *)&long long valuePtr = v16;
    sub_1000570E8((const void **)&valuePtr);
  }
  char v65 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_1000570E8((const void **)&__dst);
  CFDictionarySetValue(v58, @"epid", v65);
  sub_1000570E8(&v65);
  int v17 = *(_DWORD *)(a1 + 36);
  *(void *)&long long __dst = 0;
  LODWORD(valuePtr) = v17;
  CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v18)
  {
    uint64_t v19 = __dst;
    *(void *)&long long __dst = v18;
    *(void *)&long long valuePtr = v19;
    sub_1000570E8((const void **)&valuePtr);
  }
  char v65 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_1000570E8((const void **)&__dst);
  CFDictionarySetValue(v58, @"pid", v65);
  sub_1000570E8(&v65);
  if (*(unsigned char *)(a1 + 40)) {
    CFBooleanRef v20 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v20 = kCFBooleanFalse;
  }
  *(void *)&long long __dst = v20;
  *(void *)&long long valuePtr = 0;
  sub_100062778((const void **)&valuePtr);
  char v65 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_100062778((const void **)&__dst);
  CFDictionarySetValue(v58, @"isTcp", v65);
  sub_100062778(&v65);
  if (*(unsigned char *)(a1 + 41)) {
    CFBooleanRef v21 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v21 = kCFBooleanFalse;
  }
  *(void *)&long long __dst = v21;
  *(void *)&long long valuePtr = 0;
  sub_100062778((const void **)&valuePtr);
  char v65 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_100062778((const void **)&__dst);
  CFDictionarySetValue(v58, @"isUdp", v65);
  sub_100062778(&v65);
  if (*(unsigned char *)(a1 + 42)) {
    CFBooleanRef v22 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v22 = kCFBooleanFalse;
  }
  *(void *)&long long __dst = v22;
  *(void *)&long long valuePtr = 0;
  sub_100062778((const void **)&valuePtr);
  char v65 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_100062778((const void **)&__dst);
  CFDictionarySetValue(v58, @"isWifiAssist", v65);
  sub_100062778(&v65);
  uint64_t v23 = v58;
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 48);
    uint64_t v56 = *(void *)(a1 + 64);
  }
  if (SHIBYTE(v56) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v61 = v56;
  }
  long long v59 = 0;
  if (SHIBYTE(v61) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long valuePtr = __dst;
    uint64_t v63 = v61;
  }
  int64_t v64 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v24 = v59;
    long long v59 = v64;
    char v65 = v24;
    sub_1000558F4(&v65);
  }
  if (SHIBYTE(v63) < 0) {
    operator delete((void *)valuePtr);
  }
  xpc_object_t value = v59;
  long long v59 = 0;
  sub_1000558F4((const void **)&v59);
  if (SHIBYTE(v61) < 0) {
    operator delete((void *)__dst);
  }
  CFDictionarySetValue(v23, @"procName", value);
  sub_1000558F4((const void **)&value);
  if (SHIBYTE(v56) < 0) {
    operator delete(__p[0]);
  }
  int v25 = v58;
  if (*(char *)(a1 + 95) < 0)
  {
    sub_10004FC84(v53, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    *(_OWORD *)long long v53 = *(_OWORD *)(a1 + 72);
    uint64_t v54 = *(void *)(a1 + 88);
  }
  if (SHIBYTE(v54) < 0)
  {
    sub_10004FC84(&__dst, v53[0], (unint64_t)v53[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v53;
    uint64_t v61 = v54;
  }
  long long v59 = 0;
  if (SHIBYTE(v61) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long valuePtr = __dst;
    uint64_t v63 = v61;
  }
  int64_t v64 = 0;
  if (ctu::cf::convert_copy())
  {
    char v26 = v59;
    long long v59 = v64;
    char v65 = v26;
    sub_1000558F4(&v65);
  }
  if (SHIBYTE(v63) < 0) {
    operator delete((void *)valuePtr);
  }
  xpc_object_t value = v59;
  long long v59 = 0;
  sub_1000558F4((const void **)&v59);
  if (SHIBYTE(v61) < 0) {
    operator delete((void *)__dst);
  }
  CFDictionarySetValue(v25, @"bundleID", value);
  sub_1000558F4((const void **)&value);
  if (SHIBYTE(v54) < 0) {
    operator delete(v53[0]);
  }
  uint64_t v27 = v58;
  if (*(unsigned char *)(a1 + 96)) {
    CFBooleanRef v28 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v28 = kCFBooleanFalse;
  }
  *(void *)&long long __dst = v28;
  *(void *)&long long valuePtr = 0;
  sub_100062778((const void **)&valuePtr);
  char v65 = (const void *)__dst;
  *(void *)&long long __dst = 0;
  sub_100062778((const void **)&__dst);
  CFDictionarySetValue(v27, @"useStaticAttributionMap", v65);
  sub_100062778(&v65);
  char v29 = v58;
  if (*(char *)(a1 + 127) < 0)
  {
    sub_10004FC84(v51, *(void **)(a1 + 104), *(void *)(a1 + 112));
  }
  else
  {
    *(_OWORD *)char v51 = *(_OWORD *)(a1 + 104);
    uint64_t v52 = *(void *)(a1 + 120);
  }
  if (SHIBYTE(v52) < 0)
  {
    sub_10004FC84(&__dst, v51[0], (unint64_t)v51[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v51;
    uint64_t v61 = v52;
  }
  long long v59 = 0;
  if (SHIBYTE(v61) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long valuePtr = __dst;
    uint64_t v63 = v61;
  }
  int64_t v64 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v30 = v59;
    long long v59 = v64;
    char v65 = v30;
    sub_1000558F4(&v65);
  }
  if (SHIBYTE(v63) < 0) {
    operator delete((void *)valuePtr);
  }
  xpc_object_t value = v59;
  long long v59 = 0;
  sub_1000558F4((const void **)&v59);
  if (SHIBYTE(v61) < 0) {
    operator delete((void *)__dst);
  }
  CFDictionarySetValue(v29, @"uuid", value);
  sub_1000558F4((const void **)&value);
  if (SHIBYTE(v52) < 0) {
    operator delete(v51[0]);
  }
  unsigned __int8 v31 = v58;
  if (*(char *)(a1 + 151) < 0)
  {
    sub_10004FC84(v49, *(void **)(a1 + 128), *(void *)(a1 + 136));
  }
  else
  {
    *(_OWORD *)uint64_t v49 = *(_OWORD *)(a1 + 128);
    uint64_t v50 = *(void *)(a1 + 144);
  }
  if (SHIBYTE(v50) < 0)
  {
    sub_10004FC84(&__dst, v49[0], (unint64_t)v49[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v49;
    uint64_t v61 = v50;
  }
  long long v59 = 0;
  if (SHIBYTE(v61) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long valuePtr = __dst;
    uint64_t v63 = v61;
  }
  int64_t v64 = 0;
  if (ctu::cf::convert_copy())
  {
    char v32 = v59;
    long long v59 = v64;
    char v65 = v32;
    sub_1000558F4(&v65);
  }
  if (SHIBYTE(v63) < 0) {
    operator delete((void *)valuePtr);
  }
  xpc_object_t value = v59;
  long long v59 = 0;
  sub_1000558F4((const void **)&v59);
  if (SHIBYTE(v61) < 0) {
    operator delete((void *)__dst);
  }
  CFDictionarySetValue(v31, @"euuid", value);
  sub_1000558F4((const void **)&value);
  if (SHIBYTE(v50) < 0) {
    operator delete(v49[0]);
  }
  long long v33 = v58;
  if (*(char *)(a1 + 175) < 0)
  {
    sub_10004FC84(v47, *(void **)(a1 + 152), *(void *)(a1 + 160));
  }
  else
  {
    *(_OWORD *)uint64_t v47 = *(_OWORD *)(a1 + 152);
    uint64_t v48 = *(void *)(a1 + 168);
  }
  if (SHIBYTE(v48) < 0)
  {
    sub_10004FC84(&__dst, v47[0], (unint64_t)v47[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v47;
    uint64_t v61 = v48;
  }
  long long v59 = 0;
  if (SHIBYTE(v61) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long valuePtr = __dst;
    uint64_t v63 = v61;
  }
  int64_t v64 = 0;
  if (ctu::cf::convert_copy())
  {
    long long v34 = v59;
    long long v59 = v64;
    char v65 = v34;
    sub_1000558F4(&v65);
  }
  if (SHIBYTE(v63) < 0) {
    operator delete((void *)valuePtr);
  }
  xpc_object_t value = v59;
  long long v59 = 0;
  sub_1000558F4((const void **)&v59);
  if (SHIBYTE(v61) < 0) {
    operator delete((void *)__dst);
  }
  CFDictionarySetValue(v33, @"localAddress", value);
  sub_1000558F4((const void **)&value);
  if (SHIBYTE(v48) < 0) {
    operator delete(v47[0]);
  }
  long long v35 = v58;
  if (*(char *)(a1 + 199) < 0)
  {
    sub_10004FC84(v45, *(void **)(a1 + 176), *(void *)(a1 + 184));
  }
  else
  {
    *(_OWORD *)int v45 = *(_OWORD *)(a1 + 176);
    uint64_t v46 = *(void *)(a1 + 192);
  }
  if (SHIBYTE(v46) < 0)
  {
    sub_10004FC84(&__dst, v45[0], (unint64_t)v45[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v45;
    uint64_t v61 = v46;
  }
  long long v59 = 0;
  if (SHIBYTE(v61) < 0)
  {
    sub_10004FC84(&valuePtr, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long valuePtr = __dst;
    uint64_t v63 = v61;
  }
  int64_t v64 = 0;
  if (ctu::cf::convert_copy())
  {
    long long v36 = v59;
    long long v59 = v64;
    char v65 = v36;
    sub_1000558F4(&v65);
  }
  if (SHIBYTE(v63) < 0) {
    operator delete((void *)valuePtr);
  }
  std::bad_cast v37 = v59;
  xpc_object_t value = v59;
  long long v59 = 0;
  sub_1000558F4((const void **)&v59);
  if (SHIBYTE(v61) < 0) {
    operator delete((void *)__dst);
  }
  CFDictionarySetValue(v35, @"remoteAddress", v37);
  sub_1000558F4((const void **)&value);
  if (SHIBYTE(v46) < 0) {
    operator delete(v45[0]);
  }
  CFTypeRef v38 = v58;
  if (*(unsigned char *)(a1 + 200)) {
    CFBooleanRef v39 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v39 = kCFBooleanFalse;
  }
  *(void *)&long long valuePtr = 0;
  id v40 = sub_100062778((const void **)&valuePtr);
  *(void *)&long long __dst = v39;
  *(void *)&long long valuePtr = 0;
  sub_100062778(v40);
  CFDictionarySetValue(v38, @"shouldIgnore", v39);
  sub_100062778((const void **)&__dst);
  CFDictionarySetValue(v58, @"rawRemoteAddr", *(const void **)(a1 + 208));
  int v41 = v58;
  if (a2) {
    CFBooleanRef v42 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v42 = kCFBooleanFalse;
  }
  *(void *)&long long valuePtr = 0;
  uint64_t v43 = sub_100062778((const void **)&valuePtr);
  *(void *)&long long __dst = v42;
  *(void *)&long long valuePtr = 0;
  sub_100062778(v43);
  CFDictionarySetValue(v41, @"socketClosed", v42);
  sub_100062778((const void **)&__dst);
  CFDictionarySetValue(Mutable, @"msg-name", @"du-on-peer");
  CFDictionarySetValue(Mutable, @"msg-body", v58);
  return sub_10005717C((const void **)&v58);
}

void sub_10095992C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,char a50)
{
  sub_1000558F4((const void **)(v51 - 168));
  if (*(char *)(v51 - 137) < 0) {
    operator delete(*(void **)(v51 - 160));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10005717C((const void **)(v51 - 176));
  sub_10005717C(v50);
  _Unwind_Resume(a1);
}

void stewie::TargetInstantAtLocationCache::create(void *a1@<X1>, void *a2@<X2>, os_log_t *a3@<X3>, void *a4@<X8>)
{
  if (!*a1)
  {
    char v5 = *a3;
    if (!os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    __int16 v9 = 0;
    uint64_t v6 = "targets must be provided";
    CFMutableDictionaryRef v7 = (uint8_t *)&v9;
LABEL_9:
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, v7, 2u);
    goto LABEL_7;
  }
  if (*a2) {
    operator new();
  }
  char v5 = *a3;
  if (os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR))
  {
    __int16 v8 = 0;
    uint64_t v6 = "targetFactory must be provided";
    CFMutableDictionaryRef v7 = (uint8_t *)&v8;
    goto LABEL_9;
  }
LABEL_7:
  *a4 = 0;
  a4[1] = 0;
}

void sub_100959E18(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if (v3)
  {
    sub_10004D2C8(v3);
    if (!v1) {
      goto LABEL_3;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v1);
LABEL_3:
  _Unwind_Resume(a1);
}

BOOL sub_100959E9C(uint64_t a1, uint64_t a2)
{
  CLClientGetDistanceCoordinates();
  return v4 < 100.0
      && vabdd_f64(*(double *)(a1 + 32), *(double *)(a2 + 16)) < 100.0
      && vabdd_f64(*(double *)(a1 + 40), *(double *)(a2 + 24)) < 0.000174532925
      && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a2 + 32);
}

uint64_t sub_100959F58@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 64);
  *a2 = *(void *)(result + 56);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100959F74(uint64_t a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  CFMutableDictionaryRef v7 = (void *)(a1 + 96);
  uint64_t v6 = *(void *)(a1 + 96);
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v8 = a1 + 96;
  do
  {
    unsigned int v9 = *(_DWORD *)(v6 + 32);
    BOOL v10 = v9 >= a2;
    if (v9 >= a2) {
      uint64_t v11 = (uint64_t *)v6;
    }
    else {
      uint64_t v11 = (uint64_t *)(v6 + 8);
    }
    if (v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if ((void *)v8 != v7 && *(_DWORD *)(v8 + 32) <= a2)
  {
    uint64_t v19 = *(void *)(v8 + 40);
    uint64_t v18 = *(void *)(v8 + 48);
    *a3 = v19;
    a3[1] = v18;
    if (v18) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_12:
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    stewie::Targets::getById(*(stewie::Targets **)(a1 + 56), a2, &v22);
    if (v22)
    {
      long long v21 = 0uLL;
      (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 72) + 24))(&v21);
      uint64_t v12 = *v7;
      uint64_t v13 = v7;
      if (*v7)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v13 = (void *)v12;
            unsigned int v14 = *(_DWORD *)(v12 + 32);
            if (v14 <= a2) {
              break;
            }
            uint64_t v12 = *v13;
            CFMutableDictionaryRef v7 = v13;
            if (!*v13) {
              goto LABEL_20;
            }
          }
          if (v14 >= a2) {
            break;
          }
          uint64_t v12 = v13[1];
          if (!v12)
          {
            CFMutableDictionaryRef v7 = v13 + 1;
            goto LABEL_20;
          }
        }
        CFNumberRef v15 = (char *)v13;
      }
      else
      {
LABEL_20:
        CFNumberRef v15 = (char *)operator new(0x38uLL);
        *((_DWORD *)v15 + 8) = a2;
        *(_OWORD *)(v15 + 40) = v21;
        long long v21 = 0uLL;
        *(void *)CFNumberRef v15 = 0;
        *((void *)v15 + 1) = 0;
        *((void *)v15 + 2) = v13;
        *CFMutableDictionaryRef v7 = v15;
        uint64_t v16 = **(void **)(a1 + 88);
        int v17 = (uint64_t *)v15;
        if (v16)
        {
          *(void *)(a1 + 88) = v16;
          int v17 = (uint64_t *)*v7;
        }
        sub_100046C90(*(uint64_t **)(a1 + 96), v17);
        ++*(void *)(a1 + 104);
      }
      *a3 = *((void *)v15 + 5);
      uint64_t v20 = *((void *)v15 + 6);
      a3[1] = v20;
      if (v20) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
      }
      if (*((void *)&v21 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v21 + 1));
      }
    }
    else
    {
      *a3 = 0;
      a3[1] = 0;
    }
    if (v23) {
      sub_10004D2C8(v23);
    }
  }
}

void sub_10095A138(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10095A164(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ***********************************************************", buf, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * ConnectionAssistant::TargetInstantAtLocationCache state *", buf, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ***********************************************************", buf, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    double v3 = *(double *)(a1 + 16) * 180.0 / 3.14159265;
    double v4 = *(double *)(a1 + 24) * 180.0;
    *(_DWORD *)long long buf = 134284033;
    uint64_t v5 = *(void *)(a1 + 32);
    double v17 = v3;
    __int16 v18 = 2049;
    double v19 = v4 / 3.14159265;
    __int16 v20 = 2049;
    uint64_t v21 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Location: [%{private}.6f, %{private}.6f, %{private}.6f]", buf, 0x20u);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    double v6 = *(double *)(a1 + 40) * 180.0 / 3.14159265;
    *(_DWORD *)long long buf = 134217984;
    double v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Service threshold: %.2f", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)(a1 + 48);
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v17) = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] GPS-UTC leap second: %d", buf, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    double v8 = *(double *)(a1 + 104);
    *(_DWORD *)long long buf = 134217984;
    double v17 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] TargetInstantAtLocationCache size: %zu [", buf, 0xCu);
  }
  unsigned int v9 = *(void **)(a1 + 88);
  if (v9 != (void *)(a1 + 96))
  {
    do
    {
      BOOL v10 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = *((_DWORD *)v9 + 8);
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v17) = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [d]      targetID: %d", buf, 8u);
      }
      uint64_t v12 = (void *)v9[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v9[2];
          BOOL v14 = *v13 == (void)v9;
          unsigned int v9 = v13;
        }
        while (!v14);
      }
      unsigned int v9 = v13;
    }
    while (v13 != (void *)(a1 + 96));
  }
  CFNumberRef v15 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] ]", buf, 2u);
  }
}