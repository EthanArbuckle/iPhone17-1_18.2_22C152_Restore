void sub_10022AA48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  std::__shared_weak_count *v12;
  char v13;

  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10022AA7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  v5 = (std::__shared_weak_count *)"kLoggingConfig";
  xpc_object_t object = 0;
  sub_10000CB28((uint64_t)&v4, &object);
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v4 = 0;
    v5 = 0;
    sub_100068A94(&v4);
    if (v4) {
      (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v4 + 416))(v4, &object);
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  xpc_release(object);
}

void sub_10022AB2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, xpc_object_t object)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_10022AB60(Registry *a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1);
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v5;
  v9 = sub_10004D37C(&v4[1].__m_.__sig, &v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    v10 = 0;
  }
  std::mutex::unlock(v4);
  *a2 = v11;
  a2[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

void sub_10022AC28(void *a1, ctu **a2)
{
  int v3 = *(unsigned __int8 *)a2;
  if (v3 == 1)
  {
    uint64_t v7 = a2[1];
    if (v7) {
      unsigned int v8 = sub_100080778;
    }
    else {
      unsigned int v8 = 0;
    }
    if (!v8) {
      goto LABEL_53;
    }
    xpc_object_t v59 = 0;
    ctu::cf_to_xpc((uint64_t *)buf, v7, a2);
    xpc_object_t v9 = *(xpc_object_t *)buf;
    xpc_object_t v59 = *(xpc_object_t *)buf;
    if (*(void *)buf && xpc_get_type(*(xpc_object_t *)buf) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_retain(v9);
    }
    else {
      xpc_object_t v59 = xpc_null_create();
    }
    xpc_release(*(xpc_object_t *)buf);
    v10 = (const char *)kVinylFwUpdateOperationMode;
    value = (capabilities::ct *)xpc_dictionary_get_value(v59, kVinylFwUpdateOperationMode);
    if (!value) {
      goto LABEL_20;
    }
    *(void *)buf = &v59;
    v58 = v10;
    xpc_object_t object2 = 0;
    sub_100048BAC((uint64_t)buf, &object2);
    xpc_object_t v12 = xpc_int64_create(0);
    if (!v12) {
      xpc_object_t v12 = xpc_null_create();
    }
    BOOL v13 = xpc_equal(v12, object2);
    xpc_release(v12);
    xpc_release(object2);
    if (!v13)
    {
LABEL_20:
      if ((capabilities::ct::defaultVinylCardTypeToGSMA(value) & 1) == 0)
      {
        v17 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "rm");
        v18 = v58;
        ctu::OsLogContext::~OsLogContext(v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Vinyl FW Update error - in restore mode", buf, 2u);
        }
        xpc_object_t v41 = xpc_int64_create(5);
        if (!v41) {
          xpc_object_t v41 = xpc_null_create();
        }
        *(void *)buf = a1[4];
        v58 = "kMachError";
        sub_100035E70((uint64_t)buf, &v41, &v42);
        xpc_release(v42);
        xpc_object_t v42 = 0;
        xpc_release(v41);
        xpc_object_t v41 = 0;
        goto LABEL_52;
      }
    }
    xpc_object_t v56 = 0;
    int v15 = *(unsigned __int8 *)a2;
    if (v15 != 1)
    {
      if (v15 == 2)
      {
        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        v35 = &ctu::ResultIsError::~ResultIsError;
        ctu::ResultIsError::ResultIsError(exception);
      }
      else
      {
        exception = (ctu::ResultIsError *)__cxa_allocate_exception(0x10uLL);
        v35 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      }
      __cxa_throw(exception, v36, (void (*)(void *))v35);
    }
    ctu::cf_to_xpc((uint64_t *)buf, a2[1], v14);
    xpc_object_t v16 = *(xpc_object_t *)buf;
    xpc_object_t v56 = *(xpc_object_t *)buf;
    if (*(void *)buf && xpc_get_type(*(xpc_object_t *)buf) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_retain(v16);
    }
    else {
      xpc_object_t v56 = xpc_null_create();
    }
    xpc_release(*(xpc_object_t *)buf);
    xpc_object_t v55 = 0;
    xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v20 = v19;
    if (v19)
    {
      xpc_object_t v55 = v19;
    }
    else
    {
      xpc_object_t v20 = xpc_null_create();
      xpc_object_t v55 = v20;
      if (!v20)
      {
        xpc_object_t v21 = xpc_null_create();
        xpc_object_t v20 = 0;
        goto LABEL_39;
      }
    }
    if (xpc_get_type(v20) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v20);
      goto LABEL_40;
    }
    xpc_object_t v21 = xpc_null_create();
LABEL_39:
    xpc_object_t v55 = v21;
LABEL_40:
    xpc_release(v20);
    *(void *)buf = &v56;
    v58 = (const char *)kVinylFwUpdateCsn;
    xpc_object_t object2 = &v55;
    v53 = "EUICCCSN";
    sub_10022B448((uint64_t)&object2, (uint64_t)buf, &v54);
    xpc_release(v54);
    xpc_object_t v54 = 0;
    *(void *)buf = &v56;
    v58 = (const char *)kVinylFwUpdateMainFwNonce;
    xpc_object_t object2 = &v55;
    v53 = "EUICCMainNonce";
    sub_10022B448((uint64_t)&object2, (uint64_t)buf, &v51);
    xpc_release(v51);
    xpc_object_t v51 = 0;
    *(void *)buf = &v56;
    v58 = (const char *)kVinylFwUpdateGoldFwNonce;
    xpc_object_t object2 = &v55;
    v53 = "EUICCGoldNonce";
    sub_10022B448((uint64_t)&object2, (uint64_t)buf, &v50);
    xpc_release(v50);
    xpc_object_t v50 = 0;
    *(void *)buf = &v56;
    v58 = (const char *)kVinylFwUpdateProfileVersion;
    xpc_object_t object2 = &v55;
    v53 = "EUICCTicketVersion";
    sub_10022B448((uint64_t)&object2, (uint64_t)buf, &v49);
    xpc_release(v49);
    xpc_object_t v49 = 0;
    v22 = (const char *)kVinylFwUpdateEuiccChipId;
    *(void *)buf = &v56;
    v58 = (const char *)kVinylFwUpdateEuiccChipId;
    xpc_object_t object2 = &v55;
    v53 = "EUICCChipID";
    sub_10022B448((uint64_t)&object2, (uint64_t)buf, &v48);
    xpc_release(v48);
    xpc_object_t v48 = 0;
    *(void *)buf = &v56;
    v58 = (const char *)kVinylFwUpdateLoaderVersion;
    xpc_object_t object2 = &v55;
    v53 = "EUICCFirmwareLoaderVersion";
    sub_10022B448((uint64_t)&object2, (uint64_t)buf, &v47);
    xpc_release(v47);
    xpc_object_t v47 = 0;
    v23 = (const char *)kVinylFwUpdateKeyId;
    xpc_object_t v24 = xpc_dictionary_get_value(v56, kVinylFwUpdateKeyId);
    if (xpc_get_type(v24) == (xpc_type_t)&_xpc_type_data)
    {
      xpc_object_t v25 = xpc_dictionary_get_value(v56, v22);
      size_t v26 = xpc_int64_get_value(v25) <= 4 ? 4 : 20;
      xpc_object_t v27 = xpc_dictionary_get_value(v56, v23);
      size_t length = xpc_data_get_length(v27);
      xpc_object_t v29 = xpc_dictionary_get_value(v56, v23);
      bytes_ptr = xpc_data_get_bytes_ptr(v29);
      if (length >= v26)
      {
        xpc_object_t v45 = xpc_data_create(bytes_ptr, v26);
        if (!v45) {
          xpc_object_t v45 = xpc_null_create();
        }
        *(void *)buf = &v55;
        v58 = "EUICCCertIdentifier";
        sub_100035E70((uint64_t)buf, &v45, &v46);
        xpc_release(v46);
        xpc_object_t v46 = 0;
        xpc_release(v45);
        xpc_object_t v45 = 0;
      }
    }
    xpc_object_t v43 = v55;
    if (v55) {
      xpc_retain(v55);
    }
    else {
      xpc_object_t v43 = xpc_null_create();
    }
    *(void *)buf = a1[4];
    v58 = "kRadioModuleFirmwarePreflightInfo";
    sub_10014E03C((uint64_t)buf, &v43, &v44);
    xpc_release(v44);
    xpc_object_t v44 = 0;
    xpc_release(v43);
    xpc_object_t v43 = 0;
    xpc_release(v55);
    xpc_release(v56);
LABEL_52:
    xpc_release(v59);
    goto LABEL_53;
  }
  if (v3 != 2)
  {
    v33 = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
    ctu::ResultIsEmptyError::ResultIsEmptyError(v33);
  }
  uint64_t v4 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "rm");
  unint64_t v5 = v58;
  ctu::OsLogContext::~OsLogContext(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Vinyl FW Update error", buf, 2u);
  }
  xpc_object_t v39 = xpc_int64_create(5);
  if (!v39) {
    xpc_object_t v39 = xpc_null_create();
  }
  *(void *)buf = a1[4];
  v58 = "kMachError";
  sub_100035E70((uint64_t)buf, &v39, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v39);
  xpc_object_t v39 = 0;
LABEL_53:
  v32 = (std::__shared_weak_count *)a1[5];
  uint64_t v31 = a1[6];
  uint64_t v37 = a1[4];
  v38 = v32;
  if (v32) {
    atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v31 + 120))(v31, &v37);
  if (v38) {
    sub_10004D2C8(v38);
  }
}

void sub_10022B32C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,xpc_object_t object)
{
  __cxa_free_exception(v24);
  xpc_release(*(xpc_object_t *)(v25 - 56));
  _Unwind_Resume(a1);
}

void sub_10022B448(uint64_t a1@<X0>, uint64_t a2@<X1>, xpc_object_t *a3@<X8>)
{
  xpc_object_t object = 0;
  sub_100048BAC(a2, &object);
  xpc_object_t v5 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  sub_100035E70(a1, &v5, a3);
  xpc_release(v5);
  xpc_object_t v5 = 0;
  xpc_release(object);
}

void *sub_10022B4D4(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10022B508(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void *sub_10022B558(void *a1)
{
  *a1 = off_1019ACFE8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10022B5A4(void *a1)
{
  *a1 = off_1019ACFE8;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_10022B610(uint64_t a1)
{
  result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019ACFE8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10022B66C(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019ACFE8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10022B6A4(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10022B6B4(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10022B6F4(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v5 = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      xpc_object_t v5 = xpc_null_create();
    }
    v4[0] = *(void *)(a1 + 8);
    v4[1] = "kRadioTxPowerControlData";
    sub_100035E70((uint64_t)v4, &v5, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v5);
  }
  xpc_release(v3);
}

void sub_10022B7B4(_Unwind_Exception *a1)
{
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10022B7D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10022B810()
{
}

void *sub_10022B81C(void *a1)
{
  *a1 = off_1019AD068;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10022B868(void *a1)
{
  *a1 = off_1019AD068;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_10022B8D4(uint64_t a1)
{
  result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019AD068;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10022B930(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019AD068;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10022B968(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10022B978(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10022B9B8(uint64_t a1, int *a2)
{
  xpc_object_t v4 = xpc_int64_create(*a2);
  if (!v4) {
    xpc_object_t v4 = xpc_null_create();
  }
  v3[0] = *(void *)(a1 + 8);
  v3[1] = "kRadioVoiceLQM";
  sub_100035E70((uint64_t)v3, &v4, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v4);
}

uint64_t sub_10022BA3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10022BA7C()
{
}

void *sub_10022BA88(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10022BB0C(void *a1)
{
  *a1 = off_1019AD0F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10022BB58(void *a1)
{
  *a1 = off_1019AD0F8;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_10022BBC4(uint64_t a1)
{
  result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019AD0F8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10022BC20(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019AD0F8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10022BC58(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10022BC68(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10022BCA8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  xpc_object_t v6 = xpc_data_create(v4, v3 - (void)v4);
  if (!v6) {
    xpc_object_t v6 = xpc_null_create();
  }
  v5[0] = *(void *)(a1 + 8);
  v5[1] = "kRadioEnhancedVoiceLQM";
  sub_100035E70((uint64_t)v5, &v6, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v6);
  if (v4) {
    operator delete(v4);
  }
}

uint64_t sub_10022BD48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10022BD88()
{
}

void *sub_10022BD94(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10022BE18(void *a1)
{
  *a1 = off_1019AD188;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10022BE64(void *a1)
{
  *a1 = off_1019AD188;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_10022BED0(uint64_t a1)
{
  result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019AD188;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10022BF2C(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019AD188;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10022BF64(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10022BF74(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10022BFB4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t xdict = *a2;
  xpc_object_t v3 = xdict;
  *a2 = xpc_null_create();
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    p_xpc_object_t xdict = &xdict;
    uint64_t v11 = abm::kKeyCTCellularTransmitState;
    long long v13 = 0uLL;
    uint64_t v14 = 0;
    ctu::cf::assign();
    *(_OWORD *)__p = v13;
    uint64_t v9 = v14;
    uint64_t v4 = __p;
    if (v14 < 0) {
      uint64_t v4 = (void **)__p[0];
    }
    *(void *)&long long v13 = *(void *)(a1 + 8);
    *((void *)&v13 + 1) = v4;
    sub_10022B448((uint64_t)&v13, (uint64_t)&p_xdict, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
    p_xpc_object_t xdict = &xdict;
    uint64_t v11 = abm::kKeyCTCellularTransmitTrigger;
    if (xpc_dictionary_get_value(xdict, abm::kKeyCTCellularTransmitTrigger))
    {
      long long v13 = 0uLL;
      uint64_t v14 = 0;
      ctu::cf::assign();
      *(_OWORD *)__p = v13;
      uint64_t v9 = v14;
      xpc_object_t v5 = __p;
      if (v14 < 0) {
        xpc_object_t v5 = (void **)__p[0];
      }
      *(void *)&long long v13 = *(void *)(a1 + 8);
      *((void *)&v13 + 1) = v5;
      sub_10022B448((uint64_t)&v13, (uint64_t)&p_xdict, &v7);
      xpc_release(v7);
      xpc_object_t v7 = 0;
      if (SHIBYTE(v9) < 0) {
        operator delete(__p[0]);
      }
    }
    xpc_object_t v3 = xdict;
  }
  xpc_release(v3);
}

void sub_10022C13C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  if (*(char *)(v9 - 33) < 0) {
    operator delete(*(void **)(v9 - 56));
  }
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_10022C180(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10022C1C0()
{
}

uint64_t sub_10022C1CC()
{
  return sub_100C624B8((uint64_t)&unk_101B0C9F2, (uint64_t)sub_100227C58);
}

uint64_t sub_10022C1E8(uint64_t a1)
{
  if (((*(void *)(a1 + 80) - *(void *)(a1 + 72)) & 0x7FFFFFFF8) != 0 && !sub_100CCA330(a1, "Content-Type"))
  {
    __p = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v2 = *(void *)(a1 + 72);
    if (((*(void *)(a1 + 80) - v2) & 0x7FFFFFFF8) == 0)
    {
LABEL_9:
      uint64_t v7 = sub_10035F59C();
      (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
      operator new();
    }
    unint64_t v3 = 0;
    while (1)
    {
      uint64_t v4 = *(void *)(v2 + 8 * v3);
      uint64_t v5 = sub_100CCA3B0(v4, "Content-Type");
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 24);
        if (sub_10035F95C(v6, "application", "smil") || sub_10035F95C(v6, "application", "smil+xml")) {
          break;
        }
      }
      ++v3;
      uint64_t v2 = *(void *)(a1 + 72);
      if (v3 >= ((unint64_t)(*(void *)(a1 + 80) - v2) >> 3)) {
        goto LABEL_9;
      }
    }
    uint64_t v8 = sub_100CCA3B0(v4, "Content-ID");
    if (v8) {
      (*(void (**)(uint64_t, void **))(*(void *)v8 + 72))(v8, &__p);
    }
    uint64_t v9 = sub_10035F65C();
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9) + 8;
    sub_100CCA11C(v10, "type", (uint64_t)"application/smil", 0);
    if (SHIBYTE(v15) < 0)
    {
      if (!v14) {
        goto LABEL_18;
      }
      p_p = __p;
    }
    else
    {
      if (!HIBYTE(v15)) {
        goto LABEL_18;
      }
      p_p = &__p;
    }
    sub_100CCA11C(v10, "start", (uint64_t)p_p, 0);
LABEL_18:
    operator new();
  }
  return 1;
}

void sub_10022C48C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_10022C514(uint64_t a1)
{
  sub_10022C1E8(a1);
  uint64_t result = sub_100CCA330(a1, "X-Mms-Message-Type");
  if (result)
  {
    uint64_t v3 = sub_100CCA3B0(a1, "X-Mms-Message-Type");
    if (v3 && *(unsigned __int8 *)(v3 + 17) == 128) {
      sub_100CCA11C(a1, "From", (uint64_t)&unk_10160BACD, 0);
    }
    if (!sub_100CCA330(a1, "X-Mms-MMS-Version")) {
      sub_100CCA11C(a1, "X-Mms-MMS-Version", (uint64_t)"MMS 1.2", 0);
    }
    return sub_100CCA330(a1, "X-Mms-Transaction-ID") != 0;
  }
  return result;
}

BOOL sub_10022C5D0(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_100CCA330(a2, "Content-Type");
  if (v4)
  {
    unint64_t v5 = a1[11];
    uint64_t v6 = (uint64_t *)a1[10];
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v8 = a1[9];
      uint64_t v9 = ((uint64_t)v6 - v8) >> 3;
      if ((unint64_t)(v9 + 1) >> 61) {
        sub_10022E78C();
      }
      uint64_t v10 = v5 - v8;
      uint64_t v11 = v10 >> 2;
      if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
        uint64_t v11 = v9 + 1;
      }
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      if (v12) {
        long long v13 = (char *)sub_10004EF74((uint64_t)(a1 + 11), v12);
      }
      else {
        long long v13 = 0;
      }
      uint64_t v14 = (uint64_t *)&v13[8 * v9];
      uint64_t v15 = &v13[8 * v12];
      uint64_t *v14 = a2;
      uint64_t v7 = v14 + 1;
      v17 = (char *)a1[9];
      xpc_object_t v16 = (char *)a1[10];
      if (v16 != v17)
      {
        do
        {
          uint64_t v18 = *((void *)v16 - 1);
          v16 -= 8;
          *--uint64_t v14 = v18;
        }
        while (v16 != v17);
        xpc_object_t v16 = (char *)a1[9];
      }
      a1[9] = v14;
      a1[10] = v7;
      a1[11] = v15;
      if (v16) {
        operator delete(v16);
      }
    }
    else
    {
      uint64_t *v6 = a2;
      uint64_t v7 = v6 + 1;
    }
    a1[10] = v7;
  }
  return v4 != 0;
}

void *sub_10022C6D8(void *a1)
{
  *a1 = off_1019AD208;
  uint64_t v4 = a1 + 9;
  uint64_t v2 = (void *)a1[9];
  uint64_t v3 = (void *)v4[1];
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (v3)
    {
LABEL_7:
      a1[10] = v2;
      operator delete(v2);
    }
  }
  else
  {
    unint64_t v5 = 0;
    unsigned int v6 = 1;
    do
    {
      uint64_t v7 = *((void *)v2 + v5);
      if (v7)
      {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        uint64_t v2 = (void *)a1[9];
        uint64_t v3 = (void *)a1[10];
      }
      unint64_t v5 = v6++;
    }
    while (v5 < ((unsigned char *)v3 - (unsigned char *)v2) >> 3);
    if (v2) {
      goto LABEL_7;
    }
  }

  return sub_100CC9A2C(a1);
}

void sub_10022C7A0(void *a1)
{
  sub_10022C6D8(a1);

  operator delete();
}

void sub_10022C7D8()
{
}

void sub_10022C894()
{
}

uint64_t sub_10022C8B8()
{
  if (!qword_101B13C88) {
    operator new();
  }
  return qword_101B13C88;
}

void sub_10022E01C()
{
}

void sub_10022E108()
{
}

BOOL sub_10022E124(uint64_t a1, char a2)
{
  if (a2 <= -121)
  {
    uint64_t v4 = sub_100CCA330(a1, "X-Mms-Message-Type");
    if (!v4)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      uint64_t v4 = sub_101306428(v5, "X-Mms-Message-Type");
      sub_100CC9AE4(a1, v4, 0);
    }
    *(unsigned char *)(v4 + 17) = a2;
  }
  return a2 < -120;
}

uint64_t sub_10022E1C8@<X0>(std::string *a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v32 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v23 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  *(_OWORD *)xpc_object_t v20 = 0u;
  memset(v19, 0, sizeof(v19));
  sub_10004DE24((uint64_t)v19);
  sub_10004B96C(v19, (uint64_t)"\n", 1);
  sub_10004B96C(v19, (uint64_t)"-----------------------------\n", 30);
  sub_100CCA77C(a1, a2, a3, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v19, (uint64_t)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (a2) {
      goto LABEL_22;
    }
  }
  else if (a2)
  {
    goto LABEL_22;
  }
  std::string::pointer data = a1[3].__r_.__value_.__l.__data_;
  if (((a1[3].__r_.__value_.__l.__size_ - (void)data) & 0x7FFFFFFF8) != 0)
  {
    unint64_t v11 = 0;
    do
    {
      unint64_t v12 = *(std::string **)&data[8 * v11];
      sub_10004B96C(v19, (uint64_t)"Part ", 5);
      long long v13 = (void *)std::ostream::operator<<();
      sub_10004B96C(v13, (uint64_t)" (", 2);
      uint64_t v14 = (void *)std::ostream::operator<<();
      sub_10004B96C(v14, (uint64_t)" bytes):\n", 9);
      sub_1003C05B0(v12, a3, &__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = &__p;
      }
      else {
        uint64_t v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v16 = __p.__r_.__value_.__l.__size_;
      }
      sub_10004B96C(v19, (uint64_t)v15, v16);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      ++v11;
      std::string::pointer data = a1[3].__r_.__value_.__l.__data_;
    }
    while (v11 < ((a1[3].__r_.__value_.__l.__size_ - (unint64_t)data) >> 3));
  }
LABEL_22:
  sub_10004B96C(v19, (uint64_t)"-----------------------------", 29);
  sub_10004BC98((uint64_t)v19 + 8, a4);
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_10022E498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000C937C((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_10022E4D4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)unint64_t v12 = 0u;
  memset(v11, 0, sizeof(v11));
  sub_10004DE24((uint64_t)v11);
  uint64_t v4 = *(void *)(a1 + 72);
  if (((*(void *)(a1 + 80) - v4) & 0x7FFFFFFF8) != 0)
  {
    unint64_t v5 = 0;
    do
    {
      sub_1003C0790(*(void *)(v4 + 8 * v5), __p);
      if ((v10 & 0x80u) == 0) {
        unsigned int v6 = __p;
      }
      else {
        unsigned int v6 = (void **)__p[0];
      }
      if ((v10 & 0x80u) == 0) {
        uint64_t v7 = v10;
      }
      else {
        uint64_t v7 = (uint64_t)__p[1];
      }
      sub_10004B96C(v11, (uint64_t)v6, v7);
      if ((char)v10 < 0) {
        operator delete(__p[0]);
      }
      ++v5;
      uint64_t v4 = *(void *)(a1 + 72);
    }
    while (v5 < ((unint64_t)(*(void *)(a1 + 80) - v4) >> 3));
  }
  sub_10004BC98((uint64_t)v11 + 8, a2);
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_10022E6A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

BOOL sub_10022E6D4(uint64_t a1)
{
  if (((*(void *)(a1 + 80) - *(void *)(a1 + 72)) & 0x7FFFFFFF8) == 0) {
    return 1;
  }
  uint64_t v2 = sub_100CCA3B0(a1, "Content-Type");
  return (!v2 || (uint64_t v3 = *(void *)(v2 + 24)) == 0 || !sub_10035F9FC(v3))
      && *(_DWORD *)(**(void **)(a1 + 72) + 96) == 0;
}

char *sub_10022E748(void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    sub_100205700();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void sub_10022E78C()
{
}

void sub_10022ECE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }

  _Unwind_Resume(a1);
}

void sub_10022EDC4(uint64_t a1@<X0>, void *a2@<X8>)
{
  lpsrc = 0;
  unsigned int v6 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&lpsrc);
  if (lpsrc
  {
    uint64_t v4 = v6;
    *a2 = v3;
    a2[1] = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

uint64_t sub_10022EE94(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10022F2FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }

  _Unwind_Resume(a1);
}

void sub_10022F83C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_10022FBC4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10022FE58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002300C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100230418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  if (a24) {
    sub_10004D2C8(a24);
  }

  _Unwind_Resume(a1);
}

void sub_100230748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if ((v37 & 1) == 0) {
    sub_10004D2C8(v36);
  }
  v40 = *(std::__shared_weak_count **)(v38 - 72);
  if (v40) {
    sub_10004D2C8(v40);
  }

  _Unwind_Resume(a1);
}

void sub_100230A28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100230CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100230D3C(uint64_t a1)
{
  *(void *)a1 = off_1019AD248;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100230D90(uint64_t a1)
{
  *(void *)a1 = off_1019AD248;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100230E04(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_1019AD248;
  sub_1002310F4((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100230E58(uint64_t a1, void *a2)
{
  *a2 = off_1019AD248;
  return sub_1002310F4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100230E84(uint64_t a1)
{
}

void sub_100230E8C(void *a1)
{
  sub_100231144((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100230EC8(uint64_t a1, unsigned char *a2)
{
  if (!*a2)
  {
    id v13 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    goto LABEL_16;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unsigned int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v14);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unsigned __int8 v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unsigned __int8 v10 = 0;
  char v12 = 1;
  if (v11)
  {
LABEL_12:
    (*(void (**)(uint64_t, void, uint64_t, uint64_t, void))(*(void *)v11 + 640))(v11, *(unsigned int *)(a1 + 24), 10, 0xFFFFFFFFLL, 0);
    (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v11 + 312))(v11, *(unsigned int *)(a1 + 24), 9, 0);
  }
LABEL_13:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  id v13 = 0;
LABEL_16:
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100231084(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002310A8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019AD2A8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1002310E8()
{
  return &off_1019AD2A8;
}

uint64_t sub_1002310F4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(void *)(a1 + 24) = objc_retainBlock(*(id *)(a2 + 24));
  return a1;
}

void sub_100231144(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_100231190(uint64_t a1)
{
  return a1;
}

void sub_1002311BC(uint64_t a1)
{
  operator delete();
}

void *sub_100231208(uint64_t a1)
{
  char v2 = operator new(0x10uLL);
  *char v2 = off_1019AD2C8;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100231260(uint64_t a1, void *a2)
{
  *a2 = off_1019AD2C8;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1002312A8(uint64_t a1)
{
}

void sub_1002312B0(id *a1)
{
  operator delete(a1);
}

const void **sub_1002312EC(uint64_t a1, const void **a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  return sub_100057D78(&v3);
}

void sub_10023133C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100231350(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019AD338)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100231390()
{
  return &off_1019AD338;
}

uint64_t sub_10023139C(uint64_t a1)
{
  *(void *)a1 = off_1019AD358;

  char v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1002313F0(uint64_t a1)
{
  *(void *)a1 = off_1019AD358;

  char v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100231464(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  char v2 = operator new(0x28uLL);
  *char v2 = off_1019AD358;
  sub_1002310F4((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_1002314B8(uint64_t a1, void *a2)
{
  *a2 = off_1019AD358;
  return sub_1002310F4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1002314E4(uint64_t a1)
{
}

void sub_1002314EC(void *a1)
{
  sub_100231144((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100231528(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    unint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v4;
  unsigned int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v13);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    uint64_t v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10)
  {
LABEL_10:
    (*(void (**)(uint64_t, void, uint64_t, uint64_t, void))(*(void *)v10 + 640))(v10, *(unsigned int *)(a1 + 24), 11, 0xFFFFFFFFLL, 0);
    (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v10 + 312))(v10, *(unsigned int *)(a1 + 24), 8, 0);
  }
LABEL_11:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1002316A0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002316B8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019AD3B8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1002316F8()
{
  return &off_1019AD3B8;
}

uint64_t sub_100231704(uint64_t a1)
{
  return a1;
}

void sub_100231730(uint64_t a1)
{
  operator delete();
}

void *sub_10023177C(uint64_t a1)
{
  char v2 = operator new(0x10uLL);
  *char v2 = off_1019AD3D8;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1002317D4(uint64_t a1, void *a2)
{
  *a2 = off_1019AD3D8;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10023181C(uint64_t a1)
{
}

void sub_100231824(id *a1)
{
  operator delete(a1);
}

void sub_100231860(uint64_t a1, uint64_t **a2)
{
  unint64_t v4 = +[NSMutableArray arrayWithCapacity:((char *)a2[1] - (char *)*a2) >> 4];
  uint64_t v6 = *a2;
  unint64_t v5 = a2[1];
  while (v6 != v5)
  {
    unsigned int v7 = 0;
    sub_100C940DC(*v6, 1, &v7);
    [v4 addObject:v7];
    sub_100057D78(&v7);
    v6 += 2;
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_10023190C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100231930(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019AD448)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100231970()
{
  return &off_1019AD448;
}

void *sub_10023197C(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100231A00(capabilities::ct *a1@<X0>, uint64_t a2@<X8>)
{
  char v4 = capabilities::ct::supportsLazuli(a1);
  BOOL v5 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Lazuli support enabled", buf, 2u);
    }
    uint64_t v6 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    initially_inactive = dispatch_queue_attr_make_initially_inactive(v6);
    unsigned int v8 = dispatch_queue_create_with_target_V2("com.apple.lazuli", initially_inactive, 0);
    dispatch_set_qos_class_floor(v8, QOS_CLASS_UTILITY, 0);
    dispatch_activate(v8);
    dispatch_object_t object = v8;
    uint64_t v9 = (std::__shared_weak_count *)operator new(0x20uLL);
    v9->__shared_owners_ = 0;
    v9->__shared_weak_owners_ = 0;
    v9->__vftable = (std::__shared_weak_count_vtbl *)off_1019AD468;
    v9[1].__vftable = (std::__shared_weak_count_vtbl *)&off_101A11760;
    uint64_t v10 = v9 + 1;
    char v11 = v9;
    sub_100393F44(&object, (uint64_t)a1, &v10, buf);
    *(_OWORD *)a2 = *(_OWORD *)buf;
    memset(buf, 0, 16);
    if (v11) {
      sub_10004D2C8(v11);
    }
    if (object) {
      dispatch_release(object);
    }
  }
  else
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Lazuli support not enabled", buf, 2u);
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
}

void sub_100231B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100231BAC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AD468;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100231BCC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AD468;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100231C20(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100231C48(LazuliProvisioningWebHelper *this)
{
  *(void *)this = &off_1019AD4B8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 73);
  if (v2) {
    sub_10004D2C8(v2);
  }

  LazuliProvisioningWebHelper::~LazuliProvisioningWebHelper(this);
}

void sub_100231CA8(LazuliProvisioningWebHelper *a1)
{
  sub_100231C48(a1);

  operator delete();
}

BOOL sub_100231CE0(uint64_t a1)
{
  return *(void *)(a1 + 224) || *(void *)(a1 + 576) != 0;
}

uint64_t sub_100231D00(uint64_t a1)
{
  uint64_t v27 = 0;
  long long v28 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 80));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    BOOL v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)theDict = v4;
  unsigned int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)theDict);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v27 = v10;
  long long v28 = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v9);
    uint64_t v10 = v27;
  }
  if (v10)
  {
    *(void *)theDict = 0;
    sub_100562A8C((uint64_t)&v27, theDict);
    uint64_t v11 = 1002463;
    if (*(void *)theDict) {
      char v12 = sub_100080778;
    }
    else {
      char v12 = 0;
    }
    if (v12)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)theDict, @"ProvisioningData");
      CFDictionaryRef v14 = Value;
      if (Value)
      {
        CFTypeID v15 = CFGetTypeID(Value);
        if (v15 == CFDictionaryGetTypeID())
        {
          if (CFDictionaryContainsKey(v14, @"UseIMSIDuringProvisioning"))
          {
            long long v16 = (BOOL *)CFDictionaryGetValue(v14, @"UseIMSIDuringProvisioning");
            char v17 = v16;
            char v29 = 0;
            if (v16)
            {
              CFTypeID v18 = CFGetTypeID(v16);
              if (v18 == CFBooleanGetTypeID()) {
                ctu::cf::assign((ctu::cf *)&v29, v17, v19);
              }
            }
          }
          if (CFDictionaryContainsKey(v14, @"UseIMEIDuringProvisioning"))
          {
            long long v20 = (BOOL *)CFDictionaryGetValue(v14, @"UseIMEIDuringProvisioning");
            long long v21 = v20;
            char v29 = 0;
            if (v20)
            {
              CFTypeID v22 = CFGetTypeID(v20);
              if (v22 == CFBooleanGetTypeID())
              {
                ctu::cf::assign((ctu::cf *)&v29, v21, v23);
                if (v29) {
                  uint64_t v11 = 1002495;
                }
              }
            }
          }
        }
      }
    }
    sub_100057D78((const void **)theDict);
  }
  else
  {
    uint64_t v24 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
    uint64_t v11 = 1002463;
    long long v25 = *v24;
    if (os_log_type_enabled(*v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)theDict = 136315138;
      *(void *)&theDict[4] = "NC";
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "[%s] [...] Invalid Carrier interface", theDict, 0xCu);
    }
  }
  if (v28) {
    sub_10004D2C8(v28);
  }
  return v11;
}

void sub_100231FC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, char a13)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100232000()
{
  return 0;
}

BOOL sub_100232008(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
    if ((v5 & 0x80u) != 0) {
      uint64_t v5 = *(void *)(a2 + 8);
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&buf[4] = "NC";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [%s] Attestation data received of size: %zu", buf, 0x16u);
  }
  uint64_t v40 = 0;
  memset(buf, 0, sizeof(buf));
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  sub_10080C230((Registry **)(a1 + 80), v6, (uint64_t *)a2, (uint64_t)buf);
  int v7 = v40;
  if ((_BYTE)v40)
  {
    unsigned int v8 = *(std::__shared_weak_count **)(a1 + 320);
    if (v8)
    {
      uint64_t v9 = std::__shared_weak_count::lock(v8);
      if (v9)
      {
        uint64_t v10 = v9;
        uint64_t v11 = *(void *)(a1 + 312);
        if (v11)
        {
          LODWORD(v29[0]) = 2;
          int v31 = 6;
          v34[0] = 0;
          v34[4] = 0;
          LazuliProvisioningServerWrapper::submitMetricForReceivedXml(v11, v29, &v31, v34);
        }
        sub_10004D2C8(v10);
      }
    }
    if (!*(void *)(a1 + 576))
    {
      (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 560) + 72))(v34);
      long long v25 = *(_OWORD *)v34;
      *(void *)v34 = 0;
      *(void *)&v34[8] = 0;
      long long v26 = *(std::__shared_weak_count **)(a1 + 584);
      *(_OWORD *)(a1 + 576) = v25;
      if (v26)
      {
        sub_10004D2C8(v26);
        if (*(void *)&v34[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v34[8]);
        }
      }
    }
    v29[0] = 0;
    v29[1] = 0;
    uint64_t v30 = 0;
    sub_10005C928(v29, *(const void **)&buf[8], *(uint64_t *)&buf[16], *(void *)&buf[16] - *(void *)&buf[8]);
    char v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v34 = 136315906;
      *(void *)&v34[4] = "NC";
      *(_WORD *)&v34[12] = 2048;
      *(void *)&v34[14] = *(void *)buf;
      __int16 v35 = 1042;
      int v36 = 32;
      __int16 v37 = 2098;
      uint64_t v38 = v29[0];
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [%s] Starting attestation id:[%zu], challenge hash:\n%{public,network:data}.32P", v34, 0x26u);
    }
    sub_10003E168(v34, (void *)(a1 + 8));
    uint64_t v14 = *(void *)v34;
    unint64_t v13 = *(std::__shared_weak_count **)&v34[8];
    if (*(void *)&v34[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v34[8] + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
    }
    CFTypeID v15 = *(void (****)(void, uint64_t, void **, void *, uint64_t))(a1 + 576);
    uint64_t v16 = *(unsigned int *)(a1 + 76);
    *(_OWORD *)std::string __p = *(_OWORD *)v29;
    uint64_t v28 = v30;
    v29[0] = 0;
    v29[1] = 0;
    uint64_t v30 = 0;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v17 = *(void *)buf;
    v33 = 0;
    CFTypeID v18 = operator new(0x28uLL);
    void *v18 = off_1019AD618;
    v18[1] = v14;
    v18[2] = v13;
    v18[3] = a1;
    v18[4] = v17;
    v33 = v18;
    (**v15)(v15, v16, __p, v32, 1);
    sub_100236358(v32);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v13) {
      std::__shared_weak_count::__release_weak(v13);
    }
    if (v29[0])
    {
      v29[1] = v29[0];
      operator delete(v29[0]);
    }
  }
  else
  {
    CFBooleanRef v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v34 = 136315138;
      *(void *)&v34[4] = "NC";
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "[%s] Failed to decode attestation XML", v34, 0xCu);
    }
    long long v20 = *(std::__shared_weak_count **)(a1 + 320);
    if (v20)
    {
      long long v21 = std::__shared_weak_count::lock(v20);
      if (v21)
      {
        CFTypeID v22 = v21;
        uint64_t v23 = *(void *)(a1 + 312);
        if (v23)
        {
          LODWORD(v29[0]) = 2;
          int v31 = 9;
          v34[0] = 0;
          v34[4] = 0;
          LazuliProvisioningServerWrapper::submitMetricForReceivedXml(v23, v29, &v31, v34);
        }
        sub_10004D2C8(v22);
      }
    }
  }
  if ((_BYTE)v40 && *(void *)&buf[8])
  {
    *(void *)&buf[16] = *(void *)&buf[8];
    operator delete(*(void **)&buf[8]);
  }
  return v7 != 0;
}

void sub_1002324E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  sub_10004D2C8(v18);
  if (*(unsigned char *)(v19 - 80))
  {
    long long v21 = *(void **)(v19 - 104);
    if (v21)
    {
      *(void *)(v19 - 96) = v21;
      operator delete(v21);
    }
  }
  _Unwind_Resume(a1);
}

void sub_1002325A4(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)a2 + 48))(&v17);
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = HIBYTE(v19);
    if (v19 < 0) {
      uint64_t v6 = v18;
    }
    *(_DWORD *)buf = 136315650;
    uint64_t v23 = "NC";
    __int16 v24 = 1024;
    unsigned int v25 = v4;
    __int16 v26 = 2048;
    uint64_t v27 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [%s] Response [%d] for OTP, body-size: %ld", buf, 0x1Cu);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 320);
  if (v7)
  {
    unsigned int v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 312);
      if (v9)
      {
        if (v4 - 400 < 2 || v4 == 511)
        {
          uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315138;
            uint64_t v23 = "NC";
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [%s] Restarting provisioning from scratch after invalid OTP response", buf, 0xCu);
          }
          *(_DWORD *)buf = 4;
          int v13 = 10;
          LazuliProvisioningServerWrapper::submitMetricForPhase(v9, buf, v4 | (unint64_t)&_mh_execute_header, &v13, 0, 0);
          LazuliProvisioningWebHelper::restartProvisioning((LazuliProvisioningServerWrapper **)a1, 0);
        }
        else if (v4 == 200)
        {
          LOBYTE(__p) = 0;
          char v16 = 0;
          *(_DWORD *)buf = 4;
          LazuliProvisioningServerWrapper::handleXml(v9, (uint64_t *)&v17, (uint64_t)&__p, buf);
          if (v16 && v15 < 0) {
            operator delete(__p);
          }
          if (*(char *)(a1 + 279) < 0)
          {
            **(unsigned char **)(a1 + 256) = 0;
            *(void *)(a1 + 264) = 0;
          }
          else
          {
            *(unsigned char *)(a1 + 256) = 0;
            *(unsigned char *)(a1 + 279) = 0;
          }
          if (*(char *)(a1 + 255) < 0)
          {
            **(unsigned char **)(a1 + 232) = 0;
            *(void *)(a1 + 240) = 0;
          }
          else
          {
            *(unsigned char *)(a1 + 232) = 0;
            *(unsigned char *)(a1 + 255) = 0;
          }
        }
        else
        {
          *(_DWORD *)buf = 4;
          int v13 = 10;
          LazuliProvisioningServerWrapper::submitMetricForPhase(v9, buf, v4 | (unint64_t)&_mh_execute_header, &v13, 0, 0);
          aBlock[0] = _NSConcreteStackBlock;
          aBlock[1] = 0x40000000;
          aBlock[2] = sub_100232A74;
          aBlock[3] = &unk_1019AD4F0;
          aBlock[4] = a1;
          long long v21 = 0;
          v20[0] = off_1019AD7A8;
          v20[1] = _Block_copy(aBlock);
          long long v21 = v20;
          LazuliProvisioningWebHelper::responseUnknown(a1, a2, (uint64_t)v20);
          sub_1002364DC(v20);
        }
        goto LABEL_30;
      }
    }
  }
  else
  {
    unsigned int v8 = 0;
  }
  uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    if (!v8) {
      goto LABEL_31;
    }
LABEL_30:
    sub_10004D2C8(v8);
    goto LABEL_31;
  }
  *(_DWORD *)buf = 136315138;
  uint64_t v23 = "NC";
  _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "[%s] Client has disappeared", buf, 0xCu);
  if (v8) {
    goto LABEL_30;
  }
LABEL_31:
  if (SHIBYTE(v19) < 0) {
    operator delete(v17);
  }
}

void sub_1002329F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29)
{
  sub_1002364DC(&a29);
  sub_10004D2C8(v29);
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100232A74(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 40))();
}

void sub_100232A9C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v51 = 7;
  uint64_t v48 = 0;
  xpc_object_t v49 = 0;
  uint64_t v50 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)a2 + 56))(&v48);
  unsigned int v4 = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
  std::string __p = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)a2 + 48))(&__p);
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 320);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      int v7 = v6;
      uint64_t v8 = *(void *)(v3 + 312);
      if (v8)
      {
        *(_DWORD *)buf = 10;
        LazuliProvisioningServerWrapper::submitMetricForPhase(v8, &v51, v4 | (unint64_t)&_mh_execute_header, buf, 0, 0);
      }
      sub_10004D2C8(v7);
    }
  }
  memset(__str, 0, sizeof(__str));
  sub_100236560((uint64_t)v42, (uint64_t)&v48);
  LazuliProvisioningWebHelper::getCookie((uint64_t)v42, (uint64_t)__str);
  sub_10010C0E0((uint64_t)v42, v43);
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 76));
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = HIBYTE(v47);
    if (v47 < 0) {
      uint64_t v10 = v46;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "NC";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v4;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = __str[24];
    LOWORD(v53) = 2048;
    *(void *)((char *)&v53 + 2) = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [%s] Received app attestation response [%d] [cookie: %{BOOL}d] [body-size: %ld]", buf, 0x22u);
  }
  if ((int)v4 > 402)
  {
    if (v4 == 403)
    {
      char v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 76));
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = "YES";
        if (!__str[24]) {
          uint64_t v17 = "NO";
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "NC";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 403 forbidden response [cookie: %s]", buf, 0x16u);
      }
      uint64_t v18 = *(std::__shared_weak_count **)(v3 + 320);
      if (v18)
      {
        uint64_t v19 = std::__shared_weak_count::lock(v18);
        if (v19)
        {
          uint64_t v14 = v19;
          uint64_t v20 = *(void *)(v3 + 312);
          if (v20)
          {
            *(_DWORD *)buf = 10;
            LazuliProvisioningServerWrapper::submitMetricForPhase(v20, &v51, 0x100000193, buf, 0, 0);
            *(_DWORD *)buf = 2;
            LazuliProvisioningServerWrapper::failedFatally(v20);
          }
          goto LABEL_64;
        }
      }
      goto LABEL_65;
    }
    if (v4 != 511)
    {
LABEL_31:
      long long v21 = *(std::__shared_weak_count **)(v3 + 320);
      if (v21)
      {
        CFTypeID v22 = std::__shared_weak_count::lock(v21);
        if (v22)
        {
          uint64_t v23 = v22;
          uint64_t v24 = *(void *)(v3 + 312);
          if (v24)
          {
            *(_DWORD *)buf = 10;
            LazuliProvisioningServerWrapper::submitMetricForPhase(v24, &v51, v4 | (unint64_t)&_mh_execute_header, buf, 0, 0);
          }
          sub_10004D2C8(v23);
        }
      }
      *(void *)buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&buf[16] = sub_100233474;
      *(void *)&long long v53 = &unk_1019AD530;
      *((void *)&v53 + 1) = v3;
      int v54 = v51;
      xpc_object_t v56 = 0;
      v55[0] = off_1019AD7A8;
      v55[1] = _Block_copy(buf);
      xpc_object_t v56 = v55;
      LazuliProvisioningWebHelper::responseUnknown(v3, a2, (uint64_t)v55);
      sub_1002364DC(v55);
      goto LABEL_65;
    }
LABEL_17:
    uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 76));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = "NC";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [%s] Restarting provisioning from scratch", buf, 0xCu);
    }
    char v12 = *(std::__shared_weak_count **)(v3 + 320);
    if (v12)
    {
      int v13 = std::__shared_weak_count::lock(v12);
      if (v13)
      {
        uint64_t v14 = v13;
        uint64_t v15 = *(void *)(v3 + 312);
        if (v15)
        {
          *(_DWORD *)buf = 10;
          LazuliProvisioningServerWrapper::submitMetricForPhase(v15, &v51, v4 | (unint64_t)&_mh_execute_header, buf, 0, 0);
          LazuliProvisioningWebHelper::restartProvisioning((LazuliProvisioningServerWrapper **)v3, 0);
        }
        goto LABEL_64;
      }
    }
    goto LABEL_65;
  }
  if (v4 - 400 < 2) {
    goto LABEL_17;
  }
  if (v4 != 200) {
    goto LABEL_31;
  }
  if (__str[24])
  {
    std::string::operator=((std::string *)(v3 + 232), (const std::string *)__str);
  }
  else
  {
    unsigned int v25 = *(std::__shared_weak_count **)(v3 + 320);
    if (v25)
    {
      __int16 v26 = std::__shared_weak_count::lock(v25);
      if (v26)
      {
        uint64_t v14 = v26;
        uint64_t v27 = *(void *)(v3 + 312);
        if (v27)
        {
          uint64_t v28 = HIBYTE(v47);
          if (v47 < 0) {
            uint64_t v28 = v46;
          }
          if (v28)
          {
            buf[0] = 0;
            LOBYTE(v53) = 0;
            LazuliProvisioningServerWrapper::handleXml(v27, (uint64_t *)&__p, (uint64_t)buf, &v51);
LABEL_61:
            if ((_BYTE)v53 && (buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
LABEL_64:
            sub_10004D2C8(v14);
            goto LABEL_65;
          }
          *(_DWORD *)buf = 12;
          LazuliProvisioningServerWrapper::submitMetricForPhase(v27, &v51, 0x1000000C8, buf, 0, 0);
        }
        sub_10004D2C8(v14);
      }
    }
    if (*(char *)(v3 + 255) < 0) {
      uint64_t v29 = *(void *)(v3 + 240);
    }
    else {
      uint64_t v29 = *(unsigned __int8 *)(v3 + 255);
    }
    uint64_t v30 = *(uint64_t (**)(void))(**(void **)(v3 + 48) + 16);
    if (!v29)
    {
      __int16 v37 = *(NSObject **)v30();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = "NC";
        _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "[%s] No valid cookie during app attestation response", buf, 0xCu);
      }
      goto LABEL_65;
    }
    int v31 = *(NSObject **)v30();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = "NC";
      _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "[%s] Using previous (potentially invalid) cookie for OTP response", buf, 0xCu);
    }
  }
  uint64_t v32 = HIBYTE(v47);
  if (v47 < 0) {
    uint64_t v32 = v46;
  }
  if (v32)
  {
    v33 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 76));
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = "NC";
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 200 OK with XML", buf, 0xCu);
    }
    v34 = *(std::__shared_weak_count **)(v3 + 320);
    if (v34)
    {
      __int16 v35 = std::__shared_weak_count::lock(v34);
      if (v35)
      {
        uint64_t v14 = v35;
        uint64_t v36 = *(void *)(v3 + 312);
        if (v36)
        {
          sub_1000593FC((uint64_t)buf, (long long *)__str);
          LazuliProvisioningServerWrapper::handleXml(v36, (uint64_t *)&__p, (uint64_t)buf, &v51);
          goto LABEL_61;
        }
        sub_10004D2C8(v35);
      }
    }
  }
  if (*(char *)(v3 + 279) < 0) {
    uint64_t v38 = *(void *)(v3 + 264);
  }
  else {
    uint64_t v38 = *(unsigned __int8 *)(v3 + 279);
  }
  xpc_object_t v39 = *(uint64_t (**)(void))(**(void **)(v3 + 48) + 16);
  if (v38)
  {
    uint64_t v40 = *(NSObject **)v39();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = "NC";
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I [%s] Attestation complete, OTP recieved. Continuing...", buf, 0xCu);
    }
    LazuliProvisioningWebHelper::scheduleOtpResponse((LazuliProvisioningWebHelper *)v3);
  }
  xpc_object_t v41 = *(NSObject **)v39();
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = "NC";
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I [%s] Awaiting OTP", buf, 0xCu);
  }
  LazuliProvisioningWebHelper::startOtpReceptionTimer((LazuliProvisioningWebHelper *)v3);
LABEL_65:
  if (__str[24] && (__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if (SHIBYTE(v47) < 0) {
    operator delete(__p);
  }
  sub_10010C0E0((uint64_t)&v48, v49);
}

void sub_100233370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  sub_10004D2C8(v37);
  if (a19 && a18 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  sub_10010C0E0((uint64_t)&a27, a28);
  _Unwind_Resume(a1);
}

void sub_10023346C()
{
}

void sub_100233474(uint64_t a1, uint64_t a2)
{
}

void sub_100233484(uint64_t a1, uint64_t a2, int a3)
{
  int v62 = a3;
  uint64_t v59 = 0;
  v60 = 0;
  uint64_t v61 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)a2 + 56))(&v59);
  int v5 = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
  __s = 0;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  (*(void (**)(void ***__return_ptr))(**(void **)a2 + 48))(&__s);
  memset(__str, 0, sizeof(__str));
  sub_100236560((uint64_t)v53, (uint64_t)&v59);
  LazuliProvisioningWebHelper::getCookie((uint64_t)v53, (uint64_t)__str);
  sub_10010C0E0((uint64_t)v53, v54);
  *(unsigned char *)(a1 + 72) = 1;
  if (v5 > 402)
  {
    if (v5 == 403)
    {
      char v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = "YES";
        if (!__str[24]) {
          uint64_t v17 = "NO";
        }
        *(_DWORD *)buf = 136315394;
        v66 = "NC";
        __int16 v67 = 2080;
        v68 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 403 forbidden response [cookie: %s]", buf, 0x16u);
      }
      uint64_t v18 = *(std::__shared_weak_count **)(a1 + 320);
      if (v18)
      {
        uint64_t v19 = std::__shared_weak_count::lock(v18);
        if (v19)
        {
          uint64_t v14 = v19;
          uint64_t v20 = *(LazuliProvisioningServerWrapper **)(a1 + 312);
          if (v20)
          {
            *(_DWORD *)buf = 10;
            LazuliProvisioningServerWrapper::submitMetricForPhase((uint64_t)v20, &v62, 0x100000193, buf, 0, 0);
            LazuliProvisioningServerWrapper::handleForbiddenResponse(v20);
          }
          goto LABEL_71;
        }
      }
      goto LABEL_78;
    }
    if (v5 != 511) {
      goto LABEL_72;
    }
  }
  else if ((v5 - 400) >= 2)
  {
    if (v5 != 200) {
      goto LABEL_72;
    }
    if (!__str[24])
    {
      unsigned __int8 v8 = HIBYTE(v58);
      goto LABEL_59;
    }
    std::string::operator=((std::string *)(a1 + 232), (const std::string *)__str);
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = "YES";
      if (!__str[24]) {
        int v7 = "NO\x10";
      }
      *(_DWORD *)buf = 136315394;
      v66 = "NC";
      __int16 v67 = 2080;
      v68 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 200 OK [cookie: %s]", buf, 0x16u);
    }
    unsigned __int8 v8 = HIBYTE(v58);
    if (SHIBYTE(v58) < 0)
    {
      uint64_t v9 = v57;
      if (v57)
      {
        p_s = __s;
LABEL_31:
        if (v9 >= 27)
        {
          long long v21 = (char *)p_s + v9;
          CFTypeID v22 = p_s;
          do
          {
            uint64_t v23 = (char *)memchr(v22, 99, v9 - 26);
            if (!v23) {
              break;
            }
            if (*(void *)v23 == 0x612D746E65696C63
              && *((void *)v23 + 1) == 0x6369746E65687475
              && *((void *)v23 + 2) == 0x757165722D797469
              && *(void *)(v23 + 19) == 0x747365757165722DLL)
            {
              if (v23 == v21 || v23 - (char *)p_s == -1) {
                break;
              }
              BOOL v32 = sub_100232008(a1, (uint64_t)&__s);
              v33 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 16);
              if (v32)
              {
                v34 = *(NSObject **)v33();
                if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136315138;
                  v66 = "NC";
                  _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I [%s] Attestation flow triggered", buf, 0xCu);
                }
                goto LABEL_78;
              }
              xpc_object_t v44 = *(NSObject **)v33();
              if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315138;
                v66 = "NC";
                _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I [%s] Failed to decode secure response body", buf, 0xCu);
              }
              xpc_object_t v45 = *(std::__shared_weak_count **)(a1 + 320);
              if (v45)
              {
                uint64_t v46 = std::__shared_weak_count::lock(v45);
                if (v46)
                {
                  uint64_t v14 = v46;
                  uint64_t v47 = *(void *)(a1 + 312);
                  if (v47)
                  {
                    *(_DWORD *)buf = 4;
                    LazuliProvisioningServerWrapper::failedFatally(v47);
                  }
                  goto LABEL_71;
                }
              }
              goto LABEL_78;
            }
            CFTypeID v22 = (void **)(v23 + 1);
            uint64_t v9 = v21 - (char *)v22;
          }
          while (v21 - (char *)v22 >= 27);
        }
LABEL_59:
        if ((v8 & 0x80u) == 0) {
          uint64_t v35 = v8;
        }
        else {
          uint64_t v35 = v57;
        }
        if (v35)
        {
          uint64_t v36 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315138;
            v66 = "NC";
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 200 OK with XML", buf, 0xCu);
          }
          __int16 v37 = *(std::__shared_weak_count **)(a1 + 320);
          if (v37)
          {
            uint64_t v38 = std::__shared_weak_count::lock(v37);
            if (v38)
            {
              uint64_t v14 = v38;
              uint64_t v39 = *(void *)(a1 + 312);
              if (v39)
              {
                sub_1000593FC((uint64_t)__p, (long long *)__str);
                LazuliProvisioningServerWrapper::handleXml(v39, &__s, __p, &v62);
                if (v52)
                {
                  if (v51 < 0) {
                    operator delete(__p[0]);
                  }
                }
              }
LABEL_71:
              sub_10004D2C8(v14);
              goto LABEL_78;
            }
          }
          goto LABEL_78;
        }
LABEL_72:
        uint64_t v40 = *(std::__shared_weak_count **)(a1 + 320);
        if (v40)
        {
          xpc_object_t v41 = std::__shared_weak_count::lock(v40);
          if (v41)
          {
            xpc_object_t v42 = v41;
            uint64_t v43 = *(void *)(a1 + 312);
            if (v43)
            {
              *(_DWORD *)buf = 10;
              LazuliProvisioningServerWrapper::submitMetricForPhase(v43, &v62, v5 | (unint64_t)&_mh_execute_header, buf, 0, 0);
            }
            sub_10004D2C8(v42);
          }
        }
        aBlock[0] = _NSConcreteStackBlock;
        aBlock[1] = 0x40000000;
        aBlock[2] = sub_100233E40;
        aBlock[3] = &unk_1019AD550;
        aBlock[4] = a1;
        int v49 = v62;
        v64 = 0;
        v63[0] = off_1019AD7A8;
        v63[1] = _Block_copy(aBlock);
        v64 = v63;
        LazuliProvisioningWebHelper::responseUnknown(a1, a2, (uint64_t)v63);
        sub_1002364DC(v63);
        goto LABEL_78;
      }
    }
    else if (HIBYTE(v58))
    {
      uint64_t v9 = HIBYTE(v58);
      p_s = (void **)&__s;
      goto LABEL_31;
    }
    uint64_t v27 = *(std::__shared_weak_count **)(a1 + 320);
    if (v27)
    {
      uint64_t v28 = std::__shared_weak_count::lock(v27);
      if (v28)
      {
        uint64_t v29 = v28;
        uint64_t v30 = *(void *)(a1 + 312);
        if (v30)
        {
          *(_DWORD *)buf = 10;
          LazuliProvisioningServerWrapper::submitMetricForPhase(v30, &v62, 0x1000000C8, buf, 0, 0);
        }
        sub_10004D2C8(v29);
      }
    }
    int v31 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v66 = "NC";
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [%s] Awaiting OTP.", buf, 0xCu);
    }
    LazuliProvisioningWebHelper::startOtpReceptionTimer((LazuliProvisioningWebHelper *)a1);
    goto LABEL_78;
  }
  uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    v66 = "NC";
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [%s] Restarting provisioning from scratch", buf, 0xCu);
  }
  char v12 = *(std::__shared_weak_count **)(a1 + 320);
  if (v12)
  {
    int v13 = std::__shared_weak_count::lock(v12);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)(a1 + 312);
      if (v15)
      {
        *(_DWORD *)buf = 10;
        LazuliProvisioningServerWrapper::submitMetricForPhase(v15, &v62, v5 | (unint64_t)&_mh_execute_header, buf, 0, 0);
        LazuliProvisioningWebHelper::restartProvisioning((LazuliProvisioningServerWrapper **)a1, 0);
      }
      goto LABEL_71;
    }
  }
LABEL_78:
  if (__str[24] && (__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if (SHIBYTE(v58) < 0) {
    operator delete(__s);
  }
  sub_10010C0E0((uint64_t)&v59, v60);
}

void sub_100233D4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43,void *a44)
{
  sub_10004D2C8(v44);
  if (a35 && a34 < 0) {
    operator delete(__p);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  sub_10010C0E0((uint64_t)&a43, a44);
  _Unwind_Resume(a1);
}

void sub_100233E38()
{
}

uint64_t sub_100233E40(uint64_t a1, uint64_t a2)
{
  return sub_100233484(*(void *)(a1 + 32), a2, *(unsigned int *)(a1 + 40));
}

void sub_100233E50(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)a2 + 56))(&v42);
  unsigned int v4 = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)a2 + 48))(&v39);
  long long v37 = 0u;
  long long v38 = 0u;
  sub_100236560((uint64_t)v35, (uint64_t)&v42);
  LazuliProvisioningWebHelper::getCookie((uint64_t)v35, (uint64_t)&v37);
  sub_10010C0E0((uint64_t)v35, v36);
  int v34 = 1;
  if (v4 == 511) {
    goto LABEL_25;
  }
  if (v4 != 403)
  {
    if (v4 != 200) {
      goto LABEL_37;
    }
    uint64_t v5 = HIBYTE(v41);
    if (v41 < 0) {
      uint64_t v5 = v40;
    }
    if (v5)
    {
      uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        uint64_t v48 = "NC";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 200 OK with XML", buf, 0xCu);
      }
      int v7 = *(std::__shared_weak_count **)(a1 + 320);
      if (v7)
      {
        unsigned __int8 v8 = std::__shared_weak_count::lock(v7);
        if (v8)
        {
          uint64_t v9 = v8;
          uint64_t v10 = *(void *)(a1 + 312);
          if (v10)
          {
            LOBYTE(__p) = 0;
            char v33 = 0;
            LazuliProvisioningServerWrapper::handleXml(v10, (uint64_t *)&v39, (uint64_t)&__p, &v34);
            if (v33)
            {
              if (v32 < 0) {
                operator delete(__p);
              }
            }
          }
LABEL_23:
          sub_10004D2C8(v9);
          goto LABEL_45;
        }
      }
      goto LABEL_45;
    }
    if (!BYTE8(v38))
    {
LABEL_37:
      CFTypeID v22 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        uint64_t v48 = "NC";
        __int16 v49 = 1024;
        LODWORD(v50) = v4;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "[%s] Unhandled response in first access response: %d", buf, 0x12u);
      }
      uint64_t v23 = *(std::__shared_weak_count **)(a1 + 320);
      if (v23)
      {
        uint64_t v24 = std::__shared_weak_count::lock(v23);
        if (v24)
        {
          unsigned int v25 = v24;
          uint64_t v26 = *(void *)(a1 + 312);
          if (v26)
          {
            *(_DWORD *)buf = 10;
            LazuliProvisioningServerWrapper::submitMetricForPhase(v26, &v34, v4 | (unint64_t)&_mh_execute_header, buf, 0, 0);
          }
          sub_10004D2C8(v25);
        }
      }
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000;
      aBlock[2] = sub_1002347DC;
      aBlock[3] = &unk_1019AD570;
      aBlock[4] = a1;
      uint64_t v46 = 0;
      v45[0] = off_1019AD7A8;
      v45[1] = _Block_copy(aBlock);
      uint64_t v46 = v45;
      LazuliProvisioningWebHelper::responseUnknown(a1, a2, (uint64_t)v45);
      sub_1002364DC(v45);
      goto LABEL_45;
    }
LABEL_25:
    char v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = "YES";
      if (!BYTE8(v38)) {
        uint64_t v17 = "NO";
      }
      *(_DWORD *)buf = 136315394;
      uint64_t v48 = "NC";
      __int16 v49 = 2080;
      uint64_t v50 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [%s] Switching to secure request [cookie: %s]", buf, 0x16u);
    }
    uint64_t v18 = *(std::__shared_weak_count **)(a1 + 320);
    if (v18)
    {
      uint64_t v19 = std::__shared_weak_count::lock(v18);
      if (v19)
      {
        uint64_t v20 = v19;
        uint64_t v21 = *(void *)(a1 + 312);
        if (v21)
        {
          *(_DWORD *)buf = 10;
          LazuliProvisioningServerWrapper::submitMetricForPhase(v21, &v34, v4 | (unint64_t)&_mh_execute_header, buf, 0, 0);
        }
        sub_10004D2C8(v20);
      }
    }
    sub_1000593FC((uint64_t)v28, &v37);
    sub_100234538((LazuliProvisioningWebHelper *)a1, (uint64_t)v28);
    if (v30 && v29 < 0) {
      operator delete(v28[0]);
    }
    goto LABEL_45;
  }
  uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    char v12 = "YES";
    if (!BYTE8(v38)) {
      char v12 = "NO";
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v48 = "NC";
    __int16 v49 = 2080;
    uint64_t v50 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 403 forbidden response [cookie: %s]", buf, 0x16u);
  }
  int v13 = *(std::__shared_weak_count **)(a1 + 320);
  if (v13)
  {
    uint64_t v14 = std::__shared_weak_count::lock(v13);
    if (v14)
    {
      uint64_t v9 = v14;
      uint64_t v15 = *(LazuliProvisioningServerWrapper **)(a1 + 312);
      if (v15)
      {
        *(_DWORD *)buf = 10;
        LazuliProvisioningServerWrapper::submitMetricForPhase((uint64_t)v15, &v34, 0x100000193, buf, 0, 0);
        LazuliProvisioningServerWrapper::handleForbiddenResponse(v15);
      }
      goto LABEL_23;
    }
  }
LABEL_45:
  if (BYTE8(v38) && SBYTE7(v38) < 0) {
    operator delete((void *)v37);
  }
  if (SHIBYTE(v41) < 0) {
    operator delete(v39);
  }
  sub_10010C0E0((uint64_t)&v42, v43);
}

void sub_100234444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39)
{
  if (a28 && a27 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v39);
  if (a39 && a38 < 0) {
    operator delete(a33);
  }
  if (*(char *)(v40 - 137) < 0) {
    operator delete(*(void **)(v40 - 160));
  }
  sub_10010C0E0(v40 - 136, *(void **)(v40 - 128));
  _Unwind_Resume(a1);
}

void sub_100234530()
{
}

void sub_100234538(LazuliProvisioningWebHelper *a1, uint64_t a2)
{
  int v4 = sub_100231D00((uint64_t)a1);
  int v5 = v4;
  v17[0] = 0;
  v17[1] = 0;
  char v16 = (uint64_t *)v17;
  if (!*(unsigned char *)(a2 + 24)) {
    goto LABEL_7;
  }
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a2 + 23)) {
      goto LABEL_4;
    }
LABEL_7:
    int v7 = v4 | 0x8680;
    goto LABEL_8;
  }
  if (!*(void *)(a2 + 8)) {
    goto LABEL_7;
  }
LABEL_4:
  sub_100058DB0(&__p, "Cookie");
  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
  uint64_t v6 = sub_10014BECC(&v16, (uint64_t)&__p, (uint64_t)&unk_10144E20E, &__str);
  std::string::operator=((std::string *)((char *)v6 + 56), (const std::string *)a2);
  int v7 = v5 | 0x8600;
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
LABEL_8:
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  LazuliProvisioningWebHelper::getHeaders(a1, v7, (uint64_t)&__p);
  *((unsigned char *)a1 + 72) = 1;
  int v12 = 2;
  sub_100564D6C((uint64_t)a1 + 112, &__p, (uint64_t *)&__str);
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_10023533C;
  aBlock[3] = &unk_1019AD590;
  aBlock[4] = a1;
  uint64_t v19 = 0;
  v18[0] = off_1019AD7A8;
  v18[1] = _Block_copy(aBlock);
  uint64_t v19 = v18;
  v8.__r_.__value_.__s.__data_[0] = 0;
  char v9 = 0;
  LazuliProvisioningWebHelper::runWithTimeout((uint64_t)a1, &v12, &__str, (uint64_t)&v16, (uint64_t)v18, &v8);
  if (v9 && SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v8.__r_.__value_.__l.__data_);
  }
  sub_1002364DC(v18);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  sub_10010C0E0((uint64_t)&__p, v14);
  sub_10010C0E0((uint64_t)&v16, v17[0]);
}

void sub_100234754(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  sub_10010C0E0(v33 - 96, *(void **)(v33 - 88));
  _Unwind_Resume(a1);
}

uint64_t sub_1002347DC(uint64_t a1)
{
  return sub_100233E50(*(void *)(a1 + 32));
}

void sub_1002347E4(uint64_t a1)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v56 = 0;
  char v2 = (const std::string *)(a1 + 328);
  if (*(char *)(a1 + 351) < 0)
  {
    sub_10004FC84(__dst, *(void **)(a1 + 328), *(void *)(a1 + 336));
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
    uint64_t v56 = *(void *)(a1 + 344);
  }
  v53[0] = 0;
  v53[1] = 0;
  uint64_t v54 = 0;
  if (*(char *)(a1 + 423) < 0)
  {
    sub_10004FC84(v53, *(void **)(a1 + 400), *(void *)(a1 + 408));
  }
  else
  {
    *(_OWORD *)long long v53 = *(_OWORD *)(a1 + 400);
    uint64_t v54 = *(void *)(a1 + 416);
  }
  if (sub_1002357A8((uint64_t *)__dst, "302")) {
    goto LABEL_8;
  }
  if (!sub_1002357A8((uint64_t *)__dst, "31")) {
    goto LABEL_105;
  }
  if (SHIBYTE(v56) < 0)
  {
    int v21 = *((char *)__dst[0] + 3);
    if (v21 <= 47) {
      goto LABEL_105;
    }
  }
  else
  {
    LOBYTE(v21) = BYTE3(__dst[0]);
    if (SBYTE3(__dst[0]) < 48) {
      goto LABEL_105;
    }
  }
  if (v21 <= 0x36u)
  {
LABEL_8:
    if (sub_1002357A8((uint64_t *)v53, "+1")) {
      goto LABEL_105;
    }
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      PersonalityIdFromSlotId();
      uint64_t v4 = v73[23];
      if (v73[23] >= 0)
      {
        int v5 = v73;
      }
      else
      {
        uint64_t v4 = *(void *)&v73[8];
        int v5 = *(const char **)v73;
      }
      uint64_t v6 = v4 ? (char *)v5 : "<invalid>";
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Generating MSISDN mismatch ABC report for %{public}s", buf, 0xCu);
      if ((v73[23] & 0x80000000) != 0) {
        operator delete(*(void **)v73);
      }
    }
    LazuliProvisioningWebHelper::describe((LazuliProvisioningWebHelper *)a1);
    int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      std::string::basic_string((std::string *)v73, v2, 0, 6uLL, (std::allocator<char> *)buf);
      int v8 = v73[23];
      char v9 = *(unsigned char **)v73;
      std::string::basic_string((std::string *)buf, (const std::string *)(a1 + 400), 0, 6uLL, (std::allocator<char> *)__p);
      uint64_t v10 = v73;
      if (v8 < 0) {
        uint64_t v10 = v9;
      }
      if ((SBYTE7(v65) & 0x80u) == 0) {
        uint64_t v11 = buf;
      }
      else {
        uint64_t v11 = *(uint8_t **)buf;
      }
      *(_DWORD *)int v62 = 136446466;
      *(void *)&v62[4] = v10;
      *(_WORD *)&v62[12] = 2082;
      *(void *)&v62[14] = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I IMSI prefix: %{public}s, MSISDN prefix: %{public}s, ", v62, 0x16u);
      if (SBYTE7(v65) < 0) {
        operator delete(*(void **)buf);
      }
      if ((v73[23] & 0x80000000) != 0) {
        operator delete(*(void **)v73);
      }
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 80));
    int v13 = ServiceMap;
    if (v14 < 0)
    {
      uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        uint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    *(void *)v73 = v14;
    uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v73);
    if (!v18)
    {
      std::mutex::unlock(v13);
      goto LABEL_68;
    }
    uint64_t v20 = v18[3];
    uint64_t v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      if (!v20) {
        goto LABEL_67;
      }
    }
    else
    {
      std::mutex::unlock(v13);
      if (!v20) {
        goto LABEL_68;
      }
    }
    memset(v62, 0, sizeof(v62));
    *(_OWORD *)buf = 0u;
    long long v65 = 0u;
    __int16 v60 = 0;
    char v59 = 0;
    if ((*(unsigned int (**)(uint64_t, void, uint8_t *, uint8_t *, char *, __int16 *, char *))(*(void *)v20 + 256))(v20, *(unsigned int *)(a1 + 76), v62, buf, (char *)&v60 + 1, &v60, &v59))
    {
      CFTypeID v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        int v23 = (char)v62[23];
        uint64_t v24 = *(uint8_t **)v62;
        asString();
        unsigned int v25 = v62;
        if (v23 < 0) {
          unsigned int v25 = v24;
        }
        if (v58 >= 0) {
          uint64_t v26 = __p;
        }
        else {
          uint64_t v26 = (void **)__p[0];
        }
        if (HIBYTE(v60)) {
          uint64_t v27 = "YES";
        }
        else {
          uint64_t v27 = "NO";
        }
        *(_DWORD *)v73 = 136447234;
        if ((_BYTE)v60) {
          uint64_t v28 = "YES";
        }
        else {
          uint64_t v28 = "NO";
        }
        *(void *)&v73[4] = v25;
        if (v59) {
          char v29 = "YES";
        }
        else {
          char v29 = "NO";
        }
        *(_WORD *)&v73[12] = 2082;
        *(void *)&v73[14] = v26;
        *(_WORD *)&v73[22] = 2080;
        *(void *)&v73[24] = v27;
        *(_WORD *)&v73[32] = 2080;
        *(void *)&v73[34] = v28;
        *(_WORD *)&v73[42] = 2080;
        *(void *)&v73[44] = v29;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Label: %{public}s, PhoneNumber: %{public}s, exists: %s, editable: %s, read: %s", v73, 0x34u);
        if (v58 < 0) {
          operator delete(__p[0]);
        }
      }
    }
    if (SBYTE7(v65) < 0) {
      operator delete(*(void **)buf);
    }
    if ((char)v62[23] < 0) {
      operator delete(*(void **)v62);
    }
    if (!v19)
    {
LABEL_68:
      memset(&v73[8], 0, 32);
      *(void *)&v73[40] = 0x600000000000000;
      *(_OWORD *)&v73[56] = 0u;
      long long v77 = 0u;
      long long v76 = 0u;
      memset(&v74, 0, sizeof(v74));
      uint64_t v75 = 23;
      qmemcpy(&v73[23], "\tLazuli", 7);
      qmemcpy(v73, "Telephony", 9);
      v73[71] = 20;
      qmemcpy(&v73[48], "LazuliMsisdnMismatch", 20);
      sub_10003ECB8(&v74, "Trusted phone number does not match IMSI", 0x28uLL);
      v75 |= 0x11uLL;
      sub_10003E168(buf, (void *)(a1 + 8));
      uint64_t v31 = *(void *)buf;
      char v30 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v30);
      }
      char v32 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 80));
      uint64_t v33 = v32;
      if (v34 < 0)
      {
        uint64_t v35 = (unsigned __int8 *)(v34 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v36 = 5381;
        do
        {
          uint64_t v34 = v36;
          unsigned int v37 = *v35++;
          uint64_t v36 = (33 * v36) ^ v37;
        }
        while (v37);
      }
      std::mutex::lock(v32);
      *(void *)buf = v34;
      long long v38 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)buf);
      if (v38)
      {
        uint64_t v40 = v38[3];
        uint64_t v39 = (std::__shared_weak_count *)v38[4];
        if (v39)
        {
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v33);
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v39);
          char v41 = 0;
          if (!v40) {
            goto LABEL_91;
          }
          goto LABEL_79;
        }
      }
      else
      {
        uint64_t v40 = 0;
      }
      std::mutex::unlock(v33);
      uint64_t v39 = 0;
      char v41 = 1;
      if (!v40)
      {
LABEL_91:
        if ((v41 & 1) == 0) {
          sub_10004D2C8(v39);
        }
        if (v30) {
          std::__shared_weak_count::__release_weak(v30);
        }
        if (SBYTE7(v77) < 0) {
          operator delete((void *)v76);
        }
        if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v74.__r_.__value_.__l.__data_);
        }
        if ((v73[71] & 0x80000000) != 0) {
          operator delete(*(void **)&v73[48]);
        }
        if ((v73[47] & 0x80000000) != 0) {
          operator delete(*(void **)&v73[24]);
        }
        if ((v73[23] & 0x80000000) != 0) {
          operator delete(*(void **)v73);
        }
        goto LABEL_105;
      }
LABEL_79:
      sub_1000DB86C((char *)buf, (long long *)v73);
      if (v30) {
        atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      v63 = 0;
      uint64_t v42 = operator new(0x20uLL);
      *uint64_t v42 = off_1019AD728;
      v42[1] = a1;
      v42[2] = v31;
      v42[3] = v30;
      v63 = v42;
      (*(void (**)(uint64_t, uint8_t *, uint8_t *))(*(void *)v40 + 16))(v40, buf, v62);
      sub_1000DBADC(v62);
      if (v72 < 0) {
        operator delete(v71);
      }
      if (v70 < 0) {
        operator delete(v69);
      }
      if (v68 < 0) {
        operator delete(v67);
      }
      if (v66 < 0) {
        operator delete(*((void **)&v65 + 1));
      }
      if (SBYTE7(v65) < 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_91;
    }
LABEL_67:
    sub_10004D2C8(v19);
    goto LABEL_68;
  }
LABEL_105:
  if (SHIBYTE(v54) < 0) {
    operator delete(v53[0]);
  }
  if (SHIBYTE(v56) < 0) {
    operator delete(__dst[0]);
  }
  uint64_t v43 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v44 = (void *)(a1 + 112);
    if (*(char *)(a1 + 135) < 0) {
      uint64_t v44 = (void *)*v44;
    }
    uint64_t v45 = *(int *)(a1 + 504);
    if (v45 > 4) {
      uint64_t v46 = "kCellular";
    }
    else {
      uint64_t v46 = off_1019AD828[v45];
    }
    *(_DWORD *)v73 = 136315650;
    *(void *)&v73[4] = "NC";
    *(_WORD *)&v73[12] = 2082;
    *(void *)&v73[14] = v44;
    *(_WORD *)&v73[22] = 2082;
    *(void *)&v73[24] = v46;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [%s] Starting first access on: [%{public}s] with interface [%{public}s] ", v73, 0x20u);
  }
  if (*(_DWORD *)(a1 + 504) == 3)
  {
    LOBYTE(v50) = 0;
    char v52 = 0;
    sub_100234538((LazuliProvisioningWebHelper *)a1, (uint64_t)&v50);
    if (v52 && v51 < 0)
    {
      uint64_t v47 = v50;
LABEL_129:
      operator delete(v47);
    }
  }
  else
  {
    memset(buf, 0, sizeof(buf));
    *(void *)&long long v65 = 0;
    *(_OWORD *)&v73[8] = 0uLL;
    *(void *)v73 = &v73[8];
    sub_1005649F0(a1 + 112, v73, (uint64_t *)buf);
    sub_10010C0E0((uint64_t)v73, *(void **)&v73[8]);
    memset(v62, 0, sizeof(v62));
    sub_100235804(v73, "User-Agent", "iPhoneOS");
    sub_1002369E0((uint64_t)v62, (long long *)v73, 1);
    if ((v73[47] & 0x80000000) != 0) {
      operator delete(*(void **)&v73[24]);
    }
    if ((v73[23] & 0x80000000) != 0) {
      operator delete(*(void **)v73);
    }
    *(_DWORD *)v73 = 1;
    v61[0] = off_1019AD6A8;
    v61[1] = a1;
    v61[3] = v61;
    v48.__r_.__value_.__s.__data_[0] = 0;
    char v49 = 0;
    LazuliProvisioningWebHelper::runWithTimeout(a1, v73, (std::string *)buf, (uint64_t)v62, (uint64_t)v61, &v48);
    if (v49 && SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v48.__r_.__value_.__l.__data_);
    }
    sub_1002364DC(v61);
    sub_10010C0E0((uint64_t)v62, *(void **)&v62[8]);
    if (SBYTE7(v65) < 0)
    {
      uint64_t v47 = *(void **)buf;
      goto LABEL_129;
    }
  }
}

void sub_1002351AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  if (a57 < 0) {
    operator delete(__p);
  }
  if (a50 < 0) {
    operator delete(a45);
  }
  if (v57) {
    sub_10004D2C8(v57);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  _Unwind_Resume(exception_object);
}

void sub_10023533C(uint64_t a1, uint64_t a2)
{
}

void sub_100235348(LazuliProvisioningWebHelper *a1)
{
  int v2 = sub_100231D00((uint64_t)a1);
  int v12 = 0;
  int v13 = 0;
  uint64_t v14 = 0;
  LazuliProvisioningWebHelper::getHeaders(a1, v2, (uint64_t)&v12);
  sub_100058DB0(&__p, "rcs_state");
  p_p = &__p;
  uint64_t v3 = sub_10014BECC(&v12, (uint64_t)&__p, (uint64_t)&unk_10144E20E, (_OWORD **)&p_p);
  if (*((char *)v3 + 79) < 0)
  {
    *((void *)v3 + 8) = 2;
    uint64_t v4 = (char *)*((void *)v3 + 7);
  }
  else
  {
    uint64_t v4 = (char *)v3 + 56;
    *((unsigned char *)v3 + 79) = 2;
  }
  strcpy(v4, "-4");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  int v10 = 6;
  sub_100564D6C((uint64_t)a1 + 112, &v12, (uint64_t *)&__p);
  v9[0] = 0;
  v9[1] = 0;
  aBlock[4] = a1;
  p_p = (std::string *)v9;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1002355B0;
  aBlock[3] = &unk_1019AD5B0;
  uint64_t v16 = 0;
  v15[0] = off_1019AD7A8;
  v15[1] = _Block_copy(aBlock);
  uint64_t v16 = v15;
  v5.__r_.__value_.__s.__data_[0] = 0;
  char v6 = 0;
  LazuliProvisioningWebHelper::runWithTimeout((uint64_t)a1, &v10, &__p, (uint64_t)&p_p, (uint64_t)v15, &v5);
  if (v6 && SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v5.__r_.__value_.__l.__data_);
  }
  sub_1002364DC(v15);
  sub_10010C0E0((uint64_t)&p_p, v9[0]);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_10010C0E0((uint64_t)&v12, v13);
}

void sub_100235538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a15 && a14 < 0) {
    operator delete(__p);
  }
  sub_1002364DC((void *)(v30 - 56));
  sub_10010C0E0((uint64_t)&a21, a22);
  if (a30 < 0) {
    operator delete(a25);
  }
  sub_10010C0E0(v30 - 80, *(void **)(v30 - 72));
  _Unwind_Resume(a1);
}

void sub_1002355A8()
{
}

void sub_1002355B0(uint64_t a1, uint64_t a2)
{
}

void sub_1002355B8(LazuliProvisioningWebHelper *a1)
{
  int v2 = sub_100231D00((uint64_t)a1);
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  LazuliProvisioningWebHelper::getHeaders(a1, v2, (uint64_t)&v10);
  int v9 = 5;
  sub_100564D6C((uint64_t)a1 + 112, &v10, (uint64_t *)&__str);
  v7[0] = 0;
  v7[1] = 0;
  aBlock[4] = a1;
  char v6 = v7;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1002357A0;
  aBlock[3] = &unk_1019AD5D0;
  uint64_t v14 = 0;
  v13[0] = off_1019AD7A8;
  v13[1] = _Block_copy(aBlock);
  uint64_t v14 = v13;
  __p.__r_.__value_.__s.__data_[0] = 0;
  char v4 = 0;
  LazuliProvisioningWebHelper::runWithTimeout((uint64_t)a1, &v9, &__str, (uint64_t)&v6, (uint64_t)v13, &__p);
  if (v4 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_1002364DC(v13);
  sub_10010C0E0((uint64_t)&v6, v7[0]);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  sub_10010C0E0((uint64_t)&v10, v11);
}

void sub_100235734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,void *a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a15 && a14 < 0) {
    operator delete(__p);
  }
  sub_1002364DC((void *)(v29 - 56));
  sub_10010C0E0((uint64_t)&a21, a22);
  if (a29 < 0) {
    operator delete(a24);
  }
  sub_10010C0E0(v29 - 80, *(void **)(v29 - 72));
  _Unwind_Resume(a1);
}

void sub_1002357A0(uint64_t a1, uint64_t a2)
{
}

BOOL sub_1002357A8(uint64_t *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (*((char *)a1 + 23) < 0)
  {
    char v6 = a1;
    a1 = (uint64_t *)*a1;
    uint64_t v5 = v6[1];
  }
  else
  {
    uint64_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  v8[0] = a1;
  v8[1] = v5;
  return sub_100235858(v8, __s, v4);
}

void *sub_100235804(void *a1, char *a2, char *a3)
{
  uint64_t v5 = sub_100058DB0(a1, a2);
  sub_100058DB0(v5 + 3, a3);
  return a1;
}

void sub_10023583C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100235858(void *a1, void *__s2, size_t a3)
{
  return a1[1] >= a3 && sub_10023589C(a1, 0, a3, __s2, a3) == 0;
}

uint64_t sub_10023589C(void *a1, unint64_t a2, size_t a3, void *__s2, size_t a5)
{
  unint64_t v5 = a1[1];
  BOOL v6 = v5 >= a2;
  size_t v7 = v5 - a2;
  if (!v6) {
    sub_1000C14F0("string_view::substr");
  }
  int v9 = (const void *)(*a1 + a2);
  if (v7 >= a3) {
    size_t v10 = a3;
  }
  else {
    size_t v10 = v7;
  }
  if (a5 >= v10) {
    size_t v11 = v10;
  }
  else {
    size_t v11 = a5;
  }
  LODWORD(result) = memcmp(v9, __s2, v11);
  if (v10 < a5) {
    unsigned int v13 = -1;
  }
  else {
    unsigned int v13 = 1;
  }
  if (v10 == a5) {
    unsigned int v13 = 0;
  }
  if (result) {
    return result;
  }
  else {
    return v13;
  }
}

void *sub_10023590C(void *a1)
{
  *a1 = off_1019AD618;
  int v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100235958(void *a1)
{
  *a1 = off_1019AD618;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

__n128 sub_1002359C4(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)int v2 = off_1019AD618;
  *((void *)v2 + 1) = v4;
  *((void *)v2 + 2) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100235A28(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)a2 = off_1019AD618;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(a2 + 24) = result;
  return result;
}

void sub_100235A68(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100235A78(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

uint64_t sub_100235AB8(void *a1, long long *a2, uint64_t a3)
{
  LOBYTE(v38) = 0;
  char v42 = 0;
  if (*((unsigned char *)a2 + 48))
  {
    long long v38 = *a2;
    uint64_t v39 = *((void *)a2 + 2);
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    long long v40 = v5;
    uint64_t v41 = *((void *)a2 + 5);
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    char v42 = 1;
  }
  int v6 = *(unsigned __int8 *)(a3 + 24);
  if (*(unsigned char *)(a3 + 24))
  {
    size_t v7 = *(void **)a3;
    char v3 = *(unsigned char *)(a3 + 23);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  else
  {
    size_t v7 = 0;
  }
  int v8 = (std::__shared_weak_count *)a1[2];
  uint64_t v9 = a1[3];
  if (v8)
  {
    size_t v10 = std::__shared_weak_count::lock(v8);
    if (v10)
    {
      size_t v11 = v10;
      if (!a1[1])
      {
LABEL_63:
        sub_10004D2C8(v11);
        goto LABEL_64;
      }
      uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), *(unsigned int *)(v9 + 76));
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = "NC";
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [%s] Attestation response received", buf, 0xCu);
      }
      if (!v42)
      {
        uint64_t v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), *(unsigned int *)(v9 + 76));
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)&uint8_t buf[4] = "NC";
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [%s] Attestation output: (nil)", buf, 0xCu);
        }
        uint64_t v19 = *(std::__shared_weak_count **)(v9 + 320);
        if (v19)
        {
          uint64_t v20 = std::__shared_weak_count::lock(v19);
          if (v20)
          {
            int v21 = v20;
            uint64_t v22 = *(void *)(v9 + 312);
            if (v22)
            {
              *(_DWORD *)buf = 3;
              LODWORD(v51.__r_.__value_.__l.__data_) = 11;
              LazuliProvisioningServerWrapper::submitMetricForPhase(v22, buf, 0, &v51, 0, 0);
              LazuliProvisioningWebHelper::restartProvisioning((LazuliProvisioningServerWrapper **)v9, 0);
              sub_10004D2C8(v21);
              goto LABEL_63;
            }
            sub_10004D2C8(v21);
          }
        }
      }
      memset(&v51, 0, sizeof(v51));
      sub_10080C6FC(a1 + 4, &v51);
      v50[0] = 0;
      v50[1] = 0;
      char v49 = (uint64_t *)v50;
      if (*(char *)(v9 + 255) < 0)
      {
        if (*(void *)(v9 + 240)) {
          goto LABEL_14;
        }
      }
      else if (*(unsigned char *)(v9 + 255))
      {
LABEL_14:
        sub_100058DB0(buf, "Cookie");
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
        unsigned int v13 = sub_10014BECC(&v49, (uint64_t)buf, (uint64_t)&unk_10144E20E, &__str);
        std::string::operator=((std::string *)((char *)v13 + 56), (const std::string *)(v9 + 232));
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v14 = *(std::__shared_weak_count **)(v9 + 320);
        if (!v14) {
          goto LABEL_34;
        }
        uint64_t v15 = std::__shared_weak_count::lock(v14);
        if (!v15) {
          goto LABEL_34;
        }
        uint64_t v16 = v15;
        uint64_t v17 = *(void *)(v9 + 312);
        if (v17)
        {
          *(_DWORD *)buf = 3;
          LODWORD(__str.__r_.__value_.__l.__data_) = 16;
          LazuliProvisioningServerWrapper::submitMetricForPhase(v17, buf, 0, &__str, 0, 0);
        }
LABEL_33:
        sub_10004D2C8(v16);
LABEL_34:
        sub_100058DB0(buf, "Content-Type");
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
        uint64_t v27 = sub_10014BECC(&v49, (uint64_t)buf, (uint64_t)&unk_10144E20E, &__str);
        sub_10003ECB8((std::string *)((char *)v27 + 56), "multipart/form-data;boundary=\"boundary\"", 0x27uLL);
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v28 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), *(unsigned int *)(v9 + 76));
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v29 = (long long *)v38;
          if (v39 >= 0) {
            uint64_t v29 = &v38;
          }
          uint64_t v30 = &v40;
          if (v41 < 0) {
            uint64_t v30 = (long long *)v40;
          }
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "NC";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v29;
          *(_WORD *)&buf[22] = 2082;
          xpc_object_t v55 = v30;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I [%s] Sending attestation output to server: [%{public}s], [%{public}s]", buf, 0x20u);
        }
        memset(buf, 0, sizeof(buf));
        int v31 = sub_100231D00(v9);
        LazuliProvisioningWebHelper::getHeaders((LazuliProvisioningWebHelper *)v9, v31, (uint64_t)buf);
        if (*(char *)(v9 + 255) < 0)
        {
          **(unsigned char **)(v9 + 232) = 0;
          *(void *)(v9 + 240) = 0;
        }
        else
        {
          *(unsigned char *)(v9 + 232) = 0;
          *(unsigned char *)(v9 + 255) = 0;
        }
        *(unsigned char *)(v9 + 72) = 1;
        int v48 = 7;
        sub_100564D6C(v9 + 112, buf, (uint64_t *)&__str);
        aBlock[0] = _NSConcreteStackBlock;
        aBlock[1] = 0x40000000;
        aBlock[2] = sub_100232A9C;
        aBlock[3] = &unk_1019AD510;
        aBlock[4] = v9;
        long long v53 = 0;
        v52[0] = off_1019AD7A8;
        v52[1] = _Block_copy(aBlock);
        long long v53 = v52;
        if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, v51.__r_.__value_.__l.__data_, v51.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v51;
        }
        std::string __p = __dst;
        memset(&__dst, 0, sizeof(__dst));
        char v45 = 1;
        LazuliProvisioningWebHelper::runWithTimeout(v9, &v48, &__str, (uint64_t)&v49, (uint64_t)v52, &__p);
        if (v45 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        sub_1002364DC(v52);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        char v32 = *(std::__shared_weak_count **)(v9 + 320);
        if (v32)
        {
          uint64_t v33 = std::__shared_weak_count::lock(v32);
          if (v33)
          {
            uint64_t v34 = v33;
            uint64_t v35 = *(LazuliProvisioningServerWrapper **)(v9 + 312);
            if (v35) {
              LazuliProvisioningServerWrapper::attestationComplete(v35);
            }
            sub_10004D2C8(v34);
          }
        }
        sub_10010C0E0((uint64_t)buf, *(void **)&buf[8]);
        goto LABEL_61;
      }
      int v23 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), *(unsigned int *)(v9 + 76));
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = "NC";
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "[%s] Attestation failed: No stored cookie", buf, 0xCu);
      }
      uint64_t v24 = *(std::__shared_weak_count **)(v9 + 320);
      if (!v24) {
        goto LABEL_34;
      }
      unsigned int v25 = std::__shared_weak_count::lock(v24);
      if (!v25) {
        goto LABEL_34;
      }
      uint64_t v16 = v25;
      uint64_t v26 = *(void *)(v9 + 312);
      if (v26)
      {
        *(_DWORD *)buf = 3;
        LODWORD(__str.__r_.__value_.__l.__data_) = 12;
        LazuliProvisioningServerWrapper::submitMetricForPhase(v26, buf, 0, &__str, 0, 0);
        LazuliProvisioningWebHelper::restartProvisioning((LazuliProvisioningServerWrapper **)v9, 0);
        sub_10004D2C8(v16);
LABEL_61:
        sub_10010C0E0((uint64_t)&v49, v50[0]);
        if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v51.__r_.__value_.__l.__data_);
        }
        goto LABEL_63;
      }
      goto LABEL_33;
    }
  }
LABEL_64:
  uint64_t v36 = *(std::__shared_weak_count **)(v9 + 584);
  *(_OWORD *)(v9 + 576) = 0u;
  if (v36) {
    sub_10004D2C8(v36);
  }
  if (v6 && v3 < 0) {
    operator delete(v7);
  }
  return sub_10013E528((uint64_t)&v38);
}

void sub_1002361E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,char a44,void *a45)
{
  sub_10004D2C8(v47);
  sub_10010C0E0((uint64_t)&a44, a45);
  if (*(char *)(v50 - 161) < 0) {
    operator delete(*(void **)(v50 - 184));
  }
  sub_10004D2C8(v46);
  if (v48)
  {
    if (v49 < 0) {
      operator delete(v45);
    }
  }
  sub_10013E528((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10023630C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10023634C()
{
}

void *sub_100236358(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1002363E0()
{
}

uint64_t sub_1002363F4()
{
  return 0;
}

void *sub_1002363FC(uint64_t a1, void *a2)
{
  *a2 = off_1019AD7A8;
  __n128 result = *(void **)(a1 + 8);
  if (result) {
    __n128 result = _Block_copy(result);
  }
  a2[1] = result;
  return result;
}

void sub_100236448(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_100236480(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100236490(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019AD818)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1002364D0()
{
  return &off_1019AD818;
}

void *sub_1002364DC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100236560(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  sub_1002365B8((char *)a1, *(long long **)a2, (long long *)(a2 + 8));
  return a1;
}

void sub_1002365A0(_Unwind_Exception *a1)
{
  sub_10010C0E0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_1002365B8(char *result, long long *a2, long long *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    long long v5 = (uint64_t **)result;
    int v6 = (uint64_t *)(result + 8);
    do
    {
      __n128 result = sub_100236644(v5, v6, (uint64_t)(v4 + 2), v4 + 2);
      size_t v7 = (long long *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          size_t v7 = *(long long **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (long long *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

char *sub_100236644(uint64_t **a1, uint64_t *a2, uint64_t a3, long long *a4)
{
  size_t v11 = 0;
  uint64_t v12 = 0;
  int v6 = sub_1002366E8(a1, a2, &v12, &v11, a3);
  size_t v7 = (char *)*v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1002368D4((uint64_t)a1, a4, v10);
    sub_100046C38(a1, (uint64_t)v12, v8, (uint64_t *)v10[0]);
    size_t v7 = v10[0];
    v10[0] = 0;
    sub_10010E764((uint64_t)v10, 0);
  }
  return v7;
}

uint64_t *sub_1002366E8(uint64_t **a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, uint64_t a5)
{
  BOOL v9 = a1 + 1;
  if (a1 + 1 == (uint64_t **)a2
    || (*(char *)(a5 + 23) >= 0 ? (size_t v11 = (const char *)a5) : (size_t v11 = *(const char **)a5),
        *((char *)a2 + 55) >= 0 ? (uint64_t v12 = (const char *)(a2 + 4)) : (uint64_t v12 = (const char *)a2[4]),
        strcasecmp(v11, v12) < 0))
  {
    unsigned int v13 = (uint64_t *)*a2;
    if (*a1 == a2)
    {
      uint64_t v15 = a2;
LABEL_29:
      if (v13)
      {
        *a3 = v15;
        return v15 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v13)
    {
      uint64_t v14 = (uint64_t *)*a2;
      do
      {
        uint64_t v15 = v14;
        uint64_t v14 = (uint64_t *)v14[1];
      }
      while (v14);
    }
    else
    {
      uint64_t v18 = a2;
      do
      {
        uint64_t v15 = (uint64_t *)v18[2];
        BOOL v19 = *v15 == (void)v18;
        uint64_t v18 = v15;
      }
      while (v19);
    }
    if (*((char *)v15 + 55) >= 0) {
      uint64_t v20 = (const char *)(v15 + 4);
    }
    else {
      uint64_t v20 = (const char *)v15[4];
    }
    if (*(char *)(a5 + 23) >= 0) {
      int v21 = (const char *)a5;
    }
    else {
      int v21 = *(const char **)a5;
    }
    if (strcasecmp(v20, v21) < 0) {
      goto LABEL_29;
    }
  }
  else
  {
    if ((strcasecmp(v12, v11) & 0x80000000) == 0)
    {
      *a3 = a2;
      *a4 = a2;
      return (uint64_t *)a4;
    }
    uint64_t v16 = a2[1];
    if (v16)
    {
      uint64_t v17 = (uint64_t *)a2[1];
      do
      {
        a4 = (uint64_t **)v17;
        uint64_t v17 = (uint64_t *)*v17;
      }
      while (v17);
    }
    else
    {
      uint64_t v22 = a2;
      do
      {
        a4 = (uint64_t **)v22[2];
        BOOL v19 = *a4 == v22;
        uint64_t v22 = (uint64_t *)a4;
      }
      while (!v19);
    }
    if (a4 == v9
      || (*((char *)a4 + 55) >= 0 ? (int v23 = (const char *)(a4 + 4)) : (int v23 = (const char *)a4[4]),
          strcasecmp(v11, v23) < 0))
    {
      if (v16)
      {
        *a3 = (uint64_t *)a4;
      }
      else
      {
        *a3 = a2;
        return a2 + 1;
      }
      return (uint64_t *)a4;
    }
  }

  return sub_10014BF98((uint64_t)a1, a3, a5);
}

char *sub_1002368D4@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, char **a3@<X8>)
{
  long long v5 = (char *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  int v6 = (char *)operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = sub_100236948(v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100236930(_Unwind_Exception *a1)
{
  sub_10010E764(v1, 0);
  _Unwind_Resume(a1);
}

char *sub_100236948(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  long long v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)long long v5 = v6;
  }
  return __dst;
}

void sub_1002369C4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002369E0(uint64_t a1, long long *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  long long v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 48 * a3;
    do
    {
      sub_100236644((uint64_t **)a1, v4, (uint64_t)a2, a2);
      a2 += 3;
      v6 -= 48;
    }
    while (v6);
  }
  return a1;
}

void sub_100236A4C(_Unwind_Exception *a1)
{
  sub_10010C0E0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100236A68()
{
}

void *sub_100236A7C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019AD6A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100236AC4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019AD6A8;
  a2[1] = v2;
  return result;
}

void sub_100236AF0(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100236AF8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100236B38()
{
}

uint64_t **sub_100236B44(uint64_t **result, long long *a2, long long *a3)
{
  long long v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    size_t v7 = result[1];
    void *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      int v8 = (uint64_t *)v6[1];
    }
    else {
      int v8 = v6;
    }
    uint64_t v15 = result;
    uint64_t v16 = v8;
    uint64_t v17 = v8;
    if (v8)
    {
      uint64_t v16 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        BOOL v9 = a2;
        do
        {
          std::string::operator=((std::string *)(v8 + 4), (const std::string *)(v9 + 2));
          std::string::operator=((std::string *)(v8 + 7), (const std::string *)((char *)v9 + 56));
          uint64_t v18 = 0;
          size_t v10 = (uint64_t **)sub_100236CD8((uint64_t)v5, &v18, (uint64_t)(v17 + 4));
          sub_100046C38(v5, v18, v10, v17);
          uint64_t v17 = v16;
          if (v16) {
            uint64_t v16 = sub_1000EA590((uint64_t)v16);
          }
          size_t v11 = (long long *)*((void *)v9 + 1);
          if (v11)
          {
            do
            {
              a2 = v11;
              size_t v11 = *(long long **)v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              a2 = (long long *)*((void *)v9 + 2);
              BOOL v12 = *(void *)a2 == (void)v9;
              BOOL v9 = a2;
            }
            while (!v12);
          }
          int v8 = v17;
          if (v17) {
            BOOL v12 = a2 == a3;
          }
          else {
            BOOL v12 = 1;
          }
          BOOL v9 = a2;
        }
        while (!v12);
      }
    }
    __n128 result = (uint64_t **)sub_100236D64((uint64_t)&v15);
  }
  if (a2 != a3)
  {
    do
    {
      __n128 result = (uint64_t **)sub_100236DBC(v5, a2 + 2);
      unsigned int v13 = (long long *)*((void *)a2 + 1);
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          unsigned int v13 = *(long long **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (long long *)*((void *)a2 + 2);
          BOOL v12 = *(void *)v14 == (void)a2;
          a2 = v14;
        }
        while (!v12);
      }
      a2 = v14;
    }
    while (v14 != a3);
  }
  return result;
}

void sub_100236CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100236CD8(uint64_t a1, void *a2, uint64_t a3)
{
  long long v5 = (void *)(a1 + 8);
  long long v4 = *(void **)(a1 + 8);
  if (v4)
  {
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v6 = (const char *)a3;
    }
    else {
      uint64_t v6 = *(const char **)a3;
    }
    do
    {
      while (1)
      {
        long long v5 = v4;
        BOOL v9 = (void *)v4[4];
        size_t v7 = v4 + 4;
        int v8 = v9;
        size_t v10 = (const char *)(*((char *)v7 + 23) >= 0 ? v7 : v8);
        if ((strcasecmp(v6, v10) & 0x80000000) == 0) {
          break;
        }
        long long v4 = (void *)*v5;
        __n128 result = v5;
        if (!*v5) {
          goto LABEL_14;
        }
      }
      long long v4 = (void *)v5[1];
    }
    while (v4);
    __n128 result = v5 + 1;
  }
  else
  {
    __n128 result = (void *)(a1 + 8);
  }
LABEL_14:
  *a2 = v5;
  return result;
}

uint64_t sub_100236D64(uint64_t a1)
{
  sub_10010C0E0(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_10010C0E0(*(void *)a1, v2);
  }
  return a1;
}

char *sub_100236DBC(uint64_t **a1, long long *a2)
{
  memset(v7, 0, sizeof(v7));
  sub_1002368D4((uint64_t)a1, a2, v7);
  uint64_t v6 = 0;
  uint64_t v3 = (uint64_t **)sub_100236CD8((uint64_t)a1, &v6, (uint64_t)(v7[0] + 32));
  sub_100046C38(a1, v6, v3, (uint64_t *)v7[0]);
  long long v4 = v7[0];
  v7[0] = 0;
  sub_10010E764((uint64_t)v7, 0);
  return v4;
}

void sub_100236E34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10010E764((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void *sub_100236E4C(void *a1)
{
  *a1 = off_1019AD728;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100236E98(void *a1)
{
  *a1 = off_1019AD728;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100236F04(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019AD728;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100236F68(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019AD728;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100236FA8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100236FB8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100236FF8(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  int v4 = *a2;
  long long v5 = *(void **)a3;
  int v6 = *(char *)(a3 + 23);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  size_t v7 = (std::__shared_weak_count *)a1[3];
  if (v7)
  {
    uint64_t v8 = a1[1];
    BOOL v9 = std::__shared_weak_count::lock(v7);
    if (v9)
    {
      size_t v10 = v9;
      if (a1[2])
      {
        size_t v11 = *(NSObject **)(v8 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v12 = "success";
          if (!v4) {
            BOOL v12 = "failed";
          }
          int v13 = 136315138;
          uint64_t v14 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I ABC report %s for Lazuli MSISDN mismatch", (uint8_t *)&v13, 0xCu);
        }
      }
      sub_10004D2C8(v10);
    }
  }
  if (v6 < 0) {
    operator delete(v5);
  }
}

uint64_t sub_100237104(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100237144()
{
}

uint64_t sub_100237150@<X0>(capabilities::ct *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t result = capabilities::ct::supportsGemini(a1);
  if (result)
  {
    uint64_t v8 = *a2;
    uint64_t v7 = a2[1];
    BOOL v9 = operator new(0x100uLL);
    size_t v10 = v9;
    v9[1] = 0;
    size_t v11 = v9 + 1;
    v9[2] = 0;
    void *v9 = off_1019AD988;
    BOOL v12 = v9 + 3;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
    uint64_t v14 = dispatch_queue_create_with_target_V2("SimSetupProxy", initially_inactive, 0);
    dispatch_set_qos_class_floor(v14, QOS_CLASS_UTILITY, 0);
    dispatch_activate(v14);
    v10[4] = 0;
    v10[5] = 0;
    v10[6] = v14;
    if (v14)
    {
      dispatch_retain(v14);
      v10[7] = 0;
      dispatch_release(v14);
    }
    else
    {
      v10[7] = 0;
    }
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v10 + 8), kCtLoggingSystemName, "simsetup");
    v10[3] = off_1019AD860;
    uint64_t v15 = *((void *)a1 + 1);
    v10[9] = *(void *)a1;
    v10[10] = v15;
    if (v15) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
    }
    sub_100058DB0(&__p, "SimSetupProxy");
    uint64_t v16 = v10[6];
    int v21 = v16;
    if (v16) {
      dispatch_retain(v16);
    }
    uint64_t v17 = v10[7];
    dispatch_object_t object = v17;
    if (v17) {
      dispatch_retain(v17);
    }
    ctu::RestModule::RestModule();
    if (object) {
      dispatch_release(object);
    }
    if (v21) {
      dispatch_release(v21);
    }
    if (v24 < 0) {
      operator delete(__p);
    }
    v10[21] = 0;
    v10[13] = v8;
    v10[14] = v7;
    *((unsigned char *)v10 + 120) = 0;
    *((_DWORD *)v10 + 31) = 0;
    *((unsigned char *)v10 + 128) = 0;
    *((unsigned char *)v10 + 152) = 0;
    v10[22] = 0;
    v10[20] = v10 + 21;
    *(_OWORD *)(v10 + 23) = 0u;
    *(_OWORD *)(v10 + 25) = 0u;
    *(_OWORD *)(v10 + 27) = 0u;
    *(_OWORD *)(v10 + 29) = 0u;
    v10[31] = 0;
    v10[3] = off_1019AD9D8;
    uint64_t v18 = (std::__shared_weak_count *)v10[5];
    if (v18)
    {
      if (v18->__shared_owners_ != -1) {
        goto LABEL_25;
      }
      atomic_fetch_add_explicit(v10 + 1, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(v10 + 2, 1uLL, memory_order_relaxed);
      v10[4] = v12;
      v10[5] = v10;
      std::__shared_weak_count::__release_weak(v18);
    }
    else
    {
      atomic_fetch_add_explicit(v10 + 1, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(v10 + 2, 1uLL, memory_order_relaxed);
      v10[4] = v12;
      v10[5] = v10;
    }
    sub_10004D2C8((std::__shared_weak_count *)v10);
LABEL_25:
    std::string __p = 0;
    int v23 = 0;
    Registry::getServiceManager((uint64_t *)&__p, *(Registry **)a1);
    if (__p)
    {
      atomic_fetch_add_explicit(v11, 1uLL, memory_order_relaxed);
      operator new();
    }
    if (v23) {
      sub_10004D2C8(v23);
    }
    atomic_fetch_add_explicit(v10 + 1, 1uLL, memory_order_relaxed);
    BOOL v19 = (std::__shared_weak_count *)v10[5];
    if (v19)
    {
      if (std::__shared_weak_count::lock(v19)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  *a3 = 0;
  a3[1] = 0;
  return result;
}

void sub_10023753C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, std::__shared_weak_count *a13, int a14, __int16 a15, char a16, char a17)
{
  if (a11) {
    (*((void (**)(dispatch_object_t))a11->isa + 1))(a11);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_100237628(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100237728(uint64_t a1, xpc_object_t object, dispatch_object_t *a3)
{
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_null_create();
  }
  long long v5 = *a3;
  if (*a3)
  {
    dispatch_retain(*a3);
    dispatch_group_enter(v5);
  }
  int v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100237868(uint64_t a1, uint64_t a2, long long *a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v6, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)int v6 = *(_OWORD *)a2;
    v6[2] = *(void **)(a2 + 16);
  }
  sub_10000451C((char *)&v7, a3);
  long long v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100237A14(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*(char *)(v15 + 31) < 0) {
    operator delete(*v16);
  }
  sub_10006A6AC(a1);
}

void sub_100237A54(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100237BAC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100237D04(uint64_t a1, uint64_t a2, char a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  char v7 = a3;
  long long v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100237E6C(uint64_t a1, uint64_t a2)
{
  sub_1000C6BDC(&v4, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100237F80(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10023CDA0;
  v6[3] = &unk_1019ADCC0;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  char v7 = objc_retainBlock(v6);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    size_t v10 = sub_10023CE34;
    size_t v11 = &unk_10199E470;
    BOOL v12 = a2;
    int v13 = &v7;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    size_t v10 = sub_10023CDD0;
    size_t v11 = &unk_10199E470;
    BOOL v12 = a2;
    int v13 = &v7;
    dispatch_sync(v4, &block);
  }
}

void sub_1002380CC(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10023CE98;
  v6[3] = &unk_1019ADCC0;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  char v7 = objc_retainBlock(v6);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    size_t v10 = sub_10023CE34;
    size_t v11 = &unk_10199E470;
    BOOL v12 = a2;
    int v13 = &v7;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    size_t v10 = sub_10023CDD0;
    size_t v11 = &unk_10199E470;
    BOOL v12 = a2;
    int v13 = &v7;
    dispatch_sync(v4, &block);
  }
}

void sub_100238218(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_1002382F8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(a1 + 40);
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Persist SIM config for: %s", buf, 0xCu);
  }
  sub_100238888(a1 + 136, v4, "persistSimConfig_sync");
  if (!sub_100238CC0(a1 + 136)) {
    return sub_100238D78(a1);
  }
  CFTypeRef cf = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    size_t v10 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "Failed to create CFMutableDictionarySharedRef", buf, 2u);
    }
    return sub_10005717C(&cf);
  }
  CFTypeRef v7 = cf;
  CFTypeRef cf = Mutable;
  *(void *)buf = v7;
  sub_10005717C((const void **)buf);
  if (*(char *)(a1 + 231) < 0) {
    uint64_t v8 = *(void *)(a1 + 216);
  }
  else {
    uint64_t v8 = *(unsigned __int8 *)(a1 + 231);
  }
  size_t v11 = (void **)(a1 + 208);
  if (!v8)
  {
    sub_100238F58(buf, a1);
    if (*(char *)(a1 + 231) < 0) {
      operator delete(*v11);
    }
    *(_OWORD *)size_t v11 = *(_OWORD *)buf;
    *(void *)(a1 + 224) = v38;
  }
  CFTypeRef v35 = cf;
  if (cf)
  {
    CFRetain(cf);
    BOOL v12 = (void *)v35;
  }
  else
  {
    BOOL v12 = 0;
  }
  id v33 = v12;
  int v13 = +[NSMutableArray arrayWithCapacity:*(void *)(a1 + 152)];
  uint64_t v14 = *(void **)(a1 + 136);
  if (v14 != (void *)(a1 + 144))
  {
    do
    {
      uint64_t v15 = +[NSMutableDictionary dictionary];
      uint64_t v16 = v14 + 4;
      if (*((char *)v14 + 55) < 0) {
        uint64_t v16 = (void *)*v16;
      }
      uint64_t v17 = +[NSString stringWithUTF8String:v16];
      [v15 setObject:v17 forKeyedSubscript:@"kSimIccidKey"];

      uint64_t v18 = v14 + 7;
      if (*((char *)v14 + 79) < 0) {
        uint64_t v18 = (void *)*v18;
      }
      BOOL v19 = +[NSString stringWithUTF8String:v18];
      [v15 setObject:v19 forKeyedSubscript:@"kLabelTextKey"];

      uint64_t v20 = v14 + 10;
      if (*((char *)v14 + 103) < 0) {
        uint64_t v20 = (void *)*v20;
      }
      int v21 = +[NSString stringWithUTF8String:v20];
      [v15 setObject:v21 forKeyedSubscript:@"kLabelTagKey"];

      if (*((unsigned char *)v14 + 107))
      {
        uint64_t v22 = +[NSNumber numberWithBool:*((unsigned __int8 *)v14 + 106)];
        [v15 setObject:v22 forKeyedSubscript:@"kIMessageEnabledKey"];
      }
      if (*((unsigned char *)v14 + 105))
      {
        int v23 = +[NSNumber numberWithBool:*((unsigned __int8 *)v14 + 104)];
        [v15 setObject:v23 forKeyedSubscript:@"kDynamicDataSwitchEnabledKey"];
      }
      [v13 addObject:v15];

      char v24 = (void *)v14[1];
      if (v24)
      {
        do
        {
          unsigned int v25 = v24;
          char v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          unsigned int v25 = (void *)v14[2];
          BOOL v26 = *v25 == (void)v14;
          uint64_t v14 = v25;
        }
        while (!v26);
      }
      uint64_t v14 = v25;
    }
    while (v25 != (void *)(a1 + 144));
  }
  if ([v13 count]) {
    [v33 setObject:v13 forKeyedSubscript:@"kPerSimConfigKey"];
  }
  uint64_t v27 = (void *)(a1 + 160);
  if (*(char *)(a1 + 183) < 0)
  {
    if (!*(void *)(a1 + 168)) {
      goto LABEL_43;
    }
    uint64_t v27 = (void *)*v27;
    goto LABEL_42;
  }
  if (*(unsigned char *)(a1 + 183))
  {
LABEL_42:
    uint64_t v28 = +[NSString stringWithUTF8String:v27];
    [v33 setObject:v28 forKeyedSubscript:@"kDefaultDataPlanIccidKey"];
  }
LABEL_43:
  uint64_t v29 = (void *)(a1 + 184);
  if ((*(char *)(a1 + 207) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 207)) {
      goto LABEL_49;
    }
    goto LABEL_48;
  }
  if (*(void *)(a1 + 192))
  {
    uint64_t v29 = (void *)*v29;
LABEL_48:
    uint64_t v30 = +[NSString stringWithUTF8String:v29];
    [v33 setObject:v30 forKeyedSubscript:@"kDefaultVoicePlanIccidKey"];
  }
LABEL_49:
  if (*(char *)(a1 + 231) < 0) {
    uint64_t v31 = *(void *)(a1 + 208);
  }
  else {
    uint64_t v31 = a1 + 208;
  }
  char v32 = +[NSString stringWithUTF8String:v31];
  [v33 setObject:v32 forKeyedSubscript:@"kOSVersionKey"];

  sub_10005717C(&v35);
  sub_10004EFE4(&v34, &cf);
  sub_1002390DC(a1, (std::string::size_type *)&v34);
  sub_100057D78(&v34);
  return sub_10005717C(&cf);
}

void sub_1002387B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100238888(uint64_t a1, os_log_t *a2, void *a3)
{
  int v6 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    uint64_t v36 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Log Reason: %s", buf, 0xCu);
    int v6 = *a2;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFTypeRef v7 = (void *)(a1 + 72);
    if (*(char *)(a1 + 95) < 0) {
      CFTypeRef v7 = (void *)*v7;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I     OS version %{public}s", buf, 0xCu);
  }
  uint64_t v8 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    do
    {
      uint64_t v9 = v8 + 4;
      size_t v10 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        size_t v11 = v8 + 4;
        if (*((char *)v8 + 55) < 0) {
          size_t v11 = (void *)*v9;
        }
        BOOL v12 = (const char *)(v8 + 7);
        if (*((char *)v8 + 79) < 0) {
          BOOL v12 = *(const char **)v12;
        }
        int v13 = v8 + 10;
        if (*((char *)v8 + 103) < 0) {
          int v13 = (void *)*v13;
        }
        *(_DWORD *)buf = 136315650;
        uint64_t v36 = v11;
        __int16 v37 = 2080;
        uint64_t v38 = v12;
        __int16 v39 = 2080;
        long long v40 = v13;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I     sim [%s]: plan label (%s, %s)", buf, 0x20u);
        size_t v10 = *a2;
      }
      int v14 = *((unsigned __int8 *)v8 + 107);
      BOOL v15 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      if (v14)
      {
        if (!v15) {
          goto LABEL_29;
        }
        uint64_t v16 = v8 + 4;
        if (*((char *)v8 + 55) < 0) {
          uint64_t v16 = (void *)*v9;
        }
        if (*((unsigned char *)v8 + 106)) {
          uint64_t v17 = "true";
        }
        else {
          uint64_t v17 = "false";
        }
        *(_DWORD *)buf = 136315394;
        uint64_t v36 = v16;
        __int16 v37 = 2080;
        uint64_t v38 = v17;
        uint64_t v18 = v10;
        BOOL v19 = "#I     sim [%s]: imessage enabled (%s)";
        uint32_t v20 = 22;
      }
      else
      {
        if (!v15) {
          goto LABEL_29;
        }
        int v21 = v8 + 4;
        if (*((char *)v8 + 55) < 0) {
          int v21 = (void *)*v9;
        }
        *(_DWORD *)buf = 136315138;
        uint64_t v36 = v21;
        uint64_t v18 = v10;
        BOOL v19 = "#I     sim [%s]: imessage enabled setting unknown";
        uint32_t v20 = 12;
      }
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, v20);
LABEL_29:
      int v22 = *((unsigned __int8 *)v8 + 105);
      os_log_t v23 = *a2;
      BOOL v24 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
      if (v22)
      {
        if (v24)
        {
          if (*((char *)v8 + 55) < 0) {
            uint64_t v9 = (void *)*v9;
          }
          if (*((unsigned char *)v8 + 104)) {
            unsigned int v25 = "true";
          }
          else {
            unsigned int v25 = "false";
          }
          *(_DWORD *)buf = 136315394;
          uint64_t v36 = v9;
          __int16 v37 = 2080;
          uint64_t v38 = v25;
          BOOL v26 = v23;
          uint64_t v27 = "#I     sim [%s]: dynamic data switch enabled (%s)";
          uint32_t v28 = 22;
LABEL_41:
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v27, buf, v28);
        }
      }
      else if (v24)
      {
        if (*((char *)v8 + 55) < 0) {
          uint64_t v9 = (void *)*v9;
        }
        *(_DWORD *)buf = 136315138;
        uint64_t v36 = v9;
        BOOL v26 = v23;
        uint64_t v27 = "#I     sim [%s]: dynamic data switch setting unknown";
        uint32_t v28 = 12;
        goto LABEL_41;
      }
      uint64_t v29 = (void *)v8[1];
      if (v29)
      {
        do
        {
          uint64_t v30 = v29;
          uint64_t v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          uint64_t v30 = (void *)v8[2];
          BOOL v31 = *v30 == (void)v8;
          uint64_t v8 = v30;
        }
        while (!v31);
      }
      uint64_t v8 = v30;
    }
    while (v30 != (void *)(a1 + 8));
  }
  char v32 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    id v33 = (void *)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      id v33 = (void *)*v33;
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v36 = v33;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I     default data plan [%s]", buf, 0xCu);
    char v32 = *a2;
  }
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = (void *)(a1 + 48);
    if (*(char *)(a1 + 71) < 0) {
      uint64_t v34 = (void *)*v34;
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v36 = v34;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I     default voice plan [%s]", buf, 0xCu);
  }
}

BOOL sub_100238CC0(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0)
  {
    if (*(void *)(a1 + 56)) {
      return 1;
    }
  }
  else if (*(unsigned char *)(a1 + 71))
  {
    return 1;
  }
  if (*(char *)(a1 + 47) < 0)
  {
    if (!*(void *)(a1 + 32)) {
      goto LABEL_10;
    }
    return 1;
  }
  if (*(unsigned char *)(a1 + 47)) {
    return 1;
  }
LABEL_10:
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    while (1)
    {
      BOOL result = sub_10023A3D0((uint64_t)(v3 + 7));
      if (result) {
        break;
      }
      uint64_t v4 = (void *)v3[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v3[2];
          BOOL v6 = *v5 == (void)v3;
          uint64_t v3 = v5;
        }
        while (!v6);
      }
      uint64_t v3 = v5;
      if (v5 == v2) {
        return result;
      }
    }
    return 1;
  }
  return 0;
}

const void **sub_100238D78(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(a1 + 136);
  BOOL result = (const void **)sub_100238CC0(a1 + 136);
  if ((result & 1) == 0)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I clearing cached sim config", buf, 2u);
    }
    BOOL v15 = 0;
    uint64_t v16 = 0;
    *(void *)buf = &v15;
    uint64_t v6 = a1 + 144;
    uint64_t v5 = *(void **)(a1 + 144);
    *(_OWORD *)uint64_t v17 = 0u;
    memset(__p, 0, sizeof(__p));
    long long v19 = 0u;
    uint64_t v20 = 0;
    sub_10023A548(v5);
    CFTypeRef v7 = v15;
    *(void *)(a1 + 136) = *(void *)buf;
    *(void *)(a1 + 144) = v7;
    uint64_t v8 = v16;
    *(void *)(a1 + 152) = v16;
    if (v8)
    {
      v7[2] = v6;
      *(void *)buf = &v15;
      BOOL v15 = 0;
      uint64_t v16 = 0;
    }
    else
    {
      *uint64_t v2 = v6;
    }
    uint64_t v9 = (void **)(a1 + 160);
    if (*(char *)(a1 + 183) < 0) {
      operator delete(*v9);
    }
    *(_OWORD *)uint64_t v9 = *(_OWORD *)v17;
    *(void **)(a1 + 176) = __p[0];
    HIBYTE(__p[0]) = 0;
    LOBYTE(v17[0]) = 0;
    size_t v10 = (void **)(a1 + 184);
    if (*(char *)(a1 + 207) < 0) {
      operator delete(*v10);
    }
    *(_OWORD *)size_t v10 = *(_OWORD *)&__p[1];
    *(void **)(a1 + 200) = __p[3];
    HIBYTE(__p[3]) = 0;
    LOBYTE(__p[1]) = 0;
    size_t v11 = (void **)(a1 + 208);
    if (*(char *)(a1 + 231) < 0)
    {
      operator delete(*v11);
      int v12 = SHIBYTE(__p[3]);
      *(_OWORD *)size_t v11 = v19;
      *(void *)(a1 + 224) = v20;
      HIBYTE(v20) = 0;
      LOBYTE(v19) = 0;
      if (v12 < 0) {
        operator delete(__p[1]);
      }
    }
    else
    {
      *(_OWORD *)size_t v11 = v19;
      *(void *)(a1 + 224) = v20;
      HIBYTE(v20) = 0;
      LOBYTE(v19) = 0;
    }
    if (SHIBYTE(__p[0]) < 0) {
      operator delete(v17[0]);
    }
    sub_10023A548(v15);
    int v13 = 0;
    sub_1002390DC(a1, (std::string::size_type *)&v13);
    return sub_100057D78(&v13);
  }
  return result;
}

void sub_100238F44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100238F58(void *a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 48));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    CFTypeRef v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v6;
  size_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v16);
  if (!v10)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    int v12 = 0;
    char v13 = 1;
    if (!v11) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v10[3];
  int v12 = (std::__shared_weak_count *)v10[4];
  if (!v12) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v13 = 0;
  if (v11) {
LABEL_10:
  }
    (*(void (**)(uint64_t))(*(void *)v11 + 208))(v11);
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (!v11)
  {
    int v14 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)BOOL v15 = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "GestaltUtilityInterface not found", v15, 2u);
    }
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1002390C0(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002390DC(uint64_t a1, std::string::size_type *a2)
{
  sub_1002394EC(&v14);
  uint64_t v4 = std::string::append(&v14, "com.apple.CommCenter.SimSetupProxy.plist", 0x28uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  int64_t v13 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if (v13 >= 0) {
    unint64_t v6 = __p;
  }
  else {
    unint64_t v6 = (void **)__p[0];
  }
  CFStringRef v11 = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault, (const char *)v6, 0x8000100u, kCFAllocatorNull);
  int v7 = CFPreferencesPersistValueForCurrentUserAnyHost();
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v9 = *a2;
    LODWORD(v14.__r_.__value_.__l.__data_) = 138412290;
    *(std::string::size_type *)((char *)v14.__r_.__value_.__r.__words + 4) = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I sim config: %@", (uint8_t *)&v14, 0xCu);
    uint64_t v8 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    size_t v10 = "no";
    LODWORD(v14.__r_.__value_.__l.__data_) = 138412802;
    if (v7) {
      size_t v10 = "yes";
    }
    *(std::string::size_type *)((char *)v14.__r_.__value_.__r.__words + 4) = (std::string::size_type)@"kSimConfigKey";
    WORD2(v14.__r_.__value_.__r.__words[1]) = 2112;
    *(std::string::size_type *)((char *)&v14.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v11;
    HIWORD(v14.__r_.__value_.__r.__words[2]) = 2080;
    BOOL v15 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I written key (%@) to file (%@) successfully: %s", (uint8_t *)&v14, 0x20u);
  }
  sub_1000558F4((const void **)&v11);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002392C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

const void **sub_10023930C(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(a1 + 136);
  BOOL result = (const void **)sub_100238CC0(a1 + 136);
  if (result)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I force clearing cached sim config", buf, 2u);
    }
    BOOL v15 = 0;
    uint64_t v16 = 0;
    *(void *)buf = &v15;
    uint64_t v6 = a1 + 144;
    long long v5 = *(void **)(a1 + 144);
    *(_OWORD *)uint64_t v17 = 0u;
    memset(__p, 0, sizeof(__p));
    long long v19 = 0u;
    uint64_t v20 = 0;
    sub_10023A548(v5);
    int v7 = v15;
    *(void *)(a1 + 136) = *(void *)buf;
    *(void *)(a1 + 144) = v7;
    uint64_t v8 = v16;
    *(void *)(a1 + 152) = v16;
    if (v8)
    {
      v7[2] = v6;
      *(void *)buf = &v15;
      BOOL v15 = 0;
      uint64_t v16 = 0;
    }
    else
    {
      *uint64_t v2 = v6;
    }
    std::string::size_type v9 = (void **)(a1 + 160);
    if (*(char *)(a1 + 183) < 0) {
      operator delete(*v9);
    }
    *(_OWORD *)std::string::size_type v9 = *(_OWORD *)v17;
    *(void **)(a1 + 176) = __p[0];
    HIBYTE(__p[0]) = 0;
    LOBYTE(v17[0]) = 0;
    size_t v10 = (void **)(a1 + 184);
    if (*(char *)(a1 + 207) < 0) {
      operator delete(*v10);
    }
    *(_OWORD *)size_t v10 = *(_OWORD *)&__p[1];
    *(void **)(a1 + 200) = __p[3];
    HIBYTE(__p[3]) = 0;
    LOBYTE(__p[1]) = 0;
    CFStringRef v11 = (void **)(a1 + 208);
    if (*(char *)(a1 + 231) < 0)
    {
      operator delete(*v11);
      int v12 = SHIBYTE(__p[3]);
      *(_OWORD *)CFStringRef v11 = v19;
      *(void *)(a1 + 224) = v20;
      HIBYTE(v20) = 0;
      LOBYTE(v19) = 0;
      if (v12 < 0) {
        operator delete(__p[1]);
      }
    }
    else
    {
      *(_OWORD *)CFStringRef v11 = v19;
      *(void *)(a1 + 224) = v20;
      HIBYTE(v20) = 0;
      LOBYTE(v19) = 0;
    }
    if (SHIBYTE(__p[0]) < 0) {
      operator delete(v17[0]);
    }
    sub_10023A548(v15);
    int64_t v13 = 0;
    sub_1002390DC(a1, (std::string::size_type *)&v13);
    return sub_100057D78(&v13);
  }
  return result;
}

void sub_1002394D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1002394EC(std::string *a1)
{
  WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
  sub_100058DB0(&v4, WirelessUserDirectory);
  uint64_t v3 = std::string::append(&v4, "/Library/Preferences/no_backup/", 0x1FuLL);
  *a1 = *v3;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
}

void sub_100239560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10023957C(void *a1, void *a2, uint64_t a3)
{
  id v7 = a1;
  id v5 = a2;
  if (*(char *)(a3 + 23) < 0) {
    operator delete(*(void **)a3);
  }
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (v7 && v5)
  {
    uint64_t v6 = [v7 objectForKeyedSubscript:v5];
    if (v6)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        sub_10003ED78((std::string *)a3, (char *)[v6 UTF8String]);
      }
    }
  }
}

void sub_10023964C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100239670(uint64_t a1, uint64_t a2)
{
  std::string v4 = (void *)(a1 + 136);
  BOOL v5 = sub_100238CC0(a1 + 136);
  uint64_t v6 = *(NSObject **)(a1 + 40);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (!v5)
  {
    if (!v7) {
      return;
    }
    LOWORD(buf) = 0;
    uint64_t v20 = "#I sim config not available";
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&buf, 2u);
    return;
  }
  if (v7)
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Apply SIM config for: %s", (uint8_t *)&buf, 0xCu);
  }
  if (!*(unsigned char *)(a1 + 128) || !*(void *)(a1 + 120))
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(buf) = 0;
    uint64_t v20 = "#I assigned sim labels not yet available";
    goto LABEL_18;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  std::string::size_type v9 = ServiceMap;
  if (v10 < 0)
  {
    CFStringRef v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v10;
  std::string v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&buf);
  if (v14)
  {
    uint64_t v15 = v14[3];
    uint64_t v16 = (std::__shared_weak_count *)v14[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v17 = v16;
      sub_10004D2C8(v16);
      char v18 = 0;
      if (!v15) {
        goto LABEL_12;
      }
LABEL_22:
      char v74 = v18;
      v73 = v17;
      int v21 = *(void **)(a1 + 136);
      int v22 = (void *)(a1 + 144);
      if (v21 != (void *)(a1 + 144))
      {
        while (1)
        {
          os_log_t v23 = (long long *)(v21 + 4);
          long long buf = 0uLL;
          uint64_t v88 = 0;
          if (*((char *)v21 + 55) < 0)
          {
            sub_10004FC84(&buf, (void *)v21[4], v21[5]);
          }
          else
          {
            long long buf = *v23;
            uint64_t v88 = v21[6];
          }
          if (!*(unsigned char *)(a1 + 128)) {
            sub_10016C840();
          }
          BOOL v24 = sub_100046F68(a1 + 104, (void **)&buf);
          if (!*(unsigned char *)(a1 + 128)) {
            sub_10016C840();
          }
          if ((void **)(a1 + 112) == v24) {
            break;
          }
          if (SHIBYTE(v88) < 0) {
            operator delete((void *)buf);
          }
          unsigned int v25 = (void *)v21[1];
          if (v25)
          {
            do
            {
              BOOL v26 = v25;
              unsigned int v25 = (void *)*v25;
            }
            while (v25);
          }
          else
          {
            do
            {
              BOOL v26 = (void *)v21[2];
              BOOL v27 = *v26 == (void)v21;
              int v21 = v26;
            }
            while (!v27);
          }
          int v21 = v26;
          if (v26 == v22) {
            goto LABEL_37;
          }
        }
        __int16 v37 = *(NSObject **)(a1 + 40);
        uint64_t v17 = v73;
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)v21 + 55) < 0) {
            os_log_t v23 = *(long long **)v23;
          }
          LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I personality for sim [%s] not yet available", (uint8_t *)&__dst, 0xCu);
        }
        if (SHIBYTE(v88) < 0) {
          operator delete((void *)buf);
        }
        char v18 = v74;
        goto LABEL_166;
      }
LABEL_37:
      uint32_t v28 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
      uint64_t v29 = v28;
      if (v30 < 0)
      {
        BOOL v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v32 = 5381;
        do
        {
          uint64_t v30 = v32;
          unsigned int v33 = *v31++;
          uint64_t v32 = (33 * v32) ^ v33;
        }
        while (v33);
      }
      std::mutex::lock(v28);
      *(void *)&long long buf = v30;
      uint64_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)&buf);
      if (v34)
      {
        uint64_t v35 = v34[3];
        uint64_t v36 = (std::__shared_weak_count *)v34[4];
        if (v36)
        {
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v29);
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v36);
          if (v35) {
            goto LABEL_55;
          }
LABEL_53:
          uint64_t v38 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "TransportMasterInterface not found", (uint8_t *)&buf, 2u);
          }
LABEL_55:
          *((void *)&buf + 1) = 0;
          uint64_t v88 = 0;
          *(void *)&long long buf = (char *)&buf + 8;
          __int16 v39 = (void *)*v4;
          if (v39 != v22)
          {
            do
            {
              long long v40 = v39 + 4;
              if (v35 && *((unsigned char *)v39 + 105))
              {
                uint64_t v41 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                {
                  std::string::size_type v42 = (std::string::size_type)(v39 + 4);
                  if (*((char *)v39 + 55) < 0) {
                    std::string::size_type v42 = *v40;
                  }
                  LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v42;
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I configuring dynamic cellular data switch for (%s)", (uint8_t *)&__dst, 0xCu);
                  if (!*((unsigned char *)v39 + 105)) {
                    sub_10016C840();
                  }
                }
                (*(void (**)(uint64_t, void, void *))(*(void *)v35 + 8))(v35, *((unsigned __int8 *)v39 + 104), v39 + 4);
                if (*((unsigned char *)v39 + 105)) {
                  *((unsigned char *)v39 + 105) = 0;
                }
              }
              if (*((unsigned char *)v39 + 107) && *((unsigned char *)v39 + 106)) {
                sub_100046BAC((uint64_t **)&buf, (void **)v39 + 4, (uint64_t)(v39 + 4));
              }
              if (*((char *)v39 + 79) < 0)
              {
                if (v39[8]) {
                  goto LABEL_75;
                }
              }
              else if (*((unsigned char *)v39 + 79))
              {
                goto LABEL_75;
              }
              if (*((char *)v39 + 103) < 0)
              {
                if (v39[11])
                {
LABEL_75:
                  if (!*(unsigned char *)(a1 + 128)) {
                    sub_10016C840();
                  }
                  if (*((char *)v39 + 55) < 0)
                  {
                    sub_10004FC84(&__dst, (void *)v39[4], v39[5]);
                  }
                  else
                  {
                    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)v40;
                    __dst.__r_.__value_.__r.__words[2] = v39[6];
                  }
                  uint64_t v43 = sub_100046F68(a1 + 104, (void **)&__dst.__r_.__value_.__l.__data_);
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                  if (!*((unsigned char *)v43 + 128)) {
                    goto LABEL_112;
                  }
                  uint64_t v44 = *((unsigned __int8 *)v43 + 79);
                  if ((v44 & 0x80u) == 0) {
                    char v45 = (void *)*((unsigned __int8 *)v43 + 79);
                  }
                  else {
                    char v45 = v43[8];
                  }
                  uint64_t v46 = (void *)*((unsigned __int8 *)v39 + 79);
                  int v47 = (char)v46;
                  if ((char)v46 < 0) {
                    uint64_t v46 = (void *)v39[8];
                  }
                  if (v45 != v46) {
                    goto LABEL_112;
                  }
                  int v48 = (const void **)(v43 + 7);
                  if (v47 >= 0) {
                    char v49 = (unsigned __int8 *)(v39 + 7);
                  }
                  else {
                    char v49 = (unsigned __int8 *)v39[7];
                  }
                  if ((v44 & 0x80) != 0)
                  {
                    if (memcmp(*v48, v49, (size_t)v43[8])) {
                      goto LABEL_112;
                    }
                  }
                  else if (*((unsigned char *)v43 + 79))
                  {
                    while (*(unsigned __int8 *)v48 == *v49)
                    {
                      int v48 = (const void **)((char *)v48 + 1);
                      ++v49;
                      if (!--v44) {
                        goto LABEL_97;
                      }
                    }
LABEL_112:
                    uint64_t v56 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
                    {
                      std::string::size_type v57 = (std::string::size_type)(v39 + 4);
                      if (*((char *)v39 + 55) < 0) {
                        std::string::size_type v57 = *v40;
                      }
                      LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = v57;
                      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I configuring sim label for (%s)", (uint8_t *)&__dst, 0xCu);
                    }
                    if (*((char *)v39 + 55) < 0)
                    {
                      sub_10004FC84(&__dst, (void *)v39[4], v39[5]);
                    }
                    else
                    {
                      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)v40;
                      __dst.__r_.__value_.__r.__words[2] = v39[6];
                    }
                    (*(void (**)(void **__return_ptr, uint64_t, std::string *, void *, void *, uint64_t))(*(void *)v15 + 216))(&v75, v15, &__dst, v39 + 7, v39 + 10, 1);
                    if (v82 < 0) {
                      operator delete(__p);
                    }
                    if (v80 < 0) {
                      operator delete(v79);
                    }
                    if (v78 < 0) {
                      operator delete(v77);
                    }
                    if (v76 < 0) {
                      operator delete(v75);
                    }
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
                    goto LABEL_129;
                  }
LABEL_97:
                  uint64_t v50 = *((unsigned __int8 *)v43 + 103);
                  if ((v50 & 0x80u) == 0) {
                    std::string v51 = (void *)*((unsigned __int8 *)v43 + 103);
                  }
                  else {
                    std::string v51 = v43[11];
                  }
                  char v52 = (void *)*((unsigned __int8 *)v39 + 103);
                  int v53 = (char)v52;
                  if ((char)v52 < 0) {
                    char v52 = (void *)v39[11];
                  }
                  if (v51 != v52) {
                    goto LABEL_112;
                  }
                  uint64_t v54 = (const void **)(v43 + 10);
                  if (v53 >= 0) {
                    xpc_object_t v55 = (unsigned __int8 *)(v39 + 10);
                  }
                  else {
                    xpc_object_t v55 = (unsigned __int8 *)v39[10];
                  }
                  if ((v50 & 0x80) != 0)
                  {
                    if (memcmp(*v54, v55, (size_t)v43[11])) {
                      goto LABEL_112;
                    }
                  }
                  else if (*((unsigned char *)v43 + 103))
                  {
                    while (*(unsigned __int8 *)v54 == *v55)
                    {
                      uint64_t v54 = (const void **)((char *)v54 + 1);
                      ++v55;
                      if (!--v50) {
                        goto LABEL_142;
                      }
                    }
                    goto LABEL_112;
                  }
LABEL_142:
                  __int16 v60 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                  {
                    if (*((char *)v39 + 55) < 0) {
                      long long v40 = (std::string::size_type *)*v40;
                    }
                    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v40;
                    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I current label is same as user configured label for (%s)", (uint8_t *)&__dst, 0xCu);
                  }
LABEL_129:
                  if (*((char *)v39 + 79) < 0)
                  {
                    *(unsigned char *)v39[7] = 0;
                    v39[8] = 0;
                  }
                  else
                  {
                    *((unsigned char *)v39 + 56) = 0;
                    *((unsigned char *)v39 + 79) = 0;
                  }
                  if (*((char *)v39 + 103) < 0)
                  {
                    *(unsigned char *)v39[10] = 0;
                    v39[11] = 0;
                  }
                  else
                  {
                    *((unsigned char *)v39 + 80) = 0;
                    *((unsigned char *)v39 + 103) = 0;
                  }
                }
              }
              else if (*((unsigned char *)v39 + 103))
              {
                goto LABEL_75;
              }
              char v58 = (void *)v39[1];
              if (v58)
              {
                do
                {
                  char v59 = v58;
                  char v58 = (void *)*v58;
                }
                while (v58);
              }
              else
              {
                do
                {
                  char v59 = (void *)v39[2];
                  BOOL v27 = *v59 == (void)v39;
                  __int16 v39 = v59;
                }
                while (!v27);
              }
              __int16 v39 = v59;
            }
            while (v59 != v22);
          }
          uint64_t v61 = dispatch_group_create();
          int v62 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
          v63 = v62;
          v64 = "22CellularPlanController";
          if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
          {
            long long v65 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v66 = 5381;
            do
            {
              v64 = (const char *)v66;
              unsigned int v67 = *v65++;
              uint64_t v66 = (33 * v66) ^ v67;
            }
            while (v67);
          }
          std::mutex::lock(v62);
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v64;
          char v68 = sub_10004D37C(&v63[1].__m_.__sig, (unint64_t *)&__dst);
          if (v68)
          {
            uint64_t v70 = v68[3];
            v69 = (std::__shared_weak_count *)v68[4];
            if (v69)
            {
              atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v63);
              atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v69);
LABEL_154:
              if (v70 && v88)
              {
                v71 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
                {
                  sub_1000E8F34((std::string *)buf, (std::string *)((char *)&buf + 8), ",", 1uLL, &__dst);
                  char v72 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                      ? &__dst
                      : (std::string *)__dst.__r_.__value_.__r.__words[0];
                  *(_DWORD *)v84 = 136315138;
                  v85 = v72;
                  _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "#I configuring imessage setting for plans: %s", v84, 0xCu);
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                }
                if (v61)
                {
                  dispatch_retain(v61);
                  dispatch_group_enter(v61);
                }
                v83[0] = off_1019ADCF0;
                v83[1] = a1;
                v83[2] = v61;
                v83[3] = v83;
                (*(void (**)(uint64_t, long long *, void *))(*(void *)v70 + 544))(v70, &buf, v83);
                sub_10023D374(v83);
              }
              operator new();
            }
          }
          else
          {
            uint64_t v70 = 0;
          }
          std::mutex::unlock(v63);
          goto LABEL_154;
        }
      }
      else
      {
        uint64_t v35 = 0;
      }
      std::mutex::unlock(v29);
      if (v35) {
        goto LABEL_55;
      }
      goto LABEL_53;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v17 = 0;
  char v18 = 1;
  if (v15) {
    goto LABEL_22;
  }
LABEL_12:
  long long v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "PersonalityShop not found", (uint8_t *)&buf, 2u);
  }
LABEL_166:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_10023A174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, int a12, char a13, std::__shared_weak_count *a14, int a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v37);
  }
  if (v36) {
    dispatch_release(v36);
  }
  sub_10005CD2C(v38 - 128, *(char **)(v38 - 120));
  if ((a13 & 1) == 0) {
    sub_10004D2C8(a11);
  }
  if ((a16 & 1) == 0) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10023A26C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I buddy state: %s", (uint8_t *)&v4, 0xCu);
  }
  return *(_DWORD *)(a1 + 100) == 1;
}

BOOL sub_10023A31C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I buddy state: %s", (uint8_t *)&v4, 0xCu);
  }
  return (*(_DWORD *)(a1 + 100) & 0xFFFFFFFE) == 2;
}

BOOL sub_10023A3D0(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
  {
    if (*(void *)(a1 + 8)) {
      return 1;
    }
  }
  else if (*(unsigned char *)(a1 + 23))
  {
    return 1;
  }
  if (*(char *)(a1 + 47) < 0)
  {
    if (!*(void *)(a1 + 32)) {
      goto LABEL_9;
    }
    return 1;
  }
  if (*(unsigned char *)(a1 + 47)) {
    return 1;
  }
LABEL_9:
  if (*(unsigned char *)(a1 + 49)) {
    return 1;
  }
  return *(unsigned char *)(a1 + 51) != 0;
}

void sub_10023A428(void *a1, void *a2, uint64_t a3)
{
  id v7 = a1;
  id v5 = a2;
  if (*(unsigned char *)(a3 + 1)) {
    *(unsigned char *)(a3 + 1) = 0;
  }
  if (v7 && v5)
  {
    uint64_t v6 = [v7 objectForKeyedSubscript:v5];
    if (v6)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        *(_WORD *)a3 = (unsigned __int16)[v6 BOOLValue] | 0x100;
      }
    }
  }
}

void sub_10023A4E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10023A510(uint64_t a1)
{
  sub_10023A59C(a1);

  operator delete();
}

void sub_10023A548(void *a1)
{
  if (a1)
  {
    sub_10023A548(*a1);
    sub_10023A548(a1[1]);
    sub_10010C078((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_10023A59C(uint64_t a1)
{
  *(void *)a1 = off_1019AD860;
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*(void **)(a1 + 208));
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  sub_10023A548(*(void **)(a1 + 144));
  if (*(unsigned char *)(a1 + 128)) {
    sub_10023A670(a1 + 104, *(void **)(a1 + 112));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  SimSetupProxyInterface::~SimSetupProxyInterface((SimSetupProxyInterface *)a1);
}

void sub_10023A670(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10023A670(a1, *a2);
    sub_10023A670(a1, a2[1]);
    sub_10023A6CC((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_10023A6CC(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_10023A754(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AD988;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10023A774(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AD988;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10023A7C8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10023A7F4(uint64_t a1)
{
  sub_10023A59C(a1);

  operator delete();
}

void sub_10023A82C(ServiceManager::Service *this)
{
  *(void *)this = off_1019ADAE8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10023A888(ServiceManager::Service *this)
{
  *(void *)this = off_1019ADAE8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10023A8F8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SimSetupProxy");
}

unsigned char *sub_10023A908@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 0;
  BOOL result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10023A944(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100237628(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100237628(v4, 0);
}

uint64_t sub_10023A9C8()
{
  return 1;
}

uint64_t sub_10023A9D0()
{
  return 1;
}

uint64_t sub_10023A9D8()
{
  return 2;
}

void sub_10023A9E0(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v5 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  uint64_t v6 = *a3;
  dispatch_object_t v7 = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v6);
    sub_100237728(v4, v5, &v7);
  }
  sub_100237728(v4, v5, &v7);
}

void sub_10023AA90(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10023AB70(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10023AC84(ServiceManager::Service *this)
{
  *(void *)this = off_1019ADAE8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10023ACE0(ServiceManager::Service *this)
{
  *(void *)this = off_1019ADAE8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_10023AD50()
{
  return 0;
}

uint64_t sub_10023AD58()
{
  return 0;
}

uint64_t *sub_10023AD64(uint64_t **a1)
{
  char v1 = *a1;
  uint64_t v44 = a1;
  char v45 = v1;
  uint64_t v2 = *v1;
  v52[0] = 0;
  v52[1] = 0;
  int64_t v53 = 0;
  sub_1002394EC(&v67);
  uint64_t v3 = std::string::append(&v67, "com.apple.CommCenter.SimSetupProxy.plist", 0x28uLL);
  long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  int64_t v53 = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)char v52 = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v67.__r_.__value_.__l.__data_);
  }
  CFStringRef v51 = 0;
  if (v53 >= 0) {
    xpc_object_t v5 = v52;
  }
  else {
    xpc_object_t v5 = (void **)v52[0];
  }
  CFTypeRef cf = 0;
  CFStringRef v51 = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault, (const char *)v5, 0x8000100u, kCFAllocatorNull);
  CFPreferencesCopyValueForCurrentUserAnyHost();
  sub_10004EFE4(&cf, (CFTypeRef *)&v67.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&v67.__r_.__value_.__l.__data_);
  uint64_t v6 = (void *)cf;
  if (cf) {
    dispatch_object_t v7 = sub_100080778;
  }
  else {
    dispatch_object_t v7 = 0;
  }
  uint64_t v8 = *(NSObject **)(v2 + 40);
  uint64_t v41 = (os_log_t *)(v2 + 40);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v9)
    {
      LODWORD(v67.__r_.__value_.__l.__data_) = 138412290;
      *(std::string::size_type *)((char *)v67.__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I sim config read: %@", (uint8_t *)&v67, 0xCu);
      uint64_t v6 = (void *)cf;
    }
    memset(&__s1, 0, sizeof(__s1));
    id v39 = v6;
    sub_10023957C(v39, @"kOSVersionKey", (uint64_t)&__s1);
    sub_100238F58(v47, v2);
    uint64_t v10 = (os_log_t *)(v2 + 40);
    CFStringRef v11 = *v41;
    if (os_log_type_enabled(*v41, OS_LOG_TYPE_DEFAULT))
    {
      p_s1 = &__s1;
      if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_s1 = (std::string *)__s1.__r_.__value_.__r.__words[0];
      }
      unsigned int v13 = v47;
      if ((v48 & 0x80u) != 0) {
        unsigned int v13 = (void **)v47[0];
      }
      LODWORD(v67.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)v67.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_s1;
      WORD2(v67.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&v67.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I cached config osVersion: %{public}s, current OS version %{public}s", (uint8_t *)&v67, 0x16u);
    }
    uint64_t v14 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
    if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __s1.__r_.__value_.__l.__size_;
    }
    unint64_t v16 = v48;
    if ((v48 & 0x80u) != 0) {
      unint64_t v16 = (unint64_t)v47[1];
    }
    if (size == v16)
    {
      if ((v48 & 0x80u) == 0) {
        uint64_t v17 = v47;
      }
      else {
        uint64_t v17 = (void **)v47[0];
      }
      if ((*((unsigned char *)&__s1.__r_.__value_.__s + 23) & 0x80) == 0)
      {
        if (*((unsigned char *)&__s1.__r_.__value_.__s + 23))
        {
          char v18 = &__s1;
          while (v18->__r_.__value_.__s.__data_[0] == *(unsigned __int8 *)v17)
          {
            char v18 = (std::string *)((char *)v18 + 1);
            uint64_t v17 = (void **)((char *)v17 + 1);
            if (!--v14) {
              goto LABEL_37;
            }
          }
          goto LABEL_36;
        }
LABEL_37:
        CFTypeRef v46 = cf;
        if (cf)
        {
          CFRetain(cf);
          long long v19 = (void *)v46;
        }
        else
        {
          long long v19 = 0;
        }
        id v37 = v19;
        uint64_t v20 = [v37 objectForKeyedSubscript:@"kPerSimConfigKey"];
        uint64_t v38 = v2;
        if (v20 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
          id v21 = v20;
        }
        else {
          id v21 = 0;
        }
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        id obj = v21;
        id v22 = [obj countByEnumeratingWithState:&v56 objects:&v67 count:16];
        std::string::size_type v42 = (uint64_t **)(v2 + 136);
        if (v22)
        {
          uint64_t v23 = *(void *)v57;
          uint64_t v40 = v2 + 144;
          do
          {
            for (i = 0; i != v22; i = (char *)i + 1)
            {
              if (*(void *)v57 != v23) {
                objc_enumerationMutation(obj);
              }
              unsigned int v25 = *(void **)(*((void *)&v56 + 1) + 8 * i);
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                id v26 = v25;
                v54[0] = 0;
                v54[1] = 0;
                uint64_t v55 = 0;
                sub_10023957C(v26, @"kSimIccidKey", (uint64_t)v54);
                BOOL v27 = (void *)HIBYTE(v55);
                char v28 = HIBYTE(v55);
                if (v55 < 0) {
                  BOOL v27 = v54[1];
                }
                if (v27)
                {
                  v66[0] = 0;
                  long long v64 = 0u;
                  long long v65 = 0u;
                  long long buf = 0u;
                  sub_10023957C(v26, @"kLabelTextKey", (uint64_t)&buf);
                  sub_10023957C(v26, @"kLabelTagKey", (uint64_t)&v64 + 8);
                  sub_10023A428(v26, @"kIMessageEnabledKey", (uint64_t)v66 + 2);
                  sub_10023A428(v26, @"kDynamicDataSwitchEnabledKey", (uint64_t)v66);
                  uint64_t v62 = 0;
                  uint64_t v29 = (uint64_t **)sub_100046ED4((uint64_t)v42, &v62, v54);
                  if (!*v29)
                  {
                    uint64_t v30 = v29;
                    uint64_t v61 = 0;
                    BOOL v31 = operator new(0x70uLL);
                    uint64_t v32 = v31;
                    v60[0] = v31;
                    v60[1] = v40;
                    LOBYTE(v61) = 0;
                    if (SHIBYTE(v55) < 0)
                    {
                      sub_10004FC84(v31 + 32, v54[0], (unint64_t)v54[1]);
                    }
                    else
                    {
                      *((_OWORD *)v31 + 2) = *(_OWORD *)v54;
                      *((void *)v31 + 6) = v55;
                    }
                    sub_10000451C(v32 + 56, &buf);
                    *((_DWORD *)v32 + 26) = v66[0];
                    LOBYTE(v61) = 1;
                    sub_100046C38(v42, v62, v30, (uint64_t *)v32);
                    v60[0] = 0;
                    sub_10023C9C4((uint64_t)v60);
                    uint64_t v10 = v41;
                  }
                  if (SHIBYTE(v65) < 0) {
                    operator delete(*((void **)&v64 + 1));
                  }
                  if (SBYTE7(v64) < 0) {
                    operator delete((void *)buf);
                  }
                  char v28 = HIBYTE(v55);
                }
                if (v28 < 0) {
                  operator delete(v54[0]);
                }
              }
              else
              {
                unsigned int v33 = *v10;
                if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v34 = objc_opt_class();
                  LODWORD(buf) = 138412290;
                  *(void *)((char *)&buf + 4) = v34;
                  id v35 = v34;
                  _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "invalid type (%@) of object", (uint8_t *)&buf, 0xCu);
                }
              }
            }
            id v22 = [obj countByEnumeratingWithState:&v56 objects:&v67 count:16];
          }
          while (v22);
        }

        sub_10023957C(v37, @"kDefaultDataPlanIccidKey", v38 + 160);
        sub_10023957C(v37, @"kDefaultVoicePlanIccidKey", v38 + 184);
        std::string::operator=((std::string *)(v38 + 208), &__s1);

        sub_100057D78(&v46);
        sub_100238888((uint64_t)v42, v10, "readSimConfig_sync");
        goto LABEL_71;
      }
      if (!memcmp(__s1.__r_.__value_.__l.__data_, v17, __s1.__r_.__value_.__l.__size_)) {
        goto LABEL_37;
      }
    }
LABEL_36:
    v67.__r_.__value_.__r.__words[0] = 0;
    sub_1002390DC(v2, (std::string::size_type *)&v67);
    sub_100057D78((const void **)&v67.__r_.__value_.__l.__data_);
LABEL_71:
    if ((char)v48 < 0) {
      operator delete(v47[0]);
    }
    if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s1.__r_.__value_.__l.__data_);
    }

    goto LABEL_76;
  }
  if (v9)
  {
    LODWORD(v67.__r_.__value_.__l.__data_) = 138412546;
    *(std::string::size_type *)((char *)v67.__r_.__value_.__r.__words + 4) = (std::string::size_type)@"kSimConfigKey";
    WORD2(v67.__r_.__value_.__r.__words[1]) = 2112;
    *(std::string::size_type *)((char *)&v67.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v51;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I sim config key (%@) not found in file %@", (uint8_t *)&v67, 0x16u);
  }
LABEL_76:
  sub_100057D78(&cf);
  sub_1000558F4((const void **)&v51);
  if (SHIBYTE(v53) < 0) {
    operator delete(v52[0]);
  }
  sub_1000E3958((uint64_t *)&v45);
  return sub_100046B58((uint64_t *)&v44);
}

void sub_10023B49C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10023B604()
{
}

__n128 sub_10023B618(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019ADB50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10023B664(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019ADB50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10023B694(uint64_t a1, xpc_object_t *a2)
{
  long long v4 = *(int **)(a1 + 8);
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v10 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)a2, v6);
    *long long v4 = v10;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *long long v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (sub_10023A31C(v9)) {
    sub_100239670(v9, (uint64_t)"post-buddy");
  }
}

uint64_t sub_10023B75C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10023B79C()
{
}

void sub_10023B7AC()
{
}

__n128 sub_10023B7C0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019ADBD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10023B80C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019ADBD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10023B83C(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_null)
  {
    if (*(unsigned char *)(v4 + 24))
    {
      sub_10023A670(v4, *(void **)(v4 + 8));
      *(unsigned char *)(v4 + 24) = 0;
    }
  }
  else
  {
    if (!*(unsigned char *)(v4 + 24))
    {
      v7[0] = 0;
      v7[1] = 0;
      uint64_t v6 = v7;
      sub_10023B964(v4, &v6);
      sub_10023A670((uint64_t)&v6, v7[0]);
    }
    sub_10023B9DC(v4, a2);
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (sub_10023A31C(v5)) {
    sub_100239670(v5, (uint64_t)"assigned-labels-changed-post-buddy");
  }
}

void sub_10023B900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10023B918(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10023B958()
{
}

uint64_t sub_10023B964(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_10023BCC8(a1, a2);
  }
  else
  {
    *(void *)a1 = *a2;
    uint64_t v3 = a2 + 1;
    uint64_t v4 = a2[1];
    *(void *)(a1 + 8) = v4;
    uint64_t v5 = a1 + 8;
    uint64_t v6 = a2[2];
    *(void *)(a1 + 16) = v6;
    if (v6)
    {
      *(void *)(v4 + 16) = v5;
      *a2 = v3;
      *uint64_t v3 = 0;
      a2[2] = 0;
    }
    else
    {
      *(void *)a1 = v5;
    }
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_10023B9DC(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_10023A670(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v17, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v16, object, count);
    xpc_release(object[0]);
    for (i = v18; i != v16[1] || v17 != v16[0]; i = ++v18)
    {
      xpc_object_t v15 = 0;
      object[0] = &v17;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v15);
      if (xpc_get_type(v15) == (xpc_type_t)&_xpc_type_dictionary)
      {
        *(_OWORD *)std::string __p = 0u;
        long long v14 = 0u;
        *(_OWORD *)CFStringRef v11 = 0u;
        long long v12 = 0u;
        long long v9 = 0u;
        *(_OWORD *)int v10 = 0u;
        *(_OWORD *)dispatch_object_t object = 0u;
        *(_OWORD *)uint64_t v8 = 0u;
        xpc_object_t v6 = v15;
        if (v15) {
          xpc_retain(v15);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_10023BD34((uint64_t)object, &v6);
        xpc_release(v6);
        sub_10023BE7C((uint64_t **)a1, object, (long long *)object);
        if (SHIBYTE(v14) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(v12) < 0) {
          operator delete(v11[1]);
        }
        if (SHIBYTE(v11[0]) < 0) {
          operator delete(v10[0]);
        }
        if (SHIBYTE(v9) < 0) {
          operator delete(v8[1]);
        }
        if (SHIBYTE(v8[0]) < 0) {
          operator delete(object[0]);
        }
      }
      xpc_release(v15);
    }
    xpc_release(v17);
    xpc_release(v17);
  }
  xpc_release(v3);
}

void sub_10023BC2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 48));
  xpc_release(v11);
  _Unwind_Resume(a1);
}

void sub_10023BCC8(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)(a1 + 8);
  sub_10023A670(a1, *(void **)(a1 + 8));
  *(void *)a1 = *a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = a2[1];
  *uint64_t v4 = v6;
  uint64_t v7 = a2[2];
  *(void *)(a1 + 16) = v7;
  if (v7)
  {
    *(void *)(v6 + 16) = v4;
    *a2 = v5;
    void *v5 = 0;
    a2[2] = 0;
  }
  else
  {
    *(void *)a1 = v4;
  }
}

void sub_10023BD34(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v2 = *a2;
  xpc_object_t v6 = v2;
  if (v2 && xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v2);
  }
  else
  {
    xpc_object_t v2 = xpc_null_create();
    xpc_object_t v6 = v2;
  }
  if (xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v3 = &v6;
    uint64_t v4 = "first";
    sub_100048BAC((uint64_t)&v3, &object);
    read_rest_value();
    xpc_release(object);
    xpc_object_t v3 = &v6;
    uint64_t v4 = "second";
    sub_100048BAC((uint64_t)&v3, &object);
    read_rest_value();
    xpc_release(object);
    xpc_object_t v2 = v6;
  }
  xpc_release(v2);
}

void sub_10023BE28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12)
{
}

uint64_t *sub_10023BE7C(uint64_t **a1, void **a2, long long *a3)
{
  uint64_t v10 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v10, a2);
  xpc_object_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    memset(v9, 0, sizeof(v9));
    sub_10023BF1C((uint64_t)a1, a3, v9);
    sub_100046C38(a1, v10, v7, v9[0]);
    xpc_object_t v6 = v9[0];
    v9[0] = 0;
    sub_10023C164((uint64_t)v9, 0);
  }
  return v6;
}

void *sub_10023BF1C@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  xpc_object_t v6 = operator new(0xA0uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = sub_10023BF90(v6 + 4, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10023BF78(_Unwind_Exception *a1)
{
  sub_10023C164(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_10023BF90(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  sub_10023C008((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_10023BFEC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10023C008(uint64_t a1, uint64_t a2)
{
  long long v4 = sub_10023C0CC((char *)a1, (long long *)a2);
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84(v4 + 48, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 48);
    *((void *)v4 + 8) = *(void *)(a2 + 64);
    *((_OWORD *)v4 + 3) = v5;
  }
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  xpc_object_t v6 = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)xpc_object_t v6 = v7;
  }
  return a1;
}

void sub_10023C0A0(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v2);
  }
  sub_1001085D8(v1);
  _Unwind_Resume(a1);
}

char *sub_10023C0CC(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  long long v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)long long v5 = v6;
  }
  return __dst;
}

void sub_10023C148(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10023C164(uint64_t a1, uint64_t a2)
{
  xpc_object_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10023A6CC((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void sub_10023C1C0()
{
}

void *sub_10023C1D4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019ADC50;
  result[1] = v3;
  return result;
}

uint64_t sub_10023C21C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019ADC50;
  a2[1] = v2;
  return result;
}

void sub_10023C248(uint64_t a1)
{
}

uint64_t sub_10023C260(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10023C2A0()
{
}

uint64_t *sub_10023C2AC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100058DB0(__p, "/cc/props/buddy_state");
  *(void *)long long buf = off_1019ADB50;
  uint64_t v12 = v2 + 100;
  uint64_t v13 = v2;
  long long v14 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/assigned_sim_labels");
  *(void *)long long buf = off_1019ADBD0;
  uint64_t v12 = v2 + 104;
  uint64_t v13 = v2;
  long long v14 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  *(void *)long long buf = off_1019ADC50;
  uint64_t v12 = v2;
  long long v14 = buf;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10023C498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_10023C4F0(uint64_t a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = *(NSObject **)(**(void **)a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  operator delete();
}

uint64_t *sub_10023C57C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Migration", buf, 2u);
  }
  *(void *)long long buf = v1 + 8;
  char v10 = "kIsRestore";
  sub_100048BAC((uint64_t)buf, &object);
  int v5 = xpc::dyn_cast_or_default((xpc *)&object, 0, v4);
  xpc_release(object);
  if (v5) {
    sub_100239670(v2, (uint64_t)"migration-with-restore");
  }
  sub_10023C67C(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_10023C64C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
}

uint64_t *sub_10023C67C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = *(NSObject **)(v1 + 16);
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = *(NSObject **)(v1 + 16);
      if (v3) {
        dispatch_release(v3);
      }
    }
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t *sub_10023C6EC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 64));
  sub_100238D78(v2);
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10023C778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10023C794(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_10023A26C(*(void *)v1))
  {
    uint64_t v7 = (long long *)(v1 + 8);
    uint64_t v3 = sub_10023C8D0((uint64_t **)(v2 + 136), (void **)(v1 + 8), &v7);
    std::string::operator=((std::string *)(v3 + 56), (const std::string *)(v1 + 32));
    std::string::operator=((std::string *)(v3 + 80), (const std::string *)(v1 + 56));
    sub_1002382F8(v2, (uint64_t)"plan-label");
    *(unsigned char *)(v2 + 96) = 1;
  }
  else
  {
    sub_10023930C(v2);
  }
  sub_10023C858(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10023C83C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_10023C858((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10023C858(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

char *sub_10023C8D0(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v14 = 0;
  int v5 = (void **)sub_100046ED4((uint64_t)a1, &v14, a2);
  uint64_t v6 = (char *)*v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    uint64_t v8 = *a3;
    uint64_t v13 = 0;
    uint64_t v6 = (char *)operator new(0x70uLL);
    v12[0] = v6;
    v12[1] = a1 + 1;
    long long v9 = v6 + 32;
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84(v9, *(void **)v8, *((void *)v8 + 1));
    }
    else
    {
      long long v10 = *v8;
      *((void *)v6 + 6) = *((void *)v8 + 2);
      *(_OWORD *)long long v9 = v10;
    }
    *((void *)v6 + 13) = 0;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    LOBYTE(v13) = 1;
    sub_100046C38(a1, v14, v7, (uint64_t *)v6);
    v12[0] = 0;
    sub_10023C9C4((uint64_t)v12);
  }
  return v6;
}

void sub_10023C9B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10023C9C4(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10010C078((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

uint64_t *sub_10023CA1C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_10023A26C(*(void *)v1))
  {
    std::string::operator=((std::string *)(v2 + 160), (const std::string *)(v1 + 8));
    sub_1002382F8(v2, (uint64_t)"default-data-plan");
    *(unsigned char *)(v2 + 96) = 1;
  }
  else
  {
    sub_10023930C(v2);
  }
  sub_1001102C4(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_10023CA98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10023CAB4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_10023A26C(*(void *)v1))
  {
    std::string::operator=((std::string *)(v2 + 184), (const std::string *)(v1 + 8));
    sub_1002382F8(v2, (uint64_t)"default-voice-plan");
    *(unsigned char *)(v2 + 96) = 1;
  }
  else
  {
    sub_10023930C(v2);
  }
  sub_1001102C4(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_10023CB30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10023CB4C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  if (sub_10023A26C(*(void *)v1))
  {
    __int16 v3 = *(unsigned __int8 *)(v1 + 32);
    uint64_t v7 = (long long *)(v1 + 8);
    *((_WORD *)sub_10023C8D0((uint64_t **)(v2 + 136), (void **)(v1 + 8), &v7) + 52) = v3 | 0x100;
    sub_1002382F8(v2, (uint64_t)"dynamic-data-switch");
  }
  else
  {
    sub_10023930C(v2);
  }
  sub_10023CBF8(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10023CBDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_10023CBF8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10023CBF8(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10023CC50(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *v1;
  if (sub_10023A26C(*v1))
  {
    uint64_t v3 = *(void **)(v2 + 136);
    if (v3 != (void *)(v2 + 144))
    {
      do
      {
        *((_WORD *)v3 + 53) = 256;
        BOOL v4 = (void *)v3[1];
        if (v4)
        {
          do
          {
            uint64_t v5 = v4;
            BOOL v4 = (void *)*v4;
          }
          while (v4);
        }
        else
        {
          do
          {
            uint64_t v5 = (void *)v3[2];
            BOOL v6 = *v5 == (void)v3;
            uint64_t v3 = v5;
          }
          while (!v6);
        }
        uint64_t v3 = v5;
      }
      while (v5 != (void *)(v2 + 144));
    }
    uint64_t v7 = (uint64_t *)v1[1];
    uint64_t v8 = v1 + 2;
    if (v7 != v8)
    {
      do
      {
        uint64_t v14 = (long long *)(v7 + 4);
        *((_WORD *)sub_10023C8D0((uint64_t **)(v2 + 136), (void **)v7 + 4, &v14) + 53) = 257;
        long long v9 = (uint64_t *)v7[1];
        if (v9)
        {
          do
          {
            long long v10 = v9;
            long long v9 = (uint64_t *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            long long v10 = (uint64_t *)v7[2];
            BOOL v6 = *v10 == (void)v7;
            uint64_t v7 = v10;
          }
          while (!v6);
        }
        uint64_t v7 = v10;
      }
      while (v10 != v8);
    }
    sub_1002382F8(v2, (uint64_t)"imessage-selection");
  }
  else
  {
    sub_10023930C(v2);
  }
  sub_1000EDBB4((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_10023CD80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_1000EDBB4((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void **sub_10023CDA0@<X0>(void **result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *result[5];
  if (*(char *)(v2 + 207) < 0) {
    return (void **)sub_10004FC84((unsigned char *)a2, *(void **)(v2 + 184), *(void *)(v2 + 192));
  }
  long long v3 = *(_OWORD *)(v2 + 184);
  *(void *)(a2 + 16) = *(void *)(v2 + 200);
  *(_OWORD *)a2 = v3;
  return result;
}

__n128 sub_10023CDD0(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

__n128 sub_10023CE34(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

void **sub_10023CE98@<X0>(void **result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *result[5];
  if (*(char *)(v2 + 183) < 0) {
    return (void **)sub_10004FC84((unsigned char *)a2, *(void **)(v2 + 160), *(void *)(v2 + 168));
  }
  long long v3 = *(_OWORD *)(v2 + 160);
  *(void *)(a2 + 16) = *(void *)(v2 + 176);
  *(_OWORD *)a2 = v3;
  return result;
}

void sub_10023CEC8(uint64_t **a1)
{
  uint64_t v1 = **a1;
  if (*(unsigned char *)(v1 + 96) && sub_10023A26C(**a1))
  {
    uint64_t v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Ignore as we are still in buddy after SIM Setup was invoked", buf, 2u);
    }
    goto LABEL_22;
  }
  int v3 = *(char *)(v1 + 207);
  if (v3 < 0)
  {
    if (!*(void *)(v1 + 192)) {
      goto LABEL_9;
    }
  }
  else if (!*(unsigned char *)(v1 + 207))
  {
LABEL_9:
    if (*(char *)(v1 + 183) < 0)
    {
      if (!*(void *)(v1 + 168)) {
        goto LABEL_22;
      }
    }
    else if (!*(unsigned char *)(v1 + 183))
    {
      goto LABEL_22;
    }
  }
  __n128 v4 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I default voice & data plans are configured", v5, 2u);
    LOBYTE(v3) = *(unsigned char *)(v1 + 207);
  }
  if ((v3 & 0x80) != 0)
  {
    **(unsigned char **)(v1 + 184) = 0;
    *(void *)(v1 + 192) = 0;
  }
  else
  {
    *(unsigned char *)(v1 + 184) = 0;
    *(unsigned char *)(v1 + 207) = 0;
  }
  if (*(char *)(v1 + 183) < 0)
  {
    **(unsigned char **)(v1 + 160) = 0;
    *(void *)(v1 + 168) = 0;
  }
  else
  {
    *(unsigned char *)(v1 + 160) = 0;
    *(unsigned char *)(v1 + 183) = 0;
  }
  sub_1002382F8(v1, (uint64_t)"configured-default-voice-data-plans");
LABEL_22:
  operator delete();
}

void sub_10023D038()
{
}

void *sub_10023D064(void *a1)
{
  *a1 = off_1019ADCF0;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    int v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_10023D0BC(void *a1)
{
  *a1 = off_1019ADCF0;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    int v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_10023D134(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  *uint64_t v2 = off_1019ADCF0;
  sub_1000E6DB8(v2 + 1, v1);
  return v2;
}

void *sub_10023D188(uint64_t a1, void *a2)
{
  *a2 = off_1019ADCF0;
  return sub_1000E6DB8(a2 + 1, (void *)(a1 + 8));
}

void sub_10023D1B4(uint64_t a1)
{
}

void sub_10023D1BC(void *a1)
{
  sub_1000E1A10((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10023D1F8(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  __n128 v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (v2) {
      uint64_t v5 = "true";
    }
    else {
      uint64_t v5 = "false";
    }
    int v10 = 136315394;
    CFStringRef v11 = v5;
    __int16 v12 = 2080;
    uint64_t v13 = asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I applied imessage settings, result (%s), error (%s)", (uint8_t *)&v10, 0x16u);
  }
  if (v2)
  {
    BOOL v6 = *(void **)(v3 + 136);
    if (v6 != (void *)(v3 + 144))
    {
      do
      {
        if (*((unsigned char *)v6 + 107)) {
          *((unsigned char *)v6 + 107) = 0;
        }
        uint64_t v7 = (void *)v6[1];
        if (v7)
        {
          do
          {
            uint64_t v8 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v8 = (void *)v6[2];
            BOOL v9 = *v8 == (void)v6;
            BOOL v6 = v8;
          }
          while (!v9);
        }
        BOOL v6 = v8;
      }
      while (v8 != (void *)(v3 + 144));
    }
  }
}

uint64_t sub_10023D328(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10023D368()
{
}

void *sub_10023D374(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10023D3F8(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  int v2 = *(void **)(*(void *)a1 + 136);
  uint64_t v3 = *(void *)a1 + 144;
  if (v2 != (void *)v3)
  {
    do
    {
      if (sub_10023A3D0((uint64_t)(v2 + 7)))
      {
        __n128 v4 = (void *)v2[1];
        if (v4)
        {
          do
          {
            uint64_t v5 = v4;
            __n128 v4 = (void *)*v4;
          }
          while (v4);
        }
        else
        {
          do
          {
            uint64_t v5 = (void *)v2[2];
            BOOL v6 = *v5 == (void)v2;
            int v2 = v5;
          }
          while (!v6);
        }
      }
      else
      {
        uint64_t v7 = v1[5];
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = v2 + 4;
          if (*((char *)v2 + 55) < 0) {
            uint64_t v8 = (void *)v2[4];
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v13 = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I erasing sim config for (%s)", buf, 0xCu);
        }
        BOOL v9 = (void *)v2[1];
        int v10 = v2;
        if (v9)
        {
          do
          {
            uint64_t v5 = v9;
            BOOL v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            uint64_t v5 = (void *)v10[2];
            BOOL v6 = *v5 == (void)v10;
            int v10 = v5;
          }
          while (!v6);
        }
        if ((void *)v1[17] == v2) {
          v1[17] = v5;
        }
        CFStringRef v11 = (uint64_t *)v1[18];
        --v1[19];
        sub_10005EE6C(v11, v2);
        sub_10010C078((uint64_t)(v2 + 4));
        operator delete(v2);
      }
      int v2 = v5;
    }
    while (v5 != (void *)v3);
  }
  sub_1002382F8((uint64_t)v1, (uint64_t)"applied sim config");
  operator delete();
}

void sub_10023D5B8()
{
}

void sub_10023D5DC()
{
}

void sub_10023D604()
{
}

void sub_10023D6C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v13) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void *sub_10023D700(void *a1, NSObject **a2, void *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "cp.r.db");
  sub_10023D7EC(a1 + 1, a2, &v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *a1 = off_1019ADD80;
  a1[6] = *a3;
  uint64_t v6 = a3[1];
  a1[7] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_10023D7C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  CellularPlanDatabaseControllerInterface::~CellularPlanDatabaseControllerInterface(v9);
  _Unwind_Resume(a1);
}

void *sub_10023D7EC(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_10023D854(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void sub_10023D878(void *a1)
{
  *a1 = off_1019ADD80;
  int v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  CellularPlanDatabaseControllerInterface::~CellularPlanDatabaseControllerInterface((CellularPlanDatabaseControllerInterface *)a1);
}

void sub_10023D8EC(void *a1)
{
  sub_10023D878(a1);

  operator delete();
}

void sub_10023D924(uint64_t a1@<X0>, void **a2@<X1>, uint64_t a3@<X8>)
{
  __n128 v4 = (void *)*((unsigned __int8 *)a2 + 23);
  if ((char)v4 < 0) {
    __n128 v4 = a2[1];
  }
  if (v4)
  {
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v7 = *(void *)(a1 + 48);
    std::operator+<char>();
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v7 + 16))(&v21, v7, __p);
    if (SBYTE7(v27) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v8 = v21;
    uint64_t v9 = v22;
    if (v22 == v21)
    {
      xpc_object_t v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          unint64_t v16 = a2;
        }
        else {
          unint64_t v16 = *a2;
        }
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I No device records found for %s", (uint8_t *)__p, 0xCu);
      }
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 240) = 0;
    }
    else
    {
      if (0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 3) >= 2)
      {
        int v10 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)a2 + 23) >= 0) {
            CFStringRef v11 = a2;
          }
          else {
            CFStringRef v11 = *a2;
          }
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Multiple device records found for %s (using first record only)", (uint8_t *)__p, 0xCu);
          uint64_t v8 = v21;
          uint64_t v9 = v22;
        }
      }
      memset(&v20[1], 0, 32);
      v20[0] = &off_101A17F50;
      memset(v19, 0, sizeof(v19));
      if (v9 == v8) {
        sub_10015B728();
      }
      PB::Reader::Reader((PB::Reader *)v19, *(const unsigned __int8 **)v8, *(void *)(v8 + 8) - *(void *)v8);
      if (sub_1008E296C((uint64_t)v20, (PB::Reader *)v19))
      {
        *(void *)(a3 + 240) = 0;
        *(_OWORD *)(a3 + 208) = 0u;
        *(_OWORD *)(a3 + 224) = 0u;
        *(_OWORD *)(a3 + 176) = 0u;
        *(_OWORD *)(a3 + 192) = 0u;
        *(_OWORD *)(a3 + 144) = 0u;
        *(_OWORD *)(a3 + 160) = 0u;
        *(_OWORD *)(a3 + 112) = 0u;
        *(_OWORD *)(a3 + 128) = 0u;
        *(_OWORD *)(a3 + 80) = 0u;
        *(_OWORD *)(a3 + 96) = 0u;
        *(_OWORD *)(a3 + 48) = 0u;
        *(_OWORD *)(a3 + 64) = 0u;
        *(_OWORD *)(a3 + 16) = 0u;
        *(_OWORD *)(a3 + 32) = 0u;
        *(_OWORD *)a3 = 0u;
        memset(v33, 0, sizeof(v33));
        long long v31 = 0u;
        *(_OWORD *)uint64_t v32 = 0u;
        *(_OWORD *)uint64_t v29 = 0u;
        *(_OWORD *)uint64_t v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        *(_OWORD *)std::string __p = 0u;
        __int16 v12 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          PB::Base::formattedText((uint64_t *)v17, (PB::Base *)v20);
          int v13 = v18 >= 0 ? v17 : (void **)v17[0];
          *(_DWORD *)long long buf = 136315138;
          unsigned int v25 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I read record :%s", buf, 0xCu);
          if (v18 < 0) {
            operator delete(v17[0]);
          }
        }
        if (!sub_1006D180C((uint64_t)v20, a3, (std::string *)__p))
        {
          uint64_t v14 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v17[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "unable to decode device info from buffer", (uint8_t *)v17, 2u);
          }
        }
        v17[0] = (char *)v33 + 8;
        sub_1000C5358((void ***)v17);
        if (SBYTE7(v33[0]) < 0) {
          operator delete(v32[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(v30[1]);
        }
        if (SHIBYTE(v30[0]) < 0) {
          operator delete(v29[0]);
        }
        if (SHIBYTE(v28) < 0) {
          operator delete(*((void **)&v27 + 1));
        }
        if (SBYTE7(v27) < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        *(unsigned char *)a3 = 0;
        *(unsigned char *)(a3 + 240) = 0;
      }
      sub_1008E25A0((PB::Base *)v20);
    }
    __p[0] = &v21;
    sub_10011FF94((void ***)__p);
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 240) = 0;
  }
}

void sub_10023DCF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  sub_10023DD58((uint64_t)&__p);
  if (*(unsigned char *)(v32 + 240)) {
    sub_1000C5634(v32);
  }
  sub_1008E25A0((PB::Base *)&a17);
  std::string __p = &a22;
  sub_10011FF94((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_10023DD58(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 120);
  sub_1000C5358(&v3);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10023DDE4(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v5 = *(void *)(a1 + 48);
  sub_100058DB0(&v30, "cellplan:device:");
  uint64_t v6 = std::string::append(&v30, "%", 1uLL);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v23[0] = (void *)v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v5 + 16))(&v34, v5, __p);
  if (SHIBYTE(v23[0]) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  uint64_t v8 = v34;
  uint64_t v9 = v35;
  if (v34 != v35)
  {
    while (1)
    {
      memset(v33, 0, sizeof(v33));
      PB::Reader::Reader((PB::Reader *)v33, *(const unsigned __int8 **)v8, *(void *)(v8 + 8) - *(void *)v8);
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101A17F50;
      *(_OWORD *)&v30.__r_.__value_.__r.__words[1] = 0uLL;
      char v10 = sub_1008E296C((uint64_t)&v30, (PB::Reader *)v33);
      CFStringRef v11 = *(NSObject **)(a1 + 40);
      if ((v10 & 1) == 0)
      {
        if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "could not read device info from reader", (uint8_t *)__p, 2u);
        }
        sub_1008E25A0((PB::Base *)&v30);
        goto LABEL_45;
      }
      if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
      {
        PB::Base::formattedText((uint64_t *)__p, (PB::Base *)&v30);
        __int16 v12 = __p;
        if (SHIBYTE(v23[0]) < 0) {
          __int16 v12 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I read record :%s", buf, 0xCu);
        if (SHIBYTE(v23[0]) < 0) {
          operator delete(__p[0]);
        }
      }
      *(void *)(a3 + 240) = 0;
      *(_OWORD *)(a3 + 208) = 0u;
      *(_OWORD *)(a3 + 224) = 0u;
      *(_OWORD *)(a3 + 176) = 0u;
      *(_OWORD *)(a3 + 192) = 0u;
      *(_OWORD *)(a3 + 144) = 0u;
      *(_OWORD *)(a3 + 160) = 0u;
      *(_OWORD *)(a3 + 112) = 0u;
      *(_OWORD *)(a3 + 128) = 0u;
      *(_OWORD *)(a3 + 80) = 0u;
      *(_OWORD *)(a3 + 96) = 0u;
      *(_OWORD *)(a3 + 48) = 0u;
      *(_OWORD *)(a3 + 64) = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      *(_OWORD *)(a3 + 32) = 0u;
      *(_OWORD *)a3 = 0u;
      memset(v29, 0, sizeof(v29));
      long long v27 = 0u;
      *(_OWORD *)long long v28 = 0u;
      *(_OWORD *)unsigned int v25 = 0u;
      *(_OWORD *)id v26 = 0u;
      *(_OWORD *)uint64_t v23 = 0u;
      long long v24 = 0u;
      *(_OWORD *)std::string __p = 0u;
      if (!sub_1006D180C((uint64_t)&v30, a3, (std::string *)__p)) {
        break;
      }
      if (!*(unsigned char *)(a3 + 240)) {
        goto LABEL_27;
      }
      uint64_t v13 = *(void *)(a3 + 200);
      if (*(void *)(a3 + 208) == v13) {
        goto LABEL_27;
      }
      uint64_t v15 = *(void *)(v13 + 16);
      uint64_t v14 = *(void *)(v13 + 24);
      int v17 = v15 == *a2 && v14 == a2[1];
      char v18 = v17;
LABEL_28:
      *(void *)long long buf = (char *)v29 + 8;
      sub_1000C5358((void ***)buf);
      if (SBYTE7(v29[0]) < 0) {
        operator delete(v28[0]);
      }
      if (SHIBYTE(v27) < 0) {
        operator delete(v26[1]);
      }
      if (SHIBYTE(v26[0]) < 0) {
        operator delete(v25[0]);
      }
      if (SHIBYTE(v24) < 0) {
        operator delete(v23[1]);
      }
      if (SHIBYTE(v23[0]) < 0) {
        operator delete(__p[0]);
      }
      if (*(unsigned char *)(a3 + 240)) {
        char v20 = v18;
      }
      else {
        char v20 = 1;
      }
      if ((v20 & 1) == 0) {
        sub_1000C5634(a3);
      }
      sub_1008E25A0((PB::Base *)&v30);
      if (v17 != 3 && v17) {
        goto LABEL_47;
      }
LABEL_45:
      v8 += 24;
      if (v8 == v9) {
        goto LABEL_46;
      }
    }
    long long v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "unable to decode device info from buffer", buf, 2u);
    }
LABEL_27:
    char v18 = 0;
    int v17 = 3;
    goto LABEL_28;
  }
LABEL_46:
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 240) = 0;
LABEL_47:
  __p[0] = &v34;
  sub_10011FF94((void ***)__p);
}

void sub_10023E1A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  _Unwind_Resume(exception_object);
}

void sub_10023E230(uint64_t a1, uint64_t a2)
{
  __n128 v4 = (void **)(a2 + 168);
  if (*(char *)(a2 + 191) < 0)
  {
    unint64_t v5 = *(void *)(a2 + 176);
    if (v5)
    {
      long long __dst = 0uLL;
      uint64_t v20 = 0;
      sub_10004FC84(&__dst, *v4, v5);
      goto LABEL_6;
    }
  }
  else if (*(unsigned char *)(a2 + 191))
  {
    long long __dst = *(_OWORD *)v4;
    uint64_t v20 = *(void *)(a2 + 184);
LABEL_6:
    uint64_t v16 = 0;
    int v17 = 0;
    uint64_t v18 = 0;
    PB::Writer::Writer((PB::Writer *)&v16);
    memset(&v15[1], 0, 32);
    v15[0] = &off_101A17F50;
    LOBYTE(__p) = 0;
    char v14 = 0;
    int v6 = sub_1006D10BC(a2, (uint64_t)&__p, (uint64_t)v15);
    sub_10023F804((uint64_t)&__p);
    long long v7 = *(NSObject **)(a1 + 40);
    if (v6)
    {
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        PB::Base::formattedText((uint64_t *)&__p, (PB::Base *)v15);
        uint64_t v8 = v13 >= 0 ? &__p : (void **)__p;
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I saving device info: %s", buf, 0xCu);
        if (SHIBYTE(v13) < 0) {
          operator delete(__p);
        }
      }
      sub_1008E2D1C((uint64_t)v15, (PB::Writer *)&v16);
      __int16 v12 = 0;
      uint64_t v13 = 0;
      std::string __p = 0;
      sub_1001E7940(&__p, v17, v16, v16 - (void)v17);
      uint64_t v9 = *(void *)(a1 + 48);
      std::operator+<char>();
      (*(void (**)(uint64_t, unsigned char *, void **))(*(void *)v9 + 24))(v9, buf, &__p);
      if (v22 < 0) {
        operator delete(*(void **)buf);
      }
      if (__p)
      {
        __int16 v12 = __p;
        operator delete(__p);
      }
    }
    else if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Unable to serialize device info", (uint8_t *)&__p, 2u);
    }
    sub_1008E25A0((PB::Base *)v15);
    PB::Writer::~Writer((PB::Writer *)&v16);
    if (SHIBYTE(v20) < 0) {
      operator delete((void *)__dst);
    }
    return;
  }
  char v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "device id is empty", (uint8_t *)&__p, 2u);
  }
}

void sub_10023E4D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  sub_1008E25A0((PB::Base *)&a29);
  PB::Writer::~Writer((PB::Writer *)(v29 - 120));
  if (*(char *)(v29 - 73) < 0) {
    operator delete(*(void **)(v29 - 96));
  }
  _Unwind_Resume(a1);
}

void sub_10023E554(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    std::operator+<char>();
    (*(void (**)(uint64_t, void **))(*(void *)v3 + 32))(v3, __p);
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    __n128 v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "missing device id", (uint8_t *)__p, 2u);
    }
  }
}

void sub_10023E624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10023E640(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *((unsigned __int8 *)a2 + 23);
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = a2[1];
  }
  if (v4)
  {
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v7 = *(void *)(a1 + 48);
    std::operator+<char>();
    (*(void (**)(uint64_t *__return_ptr, uint64_t, long long *))(*(void *)v7 + 16))(&v21, v7, &buf);
    if (SHIBYTE(v27) < 0) {
      operator delete((void *)buf);
    }
    uint64_t v8 = v21;
    uint64_t v9 = v22;
    if (v22 == v21)
    {
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          int v17 = a2;
        }
        else {
          int v17 = (uint64_t *)*a2;
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I No phone records found for %s", (uint8_t *)&buf, 0xCu);
      }
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 232) = 0;
    }
    else
    {
      if (0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 3) >= 2)
      {
        char v10 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)a2 + 23) >= 0) {
            CFStringRef v11 = a2;
          }
          else {
            CFStringRef v11 = (uint64_t *)*a2;
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Multiple phone records found for %s (using first record only)", (uint8_t *)&buf, 0xCu);
          uint64_t v8 = v21;
          uint64_t v9 = v22;
        }
      }
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      *((void *)&buf + 1) = 0;
      uint64_t v27 = 0;
      *(void *)&long long buf = &off_101A17F50;
      memset(v20, 0, sizeof(v20));
      if (v9 == v8) {
        sub_10015B728();
      }
      PB::Reader::Reader((PB::Reader *)v20, *(const unsigned __int8 **)v8, *(void *)(v8 + 8) - *(void *)v8);
      char v12 = sub_1008E296C((uint64_t)&buf, (PB::Reader *)v20);
      uint64_t v13 = *(NSObject **)(a1 + 40);
      if (v12)
      {
        if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
        {
          PB::Base::formattedText((uint64_t *)__p, (PB::Base *)&buf);
          char v14 = v19 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)long long v24 = 136315138;
          unsigned int v25 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I read record : %s", v24, 0xCu);
          if (v19 < 0) {
            operator delete(__p[0]);
          }
        }
        *(_OWORD *)(a3 + 208) = 0u;
        *(_OWORD *)(a3 + 224) = 0u;
        *(_OWORD *)(a3 + 176) = 0u;
        *(_OWORD *)(a3 + 192) = 0u;
        *(_OWORD *)(a3 + 144) = 0u;
        *(_OWORD *)(a3 + 160) = 0u;
        *(_OWORD *)(a3 + 112) = 0u;
        *(_OWORD *)(a3 + 128) = 0u;
        *(_OWORD *)(a3 + 80) = 0u;
        *(_OWORD *)(a3 + 96) = 0u;
        *(_OWORD *)(a3 + 48) = 0u;
        *(_OWORD *)(a3 + 64) = 0u;
        *(_OWORD *)(a3 + 16) = 0u;
        *(_OWORD *)(a3 + 32) = 0u;
        *(_OWORD *)a3 = 0u;
        if ((sub_1006D29C4((uint64_t)&buf, (std::string *)a3) & 1) == 0)
        {
          uint64_t v15 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "failed to deserialize phone sim info", (uint8_t *)__p, 2u);
          }
        }
      }
      else
      {
        if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "failed to decode phone info", (uint8_t *)__p, 2u);
        }
        *(unsigned char *)a3 = 0;
        *(unsigned char *)(a3 + 232) = 0;
      }
      sub_1008E25A0((PB::Base *)&buf);
    }
    *(void *)&long long buf = &v21;
    sub_10011FF94((void ***)&buf);
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 232) = 0;
  }
}

void sub_10023E9B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  sub_1008E25A0((PB::Base *)(v18 - 96));
  *(void *)(v18 - 96) = &a18;
  sub_10011FF94(v20);
  _Unwind_Resume(a1);
}

void sub_10023EA14(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  if (v3)
  {
    uint64_t v18 = 0;
    char v19 = 0;
    uint64_t v20 = 0;
    PB::Writer::Writer((PB::Writer *)&v18);
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    *(void *)uint64_t v13 = &off_101A17F50;
    int v5 = sub_1006D1E2C(a2, (uint64_t)v13);
    char v6 = *(NSObject **)(a1 + 40);
    if (v5)
    {
      if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
      {
        PB::Base::formattedText((uint64_t *)&__p, (PB::Base *)v13);
        uint64_t v7 = v12 >= 0 ? &__p : (void **)__p;
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I saving phone info: %s", buf, 0xCu);
        if (SHIBYTE(v12) < 0) {
          operator delete(__p);
        }
      }
      sub_1008E2D1C((uint64_t)v13, (PB::Writer *)&v18);
      CFStringRef v11 = 0;
      uint64_t v12 = 0;
      std::string __p = 0;
      sub_1001E7940(&__p, v19, v18, v18 - (void)v19);
      uint64_t v8 = *(void *)(a1 + 48);
      std::operator+<char>();
      (*(void (**)(uint64_t, unsigned char *, void **))(*(void *)v8 + 24))(v8, buf, &__p);
      if (v22 < 0) {
        operator delete(*(void **)buf);
      }
      if (__p)
      {
        CFStringRef v11 = __p;
        operator delete(__p);
      }
    }
    else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "unable to serialize phone sim info", (uint8_t *)&__p, 2u);
    }
    sub_1008E25A0((PB::Base *)v13);
    PB::Writer::~Writer((PB::Writer *)&v18);
  }
  else
  {
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "iccid is empty skipping save", v13, 2u);
    }
  }
}

void sub_10023EC68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

void sub_10023ECC4(uint64_t a1@<X0>, void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = (void *)*((unsigned __int8 *)a2 + 23);
  if ((char)v4 < 0) {
    uint64_t v4 = a2[1];
  }
  if (v4)
  {
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    uint64_t v7 = *(void *)(a1 + 48);
    std::operator+<char>();
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v7 + 16))(&v28, v7, __p);
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v8 = v28;
    uint64_t v9 = v29;
    if (v29 == v28)
    {
      uint64_t v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          uint64_t v21 = a2;
        }
        else {
          uint64_t v21 = *a2;
        }
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I No subscr records found for %s", (uint8_t *)__p, 0xCu);
      }
      *(unsigned char *)a3 = 0;
      *(unsigned char *)(a3 + 168) = 0;
    }
    else
    {
      if (0xAAAAAAAAAAAAAAABLL * ((v29 - v28) >> 3) >= 2)
      {
        char v10 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)a2 + 23) >= 0) {
            CFStringRef v11 = a2;
          }
          else {
            CFStringRef v11 = *a2;
          }
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Multiple subscr records found for %s (using first record only)", (uint8_t *)__p, 0xCu);
          uint64_t v8 = v28;
          uint64_t v9 = v29;
        }
      }
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      v23.__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A0F638;
      *(_OWORD *)&v23.__r_.__value_.__r.__words[1] = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      memset(v22, 0, sizeof(v22));
      if (v9 == v8) {
        sub_10015B728();
      }
      PB::Reader::Reader((PB::Reader *)v22, *(const unsigned __int8 **)v8, *(void *)(v8 + 8) - *(void *)v8);
      char v12 = sub_100835D18((uint64_t)&v23, (PB::Reader *)v22);
      uint64_t v13 = *(NSObject **)(a1 + 40);
      if (v12)
      {
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          PB::Base::formattedText((uint64_t *)__p, (PB::Base *)&v23);
          if ((SBYTE7(v32) & 0x80u) == 0) {
            uint64_t v14 = __p;
          }
          else {
            uint64_t v14 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136315138;
          id v39 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I read plan subscr record : %s", buf, 0xCu);
          if (SBYTE7(v32) < 0) {
            operator delete(__p[0]);
          }
        }
        uint64_t v37 = 0;
        long long v36 = 0u;
        long long v34 = 0u;
        memset(v35, 0, sizeof(v35));
        memset(v33, 0, sizeof(v33));
        *(_OWORD *)std::string __p = 0u;
        long long v32 = 0u;
        sub_1006D2E54(&v23, (uint64_t)__p);
        uint64_t v15 = *((void *)&v33[1] + 1);
        *(void *)(a3 + 32) = *(void *)&v33[0];
        *(void *)(a3 + 56) = v15;
        *(_WORD *)(a3 + 64) = v33[2];
        *(void *)(a3 + 88) = *((void *)&v33[3] + 1);
        uint64_t v16 = *((void *)&v35[1] + 1);
        *(void *)(a3 + 112) = *(void *)&v35[0];
        long long v17 = v32;
        *(_OWORD *)a3 = *(_OWORD *)__p;
        *(_OWORD *)(a3 + 16) = v17;
        long long v32 = 0uLL;
        *(_OWORD *)(a3 + 40) = *(_OWORD *)((char *)v33 + 8);
        memset(v33, 0, 32);
        *(_OWORD *)(a3 + 72) = *(_OWORD *)((char *)&v33[2] + 8);
        *(_OWORD *)(a3 + 96) = v34;
        long long v18 = *(_OWORD *)((char *)v35 + 8);
        *(void *)(a3 + 136) = v16;
        *(_OWORD *)(a3 + 120) = v18;
        long long v19 = v36;
        *(void *)(a3 + 160) = v37;
        *(_OWORD *)(a3 + 144) = v19;
        *(unsigned char *)(a3 + 168) = 1;
      }
      else
      {
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "error reading subscr info from reader", (uint8_t *)__p, 2u);
        }
        *(unsigned char *)a3 = 0;
        *(unsigned char *)(a3 + 168) = 0;
      }
      sub_100835808((uint64_t)&v23);
    }
    __p[0] = &v28;
    sub_10011FF94((void ***)__p);
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 168) = 0;
  }
}

void sub_10023F084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,char *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  std::string __p = &a22;
  sub_10011FF94((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_10023F0DC(uint64_t a1)
{
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_10023F160(uint64_t a1, std::string *a2)
{
  std::string::pointer data = (std::string::pointer)a2[2].__r_.__value_.__s.__data_[15];
  if ((char)data < 0) {
    std::string::pointer data = a2[2].__r_.__value_.__l.__data_;
  }
  if (data)
  {
    uint64_t v18 = 0;
    long long v19 = 0;
    uint64_t v20 = 0;
    PB::Writer::Writer((PB::Writer *)&v18);
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    *(void *)char v12 = off_101A0F638;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    sub_1006D26A8(a2, (uint64_t)v12);
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      PB::Base::formattedText((uint64_t *)&__p, (PB::Base *)v12);
      char v6 = v11 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I saving plan subscr info: %s", buf, 0xCu);
      if (SHIBYTE(v11) < 0) {
        operator delete(__p);
      }
    }
    sub_1008362A0((uint64_t)v12, (PB::Writer *)&v18);
    char v10 = 0;
    uint64_t v11 = 0;
    std::string __p = 0;
    sub_1001E7940(&__p, v19, v18, v18 - (void)v19);
    uint64_t v7 = *(void *)(a1 + 48);
    std::operator+<char>();
    (*(void (**)(uint64_t, unsigned char *, void **))(*(void *)v7 + 24))(v7, buf, &__p);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    if (__p)
    {
      char v10 = __p;
      operator delete(__p);
    }
    sub_100835808((uint64_t)v12);
    PB::Writer::~Writer((PB::Writer *)&v18);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v12 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "iccid is empty skipping save", v12, 2u);
    }
  }
}

void sub_10023F380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  sub_100835808((uint64_t)&a13);
  PB::Writer::~Writer((PB::Writer *)(v13 - 88));
  _Unwind_Resume(a1);
}

void sub_10023F3DC(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 48) + 40))(&v11);
  uint64_t v6 = v11;
  uint64_t v7 = v12;
  uint64_t v8 = v12 - v11;
  if (v12 == v11)
  {
    *a3 = 0;
  }
  else
  {
    if (0xAAAAAAAAAAAAAAABLL * (v8 >> 6) >= 2)
    {
      uint64_t v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          char v10 = a2;
        }
        else {
          char v10 = (uint64_t *)*a2;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Multiple records for %s - taking the first one", buf, 0xCu);
        uint64_t v6 = v11;
        uint64_t v7 = v12;
      }
    }
    if (v7 == v6) {
      sub_10015B728();
    }
    sub_10023FB90((uint64_t)a3, v6);
    LOBYTE(v8) = 1;
  }
  a3[192] = v8;
  *(void *)long long buf = &v11;
  sub_10023FDC8((void ***)buf);
}

void sub_10023F538(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

void sub_10023F55C(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 48) + 48))(&v11);
  uint64_t v6 = v11;
  uint64_t v7 = v12;
  uint64_t v8 = v12 - v11;
  if (v12 == v11)
  {
    *a3 = 0;
  }
  else
  {
    if (0xAAAAAAAAAAAAAAABLL * (v8 >> 6) >= 2)
    {
      uint64_t v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          char v10 = a2;
        }
        else {
          char v10 = (uint64_t *)*a2;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Multiple records for %s - taking the first one", buf, 0xCu);
        uint64_t v6 = v11;
        uint64_t v7 = v12;
      }
    }
    if (v7 == v6) {
      sub_10015B728();
    }
    sub_10023FB90((uint64_t)a3, v6);
    LOBYTE(v8) = 1;
  }
  a3[192] = v8;
  *(void *)long long buf = &v11;
  sub_10023FDC8((void ***)buf);
}

void sub_10023F6B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

uint64_t sub_10023F6DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 56))();
}

void sub_10023F704(uint64_t a1, ctu *this, unint64_t a3)
{
  unsigned __int16 v3 = a3;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v6 = 0;
  ctu::hex((uint64_t *)__p, this, (const void *)0x10, a3);
  (*(void (**)(void, void **, void))(**(void **)(a1 + 48) + 64))(*(void *)(a1 + 48), __p, v3);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10023F798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10023F7B4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 72))();
}

uint64_t sub_10023F7DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 80))();
}

uint64_t sub_10023F804(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 144))
  {
    unsigned __int16 v3 = (void **)(a1 + 120);
    sub_1000C5358(&v3);
    if (*(char *)(a1 + 119) < 0) {
      operator delete(*(void **)(a1 + 96));
    }
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*(void **)(a1 + 72));
    }
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_10023F898(uint64_t a1)
{
  unsigned __int16 v3 = (void **)(a1 + 208);
  sub_10023F96C(&v3);
  unsigned __int16 v3 = (void **)(a1 + 184);
  sub_10023FA88(&v3);
  if (*(unsigned char *)(a1 + 152))
  {
    if (*(char *)(a1 + 183) < 0) {
      operator delete(*(void **)(a1 + 160));
    }
    *(unsigned char *)(a1 + 152) = 0;
  }
  if (*(unsigned char *)(a1 + 120))
  {
    if (*(char *)(a1 + 151) < 0) {
      operator delete(*(void **)(a1 + 128));
    }
    *(unsigned char *)(a1 + 120) = 0;
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10023F96C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 168;
        sub_10023F9F0(v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10023F9F0(uint64_t a1)
{
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 16);
    operator delete(v2);
  }
}

void sub_10023FA88(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 144;
        sub_10023FB0C(v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10023FB0C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 112))
  {
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    *(unsigned char *)(a1 + 112) = 0;
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(unsigned char *)(a1 + 48))
  {
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    *(unsigned char *)(a1 + 48) = 0;
  }
  if (*(unsigned char *)(a1 + 16))
  {
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    *(unsigned char *)(a1 + 16) = 0;
  }
}

uint64_t sub_10023FB90(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 64), *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v6;
  }
  if (*(char *)(a2 + 111) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 88), *(void **)(a2 + 88), *(void *)(a2 + 96));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 88);
    *(void *)(a1 + 104) = *(void *)(a2 + 104);
    *(_OWORD *)(a1 + 88) = v7;
  }
  if (*(char *)(a2 + 135) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 112), *(void **)(a2 + 112), *(void *)(a2 + 120));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 112);
    *(void *)(a1 + 128) = *(void *)(a2 + 128);
    *(_OWORD *)(a1 + 112) = v8;
  }
  if (*(char *)(a2 + 159) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 136), *(void **)(a2 + 136), *(void *)(a2 + 144));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 136);
    *(void *)(a1 + 152) = *(void *)(a2 + 152);
    *(_OWORD *)(a1 + 136) = v9;
  }
  char v10 = (unsigned char *)(a1 + 160);
  if (*(char *)(a2 + 183) < 0)
  {
    sub_10004FC84(v10, *(void **)(a2 + 160), *(void *)(a2 + 168));
  }
  else
  {
    long long v11 = *(_OWORD *)(a2 + 160);
    *(void *)(a1 + 176) = *(void *)(a2 + 176);
    *(_OWORD *)char v10 = v11;
  }
  *(_WORD *)(a1 + 184) = *(_WORD *)(a2 + 184);
  return a1;
}

void sub_10023FD34(_Unwind_Exception *exception_object)
{
  if (v1[159] < 0) {
    operator delete(*v7);
  }
  if (v1[135] < 0) {
    operator delete(*v6);
  }
  if (v1[111] < 0) {
    operator delete(*v5);
  }
  if (v1[87] < 0) {
    operator delete(*v4);
  }
  if (v1[55] < 0) {
    operator delete(*v3);
  }
  if (v1[31] < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10023FDC8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_1000C62D8(v4 - 192);
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10023FE4C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10023FF18(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10023FFF0);
  __cxa_rethrow();
}

void sub_10023FF40(_Unwind_Exception *a1)
{
}

void sub_10023FF58(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10023FF90(uint64_t a1)
{
}

uint64_t sub_10023FFAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10023FFF0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10024001C()
{
  return 1;
}

uint64_t sub_100240024()
{
  return 1;
}

uint64_t sub_10024002C()
{
  return 0;
}

uint64_t sub_100240034()
{
  return 0;
}

uint64_t sub_10024003C()
{
  return 0;
}

uint64_t sub_100240044()
{
  return 0;
}

uint64_t sub_10024004C()
{
  return 0;
}

uint64_t sub_100240054()
{
  return 0;
}

uint64_t sub_10024005C(uint64_t a1, os_log_t *a2)
{
  unsigned __int16 v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    long long v5 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v6 = 136315138;
    long long v7 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Compression is not supported for this message", (uint8_t *)&v6, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_100240110(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_100240118(uint64_t a1, os_log_t *a2)
{
  return sub_10024005C(a1 - 16, a2);
}

uint64_t sub_100240120()
{
  return 1;
}

uint64_t sub_100240128()
{
  return 1;
}

uint64_t sub_100240130()
{
  return 0;
}

uint64_t sub_100240138()
{
  return 0;
}

void sub_100240140(uint64_t a1@<X0>, os_log_t *a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    long long v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Encoding", buf, 0xCu);
  }
  if (*(void *)(a1 + 32) == *(void *)(a1 + 40))
  {
    long long v11 = *a2;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = sub_10093AA58(*(_DWORD *)(a1 + 12));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "[%s] No data to send", buf, 0xCu);
    }
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
  }
  else
  {
    *(_OWORD *)long long buf = 0u;
    long long v24 = 0u;
    sub_10024060C((uint64_t)buf, 0x64uLL);
    sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 24), 2uLL);
    sub_10024081C((unint64_t *)buf, *(unsigned __int8 *)(a1 + 25), 6uLL);
    long long v8 = *a2;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v9 = *(char *)(a1 + 24);
      if (v9 > 4) {
        char v10 = "???";
      }
      else {
        char v10 = off_1019AE230[v9];
      }
      uint64_t v12 = sub_10093AA7C(*(unsigned __int8 *)(a1 + 25));
      *(_DWORD *)char v22 = 136315394;
      *(void *)&v22[4] = v10;
      *(_WORD *)&v22[12] = 2080;
      *(void *)&v22[14] = v12;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Serialized header: Version: %s, MessageType: %s", v22, 0x16u);
    }
    uint64_t v13 = *(void *)buf;
    uint64_t v14 = *(void *)&buf[8];
    *(void *)char v22 = *(void *)buf;
    *(void *)&v22[8] = *(void *)&buf[8];
    uint64_t v15 = v24;
    *(void *)&v22[16] = v24;
    *(void *)&long long v24 = 0;
    memset(buf, 0, sizeof(buf));
    uint64_t v17 = *(unsigned char **)(a1 + 32);
    uint64_t v16 = *(unsigned char **)(a1 + 40);
    uint64_t v21 = (unint64_t *)v22;
    if (v17 == v16)
    {
      *(void *)a3 = v13;
      *(void *)(a3 + 8) = v14;
      *(void *)(a3 + 16) = v15;
      *(unsigned char *)(a3 + 24) = 1;
    }
    else
    {
      do
        sub_100240714(&v21, v17++);
      while (v17 != v16);
      uint64_t v18 = *(void *)&v22[16];
      long long v19 = *(void **)buf;
      *(_OWORD *)a3 = *(_OWORD *)v22;
      *(void *)(a3 + 16) = v18;
      *(unsigned char *)(a3 + 24) = 1;
      if (v19)
      {
        *(void *)&uint8_t buf[8] = v19;
        operator delete(v19);
      }
    }
  }
}

void sub_100240394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
}

void sub_1002403D0(uint64_t a1@<X0>, os_log_t *a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1002403D8()
{
  return 0;
}

uint64_t sub_1002403E0()
{
  return 0;
}

uint64_t sub_1002403F8(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_100240404()
{
}

void *sub_100240418(void *a1)
{
  *a1 = off_1019ADF38;
  a1[2] = &unk_1019ADFE0;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_100240488(void *a1)
{
  *a1 = off_1019ADF38;
  a1[2] = &unk_1019ADFE0;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }

  operator delete();
}

void sub_100240518(void *a1)
{
  *(a1 - 2) = off_1019ADF38;
  *a1 = &unk_1019ADFE0;
  uint64_t v1 = (void *)a1[2];
  if (v1)
  {
    a1[3] = v1;
    operator delete(v1);
  }
}

void sub_10024057C(void *a1)
{
  *(a1 - 2) = off_1019ADF38;
  *a1 = &unk_1019ADFE0;
  uint64_t v1 = (void *)a1[2];
  if (v1)
  {
    a1[3] = v1;
    operator delete(v1);
  }

  operator delete();
}

uint64_t sub_10024060C(uint64_t a1, size_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_100240658((unint64_t *)a1, a2);
  return a1;
}

void sub_10024063C(_Unwind_Exception *exception_object)
{
  unsigned __int16 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100240658(unint64_t *a1, size_t __sz)
{
  unint64_t v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0) {
      sub_10006A748();
    }
    long long v5 = (char *)a1[1];
    int v6 = operator new(__sz);
    long long v7 = &v5[(void)v6 - v2];
    long long v8 = v7;
    if (v5 != (char *)v2)
    {
      unint64_t v9 = &v5[~v2];
      do
      {
        char v10 = *--v5;
        (v9--)[(void)v6] = v10;
      }
      while (v5 != (char *)v2);
      long long v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
    {
      operator delete((void *)v2);
    }
  }
}

unint64_t **sub_100240714(unint64_t **a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  int v6 = (unsigned char *)(*a1)[1];
  unint64_t v5 = (*a1)[2];
  if ((unint64_t)v6 >= v5)
  {
    unint64_t v8 = *v4;
    unint64_t v9 = &v6[-*v4];
    unint64_t v10 = (unint64_t)(v9 + 1);
    if ((uint64_t)(v9 + 1) < 0) {
      sub_10006A748();
    }
    unint64_t v11 = v5 - v8;
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v12 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v12 = v10;
    }
    if (v12) {
      unint64_t v13 = (unint64_t)operator new(v12);
    }
    else {
      unint64_t v13 = 0;
    }
    uint64_t v14 = (char *)(v13 + v12);
    v9[v13] = *a2;
    uint64_t v7 = (uint64_t)&v9[v13 + 1];
    if (v6 == (unsigned char *)v8)
    {
      v13 += (unint64_t)v9;
    }
    else
    {
      uint64_t v15 = &v6[~v8];
      do
      {
        char v16 = *--v6;
        (v15--)[v13] = v16;
      }
      while (v6 != (unsigned char *)v8);
      int v6 = (unsigned char *)*v4;
    }
    *uint64_t v4 = v13;
    v4[1] = v7;
    void v4[2] = (unint64_t)v14;
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    unsigned char *v6 = *a2;
    uint64_t v7 = (uint64_t)(v6 + 1);
  }
  v4[1] = v7;
  return a1;
}

void sub_10024081C(unint64_t *a1, int a2, unint64_t a3)
{
  if (a3 - 9 <= 0xFFFFFFFFFFFFFFF7) {
    __assert_rtn("write", "CTBitwise.h", 40, "N > 0 && N <= 8");
  }
  unint64_t v4 = a1[3];
  if (v4)
  {
    if (a3 < 8) {
      unsigned int v5 = ~(-1 << a3);
    }
    else {
      unsigned int v5 = -1;
    }
    unsigned int v6 = v5 & a2;
    unint64_t v7 = v4 - a3;
    if (v4 >= a3)
    {
      a1[3] = v7;
      *(unsigned char *)(a1[1] - 1) |= (_BYTE)v6 << v7;
      return;
    }
    *(unsigned char *)(a1[1] - 1) |= v6 >> (a3 - v4);
    uint64_t v8 = a1[3] - a3 + 8;
    a1[3] = v8;
    unsigned int v9 = v6 << v8;
    unint64_t v11 = (unsigned char *)a1[1];
    unint64_t v10 = a1[2];
    if ((unint64_t)v11 >= v10)
    {
      unint64_t v12 = *a1;
      unint64_t v13 = &v11[-*a1];
      unint64_t v14 = (unint64_t)(v13 + 1);
      if ((uint64_t)(v13 + 1) >= 0)
      {
        unint64_t v15 = v10 - v12;
        if (2 * v15 > v14) {
          unint64_t v14 = 2 * v15;
        }
        if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v16 = v14;
        }
        if (v16) {
          unint64_t v17 = (unint64_t)operator new(v16);
        }
        else {
          unint64_t v17 = 0;
        }
        long long v25 = &v13[v17];
        uint64_t v26 = (char *)(v17 + v16);
        v13[v17] = v9;
        uint64_t v19 = (uint64_t)&v13[v17 + 1];
        if (v11 != (unsigned char *)v12)
        {
          uint64_t v29 = &v11[~v12];
          do
          {
            char v30 = *--v11;
            (v29--)[v17] = v30;
          }
          while (v11 != (unsigned char *)v12);
LABEL_36:
          unint64_t v11 = (unsigned char *)*a1;
          goto LABEL_38;
        }
        goto LABEL_37;
      }
      goto LABEL_42;
    }
  }
  else
  {
    a1[3] = 8 - a3;
    unsigned int v9 = a2 << (8 - a3);
    unint64_t v11 = (unsigned char *)a1[1];
    unint64_t v18 = a1[2];
    if ((unint64_t)v11 >= v18)
    {
      unint64_t v20 = *a1;
      uint64_t v21 = &v11[-*a1];
      unint64_t v22 = (unint64_t)(v21 + 1);
      if ((uint64_t)(v21 + 1) >= 0)
      {
        unint64_t v23 = v18 - v20;
        if (2 * v23 > v22) {
          unint64_t v22 = 2 * v23;
        }
        if (v23 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v24 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v24 = v22;
        }
        if (v24) {
          unint64_t v17 = (unint64_t)operator new(v24);
        }
        else {
          unint64_t v17 = 0;
        }
        long long v25 = &v21[v17];
        uint64_t v26 = (char *)(v17 + v24);
        v21[v17] = v9;
        uint64_t v19 = (uint64_t)&v21[v17 + 1];
        if (v11 != (unsigned char *)v20)
        {
          uint64_t v27 = &v11[~v20];
          do
          {
            char v28 = *--v11;
            (v27--)[v17] = v28;
          }
          while (v11 != (unsigned char *)v20);
          goto LABEL_36;
        }
LABEL_37:
        unint64_t v17 = (unint64_t)v25;
LABEL_38:
        *a1 = v17;
        a1[1] = v19;
        a1[2] = (unint64_t)v26;
        if (v11) {
          operator delete(v11);
        }
        goto LABEL_40;
      }
LABEL_42:
      sub_10006A748();
    }
  }
  *unint64_t v11 = v9;
  uint64_t v19 = (uint64_t)(v11 + 1);
LABEL_40:
  a1[1] = v19;
}

void sub_100240B34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100240C3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100240CFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100240F38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10024104C(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_100241370(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100241508(_Unwind_Exception *a1)
{
  unint64_t v7 = v5;

  _Unwind_Resume(a1);
}

void sub_10024165C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100241880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100241A1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100241E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t *sub_100241F18(uint64_t a1)
{
  sub_100C62630(a1, "kCellMonitorStart", (unint64_t)sub_100241FD0, 3u);
  sub_100C62630(a1, "kCellMonitorStop", (unint64_t)sub_1002420F8, 3u);
  sub_100C62700(a1, "kCellMonitorGetProperty", (unint64_t)sub_100242220, 3u);

  return sub_100C62700(a1, "kCellMonitorGetCellInfo", (unint64_t)sub_10005675C, 3u);
}

void sub_100241FD0(Registry **a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    unint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v11 = v3;
  unint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v11);
  if (!v7)
  {
    uint64_t v9 = 0;
LABEL_9:
    std::mutex::unlock(v2);
    uint64_t v8 = 0;
    char v10 = 1;
    if (!v9) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v9 = v7[3];
  uint64_t v8 = (std::__shared_weak_count *)v7[4];
  if (!v8) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v2);
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  char v10 = 0;
  if (v9) {
LABEL_10:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
LABEL_11:
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
}

void sub_1002420D8(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002420F8(Registry **a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    unint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v11 = v3;
  unint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v11);
  if (!v7)
  {
    uint64_t v9 = 0;
LABEL_9:
    std::mutex::unlock(v2);
    uint64_t v8 = 0;
    char v10 = 1;
    if (!v9) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v9 = v7[3];
  uint64_t v8 = (std::__shared_weak_count *)v7[4];
  if (!v8) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v2);
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  char v10 = 0;
  if (v9) {
LABEL_10:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 40))(v9);
LABEL_11:
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
}

void sub_100242200(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100242220(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    char v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v9;
  unint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v18);
  if (v13 && (unint64_t v14 = (std::__shared_weak_count *)v13[4]) != 0)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v8);
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v14);
    char v15 = 0;
  }
  else
  {
    std::mutex::unlock(v8);
    unint64_t v14 = 0;
    char v15 = 1;
  }
  if (xpc_dictionary_get_value(*a4, "kCellMonitorCellCount"))
  {
    xpc_object_t v20 = xpc_int64_create(45);
    if (!v20) {
      xpc_object_t v20 = xpc_null_create();
    }
    unint64_t v18 = *a5;
    uint64_t v19 = "kPosixError";
    sub_100035E70((uint64_t)&v18, &v20, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v20);
    xpc_object_t v20 = 0;
  }
  if (xpc_dictionary_get_value(*a4, "kCellMonitorUmtsCellCount"))
  {
    xpc_object_t v16 = xpc_int64_create(45);
    if (!v16) {
      xpc_object_t v16 = xpc_null_create();
    }
    unint64_t v18 = *a5;
    uint64_t v19 = "kPosixError";
    sub_100035E70((uint64_t)&v18, &v16, &v17);
    xpc_release(v17);
    xpc_object_t v17 = 0;
    xpc_release(v16);
    xpc_object_t v16 = 0;
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1002423DC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002423FC()
{
  return sub_100C624B8((uint64_t)&unk_101B0C9F3, (uint64_t)sub_100241F18);
}

void sub_100242418(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1002424A8()
{
}

uint64_t sub_1002424CC(uint64_t a1, int a2, void *a3, NSObject **a4, int a5)
{
  char v5 = a5;
  unint64_t v9 = "em.ims.volte.2";
  if (a5) {
    unint64_t v9 = "em.ims.wifi.2";
  }
  char v10 = "em.ims.volte.1";
  if (a5) {
    char v10 = "em.ims.wifi.1";
  }
  if (a2 != 2) {
    unint64_t v9 = "em.ims";
  }
  if (a2 == 1) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = v9;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v20, kCtLoggingSystemName, v11);
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  unsigned int v12 = *a4;
  *(void *)(a1 + 136) = *a4;
  if (v12) {
    dispatch_retain(v12);
  }
  *(void *)(a1 + 144) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v21, &v20);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 152), (const ctu::OsLogLogger *)v21);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v21);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  emergency::CallAgent::CallAgent();
  *(void *)a1 = off_1019AE278;
  *(void *)(a1 + 160) = *a3;
  uint64_t v13 = a3[1];
  *(void *)(a1 + 168) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 176) = v5;
  unint64_t v14 = (char *)sub_10024270C(a1);
  sub_100058DB0(&__p, v14);
  char v15 = *(NSObject **)(a1 + 136);
  xpc_object_t v17 = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  ctu::RestModule::RestModule();
  if (v17) {
    dispatch_release(v17);
  }
  if (v19 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 200) = a1 + 208;
  return a1;
}

void sub_10024267C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  unint64_t v23 = (std::__shared_weak_count *)*((void *)v19 + 21);
  if (v23) {
    sub_10004D2C8(v23);
  }
  emergency::CallAgent::~CallAgent(v19);
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

const char *sub_10024270C(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 8);
  if (v1 > 3) {
    return "???";
  }
  if (*(unsigned char *)(a1 + 176)) {
    char v2 = off_1019AE450;
  }
  else {
    char v2 = off_1019AE470;
  }
  return v2[v1];
}

uint64_t sub_100242748(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176)) {
    return 2;
  }
  else {
    return 5;
  }
}

void sub_100242760(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v3, *(Registry **)(a1 + 160));
  ctu::RestModule::connect();
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100058DB0(&__p, "/cc/props/ims_registration_state");
  char v2 = operator new(0x28uLL);
  *char v2 = off_1019AE3E0;
  v2[1] = a1 + 200;
  v2[2] = a1;
  v2[3] = sub_1002428A0;
  v2[4] = 0;
  v7[3] = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v7);
  if (v6 < 0) {
    operator delete(__p);
  }
}

void sub_100242858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002428A0(unsigned __int8 *a1, uint64_t a2)
{
  v16[0] = 0;
  v16[1] = 0;
  uint64_t v17 = 0;
  PersonalityIdFromSlotIdEx();
  *(_OWORD *)std::string __p = *(_OWORD *)v16;
  uint64_t v15 = 0;
  unint64_t v4 = sub_100046F68((uint64_t)(a1 + 200), __p);
  if (a1 + 208 == (unsigned __int8 *)v4)
  {
    int v6 = 0;
    int v5 = 0;
    int v7 = 0;
  }
  else
  {
    int v5 = *((_DWORD *)v4 + 14);
    int v6 = *((_DWORD *)v4 + 15) & 1;
    int v7 = *((unsigned __int8 *)v4 + 64);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v17) < 0)
  {
    sub_10004FC84(v12, v16[0], (unint64_t)v16[1]);
  }
  else
  {
    *(_OWORD *)unsigned int v12 = *(_OWORD *)v16;
    uint64_t v13 = v17;
  }
  uint64_t v8 = sub_100046F68(a2, v12);
  if ((void **)(a2 + 8) == v8)
  {
    int v10 = 0;
    int v9 = 0;
    int v11 = 0;
  }
  else
  {
    int v9 = *((_DWORD *)v8 + 14);
    int v10 = *((_DWORD *)v8 + 15) & 1;
    int v11 = *((unsigned __int8 *)v8 + 64);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
  if (v9 == 1 && v10 && v11 == a1[176] && (v5 != 1 || !v6 || v7 != v11)) {
    emergency::CallAgent::reportContextGone((emergency::CallAgent *)a1);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
}

void sub_100242A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100242A64(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 112)) {
    return 0;
  }
  uint64_t v3 = a1 + 200;
  PersonalityIdFromSlotIdEx();
  unint64_t v4 = sub_100046F68(v3, &__p);
  BOOL v1 = (void **)(a1 + 208) != v4
    && *((_DWORD *)v4 + 14) == 1
    && *(unsigned __int8 *)(a1 + 176) == *((unsigned __int8 *)v4 + 64);
  if (v7 < 0) {
    operator delete(__p);
  }
  return v1;
}

void sub_100242B00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100242B1C(emergency::CallAgent *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1000F0058((uint64_t)v10, a2);
  sub_1000DFC90((uint64_t)v9, a3);
  sub_1000F0058((uint64_t)v8, a4);
  emergency::CallAgent::dial();
  sub_10003B34C(v8);
  sub_100060644(v9);
  sub_10003B34C(v10);
  return emergency::CallAgent::readyToDial(a1);
}

void sub_100242BD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  sub_10003B34C((uint64_t *)va);
  sub_100060644((uint64_t *)va1);
  sub_10003B34C((uint64_t *)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_100242C10(uint64_t a1)
{
  *(void *)a1 = off_1019AE278;
  sub_10005CD2C(a1 + 200, *(char **)(a1 + 208));
  char v2 = *(std::__shared_weak_count **)(a1 + 192);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 168);
  if (v3) {
    sub_10004D2C8(v3);
  }
  emergency::CallAgent::~CallAgent((emergency::CallAgent *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 152));
  sub_100087E88((void *)(a1 + 120));
  return a1;
}

void sub_100242C8C(uint64_t a1)
{
  *(void *)a1 = off_1019AE278;
  sub_10005CD2C(a1 + 200, *(char **)(a1 + 208));
  char v2 = *(std::__shared_weak_count **)(a1 + 192);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 168);
  if (v3) {
    sub_10004D2C8(v3);
  }
  emergency::CallAgent::~CallAgent((emergency::CallAgent *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 152));
  sub_100087E88((void *)(a1 + 120));

  operator delete();
}

uint64_t sub_100242D28()
{
  return 1;
}

void sub_100242D30(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100242DFC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[17], v1, (dispatch_function_t)sub_100242ED4);
  __cxa_rethrow();
}

void sub_100242E24(_Unwind_Exception *a1)
{
}

void sub_100242E3C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100242E74(uint64_t a1)
{
}

uint64_t sub_100242E90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100242ED4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100242F04()
{
}

__n128 sub_100242F18(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_1019AE3E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100242F6C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019AE3E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100242FA4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  unint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  int v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    *unint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_1002430C8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_100243064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10024307C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002430BC()
{
}

void sub_1002430C8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_10005CD2C(a1, *(char **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v12, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v11, object, count);
    xpc_release(object[0]);
    for (i = v13; i != v11[1] || v12 != v11[0]; i = ++v13)
    {
      xpc_object_t v10 = 0;
      object[0] = &v12;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v10);
      if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
      {
        long long v8 = 0u;
        long long v9 = 0u;
        *(_OWORD *)xpc_object_t object = 0u;
        *(void *)((char *)&v9 + 4) = 0xFFFFFFFF00000002;
        xpc_object_t v6 = v10;
        if (v10) {
          xpc_retain(v10);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_100243388((uint64_t)object, &v6);
        xpc_release(v6);
        sub_1002434D0((uint64_t **)a1, object, (uint64_t)object);
        if (SBYTE7(v8) < 0) {
          operator delete(object[0]);
        }
      }
      xpc_release(v10);
    }
    xpc_release(v12);
    xpc_release(v12);
  }
  xpc_release(v3);
}

void sub_1002432E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,xpc_object_t a21,xpc_object_t a22)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v23 - 64));
  xpc_release(v22);
  _Unwind_Resume(a1);
}

void sub_100243388(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v7 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v7 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    unint64_t v4 = &v7;
    uint64_t v5 = "first";
    sub_100048BAC((uint64_t)&v4, &object);
    read_rest_value();
    xpc_release(object);
    unint64_t v4 = &v7;
    uint64_t v5 = "second";
    sub_100048BAC((uint64_t)&v4, &object);
    sub_1005919DC((int *)(a1 + 24), &object);
    xpc_release(object);
    xpc_object_t v3 = v7;
  }
  xpc_release(v3);
}

void sub_10024347C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12)
{
}

uint64_t *sub_1002434D0(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v8, a2);
  __n128 result = *v5;
  if (!*v5)
  {
    memset(v7, 0, sizeof(v7));
    sub_10024355C((uint64_t)a1, a3, v7);
    sub_100046C38(a1, v8, v5, v7[0]);
    return v7[0];
  }
  return result;
}

__n128 sub_10024355C@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  xpc_object_t v6 = a3 + 1;
  xpc_object_t v7 = (char *)operator new(0x50uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t v8 = v7 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v8, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
    *((void *)v7 + 6) = *(void *)(a2 + 16);
  }
  __n128 result = *(__n128 *)(a2 + 24);
  *(__n128 *)(v7 + 56) = result;
  *((_DWORD *)v7 + 18) = *(_DWORD *)(a2 + 40);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1002435FC(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

void sub_100243618(NSObject **a1@<X1>, void *a2@<X8>)
{
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x28uLL);
  uint64_t v5 = v4;
  v4[1] = 0;
  void v4[2] = 0;
  *unint64_t v4 = off_1019AE500;
  xpc_object_t v6 = v4 + 3;
  if (v3)
  {
    dispatch_retain(v3);
    v5[3] = &off_1019C13E8;
    v5[4] = v3;
    dispatch_retain(v3);
    dispatch_release(v3);
  }
  else
  {
    v4[3] = &off_1019C13E8;
    v4[4] = 0;
  }
  *a2 = v6;
  a2[1] = v5;
}

void sub_1002436D0(EosFactoryInterface *this)
{
  *(void *)this = off_1019AE4C0;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  EosFactoryInterface::~EosFactoryInterface(this);
}

void sub_10024372C(EosFactoryInterface *this)
{
  *(void *)this = off_1019AE4C0;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  EosFactoryInterface::~EosFactoryInterface(this);

  operator delete();
}

void sub_10024379C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AE500;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002437BC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AE500;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100243810(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100243838()
{
}

void sub_1002438C4(void *a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  xpc_object_t v6 = (std::__shared_weak_count *)a1[4];
  if (v6)
  {
    long long v9 = std::__shared_weak_count::lock(v6);
    OsLogContext v20 = v9;
    if (v9)
    {
      if (a1[3])
      {
        xpc_object_t v10 = (std::__shared_weak_count *)a1[2];
        if (v10)
        {
          uint64_t v11 = a1[1];
          uint64_t v12 = std::__shared_weak_count::lock(v10);
          if (v12)
          {
            uint64_t v16 = v11;
            uint64_t v17 = v12;
            uint64_t v13 = *a2;
            dispatch_object_t object = v13;
            if (v13) {
              dispatch_retain(v13);
            }
            *(_OWORD *)unint64_t v14 = *(_OWORD *)a3;
            *(void *)a3 = 0;
            *(void *)(a3 + 8) = 0;
            sub_100243A0C(v14, &v18);
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v9);
    }
  }
  *a4 = 0;
  a4[1] = 0;
}

void sub_1002439C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, dispatch_object_t object, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(v14 - 40);
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100243A0C(uint64_t *a1@<X3>, void *a2@<X8>)
{
  v3[0] = 0;
  v3[1] = 0;
  sub_1002449C0(a1, v3);
  *a2 = 0;
  a2[1] = 0;
  operator new();
}

void sub_100243B2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100243B98@<X0>(dispatch_object_t *a1@<X1>, const void **a2@<X2>, uint64_t a3@<X3>, _OWORD *a4@<X8>)
{
  CFStringRef v13 = @"Priority Call";
  CFRetain(@"Priority Call");
  CFStringRef v12 = @"Cancel";
  CFRetain(@"Cancel");
  CFStringRef v11 = @"Continue";
  CFRetain(@"Continue");
  uint64_t v8 = operator new(0x78uLL);
  v8[1] = 0;
  void v8[2] = 0;
  *uint64_t v8 = off_1019AE920;
  dispatch_object_t object = *a1;
  *a1 = 0;
  sub_1001D7AC4((uint64_t)(v8 + 3), (const void **)&v13, a2, (const void **)&v12, (const void **)&v11, &object, a3);
  if (object) {
    dispatch_release(object);
  }
  *(void *)&long long v10 = v8 + 3;
  *((void *)&v10 + 1) = v8;
  sub_1000B3BC8((uint64_t)&v10, v8 + 4, (uint64_t)(v8 + 3));
  *a4 = v10;
  sub_1000558F4((const void **)&v11);
  sub_1000558F4((const void **)&v12);
  return sub_1000558F4((const void **)&v13);
}

void sub_100243CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, const void *a13, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  std::__shared_weak_count::~__shared_weak_count(v14);
  operator delete(v16);
  sub_1000558F4(&a11);
  sub_1000558F4(&a12);
  sub_1000558F4(&a13);
  _Unwind_Resume(a1);
}

void sub_100243CF8(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    uint64_t v8 = v5;
    if (v5)
    {
      if (*(void *)(a1 + 24)) {
        sub_1008545C8(&v6);
      }
      sub_10004D2C8(v5);
    }
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_100243D7C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

double sub_100243D90@<D0>(_OWORD *a1@<X8>)
{
  sub_100BD482C((std::__shared_weak_count **)&v3);
  double result = *(double *)&v3;
  *a1 = v3;
  return result;
}

void sub_100243DC8(void *a1@<X0>, uint64_t a2@<X3>, void *a3@<X8>)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[4];
  if (v5)
  {
    xpc_object_t v7 = std::__shared_weak_count::lock(v5);
    CFStringRef v12 = v7;
    if (v7)
    {
      if (a1[3])
      {
        uint64_t v8 = (std::__shared_weak_count *)a1[2];
        if (v8 && std::__shared_weak_count::lock(v8))
        {
          uint64_t v9 = *(void *)(a2 + 8);
          if (v9) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
          }
          sub_100243EF8(&v10);
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_100243EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100243EF8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100243FE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v12) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_100244024(void *a1@<X0>, uint64_t a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[4];
  if (v5)
  {
    xpc_object_t v7 = std::__shared_weak_count::lock(v5);
    int v12 = v7;
    if (v7)
    {
      if (a1[3])
      {
        uint64_t v8 = (std::__shared_weak_count *)a1[2];
        if (v8 && std::__shared_weak_count::lock(v8))
        {
          uint64_t v9 = *(void *)(a2 + 8);
          if (v9) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
          }
          sub_100244144(&v10);
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_10024410C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100244144(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100244220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v12) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_100244260(const void **a1@<X1>, void *a2@<X2>, int a3@<W3>, uint64_t a4@<X8>)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v11 = 0;
  sub_10012A394(&v9, a1);
  sub_101328F44((CFUUIDRef *)&v9, (uint64_t)__p);
  sub_10012577C(&v9);
  if (a3)
  {
    sub_100246DF4(&v8);
LABEL_5:
    *(_OWORD *)a4 = v8;
    goto LABEL_6;
  }
  if (*a2)
  {
    xpc_object_t v7 = operator new(0x70uLL);
    v7[1] = 0;
    v7[2] = 0;
    *xpc_object_t v7 = off_1019AEB08;
    ims::Call::Call();
    *(void *)&long long v8 = v7 + 3;
    *((void *)&v8 + 1) = v7;
    sub_1000B3BC8((uint64_t)&v8, v7 + 4, (uint64_t)(v7 + 3));
    goto LABEL_5;
  }
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
LABEL_6:
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100244350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  std::__shared_weak_count::~__shared_weak_count(v18);
  operator delete(v20);
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100244394(void *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, dispatch_object_t *a4@<X4>, void *a5@<X8>)
{
  xpc_object_t v7 = (std::__shared_weak_count *)a1[4];
  if (v7)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v7);
    uint64_t v17 = v11;
    if (v11)
    {
      if (a1[3])
      {
        uint64_t v12 = *(void *)(a2 + 8);
        if (v12) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v13 = *(void *)(a3 + 8);
        if (v13) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
        }
        if (*a4) {
          dispatch_retain(*a4);
        }
        uint64_t v14 = (std::__shared_weak_count *)a1[2];
        if (v14)
        {
          if (std::__shared_weak_count::lock(v14)) {
            sub_100244524(&v15);
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v11);
    }
  }
  *a5 = 0;
  a5[1] = 0;
}

void sub_1002444D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 56);
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100244524(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1002446A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, dispatch_object_t object)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  uint64_t v21 = *(std::__shared_weak_count **)(v19 + 8);
  if (v21) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

double sub_100244738@<D0>(_OWORD *a1@<X8>)
{
  sub_100248248(v3);
  double result = v3[0];
  *a1 = *(_OWORD *)v3;
  return result;
}

void sub_100244774(CallFactoryInterface *this)
{
  *(void *)this = off_1019AE550;
  char v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  long long v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  CallFactoryInterface::~CallFactoryInterface(this);
}

void sub_1002447DC(CallFactoryInterface *this)
{
  *(void *)this = off_1019AE550;
  char v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  long long v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  CallFactoryInterface::~CallFactoryInterface(this);

  operator delete();
}

void sub_100244858(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1002448D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100244914(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10024494C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10024497C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_1002449C0@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x30uLL);
  uint64_t result = sub_100244A1C(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100244A08(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100244A1C(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019AE678;
  sub_100244B14(a1 + 3, a2);
  return a1;
}

void sub_100244A64(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100244A78(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AE678;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100244A98(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AE678;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100244AEC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_100244B14(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  long long v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  *a1 = off_1019AE6C8;
  a1[1] = v4;
  a1[2] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
  }
  return a1;
}

void *sub_100244B74(void *a1)
{
  *a1 = off_1019AE6C8;
  char v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100244BC0(void *a1)
{
  *a1 = off_1019AE6C8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

uint64_t sub_100244C2C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t sub_100244C5C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_100244C8C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

const void **sub_100244CBC(const void **result, const void **a2)
{
  char v2 = result[1];
  if (v2)
  {
    sub_10012A394(&v3, a2);
    (*(void (**)(const void *, const void **))(*(void *)v2 + 40))(v2, &v3);
    return sub_10012577C(&v3);
  }
  return result;
}

void sub_100244D24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100244D38(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t sub_100244D68(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 56))();
  }
  return result;
}

uint64_t sub_100244D98(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 64))();
  }
  return result;
}

const void **sub_100244DC8(const void **result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = result[1];
  if (v4)
  {
    sub_100245B5C((uint64_t)v7, a2);
    (*(void (**)(const void *, unsigned char *, uint64_t, uint64_t))(*(void *)v4 + 80))(v4, v7, a3, a4);
    return sub_1002243E8((uint64_t)v7);
  }
  return result;
}

void sub_100244E48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002243E8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100244E5C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 104))();
  }
  return result;
}

uint64_t sub_100244E8C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 96))();
  }
  return result;
}

uint64_t sub_100244EBC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 112))();
  }
  return result;
}

uint64_t sub_100244EEC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 120))();
  }
  return result;
}

uint64_t sub_100244F1C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 128))();
  }
  return result;
}

uint64_t sub_100244F4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 200))();
  }
  return result;
}

uint64_t sub_100244F7C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 208))();
  }
  return result;
}

uint64_t sub_100244FAC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 144))();
  }
  return result;
}

uint64_t sub_100244FDC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 152))();
  }
  return result;
}

uint64_t sub_10024500C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 160))();
  }
  return result;
}

uint64_t sub_10024503C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 168))();
  }
  return result;
}

const void **sub_10024506C(const void **result, uint64_t a2, const void **a3, uint64_t a4)
{
  uint64_t v4 = result[1];
  if (v4)
  {
    sub_10012A394(&v7, a3);
    (*(void (**)(const void *, uint64_t, const void **, uint64_t))(*(void *)v4 + 248))(v4, a2, &v7, a4);
    return sub_10012577C(&v7);
  }
  return result;
}

void sub_1002450F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100245104(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 256))();
  }
  return result;
}

uint64_t sub_10024513C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 264))();
  }
  return result;
}

uint64_t sub_100245174(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 272))();
  }
  return result;
}

uint64_t sub_1002451AC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 288))();
  }
  return result;
}

uint64_t sub_1002451E4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 512))();
  }
  return result;
}

uint64_t sub_10024521C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 280))();
  }
  return result;
}

uint64_t sub_100245254(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 296))();
  }
  return result;
}

uint64_t sub_10024528C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 304))();
  }
  return result;
}

uint64_t sub_1002452C4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 312))();
  }
  return result;
}

uint64_t sub_1002452FC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 328))();
  }
  return result;
}

void sub_100245334(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v2 + 400))(&v4);
    sub_100245F0C((void **)a2);
    *(_OWORD *)a2 = v4;
    *(void *)(a2 + 16) = v5;
    uint64_t v5 = 0;
    long long v4 = 0uLL;
    long long v6 = (void **)&v4;
    sub_1002244D8(&v6);
  }
}

void sub_1002453CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_1002453E4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 408))();
  }
  return result;
}

uint64_t sub_10024541C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 416))();
  }
  return result;
}

void sub_100245454(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v2 + 424))(&v4);
    sub_100245F0C((void **)a2);
    *(_OWORD *)a2 = v4;
    *(void *)(a2 + 16) = v5;
    uint64_t v5 = 0;
    long long v4 = 0uLL;
    long long v6 = (void **)&v4;
    sub_1002244D8(&v6);
  }
}

void sub_1002454EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_100245504(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  sub_10012A394(&v7, a2);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, const void **, uint64_t))(*(void *)v3 + 432))(v3, &v7, a3);
  sub_10012577C(&v7);
  return v5;
}

void sub_10024558C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1002455A0(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (std::__shared_weak_count *)a2[1];
    uint64_t v4 = *a2;
    uint64_t v5 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 440))(v2, &v4);
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
}

void sub_100245620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100245638(const void **result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1];
  if (v3)
  {
    sub_100245B5C((uint64_t)v5, a2);
    (*(void (**)(const void *, unsigned char *, uint64_t))(*(void *)v3 + 456))(v3, v5, a3);
    return sub_1002243E8((uint64_t)v5);
  }
  return result;
}

void sub_1002456B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002243E8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002456CC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 464))();
  }
  return result;
}

uint64_t sub_100245704@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 488))();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t sub_100245740(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 472))();
  }
  return result;
}

const void **sub_100245778(const void **result, uint64_t a2)
{
  uint64_t v2 = result[1];
  if (v2)
  {
    sub_100245B5C((uint64_t)v3, a2);
    (*(void (**)(const void *, unsigned char *))(*(void *)v2 + 496))(v2, v3);
    return sub_1002243E8((uint64_t)v3);
  }
  return result;
}

void sub_1002457E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002243E8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002457FC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 384))();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t sub_10024583C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 392))();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t sub_10024587C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 184))();
  }
  return result;
}

uint64_t sub_1002458AC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 520))();
  }
  return result;
}

uint64_t sub_1002458E4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 528))();
  }
  return result;
}

void *sub_10024591C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    return (void *)(*(uint64_t (**)(void))(*(void *)v2 + 536))();
  }
  else {
    return sub_100058DB0(a2, "");
  }
}

uint64_t sub_100245960(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 544))();
  }
  return result;
}

uint64_t sub_100245998(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 552))();
  }
  return result;
}

uint64_t sub_1002459D0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 560))();
  }
  return result;
}

uint64_t sub_100245A08(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 568))();
  }
  return result;
}

uint64_t sub_100245A40(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 576))();
  }
  return result;
}

uint64_t sub_100245A78(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 584))();
  }
  return result;
}

uint64_t sub_100245AB0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 600))();
  }
  return result;
}

uint64_t sub_100245AE8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 616))();
  }
  return result;
}

uint64_t sub_100245B20(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 320))();
  }
  else {
    return 255;
  }
}

uint64_t sub_100245B5C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10012A394((const void **)a1, (const void **)a2);
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)v4 + 8, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 8);
    v4[3] = *(const void **)(a2 + 24);
    *(_OWORD *)(v4 + 1) = v5;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v6;
  }
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  long long v7 = *(_OWORD *)(a2 + 72);
  long long v8 = *(_OWORD *)(a2 + 88);
  long long v9 = *(_OWORD *)(a2 + 104);
  *(void *)(a1 + 117) = *(void *)(a2 + 117);
  *(_OWORD *)(a1 + 104) = v9;
  *(_OWORD *)(a1 + 88) = v8;
  *(_OWORD *)(a1 + 72) = v7;
  if (*(char *)(a2 + 151) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 128), *(void **)(a2 + 128), *(void *)(a2 + 136));
  }
  else
  {
    long long v10 = *(_OWORD *)(a2 + 128);
    *(void *)(a1 + 144) = *(void *)(a2 + 144);
    *(_OWORD *)(a1 + 128) = v10;
  }
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  if (*(char *)(a2 + 183) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 160), *(void **)(a2 + 160), *(void *)(a2 + 168));
  }
  else
  {
    long long v11 = *(_OWORD *)(a2 + 160);
    *(void *)(a1 + 176) = *(void *)(a2 + 176);
    *(_OWORD *)(a1 + 160) = v11;
  }
  long long v12 = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 193) = *(_OWORD *)(a2 + 193);
  *(_OWORD *)(a1 + 184) = v12;
  sub_100245DF0(a1 + 216, a2 + 216);
  long long v13 = *(_OWORD *)(a2 + 248);
  *(unsigned char *)(a1 + 264) = *(unsigned char *)(a2 + 264);
  *(_OWORD *)(a1 + 248) = v13;
  if (*(char *)(a2 + 295) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 272), *(void **)(a2 + 272), *(void *)(a2 + 280));
  }
  else
  {
    long long v14 = *(_OWORD *)(a2 + 272);
    *(void *)(a1 + 288) = *(void *)(a2 + 288);
    *(_OWORD *)(a1 + 272) = v14;
  }
  long long v15 = (unsigned char *)(a1 + 296);
  if (*(char *)(a2 + 319) < 0)
  {
    sub_10004FC84(v15, *(void **)(a2 + 296), *(void *)(a2 + 304));
  }
  else
  {
    long long v16 = *(_OWORD *)(a2 + 296);
    *(void *)(a1 + 312) = *(void *)(a2 + 312);
    *(_OWORD *)long long v15 = v16;
  }
  long long v17 = *(_OWORD *)(a2 + 336);
  *(_OWORD *)(a1 + 320) = *(_OWORD *)(a2 + 320);
  *(_OWORD *)(a1 + 336) = v17;
  long long v18 = *(_OWORD *)(a2 + 352);
  long long v19 = *(_OWORD *)(a2 + 368);
  long long v20 = *(_OWORD *)(a2 + 384);
  *(void *)(a1 + 397) = *(void *)(a2 + 397);
  *(_OWORD *)(a1 + 368) = v19;
  *(_OWORD *)(a1 + 384) = v20;
  *(_OWORD *)(a1 + 352) = v18;
  return a1;
}

void sub_100245D44(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 295) < 0) {
    operator delete(*v7);
  }
  if (*(unsigned char *)(v1 + 240))
  {
    long long v9 = *v6;
    if (*v6)
    {
      *(void *)(v1 + 224) = v9;
      operator delete(v9);
    }
  }
  if (*(char *)(v1 + 183) < 0) {
    operator delete(*v5);
  }
  if (*(char *)(v1 + 151) < 0) {
    operator delete(*v4);
  }
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  sub_10012577C((const void **)v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100245DF0(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  sub_100245E44((void *)a1, a2);
  return a1;
}

void sub_100245E20(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

void *sub_100245E44(void *result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v2 = result;
    void *result = 0;
    result[1] = 0;
    result[2] = 0;
    uint64_t result = sub_100245E90(result, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    *((unsigned char *)v2 + 24) = 1;
  }
  return result;
}

void *sub_100245E90(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    uint64_t result = sub_10005CCE8(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_100245EF0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100245F0C(void **a1)
{
  uint64_t v1 = (const void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (const void **)a1[1];
    uint64_t v4 = v1;
    if (v3 != v1)
    {
      do
        uint64_t v3 = sub_1002243E8((uint64_t)(v3 - 51));
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_100245F6C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100245FEC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[4], v1, (dispatch_function_t)sub_100246158);
  __cxa_rethrow();
}

void sub_100246014(_Unwind_Exception *a1)
{
}

void sub_100246028(uint64_t a1, void *a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      uint64_t v5 = a3 + 8;
      if (!a3) {
        uint64_t v5 = 0;
      }
      long long v6 = *(std::__shared_weak_count **)(a1 + 8);
      if (v6)
      {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = v5;
      a2[1] = v6;
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v6)
      {
        sub_10004D2C8(v6);
      }
    }
  }
}

void sub_1002460C0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1002460F8(uint64_t a1)
{
}

uint64_t sub_100246114(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100246158(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100246184(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AE920;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002461A4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AE920;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002461F8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_100246220(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, char a5, uint64_t *a6)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v14, kCtLoggingSystemName, kCALL_USSD_LOG_DOMAIN);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v15, &v14);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 24), (const ctu::OsLogLogger *)v15);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v15);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v14);
  *(void *)a1 = off_101AC1948;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 1;
  *(unsigned char *)(a1 + 60) = a5;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 86) = 0;
  *(void *)(a1 + 96) = *a2;
  uint64_t v12 = a2[1];
  *(void *)(a1 + 104) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100246444(a6, &v14);
  *(OsLogContext *)(a1 + 112) = v14;
  (*(void (**)(void))(**(void **)a3 + 40))();
  std::string::operator=((std::string *)(a1 + 32), (const std::string *)(a4 + 32));
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a4 + 252);
  return a1;
}

void sub_1002463A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  long long v17 = *(std::__shared_weak_count **)(v12 + 136);
  if (v17) {
    sub_10004D2C8(v17);
  }
  long long v18 = *(std::__shared_weak_count **)(v12 + 120);
  if (v18) {
    sub_10004D2C8(v18);
  }
  long long v19 = *(std::__shared_weak_count **)(v12 + 104);
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (*(char *)(v12 + 87) < 0) {
    operator delete(*v15);
  }
  if (*(char *)(v12 + 55) < 0) {
    operator delete(*v14);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  long long v20 = *(std::__shared_weak_count **)(v12 + 16);
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  USSDServiceInterface::~USSDServiceInterface((USSDServiceInterface *)v12);
  _Unwind_Resume(a1);
}

void *sub_100246444@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x30uLL);
  uint64_t result = sub_1002464A0(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10024648C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1002464A0(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019AE970;
  sub_100246598(a1 + 3, a2);
  return a1;
}

void sub_1002464E8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1002464FC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AE970;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10024651C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AE970;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100246570(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_100246598(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *a1 = off_1019AE9C0;
    a1[1] = v4;
    a1[2] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
  }
  else
  {
    *a1 = off_1019AE9C0;
    a1[1] = v4;
    a1[2] = 0;
  }
  return a1;
}

void *sub_10024661C(void *a1)
{
  *a1 = off_1019AE9C0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100246668(void *a1)
{
  *a1 = off_1019AE9C0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

uint64_t sub_1002466D4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t sub_100246704(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_100246734(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t sub_100246764(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t sub_100246794(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t sub_1002467C4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 56))();
  }
  return result;
}

uint64_t sub_1002467F4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 64))();
  }
  return result;
}

uint64_t sub_100246824(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

uint64_t sub_100246854(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 80))();
  }
  return result;
}

void sub_100246884(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100246904(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100246940(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100246978(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1002469A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1002469EC(uint64_t a1, void *a2, uint64_t *a3, char a4, uint64_t *a5)
{
  long long v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v15 = *a3;
  long long v16 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "");
  long long v10 = (std::__shared_weak_count *)a5[1];
  uint64_t v12 = *a5;
  long long v13 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100246AF0(a1, a2, &v15, &__p, 1, a4, &v12);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  return a1;
}

void sub_100246AB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100246AF0(uint64_t a1, void *a2, uint64_t *a3, const std::string *a4, int a5, char a6, uint64_t *a7)
{
  long long v13 = (std::__shared_weak_count *)a3[1];
  uint64_t v57 = *a3;
  long long v58 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  memset(v18, 0, sizeof(v18));
  sub_100058DB0(v19, kCallerIdDefaultValue);
  int v20 = 9;
  char v21 = 0;
  int v22 = 1;
  char v23 = 1;
  uint64_t v24 = 0x400000001;
  uint64_t v25 = 2;
  char v26 = 0;
  int v27 = CallInfo::kDefaultCallId;
  char v30 = 0;
  char v31 = 0;
  uint64_t v28 = 0;
  v29[0] = 0;
  *(void *)((char *)v29 + 6) = 0;
  sub_100058DB0(v32, "");
  int v33 = 0;
  sub_100058DB0(v34, "");
  int v35 = 0;
  __int16 v36 = 0;
  int v37 = 0;
  __int16 v38 = 0;
  int v39 = 0;
  char v40 = 0;
  char v41 = 0;
  char v42 = 0;
  char v43 = 0;
  __int16 v44 = 0;
  int v45 = 1;
  char v46 = 0;
  int v47 = 0;
  char v48 = 0;
  char v54 = 0;
  char v55 = 0;
  char v56 = 0;
  char v53 = 0;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  OsLogContext v14 = (std::__shared_weak_count *)a7[1];
  uint64_t v16 = *a7;
  long long v17 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100246220(a1, a2, (uint64_t)&v57, (uint64_t)v18, a6, &v16);
  if (v17) {
    sub_10004D2C8(v17);
  }
  sub_1002243E8((uint64_t)v18);
  if (v58) {
    sub_10004D2C8(v58);
  }
  std::string::operator=((std::string *)(a1 + 32), a4);
  *(_DWORD *)(a1 + 56) = a5;
  return a1;
}

void sub_100246CBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_100246D4C(v38);
  _Unwind_Resume(a1);
}

void sub_100246D4C(uint64_t a1)
{
  *(void *)a1 = off_101AC1948;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 136);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 104);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  USSDServiceInterface::~USSDServiceInterface((USSDServiceInterface *)a1);
}

void sub_100246DF4(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x70uLL);
  sub_100246E68(v2);
  *a1 = v2 + 3;
  a1[1] = v2;

  sub_1000B3BC8((uint64_t)a1, v2 + 4, (uint64_t)(v2 + 3));
}

void sub_100246E54(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100246E68(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019AEAB8;
  ims::EmergencyCall::EmergencyCall();
  return a1;
}

void sub_100246EB0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100246EC4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AEAB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100246EE4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AEAB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100246F38(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100246F60(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AEB08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100246F80(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AEB08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100246FD4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100246FFC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10024707C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[7], v1, (dispatch_function_t)sub_100247154);
  __cxa_rethrow();
}

void sub_1002470A4(_Unwind_Exception *a1)
{
}

void sub_1002470BC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1002470F4(uint64_t a1)
{
}

uint64_t sub_100247110(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100247154(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *sub_100247180@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x30uLL);
  uint64_t result = sub_1002471DC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1002471C8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1002471DC(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019AEBB8;
  sub_1002472D4(a1 + 3, a2);
  return a1;
}

void sub_100247224(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100247238(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AEBB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100247258(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AEBB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002472AC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_1002472D4(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  *a1 = off_1019AEC08;
  a1[1] = v4;
  a1[2] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
  }
  return a1;
}

void *sub_100247334(void *a1)
{
  *a1 = off_1019AEC08;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100247380(void *a1)
{
  *a1 = off_1019AEC08;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

uint64_t sub_1002473EC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t sub_10024741C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_10024744C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

const void **sub_10024747C(const void **result, const void **a2)
{
  uint64_t v2 = result[1];
  if (v2)
  {
    sub_10012A394(&v3, a2);
    (*(void (**)(const void *, const void **))(*(void *)v2 + 40))(v2, &v3);
    return sub_10012577C(&v3);
  }
  return result;
}

void sub_1002474E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002474F8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t sub_100247528(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 56))();
  }
  return result;
}

uint64_t sub_100247558(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 64))();
  }
  return result;
}

uint64_t sub_100247588(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

uint64_t sub_1002475B8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 80))();
  }
  return result;
}

uint64_t sub_1002475E8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 88))();
  }
  return result;
}

uint64_t sub_100247618(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 96))();
  }
  return result;
}

uint64_t sub_100247648(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 104))();
  }
  return result;
}

uint64_t sub_100247678(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 112))();
  }
  return result;
}

uint64_t sub_1002476A8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 120))();
  }
  return result;
}

uint64_t sub_1002476D8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 128))();
  }
  return result;
}

uint64_t sub_100247708(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 136))();
  }
  return result;
}

uint64_t sub_100247738(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 144))();
  }
  return result;
}

uint64_t sub_100247768(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 152))();
  }
  return result;
}

uint64_t sub_100247798(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 160))();
  }
  return result;
}

uint64_t sub_1002477C8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 168))();
  }
  return result;
}

uint64_t sub_1002477F8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 176))();
  }
  return result;
}

uint64_t sub_100247828(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 184))();
  }
  return result;
}

uint64_t sub_100247858(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 192))();
  }
  return result;
}

const void **sub_100247888(const void **result, uint64_t a2, const void **a3, uint64_t a4)
{
  uint64_t v4 = result[1];
  if (v4)
  {
    sub_10012A394(&v7, a3);
    (*(void (**)(const void *, uint64_t, const void **, uint64_t))(*(void *)v4 + 200))(v4, a2, &v7, a4);
    return sub_10012577C(&v7);
  }
  return result;
}

void sub_10024790C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100247920(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 208))();
  }
  return result;
}

void sub_100247950(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v2 + 216))(&v4);
    sub_100245F0C((void **)a2);
    *(_OWORD *)a2 = v4;
    *(void *)(a2 + 16) = v5;
    uint64_t v5 = 0;
    long long v4 = 0uLL;
    long long v6 = (void **)&v4;
    sub_1002244D8(&v6);
  }
}

void sub_1002479E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_1002479F8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 224))();
  }
  return result;
}

uint64_t sub_100247A28(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 232))();
  }
  return result;
}

void sub_100247A58(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v2 + 240))(&v4);
    sub_100245F0C((void **)a2);
    *(_OWORD *)a2 = v4;
    *(void *)(a2 + 16) = v5;
    uint64_t v5 = 0;
    long long v4 = 0uLL;
    long long v6 = (void **)&v4;
    sub_1002244D8(&v6);
  }
}

void sub_100247AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_100247B00(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  sub_10012A394(&v7, a2);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, const void **, uint64_t))(*(void *)v3 + 248))(v3, &v7, a3);
  sub_10012577C(&v7);
  return v5;
}

void sub_100247B80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100247B94(const void **result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1];
  if (v3)
  {
    sub_100245B5C((uint64_t)v5, a2);
    (*(void (**)(const void *, unsigned char *, uint64_t))(*(void *)v3 + 256))(v3, v5, a3);
    return sub_1002243E8((uint64_t)v5);
  }
  return result;
}

void sub_100247C14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002243E8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100247C28(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 264))();
  }
  return result;
}

uint64_t sub_100247C60(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 272))();
  }
  return result;
}

void *sub_100247C98@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    return (void *)(*(uint64_t (**)(void))(*(void *)v2 + 280))();
  }
  else {
    return sub_100058DB0(a2, "");
  }
}

uint64_t sub_100247CDC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 288))();
  }
  return result;
}

uint64_t sub_100247D14(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 296))();
  }
  return result;
}

uint64_t sub_100247D4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 304))();
  }
  return result;
}

uint64_t sub_100247D84(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 312))();
  }
  return result;
}

uint64_t sub_100247DBC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 320))();
  }
  return result;
}

uint64_t sub_100247DF4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 328))();
  }
  return result;
}

uint64_t sub_100247E2C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 336))();
  }
  return result;
}

uint64_t sub_100247E64@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 344))();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t sub_100247EA4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 352))();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t sub_100247EE4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 360))();
  }
  return result;
}

void *sub_100247F1C@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  long long v4 = operator new(0x30uLL);
  uint64_t result = sub_100247F78(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100247F64(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100247F78(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019AEDA0;
  sub_100248070(a1 + 3, a2);
  return a1;
}

void sub_100247FC0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100247FD4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AEDA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100247FF4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AEDA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100248048(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_100248070(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  *a1 = off_1019AEDF0;
  a1[1] = v4;
  a1[2] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
  }
  return a1;
}

void *sub_1002480D0(void *a1)
{
  *a1 = off_1019AEDF0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10024811C(void *a1)
{
  *a1 = off_1019AEDF0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

uint64_t sub_100248188(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t sub_1002481B8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_1002481E8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t sub_100248218(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void *sub_100248248@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t result = sub_100248294(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_100248280(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100248294(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019AEE48;
  sub_100EC4D34((uint64_t)(a1 + 3));
  return a1;
}

void sub_1002482DC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1002482F0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AEE48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100248310(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AEE48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100248364(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100248390(RoamingInterface *a1)
{
  RoamingInterface::~RoamingInterface(a1);

  operator delete();
}

uint64_t sub_1002483C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1002483DC(a3, 0x2D00000001, 0);
}

uint64_t sub_1002483DC(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = a2;
  char v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

uint64_t sub_100248438(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100248450(a3, 0x2D00000001, 0, 0);
}

uint64_t sub_100248450(uint64_t a1, uint64_t a2, char a3, char a4)
{
  uint64_t v8 = a2;
  char v7 = a3;
  char v6 = a4;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, char *, char *))(*(void *)v4 + 48))(v4, &v8, &v7, &v6);
}

uint64_t sub_1002484B4()
{
  return 0;
}

uint64_t sub_1002484BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100060854(a4, 0x2D00000001);
}

uint64_t sub_1002484CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000607A8(a3, 0);
}

uint64_t sub_1002484DC()
{
  return 0;
}

uint64_t sub_1002484E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000607A8(a3, 0);
}

unint64_t sub_1002484F4()
{
  return 0xFFFFFFFF00000001;
}

void sub_1002484FC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void *sub_100248588(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_1019AEFE0;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_10024862C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100248648(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v7[0] = off_1019AF060;
  v7[1] = a3;
  v7[2] = &v6;
  v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v3);
  return sub_100043E48(v7);
}

void sub_1002486EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100248708(CTXPCVoicemailNotificationInterface *this)
{
  *(void *)this = off_1019AEF20;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCVoicemailNotificationInterface::~CTXPCVoicemailNotificationInterface(this);
}

void sub_100248764(CTXPCVoicemailNotificationInterface *this)
{
  *(void *)this = off_1019AEF20;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCVoicemailNotificationInterface::~CTXPCVoicemailNotificationInterface(this);

  operator delete();
}

void sub_1002487D4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10024883C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100248878(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002488B0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_1002488E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100248928()
{
}

void *sub_10024893C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019AEFE0;
  result[1] = v3;
  return result;
}

uint64_t sub_100248984(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019AEFE0;
  a2[1] = v2;
  return result;
}

void sub_1002489B0(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 voicemailDatabaseReset:v3];
}

void sub_100248A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100248A44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100248A84()
{
}

void sub_100248A94()
{
}

__n128 sub_100248AA8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019AF060;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100248AF4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019AF060;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100248B24(uint64_t a1, id *a2)
{
  id v8 = *a2;
  uint64_t v3 = objc_opt_new();
  id v4 = *(uint64_t **)(a1 + 8);
  if (*((char *)v4 + 23) < 0) {
    id v4 = (uint64_t *)*v4;
  }
  int v5 = +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v4, +[NSString defaultCStringEncoding]);
  [v3 setUrl:v5];

  [v3 setIsNetworkOriginated:*(unsigned __int8 *)(*(void *)(a1 + 8) + 25)];
  [v3 setAvailable:*(unsigned __int8 *)(*(void *)(a1 + 8) + 24)];
  int v6 = +[NSNumber numberWithInt:*(unsigned int *)(*(void *)(a1 + 8) + 28)];
  [v3 setCount:v6];

  [v3 setIsVoiceMailMWI:*(unsigned __int8 *)(*(void *)(a1 + 8) + 26)];
  char v7 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v8 voicemailInfoAvailableNotification:v7 voicemailInfo:v3];
}

void sub_100248C5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100248C90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100248CD0()
{
}

uint64_t sub_100248CE4(uint64_t a1)
{
  *(void *)a1 = off_1019AF0E0;
  sub_100248D7C(a1, 1);

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100057D78((const void **)(a1 + 56));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100248D7C(uint64_t a1, char a2)
{
  if (a2)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I user cancels proximity transfer", v4, 2u);
    }
    *(_DWORD *)(a1 + 120) = 0;
    sub_100249358(a1);
    sub_1002493D8(a1);
  }
  else
  {
    sub_1002492A0(a1, 0);
  }
}

void sub_100248E24(uint64_t a1)
{
  sub_100248CE4(a1);

  operator delete();
}

uint64_t sub_100248E5C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 120))
  {
    char v3 = 13;
  }
  else
  {
    if (*(void *)(a1 + 96))
    {
      int v5 = 1;
    }
    else
    {
      if ((ctu::RestModule::isConnected((ctu::RestModule *)(a1 + 80)) & 1) == 0)
      {
        (***(void (****)(Registry **__return_ptr))(a1 + 64))(&v30);
        Registry::createRestModuleOneTimeUseConnection(&v28, v30);
        ctu::RestModule::connect();
        if (v29) {
          sub_10004D2C8(v29);
        }
        if (v31) {
          sub_10004D2C8((std::__shared_weak_count *)v31);
        }
        int v6 = *(std::__shared_weak_count **)(a1 + 16);
        if (!v6 || (uint64_t v7 = *(void *)(a1 + 8), (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
          sub_100088B9C();
        }
        long long v9 = v8;
        atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v8);
        sub_100058DB0(__p, "/cc/events/app_state_changed");
        long long v10 = operator new(0x20uLL);
        void *v10 = off_1019AF518;
        v10[1] = a1;
        v10[2] = v7;
        v10[3] = v9;
        int v33 = v10;
        ctu::RestModule::observeEvent();
        sub_10003F600(&v30);
        if (SHIBYTE(v23) < 0) {
          operator delete(__p[0]);
        }
      }
      id v11 = objc_alloc_init((Class)off_101B09EA0());
      uint64_t v12 = *(void **)(a1 + 96);
      *(void *)(a1 + 96) = v11;

      [*(id *)(a1 + 96) setUseSecondTrigger:*(unsigned __int8 *)(a1 + 124)];
      [*(id *)(a1 + 96) setDispatchQueue:*(void *)(a1 + 24)];
      long long v13 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v13 || (v14 = *(void *)(a1 + 8), (uint64_t v15 = std::__shared_weak_count::lock(v13)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v16 = v15;
      p_shared_weak_owners = &v15->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v30 = (Registry *)_NSConcreteStackBlock;
      uint64_t v31 = 3321888768;
      long long v32 = sub_100249828;
      int v33 = &unk_1019AF128;
      uint64_t v34 = a1;
      uint64_t v35 = v14;
      __int16 v36 = v16;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      [*(id *)(a1 + 96) setEventHandler:&v30];
      long long v18 = *(void **)(a1 + 96);
      __p[0] = _NSConcreteStackBlock;
      __p[1] = (void *)3321888768;
      char v23 = sub_100249B60;
      uint64_t v24 = &unk_1019AF198;
      uint64_t v25 = a1;
      uint64_t v26 = v14;
      int v27 = v16;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      [v18 registerRequestID:@"CTProximityTransferRequestID" options:0 requestHandler:__p completionHandler:&stru_1019AF1C8];
      long long v19 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v21 = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I activate SKSetupSIMTransferServer", v21, 2u);
      }
      [*(id *)(a1 + 96) activate];
      if (v27) {
        std::__shared_weak_count::__release_weak(v27);
      }
      if (v36) {
        std::__shared_weak_count::__release_weak(v36);
      }
      std::__shared_weak_count::__release_weak(v16);
      int v5 = *(_DWORD *)(a1 + 120) + 1;
    }
    char v3 = 0;
    *(_DWORD *)(a1 + 120) = v5;
  }

  return sub_10024924C(a2, v3);
}

void sub_1002491A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10024924C(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48))(v2, &v4);
}

void sub_1002492A0(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 120);
  if (a2)
  {
    *(_DWORD *)(a1 + 120) = v3 + 1;
  }
  else if (v3)
  {
    int v4 = v3 - 1;
    *(_DWORD *)(a1 + 120) = v4;
    if (!v4)
    {
      sub_100249358(a1);
      sub_1002493D8(a1);
    }
  }
  else
  {
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "unbalance assertion", v6, 2u);
    }
  }
}

void sub_100249358(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 104) templateSession];
  [v2 invalidate];

  [*(id *)(a1 + 104) setTemplateSession:0];
  [*(id *)(a1 + 104) invalidate];
  int v3 = *(void **)(a1 + 104);
  *(void *)(a1 + 104) = 0;

  int v4 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = 0;
}

void sub_1002493C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002493D8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I invalidate SKSetupSIMTransferServer", v5, 2u);
  }
  [*(id *)(a1 + 96) invalidate];
  int v3 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = 0;

  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 80));
}

void sub_10024945C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected calls", v2, 2u);
  }
}

BOOL sub_1002494C0(uint64_t a1)
{
  return *(void *)(a1 + 96) != 0;
}

void sub_1002494D0(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v4 = *(void **)(a1 + 104);
  if (v4) {
    goto LABEL_18;
  }
  int v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(unsigned __int8 *)(a1 + 48);
    uint64_t v7 = "kUnknown";
    if (v6 == 1) {
      uint64_t v7 = "kSource";
    }
    if (v6 == 2) {
      id v8 = "kTarget";
    }
    else {
      id v8 = v7;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I start message server on %s", (uint8_t *)&buf, 0xCu);
  }
  id v9 = objc_alloc_init((Class)NSMutableDictionary);
  long long v10 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = v9;

  id v11 = objc_alloc_init((Class)CUMessageSessionServer);
  uint64_t v12 = *(void **)(a1 + 104);
  *(void *)(a1 + 104) = v11;

  [*(id *)(a1 + 104) setDispatchQueue:*(void *)(a1 + 24)];
  long long v13 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v13 || (v14 = *(void *)(a1 + 8), (uint64_t v15 = std::__shared_weak_count::lock(v13)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v16 = v15;
  p_shared_weak_owners = &v15->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3321888768;
  uint64_t v26 = sub_10024A03C;
  int v27 = &unk_1019AF1E8;
  uint64_t v28 = a1;
  uint64_t v29 = v14;
  char v30 = v16;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  [*(id *)(a1 + 104) setRegisterRequestHandler:&buf];
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3321888768;
  v23[2] = sub_10024A120;
  v23[3] = &unk_1019AF218;
  v23[4] = a1;
  v23[5] = v14;
  uint64_t v24 = v16;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  [*(id *)(a1 + 104) setSendRequestHandler:v23];
  long long v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v22 = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I activate CUMessageSessionServer", v22, 2u);
  }
  [*(id *)(a1 + 104) activate];
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  if (v30) {
    std::__shared_weak_count::__release_weak(v30);
  }
  std::__shared_weak_count::__release_weak(v16);
  int v4 = *(void **)(a1 + 104);
  if (v4)
  {
LABEL_18:
    *a2 = 0;
    a2[1] = 0;
    uint64_t v19 = [v4 templateSession];
    int v20 = operator new(0x20uLL);
    v20[1] = 0;
    _OWORD v20[2] = 0;
    *int v20 = off_1019AF4C8;
    void v20[3] = v19;
    *a2 = v20 + 3;
    a2[1] = v20;
  }
  else
  {
    char v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "invalid message server", (uint8_t *)&buf, 2u);
    }
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1002497DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (a23) {
    std::__shared_weak_count::__release_weak(a23);
  }
  std::__shared_weak_count::__release_weak(v23);
  _Unwind_Resume(a1);
}

void sub_100249828(void *a1, void *a2)
{
  id v13 = a2;
  int v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v4 = a1[4];
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      if (a1[5])
      {
        id v7 = v13;
        id v8 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v7;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I handle SKEvent : %@", buf, 0xCu);
        }
        id v9 = sub_1001DA7B0(v7);
        long long v10 = v9;
        int v22 = v9;
        if (v9) {
          CFRetain(v9);
        }
        *(_OWORD *)long long buf = 0uLL;
        (***(void (****)(Registry **__return_ptr))(v4 + 64))(&v18);
        Registry::getNotificationSenderFactory((uint64_t *)&v20, v18);
        id v11 = v20;
        (***(void (****)(Registry **__return_ptr))(v4 + 64))(&v14);
        Registry::getTimerService(&v16, v14);
        (*(void (**)(uint8_t *__return_ptr, const void *, uint64_t *, uint64_t))(*(void *)v11 + 160))(buf, v11, &v16, v4 + 24);
        if (v17) {
          sub_10004D2C8(v17);
        }
        if (v15) {
          sub_10004D2C8(v15);
        }
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v19) {
          sub_10004D2C8(v19);
        }
        uint64_t v12 = *(void *)buf;
        int v20 = v22;
        if (v22) {
          CFRetain(v22);
        }
        (*(void (**)(uint64_t, const void **))(*(void *)v12 + 32))(v12, &v20);
        sub_100057D78(&v20);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        sub_100057D78(&v22);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100249A80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100249B34(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100249B50(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100249B60(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (std::__shared_weak_count *)a1[6];
  if (!v13)
  {
    uint64_t v15 = 0;
    goto LABEL_8;
  }
  uint64_t v14 = a1[4];
  uint64_t v15 = std::__shared_weak_count::lock(v13);
  if (!v15 || !a1[5])
  {
LABEL_8:
    int v22 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:-6740 userInfo:0];
    (*((void (**)(id, void, void, void *, Block_layout *))v12 + 2))(v12, 0, 0, v22, &stru_1019AF178);

    if (!v15) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  id v26 = 0;
  id v27 = 0;
  sub_1001DA720(v10, (uint64_t *)&v26);
  id v16 = v27;
  id v17 = v26;
  id v25 = v16;
  id v18 = v11;
  id v19 = v12;
  if (v17)
  {
    int v20 = [*(id *)(v14 + 112) objectForKeyedSubscript:v17];
    if (v20)
    {
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472;
      uint64_t v29 = sub_10024A428;
      char v30 = &unk_1019AF2B0;
      id v31 = v19;
      ((void (**)(void, id, id, long long *))v20)[2](v20, v18, v25, &buf);
      char v21 = v31;
    }
    else
    {
      uint64_t v24 = *(NSObject **)(v14 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v17;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "missing handler for requestID : %@", (uint8_t *)&buf, 0xCu);
      }
      char v21 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:-6745 userInfo:0];
      (*((void (**)(id, void, void, void *, Block_layout *))v19 + 2))(v19, 0, 0, v21, &stru_1019AF268);
    }
  }
  else
  {
    char v23 = *(NSObject **)(v14 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "invalid requestID from remote", (uint8_t *)&buf, 2u);
    }
    int v20 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:-6705 userInfo:0];
    (*((void (**)(id, void, void, void (**)(void, void, void, void), Block_layout *))v19
     + 2))(v19, 0, 0, v20, &stru_1019AF248);
  }

LABEL_18:
  sub_10004D2C8(v15);
LABEL_19:
}

void sub_100249EA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

void sub_100249F54(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  if (v2)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "t.prx.tr.ctr");
    int v3 = *(NSObject **)&v5[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = 138412290;
      *(void *)int v5 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "register request CTRequest failed : %@", (uint8_t *)&v4, 0xCu);
    }
  }
}

void sub_10024A024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10024A03C(void *a1, void *a2, void *a3, void *a4)
{
  id v14 = a2;
  id v7 = a3;
  id v8 = a4;
  id v9 = (std::__shared_weak_count *)a1[6];
  if (v9)
  {
    uint64_t v10 = a1[4];
    id v11 = std::__shared_weak_count::lock(v9);
    if (v11)
    {
      id v12 = v11;
      if (a1[5])
      {
        id v13 = objc_retainBlock(v8);
        [*(id *)(v10 + 112) setObject:v13 forKeyedSubscript:v14];
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_10024A0F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void sub_10024A120(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v31 = a2;
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  id v12 = (std::__shared_weak_count *)a1[6];
  if (v12)
  {
    id v13 = (void *)a1[4];
    id v14 = std::__shared_weak_count::lock(v12);
    if (v14)
    {
      uint64_t v15 = v14;
      if (a1[5])
      {
        id v16 = v31;
        id v17 = v9;
        id v30 = v10;
        id v29 = v11;
        id v18 = v13[5];
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412802;
          *(void *)&uint8_t buf[4] = v16;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v17;
          *(_WORD *)&buf[22] = 2112;
          int v33 = v30;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I forward %@ opt:%@ req:%@", buf, 0x20u);
        }
        uint64_t v28 = v15;
        id v19 = (std::__shared_weak_count *)v13[2];
        id v27 = v16;
        if (!v19 || (uint64_t v20 = v13[1], (v21 = std::__shared_weak_count::lock(v19)) == 0)) {
          sub_100088B9C();
        }
        int v22 = v21;
        p_shared_weak_owners = &v21->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        uint64_t v24 = sub_1001DA62C(v16, v30);
        id v25 = (void *)v13[12];
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 3321888768;
        *(void *)&uint8_t buf[16] = sub_10024A5FC;
        int v33 = &unk_1019AF300;
        uint64_t v35 = v13;
        uint64_t v36 = v20;
        int v37 = v22;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        id v26 = v29;
        id v34 = v26;
        [v25 sendRequestID:@"CTProximityTransferRequestID" requestMessage:v24 options:v17 responseHandler:buf];

        uint64_t v15 = v28;
        if (v37) {
          std::__shared_weak_count::__release_weak(v37);
        }

        std::__shared_weak_count::__release_weak(v22);
      }
      sub_10004D2C8(v15);
    }
  }
}

void sub_10024A39C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, std::__shared_weak_count *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_weak(a22);
  }

  std::__shared_weak_count::__release_weak(v22);
  sub_10004D2C8(a10);

  _Unwind_Resume(a1);
}

void sub_10024A428(uint64_t a1, int a2, void *a3, void *a4)
{
  id v10 = a3;
  id v7 = a4;
  uint64_t v8 = *(void *)(a1 + 32);
  if (a2)
  {
    id v9 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:a2 userInfo:0];
  }
  else
  {
    id v9 = 0;
  }
  (*(void (**)(uint64_t, id, id, void *, Block_layout *))(v8 + 16))(v8, v7, v10, v9, &stru_1019AF288);
  if (a2) {
}
  }

void sub_10024A4EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10024A514(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  if (v2)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "t.prx.tr.ctr");
    int v3 = *(NSObject **)&v5[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = 138412290;
      *(void *)int v5 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "send response error : %@", (uint8_t *)&v4, 0xCu);
    }
  }
}

void sub_10024A5E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10024A5FC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = *(std::__shared_weak_count **)(a1 + 56);
  if (v10)
  {
    id v11 = *(void **)(a1 + 40);
    id v12 = std::__shared_weak_count::lock(v10);
    if (v12)
    {
      id v13 = v12;
      if (*(void *)(a1 + 48))
      {
        v21[0] = _NSConcreteStackBlock;
        v21[1] = 3221225472;
        v21[2] = sub_10024A7D4;
        v21[3] = &unk_1019AF2D8;
        id v25 = *(id *)(a1 + 32);
        id v22 = v9;
        id v23 = v8;
        id v24 = v7;
        id v14 = v21;
        uint64_t v15 = (std::__shared_weak_count *)v11[2];
        if (!v15 || (uint64_t v16 = v11[1], (v17 = std::__shared_weak_count::lock(v15)) == 0)) {
          sub_100088B9C();
        }
        id v18 = v17;
        id v19 = v11[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 3321888768;
        block[2] = sub_10024B204;
        block[3] = &unk_1019AF590;
        uint64_t v28 = v16;
        id v29 = v17;
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v20 = v14;
        id v27 = v20;
        dispatch_async(v19, block);

        if (v29) {
          sub_10004D2C8(v29);
        }
        sub_10004D2C8(v18);
      }
      sub_10004D2C8(v13);
    }
  }
}

uint64_t sub_10024A7D4(void *a1)
{
  uint64_t v2 = a1[7];
  uint64_t v3 = NSErrorToOSStatus();
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];
  int v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v2 + 16);

  return v6(v2, v3, v4, v5);
}

uint64_t sub_10024A824(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10024A840(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

Class sub_10024A850()
{
  if (qword_101B0CA10 != -1) {
    dispatch_once(&qword_101B0CA10, &stru_1019AF448);
  }
  Class result = objc_getClass("SKSetupSIMTransferServer");
  qword_101B0CA08 = (uint64_t)result;
  off_101B09EA0 = (uint64_t (*)(void))sub_10024A8B4;
  return result;
}

id sub_10024A8B4()
{
  return (id)qword_101B0CA08;
}

void sub_10024A8C0(id a1)
{
  qword_101B0C9F8 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/SetupKit.framework/SetupKit", 2);
}

void sub_10024A8EC(char *a1@<X1>, const void **a2@<X2>, NSObject **a3@<X3>, uint64_t *a4@<X4>, char *a5@<X5>, void *a6@<X8>)
{
  id v12 = operator new(0x98uLL);
  sub_10024A990(v12, a1, a2, a3, a4, a5);
  *a6 = v12 + 3;
  a6[1] = v12;

  sub_1000B3BC8((uint64_t)a6, v12 + 4, (uint64_t)(v12 + 3));
}

void sub_10024A97C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10024A990(void *a1, char *a2, const void **a3, NSObject **a4, uint64_t *a5, char *a6)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019AF478;
  sub_10024AA88((uint64_t)(a1 + 3), a2, a3, a4, a5, a6);
  return a1;
}

void sub_10024A9D8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10024A9EC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AF478;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10024AA0C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AF478;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10024AA60(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_10024AA88(uint64_t a1, char *a2, const void **a3, NSObject **a4, uint64_t *a5, char *a6)
{
  char v10 = *a2;
  sub_100058198(&v20, a3);
  id v11 = *a4;
  if (v11) {
    dispatch_retain(v11);
  }
  uint64_t v13 = *a5;
  id v12 = (std::__shared_weak_count *)a5[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v14 = *a6;
  *(void *)a1 = off_1019AF340;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), kCtLoggingSystemName, "t.prx.tr.ctr");
  *(void *)a1 = off_1019AF0E0;
  *(unsigned char *)(a1 + 48) = v10;
  sub_100058198((const void **)(a1 + 56), &v20);
  *(void *)(a1 + 64) = v13;
  *(void *)(a1 + 72) = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "CellularPlanTargetProximityTransportControllerImpl");
  dispatch_object_t v22 = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  uint64_t v15 = *(NSObject **)(a1 + 32);
  dispatch_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v22) {
    dispatch_release(v22);
  }
  if (v24 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(void *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 124) = v14;
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = *(unsigned __int8 *)(a1 + 48);
    id v18 = "kUnknown";
    if (v17 == 1) {
      id v18 = "kSource";
    }
    if (v17 == 2) {
      id v18 = "kTarget";
    }
    *(_DWORD *)long long buf = 136315394;
    id v26 = v18;
    __int16 v27 = 2112;
    uint64_t v28 = v20;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I create proximity transfer controller for : %s, remote device : %@", buf, 0x16u);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (v11) {
    dispatch_release(v11);
  }
  sub_100057D78(&v20);
  return a1;
}

void sub_10024ACFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (object) {
    dispatch_release(object);
  }
  if (a11) {
    dispatch_release(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  char v24 = *(std::__shared_weak_count **)(v18 + 72);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_100057D78(v22);
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v17) {
    dispatch_release(v17);
  }
  sub_100057D78((const void **)&a9);
  _Unwind_Resume(a1);
}

void sub_10024AD84(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AF4C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10024ADA4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AF4C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10024ADF8(uint64_t a1)
{
}

void *sub_10024AE04(void *a1)
{
  *a1 = off_1019AF518;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10024AE50(void *a1)
{
  *a1 = off_1019AF518;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10024AEBC(uint64_t a1)
{
  Class result = (char *)operator new(0x20uLL);
  *(void *)Class result = off_1019AF518;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10024AF20(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019AF518;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10024AF60(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10024AF70(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10024AFB0(void *a1)
{
  *(_OWORD *)std::string __p = 0u;
  long long v16 = 0u;
  rest::read_rest_value();
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (!v2) {
    goto LABEL_36;
  }
  uint64_t v3 = a1[1];
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    goto LABEL_36;
  }
  uint64_t v5 = v4;
  if (a1[2])
  {
    uint64_t v6 = HIBYTE(v16);
    if (v16 < 0) {
      uint64_t v6 = v16;
    }
    if (v6 == 21)
    {
      if (v16 >= 0) {
        id v7 = &__p[1];
      }
      else {
        id v7 = (void **)__p[1];
      }
      if (*v7 != (void *)0x6C7070612E6D6F63
        || v7[1] != (void *)0x7265666572502E65
        || *(void **)((char *)v7 + 13) != (void *)0x7365636E65726566)
      {
        if (*v7 != (void *)0x6C7070612E6D6F63
          || v7[1] != (void *)0x656C707275702E65
          || *(void **)((char *)v7 + 13) != (void *)0x7964647562656C70
          || LODWORD(__p[0]) != 1)
        {
          goto LABEL_35;
        }
LABEL_32:
        char v14 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315394;
          uint64_t v18 = v7;
          __int16 v19 = 1024;
          int v20 = HIDWORD(__p[0]);
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%s [%d] terminated. reset", buf, 0x12u);
        }
        sub_100248D7C(v3, 1);
        goto LABEL_35;
      }
      if (LODWORD(__p[0]) == 1) {
        goto LABEL_32;
      }
    }
  }
LABEL_35:
  sub_10004D2C8(v5);
LABEL_36:
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[1]);
  }
}

void sub_10024B18C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10024B1B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10024B1F8()
{
}

uint64_t sub_10024B204(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10024B214(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10024B230(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10024B240()
{
}

uint64_t sub_10024B268@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = capabilities::ct::getRadioModuleType(a1);
  if (result == 2)
  {
    uint64_t result = capabilities::ct::shouldEnableDesense((capabilities::ct *)result);
    if (result)
    {
      v5[0] = off_1019AF6F0;
      v5[3] = v5;
      inactive = dispatch_workloop_create_inactive("DesenseController");
      sub_100136200((uint64_t)v5, (uint64_t)inactive);
      dispatch_activate(inactive);
      sub_1001362D0(v5);
      *a2 = 0;
      a2[1] = 0;
      operator new();
    }
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void sub_10024B844(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, dispatch_object_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
}

const char *sub_10024BB50(int a1)
{
  uint64_t v1 = "dese.?";
  if (a1 == 2) {
    uint64_t v1 = "dese.2";
  }
  if (a1 == 1) {
    return "dese.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_10024BB7C(uint64_t a1)
{
  return a1;
}

uint64_t sub_10024BBB4(uint64_t a1)
{
  *(void *)a1 = off_1019AF5D0;
  uint64_t v2 = *(void *)(a1 + 216);
  *(void *)(a1 + 216) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 192);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 176);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 160);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_10024D0B4(*(void **)(a1 + 136));
  sub_10024D10C(a1 + 104, *(void **)(a1 + 112));
  id v9 = (void **)(a1 + 80);
  sub_10024D16C(&v9);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 64);
  if (v6) {
    sub_10004D2C8(v6);
  }
  DesenseInterface::~DesenseInterface((DesenseInterface *)a1);
  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10024BCD4(uint64_t a1)
{
  sub_10024BBB4(a1);

  operator delete();
}

void sub_10024BD0C(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10024BE0C(void **a1)
{
  uint64_t v1 = (*a1)[2];
  if (v1)
  {
    uint64_t v3 = (uint64_t)a1[2];
    __chkstk_darwin();
    uint64_t v5 = (char *)&v13 - v4;
    bzero((char *)&v13 - v4, v4);
    uint64_t v6 = (uint64_t)(*a1 + 1);
    uint64_t v7 = (void *)**a1;
    if (v7 != (void *)v6)
    {
      uint64_t v8 = 0;
      do
      {
        id v9 = &v5[16 * v8];
        *(void *)id v9 = v7[4];
        *((void *)v9 + 1) = v7[5];
        char v10 = (void *)v7[1];
        if (v10)
        {
          do
          {
            id v11 = v10;
            char v10 = (void *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            id v11 = (void *)v7[2];
            BOOL v12 = *v11 == (void)v7;
            uint64_t v7 = v11;
          }
          while (!v12);
        }
        ++v8;
        uint64_t v7 = v11;
      }
      while (v11 != (void *)v6);
    }
    sub_10024C494(v3, v1);
  }
}

void sub_10024BF2C(void **a1)
{
  uint64_t v1 = (*a1)[2];
  if (v1)
  {
    uint64_t v3 = (uint64_t)a1[2];
    __chkstk_darwin();
    uint64_t v5 = (char *)&v13 - v4;
    bzero((char *)&v13 - v4, v4);
    uint64_t v6 = (uint64_t)(*a1 + 1);
    uint64_t v7 = (void *)**a1;
    if (v7 != (void *)v6)
    {
      uint64_t v8 = 0;
      do
      {
        id v9 = &v5[16 * v8];
        *(void *)id v9 = v7[4];
        *((void *)v9 + 1) = v7[5];
        char v10 = (void *)v7[1];
        if (v10)
        {
          do
          {
            id v11 = v10;
            char v10 = (void *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            id v11 = (void *)v7[2];
            BOOL v12 = *v11 == (void)v7;
            uint64_t v7 = v11;
          }
          while (!v12);
        }
        ++v8;
        uint64_t v7 = v11;
      }
      while (v11 != (void *)v6);
    }
    sub_10024C640(v3, v1);
  }
}

void sub_10024C04C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10024C13C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)size_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Enable cellular frequency reporting", v4, 2u);
  }
  return sub_10024C1AC(a1, 1);
}

uint64_t sub_10024C1AC(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 73) = a2 != 2;
  uint64_t result = subscriber::makeSimSlotRange();
  uint64_t v5 = v7;
  if (v7 != v8)
  {
    while (1)
    {
      uint64_t result = v9(*v5);
      if (result) {
        break;
      }
      if (++v5 == v8)
      {
        uint64_t v5 = v8;
        break;
      }
    }
LABEL_5:
    while (v5 != v8)
    {
      uint64_t v6 = v5 + 1;
      uint64_t result = (*(uint64_t (**)(void, void, uint64_t))(**(void **)(a1 + 152) + 24))(*(void *)(a1 + 152), *v5, a2);
      uint64_t v5 = v8;
      if (v6 != v8)
      {
        uint64_t v5 = v6;
        while (1)
        {
          uint64_t result = v9(*v5);
          if (result) {
            break;
          }
          if (++v5 == v8)
          {
            uint64_t v5 = v8;
            goto LABEL_5;
          }
        }
      }
    }
  }
  return result;
}

void sub_10024C2A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10024C388(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10024C494(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 184);
    if (v3)
    {
      size_t v4 = *(void (**)(void))(*(void *)v3 + 24);
      v4();
    }
    else
    {
      uint64_t v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t v6 = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Baseband Controller is not set", v6, 2u);
      }
    }
  }
}

void sub_10024C548(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10024C640(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 184);
    if (v3)
    {
      size_t v4 = *(void (**)(void))(*(void *)v3 + 32);
      v4();
    }
    else
    {
      uint64_t v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t v6 = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Baseband Controller is not set", v6, 2u);
      }
    }
  }
}

void sub_10024C6F4(void *a1, unsigned int a2)
{
  uint64_t v2 = a1[10];
  if (0xAAAAAAAAAAAAAAABLL * ((a1[11] - v2) >> 3) > a2)
  {
    uint64_t v5 = a1[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = desenseClientAsString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Clearing frequencies reported by %s", (uint8_t *)&buf, 0xCu);
      uint64_t v2 = a1[10];
    }
    long long buf = 0uLL;
    uint64_t v12 = 0;
    sub_10024EEAC((uint64_t *)&buf, v2 + 24 * a2);
    uint64_t v6 = (_OWORD *)buf;
    if ((long long *)buf != (long long *)((char *)&buf + 8))
    {
      do
      {
        sub_10024C640((uint64_t)a1, 1);
        uint64_t v7 = (void *)*((void *)v6 + 1);
        if (v7)
        {
          do
          {
            uint64_t v8 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v8 = (_OWORD *)*((void *)v6 + 2);
            BOOL v9 = *(void *)v8 == (void)v6;
            uint64_t v6 = v8;
          }
          while (!v9);
        }
        uint64_t v6 = v8;
      }
      while (v8 != (long long *)((char *)&buf + 8));
    }
    uint64_t v10 = a1[10] + 24 * a2;
    sub_1000346F8(v10, *(void **)(v10 + 8));
    *(void *)uint64_t v10 = v10 + 8;
    *(void *)(v10 + 16) = 0;
    *(void *)(v10 + 8) = 0;
    sub_1000346F8((uint64_t)&buf, *((void **)&buf + 1));
  }
}

void sub_10024C884(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12)
{
}

void sub_10024C8A4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Clearing frequencies reported by all clients", buf, 2u);
  }
  sub_100BAD9EC((void *)(a1 + 80));
  sub_10024D10C(a1 + 104, *(void **)(a1 + 112));
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  uint64_t v3 = *(void *)(a1 + 184);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
  }
  else
  {
    size_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Baseband Controller is not set", v5, 2u);
    }
  }
}

void sub_10024C998(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10024CA98(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10024CB98(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10024CC88(uint64_t a1, uint64_t a2)
{
  if ((operator==() & 1) == 0)
  {
    int v4 = *(_DWORD *)(a1 + 200);
    if (*(_DWORD *)a2 == v4)
    {
      int v5 = *(unsigned __int8 *)(a2 + 4);
      int v6 = *(unsigned __int8 *)(a1 + 204);
      if (v5 == v6) {
        return;
      }
      uint64_t v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = "true";
        if (v5) {
          BOOL v9 = "true";
        }
        else {
          BOOL v9 = "false";
        }
        if (!v6) {
          uint64_t v8 = "false";
        }
        int v11 = 136315394;
        uint64_t v12 = (uint64_t)v9;
        __int16 v13 = 2080;
        uint64_t v14 = (uint64_t)v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Radio in reset changing from %s to %s", (uint8_t *)&v11, 0x16u);
        int v6 = *(unsigned __int8 *)(a1 + 204);
      }
      if (!v6)
      {
LABEL_17:
        sub_10024C13C(a1);
        return;
      }
LABEL_19:
      (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
      return;
    }
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 136315394;
      uint64_t v12 = asString();
      __int16 v13 = 2080;
      uint64_t v14 = asString();
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Radio mode changed from %s to %s", (uint8_t *)&v11, 0x16u);
      int v4 = *(_DWORD *)(a1 + 200);
    }
    if (v4)
    {
      if (v4 != 2) {
        return;
      }
      goto LABEL_17;
    }
    if (!*(unsigned char *)(a1 + 208)) {
      goto LABEL_19;
    }
  }
}

void sub_10024CE4C(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 208);
  if (v2 != a2)
  {
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = "false";
      if (a2) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      if (v2) {
        int v6 = "true";
      }
      int v8 = 136315394;
      BOOL v9 = v7;
      __int16 v10 = 2080;
      int v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Airplane mode has changed from %s to %s", (uint8_t *)&v8, 0x16u);
      int v2 = *(unsigned __int8 *)(a1 + 208);
    }
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    }
  }
}

void sub_10024CF5C(uint64_t a1)
{
  memset(&__p, 0, sizeof(__p));
  sub_100BADDD0((void *)(a1 + 80), &__p);
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 72)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Block frequency report:      %s", buf, 0xCu);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 73)) {
      int v4 = "true";
    }
    else {
      int v4 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Frequency reporting enabled: %s", buf, 0xCu);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_10024D098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10024D0B4(void *a1)
{
  if (a1)
  {
    sub_10024D0B4(*a1);
    sub_10024D0B4(a1[1]);
    sub_1000346F8((uint64_t)(a1 + 5), (void *)a1[6]);
    operator delete(a1);
  }
}

void sub_10024D10C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10024D10C(a1, *a2);
    sub_10024D10C(a1, a2[1]);
    sub_1000346F8((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }
}

void sub_10024D16C(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (char *)**a1;
  if (v2)
  {
    int v4 = (char *)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        int v6 = v4 - 24;
        sub_1000346F8((uint64_t)(v4 - 24), *((void **)v4 - 2));
        int v4 = v6;
      }
      while (v6 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10024D1FC()
{
}

void *sub_10024D210()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019AF6F0;
  return result;
}

void sub_10024D248(uint64_t a1, void *a2)
{
  *a2 = off_1019AF6F0;
}

void sub_10024D270(uint64_t a1, dispatch_workloop_t *a2)
{
}

uint64_t sub_10024D27C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10024D2BC()
{
}

void sub_10024D2CC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10024D304(uint64_t a1)
{
}

uint64_t sub_10024D320(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10024D364(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10024D390(ServiceManager::Service *this)
{
  *(void *)this = off_1019AF7D0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10024D3EC(ServiceManager::Service *this)
{
  *(void *)this = off_1019AF7D0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10024D45C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "DesenseController");
}

unsigned char *sub_10024D46C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v2 = operator new(1uLL);
  *a1 = v2;
  *int v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10024D4AC(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10024BD0C(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_10024BD0C(v4, 0);
}

uint64_t sub_10024D530()
{
  return 0;
}

uint64_t sub_10024D538()
{
  return 1;
}

uint64_t sub_10024D540()
{
  return 0;
}

void sub_10024D54C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10024D62C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10024D744()
{
}

void *sub_10024D758(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019AF850;
  result[1] = v3;
  return result;
}

uint64_t sub_10024D7A0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019AF850;
  a2[1] = v2;
  return result;
}

uint64_t sub_10024D7CC(uint64_t a1, unsigned int *a2)
{
  return (*(uint64_t (**)(void))(a1 + 8))(*a2);
}

uint64_t sub_10024D7D8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019AF8C0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10024D818()
{
  return &off_1019AF8C0;
}

void sub_10024D828()
{
}

uint64_t sub_10024D83C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_10024D848(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  int v8 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  sub_10024C8A4(v2);
  uint64_t v4 = *(void *)(v2 + 152);
  int v5 = v1[1];
  *(void *)long long buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 40))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 168));
  sub_100088C88((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_10024D940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10024D97C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  char v21 = a1;
  dispatch_object_t v22 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 216);
  int v5 = *(NSObject **)(v2 + 32);
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  (*(void (**)(uint8_t *__return_ptr, uint64_t, dispatch_object_t *))(*(void *)v4 + 16))(buf, v4, &object);
  long long v6 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  uint64_t v7 = *(std::__shared_weak_count **)(v2 + 192);
  *(_OWORD *)(v2 + 184) = v6;
  if (v7)
  {
    sub_10004D2C8(v7);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if (object) {
    dispatch_release(object);
  }
  if (!*(void *)(v2 + 184))
  {
    int v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "Failed to create Baseband Controller", buf, 2u);
    }
  }
  sub_10024C8A4(v2);
  *(_WORD *)(v2 + 72) = 0;
  BOOL v9 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v9 || (v10 = *(void *)(v2 + 8), (int v11 = std::__shared_weak_count::lock(v9)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v12 = v11;
  __int16 v13 = (std::__shared_weak_count *)operator new(0x30uLL);
  v13->__shared_owners_ = 0;
  v13->__shared_weak_owners_ = 0;
  v13->__vftable = (std::__shared_weak_count_vtbl *)off_1019AF930;
  v13[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019AF9F8;
  v13[1].__shared_owners_ = v10;
  v13[1].__shared_weak_owners_ = (uint64_t)v12;
  atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  v13[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019AF980;
  uint64_t v14 = *(void *)(v2 + 152);
  id v25 = v13 + 1;
  id v26 = v13;
  xpc_object_t v15 = xpc_null_create();
  long long v16 = v1[1];
  dispatch_group_t group = v16;
  xpc_object_t v24 = v15;
  if (v16)
  {
    dispatch_retain(v16);
    dispatch_group_enter(v16);
  }
  (*(void (**)(uint64_t, std::__shared_weak_count **, xpc_object_t *, dispatch_group_t *))(*(void *)v14 + 48))(v14, &v25, &v24, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  xpc_release(v24);
  xpc_object_t v24 = 0;
  if (v26) {
    sub_10004D2C8(v26);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  int v17 = operator new(0x20uLL);
  void *v17 = off_1019AFA40;
  v17[1] = v2;
  v17[2] = sub_10024CF5C;
  v17[3] = 0;
  id v31 = v17;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/radio_mode");
  uint64_t v18 = operator new(0x28uLL);
  void *v18 = off_1019AFAC0;
  v18[1] = v2 + 200;
  _OWORD v18[2] = v2;
  void v18[3] = sub_10024CC88;
  v18[4] = 0;
  id v31 = v18;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/airplane_mode");
  __int16 v19 = operator new(0x28uLL);
  *__int16 v19 = off_1019AFB40;
  v19[1] = v2 + 208;
  _OWORD v19[2] = v2;
  void v19[3] = sub_10024CE4C;
  _OWORD v19[4] = 0;
  id v31 = v19;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)buf, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  sub_100088C88((uint64_t *)&v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_10024DDBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group, xpc_object_t object, uint64_t a13, uint64_t a14, dispatch_object_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,std::__shared_weak_count *a23)
{
  if (a23) {
    sub_10004D2C8(a23);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10024DE90(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019AF930;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10024DEB0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019AF930;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10024DF04(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10024DF2C(DesenseCommandDriverDelegateInterface *this)
{
  *(void *)this = off_1019AF9F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  DesenseCommandDriverDelegateInterface::~DesenseCommandDriverDelegateInterface(this);
}

void sub_10024DF88(DesenseCommandDriverDelegateInterface *this)
{
  *(void *)this = off_1019AF9F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  DesenseCommandDriverDelegateInterface::~DesenseCommandDriverDelegateInterface(this);

  operator delete();
}

void sub_10024DFF8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      int v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), a2);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = "not ready";
          if (a3) {
            int v11 = "ready";
          }
          int v12 = 136315138;
          __int16 v13 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Driver is %s", (uint8_t *)&v12, 0xCu);
        }
        if (a3) {
          (*(void (**)(void, uint64_t))(**(void **)(v9 + 152) + 16))(*(void *)(v9 + 152), a2);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10024E180(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10024E194(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      long long v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        int v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v7 + 48) + 16))(*(void *)(v7 + 48), a2);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = 136315138;
          uint64_t v10 = asString();
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Driver error: %s", (uint8_t *)&v9, 0xCu);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10024E2D0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10024E2E4(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      int v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        sub_10024EEAC(v14, a3);
        if (subscriber::isValidSimSlot())
        {
          if (!*(unsigned char *)(v9 + 72) && *(unsigned char *)(v9 + 73))
          {
            sub_100BDDC9C((uint64_t **)(v9 + 104), a2, v14);
            long long buf = 0uLL;
            uint64_t v27 = 0;
            sub_100BDDCF4((void *)(v9 + 104), (uint64_t *)&buf);
            v25[0] = 0;
            v25[1] = 0;
            v23[1] = 0;
            xpc_object_t v24 = (uint64_t *)v25;
            dispatch_object_t v22 = (uint64_t *)v23;
            v23[0] = 0;
            v21[0] = &v22;
            v21[1] = (void *)a2;
            v21[2] = (void *)v9;
            v20[0] = &v24;
            v20[1] = (void *)a2;
            _OWORD v20[2] = (void *)v9;
            uint64_t v11 = *(void *)(v9 + 80);
            uint64_t v10 = (uint64_t *)(v9 + 80);
            if (*(void *)(v11 + 16))
            {
              sub_10024EEAC((uint64_t *)&v18, (uint64_t)&buf);
              sub_100BADE40(v10, 0, &v24, (uint64_t)&v18);
              sub_1000346F8((uint64_t)&v18, v19);
              sub_10024EEAC(v17, (uint64_t)&buf);
              sub_100BADF38(v10, 0, &v22, v17);
              sub_1000346F8((uint64_t)v17, (void *)v17[1]);
              sub_10024EEAC((uint64_t *)&v15, (uint64_t)&buf);
              if ((void **)*v10 != &v15) {
                sub_10024F01C((uint64_t **)*v10, v15, &v16);
              }
              sub_1000346F8((uint64_t)&v15, v16);
              sub_10024BF2C(v20);
            }
            else
            {
              sub_10024EEAC((uint64_t *)&v18, (uint64_t)&buf);
              if ((void **)*v10 != &v18) {
                sub_10024F01C((uint64_t **)*v10, v18, &v19);
              }
              sub_1000346F8((uint64_t)&v18, v19);
              sub_10024F01C(&v22, (void *)buf, (void *)&buf + 1);
            }
            sub_10024BE0C(v21);
            sub_1000346F8((uint64_t)&v22, v23[0]);
            sub_1000346F8((uint64_t)&v24, v25[0]);
            sub_1000346F8((uint64_t)&buf, *((void **)&buf + 1));
          }
        }
        else
        {
          int v12 = *(NSObject **)(v9 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            uint64_t v13 = subscriber::asString();
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v13;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid sim slot(%s)", (uint8_t *)&buf, 0xCu);
          }
        }
        sub_1000346F8((uint64_t)v14, (void *)v14[1]);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10024E580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *a19)
{
  sub_1000346F8((uint64_t)&a18, a19);
  sub_1000346F8(v20 - 128, *(void **)(v20 - 120));
  sub_1000346F8(v20 - 104, *(void **)(v20 - 96));
  sub_1000346F8(v20 - 80, *(void **)(v20 - 72));
  sub_1000346F8((uint64_t)&a9, a10);
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

void sub_10024E60C(uint64_t a1, int a2, unint64_t a3, unsigned int a4)
{
  int v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        if (subscriber::isValidSimSlot())
        {
          if (*(unsigned char *)(v11 + 73)) {
            sub_100BDDDE0(v11 + 104, a2, a3, a4);
          }
        }
        else
        {
          int v12 = *(NSObject **)(v11 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            int v13 = 136315138;
            uint64_t v14 = subscriber::asString();
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid sim slot(%s)", (uint8_t *)&v13, 0xCu);
          }
        }
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_10024E760(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10024E774(uint64_t a1, int a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      long long v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        if (subscriber::isValidSimSlot())
        {
          if (*(unsigned char *)(v7 + 73)) {
            sub_100BDE234(v7 + 104, a2);
          }
        }
        else
        {
          int v8 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            int v9 = 136315138;
            uint64_t v10 = subscriber::asString();
            _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid sim slot(%s)", (uint8_t *)&v9, 0xCu);
          }
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10024E8AC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10024E8C0(DesenseCommandDriverDelegateInterface *this)
{
  *(void *)this = off_1019AF9F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  DesenseCommandDriverDelegateInterface::~DesenseCommandDriverDelegateInterface(this);
}

void sub_10024E91C(DesenseCommandDriverDelegateInterface *this)
{
  *(void *)this = off_1019AF9F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  DesenseCommandDriverDelegateInterface::~DesenseCommandDriverDelegateInterface(this);

  operator delete();
}

void sub_10024E990()
{
}

__n128 sub_10024E9A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019AFA40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10024E9F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019AFA40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10024EA30(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10024EA78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10024EAB8()
{
}

void sub_10024EAC8()
{
}

__n128 sub_10024EADC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019AFAC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10024EB30(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019AFAC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10024EB68(uint64_t a1)
{
  uint64_t v6 = **(void **)(a1 + 8);
  read_rest_value();
  uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = (void *)(*(void *)(a1 + 16) + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_10024EBEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10024EC2C()
{
}

void sub_10024EC3C()
{
}

__n128 sub_10024EC50(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019AFB40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10024ECA4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019AFB40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10024ECDC(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_10024ED78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10024EDB8()
{
}

void sub_10024EDC4(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v1 + 152) + 32))(*(void *)(v1 + 152));
  operator delete();
}

void sub_10024EE80()
{
}

uint64_t *sub_10024EEAC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10024EF04(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_10024EEEC(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_10024EF04(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    int v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      __n128 result = sub_10024EF90(v5, v6, v4 + 4, (_OWORD *)v4 + 2);
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          int v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_10024EF90(uint64_t **a1, void *a2, unint64_t *a3, _OWORD *a4)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v6 = (void **)sub_100103C48(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_100046C38(a1, v11, v8, v7);
  }
  return v7;
}

uint64_t **sub_10024F01C(uint64_t **result, void *a2, void *a3)
{
  int v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    void *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      int v8 = (uint64_t *)v6[1];
    }
    else {
      int v8 = v6;
    }
    uint64_t v14 = result;
    xpc_object_t v15 = v8;
    long long v16 = v8;
    if (v8)
    {
      xpc_object_t v15 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        BOOL v9 = a2;
        do
        {
          void v8[4] = v9[4];
          v8[5] = v9[5];
          sub_10024F188(v5, v8);
          int v8 = v15;
          long long v16 = v15;
          if (v15) {
            xpc_object_t v15 = sub_1000EA590((uint64_t)v15);
          }
          uint64_t v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              uint64_t v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              BOOL v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          BOOL v9 = a2;
        }
        while (a2 != a3);
      }
    }
    __n128 result = (uint64_t **)sub_1001A09B4((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      __n128 result = (uint64_t **)sub_10024F1F8(v5, (_OWORD *)a2 + 2);
      int v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          int v13 = v12;
          int v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          int v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_10024F174(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001A09B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10024F188(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = a1 + 1;
  uint64_t v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = (uint64_t **)v4;
        if (a2[4] >= (unint64_t)v4[4]) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v4;
        int v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      uint64_t v4 = (uint64_t *)v4[1];
    }
    while (v4);
    int v5 = v3 + 1;
  }
  else
  {
    int v5 = a1 + 1;
  }
LABEL_8:
  sub_100046C38(a1, (uint64_t)v3, v5, a2);
  return a2;
}

_OWORD *sub_10024F1F8(uint64_t **a1, _OWORD *a2)
{
  uint64_t v4 = operator new(0x30uLL);
  int v5 = v4;
  void v4[2] = *a2;
  uint64_t v6 = a1 + 1;
  uint64_t v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v7;
        if (*((void *)v4 + 4) >= (unint64_t)v7[4]) {
          break;
        }
        uint64_t v7 = (uint64_t *)*v7;
        int v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      uint64_t v7 = (uint64_t *)v7[1];
    }
    while (v7);
    int v8 = v6 + 1;
  }
  else
  {
    int v8 = a1 + 1;
  }
LABEL_8:
  sub_100046C38(a1, (uint64_t)v6, v8, (uint64_t *)v4);
  return v5;
}

void sub_10024F290(void ***a1)
{
  uint64_t v1 = a1;
  sub_10024C6F4(**a1, *((_DWORD *)*a1 + 2));
  operator delete();
}

void sub_10024F2E8()
{
}

void sub_10024F314(void ***a1)
{
  int v5 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = v1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Disable cellular frequency reporting", buf, 2u);
  }
  sub_10024C1AC((uint64_t)v1, 2);
  sub_10024C6F4(v1, 0);
  uint64_t v4 = (void *)v1[14];
  uint64_t v3 = v1 + 14;
  sub_10024D10C((uint64_t)(v3 - 1), v4);
  *(v3 - 1) = v3;
  *uint64_t v3 = 0;
  v3[1] = 0;
  operator delete();
}

void sub_10024F3D4()
{
}

void sub_10024F400(uint64_t **a1)
{
  uint64_t v6 = a1;
  uint64_t v1 = *a1;
  unint64_t v3 = *((unsigned int *)*a1 + 2);
  uint64_t v2 = **a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v2 + 88) - *(void *)(v2 + 80)) >> 3) > v3)
  {
    unint64_t v4 = v1[2];
    unsigned int v5 = *((_DWORD *)v1 + 6);
    if (sub_100BAD92C((void *)(v2 + 80), v3, v4, v5, 0))
    {
      unint64_t v7 = v4;
      unsigned int v8 = v5;
      int v9 = 0;
      sub_10024C494(v2, 1);
    }
  }
  operator delete();
}

void sub_10024F4B8()
{
}

void sub_10024F4E4(uint64_t **a1)
{
  unsigned int v5 = a1;
  uint64_t v1 = **a1;
  unint64_t v2 = *((unsigned int *)*a1 + 2);
  uint64_t v3 = *(void *)(v1 + 80);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v1 + 88) - v3) >> 3) > v2)
  {
    unint64_t v4 = (*a1)[2];
    v6[0] = v4;
    if (sub_100BAE340(v3 + 24 * v2, v6))
    {
      v6[0] = v4;
      v6[1] = 0;
      sub_10024C640(v1, 1);
    }
  }
  operator delete();
}

void sub_10024F590()
{
}

uint64_t *sub_10024F5BC(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v10 = a1;
  BOOL v11 = v1;
  uint64_t v2 = *v1;
  unint64_t v4 = (uint64_t *)(*v1 + 80);
  uint64_t v3 = *v4;
  memset(&string, 0, sizeof(string));
  uint64_t v5 = *(void *)(v2 + 88);
  if (v3 == v5)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    do
    {
      v6 += *(void *)(v3 + 16);
      v3 += 24;
    }
    while (v3 != v5);
  }
  unint64_t v7 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Current count of frequencies is %lu", (uint8_t *)&buf, 0xCu);
  }
  if (v6)
  {
    sub_10003ECB8(&string, "Frequency \t Bandwidth \t Priority:\n", 0x22uLL);
    sub_100BADDD0(v4, &string);
    if ((string.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string string = &string;
    }
    else {
      p_std::string string = (std::string *)string.__r_.__value_.__r.__words[0];
    }
  }
  else
  {
    p_std::string string = &string;
  }
  xpc_object_t v12 = xpc_string_create((const char *)p_string);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  *(void *)&long long buf = v1[1];
  *((void *)&buf + 1) = "kRegistrationVictimFreq";
  sub_100035E70((uint64_t)&buf, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  if (SHIBYTE(string.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(string.__r_.__value_.__l.__data_);
  }
  sub_10024F798((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_10024F750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10024F798(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_10024F7EC(uint64_t **a1)
{
  uint64_t v14 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v5 = *(void *)(v2 + 136);
  uint64_t v3 = v2 + 136;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = *(_DWORD *)(v4 + 32);
    BOOL v8 = v7 < 1;
    if (v7 >= 1) {
      int v9 = (uint64_t *)v4;
    }
    else {
      int v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v3 && *(int *)(v6 + 32) <= 1)
  {
    uint64_t v13 = *(void *)(v6 + 40);
    uint64_t v10 = *(void *)(v13 + 32);
    int64_t v11 = *(unsigned int *)(v13 + 40);
  }
  else
  {
LABEL_11:
    uint64_t v10 = 0;
    int64_t v11 = 0;
  }
  xpc_object_t v19 = xpc_uint64_create(v10);
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  uint64_t v17 = v1[1];
  uint64_t v18 = "kRegistrationUplinkFreq";
  sub_100035E70((uint64_t)&v17, &v19, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  xpc_object_t v15 = xpc_int64_create(v11);
  if (!v15) {
    xpc_object_t v15 = xpc_null_create();
  }
  uint64_t v17 = v1[1];
  uint64_t v18 = "kRegistrationBandwidth";
  sub_100035E70((uint64_t)&v17, &v15, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v15);
  xpc_object_t v12 = (std::__shared_weak_count *)v1[2];
  if (v12) {
    sub_10004D2C8(v12);
  }
  operator delete();
}

void sub_10024F954(uint64_t a1)
{
  uint64_t v1 = a1;
  *(unsigned char *)(**(void **)a1 + 72) = *(unsigned char *)(*(void *)a1 + 8);
  operator delete();
}

uint64_t sub_10024F9A0(uint64_t a1, void *a2, int a3)
{
  uint64_t v6 = "msim.vol.?";
  if (a3 == 2) {
    uint64_t v6 = "msim.vol.2";
  }
  if (a3 == 1) {
    int v7 = "msim.vol.1";
  }
  else {
    int v7 = v6;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v10, kCtLoggingSystemName, v7);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v10);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
  *(void *)(a1 + 8) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 16) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 24) = a3;
  *(unsigned char *)(a1 + 28) = 0;
  return a1;
}

void sub_10024FA68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void sub_10024FA8C(ctu::OsLogLogger *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ctu::OsLogLogger::~OsLogLogger(this);
}

BOOL sub_10024FACC(uint64_t a1)
{
  uint64_t v18 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v10 + 96))(&v17, v10, *(unsigned int *)(a1 + 24), 1, @"MultiSimVoLteOnly", 0, 0);
  sub_1000057AC(&v18, &v17);
  sub_1000577C4(&v17);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v18, v12);
  int v13 = buf[0];
  uint64_t v14 = *(NSObject **)a1;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = asStringBool(v13 != 0);
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I isMsimVoLteOnly: %s", buf, 0xCu);
  }
  sub_100062778((const void **)&v18);
  return v13 != 0;
}

void sub_10024FCAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10024FCFC(uint64_t a1, int a2)
{
  if (sub_10024FACC(a1) && a2)
  {
    if (*(unsigned char *)(a1 + 28)) {
      return;
    }
    uint64_t v4 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Multi-SIM VoLTE-only activated", buf, 2u);
    }
    char v5 = 1;
  }
  else
  {
    if (!*(unsigned char *)(a1 + 28)) {
      return;
    }
    uint64_t v6 = *(NSObject **)a1;
    BOOL v7 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
    char v5 = 0;
    if (v7)
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Multi-SIM VoLTE-only deactivated", v8, 2u);
      char v5 = 0;
    }
  }
  *(unsigned char *)(a1 + 28) = v5;
}

void IMSSuppServicesCommandDriver::create()
{
}

void sub_10024FE94(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t IMSSuppServicesCommandDriver::IMSSuppServicesCommandDriver(uint64_t a1, uint64_t a2, NSObject **a3)
{
  uint64_t v4 = *a3;
  dispatch_object_t object = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  SuppServicesCommandDriver::SuppServicesCommandDriver();
  char v5 = (capabilities::ct *)object;
  if (object) {
    dispatch_release(object);
  }
  v12[0] = off_101999E18;
  v12[1] = sub_10025026C;
  v12[3] = v12;
  *(void *)(a1 + 80) = 0;
  if ((capabilities::ct::supportsGemini(v5) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 80)) {
    operator new();
  }
  sub_10008863C(v12);
  *(void *)a1 = off_1019AFD58;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = a1 + 96;
  *(unsigned char *)(a1 + 112) = 0;
  *(void *)(a1 + 116) = 0;
  *(unsigned char *)(a1 + 124) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 133) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 149) = 0;
  *(_DWORD *)(a1 + 160) = 6;
  *(void *)(a1 + 164) = 0;
  *(unsigned char *)(a1 + 172) = 0;
  *(void *)(a1 + 176) = 0x300000002;
  sub_100058DB0(&__p, "IMSSuppServicesCommandDriver");
  uint64_t v6 = *(NSObject **)(a1 + 24);
  uint64_t v8 = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  ctu::RestModule::RestModule();
  if (v8) {
    dispatch_release(v8);
  }
  if (v10 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 200) = a1 + 208;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = a1 + 232;
  return a1;
}

void sub_10025016C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19)
{
  sub_10008863C((void *)(v19 - 72));
  operator delete();
}

void sub_100250258(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x100250250);
}

const char *sub_10025026C(int a1)
{
  if ((a1 - 1) > 2) {
    return "set.supp.ims.?";
  }
  else {
    return off_1019B0350[a1 - 1];
  }
}

const char *sub_100250294()
{
  return "IMSSuppServicesCommandDriver";
}

void sub_1002502A0(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  uint64_t v3 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  char v5 = *a3;
  if (*a3)
  {
    dispatch_retain(*a3);
    dispatch_group_enter(v5);
  }
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, v3);
  operator new();
}

uint64_t sub_1002503BC(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 184));
}

const char *sub_1002503C4()
{
  return "XCAP";
}

void sub_1002503D0(uint64_t a1)
{
  *(void *)a1 = off_1019AFD58;
  sub_1000346F8(a1 + 224, *(void **)(a1 + 232));
  sub_10005CD2C(a1 + 200, *(char **)(a1 + 208));
  int v2 = *(std::__shared_weak_count **)(a1 + 192);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100119D90(*(void **)(a1 + 96));
  uint64_t v3 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }

  SuppServicesCommandDriver::~SuppServicesCommandDriver((SuppServicesCommandDriver *)a1);
}

void sub_10025047C(uint64_t a1)
{
  sub_1002503D0(a1);

  operator delete();
}

void sub_1002504B4(uint64_t a1)
{
  void (***v9)(uint64_t *__return_ptr, void, uint64_t);
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  void *v12;
  void *v13;
  NSObject *v14;
  uint64_t v15;
  BOOL v16;
  const char *v17;
  BOOL v18;
  const char *v19;
  NSObject *v20;
  uint64_t v21;
  BOOL v22;
  const char *v23;
  const char *v24;
  os_log_t *v25;
  std::mutex *v26;
  std::mutex *v27;
  uint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  unsigned int v31;
  void *v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  NSObject *v37;
  BOOL v38;
  uint64_t v39;
  BOOL v40;
  const char *v41;
  const char *v42;
  const char *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  BOOL v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  std::__shared_weak_count *v52;
  BOOL v53;
  uint64_t v54;
  BOOL v55;
  const char *v56;
  const char *v57;
  NSObject *v58;
  uint64_t v59;
  BOOL v60;
  const char *v61;
  const char *v62;
  std::__shared_weak_count *v63;
  uint64_t v64;
  std::__shared_weak_count *v65;
  std::__shared_weak_count *v66;
  atomic_ullong *p_shared_weak_owners;
  std::__shared_weak_count *v68;
  std::__shared_weak_count *v69;
  uint64_t *v70;
  std::__shared_weak_count *v71;
  std::__shared_weak_count *shared_weak_owners;
  uint64_t **v73;
  std::__shared_weak_count *v74;
  uint64_t *v75;
  std::__shared_weak_count *v76;
  uint64_t v77;
  std::__shared_weak_count *v78;
  std::__shared_weak_count *v79;
  std::__shared_weak_count *v80;
  uint64_t v81;
  unsigned int v82;
  char *v83;
  std::__shared_weak_count *v84;
  uint64_t v85;
  std::__shared_weak_count *v86;
  void *v87;
  void *v88;
  NSObject *v89;
  std::__shared_weak_count *v90;
  char v91;
  uint64_t **v92;
  uint64_t *v93;
  uint64_t v94;
  std::__shared_weak_count *v95;
  uint64_t v96;
  std::__shared_weak_count *v97;
  uint64_t v98;
  std::__shared_weak_count *v99;
  unsigned char buf[12];
  __int16 v101;
  const char *v102;
  char v103;

  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    char v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    int v9 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v8[3];
    char v10 = (std::__shared_weak_count *)v8[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      char v11 = v10;
      sub_10004D2C8(v10);
      v91 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    int v9 = 0;
  }
  std::mutex::unlock(v3);
  char v11 = 0;
  v91 = 1;
LABEL_9:
  v90 = v11;
  if (v9)
  {
    CFBooleanRef v12 = *(void **)(a1 + 200);
    int v13 = (void *)(a1 + 208);
    if (v12 != (void *)(a1 + 208))
    {
      v92 = (uint64_t **)(a1 + 88);
      v93 = (uint64_t *)(a1 + 96);
      while (!*((unsigned char *)v12 + 56))
      {
LABEL_119:
        v87 = (void *)v12[1];
        if (v87)
        {
          do
          {
            uint64_t v88 = v87;
            v87 = (void *)*v87;
          }
          while (v87);
        }
        else
        {
          do
          {
            uint64_t v88 = (void *)v12[2];
            uint64_t v18 = *v88 == (void)v12;
            CFBooleanRef v12 = v88;
          }
          while (!v18);
        }
        CFBooleanRef v12 = v88;
        if (v88 == v13) {
          goto LABEL_128;
        }
      }
      v96 = 0;
      v97 = 0;
      (**v9)(&v96, v9, (uint64_t)(v12 + 4));
      if (!v96)
      {
        xpc_object_t v20 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          char v21 = *((unsigned __int8 *)v12 + 55);
          dispatch_object_t v22 = (v21 & 0x80u) != 0;
          if ((v21 & 0x80u) != 0) {
            char v21 = v12[5];
          }
          if (v22) {
            id v23 = (const char *)v12[4];
          }
          else {
            id v23 = (const char *)(v12 + 4);
          }
          uint64_t v18 = v21 == 0;
          xpc_object_t v24 = "<invalid>";
          if (!v18) {
            xpc_object_t v24 = v23;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v24;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "PersonalityID: %s is not found", buf, 0xCu);
        }
        goto LABEL_117;
      }
      if (*(unsigned char *)(v96 + 49))
      {
        uint64_t v14 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v15 = *((unsigned __int8 *)v12 + 55);
          long long v16 = (v15 & 0x80u) != 0;
          if ((v15 & 0x80u) != 0) {
            uint64_t v15 = v12[5];
          }
          if (v16) {
            uint64_t v17 = (const char *)v12[4];
          }
          else {
            uint64_t v17 = (const char *)(v12 + 4);
          }
          uint64_t v18 = v15 == 0;
          uint64_t v19 = "<invalid>";
          if (!v18) {
            uint64_t v19 = v17;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v19;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I PersonalityID: %s is not a SIM personality, bailing...", buf, 0xCu);
        }
LABEL_117:
        if (v97) {
          sub_10004D2C8(v97);
        }
        goto LABEL_119;
      }
      id v25 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), *(unsigned int *)(v96 + 52));
      v94 = 0;
      v95 = 0;
      id v26 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
      uint64_t v27 = v26;
      if (v28 < 0)
      {
        char v29 = (unsigned __int8 *)(v28 & 0x7FFFFFFFFFFFFFFFLL);
        id v30 = 5381;
        do
        {
          uint64_t v28 = v30;
          id v31 = *v29++;
          id v30 = (33 * v30) ^ v31;
        }
        while (v31);
      }
      std::mutex::lock(v26);
      *(void *)long long buf = v28;
      long long v32 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)buf);
      if (v32)
      {
        id v34 = v32[3];
        int v33 = (std::__shared_weak_count *)v32[4];
        if (v33)
        {
          atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v27);
          atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
          int v13 = (void *)(a1 + 208);
          sub_10004D2C8(v33);
          uint64_t v35 = 0;
          goto LABEL_41;
        }
      }
      else
      {
        id v34 = 0;
      }
      std::mutex::unlock(v27);
      int v33 = 0;
      uint64_t v35 = 1;
LABEL_41:
      (*(void (**)(uint64_t *__return_ptr, uint64_t, void *))(*(void *)v34 + 24))(&v94, v34, v12 + 4);
      if ((v35 & 1) == 0) {
        sub_10004D2C8(v33);
      }
      uint64_t v36 = v94;
      int v37 = *v25;
      uint64_t v38 = os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT);
      if (!v36)
      {
        if (v38)
        {
          char v54 = *((unsigned __int8 *)v12 + 55);
          char v55 = (v54 & 0x80u) != 0;
          if ((v54 & 0x80u) != 0) {
            char v54 = v12[5];
          }
          if (v55) {
            char v56 = (const char *)v12[4];
          }
          else {
            char v56 = (const char *)(v12 + 4);
          }
          uint64_t v18 = v54 == 0;
          uint64_t v57 = "<invalid>";
          if (!v18) {
            uint64_t v57 = v56;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v57;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I IMS client for PersonalityID: %s no longer exists", buf, 0xCu);
        }
        goto LABEL_115;
      }
      if (v38)
      {
        int v39 = *((unsigned __int8 *)v12 + 55);
        char v40 = (v39 & 0x80u) != 0;
        if ((v39 & 0x80u) != 0) {
          int v39 = v12[5];
        }
        if (v40) {
          char v41 = (const char *)v12[4];
        }
        else {
          char v41 = (const char *)(v12 + 4);
        }
        uint64_t v18 = v39 == 0;
        char v42 = "<invalid>";
        if (!v18) {
          char v42 = v41;
        }
        char v43 = "now ready";
        if (!*((unsigned char *)v12 + 56)) {
          char v43 = "not ready";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v42;
        v101 = 2080;
        v102 = v43;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I IMS client for PersonalityID: %s is %s", buf, 0x16u);
      }
      __int16 v44 = *v93;
      if (*v93)
      {
        int v45 = *(_DWORD *)(v96 + 52);
        char v46 = a1 + 96;
        do
        {
          int v47 = *(_DWORD *)(v44 + 32);
          char v48 = v47 < v45;
          if (v47 >= v45) {
            long long v49 = (uint64_t *)v44;
          }
          else {
            long long v49 = (uint64_t *)(v44 + 8);
          }
          if (!v48) {
            char v46 = v44;
          }
          __int16 v44 = *v49;
        }
        while (*v49);
        if ((uint64_t *)v46 != v93 && v45 >= *(_DWORD *)(v46 + 32))
        {
          long long v50 = *(void *)(v46 + 40);
          long long v51 = *(void *)(v50 + 24);
          long long v52 = *(std::__shared_weak_count **)(v50 + 32);
          if (v52)
          {
            atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
            char v53 = sub_10001D294((unsigned __int8 *)(v51 + 24), (unsigned __int8 *)v12 + 32);
            sub_10004D2C8(v52);
            if (v53)
            {
LABEL_115:
              if (v95) {
                sub_10004D2C8(v95);
              }
              goto LABEL_117;
            }
          }
          else if (sub_10001D294((unsigned __int8 *)(v51 + 24), (unsigned __int8 *)v12 + 32))
          {
            goto LABEL_115;
          }
        }
      }
      long long v58 = *v25;
      if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
      {
        long long v59 = *((unsigned __int8 *)v12 + 55);
        __int16 v60 = (v59 & 0x80u) != 0;
        if ((v59 & 0x80u) != 0) {
          long long v59 = v12[5];
        }
        if (v60) {
          uint64_t v61 = (const char *)v12[4];
        }
        else {
          uint64_t v61 = (const char *)(v12 + 4);
        }
        uint64_t v18 = v59 == 0;
        uint64_t v62 = "<invalid>";
        if (!v18) {
          uint64_t v62 = v61;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v62;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I Creating new IMSSuppServicesCommandDriver for: %s", buf, 0xCu);
      }
      v63 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v63 || (v64 = *(void *)(a1 + 8), (long long v65 = std::__shared_weak_count::lock(v63)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v66 = v65;
      p_shared_weak_owners = &v65->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v65->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v65);
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      char v68 = (std::__shared_weak_count *)operator new(0x58uLL);
      v69 = v68;
      v68->__shared_owners_ = 0;
      v68->__shared_weak_owners_ = 0;
      v68->__vftable = (std::__shared_weak_count_vtbl *)off_1019B0310;
      uint64_t v70 = (uint64_t *)&v68[1];
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      v68[1].__shared_owners_ = 0;
      v68[1].__shared_weak_owners_ = 0;
      v68[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019AFE28;
      v71 = v97;
      v68[2].__vftable = (std::__shared_weak_count_vtbl *)v96;
      v68[2].__shared_owners_ = (uint64_t)v71;
      if (v71) {
        atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v68[2].__shared_weak_owners_ = v64;
      v68[3].__vftable = (std::__shared_weak_count_vtbl *)v66;
      atomic_fetch_add_explicit(&v66->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v68[3].__shared_owners_ = (uint64_t)v25;
      std::__shared_weak_count::__release_weak(v66);
      shared_weak_owners = (std::__shared_weak_count *)v69[1].__shared_weak_owners_;
      int v13 = (void *)(a1 + 208);
      if (shared_weak_owners)
      {
        if (shared_weak_owners->__shared_owners_ != -1)
        {
LABEL_96:
          v73 = sub_100256E84(v92, *(_DWORD *)(v96 + 52), (_DWORD *)(v96 + 52));
          char v74 = (std::__shared_weak_count *)v73[6];
          v73[5] = v70;
          v73[6] = (uint64_t *)v69;
          if (v74) {
            sub_10004D2C8(v74);
          }
          std::__shared_weak_count::__release_weak(v66);
          uint64_t v75 = sub_100256E84(v92, *(_DWORD *)(v96 + 52), (_DWORD *)(v96 + 52))[5];
          long long v77 = v94;
          char v76 = v95;
          if (v95) {
            atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          char v78 = (std::__shared_weak_count *)v75[6];
          if (v78)
          {
            v79 = std::__shared_weak_count::lock(v78);
            if (v79)
            {
              char v80 = v79;
              v81 = v75[5];
              if (v81)
              {
                char v82 = *(_DWORD *)(v75[3] + 52) - 1;
                v83 = "set.supp.ims.?";
                if (v82 <= 2) {
                  v83 = off_1019B0350[v82];
                }
                sub_100058DB0(buf, v83);
                v84 = (std::__shared_weak_count *)v75[2];
                if (!v84 || (v85 = v75[1], (v86 = std::__shared_weak_count::lock(v84)) == 0)) {
                  sub_100088B9C();
                }
                v98 = v85;
                v99 = v86;
                (*(void (**)(uint64_t, unsigned char *, uint64_t *, void))(*(void *)v77 + 176))(v77, buf, &v98, *(void *)(v81 + 24));
                if (v99) {
                  sub_10004D2C8(v99);
                }
                if (v103 < 0) {
                  operator delete(*(void **)buf);
                }
              }
              sub_10004D2C8(v80);
            }
          }
          if (v76) {
            sub_10004D2C8(v76);
          }
          std::__shared_weak_count::__release_weak(v66);
          goto LABEL_115;
        }
        atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v69->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v69[1].__shared_owners_ = (uint64_t)v70;
        v69[1].__shared_weak_owners_ = (uint64_t)v69;
        std::__shared_weak_count::__release_weak(shared_weak_owners);
      }
      else
      {
        atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v69->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v69[1].__shared_owners_ = (uint64_t)v70;
        v69[1].__shared_weak_owners_ = (uint64_t)v69;
      }
      sub_10004D2C8(v69);
      goto LABEL_96;
    }
  }
  else
  {
    v89 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "#N PersonalityShop is not ready", buf, 2u);
    }
  }
LABEL_128:
  if ((v91 & 1) == 0) {
    sub_10004D2C8(v90);
  }
}

void sub_100250D24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, int a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24,std::__shared_weak_count *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a25) {
    sub_10004D2C8(a25);
  }
  if (a31 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v33);
  if (v32) {
    sub_10004D2C8(v32);
  }
  std::__shared_weak_count::__release_weak(v31);
  if (a21) {
    sub_10004D2C8(a21);
  }
  if (a23) {
    sub_10004D2C8(a23);
  }
  if ((a13 & 1) == 0) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(a1);
}

void sub_100250E08(uint64_t a1, uint64_t a2, const __CFDictionary **a3)
{
  lpsrc = 0;
  long long v124 = 0u;
  long long v125 = 0u;
  long long v123 = 0u;
  CapSuppServicesInfo::CapSuppServicesInfo((CapSuppServicesInfo *)&v123);
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
  unsigned int v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I notificationSuppServicesResponse", buf, 2u);
  }
  if (CapSuppServicesInfo::deserialize((CapSuppServicesInfo *)&v123, *a3))
  {
    uint8_t v8 = BYTE9(v125);
    switch(BYTE9(v125))
    {
      case 0:
        int v9 = *v6;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I notificationSuppServicesResponse - Call Waiting", buf, 2u);
        }
        if (lpsrc) {
        else
        }
          char v10 = 0;
        int v26 = BYTE8(v125);
        __int16 v27 = WORD4(v123);
        __int16 v120 = WORD4(v123);
        if (SBYTE7(v125) < 0)
        {
          sub_10004FC84(&v121, (void *)v124, *((unint64_t *)&v124 + 1));
          __int16 v27 = v120;
          if (v26)
          {
LABEL_48:
            __int16 v133 = v27;
            if (SHIBYTE(v122) < 0)
            {
              sub_10004FC84(&v134, (void *)v121, *((unint64_t *)&v121 + 1));
            }
            else
            {
              long long v134 = v121;
              uint64_t v135 = v122;
            }
            char v41 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              CapSuppServicesInfo::Result::asString((uint64_t *)buf, (CapSuppServicesInfo::Result *)&v133);
              char v42 = v131 >= 0 ? buf : *(uint8_t **)buf;
              int v136 = 136315138;
              *(void *)v137 = v42;
              _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I handleCallWaitingSetResponse - Result: %s", (uint8_t *)&v136, 0xCu);
              if (SHIBYTE(v131) < 0) {
                operator delete(*(void **)buf);
              }
            }
            uint64_t v43 = *(void *)(a1 + 64);
            if ((_BYTE)v133)
            {
              (*(void (**)(void, uint64_t, uint64_t, uint64_t, void))(*(void *)v43 + 112))(*(void *)(a1 + 64), a2, 1, 3, *(unsigned __int8 *)(a1 + 172));
            }
            else
            {
              uint64_t v53 = *(unsigned int *)(a1 + 164);
              uint64_t v54 = *(unsigned int *)(a1 + 168);
              *(_WORD *)long long buf = v133;
              if (SHIBYTE(v135) < 0)
              {
                sub_10004FC84(&v131, (void *)v134, *((unint64_t *)&v134 + 1));
                int v55 = buf[0];
              }
              else
              {
                int v55 = 0;
                long long v131 = v134;
                uint64_t v132 = v135;
              }
              if (v55)
              {
                uint64_t v90 = 1;
              }
              else
              {
                if (buf[1] == 2) {
                  unsigned int v95 = 21;
                }
                else {
                  unsigned int v95 = 1;
                }
                if (buf[1] == 1) {
                  uint64_t v90 = 22;
                }
                else {
                  uint64_t v90 = v95;
                }
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v43 + 120))(v43, a2, v53, v54, v90, 1);
              if (SHIBYTE(v132) < 0) {
                operator delete((void *)v131);
              }
            }
            LOWORD(v136) = v133;
            if (SHIBYTE(v135) < 0)
            {
              sub_10004FC84(&v137[4], (void *)v134, *((unint64_t *)&v134 + 1));
            }
            else
            {
              *(_OWORD *)&v137[4] = v134;
              uint64_t v138 = v135;
            }
            IMSSuppServicesCommandDriver::submitXcapQueryMetric(a1, a2, 1, 0, (uint64_t)&v136);
          }
        }
        else
        {
          long long v121 = v124;
          uint64_t v122 = v125;
          if (BYTE8(v125)) {
            goto LABEL_48;
          }
        }
        __int16 v133 = v27;
        if (SHIBYTE(v122) < 0)
        {
          sub_10004FC84(&v134, (void *)v121, *((unint64_t *)&v121 + 1));
        }
        else
        {
          long long v134 = v121;
          uint64_t v135 = v122;
        }
        char v76 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
        if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
        {
          CapSuppServicesInfo::Result::asString((uint64_t *)buf, (CapSuppServicesInfo::Result *)&v133);
          long long v77 = v131 >= 0 ? buf : *(uint8_t **)buf;
          int v136 = 136315138;
          *(void *)v137 = v77;
          _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I handleCallWaitingFetchResponse - Result: %s", (uint8_t *)&v136, 0xCu);
          if (SHIBYTE(v131) < 0) {
            operator delete(*(void **)buf);
          }
        }
        if (v10 && (_BYTE)v133) {
          operator new();
        }
        uint64_t v78 = *(void *)(a1 + 64);
        uint64_t v79 = *(unsigned int *)(a1 + 164);
        *(_WORD *)long long buf = v133;
        if (SHIBYTE(v135) < 0)
        {
          sub_10004FC84(&v131, (void *)v134, *((unint64_t *)&v134 + 1));
          int v80 = buf[0];
        }
        else
        {
          int v80 = v133;
          long long v131 = v134;
          uint64_t v132 = v135;
        }
        if (v80)
        {
          uint64_t v101 = 1;
        }
        else
        {
          if (buf[1] == 2) {
            unsigned int v106 = 21;
          }
          else {
            unsigned int v106 = 1;
          }
          if (buf[1] == 1) {
            uint64_t v101 = 22;
          }
          else {
            uint64_t v101 = v106;
          }
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v78 + 104))(v78, a2, v79, v101, 1);
        if (SHIBYTE(v132) < 0) {
          operator delete((void *)v131);
        }
        LOWORD(v136) = v133;
        if (SHIBYTE(v135) < 0)
        {
          sub_10004FC84(&v137[4], (void *)v134, *((unint64_t *)&v134 + 1));
        }
        else
        {
          *(_OWORD *)&v137[4] = v134;
          uint64_t v138 = v135;
        }
        IMSSuppServicesCommandDriver::submitXcapQueryMetric(a1, a2, 0, 0, (uint64_t)&v136);
      case 1:
        uint64_t v19 = *v6;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I notificationSuppServicesResponse - Call Forward", buf, 2u);
        }
        if (lpsrc) {
        else
        }
          xpc_object_t v20 = 0;
        int v28 = BYTE8(v125);
        __int16 v29 = WORD4(v123);
        __int16 v117 = WORD4(v123);
        if (SBYTE7(v125) < 0)
        {
          sub_10004FC84(&v118, (void *)v124, *((unint64_t *)&v124 + 1));
          __int16 v29 = v117;
          if (v28)
          {
LABEL_53:
            __int16 v133 = v29;
            if (SHIBYTE(v119) < 0)
            {
              sub_10004FC84(&v134, (void *)v118, *((unint64_t *)&v118 + 1));
            }
            else
            {
              long long v134 = v118;
              uint64_t v135 = v119;
            }
            __int16 v44 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              CapSuppServicesInfo::Result::asString((uint64_t *)buf, (CapSuppServicesInfo::Result *)&v133);
              int v45 = v131 >= 0 ? buf : *(uint8_t **)buf;
              int v136 = 136315138;
              *(void *)v137 = v45;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I handleCallForwardingSetResponse - Result: %s", (uint8_t *)&v136, 0xCu);
              if (SHIBYTE(v131) < 0) {
                operator delete(*(void **)buf);
              }
            }
            uint64_t v46 = *(void *)(a1 + 64);
            uint64_t v47 = *(unsigned int *)(a1 + 144);
            uint64_t v48 = *(unsigned int *)(a1 + 132);
            if ((_BYTE)v133)
            {
              (*(void (**)(void, uint64_t, void, void, void, void))(*(void *)v46 + 32))(*(void *)(a1 + 64), a2, *(unsigned int *)(a1 + 144), *(unsigned int *)(a1 + 132), *(unsigned __int8 *)(a1 + 140), *(unsigned int *)(a1 + 136));
            }
            else
            {
              uint64_t v56 = *(unsigned int *)(a1 + 136);
              *(_WORD *)long long buf = v133;
              if (SHIBYTE(v135) < 0)
              {
                sub_10004FC84(&v131, (void *)v134, *((unint64_t *)&v134 + 1));
                int v57 = buf[0];
              }
              else
              {
                int v57 = 0;
                long long v131 = v134;
                uint64_t v132 = v135;
              }
              if (v57)
              {
                uint64_t v91 = 1;
              }
              else
              {
                if (buf[1] == 2) {
                  unsigned int v96 = 21;
                }
                else {
                  unsigned int v96 = 1;
                }
                if (buf[1] == 1) {
                  uint64_t v91 = 22;
                }
                else {
                  uint64_t v91 = v96;
                }
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v46 + 40))(v46, a2, v47, v48, v56, v91, 1);
              if (SHIBYTE(v132) < 0) {
                operator delete((void *)v131);
              }
            }
            LOWORD(v136) = v133;
            if (SHIBYTE(v135) < 0)
            {
              sub_10004FC84(&v137[4], (void *)v134, *((unint64_t *)&v134 + 1));
            }
            else
            {
              *(_OWORD *)&v137[4] = v134;
              uint64_t v138 = v135;
            }
            IMSSuppServicesCommandDriver::submitXcapQueryMetric(a1, a2, 1, 1, (uint64_t)&v136);
          }
        }
        else
        {
          long long v118 = v124;
          uint64_t v119 = v125;
          if (BYTE8(v125)) {
            goto LABEL_53;
          }
        }
        LOWORD(v127) = v29;
        if (SHIBYTE(v119) < 0)
        {
          sub_10004FC84(&v128, (void *)v118, *((unint64_t *)&v118 + 1));
        }
        else
        {
          long long v128 = v118;
          uint64_t v129 = v119;
        }
        v81 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
        if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
        {
          CapSuppServicesInfo::Result::asString((uint64_t *)buf, (CapSuppServicesInfo::Result *)&v127);
          char v82 = v131 >= 0 ? buf : *(uint8_t **)buf;
          int v136 = 136315138;
          *(void *)v137 = v82;
          _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "#I handleCallForwardingFetchResponse - Result: %s", (uint8_t *)&v136, 0xCu);
          if (SHIBYTE(v131) < 0) {
            operator delete(*(void **)buf);
          }
        }
        if (v20 && (_BYTE)v127) {
          operator new();
        }
        uint64_t v83 = *(void *)(a1 + 64);
        uint64_t v84 = *(unsigned int *)(a1 + 128);
        uint64_t v85 = *(unsigned int *)(a1 + 116);
        *(_WORD *)long long buf = v127;
        if (SHIBYTE(v129) < 0)
        {
          sub_10004FC84(&v131, (void *)v128, *((unint64_t *)&v128 + 1));
          int v86 = buf[0];
        }
        else
        {
          int v86 = v127;
          long long v131 = v128;
          uint64_t v132 = v129;
        }
        if (v86)
        {
          uint64_t v102 = 1;
        }
        else
        {
          if (buf[1] == 2) {
            unsigned int v107 = 21;
          }
          else {
            unsigned int v107 = 1;
          }
          if (buf[1] == 1) {
            uint64_t v102 = 22;
          }
          else {
            uint64_t v102 = v107;
          }
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v83 + 24))(v83, a2, v84, v85, v102, 1);
        if (SHIBYTE(v132) < 0) {
          operator delete((void *)v131);
        }
        LOWORD(v136) = v127;
        if (SHIBYTE(v129) < 0)
        {
          sub_10004FC84(&v137[4], (void *)v128, *((unint64_t *)&v128 + 1));
        }
        else
        {
          *(_OWORD *)&v137[4] = v128;
          uint64_t v138 = v129;
        }
        IMSSuppServicesCommandDriver::submitXcapQueryMetric(a1, a2, 0, 1, (uint64_t)&v136);
      case 2:
        int v13 = *v6;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I notificationSuppServicesResponse - Caller ID Presentation", buf, 2u);
        }
        int v14 = BYTE8(v125);
        __int16 v15 = WORD4(v123);
        __int16 v114 = WORD4(v123);
        if (SBYTE7(v125) < 0)
        {
          sub_10004FC84(&v115, (void *)v124, *((unint64_t *)&v124 + 1));
          __int16 v15 = v114;
          if (v14)
          {
LABEL_17:
            __int16 v133 = v15;
            if (SHIBYTE(v116) < 0)
            {
              sub_10004FC84(&v134, (void *)v115, *((unint64_t *)&v115 + 1));
            }
            else
            {
              long long v134 = v115;
              uint64_t v135 = v116;
            }
            uint64_t v35 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            {
              CapSuppServicesInfo::Result::asString((uint64_t *)buf, (CapSuppServicesInfo::Result *)&v133);
              uint64_t v36 = v131 >= 0 ? buf : *(uint8_t **)buf;
              int v136 = 136315138;
              *(void *)v137 = v36;
              _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I handleCLIPSetResponse - Result: %s", (uint8_t *)&v136, 0xCu);
              if (SHIBYTE(v131) < 0) {
                operator delete(*(void **)buf);
              }
            }
            uint64_t v37 = *(void *)(a1 + 64);
            if ((_BYTE)v133)
            {
              (*(void (**)(void, uint64_t, void))(*(void *)v37 + 184))(*(void *)(a1 + 64), a2, *(unsigned int *)(a1 + 176));
            }
            else
            {
              *(_WORD *)long long buf = v133;
              if (SHIBYTE(v135) < 0)
              {
                sub_10004FC84(&v131, (void *)v134, *((unint64_t *)&v134 + 1));
                int v51 = buf[0];
              }
              else
              {
                int v51 = 0;
                long long v131 = v134;
                uint64_t v132 = v135;
              }
              if (v51)
              {
                uint64_t v88 = 1;
              }
              else
              {
                if (buf[1] == 2) {
                  unsigned int v93 = 21;
                }
                else {
                  unsigned int v93 = 1;
                }
                if (buf[1] == 1) {
                  uint64_t v88 = 22;
                }
                else {
                  uint64_t v88 = v93;
                }
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v37 + 192))(v37, a2, v88);
              if (SHIBYTE(v132) < 0) {
                operator delete((void *)v131);
              }
            }
            LOWORD(v136) = v133;
            if (SHIBYTE(v135) < 0)
            {
              sub_10004FC84(&v137[4], (void *)v134, *((unint64_t *)&v134 + 1));
            }
            else
            {
              *(_OWORD *)&v137[4] = v134;
              uint64_t v138 = v135;
            }
            IMSSuppServicesCommandDriver::submitXcapQueryMetric(a1, a2, 1, 2, (uint64_t)&v136);
          }
        }
        else
        {
          long long v115 = v124;
          uint64_t v116 = v125;
          if (BYTE8(v125)) {
            goto LABEL_17;
          }
        }
        xpc_object_t v24 = lpsrc;
        __int16 v133 = v15;
        if (SHIBYTE(v116) < 0)
        {
          sub_10004FC84(&v134, (void *)v115, *((unint64_t *)&v115 + 1));
        }
        else
        {
          long long v134 = v115;
          uint64_t v135 = v116;
        }
        char v68 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
        {
          CapSuppServicesInfo::Result::asString((uint64_t *)buf, (CapSuppServicesInfo::Result *)&v133);
          v69 = v131 >= 0 ? buf : *(uint8_t **)buf;
          int v136 = 136315138;
          *(void *)v137 = v69;
          _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I handleCLIPFetchResponse - Result: %s", (uint8_t *)&v136, 0xCu);
          if (SHIBYTE(v131) < 0) {
            operator delete(*(void **)buf);
          }
        }
        if (v24 && (_BYTE)v133) {
          operator new();
        }
        uint64_t v70 = *(void *)(a1 + 64);
        *(_WORD *)long long buf = v133;
        if (SHIBYTE(v135) < 0)
        {
          sub_10004FC84(&v131, (void *)v134, *((unint64_t *)&v134 + 1));
          int v71 = buf[0];
        }
        else
        {
          int v71 = v133;
          long long v131 = v134;
          uint64_t v132 = v135;
        }
        if (v71)
        {
          uint64_t v99 = 1;
        }
        else
        {
          if (buf[1] == 2) {
            unsigned int v104 = 21;
          }
          else {
            unsigned int v104 = 1;
          }
          if (buf[1] == 1) {
            uint64_t v99 = 22;
          }
          else {
            uint64_t v99 = v104;
          }
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v70 + 176))(v70, a2, v99, 1);
        if (SHIBYTE(v132) < 0) {
          operator delete((void *)v131);
        }
        LOWORD(v136) = v133;
        if (SHIBYTE(v135) < 0)
        {
          sub_10004FC84(&v137[4], (void *)v134, *((unint64_t *)&v134 + 1));
        }
        else
        {
          *(_OWORD *)&v137[4] = v134;
          uint64_t v138 = v135;
        }
        IMSSuppServicesCommandDriver::submitXcapQueryMetric(a1, a2, 0, 2, (uint64_t)&v136);
      case 3:
        long long v16 = *v6;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I notificationSuppServicesResponse - Caller ID Restriction", buf, 2u);
        }
        int v17 = BYTE8(v125);
        __int16 v18 = WORD4(v123);
        __int16 v111 = WORD4(v123);
        if (SBYTE7(v125) < 0)
        {
          sub_10004FC84(&v112, (void *)v124, *((unint64_t *)&v124 + 1));
          __int16 v18 = v111;
          if (v17)
          {
LABEL_23:
            __int16 v133 = v18;
            if (SHIBYTE(v113) < 0)
            {
              sub_10004FC84(&v134, (void *)v112, *((unint64_t *)&v112 + 1));
            }
            else
            {
              long long v134 = v112;
              uint64_t v135 = v113;
            }
            uint64_t v38 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              CapSuppServicesInfo::Result::asString((uint64_t *)buf, (CapSuppServicesInfo::Result *)&v133);
              int v39 = v131 >= 0 ? buf : *(uint8_t **)buf;
              int v136 = 136315138;
              *(void *)v137 = v39;
              _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I handleCLIRSetResponse - Result: %s", (uint8_t *)&v136, 0xCu);
              if (SHIBYTE(v131) < 0) {
                operator delete(*(void **)buf);
              }
            }
            uint64_t v40 = *(void *)(a1 + 64);
            if ((_BYTE)v133)
            {
              (*(void (**)(void, uint64_t, void))(*(void *)v40 + 152))(*(void *)(a1 + 64), a2, *(unsigned int *)(a1 + 180));
            }
            else
            {
              *(_WORD *)long long buf = v133;
              if (SHIBYTE(v135) < 0)
              {
                sub_10004FC84(&v131, (void *)v134, *((unint64_t *)&v134 + 1));
                int v52 = buf[0];
              }
              else
              {
                int v52 = 0;
                long long v131 = v134;
                uint64_t v132 = v135;
              }
              if (v52)
              {
                uint64_t v89 = 1;
              }
              else
              {
                if (buf[1] == 2) {
                  unsigned int v94 = 21;
                }
                else {
                  unsigned int v94 = 1;
                }
                if (buf[1] == 1) {
                  uint64_t v89 = 22;
                }
                else {
                  uint64_t v89 = v94;
                }
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v40 + 160))(v40, a2, v89);
              if (SHIBYTE(v132) < 0) {
                operator delete((void *)v131);
              }
            }
            LOWORD(v136) = v133;
            if (SHIBYTE(v135) < 0)
            {
              sub_10004FC84(&v137[4], (void *)v134, *((unint64_t *)&v134 + 1));
            }
            else
            {
              *(_OWORD *)&v137[4] = v134;
              uint64_t v138 = v135;
            }
            IMSSuppServicesCommandDriver::submitXcapQueryMetric(a1, a2, 1, 3, (uint64_t)&v136);
          }
        }
        else
        {
          long long v112 = v124;
          uint64_t v113 = v125;
          if (BYTE8(v125)) {
            goto LABEL_23;
          }
        }
        id v25 = lpsrc;
        __int16 v133 = v18;
        if (SHIBYTE(v113) < 0)
        {
          sub_10004FC84(&v134, (void *)v112, *((unint64_t *)&v112 + 1));
        }
        else
        {
          long long v134 = v112;
          uint64_t v135 = v113;
        }
        char v72 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          CapSuppServicesInfo::Result::asString((uint64_t *)buf, (CapSuppServicesInfo::Result *)&v133);
          v73 = v131 >= 0 ? buf : *(uint8_t **)buf;
          int v136 = 136315138;
          *(void *)v137 = v73;
          _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I handleCLIRFetchResponse - Result: %s", (uint8_t *)&v136, 0xCu);
          if (SHIBYTE(v131) < 0) {
            operator delete(*(void **)buf);
          }
        }
        if (v25 && (_BYTE)v133)
        {
          *(void *)long long buf = 0;
          *(void *)&long long v131 = 0;
          operator new();
        }
        uint64_t v74 = *(void *)(a1 + 64);
        *(_WORD *)long long buf = v133;
        if (SHIBYTE(v135) < 0)
        {
          sub_10004FC84(&v131, (void *)v134, *((unint64_t *)&v134 + 1));
          int v75 = buf[0];
        }
        else
        {
          int v75 = v133;
          long long v131 = v134;
          uint64_t v132 = v135;
        }
        if (v75)
        {
          uint64_t v100 = 1;
        }
        else
        {
          if (buf[1] == 2) {
            unsigned int v105 = 21;
          }
          else {
            unsigned int v105 = 1;
          }
          if (buf[1] == 1) {
            uint64_t v100 = 22;
          }
          else {
            uint64_t v100 = v105;
          }
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v74 + 144))(v74, a2, v100, 1);
        if (SHIBYTE(v132) < 0) {
          operator delete((void *)v131);
        }
        LOWORD(v136) = v133;
        if (SHIBYTE(v135) < 0)
        {
          sub_10004FC84(&v137[4], (void *)v134, *((unint64_t *)&v134 + 1));
        }
        else
        {
          *(_OWORD *)&v137[4] = v134;
          uint64_t v138 = v135;
        }
        IMSSuppServicesCommandDriver::submitXcapQueryMetric(a1, a2, 0, 3, (uint64_t)&v136);
      case 4:
        char v11 = *v6;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I notificationSuppServicesResponse - Call Barring", buf, 2u);
        }
        if (lpsrc) {
        else
        }
          CFBooleanRef v12 = 0;
        int v22 = BYTE8(v125);
        __int16 v23 = WORD4(v123);
        __int16 v108 = WORD4(v123);
        if (SBYTE7(v125) < 0)
        {
          sub_10004FC84(&__p, (void *)v124, *((unint64_t *)&v124 + 1));
          __int16 v23 = v108;
          if (v22)
          {
LABEL_34:
            __int16 v133 = v23;
            if (SHIBYTE(v110) < 0)
            {
              sub_10004FC84(&v134, (void *)__p, *((unint64_t *)&__p + 1));
            }
            else
            {
              long long v134 = __p;
              uint64_t v135 = v110;
            }
            id v30 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              CapSuppServicesInfo::Result::asString((uint64_t *)buf, (CapSuppServicesInfo::Result *)&v133);
              id v31 = v131 >= 0 ? buf : *(uint8_t **)buf;
              int v136 = 136315138;
              *(void *)v137 = v31;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I handleCallBarringSetResponse - Result: %s", (uint8_t *)&v136, 0xCu);
              if (SHIBYTE(v131) < 0) {
                operator delete(*(void **)buf);
              }
            }
            uint64_t v32 = *(void *)(a1 + 64);
            uint64_t v33 = *(unsigned int *)(a1 + 160);
            uint64_t v34 = *(unsigned int *)(a1 + 148);
            if ((_BYTE)v133)
            {
              (*(void (**)(void, uint64_t, void, void, void, void))(*(void *)v32 + 64))(*(void *)(a1 + 64), a2, *(unsigned int *)(a1 + 160), *(unsigned int *)(a1 + 148), *(unsigned __int8 *)(a1 + 156), *(unsigned int *)(a1 + 152));
            }
            else
            {
              uint64_t v49 = *(unsigned int *)(a1 + 152);
              *(_WORD *)long long buf = v133;
              if (SHIBYTE(v135) < 0)
              {
                sub_10004FC84(&v131, (void *)v134, *((unint64_t *)&v134 + 1));
                int v50 = buf[0];
              }
              else
              {
                int v50 = 0;
                long long v131 = v134;
                uint64_t v132 = v135;
              }
              if (v50)
              {
                uint64_t v87 = 1;
              }
              else
              {
                if (buf[1] == 2) {
                  unsigned int v92 = 21;
                }
                else {
                  unsigned int v92 = 1;
                }
                if (buf[1] == 1) {
                  uint64_t v87 = 22;
                }
                else {
                  uint64_t v87 = v92;
                }
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v32 + 72))(v32, a2, v33, v34, v49, v87, 1);
              if (SHIBYTE(v132) < 0) {
                operator delete((void *)v131);
              }
            }
            LOWORD(v136) = v133;
            if (SHIBYTE(v135) < 0)
            {
              sub_10004FC84(&v137[4], (void *)v134, *((unint64_t *)&v134 + 1));
            }
            else
            {
              *(_OWORD *)&v137[4] = v134;
              uint64_t v138 = v135;
            }
            IMSSuppServicesCommandDriver::submitXcapQueryMetric(a1, a2, 1, 4, (uint64_t)&v136);
          }
        }
        else
        {
          long long __p = v124;
          uint64_t v110 = v125;
          if (BYTE8(v125)) {
            goto LABEL_34;
          }
        }
        __int16 v133 = v23;
        if (SHIBYTE(v110) < 0)
        {
          sub_10004FC84(&v134, (void *)__p, *((unint64_t *)&__p + 1));
        }
        else
        {
          long long v134 = __p;
          uint64_t v135 = v110;
        }
        long long v58 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          CapSuppServicesInfo::Result::asString((uint64_t *)buf, (CapSuppServicesInfo::Result *)&v133);
          long long v59 = v131 >= 0 ? buf : *(uint8_t **)buf;
          int v136 = 136315138;
          *(void *)v137 = v59;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I handleCallBarringFetchResponse - Result: %s", (uint8_t *)&v136, 0xCu);
          if (SHIBYTE(v131) < 0) {
            operator delete(*(void **)buf);
          }
        }
        if (v12 && (_BYTE)v133)
        {
          __int16 v60 = (unsigned char *)v12[2];
          uint64_t v61 = (unsigned char *)v12[3];
          uint64_t v62 = *(unsigned int *)(a1 + 160);
          if (v60 == v61)
          {
            uint64_t v98 = 0;
          }
          else
          {
            while (1)
            {
              unsigned int v63 = v60[2];
              if (v63 >= 9) {
                unsigned int v63 = 6;
              }
              if (v62 == v63) {
                break;
              }
              v60 += 3;
              if (v60 == v61) {
                goto LABEL_326;
              }
            }
            uint64_t v98 = *v60 & v60[1] & 1;
          }
          (*(void (**)(void, uint64_t, uint64_t, void, uint64_t))(**(void **)(a1 + 64) + 48))(*(void *)(a1 + 64), a2, v62, *(unsigned int *)(a1 + 148), v98);
        }
        else
        {
          uint64_t v64 = *(void *)(a1 + 64);
          uint64_t v65 = *(unsigned int *)(a1 + 160);
          uint64_t v66 = *(unsigned int *)(a1 + 148);
          *(_WORD *)long long buf = v133;
          if (SHIBYTE(v135) < 0)
          {
            sub_10004FC84(&v131, (void *)v134, *((unint64_t *)&v134 + 1));
            int v67 = buf[0];
          }
          else
          {
            int v67 = v133;
            long long v131 = v134;
            uint64_t v132 = v135;
          }
          if (v67)
          {
            uint64_t v97 = 1;
          }
          else
          {
            if (buf[1] == 2) {
              unsigned int v103 = 21;
            }
            else {
              unsigned int v103 = 1;
            }
            if (buf[1] == 1) {
              uint64_t v97 = 22;
            }
            else {
              uint64_t v97 = v103;
            }
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v64 + 56))(v64, a2, v65, v66, v97, 1);
          if (SHIBYTE(v132) < 0) {
            operator delete((void *)v131);
          }
        }
LABEL_326:
        LOWORD(v136) = v133;
        if (SHIBYTE(v135) < 0)
        {
          sub_10004FC84(&v137[4], (void *)v134, *((unint64_t *)&v134 + 1));
        }
        else
        {
          *(_OWORD *)&v137[4] = v134;
          uint64_t v138 = v135;
        }
        IMSSuppServicesCommandDriver::submitXcapQueryMetric(a1, a2, 0, 4, (uint64_t)&v136);
      default:
        char v21 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 16777472;
          uint8_t buf[4] = v8;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I notificationSuppServicesResponse - invalid service type %hhu", buf, 5u);
        }
        break;
    }
  }
  CapSuppServicesInfo::~CapSuppServicesInfo((CapSuppServicesInfo *)&v123);
}

void sub_100252F7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  sub_100255C14(v63 - 224);
  if (*(char *)(v63 - 113) < 0) {
    operator delete(*(void **)(v63 - 136));
  }
  sub_10004D2C8(v62);
  if (a62 < 0) {
    operator delete(*a12);
  }
  if (a40 < 0) {
    operator delete(__p);
  }
  CapSuppServicesInfo::~CapSuppServicesInfo((CapSuppServicesInfo *)&a48);
  _Unwind_Resume(a1);
}

void sub_100253390(void *a1, char a2, int a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v6 = operator new(0x50uLL);
  v6[1] = 0;
  void v6[2] = 0;
  void *v6 = off_1019B0090;
  CapSuppServicesInfo::CapSuppServicesInfo((CapSuppServicesInfo *)(v6 + 3));
  *a1 = v7;
  a1[1] = v6;
  *((unsigned char *)v6 + 24) = 0;
  *((unsigned char *)v6 + 64) = a2;
  *((unsigned char *)v6 + 65) = a3;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      operator new();
    case 2:
      operator new();
    case 3:
      operator new();
    case 4:
      operator new();
    default:
      return;
  }
}

void sub_100253580(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002535BC(uint64_t a1, uint64_t a2, CapSuppServicesInfo **a3)
{
  if (!*a3)
  {
    long long v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
LABEL_23:
      LOBYTE(v5) = 0;
      return v5 & 1;
    }
    LOWORD(__p[0]) = 0;
    int v17 = "sendServiceRequest: service is NULL!";
LABEL_26:
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v17, (uint8_t *)__p, 2u);
    goto LABEL_23;
  }
  char v5 = a3;
  uint64_t v22 = 0;
  __int16 v23 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v8;
  CFBooleanRef v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)__p);
  if (v12)
  {
    uint64_t v14 = v12[3];
    int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  int v13 = 0;
  char v15 = 1;
LABEL_12:
  PersonalityIdFromSlotId();
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v14 + 24))(&v22, v14, __p);
  if ((v21 & 0x80000000) == 0)
  {
    if (v15) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  operator delete(__p[0]);
  if ((v15 & 1) == 0) {
LABEL_14:
  }
    sub_10004D2C8(v13);
LABEL_15:
  uint64_t v18 = v22;
  if (v22)
  {
    CapSuppServicesInfo::serialize((uint64_t *)__p, *v5);
    LOBYTE(v5) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v18 + 136))(v18, __p[0]);
    sub_100057D78((const void **)__p);
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (!v18)
  {
    long long v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), a2);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    LOWORD(__p[0]) = 0;
    int v17 = "sendServiceRequest: Failed to get client!";
    goto LABEL_26;
  }
  return v5 & 1;
}

void sub_100253844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100253898(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I fetchCallForwarding", buf, 2u);
  }
  *(_DWORD *)(a1 + 128) = a3;
  *(_DWORD *)(a1 + 116) = a4;
  xpc_object_t v24 = 0;
  id v25 = 0;
  sub_100253390(&v24, 0, 1);
  int v9 = (CapSuppServicesInfo *)v24;
  unsigned int v11 = v10;
  *(void *)long long buf = 0x10000;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  if (a3 >= 6) {
    uint8_t v12 = 0;
  }
  else {
    uint8_t v12 = a3;
  }
  buf[1] = v12;
  int v13 = (unint64_t *)(v10 + 16);
  unint64_t v14 = *((void *)v11 + 3);
  if (v14 >= *((void *)v11 + 4))
  {
    char v15 = sub_1002559F0(v13, (uint64_t)buf);
  }
  else
  {
    sub_10025597C((uint64_t)v13, (__int16 *)buf);
    char v15 = (char *)(v14 + 32);
  }
  *((void *)v11 + 3) = v15;
  long long v16 = (std::__shared_weak_count *)v25;
  v19[0] = v9;
  v19[1] = (CapSuppServicesInfo *)v25;
  if (v25) {
    atomic_fetch_add_explicit(v25 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = sub_1002535BC(a1, a2, v19);
  if (v16)
  {
    sub_10004D2C8(v16);
    sub_10004D2C8(v16);
  }
  return v17;
}

void sub_100253A30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100253A5C(uint64_t a1, uint64_t a2, uint8_t a3, CSIPhoneNumber *a4, unsigned int a5, int a6, int a7, int a8)
{
  long long v16 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I setCallForwarding", buf, 2u);
  }
  *(_DWORD *)(a1 + 144) = a5;
  *(_DWORD *)(a1 + 132) = a6;
  *(_DWORD *)(a1 + 136) = a8;
  *(unsigned char *)(a1 + 140) = a3;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  sub_100253390(&v33, 1, 1);
  uint64_t v17 = (const void *)*((void *)v33 + 6);
  if (v17) {
  else
  }
    uint64_t v18 = 0;
  *(void *)long long buf = 1;
  long long __p = 0uLL;
  uint64_t v32 = 0;
  if (a5 >= 6) {
    uint8_t v19 = 0;
  }
  else {
    uint8_t v19 = a5;
  }
  buf[1] = v19;
  buf[2] = a3;
  CSIPhoneNumber::getFullNumber((uint64_t *)&v28, a4);
  xpc_object_t v20 = v18 + 2;
  unint64_t v22 = v18[3];
  unint64_t v21 = v18[4];
  long long __p = v28;
  uint64_t v32 = v29;
  if (v22 >= v21)
  {
    uint64_t v23 = sub_1002559F0(v20, (uint64_t)buf);
  }
  else
  {
    sub_10025597C((uint64_t)v20, (__int16 *)buf);
    uint64_t v23 = (char *)(v22 + 32);
  }
  void v18[3] = v23;
  *((_DWORD *)v18 + 3) = a7;
  xpc_object_t v24 = (std::__shared_weak_count *)v34;
  v27[0] = v33;
  v27[1] = (CapSuppServicesInfo *)v34;
  if (v34) {
    atomic_fetch_add_explicit(v34 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v25 = sub_1002535BC(a1, a2, v27);
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete((void *)__p);
  }
  if (v24) {
    sub_10004D2C8(v24);
  }
  return v25;
}

void sub_100253C60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a23) {
    sub_10004D2C8(a23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100253CA0(uint64_t a1, uint64_t a2, uint8_t a3, unsigned int a4, int a5, int a6)
{
  uint8_t v12 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I activateCallForwarding", buf, 2u);
  }
  *(_DWORD *)(a1 + 144) = a4;
  *(_DWORD *)(a1 + 132) = a5;
  *(_DWORD *)(a1 + 136) = a6;
  *(unsigned char *)(a1 + 140) = a3;
  long long v28 = 0;
  uint64_t v29 = 0;
  sub_100253390(&v28, 1, 1);
  int v13 = (CapSuppServicesInfo *)v28;
  char v15 = v14;
  *(void *)long long buf = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  if (a4 >= 6) {
    uint8_t v16 = 0;
  }
  else {
    uint8_t v16 = a4;
  }
  buf[1] = v16;
  buf[2] = a3;
  uint64_t v17 = (unint64_t *)(v14 + 16);
  unint64_t v18 = *((void *)v15 + 3);
  if (v18 >= *((void *)v15 + 4))
  {
    uint8_t v19 = sub_1002559F0(v17, (uint64_t)buf);
  }
  else
  {
    sub_10025597C((uint64_t)v17, (__int16 *)buf);
    uint8_t v19 = (char *)(v18 + 32);
  }
  *((void *)v15 + 3) = v19;
  xpc_object_t v20 = (std::__shared_weak_count *)v29;
  v23[0] = v13;
  v23[1] = (CapSuppServicesInfo *)v29;
  if (v29) {
    atomic_fetch_add_explicit(v29 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v21 = sub_1002535BC(a1, a2, v23);
  if (v20)
  {
    sub_10004D2C8(v20);
    sub_10004D2C8(v20);
  }
  return v21;
}

void sub_100253E4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100253E78(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  unsigned int v4 = a3;
  *(_DWORD *)(a1 + 160) = a3;
  *(_DWORD *)(a1 + 148) = a4;
  long long v28 = 0;
  uint64_t v29 = 0;
  sub_100253390(&v28, 0, 4);
  uint64_t v7 = v28;
  uint64_t v8 = (const void *)*((void *)v28 + 6);
  if (v8) {
  else
  }
    int v9 = 0;
  if (v4 >= 9) {
    LOBYTE(v4) = 6;
  }
  unsigned int v11 = (unsigned char *)v9[3];
  unint64_t v10 = v9[4];
  if ((unint64_t)v11 >= v10)
  {
    int v13 = (unsigned char *)v9[2];
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * (v11 - v13);
    unint64_t v15 = v14 + 1;
    if (v14 + 1 >= 0x5555555555555556) {
      sub_10006A748();
    }
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (v10 - (void)v13);
    if (2 * v16 > v15) {
      unint64_t v15 = 2 * v16;
    }
    BOOL v17 = v16 >= 0x2AAAAAAAAAAAAAAALL;
    unint64_t v18 = 0x5555555555555555;
    if (!v17) {
      unint64_t v18 = v15;
    }
    if (v18)
    {
      unint64_t v18 = (unint64_t)sub_100255BD4(v18);
      int v13 = (unsigned char *)v9[2];
      unsigned int v11 = (unsigned char *)v9[3];
    }
    else
    {
      uint64_t v19 = 0;
    }
    unint64_t v20 = v18 + 3 * v14;
    unint64_t v21 = v18 + 3 * v19;
    *(_WORD *)unint64_t v20 = 0;
    *(unsigned char *)(v20 + 2) = v4;
    uint8_t v12 = (unsigned char *)(v20 + 3);
    if (v11 != v13)
    {
      do
      {
        __int16 v22 = *(_WORD *)(v11 - 3);
        v11 -= 3;
        char v23 = v11[2];
        *(_WORD *)(v20 - 3) = v22;
        v20 -= 3;
        *(unsigned char *)(v20 + 2) = v23;
      }
      while (v11 != v13);
      int v13 = (unsigned char *)v9[2];
    }
    v9[2] = v20;
    v9[3] = v12;
    void v9[4] = v21;
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    *(_WORD *)unsigned int v11 = 0;
    v11[2] = v4;
    uint8_t v12 = v11 + 3;
  }
  v9[3] = v12;
  xpc_object_t v24 = (std::__shared_weak_count *)v29;
  v27[0] = v7;
  v27[1] = (CapSuppServicesInfo *)v29;
  if (v29) {
    atomic_fetch_add_explicit(v29 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v25 = sub_1002535BC(a1, a2, v27);
  if (v24)
  {
    sub_10004D2C8(v24);
    sub_10004D2C8(v24);
  }
  return v25;
}

void sub_100254060(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100254090(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, char a6, int a7)
{
  unsigned int v9 = a3;
  *(_DWORD *)(a1 + 160) = a3;
  *(_DWORD *)(a1 + 148) = a4;
  *(_DWORD *)(a1 + 152) = a7;
  *(unsigned char *)(a1 + 156) = a6;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  sub_100253390(&v34, 1, 4);
  uint8_t v12 = v34;
  int v13 = (const void *)*((void *)v34 + 6);
  if (v13) {
  else
  }
    unint64_t v14 = 0;
  BOOL v15 = a7 != 2;
  if (v9 >= 9) {
    LOBYTE(v9) = 6;
  }
  BOOL v17 = (unsigned char *)v14[3];
  unint64_t v16 = v14[4];
  if ((unint64_t)v17 >= v16)
  {
    uint64_t v19 = (unsigned char *)v14[2];
    unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * (v17 - v19);
    unint64_t v21 = v20 + 1;
    if (v20 + 1 >= 0x5555555555555556) {
      sub_10006A748();
    }
    unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * (v16 - (void)v19);
    if (2 * v22 > v21) {
      unint64_t v21 = 2 * v22;
    }
    BOOL v23 = v22 >= 0x2AAAAAAAAAAAAAAALL;
    unint64_t v24 = 0x5555555555555555;
    if (!v23) {
      unint64_t v24 = v21;
    }
    if (v24)
    {
      unint64_t v24 = (unint64_t)sub_100255BD4(v24);
      uint64_t v19 = (unsigned char *)v14[2];
      BOOL v17 = (unsigned char *)v14[3];
    }
    else
    {
      uint64_t v25 = 0;
    }
    uint64_t v26 = (unsigned char *)(v24 + 3 * v20);
    *uint64_t v26 = a6;
    unint64_t v27 = v24 + 3 * v25;
    v26[1] = v15;
    v26[2] = v9;
    unint64_t v18 = v26 + 3;
    if (v17 != v19)
    {
      do
      {
        __int16 v28 = *(_WORD *)(v17 - 3);
        v17 -= 3;
        char v29 = v17[2];
        *(_WORD *)(v26 - 3) = v28;
        v26 -= 3;
        v26[2] = v29;
      }
      while (v17 != v19);
      uint64_t v19 = (unsigned char *)v14[2];
    }
    v14[2] = v26;
    uint64_t v14[3] = v18;
    v14[4] = v27;
    if (v19) {
      operator delete(v19);
    }
  }
  else
  {
    unsigned char *v17 = a6;
    v17[1] = v15;
    unint64_t v18 = v17 + 3;
    v17[2] = v9;
  }
  uint64_t v14[3] = v18;
  id v30 = (std::__shared_weak_count *)v35;
  v33[0] = v12;
  v33[1] = (CapSuppServicesInfo *)v35;
  if (v35) {
    atomic_fetch_add_explicit(v35 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v31 = sub_1002535BC(a1, a2, v33);
  if (v30)
  {
    sub_10004D2C8(v30);
    sub_10004D2C8(v30);
  }
  return v31;
}

void sub_10025429C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002542CC()
{
  return 0;
}

uint64_t sub_1002542D4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fetchCallWaiting", buf, 2u);
  }
  sub_100058DB0(buf, "SupportsCW");
  CFBooleanRef v15 = kCFBooleanTrue;
  if (kCFBooleanTrue) {
    CFRetain(kCFBooleanTrue);
  }
  sub_100254598((uint64_t)&v20, a2, (Registry **)(a1 + 48));
  uint64_t v7 = v20;
  LOBYTE(v19) = 0;
  if (v20 && (CFTypeID v8 = CFGetTypeID(v20), v8 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v19, v7, v9);
    BOOL v10 = (_BYTE)v19 == 0;
  }
  else
  {
    BOOL v10 = 1;
  }
  sub_1000577C4((const void **)&v20);
  sub_1000577C4((const void **)&v15);
  if (v18 < 0)
  {
    operator delete(*(void **)buf);
    if (v10)
    {
LABEL_11:
      *(void *)long long buf = 0;
      BOOL v17 = 0;
      sub_10003E168(buf, (void *)(a1 + 8));
      operator new();
    }
  }
  else if (v10)
  {
    goto LABEL_11;
  }
  *(_DWORD *)(a1 + 164) = a3;
  *(void *)long long buf = 0;
  BOOL v17 = 0;
  sub_100253390(buf, 0, 0);
  unsigned int v11 = (std::__shared_weak_count *)v17;
  v14[0] = *(CapSuppServicesInfo **)buf;
  v14[1] = (CapSuppServicesInfo *)v17;
  if (v17) {
    atomic_fetch_add_explicit(v17 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = sub_1002535BC(a1, a2, v14);
  if (v11)
  {
    sub_10004D2C8(v11);
    sub_10004D2C8(v11);
  }
  return v12;
}

void sub_100254540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (v18)
  {
    sub_10004D2C8(v18);
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100254598(uint64_t a1, uint64_t a2, Registry **a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a3);
  unsigned int v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v5;
  CFBooleanRef v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (v9)
  {
    uint64_t v11 = v9[3];
    BOOL v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  BOOL v10 = 0;
  char v12 = 1;
LABEL_9:
  PersonalityIdFromSlotId();
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v11 + 40))(&v15, v11, __p);
  (*(void (**)(void))(*(void *)v15 + 40))();
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v14 < 0)
  {
    operator delete(__p[0]);
    if (v12) {
      return;
    }
  }
  else if (v12)
  {
    return;
  }
  sub_10004D2C8(v10);
}

void sub_100254748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100254790(uint64_t a1, uint64_t a2, char a3, int a4, int a5)
{
  BOOL v10 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I setCallWaiting", buf, 2u);
  }
  sub_100058DB0(buf, "SupportsCW");
  CFBooleanRef v20 = kCFBooleanTrue;
  if (kCFBooleanTrue) {
    CFRetain(kCFBooleanTrue);
  }
  sub_100254598((uint64_t)&cf, a2, (Registry **)(a1 + 48));
  uint64_t v11 = (BOOL *)cf;
  LOBYTE(v24) = 0;
  if (cf && (CFTypeID v12 = CFGetTypeID(cf), v12 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v24, v11, v13);
    BOOL v14 = (_BYTE)v24 == 0;
  }
  else
  {
    BOOL v14 = 1;
  }
  sub_1000577C4(&cf);
  sub_1000577C4((const void **)&v20);
  if (v23 < 0)
  {
    operator delete(*(void **)buf);
    if (v14)
    {
LABEL_11:
      *(void *)long long buf = 0;
      unint64_t v22 = 0;
      sub_10003E168(buf, (void *)(a1 + 8));
      operator new();
    }
  }
  else if (v14)
  {
    goto LABEL_11;
  }
  *(void *)long long buf = 0;
  unint64_t v22 = 0;
  sub_100253390(buf, 1, 0);
  uint64_t v15 = *(CapSuppServicesInfo **)buf;
  *(unsigned char *)(a1 + 172) = a3;
  *(_DWORD *)(a1 + 164) = a4;
  *(_DWORD *)(a1 + 168) = a5;
  unint64_t v16 = (std::__shared_weak_count *)v22;
  v19[0] = v15;
  v19[1] = (CapSuppServicesInfo *)v22;
  if (v22) {
    atomic_fetch_add_explicit(v22 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = sub_1002535BC(a1, a2, v19);
  if (v16)
  {
    sub_10004D2C8(v16);
    sub_10004D2C8(v16);
  }
  return v17;
}

void sub_100254A60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  if (v21)
  {
    sub_10004D2C8(v21);
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100254AB8(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fetchCLIR", buf, 2u);
  }
  sub_100058DB0(buf, "SupportsCLIR");
  CFBooleanRef v18 = kCFBooleanTrue;
  if (kCFBooleanTrue) {
    CFRetain(kCFBooleanTrue);
  }
  sub_100254598((uint64_t)&v23, a2, (Registry **)(a1 + 48));
  uint64_t v5 = v23;
  LOBYTE(v22) = 0;
  if (v23)
  {
    CFTypeID v6 = CFGetTypeID(v23);
    if (v6 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)&v22, v5, v7);
    }
  }
  int v8 = v22;
  sub_1000577C4((const void **)&v23);
  sub_1000577C4((const void **)&v18);
  if (v21 < 0) {
    operator delete(*(void **)buf);
  }
  sub_100058DB0(buf, "DisableCLIRModification");
  CFBooleanRef v17 = kCFBooleanFalse;
  if (kCFBooleanFalse) {
    CFRetain(kCFBooleanFalse);
  }
  sub_100254598((uint64_t)&v23, a2, (Registry **)(a1 + 48));
  CFBooleanRef v9 = v23;
  LOBYTE(v22) = 0;
  if (v23 && (CFTypeID v10 = CFGetTypeID(v23), v10 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v22, v9, v11);
    int v12 = v22;
  }
  else
  {
    int v12 = 0;
  }
  sub_1000577C4((const void **)&v23);
  sub_1000577C4((const void **)&v17);
  if (v21 < 0)
  {
    operator delete(*(void **)buf);
    if (!v8) {
      goto LABEL_25;
    }
  }
  else if (!v8)
  {
LABEL_25:
    *(void *)long long buf = 0;
    CFBooleanRef v20 = 0;
    sub_10003E168(buf, (void *)(a1 + 8));
    operator new();
  }
  if (v12) {
    goto LABEL_25;
  }
  *(void *)long long buf = 0;
  CFBooleanRef v20 = 0;
  sub_100253390(buf, 0, 3);
  CFBooleanRef v13 = (std::__shared_weak_count *)v20;
  v16[0] = *(CapSuppServicesInfo **)buf;
  v16[1] = (CapSuppServicesInfo *)v20;
  if (v20) {
    atomic_fetch_add_explicit(v20 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = sub_1002535BC(a1, a2, v16);
  if (v13)
  {
    sub_10004D2C8(v13);
    sub_10004D2C8(v13);
  }
  return v14;
}

void sub_100254DB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (v21)
  {
    sub_10004D2C8(v21);
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100254E30(uint64_t a1, uint64_t a2, int a3)
{
  CFTypeID v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  CFBooleanRef v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I setCLIR", buf, 2u);
  }
  sub_100058DB0(buf, "SupportsCLIR");
  CFBooleanRef v26 = kCFBooleanTrue;
  if (kCFBooleanTrue) {
    CFRetain(kCFBooleanTrue);
  }
  sub_100254598((uint64_t)&cf, a2, (Registry **)(a1 + 48));
  int v8 = (BOOL *)cf;
  unsigned __int8 v28 = 0;
  if (cf)
  {
    CFTypeID v9 = CFGetTypeID(cf);
    if (v9 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)&v28, v8, v10);
    }
  }
  int v11 = v28;
  sub_1000577C4(&cf);
  sub_1000577C4((const void **)&v26);
  if (v30 < 0) {
    operator delete(*(void **)buf);
  }
  sub_100058DB0(buf, "NetworkSupportsCLIRModification");
  CFBooleanRef v25 = kCFBooleanFalse;
  if (kCFBooleanFalse) {
    CFRetain(kCFBooleanFalse);
  }
  sub_100254598((uint64_t)&cf, a2, (Registry **)(a1 + 48));
  int v12 = (BOOL *)cf;
  unsigned __int8 v28 = 0;
  if (cf && (CFTypeID v13 = CFGetTypeID(cf), v13 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v28, v12, v14);
    BOOL v15 = v28 == 0;
  }
  else
  {
    BOOL v15 = 1;
  }
  sub_1000577C4(&cf);
  sub_1000577C4((const void **)&v25);
  if (v30 < 0) {
    operator delete(*(void **)buf);
  }
  if (v11) {
    char v16 = v15;
  }
  else {
    char v16 = 1;
  }
  if (v16)
  {
    CFBooleanRef v17 = *v6;
    uint64_t v18 = 0;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = "Yes";
      if (v11) {
        CFBooleanRef v20 = "Yes";
      }
      else {
        CFBooleanRef v20 = "No";
      }
      if (v15) {
        uint64_t v19 = "No";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v20;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v19;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Cannot send CLIR (Set) request over XCAP. SupportsCLIR:%s, NetworkSupportsCLIRModification:%s", buf, 0x16u);
      return 0;
    }
  }
  else
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_100253390(buf, 1, 3);
    char v21 = *(CapSuppServicesInfo **)buf;
    *(_DWORD *)(a1 + 180) = a3;
    uint64_t v22 = *(std::__shared_weak_count **)&buf[8];
    v24[0] = v21;
    v24[1] = *(CapSuppServicesInfo **)&buf[8];
    if (*(void *)&buf[8]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v18 = sub_1002535BC(a1, a2, v24);
    if (v22)
    {
      sub_10004D2C8(v22);
      sub_10004D2C8(v22);
    }
  }
  return v18;
}

void sub_100255184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (v26)
  {
    sub_10004D2C8(v26);
    sub_10004D2C8(v26);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10025520C(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fetchCLIP", buf, 2u);
  }
  *(void *)long long buf = 0;
  CFBooleanRef v10 = 0;
  sub_100253390(buf, 0, 2);
  uint64_t v5 = (std::__shared_weak_count *)v10;
  v8[0] = *(CapSuppServicesInfo **)buf;
  v8[1] = (CapSuppServicesInfo *)v10;
  if (v10) {
    atomic_fetch_add_explicit(v10 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = sub_1002535BC(a1, a2, v8);
  if (v5)
  {
    sub_10004D2C8(v5);
    sub_10004D2C8(v5);
  }
  return v6;
}

void sub_1002552FC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10025531C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I setCLIP - Value:%d", buf, 8u);
  }
  *(void *)long long buf = 0;
  CFTypeID v13 = 0;
  sub_100253390(buf, 1, 2);
  CFBooleanRef v7 = *(CapSuppServicesInfo **)buf;
  *(_DWORD *)(a1 + 176) = a3;
  int v8 = (std::__shared_weak_count *)v13;
  v11[0] = v7;
  v11[1] = (CapSuppServicesInfo *)v13;
  if (v13) {
    atomic_fetch_add_explicit(v13 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = sub_1002535BC(a1, a2, v11);
  if (v8)
  {
    sub_10004D2C8(v8);
    sub_10004D2C8(v8);
  }
  return v9;
}

void sub_1002554A0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002554C8()
{
  return 0;
}

uint64_t sub_1002554D0()
{
  return 0;
}

void sub_1002554D8(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "No";
    if (a3) {
      uint64_t v5 = "Yes";
    }
    int v7 = 136315138;
    int v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I IMSSuppServicesCommandDriver::setAutoAnswerMode - Enabled:%s", (uint8_t *)&v7, 0xCu);
  }
  uint64_t v6 = (CFPropertyListRef *)&kCFBooleanTrue;
  if (!a3) {
    uint64_t v6 = (CFPropertyListRef *)&kCFBooleanFalse;
  }
  CFPreferencesSetValue(@"enableAutoAnswer", *v6, @"com.apple.ipTelephony", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
}

void sub_1002555FC(uint64_t a1, uint64_t a2)
{
  sub_1002572E8(&v2, a2);
}

uint64_t IMSSuppServicesCommandDriver::determineCurrentRadioMode(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v24 = v6;
  CFBooleanRef v10 = sub_10004D37C(&v5[1].__m_.__sig, &v24);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    int v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_23;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  int v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12) {
    goto LABEL_23;
  }
LABEL_10:
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 232))(v12, a2, 0x100000) & 0xFF00000000) != 0)
  {
    uint64_t v16 = *(void *)(a1 + 232);
    uint64_t v15 = a1 + 232;
    uint64_t v14 = v16;
    if (v16)
    {
      uint64_t v17 = v15;
      do
      {
        int v18 = *(_DWORD *)(v14 + 28);
        BOOL v19 = v18 < (int)a2;
        if (v18 >= (int)a2) {
          CFBooleanRef v20 = (uint64_t *)v14;
        }
        else {
          CFBooleanRef v20 = (uint64_t *)(v14 + 8);
        }
        if (!v19) {
          uint64_t v17 = v14;
        }
        uint64_t v14 = *v20;
      }
      while (*v20);
      if (v17 != v15 && *(_DWORD *)(v17 + 28) <= (int)a2)
      {
        int v21 = *(_DWORD *)(v17 + 32) - 3;
        if (v21 < 0xF)
        {
          uint64_t v22 = dword_101476E8C[v21];
          goto LABEL_24;
        }
      }
    }
  }
LABEL_23:
  uint64_t v22 = 0;
LABEL_24:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  return v22;
}

void sub_1002557D0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002557EC(uint64_t a1, const void **a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 40);
      if (v6)
      {
        uint64_t v7 = *(unsigned int *)(*(void *)(a1 + 24) + 52);
        sub_100058198(&v10, a2);
        sub_100250E08(v6, v7, (const __CFDictionary **)&v10);
        sub_100057D78(&v10);
LABEL_9:
        sub_10004D2C8(v5);
        return;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v8 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)unsigned int v9 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to get reference to Controller while handling XCAP request completion", v9, 2u);
  }
  if (v5) {
    goto LABEL_9;
  }
}

void sub_1002558C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void *sub_1002558DC(void *a1)
{
  *a1 = off_1019AFE28;
  char v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    sub_10004D2C8(v3);
  }
  unsigned int v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_100255944(void *a1)
{
  sub_1002558DC(a1);

  operator delete();
}

unsigned char *sub_10025597C(uint64_t a1, __int16 *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  __int16 v4 = *a2;
  *(unsigned char *)(v3 + 2) = *((unsigned char *)a2 + 2);
  *(_WORD *)uint64_t v3 = v4;
  __n128 result = (unsigned char *)(v3 + 8);
  if (*((char *)a2 + 31) < 0)
  {
    __n128 result = sub_10004FC84(result, *((void **)a2 + 1), *((void *)a2 + 2));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 4);
    *(void *)(v3 + 24) = *((void *)a2 + 3);
    *(_OWORD *)__n128 result = v6;
  }
  *(void *)(a1 + 8) = v3 + 32;
  return result;
}

void sub_1002559E8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

char *sub_1002559F0(unint64_t *a1, uint64_t a2)
{
  unint64_t v3 = *a1;
  unint64_t v2 = a1[1];
  uint64_t v4 = (uint64_t)(v2 - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    sub_10006A748();
  }
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v24 = a1 + 2;
  if (v9)
  {
    if (v9 >> 59) {
      sub_10006A7CC();
    }
    CFBooleanRef v10 = (char *)operator new(32 * v9);
  }
  else
  {
    CFBooleanRef v10 = 0;
  }
  int v11 = &v10[32 * v4];
  int v21 = v10;
  v22.i64[0] = (uint64_t)v11;
  v22.i64[1] = (uint64_t)v11;
  char v23 = &v10[32 * v9];
  *(_WORD *)int v11 = *(_WORD *)a2;
  v11[2] = *(unsigned char *)(a2 + 2);
  uint64_t v12 = v11 + 8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84(v12, *(void **)(a2 + 8), *(void *)(a2 + 16));
    unint64_t v3 = *a1;
    unint64_t v2 = a1[1];
    char v13 = (char *)v22.i64[1];
    int v11 = (char *)v22.i64[0];
  }
  else
  {
    *(_OWORD *)uint64_t v12 = *(_OWORD *)(a2 + 8);
    *((void *)v11 + 3) = *(void *)(a2 + 24);
    char v13 = v11;
  }
  if (v2 == v3)
  {
    int64x2_t v17 = vdupq_n_s64(v3);
  }
  else
  {
    do
    {
      __int16 v14 = *(_WORD *)(v2 - 32);
      v2 -= 32;
      char v15 = *(unsigned char *)(v2 + 2);
      *((_WORD *)v11 - 16) = v14;
      v11 -= 32;
      v11[2] = v15;
      long long v16 = *(_OWORD *)(v2 + 8);
      *((void *)v11 + 3) = *(void *)(v2 + 24);
      *(_OWORD *)(v11 + 8) = v16;
      *(void *)(v2 + 16) = 0;
      *(void *)(v2 + 24) = 0;
      *(void *)(v2 + 8) = 0;
    }
    while (v2 != v3);
    int64x2_t v17 = *(int64x2_t *)a1;
  }
  int v18 = v13 + 32;
  *a1 = (unint64_t)v11;
  a1[1] = (unint64_t)(v13 + 32);
  int64x2_t v22 = v17;
  unint64_t v19 = a1[2];
  a1[2] = (unint64_t)v23;
  char v23 = (char *)v19;
  int v21 = (char *)v17.i64[0];
  sub_100255B70((uint64_t)&v21);
  return v18;
}

void sub_100255B5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100255B70((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100255B70(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 32;
      *(void *)(a1 + 16) = v2 - 32;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_100255BD4(unint64_t a1)
{
  if (a1 >= 0x5555555555555556) {
    sub_10006A7CC();
  }
  return operator new(3 * a1);
}

uint64_t sub_100255C14(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 40;
      *(void *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 9) < 0)
      {
        operator delete(*(void **)(v2 - 32));
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100255C78(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100255D44(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100255E1C);
  __cxa_rethrow();
}

void sub_100255D6C(_Unwind_Exception *a1)
{
}

void sub_100255D84(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100255DBC(uint64_t a1)
{
}

uint64_t sub_100255DD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100255E1C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100255E4C()
{
}

uint64_t sub_100255E60(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_100255E6C(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  unint64_t v9 = v1;
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v4 = v1[2];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v5 = *(std::__shared_weak_count **)(v3 + 72);
  *(void *)(v3 + 64) = v2;
  *(void *)(v3 + 72) = v4;
  if (v5) {
    sub_10004D2C8(v5);
  }
  Registry::createRestModuleOneTimeUseConnection(&v10, *(Registry **)(v3 + 48));
  ctu::RestModule::connect();
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_100058DB0(&__p, "/cc/props/ims_client_state");
  long long v6 = operator new(0x28uLL);
  void *v6 = off_1019AFF90;
  v6[1] = v3 + 200;
  void v6[2] = v3;
  v6[3] = sub_1002504B4;
  void v6[4] = 0;
  uint64_t v14[3] = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(v14);
  if (v13 < 0) {
    operator delete(__p);
  }
  sub_100256070(v3 + 224);
  sub_100256004((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100255FAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100256004(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100256004(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    uint64_t v2 = *(NSObject **)(v1 + 24);
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = *(NSObject **)(v1 + 24);
      if (v3) {
        dispatch_release(v3);
      }
    }
    uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
    if (v4) {
      sub_10004D2C8(v4);
    }
    operator delete();
  }
  return result;
}

void sub_100256070(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/reg_data_modes");
  v4[0] = off_1019B0010;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100256124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100256154()
{
}

__n128 sub_100256168(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019AFF90;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1002561BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019AFF90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1002561F4(void *a1, xpc_object_t *a2)
{
  char v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  int v11 = (char **)*v3;
  uint64_t v12 = (char *)v5;
  char v13 = (char *)v3[2];
  if (v13)
  {
    *(void *)(v5 + 16) = &v12;
    *char v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    int v11 = &v12;
  }
  sub_100256368((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  unint64_t v9 = v11;
  v10[0] = v12;
  v10[1] = v13;
  if (v13)
  {
    *((void *)v12 + 2) = v10;
    int v11 = &v12;
    uint64_t v12 = 0;
    char v13 = 0;
  }
  else
  {
    unint64_t v9 = v10;
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10[0]);
  sub_10005CD2C((uint64_t)&v11, v12);
}

void sub_1002562F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, char a12, char *a13)
{
}

uint64_t sub_10025631C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10025635C()
{
}

void sub_100256368(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_10005CD2C(a1, *(char **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v11, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v10, object, count);
    xpc_release(object[0]);
    for (i = v12; i != v10[1] || v11 != v10[0]; i = ++v12)
    {
      xpc_object_t v9 = 0;
      object[0] = &v11;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v9);
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
      {
        *(_OWORD *)dispatch_object_t object = 0u;
        long long v8 = 0u;
        xpc_object_t v6 = v9;
        if (v9) {
          xpc_retain(v9);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_100256610((uint64_t)object, &v6);
        xpc_release(v6);
        sub_10025675C((uint64_t **)a1, object, (uint64_t)object);
        if (SBYTE7(v8) < 0) {
          operator delete(object[0]);
        }
      }
      xpc_release(v9);
    }
    xpc_release(v11);
    xpc_release(v11);
  }
  xpc_release(v3);
}

void sub_10025656C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, xpc_object_t a19, xpc_object_t a20)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v21 - 48));
  xpc_release(v20);
  _Unwind_Resume(a1);
}

void sub_100256610(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v8 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v8 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v5 = &v8;
    xpc_object_t v6 = "first";
    sub_100048BAC((uint64_t)&v5, &object);
    read_rest_value();
    xpc_release(object);
    uint64_t v5 = &v8;
    xpc_object_t v6 = "second";
    sub_100048BAC((uint64_t)&v5, &object);
    *(unsigned char *)(a1 + 24) = xpc::dyn_cast_or_default((xpc *)&object, 0, v4);
    xpc_release(object);
    xpc_object_t v3 = v8;
  }
  xpc_release(v3);
}

void sub_100256708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12)
{
}

uint64_t *sub_10025675C(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v8, a2);
  __n128 result = *v5;
  if (!*v5)
  {
    memset(v7, 0, sizeof(v7));
    sub_1002567E8((uint64_t)a1, a3, v7);
    sub_100046C38(a1, v8, v5, v7[0]);
    return v7[0];
  }
  return result;
}

unsigned char *sub_1002567E8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  xpc_object_t v6 = a3 + 1;
  uint64_t v7 = (char *)operator new(0x40uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = v7 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__n128 result = *(_OWORD *)a2;
    *((void *)v7 + 6) = *(void *)(a2 + 16);
  }
  v7[56] = *(unsigned char *)(a2 + 24);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100256880(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

void sub_1002568A0()
{
}

void *sub_1002568B4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B0010;
  result[1] = v3;
  return result;
}

uint64_t sub_1002568FC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B0010;
  a2[1] = v2;
  return result;
}

void sub_100256928(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100256930(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100256970()
{
}

void sub_10025697C(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1000346F8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v10, object, 0);
    xpc_release(object[0]);
    *(void *)&long long v7 = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      *(void *)&long long v7 = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(object, (void **)&v7, count);
    xpc_release((xpc_object_t)v7);
    for (i = v11; i != object[1] || v10 != object[0]; i = ++v11)
    {
      *((void *)&v7 + 1) = i;
      xpc_object_t v8 = 0;
      *(void *)&long long v7 = &v10;
      sub_10003FBDC((uint64_t)&v7, &v8);
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        LODWORD(v7) = 0;
        *(void *)((char *)&v7 + 4) = -1;
        xpc_object_t v6 = v8;
        if (v8) {
          xpc_retain(v8);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_100256C0C((int *)&v7, &v6);
        xpc_release(v6);
        sub_100256DC0((uint64_t **)a1, (int *)&v7, (uint64_t)&v7);
      }
      xpc_release(v8);
    }
    xpc_release(v10);
    xpc_release(v10);
  }
  xpc_release(v3);
}

void sub_100256B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12, xpc_object_t a13, uint64_t a14, xpc_object_t a15)
{
  xpc_release(object);
  xpc_release(a15);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_100256C0C(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    long long v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v6 = &v9;
    long long v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    rest::read_rest_value();
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_100256D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

uint64_t **sub_100256DC0(uint64_t **a1, int *a2, uint64_t a3)
{
  xpc_object_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        xpc_object_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        xpc_object_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        xpc_object_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    xpc_object_t v8 = a1 + 1;
LABEL_10:
    int v10 = operator new(0x28uLL);
    v10[7] = *(_DWORD *)a3;
    *((void *)v10 + 4) = *(void *)(a3 + 4);
    sub_100046C38(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t **sub_100256E84(uint64_t **a1, int a2, _DWORD *a3)
{
  xpc_object_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        xpc_object_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        xpc_object_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v7 = a1 + 1;
LABEL_9:
    int v9 = (uint64_t *)v7;
    int v7 = (uint64_t **)operator new(0x38uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[5] = 0;
    v7[6] = 0;
    *int v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    xpc_object_t *v6 = (uint64_t *)v7;
    int v10 = (uint64_t *)**a1;
    int v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      int v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_100256F54(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B0090;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100256F74(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B0090;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100256FC8(uint64_t a1)
{
}

void sub_100256FD4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  xpc_object_t v3 = *(NSObject **)(*a1)[2];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Reporting persisted CW setting since network doesn't support CW over XCAP", buf, 2u);
  }
  char v4 = (*(uint64_t (**)(void, void, uint64_t))(**(void **)(v2 + 64) + 128))(*(void *)(v2 + 64), *((unsigned int *)v1 + 2), 1);
  uint64_t v5 = (std::__shared_weak_count *)operator new(0x20uLL);
  v5->__shared_weak_owners_ = 0;
  v5->__shared_owners_ = 0;
  LOBYTE(v5[1].__vftable) = v4;
  v5->__vftable = (std::__shared_weak_count_vtbl *)off_1019B00E0;
  uint64_t v6 = *(void *)(v2 + 64);
  uint64_t v7 = *((unsigned int *)v1 + 2);
  uint64_t v8 = *((unsigned int *)v1 + 3);
  *(void *)long long buf = v5 + 1;
  int v10 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *))(*(void *)v6 + 96))(v6, v7, v8, buf);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v5);
  operator delete();
}

void sub_10025712C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v12);
  operator delete();
}

void sub_100257174(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B00E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100257194(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B00E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1002571F0(uint64_t **a1)
{
  char v4 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  xpc_object_t v3 = *(NSObject **)(*a1)[3];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Setting CW locally since network doesn't support it over XCAP", buf, 2u);
  }
  (*(void (**)(void, void, void, void, void))(**(void **)(v2 + 64) + 112))(*(void *)(v2 + 64), *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 4), *((unsigned int *)v1 + 5), *((unsigned __int8 *)v1 + 12));
  operator delete();
}

void sub_1002572BC()
{
}

void sub_1002572E8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100257350(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_10025737C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002573B4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_1002573D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100257418(uint64_t a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = **(NSObject ***)(*(void *)a1 + 16);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Report default CLIR setting as fetching from network has been disabled or is not supported", buf, 2u);
  }
  *(void *)long long buf = 0;
  uint64_t v4 = 0;
  operator new();
}

void sub_100257558(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  operator delete();
}

void sub_1002575A8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002575E0(uint64_t result)
{
  if (*(void *)(result + 24))
  {
    uint64_t v1 = *(void ***)(result + 24);
    sub_100257690(&v1);
    operator delete();
  }
  return result;
}

uint64_t sub_10025764C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100257690(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 9) < 0) {
          operator delete(*(v4 - 4));
        }
        v4 -= 5;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ***sub_10025771C(void ***result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = v1;
    sub_100257690(&v2);
    operator delete();
  }
  return result;
}

void sub_100257790(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002577C8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_1002577E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100257830(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100257868(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_100257888(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1002578CC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B0310;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002578EC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B0310;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100257940(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100257970(uint64_t a1)
{
  xpc_object_t v23 = 0;
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t v23 = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v23 = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  xpc_object_t v23 = v4;
LABEL_9:
  xpc_release(v3);
  if (*(char *)(a1 + 23) >= 0) {
    uint64_t v5 = (const char *)a1;
  }
  else {
    uint64_t v5 = *(const char **)a1;
  }
  xpc_object_t v6 = xpc_string_create(v5);
  int64x2_t v22 = v6;
  if (!v6)
  {
    xpc_object_t v6 = xpc_null_create();
    int64x2_t v22 = v6;
  }
  sub_100257C70((uint64_t)&v23, @"kCTIndicatorsStateDumpFolderPrefix", &v22);
  xpc_release(v6);
  int64x2_t v22 = 0;
  if (*(char *)(a1 + 47) >= 0) {
    uint64_t v7 = (const char *)(a1 + 24);
  }
  else {
    uint64_t v7 = *(const char **)(a1 + 24);
  }
  xpc_object_t v8 = xpc_string_create(v7);
  uint64_t v21 = v8;
  if (!v8)
  {
    xpc_object_t v8 = xpc_null_create();
    uint64_t v21 = v8;
  }
  sub_100257C70((uint64_t)&v23, @"kCTIndicatorsStateSnapshotFolderPath", &v21);
  xpc_release(v8);
  uint64_t v21 = 0;
  xpc_object_t v9 = xpc_BOOL_create(*(unsigned char *)(a1 + 48));
  CFBooleanRef v20 = v9;
  if (!v9)
  {
    xpc_object_t v9 = xpc_null_create();
    CFBooleanRef v20 = v9;
  }
  sub_100257C70((uint64_t)&v23, @"kCTIndicatorsStateDumpLogFilter", &v20);
  xpc_release(v9);
  CFBooleanRef v20 = 0;
  uint64_t v12 = *(const char **)(a1 + 56);
  uint64_t v11 = a1 + 56;
  int v10 = v12;
  if (*(char *)(v11 + 23) >= 0) {
    char v13 = (const char *)v11;
  }
  else {
    char v13 = v10;
  }
  xpc_object_t v14 = xpc_string_create(v13);
  unint64_t v19 = v14;
  if (!v14)
  {
    xpc_object_t v14 = xpc_null_create();
    unint64_t v19 = v14;
  }
  sub_100257C70((uint64_t)&v23, @"kCTIndicatorsStateDumpReason", &v19);
  xpc_release(v14);
  xpc_object_t v15 = v23;
  xpc_object_t v18 = v23;
  unint64_t v19 = 0;
  if (v23)
  {
    xpc_retain(v23);
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
    xpc_object_t v18 = v15;
  }
  xpc_object_t v16 = xpc_null_create();
  xpc_object_t v17 = v16;
  sub_1000452AC(121, &v18, &v17);
  xpc_release(v16);
  xpc_release(v15);
  xpc_release(v23);
}

void sub_100257BA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  xpc_object_t v17 = v14;
  xpc_release(v17);
  xpc_release(v15);
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_100257C70(uint64_t a1, uint64_t a2, void **a3)
{
  long long v11 = 0uLL;
  uint64_t v12 = 0;
  ctu::cf::assign();
  *(_OWORD *)long long __p = 0uLL;
  uint64_t v10 = 0;
  uint64_t v5 = *a3;
  xpc_object_t v7 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_object_t v6 = __p;
  if (v10 < 0) {
    xpc_object_t v6 = (void **)__p[0];
  }
  *(void *)&long long v11 = a1;
  *((void *)&v11 + 1) = v6;
  sub_100035E70((uint64_t)&v11, &v7, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v7);
  xpc_object_t v7 = 0;
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100257D34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100257D50(uint64_t a1)
{
  xpc_object_t v23 = 0;
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t v23 = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v23 = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  xpc_object_t v23 = v4;
LABEL_9:
  xpc_release(v3);
  if (*(char *)(a1 + 23) >= 0) {
    uint64_t v5 = (const char *)a1;
  }
  else {
    uint64_t v5 = *(const char **)a1;
  }
  xpc_object_t v6 = xpc_string_create(v5);
  int64x2_t v22 = v6;
  if (!v6)
  {
    xpc_object_t v6 = xpc_null_create();
    int64x2_t v22 = v6;
  }
  sub_100257C70((uint64_t)&v23, @"kCTIndicatorsStateDumpFolderPrefix", &v22);
  xpc_release(v6);
  int64x2_t v22 = 0;
  if (*(char *)(a1 + 47) >= 0) {
    xpc_object_t v7 = (const char *)(a1 + 24);
  }
  else {
    xpc_object_t v7 = *(const char **)(a1 + 24);
  }
  xpc_object_t v8 = xpc_string_create(v7);
  uint64_t v21 = v8;
  if (!v8)
  {
    xpc_object_t v8 = xpc_null_create();
    uint64_t v21 = v8;
  }
  sub_100257C70((uint64_t)&v23, @"kCTIndicatorsStateSnapshotFolderPath", &v21);
  xpc_release(v8);
  uint64_t v21 = 0;
  xpc_object_t v9 = xpc_BOOL_create(*(unsigned char *)(a1 + 48));
  CFBooleanRef v20 = v9;
  if (!v9)
  {
    xpc_object_t v9 = xpc_null_create();
    CFBooleanRef v20 = v9;
  }
  sub_100257C70((uint64_t)&v23, @"kCTIndicatorsStateDumpLogFilter", &v20);
  xpc_release(v9);
  CFBooleanRef v20 = 0;
  uint64_t v12 = *(const char **)(a1 + 56);
  uint64_t v11 = a1 + 56;
  uint64_t v10 = v12;
  if (*(char *)(v11 + 23) >= 0) {
    char v13 = (const char *)v11;
  }
  else {
    char v13 = v10;
  }
  xpc_object_t v14 = xpc_string_create(v13);
  unint64_t v19 = v14;
  if (!v14)
  {
    xpc_object_t v14 = xpc_null_create();
    unint64_t v19 = v14;
  }
  sub_100257C70((uint64_t)&v23, @"kCTIndicatorsStateDumpReason", &v19);
  xpc_release(v14);
  xpc_object_t v15 = v23;
  xpc_object_t v18 = v23;
  unint64_t v19 = 0;
  if (v23)
  {
    xpc_retain(v23);
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
    xpc_object_t v18 = v15;
  }
  xpc_object_t v16 = xpc_null_create();
  xpc_object_t v17 = v16;
  sub_1000452AC(122, &v18, &v17);
  xpc_release(v16);
  xpc_release(v15);
  xpc_release(v23);
}

void sub_100257F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  xpc_object_t v17 = v14;
  xpc_release(v17);
  xpc_release(v15);
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_100258050(std::string *__str)
{
  memset(&v12, 0, sizeof(v12));
  if (__str)
  {
    std::string::operator=(&v12, __str);
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str->__r_.__value_.__l.__data_);
    }
    operator delete();
  }
  std::string::append(&v12, " (State Dump Skipped!)", 0x16uLL);
  uint64_t v11 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  *(_OWORD *)xpc_object_t v8 = 0u;
  sub_10044AB4C((uint64_t)&v7);
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  long long v4 = 0u;
  memset(v3, 0, sizeof(v3));
  sub_10044ACC4((unsigned __int16 *)&v7, &__stra);
  std::string::operator=((std::string *)v3, &__stra);
  if (SHIBYTE(__stra.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__stra.__r_.__value_.__l.__data_);
  }
  std::string::operator=((std::string *)&__p[1], &v12);
  LOBYTE(__p[0]) = 1;
  sub_10003ECB8((std::string *)&v3[24], "/var/wireless/Library/Logs/CrashReporter/Baseband/", 0x32uLL);
  usleep(0x3D090u);
  sub_100257970((uint64_t)v3);
  usleep(0x3D090u);
  sub_100257D50((uint64_t)v3);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v4) < 0) {
    operator delete(*(void **)&v3[24]);
  }
  if ((v3[23] & 0x80000000) != 0) {
    operator delete(*(void **)v3);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(*((void **)&v9 + 1));
  }
  if (SBYTE7(v9) < 0) {
    operator delete(v8[0]);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
}

void sub_1002581DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10019693C((uint64_t)&a16);
  sub_10008AF64((uint64_t)&a26);
  if (*(char *)(v26 - 17) < 0) {
    operator delete(*(void **)(v26 - 40));
  }
  _Unwind_Resume(a1);
}

void sub_100258234()
{
  xpc_object_t v0 = xpc_null_create();
  xpc_object_t v3 = v0;
  xpc_object_t v1 = xpc_null_create();
  xpc_object_t v2 = v1;
  sub_1000452AC(118, &v3, &v2);
  xpc_release(v1);
  xpc_release(v0);
}

void sub_1002582A0(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_1002582CC()
{
  xpc_object_t v0 = xpc_null_create();
  xpc_object_t v3 = v0;
  xpc_object_t v1 = xpc_null_create();
  xpc_object_t v2 = v1;
  sub_1000452AC(119, &v3, &v2);
  xpc_release(v1);
  xpc_release(v0);
}

void sub_100258338(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_100258364()
{
  xpc_object_t v0 = xpc_null_create();
  xpc_object_t v3 = v0;
  xpc_object_t v1 = xpc_null_create();
  xpc_object_t v2 = v1;
  sub_1000452AC(120, &v3, &v2);
  xpc_release(v1);
  xpc_release(v0);
}

void sub_1002583D0(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_1002583FC()
{
  xpc_object_t v0 = xpc_null_create();
  xpc_object_t v3 = v0;
  xpc_object_t v1 = xpc_null_create();
  xpc_object_t v2 = v1;
  sub_1000452AC(126, &v3, &v2);
  xpc_release(v1);
  xpc_release(v0);
}

void sub_100258468(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_100258494()
{
  xpc_object_t v0 = xpc_null_create();
  xpc_object_t v3 = v0;
  xpc_object_t v1 = xpc_null_create();
  xpc_object_t v2 = v1;
  sub_1000452AC(62, &v3, &v2);
  xpc_release(v1);
  xpc_release(v0);
}

void sub_100258500(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_10025852C(int a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t object = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t object = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  xpc_object_t object = v4;
LABEL_9:
  xpc_release(v3);
  xpc_object_t v5 = xpc_int64_create(a1);
  long long v10 = v5;
  if (!v5)
  {
    xpc_object_t v5 = xpc_null_create();
    long long v10 = v5;
  }
  sub_100257C70((uint64_t)&object, @"kCTRadioVoiceLinkQualityKey", &v10);
  xpc_release(v5);
  xpc_object_t v6 = object;
  xpc_object_t v9 = object;
  long long v10 = 0;
  if (object)
  {
    xpc_retain(object);
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v9 = v6;
  }
  xpc_object_t v7 = xpc_null_create();
  xpc_object_t v8 = v7;
  sub_1000452AC(138, &v9, &v8);
  xpc_release(v7);
  xpc_release(v6);
  xpc_release(object);
}

void sub_10025866C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  xpc_object_t v14 = v13;
  xpc_release(v14);
  xpc_release(v12);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_1002586D4(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t object = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t object = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  xpc_object_t object = v4;
LABEL_9:
  xpc_release(v3);
  xpc_object_t v5 = xpc_data_create(*(const void **)a1, *(void *)(a1 + 8) - *(void *)a1);
  long long v10 = v5;
  if (!v5)
  {
    xpc_object_t v5 = xpc_null_create();
    long long v10 = v5;
  }
  sub_100257C70((uint64_t)&object, @"kCTRadioEnhancedVoiceLinkQualityKey", &v10);
  xpc_release(v5);
  xpc_object_t v6 = object;
  xpc_object_t v9 = object;
  long long v10 = 0;
  if (object)
  {
    xpc_retain(object);
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v9 = v6;
  }
  xpc_object_t v7 = xpc_null_create();
  xpc_object_t v8 = v7;
  sub_1000452AC(138, &v9, &v8);
  xpc_release(v7);
  xpc_release(v6);
  xpc_release(object);
}

void sub_100258818(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  xpc_object_t v14 = v13;
  xpc_release(v14);
  xpc_release(v12);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_100258880(unsigned int a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t object = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t object = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  xpc_object_t object = v4;
LABEL_9:
  xpc_release(v3);
  xpc_object_t v5 = xpc_int64_create(a1);
  long long v10 = v5;
  if (!v5)
  {
    xpc_object_t v5 = xpc_null_create();
    long long v10 = v5;
  }
  sub_100257C70((uint64_t)&object, @"kCTRadioStateKey", &v10);
  xpc_release(v5);
  xpc_object_t v6 = object;
  xpc_object_t v9 = object;
  long long v10 = 0;
  if (object)
  {
    xpc_retain(object);
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v9 = v6;
  }
  xpc_object_t v7 = xpc_null_create();
  xpc_object_t v8 = v7;
  sub_1000452AC(169, &v9, &v8);
  xpc_release(v7);
  xpc_release(v6);
  xpc_release(object);
}

void sub_1002589C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  xpc_object_t v14 = v13;
  xpc_release(v14);
  xpc_release(v12);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_100258A30()
{
}

void sub_100258AA4()
{
}

void sub_100258AC8(uint64_t a1, void *a2, NSObject **a3)
{
  *(void *)a1 = &off_101A2B548;
  *(void *)(a1 + 8) = &off_1019EA728;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)__p, kCtLoggingSystemName, "stw.data.ctr");
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  xpc_object_t v6 = *a3;
  *(void *)(a1 + 32) = *a3;
  if (v6) {
    dispatch_retain(v6);
  }
  *(void *)(a1 + 40) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v12, (const OsLogContext *)__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 48), (const ctu::OsLogLogger *)v12);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)__p);
  *(void *)a1 = off_1019B04F8;
  *(void *)(a1 + 8) = off_1019B06E0;
  *(void *)(a1 + 56) = off_1019B07B0;
  *(void *)(a1 + 64) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 72) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  uint64_t v8 = a2[1];
  uint64_t v10 = *a2;
  uint64_t v11 = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1005C2D1C();
}

void sub_1002590C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  operator delete(v15);
  uint64_t v17 = *(void *)(v11 + 1200);
  *(void *)(v11 + 1200) = 0;
  if (v17) {
    sub_10026CD9C(v11 + 1200, v17);
  }
  uint64_t v18 = *(void *)(v11 + 1168);
  *(void *)(v11 + 1168) = 0;
  if (v18) {
    sub_10026CD9C(v11 + 1168, v18);
  }
  uint64_t v19 = *(void *)(v11 + 1136);
  *(void *)(v11 + 1136) = 0;
  if (v19) {
    sub_10026CD9C(v11 + 1136, v19);
  }
  uint64_t v20 = *(void *)(v11 + 1104);
  *(void *)(v11 + 1104) = 0;
  if (v20) {
    sub_10026CD9C(v11 + 1104, v20);
  }
  uint64_t v21 = *(void *)(v11 + 1072);
  *(void *)(v11 + 1072) = 0;
  if (v21) {
    sub_10026CD9C(v11 + 1072, v21);
  }
  uint64_t v22 = *(void *)(v11 + 1040);
  *(void *)(v11 + 1040) = 0;
  if (v22) {
    sub_10026CD9C(v11 + 1040, v22);
  }
  uint64_t v23 = *(void *)(v11 + 1008);
  *(void *)(v11 + 1008) = 0;
  if (v23) {
    sub_10026CD9C(v11 + 1008, v23);
  }
  sub_10026CE18(v11 + 928);
  sub_10005D144(*(void **)(v11 + 872));
  unint64_t v24 = *(std::__shared_weak_count **)(v11 + 856);
  if (v24) {
    sub_10004D2C8(v24);
  }
  CFBooleanRef v25 = *(std::__shared_weak_count **)(v11 + 840);
  if (v25) {
    sub_10004D2C8(v25);
  }
  sub_100259454(v14);
  uint64_t v26 = *(void *)(v11 + 720);
  *(void *)(v11 + 720) = 0;
  if (v26) {
    sub_10026CD9C(v11 + 720, v26);
  }
  uint64_t v27 = *(void *)(v11 + 688);
  *(void *)(v11 + 688) = 0;
  if (v27) {
    sub_10026CD9C(v11 + 688, v27);
  }
  sub_10026F148(*(void **)(v11 + 528));
  sub_10005D144(*(void **)(v11 + 496));
  unsigned __int8 v28 = *(std::__shared_weak_count **)(v11 + 480);
  if (v28) {
    sub_10004D2C8(v28);
  }
  char v29 = *(std::__shared_weak_count **)(v11 + 440);
  if (v29) {
    sub_10004D2C8(v29);
  }
  sub_1002594A8(v13);
  char v30 = *(std::__shared_weak_count **)(v11 + 272);
  if (v30) {
    sub_10004D2C8(v30);
  }
  if (*(unsigned char *)(v11 + 256))
  {
    uint64_t v31 = *(std::__shared_weak_count **)(v11 + 240);
    if (v31) {
      sub_10004D2C8(v31);
    }
  }
  uint64_t v32 = *(std::__shared_weak_count **)(v11 + 216);
  if (v32) {
    sub_10004D2C8(v32);
  }
  uint64_t v33 = *(std::__shared_weak_count **)(v11 + 200);
  if (v33) {
    sub_10004D2C8(v33);
  }
  uint64_t v34 = *(std::__shared_weak_count **)(v11 + 184);
  if (v34) {
    sub_10004D2C8(v34);
  }
  uint64_t v35 = *(std::__shared_weak_count **)(v11 + 168);
  if (v35) {
    sub_10004D2C8(v35);
  }
  uint64_t v36 = *(std::__shared_weak_count **)(v11 + 152);
  if (v36) {
    sub_10004D2C8(v36);
  }
  uint64_t v37 = *(std::__shared_weak_count **)(v11 + 136);
  if (v37) {
    sub_10004D2C8(v37);
  }
  uint64_t v38 = *(std::__shared_weak_count **)(v11 + 120);
  if (v38) {
    sub_10004D2C8(v38);
  }
  int v39 = *(std::__shared_weak_count **)(v11 + 104);
  if (v39) {
    sub_10004D2C8(v39);
  }
  uint64_t v40 = *(std::__shared_weak_count **)(v11 + 88);
  if (v40) {
    std::__shared_weak_count::__release_weak(v40);
  }
  char v41 = *(std::__shared_weak_count **)(v11 + 72);
  if (v41) {
    sub_10004D2C8(v41);
  }
  ctu::OsLogLogger::~OsLogLogger(v12);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

void sub_100259318(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  JUMPOUT(0x1002591B8);
}

void sub_100259330()
{
}

void sub_100259338(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  JUMPOUT(0x1002591CCLL);
}

void sub_100259350()
{
}

void sub_100259358(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  JUMPOUT(0x1002591E0);
}

void sub_100259370()
{
}

void sub_100259378(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  JUMPOUT(0x100259224);
}

void sub_100259390()
{
}

void sub_100259398(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  JUMPOUT(0x100259238);
}

void sub_1002593B0()
{
}

void sub_1002593B8()
{
}

void sub_1002593C0()
{
}

void sub_1002593C8()
{
}

void sub_1002593D0()
{
}

void sub_1002593D8()
{
}

void sub_1002593E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (!a13) {
    JUMPOUT(0x1002592DCLL);
  }
  JUMPOUT(0x1002592D8);
}

void sub_1002593F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a14);
  sub_100087E88(v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  JUMPOUT(0x100259310);
}

void sub_100259418()
{
}

uint64_t sub_100259420(uint64_t a1)
{
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  *xpc_object_t v2 = 0;
  if (v4) {
    sub_10026CD9C((uint64_t)v2, v3);
  }
  return a1;
}

uint64_t sub_100259454(uint64_t a1)
{
  xpc_object_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v4;
      operator delete(v4);
    }
  }
  return a1;
}

void sub_1002594A8(ctu::OsLogLogger *this)
{
  xpc_object_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v4) {
    sub_10004D2C8(v4);
  }
  xpc_object_t v5 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v5) {
    sub_10004D2C8(v5);
  }
  xpc_object_t v6 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v7) {
    sub_10004D2C8(v7);
  }

  ctu::OsLogLogger::~OsLogLogger(this);
}

uint64_t sub_100259524(uint64_t a1, long long *a2)
{
  uint64_t v4 = a1 + 32;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  xpc_object_t v5 = *(NSObject **)(v4 + 16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Bootstrap", buf, 2u);
  }
  long long v6 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 88);
  *(_OWORD *)(a1 + 80) = v6;
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v8
    || (v9 = *(void *)(a1 + 112), v10 = *(void *)(a1 + 16), (uint64_t v11 = std::__shared_weak_count::lock(v8)) == 0))
  {
    sub_100088B9C();
  }
  std::string v12 = v11;
  atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  *(void *)long long buf = 0;
  uint64_t v38 = 0;
  char v13 = std::__shared_weak_count::lock(v12);
  uint64_t v14 = v13;
  if (v13)
  {
    uint64_t v15 = v10 + 8;
    if (!v10) {
      uint64_t v15 = 0;
    }
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v16 = v38;
  *(void *)long long buf = v15;
  uint64_t v38 = v14;
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  std::__shared_weak_count::__release_weak(v12);
  if (v14) {
    sub_10004D2C8(v14);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v9 + 72))(v9, buf);
  if (v38) {
    std::__shared_weak_count::__release_weak(v38);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v17
    || (v18 = *(void *)(a1 + 128), uint64_t v19 = *(void *)(a1 + 16), (v20 = std::__shared_weak_count::lock(v17)) == 0))
  {
    sub_100088B9C();
  }
  uint64_t v21 = v20;
  atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  uint64_t v22 = std::__shared_weak_count::lock(v21);
  if (v22)
  {
    uint64_t v23 = v22;
    uint64_t v24 = v19 + 8;
    if (!v19) {
      uint64_t v24 = 0;
    }
    atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    *(void *)long long buf = v24;
    uint64_t v38 = v22;
    std::__shared_weak_count::__release_weak(v21);
    sub_10004D2C8(v23);
  }
  else
  {
    *(void *)long long buf = 0;
    uint64_t v38 = 0;
    std::__shared_weak_count::__release_weak(v21);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v18 + 72))(v18, buf);
  if (v38) {
    std::__shared_weak_count::__release_weak(v38);
  }
  CFBooleanRef v25 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v25 || (uint64_t v26 = *(std::__shared_weak_count **)(a1 + 16), (v27 = std::__shared_weak_count::lock(v25)) == 0)) {
    sub_100088B9C();
  }
  unsigned __int8 v28 = v27;
  atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v27);
  *(void *)long long buf = off_1019B0B58;
  uint64_t v38 = v26;
  int v39 = v28;
  uint64_t v40 = buf;
  char v29 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v29 || (v30 = *(void *)(a1 + 16), (uint64_t v31 = std::__shared_weak_count::lock(v29)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v32 = v31;
  atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v31);
  v36[0] = off_1019B0BE8;
  v36[1] = v30;
  v36[2] = v32;
  v36[3] = v36;
  sub_100ED00FC((id *)v4, (uint64_t)buf, (uint64_t)v36, &v35);
  uint64_t v33 = *(std::__shared_weak_count **)(a1 + 104);
  *(_OWORD *)(a1 + 96) = v35;
  if (v33) {
    sub_10004D2C8(v33);
  }
  sub_10026FAA0(v36);
  sub_10026F674(buf);
  return (***(uint64_t (****)(void))(a1 + 96))();
}

void sub_10025988C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
}

void sub_1002598D0(void *a1, uint64_t a2, std::__shared_weak_count *this)
{
  if (!this || (xpc_object_t v5 = std::__shared_weak_count::lock(this)) == 0) {
    sub_100088B9C();
  }
  *a1 = a2;
  a1[1] = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);

  sub_10004D2C8(v5);
}

void sub_100259928(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  xpc_object_t v2 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Start", buf, 2u);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v3
    || (uint64_t v4 = *(uint64_t (****)(void, uint64_t *))(a1 + 144),
        uint64_t v5 = *(void *)(a1 + 16),
        (long long v6 = std::__shared_weak_count::lock(v3)) == 0))
  {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  uint64_t v8 = std::__shared_weak_count::lock(v7);
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v10 = v5 + 56;
    if (!v5) {
      uint64_t v10 = 0;
    }
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v19 = v10;
    uint64_t v20 = v8;
    std::__shared_weak_count::__release_weak(v7);
    sub_10004D2C8(v9);
  }
  else
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    std::__shared_weak_count::__release_weak(v7);
  }
  char v11 = (**v4)(v4, &v19);
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  if (v11)
  {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 144) + 8))(*(void *)(a1 + 144), a1 + 282);
    (*(void (**)(void))(**(void **)(a1 + 112) + 80))(*(void *)(a1 + 112));
    std::string v12 = *(std::__shared_weak_count **)(a1 + 24);
    if (!v12
      || (uint64_t v13 = *(void *)(a1 + 128), v14 = *(void *)(a1 + 16), (v15 = std::__shared_weak_count::lock(v12)) == 0))
    {
      sub_100088B9C();
    }
    uint64_t v16 = v15;
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
    uint64_t v17 = operator new(0x20uLL);
    void *v17 = off_1019B0C78;
    v17[1] = a1;
    v17[2] = v14;
    uint64_t v17[3] = v16;
    uint64_t v22 = v17;
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v13 + 80))(v13, buf);
    sub_100060644(buf);
  }
  else
  {
    uint64_t v18 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to setup agent", buf, 2u);
    }
  }
}

void sub_100259BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100259BF8(uint64_t a1)
{
  xpc_object_t v2 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Lazy start", buf, 2u);
  }
  if (_os_feature_enabled_impl())
  {
    uint64_t v3 = *(void (****)(void, void **, uint8_t *, __int16 *))(a1 + 264);
    sub_100058DB0(__p, "networking.st.text-911");
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
    if (!v4 || (uint64_t v5 = *(void *)(a1 + 16), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v7 = v6;
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v6);
    uint64_t v64 = 0;
    uint64_t v8 = operator new(0x20uLL);
    *uint64_t v8 = off_1019B0CF8;
    v8[1] = a1;
    void v8[2] = v5;
    v8[3] = v7;
    uint64_t v64 = v8;
    __int16 v58 = 257;
    (**v3)(v3, __p, buf, &v58);
    sub_1002702C8(buf);
    if (v60 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v9 = *(void (****)(void, void **, uint8_t *, __int16 *))(a1 + 264);
    sub_100058DB0(__p, "networking.st.find-my");
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 24);
    if (!v10 || (uint64_t v11 = *(void *)(a1 + 16), (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v13 = v12;
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    uint64_t v64 = 0;
    uint64_t v14 = operator new(0x20uLL);
    void *v14 = off_1019B0D88;
    v14[1] = a1;
    v14[2] = v11;
    uint64_t v14[3] = v13;
    uint64_t v64 = v14;
    __int16 v58 = 256;
    (**v9)(v9, __p, buf, &v58);
    sub_1002702C8(buf);
    if (v60 < 0) {
      operator delete(__p[0]);
    }
    if (!_os_feature_enabled_impl())
    {
      uint64_t v21 = *(std::__shared_weak_count **)(a1 + 24);
      if (v21 && std::__shared_weak_count::lock(v21)) {
        operator new();
      }
      sub_100088B9C();
    }
    uint64_t v15 = *(void (****)(void, void **, uint8_t *, __int16 *))(a1 + 264);
    sub_100058DB0(__p, "networking.st.roadside");
    uint64_t v16 = *(std::__shared_weak_count **)(a1 + 24);
    if (!v16 || (v17 = *(void *)(a1 + 16), (uint64_t v18 = std::__shared_weak_count::lock(v16)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v19 = v18;
    atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v18);
    uint64_t v64 = 0;
    uint64_t v20 = operator new(0x20uLL);
    *uint64_t v20 = off_1019B0E08;
    v20[1] = a1;
    _OWORD v20[2] = v17;
    void v20[3] = v19;
    uint64_t v64 = v20;
    __int16 v58 = 256;
    (**v15)(v15, __p, buf, &v58);
    sub_1002702C8(buf);
    if (v60 < 0) {
      operator delete(__p[0]);
    }
    if (!_os_feature_enabled_impl())
    {
      unsigned __int8 v28 = *(std::__shared_weak_count **)(a1 + 24);
      if (v28 && std::__shared_weak_count::lock(v28)) {
        operator new();
      }
      sub_100088B9C();
    }
    uint64_t v22 = *(void (****)(void, void **, uint8_t *, __int16 *))(a1 + 264);
    sub_100058DB0(__p, "networking.st.imessage-lite");
    uint64_t v23 = *(std::__shared_weak_count **)(a1 + 24);
    if (!v23 || (uint64_t v24 = *(void *)(a1 + 16), (v25 = std::__shared_weak_count::lock(v23)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v26 = v25;
    atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v25);
    uint64_t v64 = 0;
    uint64_t v27 = operator new(0x20uLL);
    *uint64_t v27 = off_1019B0E88;
    v27[1] = a1;
    v27[2] = v24;
    v27[3] = v26;
    uint64_t v64 = v27;
    __int16 v58 = 256;
    (**v22)(v22, __p, buf, &v58);
    sub_1002702C8(buf);
    if (v60 < 0) {
      operator delete(__p[0]);
    }
    if (!_os_feature_enabled_impl())
    {
      long long v35 = *(std::__shared_weak_count **)(a1 + 24);
      if (v35 && std::__shared_weak_count::lock(v35)) {
        operator new();
      }
      sub_100088B9C();
    }
    char v29 = *(void (****)(void, void **, uint8_t *, __int16 *))(a1 + 264);
    sub_100058DB0(__p, "networking.st.sms");
    uint64_t v30 = *(std::__shared_weak_count **)(a1 + 24);
    if (!v30 || (uint64_t v31 = *(void *)(a1 + 16), (v32 = std::__shared_weak_count::lock(v30)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v33 = v32;
    atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v32);
    uint64_t v34 = operator new(0x20uLL);
    void *v34 = off_1019B0F08;
    v34[1] = a1;
    v34[2] = v31;
    void v34[3] = v33;
    uint64_t v64 = v34;
    __int16 v58 = 256;
    (**v29)(v29, __p, buf, &v58);
    sub_1002702C8(buf);
    if (v60 < 0) {
      operator delete(__p[0]);
    }
  }
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96), 1);
  uint64_t v36 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I -- Temporarily setting up environments for bootstrap --", buf, 2u);
  }
  buf[0] = 1;
  char v62 = 0;
  char v63 = 0;
  sub_1004CFF70(a1 + 304, (void *)(a1 + 64));
  buf[0] = 1;
  char v62 = 0;
  char v63 = 0;
  sub_1004D00E8(a1 + 304, (void *)(a1 + 64));
  uint64_t v37 = *(void *)(a1 + 312);
  unint64_t v38 = *(void *)(v37 + 112);
  int v39 = *(unsigned __int8 *)(v37 + 120);
  *(void *)(a1 + 888) = v38;
  *(unsigned char *)(a1 + 896) = v39;
  uint64_t v40 = *(void *)(a1 + 344);
  unint64_t v41 = *(void *)(v40 + 112);
  char v42 = *(unsigned char *)(v40 + 120);
  *(void *)(a1 + 904) = v41;
  *(unsigned char *)(a1 + 912) = v42;
  if (v39 && v42)
  {
    char v43 = -1;
    if (v38 >= v41) {
      char v43 = 1;
    }
    if (v38 == v41) {
      char v43 = 0;
    }
    if (v43 < 0)
    {
LABEL_45:
      uint64_t v44 = sub_1011260B8(v40);
      uint64_t v46 = v45;
      uint64_t v47 = sub_101117E48(*(void *)(a1 + 344));
      sub_10025A5B0(a1, v44, v46, v47, v48);
      goto LABEL_57;
    }
  }
  else
  {
    int v49 = v42 != 0;
    BOOL v50 = v39 == 0;
    int v51 = v39 != 0;
    int v52 = v50;
    BOOL v50 = (v49 & v52) == 0;
    char v53 = -1;
    if (v50) {
      char v53 = 1;
    }
    if (v51 != v49) {
      char v54 = v53;
    }
    else {
      char v54 = 0;
    }
    if (v54 < 0) {
      goto LABEL_45;
    }
  }
  uint64_t v55 = sub_1011260B8(v37);
  sub_10025A854(a1, v55, v56);
LABEL_57:
  sub_1004D01D0(a1 + 304);
  sub_1004D0058(a1 + 304);
  sub_10025AA94(a1);
  int v57 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I -- Done with temporarily set up environments --", buf, 2u);
  }
}

void sub_10025A518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10025A5B0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, char a5)
{
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  if ((_BYTE)a3 && a2 && a5)
  {
    uint64_t v8 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218496;
      *(void *)&uint8_t buf[4] = a2 / 1000;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = a2 / 60000;
      *(_WORD *)&unsigned char buf[22] = 2048;
      uint64_t v27 = a4;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [Started timer] Roadside conversation will not be eligible for resume after: %lld seconds (about %ld minutes) for providerId: %llu", buf, 0x20u);
    }
    sub_100058DB0(&__p, "RsConvResumeExpiryTimer");
    Registry::getTimerService(&v17, *(Registry **)(a1 + 64));
    *(void *)long long buf = off_1019B1A88;
    *(void *)&uint8_t buf[8] = a1;
    *(void *)&uint8_t buf[16] = a4;
    uint64_t v27 = buf;
    AutoStartTimer::create();
    uint64_t v23 = a4;
    uint64_t v9 = v21;
    if (*(unsigned char *)(a1 + 256))
    {
      uint64_t v10 = v22;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64_t v11 = *(std::__shared_weak_count **)(a1 + 240);
      *(void *)(a1 + 232) = v9;
      *(void *)(a1 + 240) = v10;
      if (v11)
      {
        sub_10004D2C8(v11);
        std::string v12 = v22;
        *(void *)(a1 + 248) = v23;
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      else
      {
        *(void *)(a1 + 248) = a4;
      }
    }
    else
    {
      uint64_t v16 = v22;
      *(void *)(a1 + 232) = v21;
      *(void *)(a1 + 240) = v16;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      *(void *)(a1 + 248) = a4;
      *(unsigned char *)(a1 + 256) = 1;
    }
    sub_10003B34C(buf);
    if (v18) {
      sub_10004D2C8(v18);
    }
    if (v20 < 0) {
      operator delete(__p);
    }
  }
  else if (*(unsigned char *)(a1 + 256))
  {
    uint64_t v13 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)
      || (uint64_t v14 = *(void *)(a1 + 248),
          *(_DWORD *)long long buf = 134217984,
          *(void *)&uint8_t buf[4] = v14,
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [Stopped timer] Roadside conversation resume eligibility for providerId: %llu", buf, 0xCu), *(unsigned char *)(a1 + 256)))
    {
      uint64_t v15 = *(std::__shared_weak_count **)(a1 + 240);
      if (v15) {
        sub_10004D2C8(v15);
      }
      *(unsigned char *)(a1 + 256) = 0;
    }
  }
  sub_10025CE9C(a1);
}

void sub_10025A814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10025A854(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  if ((_BYTE)a3 && a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218240;
      *(void *)&uint8_t buf[4] = a2 / 1000;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = a2 / 60000;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [Started timer] Emergency conversation will not be eligible for resume after: %lld seconds (about %ld minutes)", buf, 0x16u);
    }
    sub_100058DB0(&__p, "EmConvResumeExpiryTimer");
    Registry::getTimerService(&v10, *(Registry **)(a1 + 64));
    *(void *)long long buf = off_1019B1A08;
    *(void *)&uint8_t buf[8] = a1;
    uint64_t v18 = buf;
    AutoStartTimer::create();
    long long v6 = v14;
    long long v14 = 0uLL;
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 216);
    *(_OWORD *)(a1 + 208) = v6;
    if (v7)
    {
      sub_10004D2C8(v7);
      if (*((void *)&v14 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v14 + 1));
      }
    }
    sub_10003B34C(buf);
    if (v11) {
      sub_10004D2C8(v11);
    }
    if (v13 < 0) {
      operator delete(__p);
    }
  }
  else if (*(void *)(a1 + 208))
  {
    uint64_t v8 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [Stopped timer] Emergency conversation resume eligibility", buf, 2u);
    }
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 216);
    *(void *)(a1 + 208) = 0;
    *(void *)(a1 + 216) = 0;
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  sub_10025CE9C(a1);
}

void sub_10025AA54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10025AA94(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  BOOL v2 = (*(_WORD *)(a1 + 416) & 0x20) != 0 || sub_10025B63C(a1 + 1192, 0) == 1;
  if (*(unsigned char *)(a1 + 828)) {
    BOOL v3 = *(unsigned char *)(a1 + 827) == v2;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    *(_WORD *)(a1 + 827) = v2 | 0x100;
    uint64_t v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "false";
      if (v2) {
        uint64_t v5 = "true";
      }
      int v10 = 136315138;
      uint64_t v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SatSmsConfig in use changed to: %s", (uint8_t *)&v10, 0xCu);
    }
    long long v6 = *(std::__shared_weak_count **)(a1 + 88);
    if (v6)
    {
      uint64_t v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        uint64_t v8 = v7;
        uint64_t v9 = *(void *)(a1 + 80);
        if (v9) {
          (*(void (**)(uint64_t, BOOL))(*(void *)v9 + 128))(v9, v2);
        }
        sub_10004D2C8(v8);
      }
    }
  }
}

void sub_10025ABF0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void **sub_10025AC04(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v3 = CFDateCreate(kCFAllocatorDefault, Current + 2592000.0);
  CFDateRef v6 = v3;
  uint64_t v4 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    int v8 = 30;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ShutDownSatSms expires after %d days from now", buf, 8u);
  }
  (***(void (****)(void, CFDateRef))(a1 + 1232))(*(void *)(a1 + 1232), v3);
  return sub_10007CA64((const void **)&v6);
}

void sub_10025AD14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10007CA64((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10025AD28(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (!*(unsigned char *)(a1 + 829)) {
    return;
  }
  if (sub_10025B63C(a1 + 1192, 0) != 1) {
    return;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if ((*(_WORD *)(a1 + 416) & 0x20) != 0
    || ((*(uint64_t (**)(void))(**(void **)(a1 + 128) + 112))(*(void *)(a1 + 128)) & 1) != 0)
  {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 392);
  if (v2)
  {
    if (!*(unsigned char *)(v2 + 184))
    {
      CFDateRef v3 = *(std::__shared_weak_count **)(a1 + 400);
      if (v3)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v3);
      }
      uint64_t v4 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Current SatSms environment is not access restricted, we need to tear it", buf, 2u);
      }
      sub_1004D03A8(a1 + 304);
      uint64_t v2 = *(void *)(a1 + 392);
    }
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 400);
    if (v5)
    {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v5);
    }
    if (v2) {
      goto LABEL_36;
    }
  }
  else
  {
    CFDateRef v6 = *(std::__shared_weak_count **)(a1 + 400);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v6);
    }
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7)
  {
    int v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(a1 + 80);
      if (!v10)
      {
        sub_10004D2C8(v9);
        return;
      }
      CFDateRef theDate = 0;
      char v54 = 0;
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v10 + 152))(&v51);
      sub_10025B734(&theDate, &v51);
      if (v52) {
        sub_10004D2C8(v52);
      }
      CFDateRef v11 = theDate;
      if (theDate)
      {
        *(void *)&uint8_t buf[16] = 0;
        __int16 v58 = 0;
        uint64_t v59 = 0;
        uint64_t v12 = *(void *)(a1 + 840);
        *(void *)long long buf = *(void *)(a1 + 832);
        *(void *)&uint8_t buf[8] = v12;
        if (v12) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)&uint8_t buf[16] = v11;
        __int16 v58 = v54;
        if (v54) {
          atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        LOBYTE(v59) = 1;
        char v13 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v50 = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Creating environment for shutDown procedure", v50, 2u);
        }
        sub_1004D0260(a1 + 304, (void *)(a1 + 64));
        sub_10025B9C0((uint64_t)buf);
      }
      else
      {
        long long v14 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "SatSmsConfiguration is NULL. Cannot create environment", buf, 2u);
        }
      }
      if (v54) {
        sub_10004D2C8(v54);
      }
      sub_10004D2C8(v9);
      if (v11)
      {
LABEL_36:
        (*(void (**)(void, const mach_header_64 *, uint64_t, void))(**(void **)(a1 + 128) + 16))(*(void *)(a1 + 128), &_mh_execute_header, 32, *(unsigned int *)(a1 + 460));
        CFDateRef theDate = 0;
        (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 1232) + 8))(buf);
        sub_100201EE4(&theDate, (CFTypeRef *)buf);
        sub_1000577C4((const void **)buf);
        if (theDate) {
          uint64_t v15 = sub_1001908E4;
        }
        else {
          uint64_t v15 = 0;
        }
        if (v15)
        {
          CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
          *(void *)long long buf = CFDateCreate(kCFAllocatorDefault, Current);
          double TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(theDate, *(CFDateRef *)buf);
          sub_10007CA64((const void **)buf);
          *(void *)BOOL v50 = 0;
          if (TimeIntervalSinceDate <= 0.0)
          {
LABEL_47:
            uint64_t v21 = *(void *)(a1 + 128);
            *(void *)&long long v48 = a1;
            uint64_t v22 = *(std::__shared_weak_count **)(a1 + 24);
            if (!v22 || (v23 = *(void *)(a1 + 16), (uint64_t v24 = std::__shared_weak_count::lock(v22)) == 0)) {
              sub_100088B9C();
            }
            *((void *)&v48 + 1) = v23;
            int v49 = v24;
            atomic_fetch_add_explicit(&v24->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v24);
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
            uint64_t v25 = *(std::__shared_weak_count **)(a1 + 24);
            if (!v25 || (uint64_t v26 = *(void *)(a1 + 16), (v27 = std::__shared_weak_count::lock(v25)) == 0)) {
              sub_100088B9C();
            }
            unsigned __int8 v28 = v27;
            atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v27);
            char v29 = operator new(0x38uLL);
            v29[1] = 0;
            void v29[2] = 0;
            *char v29 = off_1019B1B58;
            uint64_t v30 = (std::__shared_weak_count *)operator new(0x28uLL);
            v30->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1BA8;
            v30->__shared_owners_ = a1;
            v30->__shared_weak_owners_ = v26;
            v30[1].__vftable = (std::__shared_weak_count_vtbl *)v28;
            LOWORD(v30[1].__shared_owners_) = 32;
            __int16 v58 = v30;
            sub_1000DA470((uint64_t)(v29 + 3), (uint64_t)buf);
            sub_10003B34C(buf);
            uint64_t v31 = (void **)(a1 + 872);
            uint64_t v32 = *(void ***)(a1 + 872);
            if (!v32) {
              goto LABEL_62;
            }
            uint64_t v33 = a1 + 872;
            uint64_t v34 = *(void *)(a1 + 872);
            do
            {
              unsigned int v35 = *(unsigned __int16 *)(v34 + 32);
              BOOL v36 = v35 >= 0x20;
              if (v35 >= 0x20) {
                uint64_t v37 = (uint64_t *)v34;
              }
              else {
                uint64_t v37 = (uint64_t *)(v34 + 8);
              }
              if (v36) {
                uint64_t v33 = v34;
              }
              uint64_t v34 = *v37;
            }
            while (*v37);
            if ((void **)v33 != v31 && *(unsigned __int16 *)(v33 + 32) < 0x21u)
            {
              uint64_t v46 = *(void *)(v33 + 40) + 1;
              *(void *)(v33 + 40) = v46;
              uint64_t v47 = *(NSObject **)(a1 + 48);
              if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 136315394;
                *(void *)&uint8_t buf[4] = "kSatSms";
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v46;
                _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Increment ForceEnableDataPathAssertion count for service: %s [updated count: %llu]", buf, 0x16u);
              }
            }
            else
            {
LABEL_62:
              unint64_t v38 = *(NSObject **)(a1 + 48);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = "kSatSms";
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I Created ForceEnableDataPathAssertion for service: %s [count: 1]", buf, 0xCu);
                uint64_t v32 = (void **)*v31;
              }
              int v39 = (void **)(a1 + 872);
              if (v32)
              {
                while (1)
                {
                  while (1)
                  {
                    int v39 = v32;
                    unsigned int v40 = *((unsigned __int16 *)v32 + 16);
                    if (v40 < 0x21) {
                      break;
                    }
                    uint64_t v32 = (void **)*v32;
                    uint64_t v31 = v39;
                    if (!*v39) {
                      goto LABEL_71;
                    }
                  }
                  if (v40 == 32) {
                    break;
                  }
                  uint64_t v32 = (void **)v32[1];
                  if (!v32)
                  {
                    uint64_t v31 = v39 + 1;
                    goto LABEL_71;
                  }
                }
              }
              else
              {
LABEL_71:
                unint64_t v41 = operator new(0x30uLL);
                v41[16] = 32;
                *((void *)v41 + 5) = 1;
                *(void *)unint64_t v41 = 0;
                *((void *)v41 + 1) = 0;
                *((void *)v41 + 2) = v39;
                *uint64_t v31 = v41;
                uint64_t v42 = **(void **)(a1 + 864);
                if (v42)
                {
                  *(void *)(a1 + 864) = v42;
                  unint64_t v41 = *v31;
                }
                sub_100046C90(*(uint64_t **)(a1 + 872), (uint64_t *)v41);
                ++*(void *)(a1 + 880);
              }
              *(_WORD *)(a1 + 418) |= 0x20u;
              sub_10025BAD4(a1);
            }
            uint64_t v56 = 0;
            char v43 = (char *)operator new(0x38uLL);
            *(void *)char v43 = off_1019B0F88;
            *(_OWORD *)(v43 + 8) = v48;
            *((void *)v43 + 3) = v49;
            *((_DWORD *)v43 + 8) = 0;
            *((void *)v43 + 5) = v29 + 3;
            *((void *)v43 + 6) = v29;
            uint64_t v56 = v43;
            char v44 = (*(uint64_t (**)(uint64_t, uint8_t *, void *))(*(void *)v21 + 96))(v21, v50, v55);
            sub_100060644(v55);
            if ((v44 & 1) == 0)
            {
              uint64_t v45 = *(NSObject **)(a1 + 48);
              if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Failed to request shutDownSatSms", buf, 2u);
              }
            }
            sub_10007CA64((const void **)&theDate);
            return;
          }
          uint64_t v18 = (uint64_t)(TimeIntervalSinceDate * 1000.0);
          unint64_t v19 = v18 & 0xFFFFFFFFFFFFFF00;
        }
        else
        {
          char v20 = *(NSObject **)(a1 + 48);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [ShutDownSatSms] Handling the case where expiry time is missing", buf, 2u);
          }
          sub_10025AC04(a1);
          LOBYTE(v18) = 0;
          unint64_t v19 = 2592000000;
        }
        Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 64));
        *(void *)BOOL v50 = (***(uint64_t (****)(void))buf)(*(void *)buf)
                       + 1000000 * (v18 | v19);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        goto LABEL_47;
      }
    }
  }
}

void sub_10025B528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  sub_10025B9C0((uint64_t)va);
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_10025B63C(uint64_t a1, char a2)
{
  if (*(unsigned char *)(a1 + 24) && (a2 & 1) == 0) {
    return *(unsigned int *)(a1 + 20);
  }
  *(unsigned char *)(a1 + 24) = 1;
  int v8 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(*(void *)(a1 + 8) + 8) + 8))(&v7);
  sub_1000842D0(&v8, &v7);
  sub_1000577C4(&v7);
  if (v8) {
    uint64_t v5 = sub_100081E58;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    LODWORD(v7) = 0;
    ctu::cf::assign((ctu::cf *)&v7, v8, v4);
    uint64_t v3 = v7;
  }
  else
  {
    uint64_t v3 = *(unsigned int *)(a1 + 16);
  }
  *(_DWORD *)(a1 + 20) = v3;
  sub_1000570E8((const void **)&v8);
  return v3;
}

void sub_10025B710(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10025B734(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    CFNumberRef v4 = (char *)operator new(0x60uLL);
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
    *(void *)CFNumberRef v4 = off_1019B08C8;
    *((void *)v4 + 3) = 2;
    *((void *)v4 + 5) = 0;
    uint64_t v5 = (uint64_t **)(v4 + 40);
    *((void *)v4 + 6) = 0;
    *((void *)v4 + 4) = v4 + 40;
    *(_OWORD *)(v4 + 56) = 0u;
    CFDateRef v6 = v4 + 56;
    *(_OWORD *)(v4 + 72) = 0u;
    *((void *)v4 + 11) = 0;
    uint64_t v22 = v4 + 24;
    v4[24] = *(_DWORD *)(v2 + 16) != 0;
    uint64_t v7 = *(void **)(v2 + 24);
    int v8 = (void *)(v2 + 32);
    if (v7 != (void *)(v2 + 32))
    {
      do
      {
        BOOL v9 = *((_DWORD *)v7 + 8) != 0;
        uint64_t v10 = *v5;
        CFDateRef v11 = (uint64_t **)(v4 + 40);
        uint64_t v12 = (uint64_t **)(v4 + 40);
        if (*v5)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v12 = (uint64_t **)v10;
              unsigned int v13 = *((unsigned __int8 *)v10 + 32);
              if (v13 <= v9) {
                break;
              }
              uint64_t v10 = *v12;
              CFDateRef v11 = v12;
              if (!*v12) {
                goto LABEL_10;
              }
            }
            if (v13 >= v9) {
              break;
            }
            uint64_t v10 = v12[1];
            if (!v10)
            {
              CFDateRef v11 = v12 + 1;
              goto LABEL_10;
            }
          }
          long long v14 = (char *)v12;
        }
        else
        {
LABEL_10:
          long long v14 = (char *)operator new(0x40uLL);
          v14[32] = v9;
          *((void *)v14 + 6) = 0;
          *((void *)v14 + 7) = 0;
          *((void *)v14 + 5) = 0;
          *(void *)long long v14 = 0;
          *((void *)v14 + 1) = 0;
          *((void *)v14 + 2) = v12;
          *CFDateRef v11 = (uint64_t *)v14;
          uint64_t v15 = **((void **)v4 + 4);
          uint64_t v16 = (uint64_t *)v14;
          if (v15)
          {
            *((void *)v4 + 4) = v15;
            uint64_t v16 = *v11;
          }
          sub_100046C90(*((uint64_t **)v4 + 5), v16);
          ++*((void *)v4 + 6);
        }
        std::string::operator=((std::string *)(v14 + 40), (const std::string *)(v7 + 5));
        uint64_t v17 = (void *)v7[1];
        if (v17)
        {
          do
          {
            uint64_t v18 = v17;
            uint64_t v17 = (void *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            uint64_t v18 = (void *)v7[2];
            BOOL v19 = *v18 == (void)v7;
            uint64_t v7 = v18;
          }
          while (!v19);
        }
        uint64_t v7 = v18;
      }
      while (v18 != v8);
      uint64_t v2 = *a2;
    }
    if (v6 != (void *)(v2 + 72))
    {
      sub_10006E4A8(v6, *(char **)(v2 + 72), *(char **)(v2 + 80), *(void *)(v2 + 80) - *(void *)(v2 + 72));
      uint64_t v2 = *a2;
    }
    uint64_t v20 = a2[1];
    if (v20) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v21 = (std::__shared_weak_count *)*((void *)v4 + 11);
    *((void *)v4 + 10) = v2;
    *((void *)v4 + 11) = v20;
    if (v21) {
      sub_10004D2C8(v21);
    }
    if (*v22 == 2 || !*((void *)v4 + 6) || *((void *)v4 + 7) == *((void *)v4 + 8) || !*((void *)v4 + 10))
    {
      *a1 = 0;
      a1[1] = 0;
      sub_10004D2C8((std::__shared_weak_count *)v4);
    }
    else
    {
      *a1 = v22;
      a1[1] = v4;
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
}

void sub_10025B9A8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10025B9C0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t sub_10025B9FC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_10025BA38(uint64_t a1, int a2, int a3, int a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  int v8 = *(unsigned __int16 *)(a1 + 422);
  int v9 = v8 | a2;
  if (!a3) {
    int v9 = v8 & ~a2;
  }
  int v10 = *(unsigned __int16 *)(a1 + 420);
  int v11 = v10 & ~a2;
  if (!a4) {
    int v11 = v10 | a2;
  }
  if (v9 != v8 || v11 != v10)
  {
    *(_WORD *)(a1 + 420) = v11;
    *(_WORD *)(a1 + 422) = v9;
    sub_10025BAD4(a1);
  }
}

void sub_10025BAD4(uint64_t a1)
{
  uint64_t v2 = (dispatch_queue_t *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  sub_10025C848(a1);
  dispatch_assert_queue_V2(*v2);
  dispatch_assert_queue_V2(*v2);
  if (*(unsigned char *)(a1 + 280) != 1) {
    goto LABEL_6;
  }
  uint64_t v3 = *(unsigned char **)(a1 + 432);
  if (*(unsigned char *)(a1 + 744) && !v3[1])
  {
LABEL_82:
    int v4 = 1;
    goto LABEL_7;
  }
  if (!*v3 && !v3[1])
  {
    if ((sub_100260EF8(a1) & 1) == 0)
    {
      if (sub_10110D174((void **)(a1 + 832)) && !*(unsigned char *)(a1 + 224))
      {
        int v4 = *(unsigned __int8 *)(a1 + 429) != 2;
        goto LABEL_7;
      }
      goto LABEL_6;
    }
    goto LABEL_82;
  }
LABEL_6:
  int v4 = 0;
LABEL_7:
  if (*(unsigned __int8 *)(a1 + 426) == v4)
  {
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 184);
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  else if (v4)
  {
    if (sub_100260EF8(a1))
    {
      CFDateRef v6 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Non emergency use cases satisfy off grid criteria", (uint8_t *)&buf, 2u);
      }
      *(unsigned char *)(a1 + 426) = 1;
    }
    else if (!*(void *)(a1 + 176))
    {
      sub_100058DB0(__p, "AllowNonEmUseCases");
      Registry::getTimerService(&v28, *(Registry **)(a1 + 64));
      *(void *)&long long buf = off_1019B1888;
      *((void *)&buf + 1) = a1;
      p_long long buf = &buf;
      AutoStartTimer::create();
      long long v9 = v32;
      long long v32 = 0uLL;
      int v10 = *(std::__shared_weak_count **)(a1 + 184);
      *(_OWORD *)(a1 + 176) = v9;
      if (v10)
      {
        sub_10004D2C8(v10);
        if (*((void *)&v32 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
        }
      }
      sub_10003B34C(&buf);
      if (v29) {
        sub_10004D2C8(v29);
      }
      if (v31 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Non emergency use cases are NOT allowed", (uint8_t *)&buf, 2u);
    }
    int v8 = *(std::__shared_weak_count **)(a1 + 184);
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    if (v8) {
      sub_10004D2C8(v8);
    }
    *(unsigned char *)(a1 + 426) = 0;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 280) != 1) {
    goto LABEL_33;
  }
  int v11 = *(unsigned char **)(a1 + 432);
  if (*(unsigned char *)(a1 + 744) && !v11[1]) {
    goto LABEL_84;
  }
  if (*v11 || v11[1])
  {
LABEL_33:
    int v12 = 0;
    goto LABEL_34;
  }
  if (sub_100260EF8(a1))
  {
LABEL_84:
    int v12 = 1;
  }
  else
  {
    int v27 = *(unsigned __int8 *)(a1 + 429);
    if (*(unsigned char *)(a1 + 428)) {
      int v12 = v27 != 2;
    }
    else {
      int v12 = v27 == 0;
    }
  }
LABEL_34:
  if (*(unsigned __int8 *)(a1 + 427) == v12)
  {
    unsigned int v13 = *(std::__shared_weak_count **)(a1 + 200);
    *(void *)(a1 + 192) = 0;
    *(void *)(a1 + 200) = 0;
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
  else if (v12)
  {
    if (sub_100260EF8(a1))
    {
      long long v14 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Emergency use cases satisfy off grid criteria", (uint8_t *)&buf, 2u);
      }
      *(unsigned char *)(a1 + 427) = 1;
    }
    else if (!*(void *)(a1 + 192))
    {
      sub_100058DB0(__p, "AllowEmUseCases");
      Registry::getTimerService(&v28, *(Registry **)(a1 + 64));
      *(void *)&long long buf = off_1019B1908;
      *((void *)&buf + 1) = a1;
      p_long long buf = &buf;
      AutoStartTimer::create();
      long long v17 = v32;
      long long v32 = 0uLL;
      uint64_t v18 = *(std::__shared_weak_count **)(a1 + 200);
      *(_OWORD *)(a1 + 192) = v17;
      if (v18)
      {
        sub_10004D2C8(v18);
        if (*((void *)&v32 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
        }
      }
      sub_10003B34C(&buf);
      if (v29) {
        sub_10004D2C8(v29);
      }
      if (v31 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  else
  {
    uint64_t v15 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Emergency use cases are NOT allowed", (uint8_t *)&buf, 2u);
    }
    uint64_t v16 = *(std::__shared_weak_count **)(a1 + 200);
    *(void *)(a1 + 192) = 0;
    *(void *)(a1 + 200) = 0;
    if (v16) {
      sub_10004D2C8(v16);
    }
    *(unsigned char *)(a1 + 427) = 0;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416))
  {
    sub_10026A770(a1, 0);
  }
  else
  {
    sub_10026040C((void *)a1);
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    int v19 = sub_10025C2E0(a1);
    LODWORD(buf) = (unsigned __int16)v19;
    WORD2(buf) = *(_WORD *)(a1 + 420);
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    if (_os_feature_enabled_impl()) {
      __int16 v20 = *(_WORD *)(a1 + 422);
    }
    else {
      __int16 v20 = 61;
    }
    __int16 v37 = 0;
    WORD3(buf) = v20;
    WORD4(buf) = sub_10025C21C(a1, *(_DWORD *)(a1 + 800));
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    WORD5(buf) = *(_WORD *)(a1 + 418) | *(_WORD *)(a1 + 416);
    WORD6(buf) = HIWORD(v19);
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    char v21 = 0;
    if (*(unsigned char *)(a1 + 427)) {
      __int16 v22 = 3;
    }
    else {
      __int16 v22 = 2;
    }
    if (*(unsigned char *)(a1 + 426)) {
      v22 |= 0x3Cu;
    }
    HIWORD(buf) = v22;
    __int16 v34 = *(_WORD *)(a1 + 424);
    if (*(unsigned char *)(a1 + 280)) {
      char v23 = 2 * (*(unsigned char *)(a1 + 280) == 1);
    }
    else {
      char v23 = 1;
    }
    char v35 = v23;
    unsigned int v24 = *(unsigned __int8 *)(a1 + 281) - 1;
    if (v24 <= 9) {
      char v21 = byte_101479710[(char)v24];
    }
    char v36 = v21;
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    if (*(unsigned char *)(a1 + 744)) {
      BOOL v25 = *(unsigned char *)(a1 + 429) == 2;
    }
    else {
      BOOL v25 = 0;
    }
    char v26 = !v25;
    if ((v19 & 0x3D) == 0) {
      char v26 = 0;
    }
    HIBYTE(v37) = v26;
    sub_10026A350(a1, &buf);
  }
}

void sub_10025C0CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10025C114(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t result = 5;
  switch(a2)
  {
    case 0:
    case 2:
      return result;
    case 1:
      uint64_t v5 = *(void *)(a1 + 312);
      uint64_t result = 3;
      if (v5) {
        goto LABEL_16;
      }
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_10;
    case 4:
      uint64_t v7 = *(void *)(a1 + 360);
      uint64_t result = 2;
      if (v7)
      {
        if (*(unsigned char *)(v7 + 196)) {
          uint64_t result = 3;
        }
        else {
          uint64_t result = 2;
        }
      }
      break;
    case 8:
      uint64_t v5 = *(void *)(a1 + 344);
      uint64_t result = 2;
      if (v5)
      {
LABEL_16:
        if (*(unsigned char *)(v5 + 274)) {
          uint64_t result = 5;
        }
        else {
          uint64_t result = result;
        }
      }
      break;
    default:
      if (a2 == 16 || a2 == 32)
      {
        uint64_t v6 = *(void *)(a1 + 360);
        uint64_t result = 1;
        if (v6)
        {
          if (*(unsigned __int16 *)(v6 + 194) < 0x100u) {
            uint64_t result = 1;
          }
          else {
            uint64_t result = 2;
          }
        }
      }
      else
      {
LABEL_10:
        __TUAssertTrigger();
        uint64_t result = 5;
      }
      break;
  }
  return result;
}

uint64_t sub_10025C21C(uint64_t a1, int a2)
{
  int v6 = a2;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  unsigned __int16 v5 = 0;
  uint64_t v3 = operator new(0x20uLL);
  *uint64_t v3 = off_1019B1088;
  v3[1] = a1;
  void v3[2] = &v6;
  double v3[3] = &v5;
  v7[3] = v3;
  sub_100BC88BC(63, (uint64_t)v7);
  sub_10026ED50(v7);
  return v5;
}

void sub_10025C2CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10026ED50((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10025C2E0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 280) == 1)
  {
    int v2 = *(unsigned __int16 *)(a1 + 424) & ~*(unsigned __int16 *)(a1 + 992);
    if (*(unsigned char *)(a1 + 428) && *(unsigned char *)(a1 + 226) && *(unsigned char *)(a1 + 225)) {
      v2 &= ~1u;
    }
    if (!*(unsigned char *)(a1 + 921) || !*(unsigned char *)(a1 + 920)) {
      v2 &= ~0x10u;
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    int v3 = _os_feature_enabled_impl();
    unsigned int v4 = v2;
    if (v3) {
      unsigned int v4 = (*(unsigned __int16 *)(a1 + 422) | 0xFFFFFFC2) & v2;
    }
    if (!*(unsigned char *)(a1 + 427)) {
      v4 &= ~1u;
    }
    if (!*(unsigned char *)(a1 + 426)) {
      v4 &= 0xFFFFFFC3;
    }
    if (*(unsigned char *)(a1 + 224)) {
      unsigned __int16 v5 = 0;
    }
    else {
      unsigned __int16 v5 = v2;
    }
    if (*(unsigned char *)(a1 + 224)) {
      unsigned int v6 = v4 & 0xFFFFFFFD;
    }
    else {
      unsigned int v6 = v4;
    }
    int v7 = _os_feature_enabled_impl();
    unsigned int v8 = v6 & 0xFFFFFFFB;
    unsigned __int16 v9 = v5 & 0xFFFB;
    if (v7)
    {
      unsigned __int16 v9 = v5;
      unsigned int v8 = v6;
    }
    unsigned int v10 = v8 & 0xFFFFFFF7;
    unsigned __int16 v11 = v9 & 0xFFF7;
    if (*(unsigned char *)(a1 + 453)) {
      unsigned __int16 v12 = v9;
    }
    else {
      unsigned __int16 v12 = v9 & 0xFFF7;
    }
    if (*(unsigned char *)(a1 + 453)) {
      unsigned int v13 = v8;
    }
    else {
      unsigned int v13 = v8 & 0xFFFFFFF7;
    }
    if (_os_feature_enabled_impl())
    {
      unsigned __int16 v11 = v12;
      unsigned int v10 = v13;
    }
    if (!_os_feature_enabled_impl())
    {
      v11 &= ~0x10u;
      v10 &= ~0x10u;
    }
    if (!_os_feature_enabled_impl() || !*(unsigned char *)(a1 + 829))
    {
      v10 &= ~0x20u;
      v11 &= ~0x20u;
    }
    int v14 = _os_feature_enabled_impl();
    if (v14) {
      unsigned __int16 v15 = v11;
    }
    else {
      unsigned __int16 v15 = 0;
    }
    if (!v14) {
      v10 &= ~2u;
    }
    unsigned int v16 = v10 & ~sub_10025C21C(a1, *(_DWORD *)(a1 + 800));
    if (*(unsigned char *)(a1 + 744) && *(unsigned char *)(a1 + 429) == 2) {
      LOWORD(v16) = v16 & 0xFFCF;
    }
  }
  else
  {
    unsigned __int16 v15 = 0;
    LOWORD(v16) = 0;
  }
  return (unsigned __int16)v16 | (v15 << 16);
}

void sub_10025C4D0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (!a3 || !*a2 || sub_10112599C(*a2)) {
    return;
  }
  if (!_os_feature_enabled_impl()) {
    goto LABEL_7;
  }
  int v6 = *(unsigned __int8 *)(a1 + 408);
  if (v6 != 3)
  {
    if (v6 == 2)
    {
LABEL_7:
      int v7 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        uint64_t v17 = a3;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [%s] Compression not supported. Marking invalid codecId", buf, 0xCu);
      }
      sub_101125B24(*a2, 0);
      return;
    }
    __TUAssertTrigger();
  }
  if (!*(void *)(a1 + 328)) {
    __TUAssertTrigger();
  }
  unsigned int v8 = *(std::__shared_weak_count **)(a1 + 88);
  if (v8)
  {
    unsigned __int16 v9 = std::__shared_weak_count::lock(v8);
    if (v9)
    {
      unsigned int v10 = v9;
      uint64_t v11 = *(void *)(a1 + 80);
      if (v11)
      {
        uint64_t v12 = *(void *)(a1 + 328);
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v11 + 208))(buf);
        uint64_t v13 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v12 + 8))(v12, buf);
        unsigned __int16 v15 = buf;
        sub_100047F64((void ***)&v15);
        int v14 = *(NSObject **)(a1 + 48);
        if ((v13 & 0xFF00000000) != 0)
        {
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136315394;
            uint64_t v17 = a3;
            __int16 v18 = 1024;
            int v19 = v13;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I [%s][New] Preferred codec id: %u", buf, 0x12u);
          }
        }
        else
        {
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315138;
            uint64_t v17 = a3;
            _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "[%s] Failed to derive preferred codec id. Will go uncompressed", buf, 0xCu);
          }
          uint64_t v13 = 0;
        }
        sub_101125B24(*a2, v13);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_10025C738(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10025C76C(uint64_t a1)
{
  if (!_os_feature_enabled_impl() || *(unsigned __int8 *)(a1 + 408) - 4 >= 0xFFFFFFFE)
  {
    int v2 = *(std::__shared_weak_count **)(a1 + 320);
    uint64_t v4 = *(void *)(a1 + 312);
    unsigned __int16 v5 = v2;
    if (v2) {
      atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_10025C4D0(a1, &v4, (uint64_t)"Emergency Environment");
    if (v2) {
      sub_10004D2C8(v2);
    }
    int v3 = *(std::__shared_weak_count **)(a1 + 352);
    uint64_t v4 = *(void *)(a1 + 344);
    unsigned __int16 v5 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_10025C4D0(a1, &v4, (uint64_t)"Roadside Environment");
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
}

void sub_10025C82C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10025C848(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t result = capabilities::ct::requiresSeparateOperatingModeForStewie(v2);
  if (result)
  {
    int v4 = (*(_WORD *)(a1 + 416) & 1) != 0 && *(unsigned char *)(a1 + 428) == 0;
    if (*(unsigned __int8 *)(a1 + 824) != v4)
    {
      *(unsigned char *)(a1 + 824) = v4;
      unsigned __int16 v5 = *(uint64_t (**)(void))(**(void **)(a1 + 112) + 96);
      return v5();
    }
  }
  else if (*(unsigned char *)(a1 + 824))
  {
    return __TUAssertTrigger();
  }
  return result;
}

uint64_t sub_10025C910(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  unsigned int v4 = 0;
  uint64_t v2 = *(unsigned __int16 *)(a1 + 416);
  v5[0] = off_1019B1188;
  v5[1] = a1;
  void v5[2] = &v4;
  v5[3] = v5;
  sub_100BC88BC(v2, (uint64_t)v5);
  sub_10026ED50(v5);
  if (v4) {
    return v4;
  }
  else {
    return 5;
  }
}

void sub_10025C9BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10026ED50((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10025C9D0(uint64_t a1)
{
  *(unsigned char *)(a1 + 24) = 0;
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 8) + 16))();
}

void sub_10025CA00(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 312);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 776))
    {
      uint64_t v3 = sub_101125D4C(v2, (char **)(a1 + 752));
      if (!(_BYTE)v3)
      {
        int v4 = HIDWORD(v3);
        unsigned __int16 v5 = *(std::__shared_weak_count **)(a1 + 88);
        if (v5)
        {
          int v6 = std::__shared_weak_count::lock(v5);
          if (v6)
          {
            int v7 = v6;
            uint64_t v8 = *(void *)(a1 + 80);
            if (v8)
            {
              int v9 = v4;
              __int16 v10 = 1;
              char v11 = 1;
              char v12 = 1;
              (*(void (**)(uint64_t, int *))(*(void *)v8 + 40))(v8, &v9);
            }
            sub_10004D2C8(v7);
          }
        }
      }
    }
  }
}

void sub_10025CAC4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10025CAD8(uint64_t a1, unsigned int a2)
{
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 20) = a2;
  uint64_t v2 = *(void *)(a1 + 8);
  CFNumberRef v9 = 0;
  unint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v3)
  {
    unint64_t v4 = (unint64_t)v9;
    CFNumberRef v9 = v3;
    unint64_t valuePtr = v4;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v5 = v9;
  CFNumberRef v8 = v9;
  CFNumberRef v9 = 0;
  sub_1000570E8((const void **)&v9);
  uint64_t v6 = (***(uint64_t (****)(void, const void *))(v2 + 8))(*(void *)(v2 + 8), v5);
  sub_1000570E8((const void **)&v8);
  return v6;
}

void sub_10025CB90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10025CBB0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 344);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 776))
    {
      uint64_t v3 = sub_101125D4C(v2, (char **)(a1 + 752));
      if (!(_BYTE)v3)
      {
        int v4 = HIDWORD(v3);
        CFNumberRef v5 = *(std::__shared_weak_count **)(a1 + 88);
        if (v5)
        {
          uint64_t v6 = std::__shared_weak_count::lock(v5);
          if (v6)
          {
            int v7 = v6;
            uint64_t v8 = *(void *)(a1 + 80);
            if (v8)
            {
              int v9 = v4;
              __int16 v10 = 8;
              char v11 = 1;
              char v12 = 1;
              (*(void (**)(uint64_t, int *))(*(void *)v8 + 40))(v8, &v9);
            }
            sub_10004D2C8(v7);
          }
        }
      }
    }
  }
}

void sub_10025CC78(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

BOOL sub_10025CC8C(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 416) & 2) != 0) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 744)) {
    return *(unsigned char *)(*(void *)(a1 + 432) + 1) == 0;
  }
  return 0;
}

void sub_10025CCE4(uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, char a5)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a2 + 32));
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(unsigned char *)a1 = a5;
  *(_WORD *)(a1 + 2) = a3;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a2 + 32));
  *(unsigned char *)(a1 + 5) = *(_WORD *)(a2 + 416) != 0;
  uint64_t v10 = *(void *)(a2 + 312);
  *(unsigned char *)(a1 + 6) = v10 != 0;
  *(unsigned char *)(a1 + 7) = 0;
  *(unsigned char *)(a1 + 9) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  if ((a3 & 8) != 0)
  {
    uint64_t v12 = *(void *)(a2 + 344);
    if (!v12) {
      return;
    }
    char v13 = *(unsigned char *)(v12 + 272);
    char v14 = *(unsigned char *)(v12 + 104);
    if (v13)
    {
      unsigned __int16 v15 = (void *)(a4 + 48);
      if (!*(unsigned char *)(a4 + 56))
      {
LABEL_11:
        *(void *)&v20[6] = *v15;
        v20[14] = *(unsigned char *)(a4 + 56);
        *(unsigned char *)(a1 + 16) = *(unsigned char *)(*(void *)(a2 + 344) + 104) + 1;
        *(unsigned char *)(a1 + 17) = 0;
        *(void *)(a1 + 18) = *(void *)v20;
        *(void *)(a1 + 25) = *(void *)&v20[7];
LABEL_16:
        *(unsigned char *)(a1 + 40) = 1;
        return;
      }
      unsigned int v16 = sub_101117E48(v12);
      if (*(unsigned char *)(a4 + 56) && v17)
      {
        if (v16 != (const void *)*v15) {
          goto LABEL_11;
        }
      }
      else if ((*(unsigned char *)(a4 + 56) != 0) != (v17 != 0))
      {
        goto LABEL_11;
      }
      __int16 v18 = sub_101117E48(*(void *)(a2 + 344));
    }
    else
    {
      __int16 v18 = *(const void **)(a4 + 48);
      uint64_t v19 = *(unsigned __int8 *)(a4 + 56);
    }
    *(unsigned char *)(a1 + 16) = v14;
    *(unsigned char *)(a1 + 17) = v13;
    *(_DWORD *)(a1 + 18) = *(_DWORD *)v20;
    *(_WORD *)(a1 + 22) = *(_WORD *)&v20[4];
    *(void *)(a1 + 24) = v18;
    *(void *)(a1 + 32) = v19;
    goto LABEL_16;
  }
  if (a3)
  {
    if (v10)
    {
      __int16 v11 = *(unsigned __int8 *)(v10 + 104) | (*(unsigned __int8 *)(v10 + 272) << 8);
      *(unsigned char *)(a1 + 9) = 1;
      *(_WORD *)(a1 + 7) = v11;
    }
  }
}

void sub_10025CE9C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if ((*(_WORD *)(a1 + 416) & 1) != 0
    || (uint64_t v2 = *(AutoStartTimer **)(a1 + 208)) != 0 && !AutoStartTimer::isExpired(v2)
    || (dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32)), (*(_WORD *)(a1 + 416) & 8) != 0))
  {
    uint64_t v4 = 1;
  }
  else if (*(unsigned char *)(a1 + 256) && (uint64_t v3 = *(AutoStartTimer **)(a1 + 232)) != 0)
  {
    uint64_t v4 = AutoStartTimer::isExpired(v3) ^ 1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  CFNumberRef v5 = (_WORD *)(a1 + 825);
  if (!*(unsigned char *)(a1 + 826) || *(unsigned __int8 *)v5 != v4)
  {
    _WORD *v5 = v4 | 0x100;
    uint64_t v6 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = "false";
      if (v4) {
        int v7 = "true";
      }
      int v12 = 136315138;
      char v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Codec assets are in use changed to: %s", (uint8_t *)&v12, 0xCu);
    }
    uint64_t v8 = *(std::__shared_weak_count **)(a1 + 88);
    if (v8)
    {
      int v9 = std::__shared_weak_count::lock(v8);
      if (v9)
      {
        uint64_t v10 = v9;
        uint64_t v11 = *(void *)(a1 + 80);
        if (v11) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 120))(v11, v4);
        }
        sub_10004D2C8(v10);
      }
    }
  }
}

void sub_10025D024(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10025D038(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a2 + 40))
  {
    *(_DWORD *)(a1 + 460) = a3;
    unsigned int v8 = 2;
    unsigned int v9 = 5;
  }
  else
  {
    unsigned int v9 = *(_DWORD *)(a2 + 100);
    *(_DWORD *)(a1 + 460) = a3;
    if (v9 > 0xA) {
      unsigned int v8 = 0;
    }
    else {
      unsigned int v8 = word_10147971A[v9];
    }
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a2 + 88);
  v69[0] = *(void *)(a2 + 80);
  v69[1] = (uint64_t)v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10025B734(&buf, v69);
  std::string::size_type v11 = buf.__r_.__value_.__r.__words[0];
  if (buf.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v11) {
    uint64_t v12 = v8;
  }
  else {
    uint64_t v12 = v8 & 0x1F;
  }
  if (v12)
  {
    uint64_t v13 = (unsigned __int16)(*(_WORD *)(a1 + 282) & v12);
    char v14 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_33;
    }
    sub_100BC897C(v12, &v70);
    int v15 = SHIBYTE(v70.__r_.__value_.__r.__words[2]);
    std::string::size_type v16 = v70.__r_.__value_.__r.__words[0];
    sub_100BC897C(v13, &__p);
    if (a3 > 3) {
      char v17 = "???";
    }
    else {
      char v17 = off_1019B1D78[a3];
    }
    if (v9 > 0xA) {
      __int16 v18 = "???";
    }
    else {
      __int16 v18 = off_1019B1D20[v9];
    }
    uint64_t v19 = &v70;
    if (v15 < 0) {
      uint64_t v19 = (std::string *)v16;
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316418;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v17;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    *(_DWORD *)char v72 = v12;
    *(_WORD *)&v72[4] = 2080;
    *(void *)&v72[6] = v19;
    __int16 v73 = 1024;
    int v74 = v13;
    __int16 v75 = 2080;
    char v76 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Stewie requested; Reason: %s, SPS Environment: %s, Requested services: { [Mask: %hu] %s }, Filtered services: {"
      " [Mask: %hu] %s }",
      (uint8_t *)&buf,
      0x36u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v70.__r_.__value_.__l.__data_);
      if (v13) {
        goto LABEL_34;
      }
    }
    else
    {
LABEL_33:
      if (v13)
      {
LABEL_34:
        if ((v13 & ~*(unsigned __int16 *)(a1 + 416)) == 0) {
          goto LABEL_106;
        }
        if (v13)
        {
          if (!*(unsigned char *)(a2 + 40))
          {
            int v34 = *(_DWORD *)(a2 + 100);
            if ((v34 - 3) <= 1)
            {
              char v35 = *(NSObject **)(a1 + 48);
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
                char v36 = "???";
                if (v34 == 3) {
                  char v36 = "kEmergencyFallDetection";
                }
                if (v34 == 4) {
                  char v36 = "kEmergencyKappa";
                }
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
                _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I User is incapacitated [Reason: %s], activate service and skip presenting any popups", (uint8_t *)&buf, 0xCu);
              }
              goto LABEL_106;
            }
          }
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
          if ((*(_WORD *)(a1 + 416) & 8) == 0 || *(unsigned char *)(a2 + 41)) {
            goto LABEL_106;
          }
          __int16 v37 = *(NSObject **)(a1 + 48);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I [PresentAlert] Reason: Roadside is active and Emergency was requested", (uint8_t *)&buf, 2u);
          }
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
          int v39 = ServiceMap;
          if ((v40 & 0x8000000000000000) != 0)
          {
            unint64_t v41 = (unsigned __int8 *)(v40 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v42 = 5381;
            do
            {
              std::string::size_type v40 = v42;
              unsigned int v43 = *v41++;
              uint64_t v42 = (33 * v42) ^ v43;
            }
            while (v43);
          }
          std::mutex::lock(ServiceMap);
          buf.__r_.__value_.__r.__words[0] = v40;
          char v44 = sub_10004D37C(&v39[1].__m_.__sig, (unint64_t *)&buf);
          if (v44)
          {
            std::string::size_type v46 = v44[3];
            uint64_t v45 = (std::__shared_weak_count *)v44[4];
            if (v45) {
              atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
            }
          }
          else
          {
            std::string::size_type v46 = 0;
            uint64_t v45 = 0;
          }
          std::mutex::unlock(v39);
          v70.__r_.__value_.__r.__words[0] = v46;
          v70.__r_.__value_.__l.__size_ = (std::string::size_type)v45;
          if (v45)
          {
            atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v45);
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 2;
          buf.__r_.__value_.__s.__data_[8] = 0;
          buf.__r_.__value_.__s.__data_[16] = 0;
          BOOL v47 = stewie::StewieConnectionAssistant::presentAlertInAssistantApp((uint64_t *)&v70, (int *)&buf);
          if (v70.__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)v70.__r_.__value_.__l.__size_);
          }
          if (!v47) {
            goto LABEL_106;
          }
          goto LABEL_82;
        }
        if ((v13 & 8) == 0)
        {
LABEL_106:
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
          if (*(_WORD *)(a1 + 416))
          {
            if ((v13 & ~*(unsigned __int16 *)(a1 + 416)) != 0)
            {
              LODWORD(v70.__r_.__value_.__l.__data_) = a3;
              *(_DWORD *)(a1 + 456) = v9;
              uint64_t v64 = operator new(0x20uLL);
              void *v64 = off_1019B0918;
              v64[1] = a1;
              v64[2] = a2;
              v64[3] = &v70;
              *(void *)char v72 = v64;
              sub_100BC88BC(v13, (uint64_t)&buf);
              sub_10026ED50(&buf);
              sub_10025BAD4(a1);
              sub_10025CCE4(a4, a1, v13, a2, 1);
            }
            else
            {
              uint64_t v61 = *(NSObject **)(a1 + 48);
              if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I Requested services are already active", (uint8_t *)&buf, 2u);
              }
              *(_OWORD *)(a4 + 16) = 0u;
              *(_OWORD *)(a4 + 32) = 0u;
              *(_OWORD *)a4 = 0u;
              sub_10025CCE4(a4, a1, v13, a2, 1);
              *(unsigned char *)(a4 + 4) = 1;
            }
          }
          else
          {
            int v62 = *(unsigned __int8 *)(a1 + 280);
            if (v62 == 1)
            {
              Registry::getTimerService((uint64_t *)&buf, *(Registry **)(a1 + 64));
              *(void *)(a1 + 544) = (**(uint64_t (***)(std::string::size_type))buf.__r_.__value_.__l.__data_)(buf.__r_.__value_.__r.__words[0]);
              if (buf.__r_.__value_.__l.__size_) {
                sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
              }
              (*(void (**)(void, uint64_t))(**(void **)(a1 + 96) + 24))(*(void *)(a1 + 96), 1);
              LODWORD(v70.__r_.__value_.__l.__data_) = a3;
              *(_DWORD *)(a1 + 456) = v9;
              char v63 = operator new(0x20uLL);
              void *v63 = off_1019B0918;
              v63[1] = a1;
              v63[2] = a2;
              void v63[3] = &v70;
              *(void *)char v72 = v63;
              sub_100BC88BC(v13, (uint64_t)&buf);
              sub_10026ED50(&buf);
              sub_10025BAD4(a1);
              sub_10025DA74(a1);
              sub_10025DC48(a1);
              sub_10025CCE4(a4, a1, v13, a2, 1);
            }
            else
            {
              uint64_t v65 = *(NSObject **)(a1 + 48);
              if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
              {
                if (v62) {
                  uint64_t v66 = "???";
                }
                else {
                  uint64_t v66 = "kNotSatisfied";
                }
                int v67 = sub_100BC8BB4(*(unsigned __int8 *)(a1 + 281));
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v66;
                WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v67;
                _os_log_error_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "Stewie is not allowed right now. Precondition status: %s, reason: %s", (uint8_t *)&buf, 0x16u);
              }
              sub_10025CCE4(a4, a1, v13, a2, 0);
            }
          }
          return;
        }
        uint64_t v21 = *(void *)(a2 + 64);
        if (!v21 || !*(void *)(v21 + 16)) {
          __TUAssertTrigger();
        }
        __int16 v22 = (std::string::size_type *)(a2 + 48);
        if (*(unsigned char *)(a2 + 56))
        {
          uint64_t v23 = *(void *)(a2 + 64);
          char v26 = *(void **)(v23 + 8);
          unsigned int v24 = (void *)(v23 + 8);
          BOOL v25 = v26;
          if (!v26)
          {
            long long v32 = *(NSObject **)(a1 + 48);
            if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
              goto LABEL_89;
            }
            std::string::size_type v27 = *v22;
LABEL_124:
            LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v27;
            _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "The requested Provider Id: %llu, does not exist or is not active anymore! Treating it as no Provider Id case", (uint8_t *)&buf, 0xCu);
            if (!*(unsigned char *)(a2 + 56)) {
              goto LABEL_90;
            }
LABEL_89:
            *(unsigned char *)(a2 + 56) = 0;
            goto LABEL_90;
          }
          std::string::size_type v27 = *v22;
          uint64_t v28 = v24;
          do
          {
            std::string::size_type v29 = v25[4];
            BOOL v30 = v29 >= v27;
            if (v29 >= v27) {
              char v31 = v25;
            }
            else {
              char v31 = v25 + 1;
            }
            if (v30) {
              uint64_t v28 = v25;
            }
            BOOL v25 = (void *)*v31;
          }
          while (*v31);
          if (v28 == v24 || v27 < v28[4] || !sub_100A0766C((uint64_t)(v28 + 5)))
          {
            long long v32 = *(NSObject **)(a1 + 48);
            if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
              goto LABEL_89;
            }
            goto LABEL_124;
          }
        }
LABEL_90:
        if (*(unsigned char *)(a2 + 41)) {
          goto LABEL_106;
        }
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
        if ((*(_WORD *)(a1 + 416) & 1) == 0) {
          goto LABEL_106;
        }
        BOOL v50 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I [PresentAlert] Reason: Emergency active and roadside requested. User needs to explicitly confirm this transition before proceeding.", (uint8_t *)&buf, 2u);
        }
        uint64_t v51 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
        int v52 = v51;
        if ((v53 & 0x8000000000000000) != 0)
        {
          char v54 = (unsigned __int8 *)(v53 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v55 = 5381;
          do
          {
            std::string::size_type v53 = v55;
            unsigned int v56 = *v54++;
            uint64_t v55 = (33 * v55) ^ v56;
          }
          while (v56);
        }
        std::mutex::lock(v51);
        buf.__r_.__value_.__r.__words[0] = v53;
        int v57 = sub_10004D37C(&v52[1].__m_.__sig, (unint64_t *)&buf);
        if (v57)
        {
          std::string::size_type v59 = v57[3];
          __int16 v58 = (std::__shared_weak_count *)v57[4];
          if (v58) {
            atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
          }
        }
        else
        {
          std::string::size_type v59 = 0;
          __int16 v58 = 0;
        }
        std::mutex::unlock(v52);
        v70.__r_.__value_.__r.__words[0] = v59;
        v70.__r_.__value_.__l.__size_ = (std::string::size_type)v58;
        if (v58)
        {
          atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v58);
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 1;
        buf.__r_.__value_.__l.__size_ = *v22;
        buf.__r_.__value_.__s.__data_[16] = *(unsigned char *)(a2 + 56);
        BOOL v60 = stewie::StewieConnectionAssistant::presentAlertInAssistantApp((uint64_t *)&v70, (int *)&buf);
        if (v70.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)v70.__r_.__value_.__l.__size_);
        }
        if (!v60) {
          goto LABEL_106;
        }
LABEL_82:
        *(void *)(a4 + 40) = 0;
        *(_OWORD *)(a4 + 24) = 0u;
        *(_OWORD *)(a4 + 8) = 0u;
        *(_WORD *)a4 = 257;
        *(_WORD *)(a4 + 2) = v13;
        *(_DWORD *)(a4 + 4) = 0;
        return;
      }
    }
    uint64_t v33 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      int v48 = *(unsigned __int16 *)(a1 + 282);
      sub_100BC897C(*(unsigned __int16 *)(a1 + 282), &buf);
      int v49 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &buf
          : (std::string *)buf.__r_.__value_.__r.__words[0];
      LODWORD(v70.__r_.__value_.__l.__data_) = 67109378;
      HIDWORD(v70.__r_.__value_.__r.__words[0]) = v48;
      LOWORD(v70.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v70.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v49;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Cannot enable Stewie for requested services. Allowed services: { [Mask: %hu] %s }", (uint8_t *)&v70, 0x12u);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    sub_10025CCE4(a4, a1, 0, a2, 0);
  }
  else
  {
    sub_10025CCE4(a4, a1, 0, a2, 0);
  }
}

void sub_10025D9F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, std::__shared_weak_count *a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10025DA74(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416) && *(_DWORD *)(a1 + 448))
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    int v2 = *(_DWORD *)(a1 + 448);
    if (*(_WORD *)(a1 + 416))
    {
      if (v2 != 1) {
        return;
      }
    }
    else if (v2 == 2)
    {
      return;
    }
    if (!*(unsigned char *)(a1 + 452))
    {
      uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
      if (v3)
      {
        uint64_t v4 = std::__shared_weak_count::lock(v3);
        if (v4)
        {
          CFNumberRef v5 = v4;
          uint64_t v6 = *(void *)(a1 + 80);
          if (v6)
          {
            sub_1002598D0(&v10, *(void *)(a1 + 16), *(std::__shared_weak_count **)(a1 + 24));
            int v7 = (char *)operator new(0x20uLL);
            *(void *)int v7 = off_1019B1808;
            *(_OWORD *)(v7 + 8) = v10;
            *((void *)v7 + 3) = a1;
            uint64_t v12 = v7;
            char v8 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v6 + 200))(v6, buf);
            sub_100060644(buf);
            if (v8)
            {
              *(unsigned char *)(a1 + 452) = 1;
            }
            else
            {
              unsigned int v9 = *(NSObject **)(a1 + 48);
              if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to invoke Location popup", buf, 2u);
              }
            }
          }
          sub_10004D2C8(v5);
        }
      }
    }
  }
}

void sub_10025DC10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  sub_100060644(&a13);
  sub_10004D2C8(v13);
  _Unwind_Resume(a1);
}

void sub_10025DC48(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = a1 + 32;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)v2);
  if (!*(_WORD *)(v2 + 384)) {
    return;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
  uint64_t v163 = v1 + 312;
  uint64_t v3 = *(void *)(v1 + 312);
  if (v3 && *(unsigned char *)(v3 + 274))
  {
    v171[0] = (void *)v1;
    v171[1] = (void *)(v1 + 312);
    if (*(unsigned char *)(v3 + 275)) {
      sub_100261994((uint64_t *)v171, (uint64_t)"Location update is due");
    }
    if (sub_100BDEA90(v3))
    {
      uint64_t v4 = *(void **)(v1 + 520);
      CFNumberRef v5 = (void *)(v1 + 528);
      if (v4 != (void *)(v1 + 528))
      {
        while (1)
        {
          uint64_t v6 = (unsigned int (***)(void))(v4[6] + *(void *)(*(void *)v4[6] - 48));
          if ((**v6)(v6) == 1) {
            break;
          }
          int v7 = (void *)v4[1];
          if (v7)
          {
            do
            {
              char v8 = v7;
              int v7 = (void *)*v7;
            }
            while (v7);
          }
          else
          {
            do
            {
              char v8 = (void *)v4[2];
              BOOL v9 = *v8 == (void)v4;
              uint64_t v4 = v8;
            }
            while (!v9);
          }
          uint64_t v4 = v8;
          if (v8 == v5) {
            goto LABEL_17;
          }
        }
      }
      if (v4 == v5)
      {
LABEL_17:
        uint64_t v10 = *(void *)v163;
        std::string::size_type v11 = *(AutoStartTimer **)(*(void *)v163 + 328);
        uint64_t v12 = *(std::__shared_weak_count **)(*(void *)v163 + 336);
        if (v12)
        {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!v11)
          {
            sub_10004D2C8(v12);
            uint64_t v10 = *(void *)v163;
            goto LABEL_27;
          }
        }
        else if (!v11)
        {
LABEL_27:
          sub_100058DB0(__p, "NotifyOptionUpdateTimer");
          Registry::getTimerService(&v173, *(Registry **)(v1 + 64));
          *(void *)std::string buf = off_1019B1388;
          *(void *)&uint8_t buf[8] = v1;
          v180 = buf;
          AutoStartTimer::create();
          long long v15 = v175;
          long long v175 = 0uLL;
          std::string::size_type v16 = *(std::__shared_weak_count **)(v10 + 336);
          *(_OWORD *)(v10 + 328) = v15;
          if (v16)
          {
            sub_10004D2C8(v16);
            if (*((void *)&v175 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v175 + 1));
            }
          }
          sub_10003B34C(buf);
          if (v174) {
            sub_10004D2C8(v174);
          }
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
          goto LABEL_34;
        }
        if (AutoStartTimer::isExpired(v11))
        {
          uint64_t v13 = *(void *)v163;
          char v14 = *(std::__shared_weak_count **)(*(void *)v163 + 336);
          *(void *)(v13 + 328) = 0;
          *(void *)(v13 + 336) = 0;
          if (v14) {
            sub_10004D2C8(v14);
          }
          sub_100261994((uint64_t *)v171, (uint64_t)"Notify option timer expired");
        }
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
    }
  }
LABEL_34:
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
  uint64_t v17 = *(void *)(v1 + 344);
  if (v17 && *(unsigned char *)(v17 + 274) && *(unsigned char *)(v17 + 275))
  {
    *(unsigned char *)(v17 + 275) = 0;
    __int16 v18 = *(std::__shared_weak_count **)(v17 + 264);
    *(void *)(v17 + 256) = 0;
    *(void *)(v17 + 264) = 0;
    if (v18) {
      sub_10004D2C8(v18);
    }
    uint64_t v19 = *(NSObject **)(v1 + 48);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "Location update is due";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Queuing up Rs loc update. Reason: %s", buf, 0xCu);
    }
    operator new();
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
  uint64_t v20 = *(void *)(v1 + 392);
  if (v20)
  {
    if (*(unsigned char *)(v20 + 184))
    {
      uint64_t v21 = 0;
      uint64_t v20 = 0;
    }
    else
    {
      uint64_t v21 = *(std::__shared_weak_count **)(v1 + 400);
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  uint64_t v22 = *(void *)(v1 + 376);
  if (v22)
  {
    BOOL v23 = *(unsigned char *)(v22 + 74) != 0;
    if (v20)
    {
LABEL_50:
      BOOL v24 = *(unsigned char *)(v20 + 120) != 0;
      goto LABEL_53;
    }
  }
  else
  {
    BOOL v23 = 0;
    if (v20) {
      goto LABEL_50;
    }
  }
  BOOL v24 = 0;
LABEL_53:
  uint64_t v162 = v2;
  if (v23 || v24)
  {
    uint64_t v25 = *(void *)(v1 + 360);
    if (v25)
    {
      unsigned int v26 = *(unsigned __int16 *)(v25 + 194);
      int v27 = *(unsigned char *)(v25 + 161) ? (*(unsigned char *)(v25 + 160) + 1) & 0xF : 0;
      if (v26 < 0x100 || v27 != v26)
      {
        if (v22) {
          sub_1004FB7E8(v22, 0);
        }
        if (v20) {
          sub_1006BE898(v20, 0);
        }
        uint64_t v28 = *(NSObject **)(v1 + 48);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Queuing up CarrierPigeonStart", buf, 2u);
        }
        operator new();
      }
    }
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint64_t v29 = *(void *)(v1 + 392);
  if (v29 && !*(unsigned char *)(v29 + 184))
  {
    BOOL v30 = *(std::__shared_weak_count **)(v1 + 400);
    if (v30) {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)std::string __p = 0;
    sub_1006BFF9C(v29, __p);
    if (*(void *)__p)
    {
      char v31 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Queuing up SatSmsStart", buf, 2u);
      }
      sub_1006BEC64(v29, 0);
      uint64_t v32 = *(void *)(*(void *)__p + 104);
      uint64_t v33 = *(std::__shared_weak_count **)(*(void *)__p + 112);
      if (v33)
      {
        atomic_fetch_add_explicit(&v33->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v33->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      int v34 = *(std::__shared_weak_count **)(v29 + 176);
      *(void *)(v29 + 168) = v32;
      *(void *)(v29 + 176) = v33;
      if (v34) {
        std::__shared_weak_count::__release_weak(v34);
      }
      if (v33) {
        std::__shared_weak_count::__release_weak(v33);
      }
      int v35 = *(unsigned __int16 *)(*(void *)__p + 8);
      CFUUIDRef v36 = CFUUIDCreate(kCFAllocatorDefault);
      uint64_t v37 = *(void *)__p;
      *(void *)std::string __p = 0;
      if (v35 == 8) {
        unsigned __int8 v38 = 1;
      }
      else {
        unsigned __int8 v38 = 2 * (v35 == 1);
      }
      if (v37) {
        uint64_t v39 = v37 + 16;
      }
      else {
        uint64_t v39 = 0;
      }
      *(void *)std::string buf = v36;
      *(void *)&uint8_t buf[8] = v39;
      uint8_t buf[16] = 0;
      BYTE6(v182) = 0;
      v185[0] = 0;
      v185[1] = 0;
      uint64_t v183 = 0;
      v184 = v185;
      int v186 = 0;
      __int16 v187 = 0;
      uint64_t v188 = 0;
      int v189 = 0;
      char v190 = 0;
      char v191 = 0;
      char v192 = 0;
      char v193 = 0;
      char v194 = 0;
      unsigned __int8 v195 = v38;
      unsigned __int8 v196 = v38;
      sub_100272838((uint64_t **)(v1 + 520), v38, (long long *)buf);
      sub_10005D144(v185[0]);
      uint64_t v2 = v162;
      if (BYTE6(v182) && *(void *)&buf[16])
      {
        v180 = *(const char **)&buf[16];
        operator delete(*(void **)&buf[16]);
      }
      uint64_t v40 = *(void *)&buf[8];
      *(void *)&uint8_t buf[8] = 0;
      if (v40) {
        (*(void (**)(uint64_t))(*(void *)v40 + 24))(v40);
      }
      sub_10012577C((const void **)buf);
      uint64_t v41 = *(void *)__p;
      *(void *)std::string __p = 0;
      if (v41) {
        (*(void (**)(uint64_t))(*(void *)v41 + 24))(v41);
      }
    }
    if (v30) {
      sub_10004D2C8(v30);
    }
  }
  sub_100262404(v1);
  if (*(void *)(v1 + 536))
  {
    long long v175 = 0uLL;
    uint64_t v176 = 0;
    uint64_t v42 = *(uint64_t **)(v1 + 520);
    v170 = (uint64_t *)(v1 + 528);
    if (v42 != (uint64_t *)(v1 + 528))
    {
      unsigned __int8 v166 = 0;
      uint64_t v168 = v1 + 304;
      unint64_t v161 = 0;
      v164 = (uint64_t *)(v1 + 784);
      while (1)
      {
        if (!v42[6]) {
          __TUAssertTrigger();
        }
        if (v42[5]) {
          unsigned int v43 = sub_100136254;
        }
        else {
          unsigned int v43 = 0;
        }
        if (!v43) {
          __TUAssertTrigger();
        }
        char v44 = (uint64_t (***)(void))(v42[6] + *(void *)(*(void *)v42[6] - 48));
        uint64_t v45 = (**v44)(v44);
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
        if ((*(_WORD *)(v1 + 416) & (unsigned __int16)v45) == 0) {
          goto LABEL_112;
        }
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
        if ((sub_10025C21C(v1, *(_DWORD *)(v1 + 800)) & v45) != 0
          || (*(_WORD *)(v1 + 804) & (unsigned __int16)v45) != 0
          || ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v42[6] + 48))(v42[6], v168) & 1) != 0
          || *((unsigned char *)v42 + 125))
        {
          goto LABEL_112;
        }
        if (*((unsigned char *)v42 + 124))
        {
          if (*((unsigned char *)v42 + 80))
          {
            dispatch_assert_queue_V2(*(dispatch_queue_t *)v2);
            if (_os_feature_enabled_impl())
            {
              uint64_t v47 = v42[13];
              if (v47)
              {
                int v48 = v42 + 13;
                do
                {
                  if (*(unsigned char *)(v47 + 25)) {
                    int v49 = (uint64_t *)v47;
                  }
                  else {
                    int v49 = (uint64_t *)(v47 + 8);
                  }
                  if (*(unsigned char *)(v47 + 25)) {
                    int v48 = (uint64_t *)v47;
                  }
                  uint64_t v47 = *v49;
                }
                while (*v49);
                if (v48 != v42 + 13 && *((unsigned __int8 *)v48 + 25) <= 1u)
                {
                  BOOL v50 = *(NSObject **)(v1 + 48);
                  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
                  {
                    log = v50;
                    uint64_t v51 = v42[6] + *(void *)(*(void *)v42[6] - 48);
                    unsigned int v52 = (*(uint64_t (**)(uint64_t))(*(void *)v51 + 8))(v51);
                    std::string::size_type v53 = sub_10093AA58(v52);
                    sub_100BC8FAC((CFUUIDRef *)v42 + 5, buf);
                    char v54 = buf;
                    if (buf[23] < 0) {
                      char v54 = *(unsigned char **)buf;
                    }
                    *(_DWORD *)std::string __p = 136315394;
                    *(void *)&__p[4] = v53;
                    *(_WORD *)&__p[12] = 2080;
                    *(void *)&__p[14] = v54;
                    _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I [Re-encoding] Cancel send attempt of %s, with messageID: %s", __p, 0x16u);
                    if ((buf[23] & 0x80000000) != 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                  (*(void (**)(void, uint64_t *))(**(void **)(v1 + 112) + 176))(*(void *)(v1 + 112), v42 + 5);
                  sub_100272768((uint64_t **)v42 + 12, 1u);
                  ++*((_DWORD *)v42 + 33);
                  ++*(_DWORD *)(v1 + 580);
                }
              }
            }
            uint64_t v55 = *(NSObject **)(v1 + 48);
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v56 = v42[6] + *(void *)(*(void *)v42[6] - 48);
              unsigned int v57 = (*(uint64_t (**)(uint64_t))(*(void *)v56 + 8))(v56);
              __int16 v58 = sub_10093AA58(v57);
              sub_100BC8FAC((CFUUIDRef *)v42 + 5, buf);
              std::string::size_type v59 = buf;
              if (buf[23] < 0) {
                std::string::size_type v59 = *(unsigned char **)buf;
              }
              *(_DWORD *)std::string __p = 136315394;
              *(void *)&__p[4] = v58;
              *(_WORD *)&__p[12] = 2080;
              *(void *)&__p[14] = v59;
              _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I [Re-encoding] Will re-encode: %s, with messageID: %s", __p, 0x16u);
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
            }
            if (*((unsigned char *)v42 + 80))
            {
              BOOL v60 = (void *)v42[7];
              if (v60)
              {
                unsigned char v42[8] = (uint64_t)v60;
                operator delete(v60);
              }
              *((unsigned char *)v42 + 80) = 0;
            }
          }
          else
          {
            uint64_t v61 = *(NSObject **)(v1 + 48);
            if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v62 = v42[6] + *(void *)(*(void *)v42[6] - 48);
              unsigned int v63 = (*(uint64_t (**)(uint64_t))(*(void *)v62 + 8))(v62);
              uint64_t v64 = sub_10093AA58(v63);
              sub_100BC8FAC((CFUUIDRef *)v42 + 5, buf);
              uint64_t v65 = buf;
              if (buf[23] < 0) {
                uint64_t v65 = *(unsigned char **)buf;
              }
              *(_DWORD *)std::string __p = 136315394;
              *(void *)&__p[4] = v64;
              *(_WORD *)&__p[12] = 2080;
              *(void *)&__p[14] = v65;
              _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I [Re-encoding] Not required for %s, with messageID: %s", __p, 0x16u);
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
            }
          }
          *((unsigned char *)v42 + 124) = 0;
        }
        if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v42[6] + 40))(v42[6], v168))
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)v2);
          uint64_t v66 = (char *)v42[6];
          if (!v66)
          {
            __TUAssertTrigger();
            uint64_t v66 = (char *)v42[6];
          }
          if ((*(unsigned int (**)(char *))(*(void *)&v66[*(void *)(*(void *)v66 - 48)] + 8))(&v66[*(void *)(*(void *)v66 - 48)]) == 6)
          {
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
            if ((*(_WORD *)(v1 + 416) & 8) != 0)
            {
              uint64_t v67 = *(void *)(v1 + 344);
              char v68 = *(NSObject **)(v1 + 48);
              if (v67)
              {
                if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)std::string buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I Attempting to rebuild environment for new roadside conversation and marking any pending outgoing messages for old conversation as invalid", buf, 2u);
                  uint64_t v67 = *(void *)(v1 + 344);
                }
                unint64_t v69 = sub_101125A48(v67);
                sub_1004D01D0(v168);
                buf[0] = 0;
                BOOL v70 = *(unsigned char *)(v1 + 896) != 0;
                if (*(unsigned char *)(v1 + 896)) {
                  uint64_t v71 = *(void *)(v1 + 888) + 1;
                }
                else {
                  uint64_t v71 = 0;
                }
                *(void *)&uint8_t buf[8] = v71;
                *(void *)&uint8_t buf[16] = v70;
                sub_1004D00E8(v168, (void *)(v1 + 64));
                uint64_t v72 = *(void *)(v1 + 344);
                if (v72)
                {
                  if ((v69 & 0xFF00000000) != 0) {
                    uint64_t v73 = v69;
                  }
                  else {
                    uint64_t v73 = 0;
                  }
                  sub_101125B24(v72, v73);
                  if (*v164) {
                    sub_1011261B4(*(void **)(v1 + 344), v164);
                  }
                  sub_10025CBB0(v1);
                  uint64_t v74 = *(void *)(v1 + 112);
                  uint64_t v75 = sub_10025C910(v1);
                  (*(void (**)(uint64_t, uint64_t))(*(void *)v74 + 168))(v74, v75);
                  char v76 = *(NSObject **)(v1 + 48);
                  if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)std::string buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I Finished setting up roadside environment for new roadside conversation", buf, 2u);
                  }
                  sub_10025BAD4(v1);
                  sub_10025DC48(v1);
                  goto LABEL_169;
                }
                unsigned int v96 = *(NSObject **)(v1 + 48);
                if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)std::string buf = 0;
                  unsigned int v94 = v96;
                  unsigned int v95 = "Something went terribly wrong, failed to create roadside environmen!";
                  goto LABEL_212;
                }
              }
              else if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)std::string buf = 0;
                unsigned int v94 = v68;
                unsigned int v95 = "Roadside environment is not setup";
                goto LABEL_212;
              }
            }
            else
            {
              unsigned int v93 = *(NSObject **)(v1 + 48);
              if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)std::string buf = 0;
                unsigned int v94 = v93;
                unsigned int v95 = "Roadside service is not active";
LABEL_212:
                _os_log_error_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, v95, buf, 2u);
              }
            }
          }
        }
LABEL_169:
        if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v42[6] + 56))(v42[6], v168))
        {
          uint64_t v77 = v42[6];
          *(void *)std::string __p = v1;
          uint64_t v78 = *(std::__shared_weak_count **)(v1 + 24);
          if (!v78 || (v79 = *(void *)(v1 + 16), (int v80 = std::__shared_weak_count::lock(v78)) == 0)) {
            sub_100088B9C();
          }
          *(void *)&__p[8] = v79;
          *(void *)&__p[16] = v80;
          atomic_fetch_add_explicit(&v80->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v80);
          sub_10012A394(&v178, (const void **)v42 + 5);
          v180 = 0;
          v81 = (char *)operator new(0x28uLL);
          *(void *)v81 = off_1019B0A18;
          *(_OWORD *)(v81 + 8) = *(_OWORD *)__p;
          uint64_t v82 = *(void *)&__p[16];
          uint64_t v83 = v178;
          *(void *)&__p[8] = 0;
          *(void *)&__p[16] = 0;
          *((void *)v81 + 3) = v82;
          *((void *)v81 + 4) = v83;
          v178 = 0;
          v180 = v81;
          (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v77 + 64))(v77, v168, buf);
          sub_10026E5BC(buf);
          sub_10012577C(&v178);
          uint64_t v2 = v162;
          if (*(void *)&__p[16]) {
            std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&__p[16]);
          }
          uint64_t v84 = (uint64_t *)v42[1];
          if (v84)
          {
            do
            {
              uint64_t v42 = v84;
              uint64_t v84 = (uint64_t *)*v84;
            }
            while (v84);
          }
          else
          {
            do
            {
              uint64_t v85 = v42;
              uint64_t v42 = (uint64_t *)v42[2];
            }
            while ((uint64_t *)*v42 != v85);
          }
          goto LABEL_113;
        }
        if (*((unsigned char *)v42 + 80)
          || !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v42[6] + 72))(v42[6], v168))
        {
          goto LABEL_186;
        }
        (*(void (**)(unsigned char *__return_ptr))(*(void *)v42[6] + 88))(buf);
        sub_10026E640((uint64_t)(v42 + 7), (__n128 *)buf);
        if ((_BYTE)v180 && *(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
        if (*((unsigned char *)v42 + 80))
        {
          v42[11] = v42[8] - v42[7];
LABEL_186:
          if (v42[14])
          {
            uint64_t v86 = v42[13];
            uint64_t v87 = *((unsigned __int8 *)v42 + 192);
            unsigned __int8 v88 = v166;
            if (v166 <= v87) {
              unsigned __int8 v88 = *((unsigned char *)v42 + 192);
            }
            unsigned __int8 v166 = v88;
            if (v86)
            {
              uint64_t v89 = v42 + 13;
              do
              {
                if (*(unsigned char *)(v86 + 25)) {
                  uint64_t v90 = (uint64_t *)v86;
                }
                else {
                  uint64_t v90 = (uint64_t *)(v86 + 8);
                }
                if (*(unsigned char *)(v86 + 25)) {
                  uint64_t v89 = (uint64_t *)v86;
                }
                uint64_t v86 = *v90;
              }
              while (*v90);
              if (v89 != v42 + 13 && *((unsigned __int8 *)v89 + 25) <= 1u)
              {
                ++*((void *)&v175 + v87);
                ++v161;
              }
            }
          }
          uint64_t v91 = (uint64_t *)v42[1];
          if (v91)
          {
            do
            {
              uint64_t v42 = v91;
              uint64_t v91 = (uint64_t *)*v91;
            }
            while (v91);
          }
          else
          {
            do
            {
              unsigned int v92 = v42;
              uint64_t v42 = (uint64_t *)v42[2];
            }
            while ((uint64_t *)*v42 != v92);
          }
          goto LABEL_113;
        }
LABEL_112:
        sub_10026259C(v1, v45, (uint64_t)(v42 + 5));
        std::string::size_type v46 = sub_10006C514((uint64_t **)(v1 + 520), v42);
        sub_10026F19C((uint64_t)(v42 + 4));
        operator delete(v42);
        uint64_t v42 = v46;
LABEL_113:
        if (v42 == v170) {
          goto LABEL_214;
        }
      }
    }
    unsigned __int8 v166 = 0;
    unint64_t v161 = 0;
LABEL_214:
    if (*(void *)(v1 + 504))
    {
      uint64_t v97 = *(uint64_t **)(v1 + 520);
      if (v97 != v170)
      {
        uint64_t v169 = v1 + 304;
        v157 = (_DWORD *)(v1 + 584);
        uint64_t v154 = v1 + 1192;
        v155 = (_DWORD *)(v1 + 576);
        uint64_t v159 = v1;
        uint64_t v167 = v1 + 496;
        while (1)
        {
          if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v97[6] + 96))(v97[6], v169))
          {
            uint64_t v98 = v97[13];
            if (v98)
            {
              uint64_t v99 = v97 + 13;
              do
              {
                if (*(unsigned char *)(v98 + 25)) {
                  uint64_t v100 = (uint64_t *)v98;
                }
                else {
                  uint64_t v100 = (uint64_t *)(v98 + 8);
                }
                if (*(unsigned char *)(v98 + 25)) {
                  uint64_t v99 = (uint64_t *)v98;
                }
                uint64_t v98 = *v100;
              }
              while (*v100);
              if (v99 != v97 + 13 && *((unsigned __int8 *)v99 + 25) <= 1u)
              {
                dispatch_assert_queue_V2(*(dispatch_queue_t *)v2);
                if (_os_feature_enabled_impl())
                {
                  uint64_t v101 = *(NSObject **)(v1 + 48);
                  if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v102 = v97[6] + *(void *)(*(void *)v97[6] - 48);
                    unsigned int v103 = (*(uint64_t (**)(uint64_t))(*(void *)v102 + 8))(v102);
                    unsigned int v104 = sub_10093AA58(v103);
                    sub_100BC8FAC((CFUUIDRef *)v97 + 5, buf);
                    unsigned int v105 = buf;
                    if (buf[23] < 0) {
                      unsigned int v105 = *(unsigned char **)buf;
                    }
                    *(_DWORD *)std::string __p = 136315394;
                    *(void *)&__p[4] = v104;
                    *(_WORD *)&__p[12] = 2080;
                    *(void *)&__p[14] = v105;
                    _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "#I Temporarily cancel existing %s, with messageID: %s, will attempt later", __p, 0x16u);
                    if ((buf[23] & 0x80000000) != 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                  (*(void (**)(void, uint64_t *))(**(void **)(v1 + 112) + 176))(*(void *)(v1 + 112), v97 + 5);
                  sub_100272768((uint64_t **)v97 + 12, 1u);
                  ++*((_DWORD *)v97 + 33);
                  ++*(_DWORD *)(v1 + 580);
                }
              }
            }
            goto LABEL_322;
          }
          unsigned int v106 = (void *)v167;
          if (*((unsigned char *)v97 + 80))
          {
            if (*((unsigned __int8 *)v97 + 192) >= v166)
            {
              unsigned int v107 = *(void **)(v1 + 488);
              if (v107 != (void *)v167) {
                break;
              }
            }
          }
LABEL_322:
          v152 = (uint64_t *)v97[1];
          if (v152)
          {
            do
            {
              v153 = v152;
              v152 = (uint64_t *)*v152;
            }
            while (v152);
          }
          else
          {
            do
            {
              v153 = (uint64_t *)v97[2];
              BOOL v9 = *v153 == (void)v97;
              uint64_t v97 = v153;
            }
            while (!v9);
          }
          uint64_t v97 = v153;
          if (v153 == v170) {
            goto LABEL_328;
          }
        }
        v165 = (CFUUIDRef *)(v97 + 5);
        __int16 v108 = v97 + 13;
        v156 = (int *)(v97 + 16);
        v160 = (int *)(v97 + 17);
        while (1)
        {
          unsigned int v109 = *((unsigned __int8 *)v107 + 25);
          uint64_t v110 = *v108;
          if (*v108)
          {
            __int16 v111 = v97 + 13;
            do
            {
              unsigned int v112 = *(unsigned __int8 *)(v110 + 25);
              BOOL v113 = v112 >= v109;
              if (v112 >= v109) {
                __int16 v114 = (uint64_t *)v110;
              }
              else {
                __int16 v114 = (uint64_t *)(v110 + 8);
              }
              if (v113) {
                __int16 v111 = (uint64_t *)v110;
              }
              uint64_t v110 = *v114;
            }
            while (*v114);
            if (v111 != v108 && v109 >= *((unsigned __int8 *)v111 + 25)) {
              goto LABEL_313;
            }
          }
          if (v109 == 2) {
            break;
          }
          if (v109 == 1)
          {
            uint64_t v115 = *(void *)(v1 + 112);
            uint64_t v116 = *(std::__shared_weak_count **)(v1 + 120);
            if (v116) {
              goto LABEL_253;
            }
            goto LABEL_254;
          }
LABEL_313:
          v150 = (void *)v107[1];
          if (v150)
          {
            do
            {
              v151 = v150;
              v150 = (void *)*v150;
            }
            while (v150);
          }
          else
          {
            do
            {
              v151 = (void *)v107[2];
              BOOL v9 = *v151 == (void)v107;
              unsigned int v107 = v151;
            }
            while (!v9);
          }
          unsigned int v107 = v151;
          if (v151 == v106) {
            goto LABEL_322;
          }
        }
        uint64_t v115 = *(void *)(v1 + 128);
        uint64_t v116 = *(std::__shared_weak_count **)(v1 + 136);
        if (v116) {
LABEL_253:
        }
          atomic_fetch_add_explicit(&v116->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_254:
        if (!v115
          || (__int16 v117 = (uint64_t (***)(void))(v97[6] + *(void *)(*(void *)v97[6] - 48)),
              uint64_t v118 = (**v117)(v117),
              ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v115 + 8))(v115, v118) & 1) == 0))
        {
LABEL_311:
          if (v116) {
            sub_10004D2C8(v116);
          }
          goto LABEL_313;
        }
        if (v109 == 2)
        {
          int v123 = *v160;
          if (!*v160) {
            ++*(_DWORD *)(v1 + 592);
          }
          uint64_t v122 = v97 + 17;
          long long v124 = v157;
        }
        else
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)v2);
          int v119 = _os_feature_enabled_impl();
          unint64_t v120 = 3;
          if (!v119) {
            unint64_t v120 = 1;
          }
          if (v161 >= v120) {
            goto LABEL_311;
          }
          uint64_t v121 = *((unsigned __int8 *)v97 + 192);
          if (*((void *)&v175 + v121)) {
            goto LABEL_311;
          }
          ++v161;
          *((void *)&v175 + v121) = 1;
          uint64_t v122 = v97 + 16;
          int v123 = *v156;
          if (!*v156) {
            ++*(_DWORD *)(v1 + 588);
          }
          long long v124 = v155;
        }
        *uint64_t v122 = v123 + 1;
        ++*v124;
        unsigned __int8 v166 = *((unsigned char *)v97 + 192);
        long long v125 = *(NSObject **)(v1 + 48);
        if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
        {
          sub_100BC8FAC(v165, __p);
          if (__p[23] >= 0) {
            v126 = __p;
          }
          else {
            v126 = *(unsigned char **)__p;
          }
          uint64_t v127 = v97[6] + *(void *)(*(void *)v97[6] - 48);
          unsigned int v128 = (*(uint64_t (**)(uint64_t))(*(void *)v127 + 8))(v127);
          uint64_t v129 = sub_10093AA58(v128);
          v130 = "???";
          if (v109 == 1) {
            v130 = "kBB";
          }
          if (v109 == 2) {
            long long v131 = "kInternet";
          }
          else {
            long long v131 = v130;
          }
          if (!*((unsigned char *)v97 + 80)) {
            sub_10016C840();
          }
          uint64_t v132 = v129;
          ctu::hex_sp();
          __int16 v133 = v171;
          if (v172 < 0) {
            __int16 v133 = (void **)v171[0];
          }
          *(_DWORD *)std::string buf = 136446978;
          *(void *)&uint8_t buf[4] = v126;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v132;
          *(_WORD *)&unsigned char buf[22] = 2080;
          v180 = v131;
          __int16 v181 = 2080;
          v182 = v133;
          _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "#I Attempting message (id: %{public}s, type: %s, transport: %s) with encrypted contents: %s", buf, 0x2Au);
          if (v172 < 0) {
            operator delete(v171[0]);
          }
          uint64_t v1 = v159;
          uint64_t v2 = v162;
          unsigned int v106 = (void *)v167;
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v97[6] + 104))(v97[6], v169);
        if (*(void *)v163)
        {
          uint64_t v134 = v97[6] + *(void *)(*(void *)v97[6] - 48);
          if ((*(unsigned int (**)(uint64_t))(*(void *)v134 + 8))(v134) == 1)
          {
            uint64_t v135 = *(void *)(v1 + 312);
            uint64_t v137 = *(void *)(v135 + 112);
            uint64_t v136 = *(void *)(v135 + 120);
            *(void *)(v1 + 888) = v137;
            *(unsigned char *)(v1 + 896) = v136;
            sub_10025A5B0(v1, 0, 0, 0, 0);
          }
        }
        if (*(void *)(v1 + 344))
        {
          uint64_t v138 = v97[6] + *(void *)(*(void *)v97[6] - 48);
          if ((*(unsigned int (**)(uint64_t))(*(void *)v138 + 8))(v138) == 6)
          {
            uint64_t v139 = *(void *)(v1 + 344);
            uint64_t v141 = *(void *)(v139 + 112);
            uint64_t v140 = *(void *)(v139 + 120);
            *(void *)(v1 + 904) = v141;
            *(unsigned char *)(v1 + 912) = v140;
            sub_10025A854(v1, 0, 0);
          }
        }
        uint64_t v142 = *(void *)(v1 + 392);
        if (v142 && !*(unsigned char *)(v142 + 184))
        {
          v143 = *(std::__shared_weak_count **)(v1 + 400);
          if (v143) {
            atomic_fetch_add_explicit(&v143->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_1006BEB94(v142, (uint64_t *)buf);
          if (*(void *)&buf[16])
          {
            uint64_t v144 = v97[6] + *(void *)(*(void *)v97[6] - 48);
            int v145 = (*(uint64_t (**)(uint64_t))(*(void *)v144 + 8))(v144);
            sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
            BOOL v9 = v145 == 10;
            unsigned int v106 = (void *)v167;
            if (v9)
            {
              v146 = *(NSObject **)(v1 + 48);
              if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "#I Marking ShutDownSatSms is needed", buf, 2u);
              }
              sub_10025CAD8(v154, 1u);
              unsigned int v106 = (void *)v167;
              sub_10025AC04(v1);
              sub_10025AA94(v1);
            }
            if (!v143) {
              goto LABEL_303;
            }
          }
          else
          {
            sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
            if (!v143) {
              goto LABEL_303;
            }
          }
          sub_10004D2C8(v143);
        }
LABEL_303:
        sub_100272C6C((uint64_t **)v97 + 12, v109, v109);
        if (!*((unsigned char *)v97 + 152))
        {
          Registry::getTimerService((uint64_t *)buf, *(Registry **)(v1 + 64));
          uint64_t v147 = (***(uint64_t (****)(void))buf)(*(void *)buf);
          if (!*((unsigned char *)v97 + 152)) {
            *((unsigned char *)v97 + 152) = 1;
          }
          v97[18] = v147;
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          ++*(_DWORD *)(v1 + 596);
        }
        sub_100262CE0(v1, (uint64_t)v165, v109, 1);
        v148 = (uint64_t (***)(void))(v97[6] + *(void *)(*(void *)v97[6] - 48));
        uint64_t v149 = (**v148)(v148);
        if (!*((unsigned char *)v97 + 80)) {
          sub_10016C840();
        }
        (*(void (**)(uint64_t, CFUUIDRef *, uint64_t, uint64_t *, void))(*(void *)v115 + 32))(v115, v165, v149, v97 + 7, *((unsigned __int8 *)v97 + 192));
        goto LABEL_311;
      }
    }
LABEL_328:
    sub_100262404(v1);
  }
}

void sub_10025FAC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  sub_10003B34C((void *)(v44 - 256));
  if (a34) {
    sub_10004D2C8(a34);
  }
  if (a44 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10025FD80(uint64_t a1, unsigned int *a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  unsigned int v4 = *(unsigned __int16 *)(a1 + 416);
  if (*(_WORD *)(a1 + 416))
  {
    CFNumberRef v5 = (unsigned __int16 *)(a1 + 416);
    uint64_t v6 = *(NSObject **)(a1 + 48);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    __int16 v8 = v4;
    if (v7)
    {
      BOOL v9 = sub_100BC8B90(*a2);
      uint64_t v10 = v9;
      if (*((unsigned char *)a2 + 8)) {
        std::string::size_type v11 = "true";
      }
      else {
        std::string::size_type v11 = "false";
      }
      if (*((unsigned char *)a2 + 6))
      {
        sub_100BC897C(*((unsigned __int16 *)a2 + 2), &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = v10;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v11;
        *(_WORD *)&unsigned char buf[22] = 2080;
        BOOL v30 = (const char *)p_p;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Exit Stewie (if required) (Reason: %s, Alert User: %s), filter: %s", buf, 0x20u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v11;
        *(_WORD *)&unsigned char buf[22] = 2080;
        BOOL v30 = "<none>";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Exit Stewie (if required) (Reason: %s, Alert User: %s), filter: %s", buf, 0x20u);
      }
      __int16 v8 = *v5;
    }
    uint64_t v13 = a2 + 1;
    if (!*((unsigned char *)a2 + 6)) {
      uint64_t v13 = (_WORD *)(a1 + 416);
    }
    uint64_t v14 = (unsigned __int16)(*v13 & v8);
    uint64_t v15 = *a2;
    *(void *)std::string buf = off_1019B1288;
    *(void *)&uint8_t buf[8] = a1;
    *(void *)&uint8_t buf[16] = v15;
    BOOL v30 = buf;
    sub_100BC88BC(v14, (uint64_t)buf);
    sub_10026ED50(buf);
    int v16 = *v5;
    if (v16 == v4)
    {
      uint64_t v17 = *(NSObject **)(a1 + 48);
      BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (!v18) {
        return result;
      }
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I No services were torn down", buf, 2u);
      return 0;
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    int v20 = v4 & ~v16;
    int v21 = *(unsigned __int16 *)(a1 + 416);
    uint64_t v22 = *(NSObject **)(a1 + 48);
    BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    if (v21)
    {
      if (v23)
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Exit Stewie - partial teardown", buf, 2u);
      }
      StewieDataController::submitStewieExitMetric(a1, *a2, v4);
      sub_100260260((Registry **)(a1 + 64), v20, *(unsigned __int16 *)(a1 + 416), (uint64_t)a2);
      sub_10025BAD4(a1);
      sub_10025DC48(a1);
      return 0;
    }
    if (v23)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Exit Stewie - complete teardown", buf, 2u);
    }
    (*(void (**)(void, void))(**(void **)(a1 + 96) + 8))(*(void *)(a1 + 96), 0);
    sub_1004D0740(a1 + 304, 0);
    StewieDataController::submitStewieExitMetric(a1, *a2, v4);
    *(void *)(a1 + 544) = 0;
    *(_WORD *)(a1 + 552) = 0;
    *(_OWORD *)(a1 + 560) = 0u;
    *(_OWORD *)(a1 + 576) = 0u;
    *(_OWORD *)(a1 + 592) = 0u;
    *(_OWORD *)(a1 + 602) = 0u;
    *(_DWORD *)(a1 + 620) = 1;
    *(unsigned char *)(a1 + 624) = 0;
    *(unsigned char *)(a1 + 632) = 0;
    *(void *)(a1 + 640) = 0;
    *(unsigned char *)(a1 + 648) = 0;
    *(unsigned char *)(a1 + 656) = 0;
    *(unsigned char *)(a1 + 664) = 0;
    *(unsigned char *)(a1 + 672) = 0;
    buf[0] = 0;
    LOBYTE(v30) = 0;
    long long v32 = 0uLL;
    memset(v31, 0, sizeof(v31));
    sub_10026E640(a1 + 752, (__n128 *)buf);
    long long v24 = *(_OWORD *)v31;
    *(_OWORD *)char v31 = 0uLL;
    uint64_t v25 = *(std::__shared_weak_count **)(a1 + 792);
    *(_OWORD *)(a1 + 784) = v24;
    if (v25) {
      sub_10004D2C8(v25);
    }
    *(_DWORD *)(a1 + 800) = *(_DWORD *)&v31[16];
    *(_WORD *)(a1 + 804) = *(_WORD *)&v31[20];
    long long v26 = v32;
    long long v32 = 0uLL;
    int v27 = *(std::__shared_weak_count **)(a1 + 816);
    *(_OWORD *)(a1 + 808) = v26;
    if (v27)
    {
      sub_10004D2C8(v27);
      if (*((void *)&v32 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
      }
    }
    if (*(void *)&v31[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v31[8]);
    }
    if ((_BYTE)v30 && *(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    sub_10025BAD4(a1);
    sub_10026F148(*(void **)(a1 + 528));
    *(void *)(a1 + 520) = a1 + 528;
    *(void *)(a1 + 536) = 0;
    *(void *)(a1 + 528) = 0;
    (*(void (**)(void, void))(**(void **)(a1 + 96) + 24))(*(void *)(a1 + 96), 0);
    *(unsigned char *)(a1 + 512) = 0;
    sub_10005D144(*(void **)(a1 + 496));
    *(void *)(a1 + 496) = 0;
    *(void *)(a1 + 504) = 0;
    *(void *)(a1 + 488) = a1 + 496;
    *(void *)(a1 + 456) = 0;
    sub_10026040C((void *)a1);
    sub_100260260((Registry **)(a1 + 64), v20, *(unsigned __int16 *)(a1 + 416), (uint64_t)a2);
  }
  return 1;
}

void sub_100260234(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100260260(Registry **a1, int a2, int a3, uint64_t a4)
{
  if (!a2 || !*(unsigned char *)(a4 + 8)) {
    return;
  }
  if (a2 == 2)
  {
    CFStringRef v5 = @"BIFROST_DEMO_EXIT_TITLE";
    CFStringRef v6 = @"BIFROST_DEMO_EXIT_MESSAGE";
  }
  else
  {
    unsigned __int16 v8 = a2 & 0xFFEF;
    if ((~a2 & 0x30) != 0) {
      unsigned __int16 v8 = a2;
    }
    if (a3)
    {
      v12[0] = off_1019B0998;
      v12[1] = a1;
      void v12[2] = a4;
      v12[3] = v12;
      sub_100BC88BC(v8, (uint64_t)v12);
      sub_10026ED50(v12);
      return;
    }
    unsigned int v9 = *(_DWORD *)a4;
    if ((v8 & (unsigned __int16)(v8 - 1)) == 0)
    {
      int v10 = v8;
      CFStringRef v11 = sub_10026DF00(v8, *(_DWORD *)a4);
      CFStringRef v6 = sub_10026DFF8(v10, v9);
      BOOL v7 = a1;
      CFStringRef v5 = v11;
      goto LABEL_6;
    }
    CFStringRef v6 = (const __CFString *)sub_10026E064(*(_DWORD *)a4);
    CFStringRef v5 = @"BIFROST_MULTIPLE_SERVICES_EXIT_TITLE";
  }
  BOOL v7 = a1;
LABEL_6:

  sub_1004B2FA8(v7, (uint64_t)v5, (uint64_t)v6);
}

void sub_1002603F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10026ED50((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_10026040C(void *a1)
{
  if (a1[20])
  {
    uint64_t v2 = (std::__shared_weak_count *)a1[21];
    a1[20] = 0;
    a1[21] = 0;
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = a1[6];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Stopping handover timer", v4, 2u);
    }
  }
}

BOOL sub_100260488(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 520);
  uint64_t v2 = (void *)(a1 + 528);
  if (v1 != (void *)(a1 + 528))
  {
    while (1)
    {
      uint64_t v3 = (char *)v1[6];
      if (((**(uint64_t (***)(char *))&v3[*(void *)(*(void *)v3 - 48)])(&v3[*(void *)(*(void *)v3 - 48)]) & 0x30) != 0
        || (*(unsigned int (**)(char *))(*(void *)&v3[*(void *)(*(void *)v3 - 48)] + 8))(&v3[*(void *)(*(void *)v3 - 48)]) == 10)
      {
        break;
      }
      unsigned int v4 = (void *)v1[1];
      if (v4)
      {
        do
        {
          CFStringRef v5 = v4;
          unsigned int v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          CFStringRef v5 = (void *)v1[2];
          BOOL v6 = *v5 == (void)v1;
          uint64_t v1 = v5;
        }
        while (!v6);
      }
      uint64_t v1 = v5;
      if (v5 == v2)
      {
        uint64_t v1 = v2;
        return v1 != v2;
      }
    }
  }
  return v1 != v2;
}

void sub_10026058C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Stop", v4, 2u);
  }
  (*(void (**)(void))(**(void **)(a1 + 112) + 88))(*(void *)(a1 + 112));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t sub_100260630(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

void sub_100260684(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v20 = 0;
  int v21 = 0;
  if (a2 == 8)
  {
    uint64_t v9 = *(void *)(a1 + 344);
    unsigned __int16 v8 = *(std::__shared_weak_count **)(a1 + 352);
    if (v8) {
LABEL_4:
    }
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    unsigned __int16 v8 = 0;
    if (a2 != 1) {
      goto LABEL_9;
    }
    uint64_t v9 = *(void *)(a1 + 312);
    unsigned __int16 v8 = *(std::__shared_weak_count **)(a1 + 320);
    if (v8) {
      goto LABEL_4;
    }
  }
  uint64_t v20 = v9;
  int v21 = v8;
  if (v9)
  {
    if (sub_1004D0838(a1 + 304, &v20) == 3)
    {
      unint64_t v10 = sub_101125A48(v9);
      unint64_t v11 = v10;
      if ((v10 & 0xFF00000000) == 0)
      {
        __TUAssertTrigger();
        sub_10016C840();
      }
      uint64_t v12 = *(void *)(a1 + 328);
      LODWORD(__p[0]) = v10;
      sub_1002723D4((uint64_t)&__p[1], a4);
      long long v24 = 0;
      uint64_t v13 = operator new(0x30uLL);
      *(void *)uint64_t v13 = off_1019B1308;
      v13[2] = __p[0];
      sub_1002723D4((uint64_t)(v13 + 4), (uint64_t)&__p[1]);
      long long v24 = v13;
      (*(void (**)(uint64_t, unint64_t, uint64_t, uint8_t *))(*(void *)v12 + 16))(v12, v11, a3, buf);
      sub_1002726E4(buf);
      sub_1001E8DA8(&__p[1]);
      goto LABEL_14;
    }
    int v16 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      if (_os_feature_enabled_impl())
      {
        unint64_t v17 = *(char *)(a1 + 408);
        if (v17 > 3) {
          BOOL v18 = "???";
        }
        else {
          BOOL v18 = off_1019B1CD0[v17];
        }
      }
      else
      {
        BOOL v18 = "kNotSupported";
      }
      uint64_t v19 = "initialized";
      if (!*(void *)(a1 + 328)) {
        uint64_t v19 = "missing";
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "[Compress] Compression manager state: %s, Compression Manager: %s", buf, 0x16u);
    }
    memset(buf, 0, sizeof(buf));
    sub_100260630(*(void *)(a4 + 24), 0, 0);
    uint64_t v15 = *(void **)buf;
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      goto LABEL_13;
    }
    goto LABEL_14;
  }
LABEL_9:
  uint64_t v14 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)sub_100BC87FC(a2);
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "[Compress] Not supported for service: %s", (uint8_t *)__p, 0xCu);
  }
  memset(__p, 0, 24);
  sub_100260630(*(void *)(a4 + 24), 0, 0);
  uint64_t v15 = __p[0];
  if (__p[0])
  {
    __p[1] = __p[0];
LABEL_13:
    operator delete(v15);
  }
LABEL_14:
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_100260994(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002609F8(uint64_t a1)
{
  return sub_10025B63C(a1 + 712, 0) == 1;
}

uint64_t sub_100260A34(uint64_t a1, uint64_t a2, int a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v6 = *(void *)(a1 + 848);
  if (a2)
  {
    if (v6) {
      goto LABEL_12;
    }
    BOOL v7 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [Stewie Only][Warmup] Acquiring CLECEA/CLEPTO for emergency", v12, 2u);
    }
    unsigned __int8 v14 = 1;
    unsigned __int8 v13 = 0;
    sub_100ECFEE0(&v14, &v13, v12);
    long long v8 = *(_OWORD *)v12;
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 856);
  }
  else
  {
    if (!v6) {
      goto LABEL_12;
    }
    unint64_t v10 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [Stewie Only][Warmup] Releasing CLECEA/CLEPTO for emergency", v12, 2u);
    }
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 856);
    long long v8 = 0uLL;
  }
  *(_OWORD *)(a1 + 848) = v8;
  if (v9) {
    sub_10004D2C8(v9);
  }
LABEL_12:
  if (*(unsigned __int8 *)(a1 + 224) != a3)
  {
    *(unsigned char *)(a1 + 224) = a3;
    if (a3)
    {
      *(_WORD *)(a1 + 225) = (*(unsigned char *)(a1 + 429) == 2) | 0x100;
    }
    else if (*(unsigned char *)(a1 + 226))
    {
      *(unsigned char *)(a1 + 226) = 0;
    }
    sub_10025BAD4(a1);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 104))(*(void *)(a1 + 112), a2);
}

uint64_t sub_100260BA8(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 112) + 112);

  return v2();
}

uint64_t sub_100260C0C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 112) + 120);

  return v2();
}

void sub_100260C68(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(unsigned __int16 *)(a1 + 416);
  if (*(_WORD *)(a1 + 416) && *(unsigned char *)(a1 + 302) == 1)
  {
    uint64_t v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [Re-initialize BB transport] 1. Disabling BB transport", buf, 2u);
      uint64_t v2 = *(unsigned __int16 *)(a1 + 416);
    }
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 112) + 24))(*(void *)(a1 + 112), 0x10000000DLL, v2);
    sub_100272768((uint64_t **)(a1 + 488), 1u);
    if (*(unsigned char *)(a1 + 776))
    {
      uint64_t v4 = *(void **)(a1 + 752);
      if (v4)
      {
        *(void *)(a1 + 760) = v4;
        operator delete(v4);
      }
      *(unsigned char *)(a1 + 776) = 0;
    }
    uint64_t v5 = *(uint64_t ***)(a1 + 520);
    if (v5 != (uint64_t **)(a1 + 528))
    {
      do
      {
        sub_100272768(v5 + 12, 1u);
        uint64_t v6 = v5[1];
        if (v6)
        {
          do
          {
            BOOL v7 = (uint64_t **)v6;
            uint64_t v6 = (uint64_t *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            BOOL v7 = (uint64_t **)v5[2];
            BOOL v8 = *v7 == (uint64_t *)v5;
            uint64_t v5 = v7;
          }
          while (!v8);
        }
        uint64_t v5 = v7;
      }
      while (v7 != (uint64_t **)(a1 + 528));
    }
    uint64_t v9 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [Re-initialize BB transport] 2. Re-enable BB transport", (uint8_t *)v10, 2u);
    }
    (*(void (**)(void, unint64_t, void, void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112), *(unsigned int *)(a1 + 456) | (unint64_t)&_mh_execute_header, *(unsigned __int16 *)(a1 + 416), *(unsigned int *)(a1 + 460));
  }
}

void sub_100260E20(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [Handling configuration change] We need to re-initialize baseband (if required)", v3, 2u);
  }
  sub_100260C68(a1);
}

uint64_t sub_100260E94(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 112) + 136);

  return v2();
}

uint64_t sub_100260EF8(uint64_t a1)
{
  void (***v10)(uint64_t *__return_ptr, void);
  char v11;
  uint64_t v12;
  std::mutex *v13;
  std::mutex *v14;
  unint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  unsigned int v18;
  void *v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  char v22;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t v26;

  long long v24 = 0;
  uint64_t v25 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v3 = ServiceMap;
  uint64_t v4 = "20ProfileManagedConfig";
  if (((unint64_t)"20ProfileManagedConfig" & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)((unint64_t)"20ProfileManagedConfig" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  long long v26 = (unint64_t)v4;
  BOOL v8 = sub_10004D37C(&v3[1].__m_.__sig, &v26);
  if (v8)
  {
    unint64_t v10 = (void (***)(uint64_t *__return_ptr, void))v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      unint64_t v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    unint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  unint64_t v11 = 1;
LABEL_9:
  (**v10)(&v24, v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (v24 && *(unsigned char *)(v24 + 3) && *(unsigned char *)(v24 + 2))
  {
    uint64_t v12 = 1;
    goto LABEL_31;
  }
  unsigned __int8 v13 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  unsigned __int8 v14 = v13;
  if ((v15 & 0x8000000000000000) != 0)
  {
    int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    unint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      BOOL v18 = *v16++;
      unint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(v13);
  long long v26 = v15;
  uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, &v26);
  if (v19)
  {
    int v21 = v19[3];
    uint64_t v20 = (std::__shared_weak_count *)v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      uint64_t v22 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    int v21 = 0;
  }
  std::mutex::unlock(v14);
  uint64_t v20 = 0;
  uint64_t v22 = 1;
LABEL_23:
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v21 + 16))(v21))
  {
    if ((v22 & 1) == 0) {
      sub_10004D2C8(v20);
    }
    goto LABEL_30;
  }
  uint64_t v12 = sub_10025B63C(a1 + 1000, 0);
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  if (v12 != 1) {
LABEL_30:
  }
    uint64_t v12 = 0;
LABEL_31:
  if (v25) {
    sub_10004D2C8(v25);
  }
  return v12;
}

void sub_100261130(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100261170(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 112) + 144);

  return v2();
}

void sub_1002611D4(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v5 = *(void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 832) = v5;
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 840);
  *(void *)(a1 + 840) = v4;
  if (v6) {
    sub_10004D2C8(v6);
  }
  unsigned int v7 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v8 = sub_10110D174((void **)a2);
    uint64_t v9 = "false";
    if (v8) {
      uint64_t v9 = "true";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Device has non bootstrap SIM: %s", __p, 0xCu);
  }
  uint64_t v10 = *(void *)(a1 + 392);
  char v11 = *(std::__shared_weak_count **)(a1 + 400);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v10) {
    sub_1006BE7B0(v10, (uint64_t *)a2);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (*(unsigned char *)(a1 + 984))
  {
    uint64_t v12 = *(void **)(a1 + 928);
    if (v12 != (void *)(a1 + 936))
    {
      do
      {
        sub_10110D1DC((void **)(a1 + 832), *((_DWORD *)v12 + 8), (uint64_t)__p);
        if (v20 && v19 < 0)
        {
          operator delete(*(void **)__p);
        }
        else if (!v20)
        {
          int v16 = (void *)v12[1];
          unint64_t v17 = v12;
          if (v16)
          {
            do
            {
              unsigned __int8 v14 = v16;
              int v16 = (void *)*v16;
            }
            while (v16);
          }
          else
          {
            do
            {
              unsigned __int8 v14 = (void *)v17[2];
              BOOL v15 = *v14 == (void)v17;
              unint64_t v17 = v14;
            }
            while (!v15);
          }
          if (*(void **)(a1 + 928) == v12) {
            *(void *)(a1 + 928) = v14;
          }
          --*(void *)(a1 + 944);
          sub_10005EE6C(*(uint64_t **)(a1 + 936), v12);
          sub_10026CEAC((void *)v12[6]);
          operator delete(v12);
          goto LABEL_35;
        }
        unsigned __int8 v13 = (void *)v12[1];
        if (v13)
        {
          do
          {
            unsigned __int8 v14 = v13;
            unsigned __int8 v13 = (void *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            unsigned __int8 v14 = (void *)v12[2];
            BOOL v15 = *v14 == (void)v12;
            uint64_t v12 = v14;
          }
          while (!v15);
        }
LABEL_35:
        uint64_t v12 = v14;
      }
      while (v14 != (void *)(a1 + 936));
    }
  }
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 152))(*(void *)(a1 + 112), a2);
  sub_10025BAD4(a1);
  sub_10025DC48(a1);
}

void sub_10026142C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10026144C(uint64_t a1, unsigned __int8 *a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  int v4 = *a2;
  int v5 = a2[1];
  if (v4 != *(unsigned __int8 *)(a1 + 280) || v5 != *(unsigned __int8 *)(a1 + 281))
  {
    *(unsigned char *)(a1 + 280) = v4;
    *(unsigned char *)(a1 + 281) = v5;
    sub_10025BAD4(a1);
  }
}

void sub_1002614BC(uint64_t a1, int a2, int a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned __int8 *)(a1 + 429) != a2 || *(unsigned __int8 *)(a1 + 744) != a3)
  {
    *(unsigned char *)(a1 + 429) = a2;
    *(unsigned char *)(a1 + 744) = a3;
    sub_10025BAD4(a1);
  }
}

void sub_100261538(uint64_t a1, unsigned __int8 **a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  int v4 = *a2;
  if (!*a2)
  {
    __TUAssertTrigger();
    int v4 = *a2;
  }
  int v5 = *(unsigned __int8 **)(a1 + 432);
  int v6 = *v5;
  int v7 = v5[1];
  if (v6 != *v4 || v7 != v4[1])
  {
    uint64_t v9 = a2[1];
    if (v9) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)v9 + 1, 1uLL, memory_order_relaxed);
    }
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 440);
    *(void *)(a1 + 432) = v4;
    *(void *)(a1 + 440) = v9;
    if (v10)
    {
      sub_10004D2C8(v10);
      int v4 = *(unsigned __int8 **)(a1 + 432);
    }
    if (*v4) {
      BOOL v11 = 1;
    }
    else {
      BOOL v11 = v4[1] != 0;
    }
    (*(void (**)(void, BOOL))(**(void **)(a1 + 128) + 88))(*(void *)(a1 + 128), v11);
    sub_10025BAD4(a1);
  }
}

uint64_t sub_100261628(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 112) + 160);

  return v2();
}

void sub_10026168C(uint64_t a1, int a2)
{
  LODWORD(v2) = a2;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if ((v2 & 0x3D) != 0) {
    uint64_t v2 = v2 | 2;
  }
  else {
    uint64_t v2 = v2;
  }
  if (*(unsigned __int16 *)(a1 + 424) != v2)
  {
    int v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BC897C(v2, &__p);
      int v5 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &__p
         : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)std::string buf = 136315138;
      BOOL v18 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Configured for location services changed to: %s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    int v6 = *(NSObject **)(a1 + 32);
    *(_WORD *)(a1 + 424) = v2;
    dispatch_assert_queue_V2(v6);
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    int v7 = *(unsigned __int16 *)(a1 + 416);
    if (*(_WORD *)(a1 + 416))
    {
      int v8 = *(unsigned __int16 *)(a1 + 424);
      uint64_t v9 = v7 & ~v8;
      if ((v7 & ~v8) != 0)
      {
        uint64_t v10 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          sub_100BC897C(v9, &__p);
          BOOL v11 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &__p
              : (std::string *)__p.__r_.__value_.__r.__words[0];
          *(_DWORD *)std::string buf = 136446210;
          BOOL v18 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [Not allowed at location] Exiting services: %{public}s", buf, 0xCu);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        uint64_t v12 = *(std::__shared_weak_count **)(a1 + 88);
        if (v12)
        {
          unsigned __int8 v13 = std::__shared_weak_count::lock(v12);
          if (v13)
          {
            unsigned __int8 v14 = v13;
            uint64_t v15 = *(void *)(a1 + 80);
            if (v15)
            {
              LODWORD(__p.__r_.__value_.__l.__data_) = 7;
              WORD2(__p.__r_.__value_.__r.__words[0]) = v9;
              __p.__r_.__value_.__s.__data_[6] = 1;
              __p.__r_.__value_.__s.__data_[8] = 1;
              (*(void (**)(uint64_t, std::string *))(*(void *)v15 + 40))(v15, &__p);
            }
            sub_10004D2C8(v14);
          }
        }
      }
    }
    sub_10025BAD4(a1);
  }
}

void sub_100261898(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1002618B4(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned __int8 *)(a1 + 428) != a2)
  {
    *(unsigned char *)(a1 + 428) = a2;
    int v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = "false";
      if (a2) {
        int v5 = "true";
      }
      int v6 = 136315138;
      int v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Allow Emergency use cases in limited service changed to: %s", (uint8_t *)&v6, 0xCu);
    }
    sub_10025BAD4(a1);
  }
}

void sub_100261994(uint64_t *a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = *(void *)a1[1];
    *(unsigned char *)(v4 + 275) = 0;
    int v5 = *(std::__shared_weak_count **)(v4 + 264);
    *(void *)(v4 + 256) = 0;
    *(void *)(v4 + 264) = 0;
    if (v5) {
      sub_10004D2C8(v5);
    }
    int v6 = *(NSObject **)(v3 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315138;
      uint64_t v8 = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Queuing up Em loc update. Reason: %s", (uint8_t *)&v7, 0xCu);
    }
    operator new();
  }
  __assert_rtn("operator()", "StewieDataController_ios.cpp", 1927, "reason");
}

void sub_100261CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100261D28(uint64_t a1)
{
  uint64_t v2 = a1 + 32;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v3 = *(void *)(v2 + 312);
  if (v3)
  {
    uint64_t v4 = *(AutoStartTimer **)(v3 + 256);
    if (!v4 || AutoStartTimer::isExpired(v4))
    {
      int v5 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = 900;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Next roadside location update will scheduled after (after %lld seconds)", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v6 = *(void *)(a1 + 344);
      sub_100058DB0(&__p, "RoadsideLocationUpdate");
      Registry::getTimerService(&v9, *(Registry **)(a1 + 64));
      *(void *)&long long buf = off_1019B1408;
      *((void *)&buf + 1) = a1;
      p_long long buf = &buf;
      AutoStartTimer::create();
      long long v7 = v13;
      long long v13 = 0uLL;
      uint64_t v8 = *(std::__shared_weak_count **)(v6 + 264);
      *(_OWORD *)(v6 + 256) = v7;
      if (v8)
      {
        sub_10004D2C8(v8);
        if (*((void *)&v13 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
        }
      }
      sub_10003B34C(&buf);
      if (v10) {
        sub_10004D2C8(v10);
      }
      if (v12 < 0) {
        operator delete(__p);
      }
    }
  }
}

void sub_100261EA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100261EE0(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned __int8 *)(a1 + 453) != a2)
  {
    *(unsigned char *)(a1 + 453) = a2;
    uint64_t v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = "false";
      if (a2) {
        int v5 = "true";
      }
      int v6 = 136315138;
      long long v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Has active roadside providers changed to: %s", (uint8_t *)&v6, 0xCu);
    }
    sub_10025BAD4(a1);
  }
}

uint64_t sub_100261FC0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 112) + 184);

  return v2();
}

void sub_100262024(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned __int8 *)(a1 + 829) != a2)
  {
    *(unsigned char *)(a1 + 829) = a2;
    uint64_t v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = "false";
      if (a2) {
        int v5 = "true";
      }
      int v6 = 136315138;
      long long v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SatSMS provisioned changed to: %s", (uint8_t *)&v6, 0xCu);
    }
    sub_10025AD28(a1);
    sub_10025BAD4(a1);
  }
}

void sub_10026210C(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (!_os_feature_enabled_impl() || *(unsigned __int16 *)(a1 + 992) == a2) {
    return;
  }
  *(_WORD *)(a1 + 992) = a2;
  uint64_t v4 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC897C(a2, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136446210;
    unint64_t v17 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Blocked services based on installed apps changed to: %{public}s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if ((*(_WORD *)(a1 + 992) & 1) == 0) {
      goto LABEL_16;
    }
    goto LABEL_12;
  }
  if (a2)
  {
LABEL_12:
    if (sub_10025B63C(a1 + 1128, 0) != 1)
    {
      int v6 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Saving that resuming Em is disallowed in next attempt", (uint8_t *)&__p, 2u);
      }
      sub_10025CAD8(a1 + 1128, 1u);
    }
  }
LABEL_16:
  if ((*(_WORD *)(a1 + 992) & 8) != 0 && sub_10025B63C(a1 + 1160, 0) != 1)
  {
    long long v7 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Saving that resuming Rs is disallowed in next attempt", (uint8_t *)&__p, 2u);
    }
    sub_10025CAD8(a1 + 1160, 1u);
  }
  sub_10025BAD4(a1);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416))
  {
    uint64_t v8 = (unsigned __int16)(*(_WORD *)(a1 + 416) & a2);
    if (v8)
    {
      uint64_t v9 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        sub_100BC897C(v8, &__p);
        uint64_t v10 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &__p
            : (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)long long buf = 136446210;
        unint64_t v17 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [Blocked based on installed apps] Exiting services: %{public}s", buf, 0xCu);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      BOOL v11 = *(std::__shared_weak_count **)(a1 + 88);
      if (v11)
      {
        char v12 = std::__shared_weak_count::lock(v11);
        if (v12)
        {
          long long v13 = v12;
          uint64_t v14 = *(void *)(a1 + 80);
          if (v14)
          {
            LODWORD(__p.__r_.__value_.__l.__data_) = 1;
            WORD2(__p.__r_.__value_.__r.__words[0]) = v8;
            __p.__r_.__value_.__s.__data_[6] = 1;
            __p.__r_.__value_.__s.__data_[8] = 1;
            (*(void (**)(uint64_t, std::string *))(*(void *)v14 + 40))(v14, &__p);
          }
          sub_10004D2C8(v13);
        }
      }
    }
  }
}

void sub_1002623E8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100262404(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  memset(v7, 0, sizeof(v7));
  uint64_t v2 = *(void **)(a1 + 520);
  if (v2 != (void *)(a1 + 528))
  {
    do
    {
      ++v7[*((unsigned __int8 *)v2 + 193)];
      uint64_t v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          uint64_t v2 = v4;
        }
        while (!v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != (void *)(a1 + 528));
  }
  for (uint64_t i = 0; i != 3; ++i)
  {
    if (v7[i] <= 1uLL) {
      (*(void (**)(void, void))(**(void **)(a1 + 144) + 16))(*(void *)(a1 + 144), i);
    }
  }
}

const void **sub_100262518(uint64_t a1)
{
  sub_10005D144(*(void **)(a1 + 64));
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v2 = *(void **)(a1 + 16);
    if (v2)
    {
      *(void *)(a1 + 24) = v2;
      operator delete(v2);
    }
  }
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  return sub_10012577C((const void **)a1);
}

uint64_t sub_10026259C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC8FAC((CFUUIDRef *)a3, __p);
    if (v29 >= 0) {
      long long v7 = __p;
    }
    else {
      long long v7 = *(unsigned char **)__p;
    }
    uint64_t v8 = *(void *)(a3 + 8) + *(void *)(**(void **)(a3 + 8) - 48);
    unsigned int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 8))(v8);
    int v10 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a3 + 8) + 48))(*(void *)(a3 + 8), a1 + 304);
    BOOL v11 = sub_10093AA58(v9);
    char v12 = "no";
    int v13 = *(unsigned __int8 *)(a3 + 85);
    *(_DWORD *)long long buf = 136446978;
    *(void *)&uint8_t buf[4] = v7;
    if (v10) {
      uint64_t v14 = "yes";
    }
    else {
      uint64_t v14 = "no";
    }
    __int16 v31 = 2080;
    if (v13) {
      char v12 = "yes";
    }
    long long v32 = v11;
    __int16 v33 = 2080;
    int v34 = v14;
    __int16 v35 = 2080;
    CFUUIDRef v36 = v12;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Discarding message (id: %{public}s, type: %s, isMessageObsolete: %s, isContextObsolete: %s)", buf, 0x2Au);
    if (v29 < 0) {
      operator delete(*(void **)__p);
    }
  }
  if ((*(unsigned int (**)(void))(**(void **)(a3 + 8) + 32))(*(void *)(a3 + 8)))
  {
    uint64_t v15 = *(void *)(a1 + 144);
    uint64_t v25 = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, const void **, void))(*(void *)v15 + 64))(v15, a3, a2, 0, &v25, 0);
    sub_100057D78(&v25);
  }
  if (*(_DWORD *)(a3 + 80)) {
    sub_100262CE0(a1, a3, 0, 3);
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t result = _os_feature_enabled_impl();
  if (result)
  {
    uint64_t v17 = *(void *)(a3 + 64);
    if (v17)
    {
      uint64_t v18 = a3 + 64;
      do
      {
        if (*(unsigned char *)(v17 + 25)) {
          char v19 = (uint64_t *)v17;
        }
        else {
          char v19 = (uint64_t *)(v17 + 8);
        }
        if (*(unsigned char *)(v17 + 25)) {
          uint64_t v18 = v17;
        }
        uint64_t v17 = *v19;
      }
      while (*v19);
      if (v18 != a3 + 64 && *(unsigned __int8 *)(v18 + 25) <= 1u)
      {
        char v20 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = *(void *)(a3 + 8) + *(void *)(**(void **)(a3 + 8) - 48);
          unsigned int v22 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 8))(v21);
          BOOL v23 = sub_10093AA58(v22);
          sub_100BC8FAC((CFUUIDRef *)a3, buf);
          if (v33 >= 0) {
            long long v24 = buf;
          }
          else {
            long long v24 = *(unsigned char **)buf;
          }
          *(_DWORD *)std::string __p = 136315394;
          *(void *)&__p[4] = v23;
          __int16 v27 = 2080;
          uint64_t v28 = v24;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [Discarded] Cancel send attempt of %s, with messageID: %s", __p, 0x16u);
          if (SHIBYTE(v33) < 0) {
            operator delete(*(void **)buf);
          }
        }
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 176))(*(void *)(a1 + 112), a3);
        uint64_t result = (uint64_t)sub_100272768((uint64_t **)(a3 + 56), 1u);
        ++*(_DWORD *)(a3 + 92);
        ++*(_DWORD *)(a1 + 580);
      }
    }
  }
  return result;
}

void sub_100262954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_100262988(uint64_t a1, int a2, int a3, int a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v8 = (uint64_t **)(a1 + 488);
  if (a3 == 1 && a4)
  {
    if (!sub_100272C6C(v8, a2, a2)) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  if (sub_100272768(v8, a2)) {
LABEL_6:
  }
    sub_10025DC48(a1);
LABEL_7:
  if (a2 == 1)
  {
    int v9 = a3 == 2;
    if (*(unsigned __int8 *)(a1 + 512) != v9)
    {
      *(unsigned char *)(a1 + 512) = v9;
      sub_10025BAD4(a1);
    }
  }
}

void sub_100262A44(uint64_t a1, int a2, int a3, int a4)
{
}

void sub_100262A4C(uint64_t a1, uint64_t a2, int a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416))
  {
    BOOL v5 = *(std::__shared_weak_count **)(a1 + 88);
    if (v5)
    {
      int v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        long long v7 = v6;
        uint64_t v8 = *(void *)(a1 + 80);
        if (v8)
        {
          if (a3 == 4) {
            int v9 = 7;
          }
          else {
            int v9 = 5;
          }
          int v10 = v9;
          char v11 = 0;
          char v12 = 0;
          char v13 = 1;
          (*(void (**)(uint64_t, int *))(*(void *)v8 + 40))(v8, &v10);
        }
        sub_10004D2C8(v7);
      }
    }
  }
}

void sub_100262B08(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100262B1C(uint64_t a1, uint64_t a2, int a3)
{
}

void sub_100262B28(uint64_t a1)
{
  uint64_t v2 = a1 + 32;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v3 = *(void *)(v2 + 280);
  if (v3)
  {
    uint64_t v4 = *(AutoStartTimer **)(v3 + 256);
    if (!v4 || AutoStartTimer::isExpired(v4))
    {
      BOOL v5 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = 900;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Next emergency location update will scheduled after (after %lld seconds)", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v6 = *(void *)(a1 + 312);
      sub_100058DB0(&__p, "EmergencyLocationUpdate");
      Registry::getTimerService(&v9, *(Registry **)(a1 + 64));
      *(void *)&long long buf = off_1019B1488;
      *((void *)&buf + 1) = a1;
      p_long long buf = &buf;
      AutoStartTimer::create();
      long long v7 = v13;
      long long v13 = 0uLL;
      uint64_t v8 = *(std::__shared_weak_count **)(v6 + 264);
      *(_OWORD *)(v6 + 256) = v7;
      if (v8)
      {
        sub_10004D2C8(v8);
        if (*((void *)&v13 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
        }
      }
      sub_10003B34C(&buf);
      if (v10) {
        sub_10004D2C8(v10);
      }
      if (v12 < 0) {
        operator delete(__p);
      }
    }
  }
}

void sub_100262CA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100262CE0(uint64_t a1, uint64_t a2, unsigned __int8 a3, int a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_DWORD *)(a2 + 80) != a4)
  {
    *(_DWORD *)(a2 + 80) = a4;
    v8[0] = a1;
    v8[1] = a3;
    sub_100262DC0(v8, a2);
  }
}

void sub_100262DC0(void *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *a1;
  uint64_t v5 = *(void *)(a2 + 8) + *(void *)(**(void **)(a2 + 8) - 48);
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8))(v5);
  LOBYTE(v3) = *((unsigned char *)v3 + 8);
  int v7 = *(_DWORD *)(a2 + 80);
  uint64_t v8 = *(void *)(a2 + 48);
  sub_10012A394(&v10, (const void **)a2);
  int v11 = v6;
  char v12 = (char)v3;
  int v13 = v7;
  uint64_t v14 = v8;
  uint64_t v9 = *(std::__shared_weak_count **)(v4 + 24);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100262F58(uint64_t a1, uint64_t a2, CFTypeRef *a3, int a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416))
  {
    if (*a3) {
      uint64_t v8 = sub_100136254;
    }
    else {
      uint64_t v8 = 0;
    }
    if (v8)
    {
      if (*(void *)(a1 + 536))
      {
        uint64_t v9 = *(void **)(a1 + 520);
        int v10 = (void *)(a1 + 528);
        if (v9 != (void *)(a1 + 528))
        {
          while (1)
          {
            if (!v9[6]) {
              __TUAssertTrigger();
            }
            int v11 = (const void *)v9[5];
            if (v11) {
              char v12 = sub_100136254;
            }
            else {
              char v12 = 0;
            }
            if (!v12)
            {
              __TUAssertTrigger();
              int v11 = (const void *)v9[5];
            }
            if (CFEqual(v11, *a3)) {
              break;
            }
            int v13 = (void *)v9[1];
            if (v13)
            {
              do
              {
                uint64_t v14 = v13;
                int v13 = (void *)*v13;
              }
              while (v13);
            }
            else
            {
              do
              {
                uint64_t v14 = (void *)v9[2];
                BOOL v15 = *v14 == (void)v9;
                uint64_t v9 = v14;
              }
              while (!v15);
            }
            uint64_t v9 = v14;
            if (v14 == v10) {
              goto LABEL_30;
            }
          }
        }
        if (v9 != v10)
        {
          uint64_t v16 = v9[6] + *(void *)(*(void *)v9[6] - 48);
          unsigned int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 8))(v16);
          CFStringRef v42 = CFUUIDCreateString(kCFAllocatorDefault, (CFUUIDRef)*a3);
          uint64_t v18 = *(NSObject **)(a1 + 48);
          if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_35;
          }
          char v19 = a4 ? "success" : "failure";
          long long v43 = 0uLL;
          uint64_t v44 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = 0uLL;
          uint64_t v41 = 0;
          char v20 = a2 > 2 ? "???" : off_1019B1E00[(char)a2];
          uint64_t v21 = sub_10093AA58(v17);
          *(_DWORD *)long long buf = 136315906;
          *(void *)&uint8_t buf[4] = v19;
          __int16 v46 = 2080;
          *(void *)uint64_t v47 = __p;
          *(_WORD *)&v47[8] = 2080;
          int v48 = v20;
          __int16 v49 = 2080;
          BOOL v50 = v21;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Message send result: %s (id: %s, transport: %s, type: %s)", buf, 0x2Au);
          if (SHIBYTE(v41) < 0)
          {
            operator delete(__p[0]);
            if (a4) {
              goto LABEL_36;
            }
          }
          else
          {
LABEL_35:
            if (a4)
            {
LABEL_36:
              (*(void (**)(void, uint64_t))(*(void *)v9[6] + 112))(v9[6], a1 + 304);
              uint64_t v22 = *(void *)(a1 + 312);
              if (v22 && v17 - 1 <= 3)
              {
                BOOL v23 = (uint64_t *)(a1 + 312);
                if (v17 == 4)
                {
                  sub_100262B28(a1);
                }
                else if (v17 == 1)
                {
                  if (sub_1011252B0(v22))
                  {
                    uint64_t v24 = *(void *)(*(void *)(a1 + 312) + 104);
                    *(void *)long long buf = a1;
                    uint8_t buf[8] = v24;
                    sub_100263628(a1 + 16);
                  }
                  sub_100262B28(a1);
                  uint64_t v25 = *(void *)(a1 + 112);
                  uint64_t v26 = sub_10025C910(a1);
                  (*(void (**)(uint64_t, uint64_t))(*(void *)v25 + 168))(v25, v26);
                }
              }
              else
              {
                uint64_t v27 = *(void *)(a1 + 344);
                if (!v27 || v17 - 6 > 3)
                {
                  if (v17 == 10)
                  {
                    uint64_t v33 = *(void *)(a1 + 112);
                    uint64_t v34 = sub_10025C910(a1);
                    (*(void (**)(uint64_t, uint64_t))(*(void *)v33 + 168))(v33, v34);
                  }
                  goto LABEL_59;
                }
                BOOL v23 = (uint64_t *)(a1 + 344);
                if (v17 == 9)
                {
                  sub_100261D28(a1);
                }
                else if (v17 == 6)
                {
                  if (sub_1011252B0(v27))
                  {
                    char v28 = *(unsigned char *)(*v23 + 104);
                    char v29 = sub_101117E48(*v23);
                    if (!v30) {
                      __TUAssertTrigger();
                    }
                    *(void *)long long buf = a1;
                    uint8_t buf[8] = v28;
                    *(void *)&v47[2] = v29;
                    sub_100263718(a1 + 16);
                  }
                  sub_100261D28(a1);
                  uint64_t v31 = *(void *)(a1 + 112);
                  uint64_t v32 = sub_10025C910(a1);
                  (*(void (**)(uint64_t, uint64_t))(*(void *)v31 + 168))(v31, v32);
                }
              }
              sub_101125BCC((const void **)*v23);
LABEL_59:
              if ((*(unsigned int (**)(void))(*(void *)v9[6] + 32))(v9[6]))
              {
                __int16 v35 = (uint64_t (***)(void))(v9[6] + *(void *)(*(void *)v9[6] - 48));
                uint64_t v36 = (**v35)(v35);
                uint64_t v37 = *(void *)(a1 + 144);
                uint64_t v39 = 0;
                (*(void (**)(uint64_t, void *, uint64_t, uint64_t, const void **, uint64_t))(*(void *)v37 + 64))(v37, v9 + 5, v36, 1, &v39, a2);
                sub_100057D78(&v39);
              }
              if (a2 == 2)
              {
                ++*(_DWORD *)(a1 + 572);
              }
              else if (a2 == 1)
              {
                ++*(_DWORD *)(a1 + 568);
              }
              *(_DWORD *)(a1 + 600) += *((_DWORD *)v9 + 22);
              sub_100262CE0(a1, (uint64_t)(v9 + 5), a2, 2);
              sub_10006C514((uint64_t **)(a1 + 520), v9);
              sub_10026F19C((uint64_t)(v9 + 4));
              operator delete(v9);
              goto LABEL_66;
            }
          }
          sub_100272768((uint64_t **)v9 + 12, a2);
LABEL_66:
          sub_10025DC48(a1);
          sub_1000558F4((const void **)&v42);
          return;
        }
      }
LABEL_30:
      sub_10025DC48(a1);
    }
    else
    {
      unsigned __int8 v38 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Message ID is nullptr", buf, 2u);
      }
      sub_10025DC48(a1);
    }
  }
}

void sub_1002635D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void sub_100263628(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100263718(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100263810(uint64_t a1, uint64_t a2, CFTypeRef *a3, int a4)
{
}

uint64_t sub_100263818(uint64_t a1)
{
  sub_10012577C((const void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100263850(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (a4 == 2)
  {
    uint64_t v8 = *(void *)(a1 + 128);
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 136);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (a4 != 1) {
    goto LABEL_9;
  }
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 120);
  if (v9) {
LABEL_4:
  }
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_5:
  if (v8) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 40))(v8, a3);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
LABEL_9:
  uint64_t v10 = *(void *)(a1 + 360);
  if (!v10) {
    return;
  }
  CFTypeRef cf = 0;
  uint64_t v57 = 0;
  sub_10012A394(&cf, (const void **)(v10 + 64));
  LOBYTE(v57) = *(unsigned char *)(a2 + 26);
  WORD1(v57) = *(_WORD *)(a2 + 28);
  if (sub_1003CB160(*(void *)(a1 + 360), (uint64_t)&cf))
  {
    StewieDataController::submitCPSummaryMetric(a1, a2);
    uint64_t v11 = *(void *)(a1 + 392);
    if (v11)
    {
      if (!*(unsigned char *)(v11 + 184))
      {
        char v12 = *(std::__shared_weak_count **)(a1 + 400);
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
LABEL_15:
        if (sub_1003CB048(*(void *)(a1 + 360), &cf, v57))
        {
          uint64_t v13 = *(void *)(a1 + 376);
          if (v13) {
            sub_1004FBAE4(v13, &cf, v57);
          }
          if (v11) {
            sub_1006BEFAC(v11, &cf, v57);
          }
          uint64_t v14 = *(void *)(a1 + 112);
          uint64_t v15 = sub_10025C910(a1);
          (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 168))(v14, v15);
        }
        if (!v11
          || !sub_1006BF298(v11, &cf, v57, *(unsigned char *)(a2 + 56), *(unsigned char *)(a2 + 57))
          || (dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32)), (uint64_t v16 = *(void *)(a1 + 392)) == 0)
          || *(unsigned char *)(v16 + 184))
        {
LABEL_86:
          uint64_t v52 = *(void *)(a1 + 144);
          __p[0] = 0;
          __p[1] = 0;
          std::string::size_type v59 = 0;
          (*(void (**)(uint64_t, uint64_t, void **, uint64_t))(*(void *)v52 + 40))(v52, a2, __p, a4);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          if (v12) {
            sub_10004D2C8(v12);
          }
          goto LABEL_90;
        }
        unsigned int v17 = *(std::__shared_weak_count **)(a1 + 400);
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
        char v19 = ServiceMap;
        if (v20 < 0)
        {
          uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v22 = 5381;
          do
          {
            uint64_t v20 = v22;
            unsigned int v23 = *v21++;
            uint64_t v22 = (33 * v22) ^ v23;
          }
          while (v23);
        }
        std::mutex::lock(ServiceMap);
        __p[0] = (void *)v20;
        uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)__p);
        if (v24)
        {
          uint64_t v25 = (std::__shared_weak_count *)v24[4];
          uint64_t v54 = v24[3];
          if (v25)
          {
            atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v19);
            atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v25);
            char v53 = 0;
LABEL_39:
            if (v54)
            {
              uint64_t v26 = *(uint64_t ***)(a2 + 32);
              for (uint64_t i = *(unsigned __int8 **)(a2 + 40); v26 != (uint64_t **)i; v26 += 7)
              {
                if (*(unsigned char *)v26 == 2 || v26[1] == v26[2] || v26[4] == v26[5]) {
                  __TUAssertTrigger();
                }
                sub_1006BEB94(v16, (uint64_t *)&buf);
                if (!*((void *)&buf + 1)) {
                  goto LABEL_55;
                }
                unsigned int v27 = *(unsigned __int8 *)v26;
                char v28 = (long long *)((char *)&buf + 8);
                char v29 = (uint64_t *)*((void *)&buf + 1);
                do
                {
                  char v30 = v29;
                  uint64_t v31 = v28;
                  unsigned int v32 = *((unsigned __int8 *)v29 + 25);
                  if (v32 >= v27) {
                    char v28 = v29;
                  }
                  else {
                    ++v29;
                  }
                  char v29 = (uint64_t *)*v29;
                }
                while (v29);
                if (v28 == (long long *)((char *)&buf + 8)) {
                  goto LABEL_55;
                }
                if (v32 < v27) {
                  char v30 = v31;
                }
                if (v27 >= *((unsigned __int8 *)v30 + 25))
                {
                  sub_1000346F8((uint64_t)&buf, *((void **)&buf + 1));
                  unsigned int v38 = sub_1006BEA40(v16, *(unsigned __int8 *)v26);
                  unsigned int v39 = v38;
                  if (v38)
                  {
                    v71[0] = 0;
                    v71[1] = 0;
                    *((void *)&buf + 1) = v71;
                    *(void *)&long long buf = v38 | 0x200000000;
                    int v66 = 0;
                    *(void *)unint64_t v69 = &v66;
                    uint64_t v40 = sub_10008CC40((uint64_t **)&buf + 1, &v66, (uint64_t)&unk_10144E20E, (_DWORD **)v69) + 5;
                    if (v40 != v26 + 4) {
                      sub_10006E4A8(v40, (char *)v26[4], (char *)v26[5], (char *)v26[5] - (char *)v26[4]);
                    }
                    int v66 = 1;
                    *(void *)unint64_t v69 = &v66;
                    uint64_t v41 = sub_10008CC40((uint64_t **)&buf + 1, &v66, (uint64_t)&unk_10144E20E, (_DWORD **)v69);
                    if (v41 + 4 != v26) {
                      sub_10006E4A8(v41 + 5, (char *)v26[1], (char *)v26[2], (char *)v26[2] - (char *)v26[1]);
                    }
                    CFStringRef v42 = *(NSObject **)(a1 + 48);
                    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v43 = subscriber::asString();
                      *(_DWORD *)unint64_t v69 = 136315138;
                      *(void *)&v69[4] = v43;
                      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I [EAP-AKA challenge] Attempting to solve challenge for slot: %s", v69, 0xCu);
                    }
                    uint64_t v64 = buf;
                    sub_10026E7F8(v65, (uint64_t)&buf + 8);
                    __p[0] = (void *)a1;
                    uint64_t v44 = *(std::__shared_weak_count **)(a1 + 24);
                    if (!v44 || (uint64_t v45 = *(void **)(a1 + 16), (v46 = std::__shared_weak_count::lock(v44)) == 0)) {
                      sub_100088B9C();
                    }
                    __p[1] = v45;
                    std::string::size_type v59 = v46;
                    atomic_fetch_add_explicit(&v46->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v46);
                    unsigned int v60 = v39;
                    CFTypeRef v61 = cf;
                    if (cf) {
                      CFRetain(cf);
                    }
                    int v62 = v57;
                    char v63 = *(unsigned char *)v26;
                    char v68 = 0;
                    uint64_t v47 = (char *)operator new(0x40uLL);
                    *(void *)uint64_t v47 = off_1019B1508;
                    *(_OWORD *)(v47 + 8) = *(_OWORD *)__p;
                    *((void *)v47 + 3) = v59;
                    __p[1] = 0;
                    std::string::size_type v59 = 0;
                    *((_DWORD *)v47 + 8) = v60;
                    sub_10012A394((const void **)v47 + 5, &v61);
                    *((_DWORD *)v47 + 12) = v62;
                    v47[56] = v63;
                    char v68 = v47;
                    (*(void (**)(uint64_t))(*(void *)v54 + 256))(v54);
                    sub_100273F20(v67);
                    sub_10012577C(&v61);
                    if (v59) {
                      std::__shared_weak_count::__release_weak(v59);
                    }
                    sub_10026CF54((uint64_t)v65, (void *)v65[1]);
                    sub_10026CF54((uint64_t)&buf + 8, v71[0]);
                    continue;
                  }
                  int v48 = *(NSObject **)(a1 + 48);
                  if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                  {
                    unint64_t v49 = *(char *)v26;
                    BOOL v50 = "???";
                    if (v49 <= 2) {
                      BOOL v50 = off_1019B1CA0[v49];
                    }
                    LODWORD(buf) = 136315138;
                    *(void *)((char *)&buf + 4) = v50;
                    uint64_t v36 = v48;
                    uint64_t v37 = "#I Ignoring challenge for: %s, as it translated to unknown slot";
                    goto LABEL_59;
                  }
                }
                else
                {
LABEL_55:
                  sub_1000346F8((uint64_t)&buf, *((void **)&buf + 1));
                  uint64_t v33 = *(NSObject **)(a1 + 48);
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                  {
                    unint64_t v34 = *(char *)v26;
                    __int16 v35 = "???";
                    if (v34 <= 2) {
                      __int16 v35 = off_1019B1CA0[v34];
                    }
                    LODWORD(buf) = 136315138;
                    *(void *)((char *)&buf + 4) = v35;
                    uint64_t v36 = v33;
                    uint64_t v37 = "#I Ignoring challenge for: %s, as it is not enabled";
LABEL_59:
                    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v37, (uint8_t *)&buf, 0xCu);
                  }
                }
              }
            }
            else
            {
              uint64_t v51 = *(NSObject **)(a1 + 48);
              if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
              {
                LOWORD(__p[0]) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "Missing subscriber controller, cannot process challenge?", (uint8_t *)__p, 2u);
              }
            }
            if ((v53 & 1) == 0) {
              sub_10004D2C8(v25);
            }
            if (v17) {
              sub_10004D2C8(v17);
            }
            goto LABEL_86;
          }
        }
        else
        {
          uint64_t v54 = 0;
        }
        std::mutex::unlock(v19);
        uint64_t v25 = 0;
        char v53 = 1;
        goto LABEL_39;
      }
      uint64_t v11 = 0;
    }
    char v12 = 0;
    goto LABEL_15;
  }
LABEL_90:
  sub_10012577C(&cf);
}

void sub_100264008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,const void *a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  sub_10026CF54(v34, *(void **)(v35 - 128));
  if ((a14 & 1) == 0) {
    sub_10004D2C8(a9);
  }
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (v33) {
    sub_10004D2C8(v33);
  }
  sub_10012577C(&a22);
  _Unwind_Resume(a1);
}

void sub_100264100(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (a4 == 2)
  {
    uint64_t v8 = *(void *)(a1 + 128);
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 136);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (a4 != 1) {
    goto LABEL_9;
  }
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 120);
  if (v9) {
LABEL_4:
  }
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_5:
  if (v8) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 40))(v8, a3);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
LABEL_9:
  uint64_t v10 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a2 + 32);
    char v12 = "???";
    if (*(unsigned char *)(a2 + 40) == 1) {
      char v12 = "kUnknown";
    }
    if (*(unsigned char *)(a2 + 40)) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = "kInvalidateShortHandleIndices";
    }
    int v37 = 134218242;
    uint64_t v38 = v11;
    __int16 v39 = 2080;
    uint64_t v40 = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [StewieIMessageLiteErrorMessageIncoming] Processing... TimeStamp: %llu, Error code: %s", (uint8_t *)&v37, 0x16u);
  }
  if (*(unsigned char *)(a2 + 40) == 1)
  {
    uint64_t v35 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v37) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "[StewieIMessageLiteErrorMessageIncoming][Coding error] Parsing should have failed", (uint8_t *)&v37, 2u);
    }
  }
  else if (!*(unsigned char *)(a2 + 40))
  {
    unint64_t v14 = *(void *)(a2 + 32);
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    uint64_t v15 = *(void *)(a1 + 360);
    if (v15)
    {
      uint64_t v18 = *(uint64_t **)(v15 + 144);
      uint64_t v16 = (uint64_t **)(v15 + 144);
      unsigned int v17 = v18;
      char v19 = v16;
      if (!v18) {
        goto LABEL_30;
      }
      uint64_t v20 = v16;
      uint64_t v21 = v17;
      do
      {
        unint64_t v22 = v21[4];
        BOOL v23 = v22 >= v14;
        if (v22 >= v14) {
          uint64_t v24 = (uint64_t **)v21;
        }
        else {
          uint64_t v24 = (uint64_t **)(v21 + 1);
        }
        if (v23) {
          uint64_t v20 = (uint64_t **)v21;
        }
        uint64_t v21 = *v24;
      }
      while (*v24);
      if (v20 != v16 && (unint64_t)v20[4] <= v14)
      {
        uint64_t v36 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v37) = 0;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I [InvalidateShortHandleIndices] Ignoring duplicate", (uint8_t *)&v37, 2u);
        }
      }
      else
      {
LABEL_30:
        uint64_t v25 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v37) = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I [InvalidateShortHandleIndices] Processing...", (uint8_t *)&v37, 2u);
          unsigned int v17 = *v16;
        }
        uint64_t v26 = v16;
        if (v17)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v26 = (uint64_t **)v17;
              unint64_t v27 = v17[4];
              if (v27 <= v14) {
                break;
              }
              unsigned int v17 = (uint64_t *)*v17;
              char v19 = v26;
              if (!*v26) {
                goto LABEL_39;
              }
            }
            if (v27 >= v14) {
              break;
            }
            unsigned int v17 = (uint64_t *)v17[1];
            if (!v17)
            {
              char v19 = v26 + 1;
              goto LABEL_39;
            }
          }
        }
        else
        {
LABEL_39:
          char v28 = (uint64_t *)operator new(0x28uLL);
          v28[4] = v14;
          sub_100046C38(v16 - 1, (uint64_t)v26, v19, v28);
        }
        sub_1003CAC98(*(void *)(a1 + 360) + 72);
        sub_1003CAC98(*(void *)(a1 + 360) + 104);
        char v29 = *(void **)(a1 + 520);
        char v30 = (void *)(a1 + 528);
        if (v29 != v30)
        {
          do
          {
            uint64_t v31 = v29[6] + *(void *)(*(void *)v29[6] - 48);
            if ((*(unsigned int (**)(uint64_t))(*(void *)v31 + 8))(v31) == 13) {
              *((unsigned char *)v29 + 124) = 1;
            }
            unsigned int v32 = (void *)v29[1];
            if (v32)
            {
              do
              {
                uint64_t v33 = v32;
                unsigned int v32 = (void *)*v32;
              }
              while (v32);
            }
            else
            {
              do
              {
                uint64_t v33 = (void *)v29[2];
                BOOL v34 = *v33 == (void)v29;
                char v29 = v33;
              }
              while (!v34);
            }
            char v29 = v33;
          }
          while (v33 != v30);
        }
      }
    }
  }
}

void sub_10026449C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002644BC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a2 + 160))
  {
    uint64_t v8 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Handling StewieSatSmsMessageIncoming as MMS", buf, 2u);
    }
    uint64_t v9 = (int *)(a2 + 40);
    sub_10110D1DC((void **)(a1 + 832), *(_DWORD *)(a2 + 40), (uint64_t)buf);
    if (!(_BYTE)v76)
    {
      unsigned int v17 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        uint64_t v18 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Slot: %s is not active. Dropping MMS", buf, 0xCu);
      }
      goto LABEL_104;
    }
    if (SHIBYTE(v75) < 0) {
      operator delete(*(void **)buf);
    }
    unint64_t v69 = (uint64_t **)(a1 + 928);
    if (!*(unsigned char *)(a1 + 984))
    {
      uint64_t v10 = *(NSObject **)(a1 + 48);
      BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      int v12 = 0;
      if (v11)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Setup SatMMS cache", buf, 2u);
        int v12 = *(unsigned __int8 *)(a1 + 984);
      }
      *(void *)long long buf = &buf[8];
      *(void *)&uint8_t buf[8] = 0;
      uint64_t v78 = 0;
      uint64_t v79 = 0;
      char v76 = &v77;
      uint64_t v77 = 0;
      uint64_t v13 = (uint64_t *)(a1 + 936);
      std::string::size_type v75 = 0;
      if (v12)
      {
        sub_10026CE58(*(void **)(a1 + 936));
        uint64_t v14 = *(void *)&buf[8];
        *(void *)(a1 + 928) = *(void *)buf;
        *(void *)(a1 + 936) = v14;
        std::string::size_type v15 = v75;
        *(void *)(a1 + 944) = v75;
        if (v15)
        {
          *(void *)(v14 + 16) = v13;
          *(void *)long long buf = &buf[8];
          *(void *)&uint8_t buf[8] = 0;
          std::string::size_type v75 = 0;
        }
        else
        {
          uint8_t *v69 = v13;
        }
        uint64_t v20 = a1 + 960;
        sub_10005CD2C(a1 + 952, *(char **)(a1 + 960));
        uint64_t v19 = v77;
        *(void *)(a1 + 952) = v76;
        *(void *)(a1 + 960) = v19;
        uint64_t v21 = v78;
        *(void *)(a1 + 968) = v78;
        if (v21)
        {
          *(void *)(v19 + 16) = v20;
          uint64_t v19 = 0;
          char v76 = &v77;
          uint64_t v77 = 0;
          uint64_t v78 = 0;
        }
        else
        {
          *(void *)(a1 + 952) = v20;
        }
        *(void *)(a1 + 976) = v79;
      }
      else
      {
        uint64_t v19 = 0;
        *uint64_t v13 = 0;
        *(void *)(a1 + 944) = 0;
        *(void *)(a1 + 928) = v13;
        *(void *)(a1 + 960) = 0;
        *(void *)(a1 + 976) = 0;
        *(void *)(a1 + 968) = 0;
        *(void *)(a1 + 952) = a1 + 960;
        *(unsigned char *)(a1 + 984) = 1;
      }
      sub_10005CD2C((uint64_t)&v76, (char *)v19);
      sub_10026CE58(*(void **)&buf[8]);
    }
    unint64_t v22 = (uint64_t *)(a1 + 960);
    if ((void **)(a1 + 960) != sub_100046F68(a1 + 952, (void **)(a2 + 136)))
    {
      BOOL v23 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Ignoring duplicate message attempt", buf, 2u);
      }
      goto LABEL_104;
    }
    if (*(void *)(a1 + 968) >= 0x14uLL)
    {
      uint64_t v24 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = 15;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I [RecentUniqueIds] Keep latest %zu entries and dropping rest to make space for new one's", buf, 0xCu);
      }
      uint64_t v25 = *(uint64_t **)(a1 + 952);
      if (v25 != v22)
      {
        unint64_t v26 = *(void *)(a1 + 976) - 15;
        do
        {
          if (v25[7] <= v26)
          {
            char v28 = sub_1000E1C44((uint64_t **)(a1 + 952), (uint64_t)v25);
          }
          else
          {
            unint64_t v27 = (uint64_t *)v25[1];
            if (v27)
            {
              do
              {
                char v28 = v27;
                unint64_t v27 = (uint64_t *)*v27;
              }
              while (v27);
            }
            else
            {
              do
              {
                char v28 = (uint64_t *)v25[2];
                BOOL v29 = *v28 == (void)v25;
                uint64_t v25 = v28;
              }
              while (!v29);
            }
          }
          uint64_t v25 = v28;
        }
        while (v28 != v22);
      }
    }
    ++*(void *)(a1 + 976);
    v70.__r_.__value_.__r.__words[0] = 0;
    char v30 = (uint64_t **)sub_100046ED4(a1 + 952, &v70, (void **)(a2 + 136));
    if (!*v30)
    {
      std::string::size_type v75 = 0;
      uint64_t v31 = (uint64_t *)operator new(0x40uLL);
      *(void *)&uint8_t buf[8] = a1 + 960;
      unsigned int v32 = v31 + 4;
      if (*(char *)(a2 + 159) < 0)
      {
        sub_10004FC84(v32, *(void **)(a2 + 136), *(void *)(a2 + 144));
      }
      else
      {
        *(_OWORD *)unsigned int v32 = *(_OWORD *)(a2 + 136);
        v31[6] = *(void *)(a2 + 152);
      }
      v31[7] = *(void *)(a1 + 976);
      sub_100046C38((uint64_t **)(a1 + 952), (uint64_t)v70.__r_.__value_.__l.__data_, v30, v31);
    }
    if (!*(void *)(a2 + 168))
    {
LABEL_91:
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
      uint64_t v57 = ServiceMap;
      __int16 v58 = "27MessageCenterModelInterface";
      if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
      {
        std::string::size_type v59 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v60 = 5381;
        do
        {
          __int16 v58 = (const char *)v60;
          unsigned int v61 = *v59++;
          uint64_t v60 = (33 * v60) ^ v61;
        }
        while (v61);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v58;
      int v62 = sub_10004D37C(&v57[1].__m_.__sig, (unint64_t *)buf);
      if (v62)
      {
        uint64_t v64 = v62[3];
        char v63 = (std::__shared_weak_count *)v62[4];
        if (v63)
        {
          atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v57);
          atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v63);
          char v65 = 0;
          if (!v64) {
            goto LABEL_97;
          }
          goto LABEL_101;
        }
      }
      else
      {
        uint64_t v64 = 0;
      }
      std::mutex::unlock(v57);
      char v63 = 0;
      char v65 = 1;
      if (!v64)
      {
LABEL_97:
        int v66 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "MessageCenterModel is not ready", buf, 2u);
        }
        goto LABEL_102;
      }
LABEL_101:
      (*(void (**)(uint64_t, void, uint64_t, unint64_t))(*(void *)v64 + 272))(v64, *(unsigned int *)(a2 + 40), a2 + 112, *(void *)(a2 + 32) / 0x3B9ACA00uLL);
LABEL_102:
      if ((v65 & 1) == 0) {
        sub_10004D2C8(v63);
      }
      goto LABEL_104;
    }
    memset(buf, 0, sizeof(buf));
    std::string::size_type v75 = 0;
    if (*(char *)(a2 + 103) >= 0) {
      size_t v33 = *(unsigned __int8 *)(a2 + 103);
    }
    else {
      size_t v33 = *(void *)(a2 + 88);
    }
    memset(&v70, 0, sizeof(v70));
    sub_1000C140C((uint64_t)&v70, v33 + 1);
    if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      BOOL v34 = &v70;
    }
    else {
      BOOL v34 = (std::string *)v70.__r_.__value_.__r.__words[0];
    }
    if (v33)
    {
      if (*(char *)(a2 + 103) >= 0) {
        uint64_t v35 = (const void *)(a2 + 80);
      }
      else {
        uint64_t v35 = *(const void **)(a2 + 80);
      }
      memmove(v34, v35, v33);
    }
    *(_WORD *)((char *)&v34->__r_.__value_.__l.__data_ + v33) = 95;
    std::to_string(&v73, **(unsigned __int16 **)(a2 + 168));
    if ((v73.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v36 = &v73;
    }
    else {
      uint64_t v36 = (std::string *)v73.__r_.__value_.__r.__words[0];
    }
    if ((v73.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v73.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v73.__r_.__value_.__l.__size_;
    }
    uint64_t v38 = std::string::append(&v70, (const std::string::value_type *)v36, size);
    long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    std::string::size_type v75 = v38->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long buf = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v73.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v70.__r_.__value_.__l.__data_);
    }
    uint64_t v40 = sub_100112C78(v69, *v9, (_DWORD *)(a2 + 40));
    CFStringRef v42 = (void **)(a2 + 112);
    uint64_t v41 = *(const void **)(a2 + 112);
    uint64_t v43 = *(void *)(a2 + 168);
    unint64_t v44 = *(unsigned __int8 *)(v43 + 3);
    unint64_t v45 = *(unsigned __int8 *)(v43 + 2);
    memset(&v70, 0, sizeof(v70));
    sub_10005C928(&v70, v41, *(void *)(a2 + 120), *(void *)(a2 + 120) - (void)v41);
    int v46 = sub_1010131D0(v40 + 5, (long long *)buf, v44, v45, (uint64_t)&v70);
    if (v70.__r_.__value_.__r.__words[0])
    {
      v70.__r_.__value_.__l.__size_ = v70.__r_.__value_.__r.__words[0];
      operator delete(v70.__r_.__value_.__l.__data_);
    }
    uint64_t v47 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      int v48 = "success";
      if ((v46 & 1) == 0) {
        int v48 = "failure";
      }
      unint64_t v49 = "in";
      if ((v46 & 0x100) != 0) {
        unint64_t v49 = "";
      }
      LODWORD(v73.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)v73.__r_.__value_.__r.__words + 4) = (std::string::size_type)v48;
      WORD2(v73.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v73.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v49;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I [Multi Part MMS] Add part result: %s, message is %scomplete", (uint8_t *)&v73, 0x16u);
    }
    if ((~v46 & 0x101) != 0) {
      goto LABEL_87;
    }
    memset(&v73, 0, sizeof(v73));
    BOOL v50 = sub_100112C78(v69, *v9, (_DWORD *)(a2 + 40));
    sub_101013390(v50 + 5, (void **)buf, (unint64_t *)&v73);
    std::string::size_type v52 = v73.__r_.__value_.__l.__size_;
    uint64_t v51 = (void *)v73.__r_.__value_.__r.__words[0];
    char v53 = *(NSObject **)(a1 + 48);
    if (v73.__r_.__value_.__r.__words[0] != v73.__r_.__value_.__l.__size_)
    {
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v71 = 134217984;
        std::string::size_type v72 = v52 - (void)v51;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I [Multi Part MMS] Extracted message of size: %zu", v71, 0xCu);
      }
      uint64_t v54 = *v42;
      if (*v42)
      {
        *(void *)(a2 + 120) = v54;
        operator delete(v54);
        *CFStringRef v42 = 0;
        *(void *)(a2 + 120) = 0;
        *(void *)(a2 + 128) = 0;
      }
      int v55 = 0;
      *(std::string *)(a2 + 112) = v73;
LABEL_88:
      if (SHIBYTE(v75) < 0) {
        operator delete(*(void **)buf);
      }
      if (!v55) {
        goto LABEL_91;
      }
LABEL_104:
      if (a4 == 2)
      {
        uint64_t v67 = *(void *)(a1 + 128);
        char v68 = *(std::__shared_weak_count **)(a1 + 136);
        if (!v68) {
          goto LABEL_108;
        }
      }
      else
      {
        if (a4 != 1) {
          return;
        }
        uint64_t v67 = *(void *)(a1 + 112);
        char v68 = *(std::__shared_weak_count **)(a1 + 120);
        if (!v68) {
          goto LABEL_108;
        }
      }
      atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_108:
      if (v67) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v67 + 40))(v67, a3);
      }
      if (v68) {
        sub_10004D2C8(v68);
      }
      return;
    }
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v71 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "[Multi Part MMS] Extracted message had no content", v71, 2u);
      uint64_t v51 = (void *)v73.__r_.__value_.__r.__words[0];
      if (!v73.__r_.__value_.__r.__words[0]) {
        goto LABEL_87;
      }
    }
    else if (!v51)
    {
LABEL_87:
      int v55 = 1;
      goto LABEL_88;
    }
    v73.__r_.__value_.__l.__size_ = (std::string::size_type)v51;
    operator delete(v51);
    goto LABEL_87;
  }
  uint64_t v16 = *(void (**)(void))(**(void **)(a1 + 144) + 56);

  v16();
}

void sub_100264E08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  sub_1000C6EE8(v30, v31);
  _Unwind_Resume(a1);
}

void sub_100264EC0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (a4 == 2)
  {
    uint64_t v8 = *(void *)(a1 + 128);
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 136);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (a4 != 1) {
    goto LABEL_9;
  }
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 120);
  if (v9) {
LABEL_4:
  }
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_5:
  if (v8) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 40))(v8, a3);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
LABEL_9:
  uint64_t v10 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a2 + 32);
    unint64_t v12 = *(char *)(a2 + 40);
    if (v12 > 2) {
      uint64_t v13 = "???";
    }
    else {
      uint64_t v13 = off_1019B1CB8[v12];
    }
    int v20 = 134218242;
    uint64_t v21 = v11;
    __int16 v22 = 2080;
    BOOL v23 = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [StewieGenericErrorMessageIncoming] Processing... TimeStamp: %llu, Error code: %s", (uint8_t *)&v20, 0x16u);
  }
  int v14 = *(unsigned __int8 *)(a2 + 40);
  if (v14 == 2)
  {
    std::string::size_type v15 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "[StewieGenericErrorMessageIncoming][Coding error] Parsing should have failed", (uint8_t *)&v20, 2u);
    }
  }
  else if (v14 == 1)
  {
    uint64_t v16 = *(std::__shared_weak_count **)(a1 + 88);
    if (v16)
    {
      unsigned int v17 = std::__shared_weak_count::lock(v16);
      if (v17)
      {
        uint64_t v18 = v17;
        uint64_t v19 = *(void *)(a1 + 80);
        if (v19)
        {
          int v20 = 14;
          LOBYTE(v21) = 0;
          BYTE2(v21) = 0;
          BYTE4(v21) = 1;
          (*(void (**)(uint64_t, int *))(*(void *)v19 + 40))(v19, &v20);
        }
        sub_10004D2C8(v18);
      }
    }
  }
  else if (!*(unsigned char *)(a2 + 40))
  {
    sub_100260C68(a1);
  }
}

void sub_1002650DC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100265108(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7 = a1 + 32;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v8 = *(void *)(a3 + 8) - *(void *)a3;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
  if (*(_WORD *)(v7 + 384))
  {
    if (!*(unsigned char *)(a1 + 656))
    {
      Registry::getTimerService((uint64_t *)&__p, *(Registry **)(a1 + 64));
      uint64_t v9 = (**(uint64_t (***)(void))__p)(__p);
      if (!*(unsigned char *)(a1 + 656)) {
        *(unsigned char *)(a1 + 656) = 1;
      }
      *(void *)(a1 + 648) = v9;
      if (*((void *)&__p + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&__p + 1));
      }
    }
    if (a2 == 2)
    {
      ++*(_DWORD *)(a1 + 608);
    }
    else if (a2 == 1)
    {
      ++*(_DWORD *)(a1 + 604);
    }
    *(_DWORD *)(a1 + 612) += v8;
  }
  uint64_t v10 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    ctu::hex_sp();
    uint64_t v11 = SHIBYTE(v158) >= 0 ? &__p : (long long *)__p;
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Got encrypted message: %s", buf, 0xCu);
    if (SHIBYTE(v158) < 0) {
      operator delete((void *)__p);
    }
  }
  uint64_t v141 = *(void **)a3;
  unint64_t v12 = (unsigned __int8 *)v141;
  long long v142 = *(_OWORD *)(a3 + 8);
  uint64_t v13 = (unsigned __int8 *)v142;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  uint64_t v143 = 0;
  *(void *)&long long v144 = 0;
  *((void *)&v144 + 1) = 8;
  int v14 = *(NSObject **)(a1 + 304);
  if (v13 == v12)
  {
    LOBYTE(v143) = 1;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
LABEL_37:
      LOBYTE(v139[0]) = 0;
      char v140 = 0;
      StewieDataController::submitMessageIncomingMetric(a1, 0, v8, a2, 0, 0, v139);
      BOOL v34 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Hit failure, but still going to ack because we don't want this message to be re-transmitted", (uint8_t *)&__p, 2u);
      }
      if (a2 == 2)
      {
        uint64_t v35 = *(void *)(a1 + 128);
        uint64_t v36 = *(std::__shared_weak_count **)(a1 + 136);
        if (!v36)
        {
LABEL_43:
          if (v35) {
            (*(void (**)(uint64_t, uint64_t *))(*(void *)v35 + 40))(v35, a4);
          }
          goto LABEL_45;
        }
      }
      else
      {
        if (a2 != 1) {
          goto LABEL_231;
        }
        uint64_t v35 = *(void *)(a1 + 112);
        uint64_t v36 = *(std::__shared_weak_count **)(a1 + 120);
        if (!v36) {
          goto LABEL_43;
        }
      }
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      goto LABEL_43;
    }
    LOWORD(__p) = 0;
    int v37 = "Failed to read version";
    uint64_t v38 = v14;
    uint32_t v39 = 2;
LABEL_108:
    _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, v37, (uint8_t *)&__p, v39);
    goto LABEL_37;
  }
  *((void *)&v144 + 1) = 6;
  unsigned int v15 = *v12;
  if (v15 >= 0x40)
  {
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_37;
    }
    LODWORD(__p) = 16777728;
    WORD2(__p) = 0;
    BYTE6(__p) = 4;
    *(_DWORD *)((char *)&__p + 7) = v15 >> 6;
    int v37 = "Version mismatch. Supported: %hhu, Got: %hhu";
    uint64_t v38 = v14;
    uint32_t v39 = 11;
    goto LABEL_108;
  }
  *((void *)&v144 + 1) = 0;
  int v16 = *v12 & 0x3F;
  switch(*v12 & 0x3F)
  {
    case 2:
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
      uint64_t v134 = (NSObject **)(a1 + 304);
      memset(v159, 0, 56);
      *((void *)&__p + 1) = 0x200000001;
      *(void *)&long long __p = off_1019BE450;
      v158 = &unk_1019BE4B8;
      *(_DWORD *)uint64_t v159 = 50332160;
      v159[4] = 2;
      *(_WORD *)&v159[6] = 0;
      v159[8] = 0;
      v159[12] = 0;
      unsigned int v17 = *(NSObject **)(a1 + 48);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_290;
      }
      ctu::hex_sp();
      if (buf[23] >= 0) {
        uint64_t v18 = buf;
      }
      else {
        uint64_t v18 = *(const char **)buf;
      }
      *(_DWORD *)v153 = 136315394;
      *(void *)&v153[4] = "kEmergencyTextIncoming";
      __int16 v154 = 2080;
      v155 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding message with encrypted contents: %s", v153, 0x16u);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      if (HIDWORD(__p) < 0xF || (HIDWORD(__p) - 16) <= 2)
      {
LABEL_290:
        unsigned __int16 v19 = WORD4(__p);
        dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
        dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
        if (((unsigned __int16)(*(_WORD *)(a1 + 418) | *(_WORD *)(a1 + 416)) & v19) == 0)
        {
          uint64_t v71 = *(NSObject **)(a1 + 48);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
          {
            std::string::size_type v72 = sub_100BC87FC(WORD4(__p));
            std::string v73 = sub_10093AA58(HIDWORD(__p));
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v72;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v73;
            _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "#I %s service is not data path asserted, but received %s message. Ignore for now", buf, 0x16u);
          }
          goto LABEL_226;
        }
      }
      if (sub_10036B6F4((uint64_t)&__p, (uint64_t)v134, (unsigned __int8 **)&v141))
      {
        if (v159[12])
        {
          if (!*(void *)&v159[40])
          {
            uint64_t v20 = *(void *)&v159[16];
            uint64_t v21 = *(void *)&v159[24];
            if (*(void *)&v159[16] != *(void *)&v159[24])
            {
              __int16 v22 = operator new(0x68uLL);
              v22[1] = 0;
              _OWORD v22[2] = 0;
              void *v22 = off_1019B1598;
              v22[3] = off_1019BE558;
              v22[3] = off_1019BE558;
              v22[4] = *((void *)&__p + 1);
              v22[5] = &unk_1019BE5D0;
              v22[3] = &off_1019BE630;
              v22[3] = off_1019BE450;
              uint64_t v23 = *(void *)v159;
              v22[5] = &unk_1019BE4B8;
              v22[6] = v23;
              *(void *)((char *)v22 + 53) = *(void *)&v159[5];
              uint8_t v22[8] = v20;
              v22[9] = v21;
              memset(&v159[16], 0, 24);
              uint64_t v24 = *(void *)&v159[48];
              v22[10] = *(void *)&v159[32];
              v22[11] = 0;
              v22[12] = v24;
              *(void *)&v159[40] = 0;
              *(void *)&v159[48] = 0;
              *(void *)long long buf = a1;
              uint64_t v25 = *(std::__shared_weak_count **)(a1 + 24);
              if (!v25 || (uint64_t v26 = *(void *)(a1 + 16), (v27 = std::__shared_weak_count::lock(v25)) == 0)) {
                sub_100088B9C();
              }
              char v28 = v27;
              *(void *)&uint8_t buf[8] = v26;
              *(void *)&uint8_t buf[16] = v27;
              atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v27);
              v146 = v22 + 3;
              uint64_t v147 = (char *)v22;
              atomic_fetch_add_explicit(v22 + 1, 1uLL, memory_order_relaxed);
              char v148 = a2;
              uint64_t v30 = a4[1];
              uint64_t v149 = *a4;
              uint64_t v29 = v149;
              uint64_t v150 = v30;
              uint64_t v31 = a4[2];
              a4[1] = 0;
              a4[2] = 0;
              *a4 = 0;
              uint64_t v151 = v31;
              uint64_t v152 = v8;
              v156 = 0;
              unsigned int v32 = operator new(0x58uLL);
              void *v32 = off_1019B15E8;
              v32[1] = a1;
              v32[2] = v26;
              void v32[3] = v28;
              *(void *)&uint8_t buf[8] = 0;
              *(void *)&uint8_t buf[16] = 0;
              v32[4] = v22 + 3;
              v32[5] = v22;
              v146 = 0;
              uint64_t v147 = 0;
              *((unsigned char *)v32 + 48) = a2;
              v32[7] = v29;
              v32[8] = v30;
              uint64_t v150 = 0;
              uint64_t v151 = 0;
              uint64_t v149 = 0;
              v32[9] = v31;
              v32[10] = v8;
              v156 = v32;
              sub_10036B328((uint64_t)(v22 + 3), v7, v134, (uint64_t)v153);
              sub_10026E5BC(v153);
              size_t v33 = (std::__shared_weak_count *)v22;
              goto LABEL_138;
            }
          }
        }
        buf[0] = 0;
        uint8_t buf[16] = 0;
        StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 1, 0, (unsigned int *)buf);
        dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
        (*(void (**)(void, long long *, uint64_t *, uint64_t))(**(void **)(a1 + 144) + 24))(*(void *)(a1 + 144), &__p, a4, a2);
        sub_10025DC48(a1);
        goto LABEL_226;
      }
      buf[0] = 0;
      uint8_t buf[16] = 0;
      StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 0, 0, (unsigned int *)buf);
      uint64_t v83 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
      {
        unint64_t v120 = sub_100BC87FC(WORD4(__p));
        uint64_t v121 = sub_10093AA58(HIDWORD(__p));
        *(_DWORD *)v153 = 136315394;
        *(void *)&v153[4] = v120;
        __int16 v154 = 2080;
        v155 = v121;
        _os_log_error_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, "Hit failure for service: %s, but still going to ack because we don't want this %s to be re-transmitted", v153, 0x16u);
      }
      if (a2 == 2)
      {
        uint64_t v84 = *(void *)(a1 + 128);
        uint64_t v85 = *(std::__shared_weak_count **)(a1 + 136);
        if (v85) {
LABEL_133:
        }
          atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        if (a2 != 1) {
          goto LABEL_226;
        }
        uint64_t v84 = *(void *)(a1 + 112);
        uint64_t v85 = *(std::__shared_weak_count **)(a1 + 120);
        if (v85) {
          goto LABEL_133;
        }
      }
      if (v84) {
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v84 + 40))(v84, a4);
      }
      if (v85)
      {
        size_t v33 = v85;
LABEL_138:
        sub_10004D2C8(v33);
      }
LABEL_226:
      *(void *)&long long __p = off_1019BE450;
      v158 = &unk_1019BE4B8;
      if (*(void *)&v159[48]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v159[48]);
      }
      uint64_t v89 = *(void **)&v159[16];
      if (*(void *)&v159[16])
      {
        *(void *)&v159[24] = *(void *)&v159[16];
        goto LABEL_230;
      }
      goto LABEL_231;
    case 3:
    case 4:
    case 5:
    case 6:
    case 8:
    case 0xB:
    case 0xC:
      goto LABEL_182;
    case 7:
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
      uint64_t v135 = (NSObject **)(a1 + 304);
      memset(v159, 0, 64);
      *((void *)&__p + 1) = 0x700000008;
      *(void *)&long long __p = off_101A917F0;
      v158 = &unk_101A91858;
      *(_WORD *)uint64_t v159 = 1792;
      v159[2] = 0;
      *(_WORD *)&v159[4] = 0;
      v159[6] = 3;
      *(_WORD *)&v159[8] = 0;
      v159[12] = 0;
      uint64_t v40 = *(NSObject **)(a1 + 48);
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_291;
      }
      ctu::hex_sp();
      if (buf[23] >= 0) {
        uint64_t v41 = buf;
      }
      else {
        uint64_t v41 = *(const char **)buf;
      }
      *(_DWORD *)v153 = 136315394;
      *(void *)&v153[4] = "kRoadsideTextIncoming";
      __int16 v154 = 2080;
      v155 = v41;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding message with encrypted contents: %s", v153, 0x16u);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      if (HIDWORD(__p) < 0xF || (HIDWORD(__p) - 16) <= 2)
      {
LABEL_291:
        unsigned __int16 v42 = WORD4(__p);
        dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
        dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
        if (((unsigned __int16)(*(_WORD *)(a1 + 418) | *(_WORD *)(a1 + 416)) & v42) == 0)
        {
          char v68 = *(NSObject **)(a1 + 48);
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v69 = sub_100BC87FC(WORD4(__p));
            std::string v70 = sub_10093AA58(HIDWORD(__p));
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v69;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v70;
            _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I %s service is not data path asserted, but received %s message. Ignore for now", buf, 0x16u);
          }
          goto LABEL_221;
        }
      }
      if (sub_10111D2D4((uint64_t)&__p, (uint64_t)v135, (unsigned char **)&v141))
      {
        if (v159[16])
        {
          if (!*(void *)&v159[48])
          {
            long long v43 = *(_OWORD *)&v159[24];
            if (*(void *)&v159[24] != *(void *)&v159[32])
            {
              unint64_t v44 = (char *)operator new(0x70uLL);
              *((void *)v44 + 1) = 0;
              *((void *)v44 + 2) = 0;
              *(void *)unint64_t v44 = off_1019B1668;
              *((void *)v44 + 3) = off_101A918F8;
              *((void *)v44 + 3) = off_101A918F8;
              *((void *)v44 + 4) = *((void *)&__p + 1);
              *((void *)v44 + 5) = &unk_101A91970;
              *((void *)v44 + 3) = &off_101A919D0;
              *((void *)v44 + 3) = off_101A917F0;
              *((void *)v44 + 5) = &unk_101A91858;
              *((_OWORD *)v44 + 3) = *(_OWORD *)v159;
              v44[64] = v159[16];
              *(_OWORD *)(v44 + 72) = v43;
              memset(&v159[24], 0, 24);
              uint64_t v45 = *(void *)&v159[56];
              *((void *)v44 + 11) = *(void *)&v159[40];
              *((void *)v44 + 12) = 0;
              *((void *)v44 + 13) = v45;
              *(void *)&v159[48] = 0;
              *(void *)&v159[56] = 0;
              *(void *)long long buf = a1;
              int v46 = *(std::__shared_weak_count **)(a1 + 24);
              if (!v46 || (uint64_t v47 = *(void *)(a1 + 16), (v48 = std::__shared_weak_count::lock(v46)) == 0)) {
                sub_100088B9C();
              }
              unint64_t v49 = v48;
              *(void *)&uint8_t buf[8] = v47;
              *(void *)&uint8_t buf[16] = v48;
              atomic_fetch_add_explicit(&v48->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v48);
              v146 = v44 + 24;
              uint64_t v147 = v44;
              atomic_fetch_add_explicit((atomic_ullong *volatile)v44 + 1, 1uLL, memory_order_relaxed);
              char v148 = a2;
              uint64_t v51 = a4[1];
              uint64_t v149 = *a4;
              uint64_t v50 = v149;
              uint64_t v150 = v51;
              uint64_t v52 = a4[2];
              a4[1] = 0;
              a4[2] = 0;
              *a4 = 0;
              uint64_t v151 = v52;
              uint64_t v152 = v8;
              v156 = 0;
              char v53 = operator new(0x58uLL);
              void *v53 = off_1019B16B8;
              v53[1] = a1;
              v53[2] = v47;
              v53[3] = v49;
              *(void *)&uint8_t buf[8] = 0;
              *(void *)&uint8_t buf[16] = 0;
              v53[4] = v44 + 24;
              v53[5] = v44;
              v146 = 0;
              uint64_t v147 = 0;
              *((unsigned char *)v53 + 48) = a2;
              v53[7] = v50;
              char v53[8] = v51;
              uint64_t v150 = 0;
              uint64_t v151 = 0;
              uint64_t v149 = 0;
              v53[9] = v52;
              v53[10] = v8;
              v156 = v53;
              sub_10111CF50((uint64_t)(v44 + 24), v7, v135, (uint64_t)v153);
              sub_10026E5BC(v153);
              uint64_t v54 = (std::__shared_weak_count *)v44;
              goto LABEL_127;
            }
          }
        }
        buf[0] = 0;
        uint8_t buf[16] = 0;
        StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 1, 0, (unsigned int *)buf);
        dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
        (*(void (**)(void, long long *, uint64_t *, uint64_t))(**(void **)(a1 + 144) + 32))(*(void *)(a1 + 144), &__p, a4, a2);
        sub_10025DC48(a1);
        goto LABEL_221;
      }
      buf[0] = 0;
      uint8_t buf[16] = 0;
      StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 0, 0, (unsigned int *)buf);
      int v80 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
      {
        uint64_t v116 = sub_100BC87FC(WORD4(__p));
        __int16 v117 = sub_10093AA58(HIDWORD(__p));
        *(_DWORD *)v153 = 136315394;
        *(void *)&v153[4] = v116;
        __int16 v154 = 2080;
        v155 = v117;
        _os_log_error_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "Hit failure for service: %s, but still going to ack because we don't want this %s to be re-transmitted", v153, 0x16u);
      }
      if (a2 == 2)
      {
        uint64_t v81 = *(void *)(a1 + 128);
        uint64_t v82 = *(std::__shared_weak_count **)(a1 + 136);
        if (v82) {
LABEL_122:
        }
          atomic_fetch_add_explicit(&v82->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        if (a2 != 1) {
          goto LABEL_221;
        }
        uint64_t v81 = *(void *)(a1 + 112);
        uint64_t v82 = *(std::__shared_weak_count **)(a1 + 120);
        if (v82) {
          goto LABEL_122;
        }
      }
      if (v81) {
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v81 + 40))(v81, a4);
      }
      if (v82)
      {
        uint64_t v54 = v82;
LABEL_127:
        sub_10004D2C8(v54);
      }
LABEL_221:
      *(void *)&long long __p = off_101A917F0;
      v158 = &unk_101A91858;
      if (*(void *)&v159[56]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v159[56]);
      }
      uint64_t v89 = *(void **)&v159[24];
      if (!*(void *)&v159[24]) {
        goto LABEL_231;
      }
      *(void *)&v159[32] = *(void *)&v159[24];
      goto LABEL_230;
    case 9:
      uint64_t v55 = *(void *)(a1 + 392);
      if (v55 && !*(unsigned char *)(v55 + 184))
      {
        uint64_t v99 = *(std::__shared_weak_count **)(a1 + 400);
        if (v99)
        {
          atomic_fetch_add_explicit(&v99->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v99);
        }
        unsigned __int16 v56 = 32;
      }
      else
      {
        unsigned __int16 v56 = 16;
      }
      dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
      *(void *)&v159[32] = 1285;
      *(_DWORD *)uint64_t v159 = 2304;
      HIDWORD(__p) = 11;
      *(void *)&long long __p = off_1019D3880;
      v158 = &unk_1019D38E8;
      memset(&v159[4], 0, 28);
      memset(&v159[40], 0, 24);
      DWORD2(__p) = v56;
      uint64_t v100 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
      {
        ctu::hex_sp();
        if (buf[23] >= 0) {
          uint64_t v101 = buf;
        }
        else {
          uint64_t v101 = *(const char **)buf;
        }
        *(_DWORD *)v153 = 136315394;
        *(void *)&v153[4] = "kCarrierPigeonSummaryMessage";
        __int16 v154 = 2080;
        v155 = v101;
        _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding message with encrypted contents: %s", v153, 0x16u);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (HIDWORD(__p) >= 0xF && (HIDWORD(__p) - 16) > 2) {
          goto LABEL_203;
        }
      }
      unsigned __int16 v102 = WORD4(__p);
      dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
      dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
      if (((unsigned __int16)(*(_WORD *)(a1 + 418) | *(_WORD *)(a1 + 416)) & v102) != 0)
      {
LABEL_203:
        if (sub_10049D1A0((uint64_t)&__p, a1 + 304, (uint64_t)&v141))
        {
          buf[0] = 0;
          uint8_t buf[16] = 0;
          StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 1, 0, (unsigned int *)buf);
          sub_100263850(a1, (uint64_t)&__p, (uint64_t)a4, a2);
          sub_10025DC48(a1);
          goto LABEL_217;
        }
        buf[0] = 0;
        uint8_t buf[16] = 0;
        StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 0, 0, (unsigned int *)buf);
        unsigned int v106 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
        {
          uint64_t v118 = sub_100BC87FC(WORD4(__p));
          int v119 = sub_10093AA58(HIDWORD(__p));
          *(_DWORD *)v153 = 136315394;
          *(void *)&v153[4] = v118;
          __int16 v154 = 2080;
          v155 = v119;
          _os_log_error_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_ERROR, "Hit failure for service: %s, but still going to ack because we don't want this %s to be re-transmitted", v153, 0x16u);
        }
        if (a2 == 2)
        {
          uint64_t v107 = *(void *)(a1 + 128);
          __int16 v108 = *(std::__shared_weak_count **)(a1 + 136);
          if (!v108) {
            goto LABEL_213;
          }
        }
        else
        {
          if (a2 != 1) {
            goto LABEL_217;
          }
          uint64_t v107 = *(void *)(a1 + 112);
          __int16 v108 = *(std::__shared_weak_count **)(a1 + 120);
          if (!v108) {
            goto LABEL_213;
          }
        }
        atomic_fetch_add_explicit(&v108->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_213:
        if (v107) {
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v107 + 40))(v107, a4);
        }
        if (v108) {
          sub_10004D2C8(v108);
        }
        goto LABEL_217;
      }
      unsigned int v103 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v104 = sub_100BC87FC(WORD4(__p));
        unsigned int v105 = sub_10093AA58(HIDWORD(__p));
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v104;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v105;
        _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "#I %s service is not data path asserted, but received %s message. Ignore for now", buf, 0x16u);
      }
LABEL_217:
      *(void *)&long long __p = off_1019D3880;
      v158 = &unk_1019D38E8;
      if (*(void *)&v159[40])
      {
        *(void *)&v159[48] = *(void *)&v159[40];
        operator delete(*(void **)&v159[40]);
      }
      *(void *)v153 = &v159[8];
      sub_100274E3C((void ***)v153);
      goto LABEL_231;
    case 0xA:
      dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
      *(void *)uint64_t v159 = 2560;
      *((void *)&__p + 1) = 0xC00000010;
      *(void *)&long long __p = off_1019D3988;
      v158 = &unk_1019D39F0;
      memset(&v159[8], 0, 72);
      uint64_t v57 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        ctu::hex_sp();
        if (buf[23] >= 0) {
          __int16 v58 = buf;
        }
        else {
          __int16 v58 = *(const char **)buf;
        }
        *(_DWORD *)v153 = 136315394;
        *(void *)&v153[4] = "kIMessageLiteMessageIncoming";
        __int16 v154 = 2080;
        v155 = v58;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding message with encrypted contents: %s", v153, 0x16u);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (HIDWORD(__p) >= 0xF && (HIDWORD(__p) - 16) > 2) {
          goto LABEL_79;
        }
      }
      unsigned __int16 v59 = WORD4(__p);
      dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
      dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
      if (((unsigned __int16)(*(_WORD *)(a1 + 418) | *(_WORD *)(a1 + 416)) & v59) != 0)
      {
LABEL_79:
        if (sub_10049EF6C((uint64_t)&__p, a1 + 304, (uint64_t)&v141))
        {
          buf[0] = 0;
          uint8_t buf[16] = 0;
          StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 1, 0, (unsigned int *)buf);
          dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
          (*(void (**)(void, long long *, uint64_t *, uint64_t))(**(void **)(a1 + 144) + 48))(*(void *)(a1 + 144), &__p, a4, a2);
          sub_10025DC48(a1);
          goto LABEL_149;
        }
        buf[0] = 0;
        uint8_t buf[16] = 0;
        StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 0, 0, (unsigned int *)buf);
        uint64_t v86 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
        {
          uint64_t v122 = sub_100BC87FC(WORD4(__p));
          int v123 = sub_10093AA58(HIDWORD(__p));
          *(_DWORD *)v153 = 136315394;
          *(void *)&v153[4] = v122;
          __int16 v154 = 2080;
          v155 = v123;
          _os_log_error_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "Hit failure for service: %s, but still going to ack because we don't want this %s to be re-transmitted", v153, 0x16u);
        }
        if (a2 == 2)
        {
          uint64_t v87 = *(void *)(a1 + 128);
          unsigned __int8 v88 = *(std::__shared_weak_count **)(a1 + 136);
          if (!v88) {
            goto LABEL_145;
          }
        }
        else
        {
          if (a2 != 1) {
            goto LABEL_149;
          }
          uint64_t v87 = *(void *)(a1 + 112);
          unsigned __int8 v88 = *(std::__shared_weak_count **)(a1 + 120);
          if (!v88) {
            goto LABEL_145;
          }
        }
        atomic_fetch_add_explicit(&v88->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_145:
        if (v87) {
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v87 + 40))(v87, a4);
        }
        if (v88) {
          sub_10004D2C8(v88);
        }
        goto LABEL_149;
      }
      uint64_t v74 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v75 = sub_100BC87FC(WORD4(__p));
        char v76 = sub_10093AA58(HIDWORD(__p));
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v75;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v76;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I %s service is not data path asserted, but received %s message. Ignore for now", buf, 0x16u);
      }
LABEL_149:
      *(void *)&long long __p = off_1019D3988;
      v158 = &unk_1019D39F0;
      uint64_t v89 = *(void **)&v159[56];
      if (!*(void *)&v159[56]) {
        goto LABEL_231;
      }
      *(void *)&v159[64] = *(void *)&v159[56];
      goto LABEL_230;
    case 0xD:
      dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
      uint64_t v160 = 0;
      *(void *)uint64_t v159 = 3328;
      *((void *)&__p + 1) = 0x1100000020;
      *(void *)&long long __p = off_1019D3A90;
      v158 = &unk_1019D3AF8;
      uint64_t v164 = 0;
      v165 = 0;
      memset(&v159[8], 0, 72);
      *(_OWORD *)unint64_t v161 = 0u;
      *(_OWORD *)uint64_t v162 = 0u;
      memset(v163, 0, sizeof(v163));
      uint64_t v60 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        ctu::hex_sp();
        if (buf[23] >= 0) {
          unsigned int v61 = buf;
        }
        else {
          unsigned int v61 = *(const char **)buf;
        }
        *(_DWORD *)v153 = 136315394;
        *(void *)&v153[4] = "kSatSmsMessageIncoming";
        __int16 v154 = 2080;
        v155 = v61;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding message with encrypted contents: %s", v153, 0x16u);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (HIDWORD(__p) >= 0xF && (HIDWORD(__p) - 16) > 2) {
          goto LABEL_89;
        }
      }
      unsigned __int16 v62 = WORD4(__p);
      dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
      dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
      if (((unsigned __int16)(*(_WORD *)(a1 + 418) | *(_WORD *)(a1 + 416)) & v62) != 0)
      {
LABEL_89:
        if (sub_1004A2564((uint64_t)&__p, a1 + 304, (uint64_t)&v141))
        {
          buf[0] = 0;
          uint8_t buf[16] = 0;
          StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 1, 0, (unsigned int *)buf);
          sub_1002644BC(a1, (uint64_t)&__p, (uint64_t)a4, a2);
          sub_10025DC48(a1);
          goto LABEL_161;
        }
        buf[0] = 0;
        uint8_t buf[16] = 0;
        StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 0, 0, (unsigned int *)buf);
        uint64_t v90 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
        {
          long long v124 = sub_100BC87FC(WORD4(__p));
          long long v125 = sub_10093AA58(HIDWORD(__p));
          *(_DWORD *)v153 = 136315394;
          *(void *)&v153[4] = v124;
          __int16 v154 = 2080;
          v155 = v125;
          _os_log_error_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_ERROR, "Hit failure for service: %s, but still going to ack because we don't want this %s to be re-transmitted", v153, 0x16u);
        }
        if (a2 == 2)
        {
          uint64_t v91 = *(void *)(a1 + 128);
          unsigned int v92 = *(std::__shared_weak_count **)(a1 + 136);
          if (!v92) {
            goto LABEL_157;
          }
        }
        else
        {
          if (a2 != 1) {
            goto LABEL_161;
          }
          uint64_t v91 = *(void *)(a1 + 112);
          unsigned int v92 = *(std::__shared_weak_count **)(a1 + 120);
          if (!v92) {
            goto LABEL_157;
          }
        }
        atomic_fetch_add_explicit(&v92->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_157:
        if (v91) {
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v91 + 40))(v91, a4);
        }
        if (v92) {
          sub_10004D2C8(v92);
        }
        goto LABEL_161;
      }
      uint64_t v77 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v78 = sub_100BC87FC(WORD4(__p));
        uint64_t v79 = sub_10093AA58(HIDWORD(__p));
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v78;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v79;
        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I %s service is not data path asserted, but received %s message. Ignore for now", buf, 0x16u);
      }
LABEL_161:
      *(void *)&long long __p = off_1019D3A90;
      v158 = &unk_1019D3AF8;
      if (v165) {
        sub_10004D2C8(v165);
      }
      if ((v163[15] & 0x80000000) != 0) {
        operator delete(v162[1]);
      }
      if (v161[0])
      {
        v161[1] = v161[0];
        operator delete(v161[0]);
      }
      if ((v159[79] & 0x80000000) != 0) {
        operator delete(*(void **)&v159[56]);
      }
      uint64_t v89 = *(void **)&v159[32];
      if (*(void *)&v159[32])
      {
        *(void *)&v159[40] = *(void *)&v159[32];
LABEL_230:
        operator delete(v89);
      }
      goto LABEL_231;
    default:
      if (v16 != 62)
      {
        if (v16 == 63)
        {
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
          *(void *)&long long __p = 0x3F04000100;
          int v37 = "Unknown message type: %hhu";
          uint64_t v38 = v14;
          uint32_t v39 = 8;
          goto LABEL_108;
        }
LABEL_182:
        LOBYTE(v137[0]) = 0;
        char v138 = 0;
        StewieDataController::submitMessageIncomingMetric(a1, 0, v8, a2, 0, 0, v137);
        uint64_t v97 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
        {
          uint64_t v115 = sub_10093AA7C(v16);
          LODWORD(__p) = 136315138;
          *(void *)((char *)&__p + 4) = v115;
          _os_log_error_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_ERROR, "Unexpected message type: %s, but still going to ack because we don't want this message to be re-transmitted", (uint8_t *)&__p, 0xCu);
        }
        if (a2 == 2)
        {
          uint64_t v98 = *(void *)(a1 + 128);
          uint64_t v36 = *(std::__shared_weak_count **)(a1 + 136);
          if (!v36)
          {
LABEL_188:
            if (v98) {
              (*(void (**)(uint64_t, uint64_t *))(*(void *)v98 + 40))(v98, a4);
            }
            goto LABEL_45;
          }
        }
        else
        {
          if (a2 != 1) {
            goto LABEL_231;
          }
          uint64_t v98 = *(void *)(a1 + 112);
          uint64_t v36 = *(std::__shared_weak_count **)(a1 + 120);
          if (!v36) {
            goto LABEL_188;
          }
        }
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        goto LABEL_188;
      }
      long long v144 = xmmword_101476F90;
      if ((unint64_t)(v13 - v12) < 2)
      {
        LOBYTE(v143) = 1;
        __int16 v133 = *(NSObject **)(a1 + 48);
        if (!os_log_type_enabled(v133, OS_LOG_TYPE_ERROR)) {
          goto LABEL_182;
        }
        LOWORD(__p) = 0;
        v126 = "Failed to read protocol service type from error message";
        uint64_t v127 = v133;
        uint32_t v128 = 2;
LABEL_281:
        _os_log_error_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_ERROR, v126, (uint8_t *)&__p, v128);
        goto LABEL_182;
      }
      *((void *)&v144 + 1) = 0;
      unsigned int v63 = v12[1];
      if (v63 >= 5) {
        int v64 = 5;
      }
      else {
        int v64 = v12[1];
      }
      if (!v64)
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
        *(void *)&v159[16] = 2;
        *(void *)uint64_t v159 = 15872;
        *((void *)&__p + 1) = 0x1300000000;
        *(void *)&long long __p = off_101A70DD0;
        v158 = &unk_101A70E38;
        *(void *)&v159[8] = 0;
        unsigned int v93 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
        {
          ctu::hex_sp();
          if (buf[23] >= 0) {
            unsigned int v94 = buf;
          }
          else {
            unsigned int v94 = *(const char **)buf;
          }
          *(_DWORD *)v153 = 136315394;
          *(void *)&v153[4] = "kGenericErrorMessage";
          __int16 v154 = 2080;
          v155 = v94;
          _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding message with encrypted contents: %s", v153, 0x16u);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          if (HIDWORD(__p) < 0xF || (HIDWORD(__p) - 16) <= 2)
          {
            unsigned __int16 v95 = WORD4(__p);
            dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
            dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
            if (((unsigned __int16)(*(_WORD *)(a1 + 418) | *(_WORD *)(a1 + 416)) & v95) == 0) {
              goto LABEL_270;
            }
          }
        }
        if (sub_100F36EEC((uint64_t)&__p, (os_log_t *)(a1 + 304), (uint64_t)&v141))
        {
          buf[0] = 0;
          uint8_t buf[16] = 0;
          StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 1, 0, (unsigned int *)buf);
          sub_100264EC0(a1, (uint64_t)&__p, (uint64_t)a4, a2);
          sub_10025DC48(a1);
          goto LABEL_231;
        }
        buf[0] = 0;
        uint8_t buf[16] = 0;
        StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 0, 0, (unsigned int *)buf);
        __int16 v111 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
        {
          long long v131 = sub_100BC87FC(WORD4(__p));
          uint64_t v132 = sub_10093AA58(HIDWORD(__p));
          *(_DWORD *)v153 = 136315394;
          *(void *)&v153[4] = v131;
          __int16 v154 = 2080;
          v155 = v132;
          _os_log_error_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "Hit failure for service: %s, but still going to ack because we don't want this %s to be re-transmitted", v153, 0x16u);
        }
        if (a2 == 2)
        {
          uint64_t v110 = *(void *)(a1 + 128);
          uint64_t v36 = *(std::__shared_weak_count **)(a1 + 136);
          if (v36) {
LABEL_247:
          }
            atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          if (a2 != 1) {
            goto LABEL_231;
          }
          uint64_t v110 = *(void *)(a1 + 112);
          uint64_t v36 = *(std::__shared_weak_count **)(a1 + 120);
          if (v36) {
            goto LABEL_247;
          }
        }
        if (!v110)
        {
LABEL_45:
          if (v36) {
            sub_10004D2C8(v36);
          }
          goto LABEL_231;
        }
LABEL_241:
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v110 + 40))(v110, a4);
        goto LABEL_45;
      }
      if (v64 != 4)
      {
        unsigned int v96 = *(NSObject **)(a1 + 48);
        if (!os_log_type_enabled(v96, OS_LOG_TYPE_ERROR)) {
          goto LABEL_182;
        }
        LODWORD(__p) = 67109120;
        DWORD1(__p) = v63;
        v126 = "Unrecognized service type: %hhu in error message";
        uint64_t v127 = v96;
        uint32_t v128 = 8;
        goto LABEL_281;
      }
      dispatch_assert_queue_V2(*(dispatch_queue_t *)v7);
      *(void *)&v159[16] = 1;
      *(void *)uint64_t v159 = 15872;
      *((void *)&__p + 1) = 0xF00000000;
      *(void *)&long long __p = off_1019D3B98;
      v158 = &unk_1019D3C00;
      *(void *)&v159[8] = 0;
      char v65 = *(NSObject **)(a1 + 48);
      if (!os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_105;
      }
      ctu::hex_sp();
      if (buf[23] >= 0) {
        int v66 = buf;
      }
      else {
        int v66 = *(const char **)buf;
      }
      *(_DWORD *)v153 = 136315394;
      *(void *)&v153[4] = "kIMessageLiteErrorMessage";
      __int16 v154 = 2080;
      v155 = v66;
      _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding message with encrypted contents: %s", v153, 0x16u);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      if (HIDWORD(__p) >= 0xF && (HIDWORD(__p) - 16) > 2
        || (unsigned __int16 v67 = WORD4(__p),
            dispatch_assert_queue_V2(*(dispatch_queue_t *)v7),
            dispatch_assert_queue_V2(*(dispatch_queue_t *)v7),
            ((unsigned __int16)(*(_WORD *)(a1 + 418) | *(_WORD *)(a1 + 416)) & v67) != 0))
      {
LABEL_105:
        if (sub_1004A0560((uint64_t)&__p, (os_log_t *)(a1 + 304), (uint64_t)&v141))
        {
          buf[0] = 0;
          uint8_t buf[16] = 0;
          StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 1, 0, (unsigned int *)buf);
          sub_100264100(a1, (uint64_t)&__p, (uint64_t)a4, a2);
          sub_10025DC48(a1);
          goto LABEL_231;
        }
        buf[0] = 0;
        uint8_t buf[16] = 0;
        StewieDataController::submitMessageIncomingMetric(a1, SHIDWORD(__p), v8, a2, 0, 0, (unsigned int *)buf);
        unsigned int v109 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
        {
          uint64_t v129 = sub_100BC87FC(WORD4(__p));
          v130 = sub_10093AA58(HIDWORD(__p));
          *(_DWORD *)v153 = 136315394;
          *(void *)&v153[4] = v129;
          __int16 v154 = 2080;
          v155 = v130;
          _os_log_error_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_ERROR, "Hit failure for service: %s, but still going to ack because we don't want this %s to be re-transmitted", v153, 0x16u);
        }
        if (a2 == 2)
        {
          uint64_t v110 = *(void *)(a1 + 128);
          uint64_t v36 = *(std::__shared_weak_count **)(a1 + 136);
          if (v36) {
LABEL_239:
          }
            atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          if (a2 != 1) {
            goto LABEL_231;
          }
          uint64_t v110 = *(void *)(a1 + 112);
          uint64_t v36 = *(std::__shared_weak_count **)(a1 + 120);
          if (v36) {
            goto LABEL_239;
          }
        }
        if (!v110) {
          goto LABEL_45;
        }
        goto LABEL_241;
      }
LABEL_270:
      unsigned int v112 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v113 = sub_100BC87FC(WORD4(__p));
        __int16 v114 = sub_10093AA58(HIDWORD(__p));
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v113;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v114;
        _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "#I %s service is not data path asserted, but received %s message. Ignore for now", buf, 0x16u);
      }
LABEL_231:
      if (v141)
      {
        *(void *)&long long v142 = v141;
        operator delete(v141);
      }
      return;
  }
}

void sub_100267D74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42)
{
  if (v42) {
    sub_10004D2C8(v42);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100267F34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
}

void sub_100267F3C(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      int v6 = v5;
      uint64_t v7 = *(void (****)(void, uint64_t))(a1 + 80);
      if (v7) {
        (**v7)(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100267FD8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100267FEC(uint64_t a1, uint64_t a2)
{
}

void sub_100267FF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (!*(unsigned char *)(a1 + 672))
  {
    Registry::getTimerService((uint64_t *)&v11, *(Registry **)(a1 + 64));
    uint64_t v6 = (**v11)(v11);
    if (!*(unsigned char *)(a1 + 672)) {
      *(unsigned char *)(a1 + 672) = 1;
    }
    *(void *)(a1 + 664) = v6;
    if (v12) {
      sub_10004D2C8(v12);
    }
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7)
  {
    uint64_t v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(a1 + 80);
      if (v10) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 8))(v10, a2, a3);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1002680E0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100268104(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_10026810C(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 80);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 104))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1002681A8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1002681BC(uint64_t a1, uint64_t a2)
{
}

void sub_1002681C4(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 80);
      if (v7)
      {
        int v8 = a2;
        char v9 = 0;
        char v10 = 0;
        char v11 = 1;
        (*(void (**)(uint64_t, int *))(*(void *)v7 + 40))(v7, &v8);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100268260(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100268274(uint64_t a1, int a2)
{
}

void sub_10026827C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416))
  {
    unsigned int v2 = sub_10025C21C(a1, *(_DWORD *)(a1 + 800));
    int v3 = *(unsigned __int16 *)(a1 + 416);
    uint64_t v4 = v3 & v2;
    if ((v3 & v2) != 0)
    {
      uint64_t v5 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        sub_100BC897C(v4, &__p);
        uint64_t v6 = *(int *)(a1 + 800);
        if (v6 > 5) {
          uint64_t v7 = "???";
        }
        else {
          uint64_t v7 = off_1019B1CF0[v6];
        }
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        *(_DWORD *)long long buf = 136446466;
        unsigned int v15 = p_p;
        __int16 v16 = 2080;
        unsigned int v17 = v7;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [Congestion] Exiting services: %{public}s due to congestion status: %s", buf, 0x16u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      char v9 = *(std::__shared_weak_count **)(a1 + 88);
      if (v9)
      {
        char v10 = std::__shared_weak_count::lock(v9);
        if (v10)
        {
          char v11 = v10;
          uint64_t v12 = *(void *)(a1 + 80);
          if (v12)
          {
            LODWORD(__p.__r_.__value_.__l.__data_) = 12;
            WORD2(__p.__r_.__value_.__r.__words[0]) = v4;
            __p.__r_.__value_.__s.__data_[6] = 1;
            __p.__r_.__value_.__s.__data_[8] = 1;
            (*(void (**)(uint64_t, std::string *))(*(void *)v12 + 40))(v12, &__p);
          }
          sub_10004D2C8(v11);
        }
      }
    }
  }
}

void sub_100268414(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100268430(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if ((*(_DWORD *)a2 & 0xFFFFFFFE) == 2) {
    *(unsigned char *)(a1 + 552) = 1;
  }
  uint64_t v4 = *(void *)(a1 + 360);
  if (v4) {
    sub_1003CB63C(v4, *(_DWORD *)(a2 + 4) == 2);
  }
  if (*(_DWORD *)(a2 + 4) == 2 && !*(unsigned char *)(a1 + 553))
  {
    *(unsigned char *)(a1 + 553) = 1;
    Registry::getTimerService((uint64_t *)&v10, *(Registry **)(a1 + 64));
    *(void *)(a1 + 560) = (**v10)();
    if (v11) {
      sub_10004D2C8(v11);
    }
  }
  if (*(unsigned char *)(a2 + 20))
  {
    int v5 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 800) = v5;
    if (*(_DWORD *)(a1 + 620) < v5) {
      *(_DWORD *)(a1 + 620) = v5;
    }
  }
  sub_10026827C(a1);
  sub_10025BAD4(a1);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      int v8 = v7;
      uint64_t v9 = *(void *)(a1 + 80);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 16))(v9, a2);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10026858C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002685B0(uint64_t a1, uint64_t a2)
{
}

void sub_1002685B8(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    int v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 80);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 24))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100268654(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100268668(uint64_t a1, uint64_t a2)
{
}

void sub_100268670(uint64_t a1, __n128 *a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416))
  {
    uint64_t v21 = 0;
    __int16 v22 = 0;
    std::string __p = 0;
    unsigned __int16 v19 = 0;
    uint64_t v20 = 0;
    sub_10014BD54((char *)&__p, "com.apple.stewie.logging", "", 0x18uLL);
    uint64_t v4 = (NSObject **)(a1 + 48);
    sub_100BCB70C((os_log_t *)(a1 + 48), 0x20uLL, &v21);
    if (__p)
    {
      unsigned __int16 v19 = __p;
      operator delete(__p);
    }
    if (v21 && v21[1] - *v21 == 32)
    {
      int v5 = *v4;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        ctu::hex_sp();
        uint64_t v6 = v20 >= 0 ? &__p : (void **)__p;
        *(_DWORD *)long long buf = 136446210;
        uint64_t v24 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [Klog] Logging key: %{public}s", buf, 0xCu);
        if (SHIBYTE(v20) < 0) {
          operator delete(__p);
        }
      }
    }
    else
    {
      uint64_t v7 = *v4;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#E [Klog] Unable expand logging key", (uint8_t *)&__p, 2u);
      }
    }
    sub_100195D74(a1 + 752, a2);
    sub_10025CA00(a1);
    sub_10025CBB0(a1);
    int v8 = *(void **)(a1 + 520);
    if (v8 != (void *)(a1 + 528))
    {
      do
      {
        if ((*(unsigned int (**)(void))(*(void *)v8[6] + 80))(v8[6])) {
          *((unsigned char *)v8 + 124) = 1;
        }
        uint64_t v9 = (void *)v8[1];
        if (v9)
        {
          do
          {
            char v10 = v9;
            uint64_t v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            char v10 = (void *)v8[2];
            BOOL v11 = *v10 == (void)v8;
            int v8 = v10;
          }
          while (!v11);
        }
        int v8 = v10;
      }
      while (v10 != (void *)(a1 + 528));
    }
    sub_1004D06C4(a1 + 304);
    sub_1004D05EC(a1 + 304, (void *)(a1 + 64));
    sub_10026827C(a1);
    uint64_t v12 = *(void *)(a1 + 112);
    uint64_t v13 = sub_10025C910(a1);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 168))(v12, v13);
    uint64_t v14 = *(void *)(a1 + 360);
    if (v14)
    {
      uint64_t v15 = *(void *)(a1 + 376);
      if (v15) {
        sub_1004FBE4C(v15, (const void **)(v14 + 64));
      }
      uint64_t v16 = *(void *)(a1 + 392);
      if (v16 && !*(unsigned char *)(v16 + 184))
      {
        unsigned int v17 = *(std::__shared_weak_count **)(a1 + 400);
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1006BFB58(v16, (const void **)(*(void *)(a1 + 360) + 64));
        if (v17) {
          sub_10004D2C8(v17);
        }
      }
    }
    sub_10025DC48(a1);
    if (v22) {
      sub_10004D2C8(v22);
    }
  }
}

void sub_100268968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002689BC(uint64_t a1, __n128 *a2)
{
}

void sub_1002689C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      int v8 = v7;
      uint64_t v9 = *(void *)(a1 + 80);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100268A68(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100268A7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100268A84(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    int v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 80);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100268B20(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100268B34(uint64_t a1, uint64_t a2)
{
}

void sub_100268B3C(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    int v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 80);
      if (v6)
      {
        (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
LABEL_9:
        sub_10004D2C8(v5);
        return;
      }
    }
  }
  else
  {
    int v5 = 0;
  }
  uint64_t v7 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No delegate to create assertion", v8, 2u);
  }
  *a2 = 0;
  a2[1] = 0;
  if (v5) {
    goto LABEL_9;
  }
}

void sub_100268C14(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100268C28(uint64_t a1@<X0>, void *a2@<X8>)
{
}

void sub_100268C30(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    int v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 80);
      if (v6)
      {
        (*(void (**)(uint64_t))(*(void *)v6 + 56))(v6);
LABEL_9:
        sub_10004D2C8(v5);
        return;
      }
    }
  }
  else
  {
    int v5 = 0;
  }
  uint64_t v7 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No delegate to create assertion", v8, 2u);
  }
  *a2 = 0;
  a2[1] = 0;
  if (v5) {
    goto LABEL_9;
  }
}

void sub_100268D08(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100268D1C(uint64_t a1@<X0>, void *a2@<X8>)
{
}

void sub_100268D24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 80);
      if (v8)
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 144))(v8, a2, a3);
LABEL_12:
        sub_10004D2C8(v7);
        return;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v9 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v11) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No delegate to get provisioning data", (uint8_t *)&v11, 2u);
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v10 = *(void *)(a3 + 24);
  if (!v10) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v10 + 48))(v10, &v11);
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (v7) {
    goto LABEL_12;
  }
}

void sub_100268E48(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100268E74(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    sub_10007B600();
  }
  unsigned int v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

void sub_100268EC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100268ECC(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    int v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 80);
      if (v6)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 160))(v6, a2);
LABEL_12:
        sub_10004D2C8(v5);
        return;
      }
    }
  }
  else
  {
    int v5 = 0;
  }
  uint64_t v7 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v9) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No delegate to get credentials", (uint8_t *)&v9, 2u);
  }
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v8 = *(void *)(a2 + 24);
  if (!v8) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v8 + 48))(v8, &v9);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v5) {
    goto LABEL_12;
  }
}

void sub_100268FE8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100269014(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    sub_10007B600();
  }
  unsigned int v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

void sub_100269064(uint64_t a1, uint64_t a2)
{
}

void sub_10026906C(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    int v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 80);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 168))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100269108(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10026911C(uint64_t a1, uint64_t a2)
{
}

void sub_100269124(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  unsigned int v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 80);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 176))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1002691AC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1002691C0(uint64_t a1)
{
}

void sub_1002691C8(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 80);
      if (v6)
      {
        (*(void (**)(uint64_t))(*(void *)v6 + 184))(v6);
LABEL_9:
        sub_10004D2C8(v5);
        return;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v7 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No delegate to get target data", v8, 2u);
  }
  *a2 = 0;
  a2[1] = 0;
  if (v5) {
    goto LABEL_9;
  }
}

void sub_1002692A0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1002692B4(uint64_t a1@<X0>, void *a2@<X8>)
{
}

void sub_1002692BC(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 80);
      if (v6)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 192))(v6, a2);
LABEL_9:
        sub_10004D2C8(v5);
        return;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v7 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No delegate to get invalidate key", v8, 2u);
  }
  if (v5) {
    goto LABEL_9;
  }
}

void sub_100269390(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1002693A4(uint64_t a1, uint64_t a2)
{
}

void sub_1002693AC(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 80);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 224))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100269448(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10026945C(uint64_t a1, uint64_t a2)
{
}

void sub_100269464(uint64_t a1, CFUUIDRef *a2, char **a3, int a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (!*(_WORD *)(a1 + 416)) {
    return;
  }
  if (*a2) {
    uint64_t v8 = sub_100136254;
  }
  else {
    uint64_t v8 = 0;
  }
  if (!v8)
  {
    uint64_t v31 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Message ID is nullptr", buf, 2u);
    }
    goto LABEL_45;
  }
  uint64_t v9 = *a3;
  if (!*a3)
  {
    unsigned int v32 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Message is nullptr", buf, 2u);
    }
LABEL_45:
    sub_10025DC48(a1);
    return;
  }
  if (a4 == 3)
  {
    uint64_t v10 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      sub_100BC8FAC(a2, v33);
      if (v34 >= 0) {
        uint64_t v30 = v33;
      }
      else {
        uint64_t v30 = (void **)v33[0];
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "kUnknown";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "kLow";
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v36 = v30;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Adjusting client priority from %s to %s for messageId: %s", buf, 0x20u);
      if (SHIBYTE(v34) < 0) {
        operator delete(v33[0]);
      }
      LOBYTE(a4) = 0;
      uint64_t v9 = *a3;
    }
    else
    {
      LOBYTE(a4) = 0;
    }
  }
  int v11 = (**(uint64_t (***)(char *))&v9[*(void *)(*(void *)v9 - 48)])(&v9[*(void *)(*(void *)v9 - 48)]);
  if (v11 == 8) {
    unsigned int v12 = 1;
  }
  else {
    unsigned int v12 = 2 * (v11 == 1);
  }
  uint64_t v13 = &(*a3)[*(void *)(*(void *)*a3 - 48)];
  if ((*(unsigned int (**)(char *))(*(void *)v13 + 8))(v13) == 14)
  {
    uint64_t v14 = *(void **)(a1 + 520);
    if (v14 != (void *)(a1 + 528))
    {
      do
      {
        uint64_t v15 = v14[6] + *(void *)(*(void *)v14[6] - 48);
        int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 8))(v15);
        unsigned int v17 = &(*a3)[*(void *)(*(void *)*a3 - 48)];
        if (v16 == (*(unsigned int (**)(char *))(*(void *)v17 + 8))(v17)) {
          *((unsigned char *)v14 + 125) = 1;
        }
        uint64_t v18 = (void *)v14[1];
        if (v18)
        {
          do
          {
            unsigned __int16 v19 = v18;
            uint64_t v18 = (void *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            unsigned __int16 v19 = (void *)v14[2];
            BOOL v20 = *v19 == (void)v14;
            uint64_t v14 = v19;
          }
          while (!v20);
        }
        uint64_t v14 = v19;
      }
      while (v19 != (void *)(a1 + 528));
    }
  }
  CFUUIDRef v21 = *a2;
  *a2 = 0;
  __int16 v22 = *a3;
  *a3 = 0;
  *(void *)long long buf = v21;
  *(void *)&uint8_t buf[8] = v22;
  uint8_t buf[16] = 0;
  char v37 = 0;
  v40[0] = 0;
  v40[1] = 0;
  uint64_t v38 = 0;
  uint32_t v39 = v40;
  LODWORD(v41) = 0;
  WORD2(v41) = 0;
  *((void *)&v41 + 1) = 0;
  LODWORD(v42) = 0;
  BYTE8(v42) = 0;
  LOBYTE(v43) = 0;
  BYTE8(v43) = 0;
  v44[0] = 0;
  v44[16] = 0;
  v44[24] = v12;
  v44[25] = a4;
  uint64_t v34 = 1;
  uint64_t v23 = (char *)operator new(0xC8uLL);
  long long v24 = v41;
  *(_OWORD *)(v23 + 136) = v42;
  long long v25 = *(_OWORD *)v44;
  *(_OWORD *)(v23 + 152) = v43;
  *(_OWORD *)(v23 + 168) = v25;
  *(_OWORD *)(v23 + 178) = *(_OWORD *)&v44[10];
  uint64_t v26 = (uint64_t **)(a1 + 528);
  v33[0] = v23;
  v33[1] = (void *)(a1 + 528);
  v23[32] = v12;
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  *((void *)v23 + 5) = v21;
  *((void *)v23 + 6) = v22;
  v23[56] = 0;
  v23[80] = 0;
  *((void *)v23 + 14) = 0;
  *((void *)v23 + 13) = 0;
  *((void *)v23 + 11) = 0;
  *((void *)v23 + 12) = v23 + 104;
  *(_OWORD *)(v23 + 120) = v24;
  unint64_t v27 = *(uint64_t **)(a1 + 528);
  if (v27)
  {
    do
    {
      while (1)
      {
        uint64_t v26 = (uint64_t **)v27;
        if (*((unsigned __int8 *)v27 + 32) >= v12) {
          break;
        }
        unint64_t v27 = (uint64_t *)*v27;
        char v28 = v26;
        if (!*v26) {
          goto LABEL_30;
        }
      }
      unint64_t v27 = (uint64_t *)v27[1];
    }
    while (v27);
    char v28 = v26 + 1;
  }
  else
  {
    char v28 = (uint64_t **)(a1 + 528);
  }
LABEL_30:
  sub_100046C38((uint64_t **)(a1 + 520), (uint64_t)v26, v28, (uint64_t *)v23);
  v33[0] = 0;
  sub_10027297C((uint64_t)v33);
  sub_10005D144(v40[0]);
  if (v37 && *(void *)&buf[16])
  {
    uint64_t v36 = *(void ***)&buf[16];
    operator delete(*(void **)&buf[16]);
  }
  uint64_t v29 = *(void *)&buf[8];
  *(void *)&uint8_t buf[8] = 0;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 24))(v29);
  }
  sub_10012577C((const void **)buf);
  sub_10025DC48(a1);
}

void sub_100269950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100262518((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10026996C(uint64_t a1, CFUUIDRef *a2, char **a3, int a4)
{
}

void sub_100269974(uint64_t a1, void *a2, unsigned int a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416))
  {
    if (*a2) {
      uint64_t v6 = sub_100136254;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6)
    {
      if (a3 == 2 || (uint64_t v7 = *(void *)(a1 + 312)) == 0)
      {
        uint64_t v13 = *(void *)(a1 + 144);
        int v16 = 0;
        (*(void (**)(uint64_t, void *, uint64_t, void, const void **, void))(*(void *)v13 + 64))(v13, a2, 1, 0, &v16, 0);
        sub_100057D78(&v16);
      }
      else
      {
        sub_100BDEAE8(v7 + 296, a3);
        BOOL v8 = sub_100BDEA90(*(void *)(a1 + 312));
        uint64_t v9 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = "???";
          if (a3 == 1) {
            uint64_t v10 = "kNotifyAndSendTranscript";
          }
          if (!a3) {
            uint64_t v10 = "kDoNotNotify";
          }
          int v11 = "yes";
          if (!v8) {
            int v11 = "no";
          }
          *(_DWORD *)long long buf = 136315394;
          uint64_t v18 = v10;
          __int16 v19 = 2080;
          BOOL v20 = v11;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Received new notify option: %s, need to sync with backend: %s", buf, 0x16u);
        }
        uint64_t v12 = *(void *)(a1 + 144);
        uint64_t v15 = 0;
        (*(void (**)(uint64_t, void *, uint64_t, uint64_t, const void **, void))(*(void *)v12 + 64))(v12, a2, 1, 1, &v15, 0);
        sub_100057D78(&v15);
        if (v8) {
          sub_10025DC48(a1);
        }
      }
    }
    else
    {
      uint64_t v14 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Message ID is nullptr", buf, 2u);
      }
    }
  }
}

void sub_100269BB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_100269BDC(uint64_t a1, void *a2, unsigned int a3)
{
}

void sub_100269BE4(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416))
  {
    if (*a2) {
      uint64_t v6 = sub_100136254;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6)
    {
      uint64_t v7 = *(char **)(a3 + 8);
      BOOL v8 = v7 != *(char **)a3 && &v7[-*(void *)a3] == (char *)16;
      if (v8 && (uint64_t v9 = *(void *)(a1 + 376)) != 0)
      {
        std::string __p = *(void **)a3;
        BOOL v20 = v7;
        uint64_t v21 = *(void *)(a3 + 16);
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = 0;
        *(void *)(a3 + 16) = 0;
        uint64_t v10 = *(std::__shared_weak_count **)(a1 + 24);
        if (!v10 || (uint64_t v11 = *(void *)(a1 + 16), (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v13 = v12;
        atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        uint64_t v14 = *a2;
        *a2 = 0;
        uint64_t v15 = operator new(0x28uLL);
        *uint64_t v15 = off_1019B1738;
        v15[1] = a1;
        v15[2] = v11;
        void v15[3] = v13;
        v15[4] = v14;
        uint64_t v18 = 0;
        v24[3] = v15;
        sub_1004FC000(v9, (uint64_t *)&__p, (uint64_t)v24);
        sub_100060644(v24);
        sub_10012577C(&v18);
        if (__p)
        {
          BOOL v20 = __p;
          operator delete(__p);
        }
        sub_10025DC48(a1);
      }
      else
      {
        uint64_t v16 = *(void *)(a1 + 144);
        __int16 v22 = 0;
        (*(void (**)(uint64_t, uint64_t *, uint64_t, void, const void **, void))(*(void *)v16 + 64))(v16, a2, 16, 0, &v22, 0);
        sub_100057D78(&v22);
      }
    }
    else
    {
      unsigned int v17 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Message ID is nullptr", buf, 2u);
      }
    }
  }
}

void sub_100269E10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18)
{
}

uint64_t sub_100269E68(uint64_t a1)
{
  sub_10012577C((const void **)(a1 + 24));
  unsigned int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100269EA0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

void sub_100269EA8(uint64_t a1, CFUUIDRef *a2, uint64_t a3, unsigned int a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*a2) {
    BOOL v8 = sub_100136254;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8)
  {
    CFStringRef v17 = CFUUIDCreateString(kCFAllocatorDefault, *a2);
    uint64_t v9 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      memset(v18, 0, sizeof(v18));
      uint64_t v19 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v16 = 0;
      if (a4 > 2) {
        uint64_t v10 = "???";
      }
      else {
        uint64_t v10 = off_1019B1E00[(char)a4];
      }
      uint64_t v11 = (void **)__p[0];
      if (v16 >= 0) {
        uint64_t v11 = __p;
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v21 = v11;
      __int16 v22 = 2080;
      uint64_t v23 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Client acked message (id: %s, transport: %s)", buf, 0x16u);
      if (SHIBYTE(v16) < 0) {
        operator delete(__p[0]);
      }
    }
    if (a4 == 2)
    {
      uint64_t v12 = *(void *)(a1 + 128);
      uint64_t v13 = *(std::__shared_weak_count **)(a1 + 136);
      if (!v13) {
        goto LABEL_17;
      }
    }
    else
    {
      if (a4 != 1)
      {
LABEL_21:
        sub_1000558F4((const void **)&v17);
        return;
      }
      uint64_t v12 = *(void *)(a1 + 112);
      uint64_t v13 = *(std::__shared_weak_count **)(a1 + 120);
      if (!v13)
      {
LABEL_17:
        if (v12) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 40))(v12, a3);
        }
        if (v13) {
          sub_10004D2C8(v13);
        }
        goto LABEL_21;
      }
    }
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_17;
  }
  uint64_t v14 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v18 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Message ID is nullptr", v18, 2u);
  }
}

void sub_10026A0C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_1000558F4(&a12);
  _Unwind_Resume(a1);
}

void sub_10026A100(uint64_t a1, CFUUIDRef *a2, uint64_t a3, unsigned int a4)
{
}

void sub_10026A108(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416))
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    if ((*(_WORD *)(a1 + 416) & 2) == 0)
    {
      unsigned int v2 = *(std::__shared_weak_count **)(a1 + 88);
      if (v2)
      {
        int v3 = std::__shared_weak_count::lock(v2);
        if (v3)
        {
          uint64_t v4 = v3;
          uint64_t v5 = *(void *)(a1 + 80);
          if (v5)
          {
            int v6 = 5;
            char v7 = 0;
            char v8 = 0;
            char v9 = 1;
            (*(void (**)(uint64_t, int *))(*(void *)v5 + 40))(v5, &v6);
          }
          sub_10004D2C8(v4);
        }
      }
    }
  }
}

void sub_10026A1BC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10026A1D0(uint64_t a1)
{
}

void sub_10026A1D8(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(_WORD *)(a1 + 416)) {
    BOOL v4 = a2 == 1;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4 && a2 != 8)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    if ((*(_WORD *)(a1 + 416) & (unsigned __int16)a2) != 0)
    {
      int v6 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = 136315138;
        uint64_t v13 = sub_100BC87FC(a2);
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Data client disconnected for service: %s, but service is active. Posting exit", (uint8_t *)&v12, 0xCu);
      }
      if ((a2 & 0x30) != 0) {
        __int16 v7 = a2 | 0x30;
      }
      else {
        __int16 v7 = a2;
      }
      char v8 = *(std::__shared_weak_count **)(a1 + 88);
      if (v8)
      {
        char v9 = std::__shared_weak_count::lock(v8);
        if (v9)
        {
          uint64_t v10 = v9;
          uint64_t v11 = *(void *)(a1 + 80);
          if (v11)
          {
            int v12 = 5;
            LOWORD(v13) = v7;
            BYTE2(v13) = 1;
            BYTE4(v13) = 1;
            (*(void (**)(uint64_t, int *))(*(void *)v11 + 40))(v11, &v12);
          }
          sub_10004D2C8(v10);
        }
      }
    }
  }
}

void sub_10026A334(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10026A348(uint64_t a1, int a2)
{
}

void sub_10026A350(uint64_t a1, long long *a2)
{
  uint64_t v4 = a1 + 32;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v5 = v4 + 250;
  if (!sub_1005025D0((void *)(v4 + 250), a2))
  {
    if ((*(_WORD *)a2 & 0x3D) != 0)
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
      if (!*(void *)(a1 + 472))
      {
        int v6 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Created GPSSatsVisibilityProvider", buf, 2u);
        }
        __int16 v7 = *(std::__shared_weak_count **)(a1 + 24);
        if (!v7 || (uint64_t v8 = *(void *)(a1 + 16), (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v10 = v9;
        atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        uint64_t v11 = operator new(0x20uLL);
        *uint64_t v11 = off_1019B1008;
        v11[1] = v8;
        v11[2] = v10;
        v11[3] = a1;
        uint64_t v31 = v11;
        sub_10081EEB8((id *)v4, (uint64_t)buf, &v28);
        int v12 = *(std::__shared_weak_count **)(a1 + 480);
        *(_OWORD *)(a1 + 472) = v28;
        if (v12) {
          sub_10004D2C8(v12);
        }
        sub_100060644(buf);
      }
    }
    else
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
      if (*(void *)(a1 + 472))
      {
        uint64_t v13 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Destroyed GPSSatsVisibilityProvider. Resetting visibility to: unknown", buf, 2u);
        }
        uint64_t v14 = *(std::__shared_weak_count **)(a1 + 480);
        *(void *)(a1 + 472) = 0;
        *(void *)(a1 + 480) = 0;
        if (v14) {
          sub_10004D2C8(v14);
        }
        if (*(unsigned char *)(a1 + 465)) {
          *(unsigned char *)(a1 + 465) = 0;
        }
        uint64_t v15 = *(std::__shared_weak_count **)(a1 + 88);
        if (v15)
        {
          uint64_t v16 = std::__shared_weak_count::lock(v15);
          if (v16)
          {
            CFStringRef v17 = v16;
            uint64_t v18 = *(void *)(a1 + 80);
            if (v18)
            {
              *(_WORD *)long long buf = 0;
              (*(void (**)(uint64_t, uint8_t *))(*(void *)v18 + 232))(v18, buf);
            }
            sub_10004D2C8(v17);
          }
        }
      }
    }
    int v19 = *(unsigned __int8 *)(a1 + 302);
    int v20 = *((unsigned __int8 *)a2 + 20);
    if (v19 != v20)
    {
      if (v20 == 1)
      {
        Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 64));
        uint64_t v21 = (***(uint64_t (****)(void))buf)(*(void *)buf);
        if (!*(unsigned char *)(a1 + 632)) {
          *(unsigned char *)(a1 + 632) = 1;
        }
        *(void *)(a1 + 624) = v21;
        if (v30) {
          sub_10004D2C8(v30);
        }
      }
      else if (v19 == 1 && *(unsigned char *)(a1 + 632))
      {
        Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 64));
        uint64_t v22 = (***(uint64_t (****)(void))buf)(*(void *)buf);
        if (!*(unsigned char *)(a1 + 632)) {
          sub_10016C840();
        }
        *(void *)(a1 + 640) += (v22 - *(void *)(a1 + 624)) / 1000000;
        if (!v30 || (sub_10004D2C8(v30), *(unsigned char *)(a1 + 632))) {
          *(unsigned char *)(a1 + 632) = 0;
        }
      }
    }
    (*(void (**)(void, long long *))(**(void **)(a1 + 144) + 8))(*(void *)(a1 + 144), a2);
    long long v23 = *a2;
    *(void *)(v5 + 14) = *(void *)((char *)a2 + 14);
    *(_OWORD *)uint64_t v5 = v23;
    long long v24 = *(std::__shared_weak_count **)(a1 + 88);
    if (v24)
    {
      long long v25 = std::__shared_weak_count::lock(v24);
      if (v25)
      {
        uint64_t v26 = v25;
        uint64_t v27 = *(void *)(a1 + 80);
        if (v27) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v27 + 88))(v27, v5);
        }
        sub_10004D2C8(v26);
      }
    }
  }
}

void sub_10026A714(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10026A770(uint64_t a1, char a2)
{
  uint64_t v4 = a1 + 32;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v5 = *(void *)(v4 + 280);
  if (v5) {
    BOOL v6 = *(unsigned __int8 *)(v5 + 274) == 0;
  }
  else {
    BOOL v6 = 0;
  }
  uint64_t v7 = *(void *)(a1 + 344);
  if (v7) {
    BOOL v8 = *(unsigned __int8 *)(v7 + 274) == 0;
  }
  else {
    BOOL v8 = 0;
  }
  if (!*(unsigned char *)(*(void *)(a1 + 432) + 1) || sub_10025CC8C(a1)) {
    goto LABEL_9;
  }
  if (v6)
  {
    int v12 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Recovered before emergency start was acked. Must exit stewie", buf, 2u);
    }
    sub_10026040C((void *)a1);
    if (!v8)
    {
      __int16 v13 = 1;
LABEL_63:
      char v37 = *(std::__shared_weak_count **)(a1 + 88);
      if (!v37) {
        return;
      }
      uint64_t v38 = std::__shared_weak_count::lock(v37);
      if (!v38) {
        return;
      }
      uint64_t v34 = v38;
      uint64_t v39 = *(void *)(a1 + 80);
      if (v39)
      {
        *(_DWORD *)long long buf = 6;
        *(_WORD *)&uint8_t buf[4] = v13;
        buf[6] = 1;
        uint8_t buf[8] = 0;
        (*(void (**)(uint64_t, unsigned char *))(*(void *)v39 + 40))(v39, buf);
      }
LABEL_67:
      sub_10004D2C8(v34);
      return;
    }
    __int16 v13 = 9;
LABEL_59:
    uint64_t v36 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Recovered before roadside start was acked. Must exit stewie", buf, 2u);
    }
    sub_10026040C((void *)a1);
    goto LABEL_63;
  }
  if (v8)
  {
    __int16 v13 = 8;
    goto LABEL_59;
  }
LABEL_9:
  int v9 = sub_10025C2E0(a1);
  uint64_t v10 = *(unsigned char **)(a1 + 432);
  if (*v10) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = v10[1] != 0;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  __int16 v14 = *(_WORD *)(a1 + 416);
  if ((v14 & 2) != 0) {
    __int16 v15 = 2;
  }
  else {
    __int16 v15 = v9 & 0xFFFD;
  }
  int v16 = (v8 || v6) | sub_10025CC8C(a1);
  if (*(unsigned char *)(a1 + 302) != 2 || !(v16 | !v11))
  {
    sub_10026040C((void *)a1);
    if ((v11 & (v16 ^ 1)) == 1) {
      goto LABEL_34;
    }
LABEL_37:
    int v25 = 0;
    int v23 = 1;
    int v24 = 1;
    goto LABEL_38;
  }
  if (a2) {
    goto LABEL_37;
  }
  if (!*(void *)(a1 + 160))
  {
    CFStringRef v17 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = 10;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Creating handover timer to transition to BB (Expires in %lld seconds)", buf, 0xCu);
    }
    sub_100058DB0(&__p, "StewieHandover");
    Registry::getTimerService(&v50, *(Registry **)(a1 + 64));
    *(void *)long long buf = off_1019B1988;
    *(void *)&uint8_t buf[8] = a1;
    unsigned __int16 v56 = buf;
    AutoStartTimer::create();
    long long v18 = v54;
    long long v54 = 0uLL;
    int v19 = *(std::__shared_weak_count **)(a1 + 168);
    *(_OWORD *)(a1 + 160) = v18;
    if (v19)
    {
      sub_10004D2C8(v19);
      if (*((void *)&v54 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v54 + 1));
      }
    }
    sub_10003B34C(buf);
    if (v51) {
      sub_10004D2C8(v51);
    }
    if (v53 < 0) {
      operator delete(__p);
    }
  }
LABEL_34:
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  __int16 v20 = *(_WORD *)(a1 + 416);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  __int16 v21 = *(_WORD *)(a1 + 416);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  int v22 = v21 & 0x20 | v20 & 4;
  if ((*(_WORD *)(a1 + 416) & 0x10) != 0)
  {
    LOWORD(v22) = v22 | 0x10;
LABEL_53:
    unsigned int v32 = *(std::__shared_weak_count **)(a1 + 88);
    if (!v32) {
      return;
    }
    size_t v33 = std::__shared_weak_count::lock(v32);
    if (!v33) {
      return;
    }
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)(a1 + 80);
    if (v35)
    {
      *(_DWORD *)long long buf = 15;
      *(_WORD *)&uint8_t buf[4] = v22;
      buf[6] = 1;
      uint8_t buf[8] = 0;
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v35 + 40))(v35, buf);
    }
    goto LABEL_67;
  }
  if (v22) {
    goto LABEL_53;
  }
  int v23 = 0;
  int v24 = 2;
  int v25 = 1;
LABEL_38:
  int v26 = *(unsigned __int8 *)(a1 + 302);
  if (v26 != v24)
  {
    uint64_t v27 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      long long v28 = "???";
      uint64_t v29 = "kBB";
      if (!v23) {
        uint64_t v29 = "???";
      }
      if (v25) {
        uint64_t v29 = "kInternet";
      }
      if ((char)v26 <= 2) {
        long long v28 = off_1019B1E00[(char)v26];
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v29;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v28;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Time to switch transport to %s from %s", buf, 0x16u);
    }
    uint64_t v30 = *(void *)(a1 + 112);
    uint64_t v31 = *(std::__shared_weak_count **)(a1 + 120);
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v30)
    {
      if (v23)
      {
        (*(void (**)(uint64_t, unint64_t, void, void))(*(void *)v30 + 16))(v30, *(unsigned int *)(a1 + 456) | (unint64_t)&_mh_execute_header, *(unsigned __int16 *)(a1 + 416), *(unsigned int *)(a1 + 460));
      }
      else
      {
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v30 + 24))(v30, 0x100000009, *(unsigned __int16 *)(a1 + 416));
        sub_100272768((uint64_t **)(a1 + 488), 1u);
        if (*(unsigned char *)(a1 + 776))
        {
          uint64_t v40 = *(void **)(a1 + 752);
          if (v40)
          {
            *(void *)(a1 + 760) = v40;
            operator delete(v40);
          }
          *(unsigned char *)(a1 + 776) = 0;
        }
        long long v41 = *(uint64_t ***)(a1 + 520);
        if (v41 != (uint64_t **)(a1 + 528))
        {
          do
          {
            sub_100272768(v41 + 12, 1u);
            long long v42 = v41[1];
            if (v42)
            {
              do
              {
                long long v43 = (uint64_t **)v42;
                long long v42 = (uint64_t *)*v42;
              }
              while (v42);
            }
            else
            {
              do
              {
                long long v43 = (uint64_t **)v41[2];
                BOOL v44 = *v43 == (uint64_t *)v41;
                long long v41 = v43;
              }
              while (!v44);
            }
            long long v41 = v43;
          }
          while (v43 != (uint64_t **)(a1 + 528));
        }
      }
    }
    if (v31) {
      sub_10004D2C8(v31);
    }
  }
  char v45 = 3;
  if (v23)
  {
    if (*(unsigned char *)(a1 + 512)) {
      char v45 = 4;
    }
    else {
      char v45 = 3;
    }
  }
  *(_WORD *)&buf[20] = 0;
  *(_WORD *)long long buf = v15;
  int v46 = *(unsigned __int16 *)(a1 + 416);
  *(_WORD *)&buf[2] = *(_WORD *)(a1 + 416);
  *(_WORD *)&uint8_t buf[4] = *(_WORD *)(a1 + 420);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (_os_feature_enabled_impl()) {
    __int16 v47 = *(_WORD *)(a1 + 422);
  }
  else {
    __int16 v47 = 61;
  }
  *(_WORD *)&buf[6] = v47;
  *(_WORD *)&uint8_t buf[8] = sub_10025C21C(a1, *(_DWORD *)(a1 + 800));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  *(_WORD *)&buf[10] = *(_WORD *)(a1 + 418) | *(_WORD *)(a1 + 416);
  *(_WORD *)&unsigned char buf[12] = ((__int16)(v14 << 14) >> 15) & HIWORD(v9);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 427)) {
    __int16 v48 = 3;
  }
  else {
    __int16 v48 = 2;
  }
  if (*(unsigned char *)(a1 + 426)) {
    v48 |= 0x3Cu;
  }
  *(_WORD *)&buf[14] = v48;
  *(_WORD *)&uint8_t buf[16] = *(_WORD *)(a1 + 424);
  buf[18] = v45;
  buf[19] = 0;
  buf[20] = v24;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 744) && *(unsigned char *)(a1 + 429) == 2 || (v25 & 1) != 0)
  {
    BOOL v49 = 0;
  }
  else if (v46)
  {
    BOOL v49 = 1;
  }
  else
  {
    BOOL v49 = (v15 & 0x3D) != 0;
  }
  buf[21] = v49;
  sub_10026A350(a1, (long long *)buf);
}

void sub_10026AE80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  if (v20) {
    sub_10004D2C8(v20);
  }
  _Unwind_Resume(exception_object);
}

void sub_10026AEE4(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (!*a2) {
    __TUAssertTrigger();
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if ((*(_WORD *)(a1 + 416) & 8) == 0)
  {
    BOOL v6 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24.__r_.__value_.__l.__data_) = 0;
      uint64_t v7 = "Roadside is not requested";
LABEL_34:
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&v24, 2u);
      goto LABEL_22;
    }
    goto LABEL_22;
  }
  uint64_t v8 = *(void *)(a1 + 344);
  if (!v8)
  {
    BOOL v6 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24.__r_.__value_.__l.__data_) = 0;
      uint64_t v7 = "Roadside environment does not exist";
      goto LABEL_34;
    }
LABEL_22:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  int v9 = *(unsigned __int8 *)(v8 + 272);
  char v10 = *(unsigned char *)(v8 + 104);
  int v22 = sub_101117E48(v8);
  uint64_t v23 = v11;
  int v12 = *(NSObject **)(a1 + 48);
  if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_16;
  }
  sub_10026B270(*a2, &v24);
  int v13 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
  std::string::size_type v14 = v24.__r_.__value_.__r.__words[0];
  sub_10026B270((uint64_t)&v22, &__p);
  __int16 v15 = &v24;
  if (v13 < 0) {
    __int16 v15 = (std::string *)v14;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  *(_DWORD *)long long buf = 136446466;
  int v26 = v15;
  __int16 v27 = 2080;
  long long v28 = p_p;
  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I User selected providerId: %{public}s, resumable provider ID: %s", buf, 0x16u);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v24.__r_.__value_.__l.__data_);
    if (!v9) {
      goto LABEL_28;
    }
  }
  else
  {
LABEL_16:
    if (!v9) {
      goto LABEL_28;
    }
  }
  if (*(unsigned char *)(*a2 + 8) && (_BYTE)v23)
  {
    if (*(const void **)*a2 != v22) {
      goto LABEL_28;
    }
LABEL_24:
    CFStringRef v17 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v24.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Marking location update as due for roadside provider as user selected resumable providerID", (uint8_t *)&v24, 2u);
    }
    *(unsigned char *)(*(void *)(a1 + 344) + 275) = 1;
    sub_10025DC48(a1);
    *(std::string::size_type *)((char *)v24.__r_.__value_.__r.__words + 6) = (std::string::size_type)v22;
    v24.__r_.__value_.__s.__data_[14] = v23;
    long long v18 = operator new(0x30uLL);
    v18[1] = 0;
    _OWORD v18[2] = 0;
    void *v18 = off_1019B1B08;
    *((unsigned char *)v18 + 24) = v10;
    *((unsigned char *)v18 + 25) = v9;
    *(void *)((char *)v18 + 26) = v24.__r_.__value_.__r.__words[0];
    *(void *)((char *)v18 + 33) = *(std::string::size_type *)((char *)v24.__r_.__value_.__r.__words + 7);
    *a3 = v18 + 3;
    goto LABEL_31;
  }
  if ((*(unsigned char *)(*a2 + 8) != 0) == (v23 != 0)) {
    goto LABEL_24;
  }
LABEL_28:
  int v19 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v24.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Resume is not possible OR User didn't select a resumable provider ID", (uint8_t *)&v24, 2u);
  }
  char v20 = *(unsigned char *)(*(void *)(a1 + 344) + 104);
  long long v18 = operator new(0x30uLL);
  v18[1] = 0;
  _OWORD v18[2] = 0;
  *((unsigned char *)v18 + 24) = v20 + 1;
  void *v18 = off_1019B1B08;
  *((unsigned char *)v18 + 25) = 0;
  *((unsigned char *)v18 + 32) = 0;
  *((unsigned char *)v18 + 40) = 0;
  *a3 = v18 + 3;
LABEL_31:
  a3[1] = v18;
}

void sub_10026B24C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_10026B270@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 8)) {
    return std::to_string(a2, *(void *)a1);
  }
  else {
    return (std::string *)sub_100058DB0(a2, "<none>");
  }
}

void sub_10026B290(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if ((*(_WORD *)(a1 + 416) & 8) != 0)
  {
    uint64_t v7 = *(void *)(a1 + 344);
    if (v7)
    {
      uint64_t v8 = *(void *)(v7 + 104);
      char v9 = *(unsigned char *)(v7 + 272);
      char v10 = sub_101117E48(v7);
      char v12 = v11;
      int v13 = operator new(0x30uLL);
      v13[1] = 0;
      v13[2] = 0;
      *int v13 = off_1019B1B08;
      *((unsigned char *)v13 + 25) = v9;
      v13[4] = v10;
      *((unsigned char *)v13 + 40) = v12;
      a2[1] = v13;
      *((unsigned char *)v13 + 24) = v8;
      *a2 = v13 + 3;
      return;
    }
    uint64_t v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      __int16 v14 = 0;
      uint64_t v5 = "Roadside environment does not exist";
      BOOL v6 = (uint8_t *)&v14;
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      __int16 v15 = 0;
      uint64_t v5 = "Roadside is not requested";
      BOOL v6 = (uint8_t *)&v15;
LABEL_10:
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, v5, v6, 2u);
    }
  }
  *a2 = 0;
  a2[1] = 0;
}

uint64_t sub_10026B3B8(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  unsigned int v2 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ******************************", (uint8_t *)&buf, 2u);
    unsigned int v2 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * StewieDataController state *", (uint8_t *)&buf, 2u);
    unsigned int v2 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ******************************", (uint8_t *)&buf, 2u);
  }
  int v3 = *(AutoStartTimer **)(a1 + 160);
  if (v3)
  {
    if ((AutoStartTimer::isExpired(v3) & 1) == 0)
    {
      uint64_t v4 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [d] Handover timer is running", (uint8_t *)&buf, 2u);
      }
    }
  }
  uint64_t v5 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (_os_feature_enabled_impl())
    {
      unint64_t v6 = *(char *)(a1 + 408);
      if (v6 > 3) {
        uint64_t v7 = "???";
      }
      else {
        uint64_t v7 = off_1019B1CD0[v6];
      }
    }
    else
    {
      uint64_t v7 = "kNotSupported";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [d] Compression Manager State: %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v8 = *(void *)(a1 + 312);
  if (v8)
  {
    sub_100BDF768(v8);
    char v9 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      char v10 = *(std::__shared_weak_count **)(a1 + 320);
      buf.__r_.__value_.__r.__words[0] = *(void *)(a1 + 312);
      buf.__r_.__value_.__l.__size_ = (std::string::size_type)v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unsigned int v11 = sub_1004D0838(a1 + 304, (uint64_t *)&buf);
      if (v11 > 3) {
        char v12 = "???";
      }
      else {
        char v12 = off_1019B1CD0[(char)v11];
      }
      LODWORD(v135.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v135.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [d] (Em Env) Compression Support: %s", (uint8_t *)&v135, 0xCu);
      if (v10) {
        sub_10004D2C8(v10);
      }
    }
  }
  int v13 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 453)) {
      __int16 v14 = "true";
    }
    else {
      __int16 v14 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [d] HasActiveRoadsideProviders: %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v15 = *(void *)(a1 + 344);
  if (v15)
  {
    sub_101117FEC(v15);
    int v16 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v17 = *(std::__shared_weak_count **)(a1 + 352);
      buf.__r_.__value_.__r.__words[0] = *(void *)(a1 + 344);
      buf.__r_.__value_.__l.__size_ = (std::string::size_type)v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unsigned int v18 = sub_1004D0838(a1 + 304, (uint64_t *)&buf);
      if (v18 > 3) {
        int v19 = "???";
      }
      else {
        int v19 = off_1019B1CD0[(char)v18];
      }
      LODWORD(v135.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v135.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [d] (Rs Env) Compression Support: %s", (uint8_t *)&v135, 0xCu);
      if (v17) {
        sub_10004D2C8(v17);
      }
    }
  }
  char v20 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = *(int *)(a1 + 800);
    if (v21 > 5) {
      int v22 = "???";
    }
    else {
      int v22 = off_1019B1CF0[v21];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v22;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [d] Cached congestion status: %s", (uint8_t *)&buf, 0xCu);
    char v20 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 784)) {
      uint64_t v23 = "true";
    }
    else {
      uint64_t v23 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [d] Has cached location: %s", (uint8_t *)&buf, 0xCu);
    char v20 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 776)) {
      std::string v24 = "true";
    }
    else {
      std::string v24 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v24;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [d] Has cached gen app key: %s", (uint8_t *)&buf, 0xCu);
    char v20 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 826))
    {
      if (*(unsigned char *)(a1 + 825)) {
        int v25 = "true";
      }
      else {
        int v25 = "false";
      }
    }
    else
    {
      int v25 = "Unknown";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [d] Codec assets are in use: %s", (uint8_t *)&buf, 0xCu);
    char v20 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 826))
    {
      if (*(unsigned char *)(a1 + 825)) {
        int v26 = "true";
      }
      else {
        int v26 = "false";
      }
    }
    else
    {
      int v26 = "Unknown";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v26;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [d] SatSmsConfig in use: %s", (uint8_t *)&buf, 0xCu);
    char v20 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 829)) {
      __int16 v27 = "true";
    }
    else {
      __int16 v27 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [d] SatSMS provisioned: %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v28 = *(void *)(a1 + 376);
  if (v28) {
    sub_1004FC2D8(v28);
  }
  uint64_t v29 = *(void *)(a1 + 392);
  uint64_t v30 = *(std::__shared_weak_count **)(a1 + 400);
  if (v30) {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v29) {
    sub_1006C0764(v29);
  }
  if (v30) {
    sub_10004D2C8(v30);
  }
  uint64_t v31 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    int v32 = *(unsigned __int16 *)(a1 + 416);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 416), &buf);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string buf = &buf;
    }
    else {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v135.__r_.__value_.__l.__data_) = 67109378;
    HIDWORD(v135.__r_.__value_.__r.__words[0]) = v32;
    LOWORD(v135.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v135.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)p_buf;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [d] Active services: { [Mask: %hu] %s }", (uint8_t *)&v135, 0x12u);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    uint64_t v31 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    int v34 = *(unsigned __int16 *)(a1 + 804);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 804), &buf);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v35 = &buf;
    }
    else {
      uint64_t v35 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v135.__r_.__value_.__l.__data_) = 67109378;
    HIDWORD(v135.__r_.__value_.__r.__words[0]) = v34;
    LOWORD(v135.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v135.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v35;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [d] Shutting down services: { [Mask: %hu] %s }", (uint8_t *)&v135, 0x12u);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    uint64_t v31 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v36 = *(int *)(a1 + 456);
    if (v36 > 0xA) {
      char v37 = "???";
    }
    else {
      char v37 = off_1019B1D20[v36];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v37;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [d] Requested reason: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v31 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v38 = *(int *)(a1 + 460);
    if (v38 > 3) {
      uint64_t v39 = "???";
    }
    else {
      uint64_t v39 = off_1019B1D78[v38];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v39;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [d] SPS environment: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v31 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v40 = *(int *)(a1 + 448);
    if (v40 > 3) {
      long long v41 = "???";
    }
    else {
      long long v41 = off_1019B1E90[v40];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v41;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [d] Location auth status: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v31 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 452)) {
      long long v42 = "true";
    }
    else {
      long long v42 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v42;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [d] Location popup invoked: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v31 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v43 = sub_10110D174((void **)(a1 + 832));
    BOOL v44 = "false";
    if (v43) {
      BOOL v44 = "true";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v44;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [d] Device has non bootstrap SIM: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v31 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 428)) {
      char v45 = "true";
    }
    else {
      char v45 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v45;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [d] Allow Emergency use cases in limited service: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v31 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 465))
    {
      if (*(unsigned char *)(a1 + 464)) {
        int v46 = "true";
      }
      else {
        int v46 = "false";
      }
    }
    else
    {
      int v46 = "<none>";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v46;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [d] Are GPS Satellites visible: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v31 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    int v47 = sub_10025B63C(a1 + 1096, 0);
    __int16 v48 = "kDisabled";
    if (v47 == 1) {
      __int16 v48 = "kEnabled";
    }
    if (v47 == 2) {
      __int16 v48 = "kUnknown";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v48;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I [d] Ignore GPS satellite visibility: %s", (uint8_t *)&buf, 0xCu);
  }
  BOOL v49 = *(void **)(a1 + 488);
  if (v49 != (void *)(a1 + 496))
  {
    do
    {
      uint64_t v50 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v51 = *((char *)v49 + 25);
        uint64_t v52 = "???";
        if (v51 <= 2) {
          uint64_t v52 = off_1019B1E00[v51];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v52;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I [d] %s is available", (uint8_t *)&buf, 0xCu);
      }
      char v53 = (void *)v49[1];
      if (v53)
      {
        do
        {
          long long v54 = v53;
          char v53 = (void *)*v53;
        }
        while (v53);
      }
      else
      {
        do
        {
          long long v54 = (void *)v49[2];
          BOOL v55 = *v54 == (void)v49;
          BOOL v49 = v54;
        }
        while (!v55);
      }
      BOOL v49 = v54;
    }
    while (v54 != (void *)(a1 + 496));
  }
  unsigned __int16 v56 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 512)) {
      uint64_t v57 = "true";
    }
    else {
      uint64_t v57 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v57;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I [d] Is BB suspended: %s", (uint8_t *)&buf, 0xCu);
    unsigned __int16 v56 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    int v58 = _os_feature_enabled_impl();
    unsigned __int16 v59 = "not ";
    if (v58) {
      unsigned __int16 v59 = "";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v59;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I [d] Advanced congestion control: %ssupported", (uint8_t *)&buf, 0xCu);
    unsigned __int16 v56 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v60 = *(void *)(a1 + 536);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v60;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I [d] Num outgoing messages: %lu", (uint8_t *)&buf, 0xCu);
    unsigned __int16 v56 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v61 = "true";
    if (*(unsigned char *)(a1 + 427)) {
      unsigned __int16 v62 = "true";
    }
    else {
      unsigned __int16 v62 = "false";
    }
    if (!*(void *)(a1 + 192)) {
      unsigned int v61 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v62;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v61;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I [d] Allow Emergency use cases: %s, Settling timer running: %s", (uint8_t *)&buf, 0x16u);
    unsigned __int16 v56 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v63 = "true";
    if (*(unsigned char *)(a1 + 426)) {
      int v64 = "true";
    }
    else {
      int v64 = "false";
    }
    if (!*(void *)(a1 + 176)) {
      unsigned int v63 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v64;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v63;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I [d] Allow Non Emergency use cases: %s, Settling timer running: %s", (uint8_t *)&buf, 0x16u);
    unsigned __int16 v56 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    int v65 = *(unsigned __int16 *)(a1 + 282);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 282), &v135);
    if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v66 = &v135;
    }
    else {
      int v66 = (std::string *)v135.__r_.__value_.__r.__words[0];
    }
    int v67 = *(unsigned __int16 *)(a1 + 284);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 284), &v134);
    if ((v134.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v68 = &v134;
    }
    else {
      char v68 = (std::string *)v134.__r_.__value_.__r.__words[0];
    }
    int v69 = *(unsigned __int16 *)(a1 + 290);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 290), &v133);
    if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string v70 = &v133;
    }
    else {
      std::string v70 = (std::string *)v133.__r_.__value_.__r.__words[0];
    }
    uint32_t v128 = v70;
    int v71 = *(unsigned __int16 *)(a1 + 292);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 292), &v132);
    v126 = v68;
    std::string::size_type v127 = (std::string::size_type)v66;
    if ((v132.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v72 = &v132;
    }
    else {
      std::string::size_type v72 = (std::string *)v132.__r_.__value_.__r.__words[0];
    }
    long long v125 = v72;
    int v73 = *(unsigned __int16 *)(a1 + 294);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 294), &v131);
    if ((v131.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v74 = &v131;
    }
    else {
      uint64_t v74 = (std::string *)v131.__r_.__value_.__r.__words[0];
    }
    long long v124 = v74;
    int v75 = *(unsigned __int16 *)(a1 + 296);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 296), &v130);
    if ((v130.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v76 = &v130;
    }
    else {
      char v76 = (std::string *)v130.__r_.__value_.__r.__words[0];
    }
    int v123 = v76;
    int v77 = *(unsigned __int16 *)(a1 + 298);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 298), &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    unint64_t v79 = *(char *)(a1 + 300);
    if (v79 > 4) {
      int v80 = "???";
    }
    else {
      int v80 = off_1019B1D98[v79];
    }
    unint64_t v81 = *(char *)(a1 + 301);
    if (v81 > 7) {
      uint64_t v82 = "???";
    }
    else {
      uint64_t v82 = off_1019B1DC0[v81];
    }
    unint64_t v83 = *(char *)(a1 + 302);
    if (v83 > 2) {
      uint64_t v84 = "???";
    }
    else {
      uint64_t v84 = off_1019B1E00[v83];
    }
    int v85 = *(unsigned __int8 *)(a1 + 303);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67113474;
    if (v85) {
      uint64_t v86 = "true";
    }
    else {
      uint64_t v86 = "false";
    }
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v65;
    LOWORD(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v127;
    WORD1(buf.__r_.__value_.__r.__words[2]) = 1024;
    HIDWORD(buf.__r_.__value_.__r.__words[2]) = v67;
    *(_WORD *)uint64_t v137 = 2080;
    *(void *)&v137[2] = v126;
    *(_WORD *)char v138 = 1024;
    *(_DWORD *)&v138[2] = v69;
    *(_WORD *)&v138[6] = 2080;
    *(void *)&v138[8] = v128;
    *(_WORD *)&v138[16] = 1024;
    *(_DWORD *)uint64_t v139 = v71;
    *(_WORD *)&unsigned int v139[4] = 2080;
    *(void *)&v139[6] = v125;
    __int16 v140 = 1024;
    int v141 = v73;
    __int16 v142 = 2080;
    uint64_t v143 = v124;
    __int16 v144 = 1024;
    int v145 = v75;
    __int16 v146 = 2080;
    uint64_t v147 = v123;
    __int16 v148 = 1024;
    int v149 = v77;
    __int16 v150 = 2080;
    uint64_t v151 = p_p;
    __int16 v152 = 2080;
    v153 = v80;
    __int16 v154 = 2080;
    v155 = v82;
    __int16 v156 = 2080;
    v157 = v84;
    __int16 v158 = 2080;
    uint64_t v159 = v86;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I [d] [Stewie State] Allowed services: { [Mask: %hu] %s }, Active services: { [Mask: %hu] %s }, Congested services: { [Mask: %hu] %s }, Data path asserted services: { [Mask: %hu] %s }, Demo allowed services: { [Mask: %hu] %s }, Off grid criteria satisfied services: { [Mask: %hu] %s }, Configured for location services: { [Mask: %hu] %s }, Status: %s, Base Reason: %s, Transport: %s, display satellite icon: %s", (uint8_t *)&buf, 0x9Au);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v130.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v130.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v131.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v131.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v132.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v133.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v134.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v134.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v135.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v135.__r_.__value_.__l.__data_);
    }
    unsigned __int16 v56 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    int v87 = *(unsigned __int16 *)(a1 + 418);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 418), &buf);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned __int8 v88 = &buf;
    }
    else {
      unsigned __int8 v88 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v135.__r_.__value_.__l.__data_) = 67109378;
    HIDWORD(v135.__r_.__value_.__r.__words[0]) = v87;
    LOWORD(v135.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v135.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v88;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I [d] Force enable data path for services: { [Mask: %hu] %s }", (uint8_t *)&v135, 0x12u);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    unsigned __int16 v56 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    int v89 = *(unsigned __int16 *)(a1 + 420);
    sub_100BC897C(*(unsigned __int16 *)(a1 + 420), &v135);
    if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v90 = &v135;
    }
    else {
      uint64_t v90 = (std::string *)v135.__r_.__value_.__r.__words[0];
    }
    int v91 = *(unsigned __int16 *)(a1 + 422);
    unsigned int v92 = &v134;
    sub_100BC897C(*(unsigned __int16 *)(a1 + 422), &v134);
    if ((v134.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      unsigned int v92 = (std::string *)v134.__r_.__value_.__r.__words[0];
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
    int v93 = _os_feature_enabled_impl();
    unsigned int v94 = "true";
    LODWORD(buf.__r_.__value_.__l.__data_) = 67110146;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v89;
    LOWORD(buf.__r_.__value_.__r.__words[1]) = 2080;
    if (v93) {
      unsigned int v94 = "false";
    }
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v90;
    WORD1(buf.__r_.__value_.__r.__words[2]) = 1024;
    HIDWORD(buf.__r_.__value_.__r.__words[2]) = v91;
    *(_WORD *)uint64_t v137 = 2080;
    *(void *)&v137[2] = v92;
    *(_WORD *)char v138 = 2080;
    *(void *)&v138[2] = v94;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I [d] Subscription determined for services: { [Mask: %hu] %s }, Subscribed services: { [Mask: %hu] %s }, IgnoreSubscriptionStatus: %s", (uint8_t *)&buf, 0x2Cu);
    if (SHIBYTE(v134.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v134.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v135.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v135.__r_.__value_.__l.__data_);
    }
    unsigned __int16 v56 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 224)) {
      unsigned __int16 v95 = "true";
    }
    else {
      unsigned __int16 v95 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v95;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I [d] Is Emergency call active: %s (Note: Non em scenarios are disallowed during emergency call)", (uint8_t *)&buf, 0xCu);
  }
  if (*(unsigned char *)(a1 + 226))
  {
    unsigned int v96 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 225)) {
        uint64_t v97 = "true";
      }
      else {
        uint64_t v97 = "false";
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v97;
      _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "#I [d] Emergency Call dialed when device was in service: %s", (uint8_t *)&buf, 0xCu);
    }
  }
  uint64_t v98 = *(void **)(a1 + 864);
  if (v98 != (void *)(a1 + 872))
  {
    do
    {
      uint64_t v99 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v100 = sub_100BC87FC(*((unsigned __int16 *)v98 + 16));
        std::string::size_type v101 = v98[5];
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v100;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v101;
        _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "#I [d] ForceEnableDataPathAssertion for service: %s, [count: %llu]", (uint8_t *)&buf, 0x16u);
      }
      unsigned __int16 v102 = (void *)v98[1];
      if (v102)
      {
        do
        {
          unsigned int v103 = v102;
          unsigned __int16 v102 = (void *)*v102;
        }
        while (v102);
      }
      else
      {
        do
        {
          unsigned int v103 = (void *)v98[2];
          BOOL v55 = *v103 == (void)v98;
          uint64_t v98 = v103;
        }
        while (!v55);
      }
      uint64_t v98 = v103;
    }
    while (v103 != (void *)(a1 + 872));
  }
  unsigned int v104 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
  {
    if (_os_feature_enabled_impl()) {
      unsigned int v105 = "[Cloud] ";
    }
    else {
      unsigned int v105 = "";
    }
    if (_os_feature_enabled_impl()) {
      unsigned int v106 = "[Auto] ";
    }
    else {
      unsigned int v106 = "";
    }
    if (_os_feature_enabled_impl()) {
      uint64_t v107 = "[Comp] ";
    }
    else {
      uint64_t v107 = "";
    }
    if (_os_feature_enabled_impl()) {
      __int16 v108 = "[TryOut] ";
    }
    else {
      __int16 v108 = "";
    }
    if (sub_10025B63C(a1 + 680, 0) == 1) {
      unsigned int v109 = "[LPM] ";
    }
    else {
      unsigned int v109 = "";
    }
    int v110 = _os_feature_enabled_impl();
    __int16 v111 = "[FindMy] ";
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316418;
    if (!v110) {
      __int16 v111 = "";
    }
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v105;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v106;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    *(void *)uint64_t v137 = v107;
    *(_WORD *)&v137[8] = 2080;
    *(void *)char v138 = v108;
    *(_WORD *)&v138[8] = 2080;
    *(void *)&v138[10] = v109;
    *(_WORD *)uint64_t v139 = 2080;
    *(void *)&v139[2] = v111;
    _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I [d] Enabled features: %s%s%s%s%s%s", (uint8_t *)&buf, 0x3Eu);
    unsigned int v104 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
  {
    sub_10026CCB8((unsigned __int8 *)(a1 + 920), &buf);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v112 = &buf;
    }
    else {
      unsigned int v112 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v135.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v135.__r_.__value_.__r.__words + 4) = (std::string::size_type)v112;
    _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I [d] Is iMessage signed in: %s", (uint8_t *)&v135, 0xCu);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    unsigned int v104 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
  {
    int v113 = sub_10025B63C(a1 + 1000, 0);
    __int16 v114 = "kDisabled";
    if (v113 == 1) {
      __int16 v114 = "kEnabled";
    }
    if (v113 == 2) {
      __int16 v114 = "kUnknown";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v114;
    _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I [d] Ignore cellular service state switch state: %s", (uint8_t *)&buf, 0xCu);
    unsigned int v104 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC897C(*(unsigned __int16 *)(a1 + 992), &buf);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v115 = &buf;
    }
    else {
      uint64_t v115 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v135.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v135.__r_.__value_.__r.__words + 4) = (std::string::size_type)v115;
    _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I [d] Blocked services based on installed apps: %{public}s", (uint8_t *)&v135, 0xCu);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    unsigned int v104 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
  {
    int v116 = sub_10025B63C(a1 + 1128, 0);
    __int16 v117 = "kDisabled";
    if (v116 == 1) {
      __int16 v117 = "kEnabled";
    }
    if (v116 == 2) {
      __int16 v117 = "kUnknown";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v117;
    _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I [d] Force new Em conversation in next attempt: %s", (uint8_t *)&buf, 0xCu);
    unsigned int v104 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
  {
    int v118 = sub_10025B63C(a1 + 1160, 0);
    int v119 = "kDisabled";
    if (v118 == 1) {
      int v119 = "kEnabled";
    }
    if (v118 == 2) {
      int v119 = "kUnknown";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v119;
    _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I [d] Force new Rs conversation in next attempt: %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v120 = *(void *)(a1 + 144);
  if (v120) {
    (*(void (**)(uint64_t))(*(void *)v120 + 72))(v120);
  }
  uint64_t v121 = *(void *)(a1 + 112);
  if (v121) {
    (*(void (**)(uint64_t))(*(void *)v121 + 48))(v121);
  }
  uint64_t result = *(void *)(a1 + 128);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result);
  }
  return result;
}

void sub_10026CBEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (v55) {
    sub_10004D2C8(v55);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_10026CCB8@<X0>(unsigned __int8 *a1@<X0>, std::string *a2@<X8>)
{
  if (a1[1]) {
    return std::to_string(a2, *a1);
  }
  else {
    return (std::string *)sub_100058DB0(a2, "<none>");
  }
}

void sub_10026CCDC(uint64_t a1)
{
  sub_10026EA6C(a1);

  operator delete();
}

uint64_t sub_10026CD14(uint64_t a1)
{
  return sub_10026EA6C(a1 - 8);
}

void sub_10026CD1C(uint64_t a1)
{
  sub_10026EA6C(a1 - 8);

  operator delete();
}

uint64_t sub_10026CD58(uint64_t a1)
{
  return sub_10026EA6C(a1 - 56);
}

void sub_10026CD60(uint64_t a1)
{
  sub_10026EA6C(a1 - 56);

  operator delete();
}

void sub_10026CD9C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 8);
    *(void *)(a2 + 8) = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
    }
    operator delete();
  }
}

uint64_t sub_10026CE18(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    sub_10005CD2C(a1 + 24, *(char **)(a1 + 32));
    sub_10026CE58(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_10026CE58(void *a1)
{
  if (a1)
  {
    sub_10026CE58(*a1);
    sub_10026CE58(a1[1]);
    sub_10026CEAC((void *)a1[6]);
    operator delete(a1);
  }
}

void sub_10026CEAC(void *a1)
{
  if (a1)
  {
    sub_10026CEAC(*a1);
    sub_10026CEAC(a1[1]);
    sub_10026CF00((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_10026CF00(uint64_t a1)
{
  sub_10026CF54(a1 + 32, *(void **)(a1 + 40));
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_10026CF54(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10026CF54(a1, *a2);
    sub_10026CF54(a1, a2[1]);
    uint64_t v4 = (void *)a2[5];
    if (v4)
    {
      a2[6] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

void sub_10026CFB8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B08C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10026CFD8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B08C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10026D02C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (void *)a1[7];
  if (v3)
  {
    a1[8] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (char *)a1[5];

  sub_10026D080(v4);
}

void sub_10026D080(char *a1)
{
  if (a1)
  {
    sub_10026D080(*(void *)a1);
    sub_10026D080(*((void *)a1 + 1));
    if (a1[63] < 0) {
      operator delete(*((void **)a1 + 5));
    }
    operator delete(a1);
  }
}

void sub_10026D0E0()
{
}

__n128 sub_10026D0F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019B0918;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10026D148(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B0918;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10026D180(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = **(unsigned int **)(a1 + 24);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 32));
  if ((*(_WORD *)(v3 + 416) & (unsigned __int16)v2) != 0) {
    return;
  }
  unint64_t v6 = (_OWORD *)(v3 + 328);
  if (!*(void *)(v3 + 808))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 64));
    uint64_t v8 = ServiceMap;
    if (v9 < 0)
    {
      char v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v9;
    int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
    if (v13)
    {
      uint64_t v15 = v13[3];
      __int16 v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
        if (!v15)
        {
LABEL_15:
          if ((v16 & 1) == 0) {
            sub_10004D2C8(v14);
          }
          goto LABEL_17;
        }
LABEL_12:
        (*(void (**)(uint8_t *__return_ptr, uint64_t, const char *, void))(*(void *)v15 + 8))(buf, v15, "Stewie Session", 0);
        long long v17 = *(_OWORD *)buf;
        memset(buf, 0, sizeof(buf));
        unsigned int v18 = *(std::__shared_weak_count **)(v3 + 816);
        *(_OWORD *)(v3 + 808) = v17;
        if (v18)
        {
          sub_10004D2C8(v18);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
        }
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    __int16 v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
LABEL_17:
  *(_WORD *)(v3 + 416) |= v2;
  *(_WORD *)(v3 + 616) |= v2;
  sub_10025C848(v3);
  if (sub_10025B63C(v3 + 680, 0) == 1)
  {
    unsigned int v19 = (unsigned __int16)sub_100A72B1C();
    if (v19 <= 0x100) {
      LOBYTE(v19) = 0;
    }
    if (!(_BYTE)v19)
    {
      char v20 = *(std::__shared_weak_count **)(v3 + 24);
      if (!v20 || (uint64_t v21 = *(void *)(v3 + 16), (v22 = std::__shared_weak_count::lock(v20)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v23 = v22;
      atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      uint64_t v84 = 0;
      std::string v24 = (std::__shared_weak_count *)operator new(0x20uLL);
      v24->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1208;
      v24->__shared_owners_ = v3;
      v24->__shared_weak_owners_ = v21;
      v24[1].__vftable = (std::__shared_weak_count_vtbl *)v23;
      uint64_t v84 = v24;
      sub_100A72B88(1u, (uint64_t)buf);
      sub_100060644(buf);
    }
  }
  switch((int)v2)
  {
    case 1:
      [(id)off_101B0A860() donateWithEventIdentifier:@"com.apple.CommCenter.em.message" bundleIdentifier:@"com.apple.CommCenter.bifrost" completionHandler:&stru_101A0BE60];
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 32));
      if ((*(_WORD *)(v3 + 416) & 8) != 0) {
        *(_WORD *)(v3 + 804) |= 8u;
      }
      BOOL v26 = *(unsigned char *)(v3 + 912) != 0;
      if (*(unsigned char *)(v3 + 912)) {
        uint64_t v27 = *(void *)(v3 + 904) + 1;
      }
      else {
        uint64_t v27 = 0;
      }
      sub_10025A854(v3, 0, 0);
      BOOL v28 = sub_10025B63C(v3 + 1128, 0) != 1;
      buf[0] = v28;
      *(void *)&uint8_t buf[8] = v27;
      LOBYTE(v83) = v26;
      sub_1004CFF70(v3 + 304, (void *)(v3 + 64));
      if (!v28)
      {
        uint64_t v29 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Note: Resuming Em was disallowed in this attempt due to stored state", buf, 2u);
        }
        *(unsigned char *)(v3 + 1152) = 0;
        (*(void (**)(void))(**(void **)(*(void *)(v3 + 1136) + 8) + 16))(*(void *)(*(void *)(v3 + 1136) + 8));
      }
      uint64_t v30 = *(void *)(v3 + 312);
      if (!v30) {
        goto LABEL_106;
      }
      uint64_t v31 = *(int *)(v3 + 456);
      if (v31 > 0xA) {
        char v32 = 0;
      }
      else {
        char v32 = byte_101479730[v31];
      }
      *(unsigned char *)(v30 + 344) = v32;
      if (*(void *)(v3 + 784)) {
        sub_1011261B4((void *)v30, (uint64_t *)(v3 + 784));
      }
      sub_10025CA00(v3);
      unint64_t v51 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 64));
      uint64_t v52 = v51;
      if (v53 < 0)
      {
        long long v54 = (unsigned __int8 *)(v53 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v55 = 5381;
        do
        {
          uint64_t v53 = v55;
          unsigned int v56 = *v54++;
          uint64_t v55 = (33 * v55) ^ v56;
        }
        while (v56);
      }
      std::mutex::lock(v51);
      *(void *)std::string buf = v53;
      uint64_t v57 = sub_10004D37C(&v52[1].__m_.__sig, (unint64_t *)buf);
      if (v57)
      {
        uint64_t v59 = v57[3];
        int v58 = (std::__shared_weak_count *)v57[4];
        if (v58)
        {
          atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v52);
          atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v58);
          char v60 = 0;
          goto LABEL_98;
        }
      }
      else
      {
        uint64_t v59 = 0;
      }
      std::mutex::unlock(v52);
      int v58 = 0;
      char v60 = 1;
LABEL_98:
      if ((*(unsigned int (**)(uint64_t))(*(void *)v59 + 16))(v59))
      {
        int v61 = sub_10025B63C(v3 + 1032, 0);
        if ((v60 & 1) == 0) {
          sub_10004D2C8(v58);
        }
        if (v61 != 1 && sub_1002B45F4(*(void *)(v3 + 312))) {
          sub_1004B32CC(@"CAUTION", @"Mock Mode is ON. If you are in a real emergency, turn Mock Mode OFF immediately from Settings > Internal Settings > CoreTelephony > Stewie", @"OK");
        }
      }
      else if ((v60 & 1) == 0)
      {
        sub_10004D2C8(v58);
      }
LABEL_106:
      (*(void (**)(void, uint64_t))(**(void **)(v3 + 96) + 8))(*(void *)(v3 + 96), 1);
      goto LABEL_112;
    case 2:
      [(id)off_101B0A860() donateWithEventIdentifier:@"com.apple.CommCenter.tryOut" bundleIdentifier:@"com.apple.CommCenter.bifrost" completionHandler:&stru_101A0BE60];
      sub_10025CAD8(v3 + 712, 1u);
      goto LABEL_131;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_131;
    case 4:
      [(id)off_101B0A860() donateWithEventIdentifier:@"com.apple.CommCenter.findMy" bundleIdentifier:@"com.apple.CommCenter.bifrost" completionHandler:&stru_101A0BE60];
      goto LABEL_131;
    case 8:
      [(id)off_101B0A860() donateWithEventIdentifier:@"com.apple.CommCenter.roadside" bundleIdentifier:@"com.apple.CommCenter.bifrost" completionHandler:&stru_101A0BE60];
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 32));
      if (*(_WORD *)(v3 + 416)) {
        *(_WORD *)(v3 + 804) |= 1u;
      }
      sub_10025A5B0(v3, 0, 0, 0, 0);
      BOOL v41 = sub_10025B63C(v3 + 1160, 0) != 1;
      buf[0] = v41;
      BOOL v42 = *(unsigned char *)(v3 + 896) != 0;
      if (*(unsigned char *)(v3 + 896)) {
        uint64_t v43 = *(void *)(v3 + 888) + 1;
      }
      else {
        uint64_t v43 = 0;
      }
      *(void *)&uint8_t buf[8] = v43;
      BOOL v83 = v42;
      sub_1004D00E8(v3 + 304, (void *)(v3 + 64));
      if (!v41)
      {
        BOOL v44 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Note: Resuming Rs was disallowed in this attempt due to stored state", buf, 2u);
        }
        *(unsigned char *)(v3 + 1184) = 0;
        (*(void (**)(void))(**(void **)(*(void *)(v3 + 1168) + 8) + 16))(*(void *)(*(void *)(v3 + 1168) + 8));
      }
      uint64_t v45 = *(void *)(v3 + 344);
      if (!v45) {
        goto LABEL_112;
      }
      if (*(void *)(v3 + 784))
      {
        sub_1011261B4((void *)v45, (uint64_t *)(v3 + 784));
        uint64_t v45 = *(void *)(v3 + 344);
      }
      if (!*(unsigned char *)(v45 + 275)) {
        goto LABEL_111;
      }
      if (!*(unsigned char *)(v4 + 56)) {
        goto LABEL_108;
      }
      int v46 = sub_101117E48(v45);
      if (*(unsigned char *)(v4 + 56) && v47)
      {
        if (v46 == *(const void **)(v4 + 48)) {
          goto LABEL_111;
        }
      }
      else if ((*(unsigned char *)(v4 + 56) != 0) == (v47 != 0))
      {
        goto LABEL_111;
      }
LABEL_108:
      unsigned __int16 v62 = *(NSObject **)(v3 + 48);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I Mark location update is not due for roadside environment because we don't know which provider ID user wants yet or user picked a non-resumable provider", buf, 2u);
      }
      *(unsigned char *)(*(void *)(v3 + 344) + 275) = 0;
LABEL_111:
      sub_10025CBB0(v3);
LABEL_112:
      unsigned int v63 = *(std::__shared_weak_count **)(v3 + 88);
      if (v63)
      {
        int v64 = std::__shared_weak_count::lock(v63);
        if (v64)
        {
          int v65 = v64;
          uint64_t v66 = *(void *)(v3 + 80);
          if (v66 && _os_feature_enabled_impl() && !*(unsigned char *)(v3 + 408))
          {
            sub_1004D0740(v3 + 304, 1u);
            sub_1002C2B48((void *)(v3 + 64), (NSObject **)(v3 + 32), buf);
            int v67 = *(void (****)(void, uint64_t *, uint8_t *))buf;
            char v68 = *(std::__shared_weak_count **)(v3 + 336);
            _OWORD *v6 = *(_OWORD *)buf;
            if (v68)
            {
              sub_10004D2C8(v68);
              int v69 = *(void (****)(void, uint64_t *, uint8_t *))v6;
            }
            else
            {
              int v69 = v67;
            }
            if (v69)
            {
              (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v66 + 216))(&v80, v66);
              std::string v70 = *(std::__shared_weak_count **)(v3 + 24);
              if (!v70 || (v71 = *(void *)(v3 + 16), (std::string::size_type v72 = std::__shared_weak_count::lock(v70)) == 0)) {
                sub_100088B9C();
              }
              int v73 = v72;
              atomic_fetch_add_explicit(&v72->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v72);
              uint64_t v74 = (std::__shared_weak_count *)operator new(0x20uLL);
              v74->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1108;
              v74->__shared_owners_ = v3;
              v74->__shared_weak_owners_ = v71;
              v74[1].__vftable = (std::__shared_weak_count_vtbl *)v73;
              uint64_t v84 = v74;
              (**v69)(v69, &v80, buf);
              sub_100060644(buf);
              sub_10010C0E0((uint64_t)&v80, v81);
            }
            else
            {
              int v75 = *(NSObject **)(v3 + 48);
              if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "Failed to create compression manager", buf, 2u);
              }
              sub_1004D0740(v3 + 304, 2u);
              sub_10025C76C(v3);
            }
          }
          sub_10004D2C8(v65);
        }
      }
      sub_10025C76C(v3);
      goto LABEL_131;
    default:
      if (v2 != 16)
      {
        if (v2 != 32) {
          goto LABEL_131;
        }
        if (!*(void *)(v4 + 80)) {
          __TUAssertTrigger();
        }
        (*(void (**)(void))(**(void **)(v3 + 128) + 104))(*(void *)(v3 + 128));
        uint64_t v33 = *(void *)(v3 + 392);
        int v34 = *(std::__shared_weak_count **)(v3 + 400);
        if (v34) {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v33 && *(unsigned char *)(v33 + 184)) {
          sub_1004D03A8(v3 + 304);
        }
        if (v34) {
          sub_10004D2C8(v34);
        }
        BOOL v83 = 0;
        uint64_t v84 = 0;
        uint64_t v85 = 0;
        uint64_t v35 = *(void *)(v3 + 840);
        *(void *)std::string buf = *(void *)(v3 + 832);
        *(void *)&uint8_t buf[8] = v35;
        if (v35) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v35 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v36 = *(std::__shared_weak_count **)(v4 + 88);
        uint64_t v80 = *(void *)(v4 + 80);
        unint64_t v81 = &v36->__vftable;
        if (v36) {
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_10025B734(&v83, &v80);
        LOBYTE(v85) = 0;
        if (v36) {
          sub_10004D2C8(v36);
        }
        sub_1004D0260(v3 + 304, (void *)(v3 + 64));
        uint64_t v37 = *(void *)(v3 + 360);
        if (!v37) {
          goto LABEL_61;
        }
        uint64_t v38 = *(void *)(v3 + 392);
        if (v38)
        {
          if (!*(unsigned char *)(v38 + 184))
          {
            uint64_t v39 = *(std::__shared_weak_count **)(v3 + 400);
            if (v39)
            {
              atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v37 = *(void *)(v3 + 360);
            }
            goto LABEL_59;
          }
          uint64_t v38 = 0;
        }
        uint64_t v39 = 0;
LABEL_59:
        sub_1006BFB58(v38, (const void **)(v37 + 64));
        if (v39) {
          sub_10004D2C8(v39);
        }
LABEL_61:
        sub_10025AA94(v3);
        if (v84) {
          sub_10004D2C8(v84);
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        goto LABEL_131;
      }
      *(_WORD *)std::string buf = *(_WORD *)(v4 + 96);
      sub_1004D0438(v3 + 304, (void *)(v3 + 64));
      uint64_t v50 = *(void *)(v3 + 360);
      if (v50) {
        sub_1004FBE4C(*(void *)(v3 + 376), (const void **)(v50 + 64));
      }
LABEL_131:
      uint64_t v76 = *(void *)(v3 + 112);
      uint64_t v77 = sub_10025C910(v3);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v76 + 168))(v76, v77);
      if (*(unsigned char *)(v4 + 40)) {
        unint64_t v78 = 0x100000005;
      }
      else {
        unint64_t v78 = *(unsigned int *)(v4 + 100) | (unint64_t)&_mh_execute_header;
      }
      (*(void (**)(void, unint64_t, uint64_t, uint64_t))(**(void **)(v3 + 112) + 16))(*(void *)(v3 + 112), v78, v2, v5);
      if (!sub_10025CC8C(v3)
        && (***(unsigned int (****)(void, uint64_t))(v3 + 128))(*(void *)(v3 + 128), v2))
      {
        if (*(unsigned char *)(v4 + 40)) {
          unint64_t v79 = 0x100000005;
        }
        else {
          unint64_t v79 = *(unsigned int *)(v4 + 100) | (unint64_t)&_mh_execute_header;
        }
        (*(void (**)(void, unint64_t, uint64_t, uint64_t))(**(void **)(v3 + 128) + 16))(*(void *)(v3 + 128), v79, v2, v5);
      }
      break;
  }
}

void sub_10026DD9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  unint64_t v6 = va_arg(va1, void *);
  uint64_t v7 = va_arg(va1, void);
  sub_100060644((uint64_t *)va1);
  sub_10010C0E0((uint64_t)va, v6);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10026DEB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10026DEF4()
{
}

CFStringRef sub_10026DF00(int a1, int a2)
{
  if (a2 == 12)
  {
    if (a1 <= 7)
    {
      if (a1 != 1)
      {
        if (a1 == 4) {
          return @"BIFROST_FIND_MY_EXIT_NETWORK_CONGESTION_TITLE";
        }
        return 0;
      }
      return @"BIFROST_EMERGENCY_SOS_EXIT_TITLE";
    }
    else
    {
      if (a1 != 8)
      {
        if (a1 == 16 || a1 == 32) {
          return @"BIFROST_MESSAGING_EXIT_NETWORK_CONGESTION_TITLE";
        }
        return 0;
      }
      return @"BIFROST_ROADSIDE_EXIT_TITLE";
    }
  }
  else
  {
    int v3 = a1 - 1;
    CFStringRef result = @"BIFROST_EMERGENCY_SOS_EXIT_TITLE";
    switch(v3)
    {
      case 0:
        return result;
      case 1:
        CFStringRef result = @"BIFROST_DEMO_EXIT_TITLE";
        break;
      case 2:
      case 4:
      case 5:
      case 6:
        return 0;
      case 3:
        CFStringRef result = @"BIFROST_FIND_MY_EXIT_TITLE";
        break;
      case 7:
        return @"BIFROST_ROADSIDE_EXIT_TITLE";
      default:
        if (@"BIFROST_EMERGENCY_SOS_EXIT_TITLE" != 16
          && @"BIFROST_EMERGENCY_SOS_EXIT_TITLE" != 32)
        {
          return 0;
        }
        CFStringRef result = @"BIFROST_MESSAGING_EXIT_TITLE";
        break;
    }
  }
  return result;
}

CFStringRef sub_10026DFF8(int a1, unsigned int a2)
{
  if (a2 != 12) {
    return (const __CFString *)sub_10026E064(a2);
  }
  if (a1 <= 7)
  {
    if (a1 != 1)
    {
      if (a1 == 4) {
        return @"BIFROST_FIND_MY_EXIT_NETWORK_CONGESTION_MESSAGE";
      }
      return 0;
    }
    return @"BIFROST_EXIT_NETWORK_CONGESTION_MESSAGE";
  }
  if (a1 == 8) {
    return @"BIFROST_EXIT_NETWORK_CONGESTION_MESSAGE";
  }
  if (a1 == 16 || a1 == 32) {
    return @"BIFROST_MESSAGING_EXIT_NETWORK_CONGESTION_MESSAGE";
  }
  return 0;
}

uint64_t sub_10026E064(unsigned int a1)
{
  if (a1 > 0xE) {
    return 0;
  }
  else {
    return (uint64_t)*(&off_1019B1E18 + (int)a1);
  }
}

void sub_10026E088()
{
}

__n128 sub_10026E09C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019B0998;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10026E0E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B0998;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10026E118(uint64_t a1, unsigned __int16 *a2)
{
  int v2 = *a2;
  int v3 = *(Registry ***)(a1 + 8);
  unsigned int v4 = **(_DWORD **)(a1 + 16);
  CFStringRef v5 = sub_10026DF00(v2, v4);
  CFStringRef v6 = sub_10026DFF8(v2, v4);

  sub_1004B2FA8(v3, (uint64_t)v5, (uint64_t)v6);
}

uint64_t sub_10026E180(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10026E1C0()
{
}

uint64_t sub_10026E1CC(uint64_t a1)
{
  *(void *)a1 = off_1019B0A18;
  sub_10012577C((const void **)(a1 + 32));
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10026E21C(uint64_t a1)
{
  *(void *)a1 = off_1019B0A18;
  sub_10012577C((const void **)(a1 + 32));
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

char *sub_10026E28C(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  int v3 = v2;
  *(void *)int v2 = off_1019B0A18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 24);
  *((void *)v2 + 3) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_10012A394((const void **)v2 + 4, (const void **)(a1 + 32));
  return v3;
}

const void **sub_10026E304(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B0A18;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_10012A394((const void **)(a2 + 32), (const void **)(a1 + 32));
}

void sub_10026E350(uint64_t a1)
{
}

void sub_10026E358(void *a1)
{
  sub_10026E570((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10026E394(uint64_t a1, long long *a2)
{
  long long v14 = *a2;
  uint64_t v15 = *((void *)a2 + 2);
  int v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    CFStringRef v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      CFStringRef v6 = v5;
      if (*(void *)(a1 + 16))
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v4 + 32));
        uint64_t v7 = *(void **)(v4 + 520);
        uint64_t v8 = (void *)(v4 + 528);
        if (v7 != (void *)(v4 + 528))
        {
          while (1)
          {
            if (!v7[6]) {
              __TUAssertTrigger();
            }
            uint64_t v9 = (const void *)v7[5];
            if (v9) {
              char v10 = sub_100136254;
            }
            else {
              char v10 = 0;
            }
            if (!v10)
            {
              __TUAssertTrigger();
              uint64_t v9 = (const void *)v7[5];
            }
            if (CFEqual(v9, *(CFTypeRef *)(a1 + 32))) {
              break;
            }
            uint64_t v11 = (void *)v7[1];
            if (v11)
            {
              do
              {
                unsigned int v12 = v11;
                uint64_t v11 = (void *)*v11;
              }
              while (v11);
            }
            else
            {
              do
              {
                unsigned int v12 = (void *)v7[2];
                BOOL v13 = *v12 == (void)v7;
                uint64_t v7 = v12;
              }
              while (!v13);
            }
            uint64_t v7 = v12;
            if (v12 == v8) {
              goto LABEL_23;
            }
          }
        }
        if (v7 != v8)
        {
          *((unsigned char *)v7 + 160) = 1;
          *(_OWORD *)(v7 + 21) = v14;
          *((unsigned char *)v7 + 184) = v15;
          sub_10025DC48(v4);
        }
      }
LABEL_23:
      sub_10004D2C8(v6);
    }
  }
}

void sub_10026E508(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10026E524(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10026E564()
{
}

void sub_10026E570(uint64_t a1)
{
  sub_10012577C((const void **)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void *sub_10026E5BC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

__n128 sub_10026E640(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      result.n128_u64[0] = sub_10005C9A4(a1, a2).n128_u64[0];
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v4;
      operator delete(v4);
    }
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

uint64_t *sub_10026E6D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(*(void *)v1 + 32));
  if (*(_WORD *)(v2 + 416))
  {
    int v3 = *(std::__shared_weak_count **)(v2 + 88);
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        CFStringRef v5 = v4;
        uint64_t v6 = *(void *)(v2 + 80);
        if (v6) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 80))(v6, v1 + 8);
        }
        sub_10004D2C8(v5);
      }
    }
  }
  sub_10026E7A8(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_10026E77C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10026E7A8(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10026E7A8(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_10012577C((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_10026E7F8(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10026E850(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_10026E838(_Unwind_Exception *a1)
{
  sub_10026CF54(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_10026E850(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    CFStringRef v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      __n128 result = sub_10026E8DC(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      uint64_t v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_10026E8DC(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v9 = 0;
  char v10 = 0;
  uint64_t v6 = (uint64_t **)sub_1000262C0(a1, a2, &v10, &v9, a3);
  __n128 result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_10026E96C((uint64_t)a1, a4, v8);
    sub_100046C38(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }
  return result;
}

void *sub_10026E96C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  uint64_t v6 = a3 + 1;
  uint64_t v7 = operator new(0x40uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  unsigned char v7[8] = *(_DWORD *)a2;
  *((void *)v7 + 6) = 0;
  *((void *)v7 + 7) = 0;
  *((void *)v7 + 5) = 0;
  __n128 result = sub_10005C928((void *)v7 + 5, *(const void **)(a2 + 8), *(void *)(a2 + 16), *(void *)(a2 + 16) - *(void *)(a2 + 8));
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10026E9F0(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_10026EA0C(v2, v3);
  _Unwind_Resume(a1);
}

void sub_10026EA0C(uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    int v3 = (void *)__p[5];
    if (v3)
    {
      __p[6] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t sub_10026EA6C(uint64_t a1)
{
  *(void *)a1 = off_1019B04F8;
  *(void *)(a1 + 8) = off_1019B06E0;
  *(void *)(a1 + 56) = off_1019B07B0;
  uint64_t v2 = *(void *)(a1 + 1232);
  *(void *)(a1 + 1232) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 1200);
  *(void *)(a1 + 1200) = 0;
  if (v3) {
    sub_10026CD9C(a1 + 1200, v3);
  }
  uint64_t v4 = *(void *)(a1 + 1168);
  *(void *)(a1 + 1168) = 0;
  if (v4) {
    sub_10026CD9C(a1 + 1168, v4);
  }
  uint64_t v5 = *(void *)(a1 + 1136);
  *(void *)(a1 + 1136) = 0;
  if (v5) {
    sub_10026CD9C(a1 + 1136, v5);
  }
  uint64_t v6 = *(void *)(a1 + 1104);
  *(void *)(a1 + 1104) = 0;
  if (v6) {
    sub_10026CD9C(a1 + 1104, v6);
  }
  uint64_t v7 = *(void *)(a1 + 1072);
  *(void *)(a1 + 1072) = 0;
  if (v7) {
    sub_10026CD9C(a1 + 1072, v7);
  }
  uint64_t v8 = *(void *)(a1 + 1040);
  *(void *)(a1 + 1040) = 0;
  if (v8) {
    sub_10026CD9C(a1 + 1040, v8);
  }
  uint64_t v9 = *(void *)(a1 + 1008);
  *(void *)(a1 + 1008) = 0;
  if (v9) {
    sub_10026CD9C(a1 + 1008, v9);
  }
  sub_10026CE18(a1 + 928);
  sub_10005D144(*(void **)(a1 + 872));
  char v10 = *(std::__shared_weak_count **)(a1 + 856);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 840);
  if (v11) {
    sub_10004D2C8(v11);
  }
  unsigned int v12 = *(std::__shared_weak_count **)(a1 + 816);
  if (v12) {
    sub_10004D2C8(v12);
  }
  BOOL v13 = *(std::__shared_weak_count **)(a1 + 792);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (*(unsigned char *)(a1 + 776))
  {
    long long v14 = *(void **)(a1 + 752);
    if (v14)
    {
      *(void *)(a1 + 760) = v14;
      operator delete(v14);
    }
  }
  uint64_t v15 = *(void *)(a1 + 720);
  *(void *)(a1 + 720) = 0;
  if (v15) {
    sub_10026CD9C(a1 + 720, v15);
  }
  uint64_t v16 = *(void *)(a1 + 688);
  *(void *)(a1 + 688) = 0;
  if (v16) {
    sub_10026CD9C(a1 + 688, v16);
  }
  sub_10026F148(*(void **)(a1 + 528));
  sub_10005D144(*(void **)(a1 + 496));
  long long v17 = *(std::__shared_weak_count **)(a1 + 480);
  if (v17) {
    sub_10004D2C8(v17);
  }
  unsigned int v18 = *(std::__shared_weak_count **)(a1 + 440);
  if (v18) {
    sub_10004D2C8(v18);
  }
  unsigned int v19 = *(std::__shared_weak_count **)(a1 + 400);
  if (v19) {
    sub_10004D2C8(v19);
  }
  char v20 = *(std::__shared_weak_count **)(a1 + 384);
  if (v20) {
    sub_10004D2C8(v20);
  }
  uint64_t v21 = *(std::__shared_weak_count **)(a1 + 368);
  if (v21) {
    sub_10004D2C8(v21);
  }
  int v22 = *(std::__shared_weak_count **)(a1 + 352);
  if (v22) {
    sub_10004D2C8(v22);
  }
  uint64_t v23 = *(std::__shared_weak_count **)(a1 + 336);
  if (v23) {
    sub_10004D2C8(v23);
  }
  std::string v24 = *(std::__shared_weak_count **)(a1 + 320);
  if (v24) {
    sub_10004D2C8(v24);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 304));
  int v25 = *(std::__shared_weak_count **)(a1 + 272);
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (*(unsigned char *)(a1 + 256))
  {
    BOOL v26 = *(std::__shared_weak_count **)(a1 + 240);
    if (v26) {
      sub_10004D2C8(v26);
    }
  }
  uint64_t v27 = *(std::__shared_weak_count **)(a1 + 216);
  if (v27) {
    sub_10004D2C8(v27);
  }
  BOOL v28 = *(std::__shared_weak_count **)(a1 + 200);
  if (v28) {
    sub_10004D2C8(v28);
  }
  uint64_t v29 = *(std::__shared_weak_count **)(a1 + 184);
  if (v29) {
    sub_10004D2C8(v29);
  }
  uint64_t v30 = *(std::__shared_weak_count **)(a1 + 168);
  if (v30) {
    sub_10004D2C8(v30);
  }
  uint64_t v31 = *(std::__shared_weak_count **)(a1 + 152);
  if (v31) {
    sub_10004D2C8(v31);
  }
  char v32 = *(std::__shared_weak_count **)(a1 + 136);
  if (v32) {
    sub_10004D2C8(v32);
  }
  uint64_t v33 = *(std::__shared_weak_count **)(a1 + 120);
  if (v33) {
    sub_10004D2C8(v33);
  }
  int v34 = *(std::__shared_weak_count **)(a1 + 104);
  if (v34) {
    sub_10004D2C8(v34);
  }
  uint64_t v35 = *(std::__shared_weak_count **)(a1 + 88);
  if (v35) {
    std::__shared_weak_count::__release_weak(v35);
  }
  uint64_t v36 = *(std::__shared_weak_count **)(a1 + 72);
  if (v36) {
    sub_10004D2C8(v36);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 48));
  sub_100087E88((void *)(a1 + 16));
  return a1;
}

void *sub_10026ED50(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10026EDD4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10026EEA0(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[4], v1, (dispatch_function_t)sub_10026EF78);
  __cxa_rethrow();
}

void sub_10026EEC8(_Unwind_Exception *a1)
{
}

void sub_10026EEE0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10026EF18(uint64_t a1)
{
}

uint64_t sub_10026EF34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10026EF78(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 240))();
  }
  return result;
}

void sub_10026EFA4(void *a1)
{
  *a1 = off_1019B1C28;
  operator new();
}

void sub_10026F04C()
{
}

uint64_t sub_10026F070(uint64_t a1)
{
  return sub_10025B63C(a1, 1);
}

void sub_10026F078(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = v3;
  void *v1 = 0;
  if (v3) {
    sub_10026CD9C((uint64_t)v1, v2);
  }

  operator delete();
}

void sub_10026F0CC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B0B08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10026F0EC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B0B08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10026F148(void *a1)
{
  if (a1)
  {
    sub_10026F148(*a1);
    sub_10026F148(a1[1]);
    sub_10026F19C((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

const void **sub_10026F19C(uint64_t a1)
{
  sub_10005D144(*(void **)(a1 + 72));
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = *(void **)(a1 + 24);
    if (v2)
    {
      *(void *)(a1 + 32) = v2;
      operator delete(v2);
    }
  }
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  return sub_10012577C((const void **)(a1 + 8));
}

void *sub_10026F220(void *a1)
{
  *a1 = off_1019B0B58;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10026F26C(void *a1)
{
  *a1 = off_1019B0B58;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_10026F2D8(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019B0B58;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10026F334(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019B0B58;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10026F36C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10026F37C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10026F3BC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3) {
    return;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v7 + 32));
    if (*(unsigned char *)(a2 + 83))
    {
      double v8 = *(double *)(a2 + 40);
      if (v8 <= 1000.0)
      {
        if (v8 <= 100.0)
        {
          if (*(unsigned char *)(a2 + 80)) {
            BOOL v10 = 0;
          }
          else {
            BOOL v10 = *(unsigned char *)(a2 + 81) == 0;
          }
          if (!v10 || *(unsigned char *)(a2 + 82) == 0) {
            unsigned int v9 = 2;
          }
          else {
            unsigned int v9 = 3;
          }
        }
        else
        {
          unsigned int v9 = 1;
        }
        unsigned int v12 = (char *)operator new(0x70uLL);
        long long v13 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(v12 + 56) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(v12 + 72) = v13;
        *(_OWORD *)(v12 + 88) = *(_OWORD *)(a2 + 64);
        long long v14 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)(v12 + 24) = *(_OWORD *)a2;
        *((void *)v12 + 1) = 0;
        *((void *)v12 + 2) = 0;
        *(void *)unsigned int v12 = off_1019B17B8;
        *((void *)v12 + 13) = *(void *)(a2 + 80);
        *(_OWORD *)(v12 + 40) = v14;
        int v22 = v12 + 24;
        uint64_t v23 = v12;
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v7 + 32));
        if (*(_WORD *)(v7 + 416))
        {
          if (v9 < 2) {
            goto LABEL_33;
          }
          atomic_fetch_add_explicit((atomic_ullong *volatile)v12 + 1, 1uLL, memory_order_relaxed);
          *(void *)(v7 + 784) = v12 + 24;
          uint64_t v15 = *(std::__shared_weak_count **)(v7 + 792);
          *(void *)(v7 + 792) = v12;
          if (v15) {
            sub_10004D2C8(v15);
          }
          uint64_t v16 = *(void **)(v7 + 312);
          if (v16) {
            sub_1011261B4(v16, (uint64_t *)(v7 + 784));
          }
          long long v17 = *(void **)(v7 + 344);
          if (v17) {
            sub_1011261B4(v17, (uint64_t *)(v7 + 784));
          }
          if (v9 != 3)
          {
LABEL_33:
            sub_10004D2C8((std::__shared_weak_count *)v12);
            goto LABEL_34;
          }
          (*(void (**)(void, uint64_t))(**(void **)(v7 + 112) + 128))(*(void *)(v7 + 112), v7 + 784);
          sub_10025DC48(v7);
        }
        unsigned int v18 = *(std::__shared_weak_count **)(v7 + 88);
        if (v18)
        {
          unsigned int v19 = std::__shared_weak_count::lock(v18);
          if (v19)
          {
            char v20 = v19;
            uint64_t v21 = *(void *)(v7 + 80);
            if (v21) {
              (*(void (**)(uint64_t, char **))(*(void *)v21 + 112))(v21, &v22);
            }
            sub_10004D2C8(v20);
            unsigned int v12 = v23;
            if (!v23) {
              goto LABEL_34;
            }
          }
        }
        goto LABEL_33;
      }
    }
  }
LABEL_34:

  sub_10004D2C8(v6);
}

void sub_10026F5EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  sub_10004D2C8(v11);
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10026F628(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10026F668()
{
}

void *sub_10026F674(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10026F6F8(void *a1)
{
  *a1 = off_1019B0BE8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10026F744(void *a1)
{
  *a1 = off_1019B0BE8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_10026F7B0(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019B0BE8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10026F80C(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019B0BE8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10026F844(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10026F854(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10026F894(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v4 = *a2;
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v7 + 32));
        if (*(_DWORD *)(v7 + 448) != v4)
        {
          double v8 = *(NSObject **)(v7 + 48);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            if (v4 > 3) {
              unsigned int v9 = "???";
            }
            else {
              unsigned int v9 = off_1019B1E90[(int)v4];
            }
            int v14 = 136315138;
            uint64_t v15 = v9;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Location auth changed to: %s", (uint8_t *)&v14, 0xCu);
          }
          *(_DWORD *)(v7 + 448) = v4;
          sub_10025DA74(v7);
          sub_10025BAD4(v7);
          BOOL v10 = *(std::__shared_weak_count **)(v7 + 88);
          if (v10)
          {
            uint64_t v11 = std::__shared_weak_count::lock(v10);
            if (v11)
            {
              unsigned int v12 = v11;
              uint64_t v13 = *(void *)(v7 + 80);
              if (v13) {
                (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 136))(v13, v4);
              }
              sub_10004D2C8(v12);
            }
          }
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10026FA30(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10026FA54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10026FA94()
{
}

void *sub_10026FAA0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10026FB24(void *a1)
{
  *a1 = off_1019B0C78;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10026FB70(void *a1)
{
  *a1 = off_1019B0C78;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10026FBDC(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019B0C78;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10026FC40(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B0C78;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10026FC80(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10026FC90(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10026FCD0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 24);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_10026FDF0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10026FE30()
{
}

void sub_10026FE3C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  int v2 = *((unsigned __int8 *)*a1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
  if (*(unsigned char *)(v1 + 921)) {
    BOOL v3 = *(unsigned __int8 *)(v1 + 920) == v2;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    uint64_t v4 = *(NSObject **)(v1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "true";
      if (!v2) {
        uint64_t v5 = "false";
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Is iMessage signed in: %s", buf, 0xCu);
    }
    *(_WORD *)(v1 + 920) = v2 | 0x100;
    sub_10025BAD4(v1);
    if (!v2)
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
      if ((*(_WORD *)(v1 + 416) & 0x10) != 0)
      {
        uint64_t v6 = *(std::__shared_weak_count **)(v1 + 88);
        if (v6)
        {
          uint64_t v7 = std::__shared_weak_count::lock(v6);
          if (v7)
          {
            double v8 = v7;
            uint64_t v9 = *(void *)(v1 + 80);
            if (v9)
            {
              *(_DWORD *)std::string buf = 1;
              LOWORD(v11) = 16;
              BYTE2(v11) = 1;
              BYTE4(v11) = 0;
              (*(void (**)(uint64_t, uint8_t *))(*(void *)v9 + 40))(v9, buf);
            }
            sub_10004D2C8(v8);
          }
        }
      }
    }
  }
  operator delete();
}

void sub_10026FFC8()
{
  sub_10004D2C8(v0);
  operator delete();
}

void *sub_100270004(void *a1)
{
  *a1 = off_1019B0CF8;
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100270050(void *a1)
{
  *a1 = off_1019B0CF8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1002700BC(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019B0CF8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100270120(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B0CF8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100270160(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100270170(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1002701B0(void *a1, unsigned __int16 *a2, unsigned __int8 *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    unsigned int v5 = *a2;
    int v6 = *a3;
    uint64_t v7 = a1[1];
    double v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[2])
      {
        if (v5 <= 0xFF)
        {
          __TUAssertTrigger();
          sub_10016C840();
        }
        sub_10025BA38(v7, 1, v5 != 0, v6 != 0);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_100270268(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10027027C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1002702BC()
{
}

void *sub_1002702C8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10027034C(void *a1)
{
  *a1 = off_1019B0D88;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100270398(void *a1)
{
  *a1 = off_1019B0D88;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100270404(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019B0D88;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100270468(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B0D88;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1002704A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1002704B8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1002704F8(void *a1, unsigned __int16 *a2, unsigned __int8 *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    unsigned int v5 = *a2;
    int v6 = *a3;
    uint64_t v7 = a1[1];
    double v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[2])
      {
        if (v5 <= 0xFF)
        {
          __TUAssertTrigger();
          sub_10016C840();
        }
        sub_10025BA38(v7, 4, v5 != 0, v6 != 0);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1002705B0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002705C4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100270604()
{
}

void *sub_100270610(void *a1)
{
  *a1 = off_1019B0E08;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10027065C(void *a1)
{
  *a1 = off_1019B0E08;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1002706C8(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019B0E08;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10027072C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B0E08;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10027076C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10027077C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1002707BC(void *a1, unsigned __int16 *a2, unsigned __int8 *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    unsigned int v5 = *a2;
    int v6 = *a3;
    uint64_t v7 = a1[1];
    double v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[2])
      {
        if (v5 <= 0xFF)
        {
          __TUAssertTrigger();
          sub_10016C840();
        }
        sub_10025BA38(v7, 8, v5 != 0, v6 != 0);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_100270874(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100270888(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1002708C8()
{
}

void sub_1002708D4(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_10025BA38(**a1, 8, 1, 1);
  operator delete();
}

void sub_100270934()
{
}

void *sub_100270960(void *a1)
{
  *a1 = off_1019B0E88;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1002709AC(void *a1)
{
  *a1 = off_1019B0E88;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100270A18(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019B0E88;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100270A7C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B0E88;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100270ABC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100270ACC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100270B0C(void *a1, unsigned __int16 *a2, unsigned __int8 *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    unsigned int v5 = *a2;
    int v6 = *a3;
    uint64_t v7 = a1[1];
    double v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[2])
      {
        if (v5 <= 0xFF)
        {
          __TUAssertTrigger();
          sub_10016C840();
        }
        sub_10025BA38(v7, 16, v5 != 0, v6 != 0);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_100270BC4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100270BD8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100270C18()
{
}

void sub_100270C24(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_10025BA38(**a1, 16, 1, 1);
  operator delete();
}

void sub_100270C84()
{
}

void *sub_100270CB0(void *a1)
{
  *a1 = off_1019B0F08;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100270CFC(void *a1)
{
  *a1 = off_1019B0F08;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100270D68(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019B0F08;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100270DCC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B0F08;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100270E0C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100270E1C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100270E5C(void *a1, unsigned __int16 *a2, unsigned __int8 *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    unsigned int v5 = *a2;
    int v6 = *a3;
    uint64_t v7 = a1[1];
    double v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[2])
      {
        if (v5 <= 0xFF)
        {
          __TUAssertTrigger();
          sub_10016C840();
        }
        sub_10025BA38(v7, 32, v5 != 0, v6 != 0);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_100270F14(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100270F28(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100270F68()
{
}

void sub_100270F74(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_10025BA38(**a1, 32, 1, 1);
  operator delete();
}

void sub_100270FD4()
{
}

void *sub_100271000(void *a1)
{
  *a1 = off_1019B0F88;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100271058(void *a1)
{
  *a1 = off_1019B0F88;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_1002710D0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_1019B0F88;
  sub_100271398((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100271124(uint64_t a1, void *a2)
{
  *a2 = off_1019B0F88;
  return sub_100271398((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100271150(uint64_t a1)
{
}

void sub_100271158(void *a1)
{
  sub_1002713DC((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100271194(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = *(void *)(a1 + 8);
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (!*(void *)(a1 + 16))
      {
LABEL_14:
        sub_10004D2C8(v7);
        return;
      }
      uint64_t v9 = *(void *)(v5 + 392);
      double v8 = *(std::__shared_weak_count **)(v5 + 400);
      if (v8)
      {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v8);
      }
      if (!v9 && (BOOL v10 = *(NSObject **)(v5 + 48), os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Expected SatSmsEnvironment to be up", buf, 2u);
        if (v4)
        {
LABEL_9:
          uint64_t v11 = *(NSObject **)(v5 + 48);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)unsigned int v12 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "ShutDownSatSms expired", v12, 2u);
          }
        }
      }
      else if (v4)
      {
        goto LABEL_9;
      }
      sub_10025CAD8(v5 + 1192, 0);
      (*(void (**)(void))(**(void **)(v5 + 1232) + 16))(*(void *)(v5 + 1232));
      if (*(unsigned char *)(v5 + 984))
      {
        sub_10005CD2C(v5 + 952, *(char **)(v5 + 960));
        sub_10026CE58(*(void **)(v5 + 936));
        *(unsigned char *)(v5 + 984) = 0;
      }
      sub_1004D03A8(v5 + 304);
      sub_10025AA94(v5);
      (*(void (**)(void, unint64_t, uint64_t))(**(void **)(v5 + 128) + 24))(*(void *)(v5 + 128), *(unsigned int *)(a1 + 32) | (unint64_t)&_mh_execute_header, 32);
      goto LABEL_14;
    }
  }
}

void sub_100271338(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10027134C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10027138C()
{
}

uint64_t sub_100271398(uint64_t result, uint64_t a2)
{
  *(_OWORD *)__n128 result = *(_OWORD *)a2;
  uint64_t v2 = *(void *)(a2 + 16);
  *(void *)(result + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
  uint64_t v3 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1002713DC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *sub_10027142C(void *a1)
{
  *a1 = off_1019B1008;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100271478(void *a1)
{
  *a1 = off_1019B1008;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1002714E4(void *a1)
{
  __n128 result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = off_1019B1008;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_100271548(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_1019B1008;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_100271588(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100271598(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1002715D8(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[3];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[1])
      {
        if (sub_10025B63C(v5 + 1096, 0) == 1)
        {
          double v8 = *(NSObject **)(v5 + 48);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v15) = 0;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [Override] areGPSSatsVisible set to true", (uint8_t *)&v15, 2u);
          }
          int v4 = 1;
        }
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 32));
        if (!*(unsigned char *)(v5 + 465) || *(unsigned __int8 *)(v5 + 464) != v4)
        {
          *(_WORD *)(v5 + 464) = v4 | 0x100;
          uint64_t v9 = *(NSObject **)(v5 + 48);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            BOOL v10 = "";
            if (!v4) {
              BOOL v10 = "not ";
            }
            int v15 = 136315138;
            uint64_t v16 = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I GPS Satellites are now %svisible.", (uint8_t *)&v15, 0xCu);
          }
          sub_10025BAD4(v5);
        }
        uint64_t v11 = *(std::__shared_weak_count **)(v5 + 88);
        if (v11)
        {
          unsigned int v12 = std::__shared_weak_count::lock(v11);
          if (v12)
          {
            uint64_t v13 = v12;
            uint64_t v14 = *(void *)(v5 + 80);
            if (v14)
            {
              LOBYTE(v15) = v4;
              BYTE1(v15) = 1;
              (*(void (**)(uint64_t, int *))(*(void *)v14 + 232))(v14, &v15);
            }
            sub_10004D2C8(v13);
          }
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100271798(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002717BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002717FC()
{
}

void sub_10027180C()
{
}

__n128 sub_100271820(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019B1088;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100271874(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B1088;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1002718AC(uint64_t a1, unsigned __int16 *a2)
{
  __int16 v3 = *a2;
  uint64_t result = sub_10025C114(*(void *)(a1 + 8), *a2);
  if (**(_DWORD **)(a1 + 16) > (int)result) {
    **(_WORD **)(a1 + 24) |= v3;
  }
  return result;
}

uint64_t sub_1002718FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10027193C()
{
}

void *sub_100271948(void *a1)
{
  *a1 = off_1019B1108;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100271994(void *a1)
{
  *a1 = off_1019B1108;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100271A00(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019B1108;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100271A64(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B1108;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100271AA4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100271AB4(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100271AF4(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        if (v4)
        {
          unsigned int v8 = 3;
        }
        else
        {
          uint64_t v9 = *(NSObject **)(v5 + 48);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)BOOL v10 = 0;
            unsigned int v8 = 2;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to initialize compression manager", v10, 2u);
          }
          else
          {
            unsigned int v8 = 2;
          }
        }
        sub_1004D0740(v5 + 304, v8);
        sub_10025C76C(v5);
        sub_10025DC48(v5);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100271BC0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100271BD4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100271C14()
{
}

void sub_100271C24()
{
}

__n128 sub_100271C38(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019B1188;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100271C84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B1188;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100271CB4(uint64_t a1, unsigned __int16 *a2, BOOL *a3)
{
  uint64_t result = sub_10025C114(*(void *)(a1 + 8), *a2);
  int v6 = *(int **)(a1 + 16);
  int v7 = *v6;
  if (*v6 <= (int)result) {
    int v7 = result;
  }
  int *v6 = v7;
  *a3 = v7 == 5;
  return result;
}

uint64_t sub_100271D04(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100271D44()
{
}

void *sub_100271D50(void *a1)
{
  *a1 = off_1019B1208;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100271D9C(void *a1)
{
  *a1 = off_1019B1208;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100271E08(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019B1208;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100271E6C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B1208;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100271EAC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100271EBC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100271EFC(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (a1[2])
      {
        unsigned int v8 = *(NSObject **)(v5 + 48);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = "Succeeded";
          if (!v4) {
            uint64_t v9 = "Failed";
          }
          int v10 = 136315138;
          uint64_t v11 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s to enter low power mode", (uint8_t *)&v10, 0xCu);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

uint64_t sub_100271FE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100272024()
{
}

void sub_100272034()
{
}

__n128 sub_100272048(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019B1288;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100272094(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B1288;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1002720C4(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 32));
  int v5 = *(unsigned __int16 *)(v3 + 416);
  if ((v5 & v2) == 0) {
    return;
  }
  *(_WORD *)(v3 + 416) = v5 & ~(_WORD)v2;
  *(_WORD *)(v3 + 804) &= ~(_WORD)v2;
  sub_10025C848(v3);
  uint64_t v6 = *(void *)(v3 + 112);
  uint64_t v7 = sub_10025C910(v3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 168))(v6, v7);
  BOOL v8 = 0;
  if ((int)v2 > 15)
  {
    if (v2 != 16)
    {
      if (v2 == 32)
      {
        uint64_t v15 = *(void *)(v3 + 392);
        if (v15 && !*(unsigned char *)(v15 + 184))
        {
          uint64_t v21 = *(std::__shared_weak_count **)(v3 + 400);
          if (v21)
          {
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v21);
          }
        }
        else
        {
          __TUAssertTrigger();
        }
        sub_1004D03A8(v3 + 304);
        int v16 = sub_10025B63C(v3 + 1192, 0);
        BOOL v8 = v16 == 1;
        if (v16 == 1) {
          sub_10025AD28(v3);
        }
        sub_10025AA94(v3);
      }
      goto LABEL_23;
    }
    if (!*(void *)(v3 + 376)) {
      __TUAssertTrigger();
    }
    sub_1004D055C(v3 + 304);
    goto LABEL_22;
  }
  if (v2 == 1)
  {
    uint64_t v17 = *(void *)(v3 + 312);
    if (!v17)
    {
      __TUAssertTrigger();
      uint64_t v17 = *(void *)(v3 + 312);
    }
    uint64_t v18 = sub_1011260B8(v17);
    sub_10025A854(v3, v18, v19);
    sub_1004D0058(v3 + 304);
    goto LABEL_22;
  }
  if (v2 == 8)
  {
    uint64_t v9 = *(void *)(v3 + 344);
    if (!v9)
    {
      __TUAssertTrigger();
      uint64_t v9 = *(void *)(v3 + 344);
    }
    uint64_t v10 = sub_1011260B8(v9);
    uint64_t v12 = v11;
    uint64_t v13 = sub_101117E48(*(void *)(v3 + 344));
    sub_10025A5B0(v3, v10, v12, v13, v14);
    sub_1004D01D0(v3 + 304);
LABEL_22:
    BOOL v8 = 0;
  }
LABEL_23:
  (*(void (**)(void, unint64_t, uint64_t))(**(void **)(v3 + 112) + 24))(*(void *)(v3 + 112), v4 | (unint64_t)&_mh_execute_header, v2);
  if (!v8
    && !sub_10025CC8C(v3)
    && (***(unsigned int (****)(void, uint64_t))(v3 + 128))(*(void *)(v3 + 128), v2))
  {
    char v20 = *(void (**)(void))(**(void **)(v3 + 128) + 24);
    v20();
  }
}

uint64_t sub_100272388(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1002723C8()
{
}

uint64_t sub_1002723D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_100272454(void *a1)
{
  *a1 = off_1019B1308;
  sub_1001E8DA8(a1 + 2);
  return a1;
}

void sub_100272498(void *a1)
{
  *a1 = off_1019B1308;
  sub_1001E8DA8(a1 + 2);

  operator delete();
}

_DWORD *sub_1002724FC(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  *(void *)uint64_t v2 = off_1019B1308;
  v2[2] = *(_DWORD *)(a1 + 8);
  sub_10027264C((uint64_t)(v2 + 4), a1 + 16);
  return v2;
}

void sub_10027255C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100272570(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B1308;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  return sub_10027264C(a2 + 16, a1 + 16);
}

void *sub_1002725A4(uint64_t a1)
{
  return sub_1001E8DA8((void *)(a1 + 16));
}

void sub_1002725AC(void *a1)
{
  sub_1001E8DA8(a1 + 2);

  operator delete(a1);
}

uint64_t sub_1002725E8(uint64_t a1, uint64_t *a2)
{
  return sub_100260630(*(void *)(a1 + 40), *a2, *(unsigned int *)(a1 + 8) | (unint64_t)&_mh_execute_header);
}

uint64_t sub_100272600(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100272640()
{
}

uint64_t sub_10027264C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_1002726E4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_100272768(uint64_t **a1, unsigned __int8 a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 1);
  __n128 result = a1[1];
  if (result)
  {
    int v5 = v4;
    uint64_t v6 = result;
    do
    {
      unsigned int v7 = *((unsigned __int8 *)v6 + 25);
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t **)v6;
      }
      else {
        uint64_t v9 = (uint64_t **)(v6 + 1);
      }
      if (v8) {
        int v5 = v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 == v4 || *((unsigned __int8 *)v5 + 25) > a2)
    {
      return 0;
    }
    else
    {
      uint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v5;
        do
        {
          uint64_t v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if (*a1 == v5) {
        *a1 = v11;
      }
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      sub_10005EE6C(result, v5);
      operator delete(v5);
      return (uint64_t *)1;
    }
  }
  return result;
}

void sub_100272838(uint64_t **a1, unsigned __int8 a2, long long *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v19 = 0;
  unsigned int v7 = (char *)operator new(0xC8uLL);
  v18[0] = v7;
  v18[1] = v6;
  v7[32] = a2;
  long long v8 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  *(_OWORD *)(v7 + 40) = v8;
  v7[56] = 0;
  v7[80] = 0;
  if (*((unsigned char *)a3 + 40))
  {
    *(_OWORD *)(v7 + 56) = a3[1];
    *((void *)v7 + 9) = *((void *)a3 + 4);
    *((void *)a3 + 3) = 0;
    *((void *)a3 + 4) = 0;
    *((void *)a3 + 2) = 0;
    v7[80] = 1;
  }
  uint64_t v9 = a3 + 4;
  uint64_t v10 = *((void *)a3 + 8);
  *((void *)v7 + 13) = v10;
  uint64_t v11 = v7 + 104;
  uint64_t v12 = *((void *)a3 + 7);
  *((void *)v7 + 11) = *((void *)a3 + 6);
  *((void *)v7 + 12) = v12;
  uint64_t v13 = *((void *)a3 + 9);
  *((void *)v7 + 14) = v13;
  if (v13)
  {
    *(void *)(v10 + 16) = v11;
    *((void *)a3 + 7) = v9;
    void *v9 = 0;
    *((void *)a3 + 9) = 0;
  }
  else
  {
    *((void *)v7 + 12) = v11;
  }
  long long v14 = a3[5];
  *(_OWORD *)(v7 + 136) = a3[6];
  long long v15 = a3[8];
  *(_OWORD *)(v7 + 152) = a3[7];
  *(_OWORD *)(v7 + 168) = v15;
  *(_OWORD *)(v7 + 178) = *(long long *)((char *)a3 + 138);
  *(_OWORD *)(v7 + 120) = v14;
  LOBYTE(v19) = 1;
  int v16 = v6;
  uint64_t v17 = *v6;
  if (*v6)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v17;
        if (*((unsigned __int8 *)v17 + 32) >= a2) {
          break;
        }
        uint64_t v17 = (uint64_t *)*v17;
        int v16 = v6;
        if (!*v6) {
          goto LABEL_12;
        }
      }
      uint64_t v17 = (uint64_t *)v17[1];
    }
    while (v17);
    int v16 = v6 + 1;
  }
LABEL_12:
  sub_100046C38(a1, (uint64_t)v6, v16, (uint64_t *)v7);
  v18[0] = 0;
  sub_10027297C((uint64_t)v18);
}

void sub_10027297C(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10026F19C((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void sub_1002729D8()
{
}

void *sub_1002729EC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B1388;
  result[1] = v3;
  return result;
}

uint64_t sub_100272A34(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B1388;
  a2[1] = v2;
  return result;
}

void sub_100272A60(uint64_t a1)
{
}

uint64_t sub_100272A68(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100272AA8()
{
}

void sub_100272AB8()
{
}

void *sub_100272ACC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B1408;
  result[1] = v3;
  return result;
}

uint64_t sub_100272B14(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B1408;
  a2[1] = v2;
  return result;
}

void sub_100272B40(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 344);
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 264);
    *(void *)(v2 + 256) = 0;
    *(void *)(v2 + 264) = 0;
    if (v3) {
      sub_10004D2C8(v3);
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
    if (*(_WORD *)(v1 + 416))
    {
      uint64_t v4 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = 134217984;
        uint64_t v6 = 900;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Marking roadside location update due (after %lld seconds)", (uint8_t *)&v5, 0xCu);
      }
      *(unsigned char *)(*(void *)(v1 + 344) + 275) = 1;
      sub_10025DC48(v1);
    }
  }
}

uint64_t sub_100272C20(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100272C60()
{
}

uint64_t sub_100272C6C(uint64_t **a1, unsigned __int8 a2, char a3)
{
  uint64_t v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = (uint64_t **)v5;
        unsigned int v8 = *((unsigned __int8 *)v5 + 25);
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        return 0;
      }
      int v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unsigned int v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = operator new(0x20uLL);
    v9[25] = a3;
    *(void *)uint64_t v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v7;
    uint64_t *v6 = (uint64_t *)v9;
    uint64_t v10 = (uint64_t *)**a1;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    else
    {
      uint64_t v11 = (uint64_t *)v9;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return 1;
  }
}

void sub_100272D38()
{
}

void *sub_100272D4C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B1488;
  result[1] = v3;
  return result;
}

uint64_t sub_100272D94(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B1488;
  a2[1] = v2;
  return result;
}

void sub_100272DC0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 312);
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 264);
    *(void *)(v2 + 256) = 0;
    *(void *)(v2 + 264) = 0;
    if (v3) {
      sub_10004D2C8(v3);
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
    if (*(_WORD *)(v1 + 416))
    {
      uint64_t v4 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = 134217984;
        uint64_t v6 = 900;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Marking emergency location update due (after %lld seconds)", (uint8_t *)&v5, 0xCu);
      }
      *(unsigned char *)(*(void *)(v1 + 312) + 275) = 1;
      sub_10025DC48(v1);
    }
  }
}

uint64_t sub_100272EA0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100272EE0()
{
}

void sub_100272EEC(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  if (*(_WORD *)(v2 + 416))
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 88);
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        int v5 = v4;
        uint64_t v6 = *(void *)(v2 + 80);
        if (v6) {
          (*(void (**)(uint64_t, void))(*(void *)v6 + 64))(v6, *((unsigned __int8 *)v1 + 8));
        }
        sub_10004D2C8(v5);
      }
    }
  }
  operator delete();
}

void sub_100272FA0()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_100272FDC(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  if (*(_WORD *)(v2 + 416))
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 88);
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        int v5 = v4;
        uint64_t v6 = *(void *)(v2 + 80);
        if (v6) {
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v6 + 72))(v6, *((unsigned __int8 *)v1 + 8), v1[2]);
        }
        sub_10004D2C8(v5);
      }
    }
  }
  operator delete();
}

void sub_100273094()
{
  sub_10004D2C8(v0);
  operator delete();
}

uint64_t sub_1002730D0(uint64_t a1)
{
  *(void *)a1 = off_1019B1508;
  sub_10012577C((const void **)(a1 + 40));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100273120(uint64_t a1)
{
  *(void *)a1 = off_1019B1508;
  sub_10012577C((const void **)(a1 + 40));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100273190(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  *uint64_t v2 = off_1019B1508;
  sub_1002734F8((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_1002731E4(uint64_t a1, void *a2)
{
  *a2 = off_1019B1508;
  return sub_1002734F8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100273210(uint64_t a1)
{
}

void sub_100273218(void *a1)
{
  sub_100273564((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100273254(uint64_t a1, void *a2)
{
  uint64_t v3 = a2 + 1;
  uint64_t v4 = a2[1];
  unsigned int v8 = (uint64_t *)*a2;
  uint64_t v9 = v4;
  if (a2[2])
  {
    *(void *)(v4 + 16) = &v9;
    *a2 = v3;
    *uint64_t v3 = 0;
    a2[2] = 0;
  }
  else
  {
    unsigned int v8 = &v9;
  }
  long long v7 = *(_OWORD *)(a1 + 8);
  long long v11 = v7;
  int v5 = *(std::__shared_weak_count **)(a1 + 24);
  uint64_t v12 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  int v13 = *(_DWORD *)(a1 + 32);
  sub_10012A394(&v14, (const void **)(a1 + 40));
  int v15 = *(_DWORD *)(a1 + 48);
  char v16 = *(unsigned char *)(a1 + 56);
  sub_10026E7F8(&v17, (uint64_t)&v8);
  uint64_t v6 = *(std::__shared_weak_count **)(v7 + 24);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10027347C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  sub_10012577C(v17);
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  sub_10026CF54((uint64_t)&a12, a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1002734AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002734EC()
{
}

uint64_t sub_1002734F8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  sub_10012A394((const void **)(a1 + 32), (const void **)(a2 + 32));
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  return a1;
}

void sub_100273564(uint64_t a1)
{
  sub_10012577C((const void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_1002735B0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v57 = a1;
  uint64_t v58 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void **)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (!*(void *)(v1 + 8))
      {
LABEL_79:
        sub_10004D2C8(v5);
        goto LABEL_80;
      }
      uint64_t v6 = v3[49];
      if (!v6 || *(unsigned char *)(v6 + 184))
      {
        long long v7 = v3[6];
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Sat Sms environment doesn't exist anymore", buf, 2u);
        }
        goto LABEL_79;
      }
      unsigned int v8 = (std::__shared_weak_count *)v3[50];
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v68 = 0;
      v69[0] = 0;
      v69[1] = 0;
      sub_10026E7F8((uint64_t *)&v68, v1 + 56);
      if (sub_10025B63C((uint64_t)(v3 + 133), 0) == 1)
      {
        sub_10008E4E8(buf, 0x10uLL);
        LODWORD(v70) = 5;
        *(void *)&long long v62 = &v70;
        uint64_t v9 = sub_10008CC40(&v68, (int *)&v70, (uint64_t)&unk_10144E20E, (_DWORD **)&v62);
        uint64_t v10 = v9[5];
        if (v10)
        {
          v9[6] = v10;
          operator delete(v10);
          v9[5] = 0;
          v9[6] = 0;
          v9[7] = 0;
        }
        *(_OWORD *)(v9 + 5) = *(_OWORD *)buf;
        v9[7] = *(uint64_t **)&buf[16];
        sub_10008E4E8(buf, 0x10uLL);
        LODWORD(v70) = 6;
        *(void *)&long long v62 = &v70;
        long long v11 = sub_10008CC40(&v68, (int *)&v70, (uint64_t)&unk_10144E20E, (_DWORD **)&v62);
        uint64_t v12 = v11[5];
        if (v12)
        {
          v11[6] = v12;
          operator delete(v12);
          v11[5] = 0;
          v11[6] = 0;
          v11[7] = 0;
        }
        *(_OWORD *)(v11 + 5) = *(_OWORD *)buf;
        v11[7] = *(uint64_t **)&buf[16];
        sub_10008E4E8(buf, 0x10uLL);
        LODWORD(v70) = 7;
        *(void *)&long long v62 = &v70;
        int v13 = sub_10008CC40(&v68, (int *)&v70, (uint64_t)&unk_10144E20E, (_DWORD **)&v62);
        long long v14 = v13[5];
        if (v14)
        {
          v13[6] = v14;
          operator delete(v14);
          v13[5] = 0;
          v13[6] = 0;
          v13[7] = 0;
        }
        *(_OWORD *)(v13 + 5) = *(_OWORD *)buf;
        v13[7] = *(uint64_t **)&buf[16];
      }
      int v15 = v69[0];
      if (v69[0])
      {
        char v16 = v69;
        uint64_t v17 = (int *)v69;
        uint64_t v18 = (int *)v69[0];
        do
        {
          uint64_t v19 = v18;
          char v20 = v17;
          int v21 = v18[8];
          if (v21 >= 5) {
            uint64_t v17 = v18;
          }
          else {
            v18 += 2;
          }
          uint64_t v18 = *(int **)v18;
        }
        while (v18);
        if (v17 != (int *)v69)
        {
          if (v21 < 5) {
            uint64_t v19 = v20;
          }
          if (v19[8] <= 5)
          {
            int v22 = (int *)v69;
            uint64_t v23 = (int *)v69[0];
            do
            {
              std::string v24 = v23;
              int v25 = v22;
              int v26 = v23[8];
              if (v26 >= 6) {
                int v22 = v23;
              }
              else {
                v23 += 2;
              }
              uint64_t v23 = *(int **)v23;
            }
            while (v23);
            if (v22 != (int *)v69)
            {
              if (v26 < 6) {
                std::string v24 = v25;
              }
              if (v24[8] <= 6)
              {
                uint64_t v27 = (int *)v69;
                BOOL v28 = (int *)v69[0];
                do
                {
                  uint64_t v29 = v28;
                  uint64_t v30 = v27;
                  int v31 = v28[8];
                  if (v31 >= 7) {
                    uint64_t v27 = v28;
                  }
                  else {
                    v28 += 2;
                  }
                  BOOL v28 = *(int **)v28;
                }
                while (v28);
                if (v27 != (int *)v69)
                {
                  if (v31 < 7) {
                    uint64_t v29 = v30;
                  }
                  if (v29[8] <= 7)
                  {
                    char v32 = v3[6];
                    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v33 = subscriber::asString();
                      *(_DWORD *)std::string buf = 136315138;
                      *(void *)&uint8_t buf[4] = v33;
                      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I [EAP-AKA challenge] Successfully solved for slot: %s", buf, 0xCu);
                    }
                    int v34 = *(unsigned __int8 *)(v1 + 40);
                    unsigned __int8 v35 = *(unsigned char *)(v1 + 48);
                    buf[0] = 3;
                    uint8_t buf[8] = 0;
                    char v73 = 0;
                    int v61 = 5;
                    std::string v70 = &v61;
                    uint64_t v36 = sub_10008CC40(&v68, &v61, (uint64_t)&unk_10144E20E, &v70);
                    uint64_t v63 = 0;
                    long long v62 = 0uLL;
                    sub_10005C928(&v62, v36[5], (uint64_t)v36[6], (char *)v36[6] - (char *)v36[5]);
                    int v60 = 6;
                    std::string v70 = &v60;
                    uint64_t v37 = sub_10008CC40(&v68, &v60, (uint64_t)&unk_10144E20E, &v70);
                    uint64_t v65 = 0;
                    long long v64 = 0uLL;
                    sub_10005C928(&v64, v37[5], (uint64_t)v37[6], (char *)v37[6] - (char *)v37[5]);
                    int v59 = 7;
                    std::string v70 = &v59;
                    uint64_t v38 = sub_10008CC40(&v68, &v59, (uint64_t)&unk_10144E20E, &v70);
                    __p[1] = 0;
                    uint64_t v67 = 0;
                    __p[0] = 0;
                    sub_10005C928(__p, v38[5], (uint64_t)v38[6], (char *)v38[6] - (char *)v38[5]);
                    long long v74 = v62;
                    uint64_t v75 = v63;
                    uint64_t v63 = 0;
                    long long v62 = 0uLL;
                    long long v76 = v64;
                    uint64_t v39 = v65;
                    uint64_t v65 = 0;
                    long long v64 = 0uLL;
                    long long v78 = *(_OWORD *)__p;
                    uint64_t v77 = v39;
                    uint64_t v79 = v67;
                    __p[1] = 0;
                    uint64_t v67 = 0;
                    __p[0] = 0;
                    char v80 = 1;
                    sub_1006BF5C8(v6, (const void **)(v1 + 32), v34, v35, buf);
                    sub_100273EC4((uint64_t)&v74);
                    if (v73 && *(void *)&buf[8])
                    {
                      *(void *)&uint8_t buf[16] = *(void *)&buf[8];
                      operator delete(*(void **)&buf[8]);
                    }
                    if (__p[0])
                    {
                      __p[1] = __p[0];
                      operator delete(__p[0]);
                    }
                    uint64_t v40 = (void *)v64;
                    if (!(void)v64) {
                      goto LABEL_69;
                    }
                    *((void *)&v64 + 1) = v64;
LABEL_68:
                    operator delete(v40);
LABEL_69:
                    unint64_t v51 = (void *)v62;
                    if (!(void)v62) {
                      goto LABEL_77;
                    }
                    *((void *)&v62 + 1) = v62;
LABEL_76:
                    operator delete(v51);
LABEL_77:
                    sub_10025DC48((uint64_t)v3);
                    sub_10026CF54((uint64_t)&v68, v69[0]);
                    if (v8) {
                      sub_10004D2C8(v8);
                    }
                    goto LABEL_79;
                  }
                }
              }
            }
          }
        }
        do
        {
          BOOL v41 = v15;
          BOOL v42 = v16;
          int v43 = *((_DWORD *)v15 + 8);
          BOOL v44 = v15 + 1;
          if (v43 >= 9)
          {
            BOOL v44 = v41;
            char v16 = (void **)v41;
          }
          int v15 = (void *)*v44;
        }
        while (v15);
        if (v16 != v69)
        {
          uint64_t v45 = (int *)(v43 >= 9 ? v41 : v42);
          if (v45[8] <= 9)
          {
            int v46 = v3[6];
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v47 = subscriber::asString();
              *(_DWORD *)std::string buf = 136315138;
              *(void *)&uint8_t buf[4] = v47;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I [EAP-AKA challenge] Resync required for slot: %s", buf, 0xCu);
            }
            int v48 = *(unsigned __int8 *)(v1 + 40);
            unsigned __int8 v49 = *(unsigned char *)(v1 + 48);
            buf[0] = 2;
            int v61 = 9;
            std::string v70 = &v61;
            uint64_t v50 = sub_10008CC40(&v68, &v61, (uint64_t)&unk_10144E20E, &v70);
            uint64_t v63 = 0;
            long long v62 = 0uLL;
            sub_10005C928(&v62, v50[5], (uint64_t)v50[6], (char *)v50[6] - (char *)v50[5]);
            *(_OWORD *)&uint8_t buf[8] = v62;
            uint64_t v72 = v63;
            uint64_t v63 = 0;
            long long v62 = 0uLL;
            char v73 = 1;
            LOBYTE(v74) = 0;
            char v80 = 0;
            sub_1006BF5C8(v6, (const void **)(v1 + 32), v48, v49, buf);
            sub_100273EC4((uint64_t)&v74);
            if (!v73) {
              goto LABEL_69;
            }
            uint64_t v40 = *(void **)&buf[8];
            if (!*(void *)&buf[8]) {
              goto LABEL_69;
            }
            *(void *)&uint8_t buf[16] = *(void *)&buf[8];
            goto LABEL_68;
          }
        }
      }
      uint64_t v52 = v3[6];
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v53 = subscriber::asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v53;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I [EAP-AKA challenge] Failed for slot: %s", buf, 0xCu);
      }
      int v54 = *(unsigned __int8 *)(v1 + 40);
      unsigned __int8 v55 = *(unsigned char *)(v1 + 48);
      buf[0] = 5;
      uint8_t buf[8] = 0;
      char v73 = 0;
      LOBYTE(v74) = 0;
      char v80 = 0;
      sub_1006BF5C8(v6, (const void **)(v1 + 32), v54, v55, buf);
      sub_100273EC4((uint64_t)&v74);
      if (!v73) {
        goto LABEL_77;
      }
      unint64_t v51 = *(void **)&buf[8];
      if (!*(void *)&buf[8]) {
        goto LABEL_77;
      }
      *(void *)&uint8_t buf[16] = *(void *)&buf[8];
      goto LABEL_76;
    }
  }
LABEL_80:
  sub_100273E5C(&v58);
  return sub_100046B58((uint64_t *)&v57);
}

void sub_100273D2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,char a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,char a31)
{
  sub_10026CF54((uint64_t)&a22, a23);
  if (v32) {
    sub_10004D2C8(v32);
  }
  sub_10004D2C8(v31);
  sub_100273E5C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100273E5C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_10026CF54(v1 + 56, *(void **)(v1 + 64));
    sub_10012577C((const void **)(v1 + 32));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100273EC4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v2 = *(void **)(a1 + 48);
    if (v2)
    {
      *(void *)(a1 + 56) = v2;
      operator delete(v2);
    }
    uint64_t v3 = *(void **)(a1 + 24);
    if (v3)
    {
      *(void *)(a1 + 32) = v3;
      operator delete(v3);
    }
    uint64_t v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v4;
      operator delete(v4);
    }
  }
  return a1;
}

void *sub_100273F20(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100273FA4(void *a1)
{
  uint64_t v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void *sub_100273FF0(void *a1)
{
  *a1 = off_1019BE450;
  *a1 = off_1019BE450;
  a1[2] = &unk_1019BE4B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void *)a1[5];
  if (v3)
  {
    a1[6] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1002740F0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1598;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100274110(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1598;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100274164(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16))();
}

void *sub_10027418C(void *a1)
{
  *a1 = off_1019B15E8;
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_1002741F4(void *a1)
{
  *a1 = off_1019B15E8;
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void *sub_10027427C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_1019B15E8;
  sub_1002745B4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1002742D0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002742E4(uint64_t a1, void *a2)
{
  *a2 = off_1019B15E8;
  return sub_1002745B4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100274310(uint64_t a1)
{
}

void sub_100274318(void *a1)
{
  sub_100274660(a1 + 1);

  operator delete(a1);
}

void sub_100274354(uint64_t a1, long long *a2)
{
  long long v18 = *a2;
  int v3 = *((unsigned __int8 *)a2 + 16);
  *(_DWORD *)uint64_t v17 = *(_DWORD *)((char *)a2 + 17);
  *(_DWORD *)&uint64_t v17[3] = *((_DWORD *)a2 + 5);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      long long v7 = v6;
      if (*(void *)(a1 + 16))
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 32));
        if (*(_WORD *)(v5 + 416))
        {
          int v8 = *(unsigned __int8 *)(a1 + 48);
          if (v8 == 2)
          {
            uint64_t v10 = *(void *)(v5 + 128);
            uint64_t v9 = *(std::__shared_weak_count **)(v5 + 136);
            if (!v9) {
              goto LABEL_9;
            }
            goto LABEL_8;
          }
          if (v8 == 1)
          {
            uint64_t v10 = *(void *)(v5 + 112);
            uint64_t v9 = *(std::__shared_weak_count **)(v5 + 120);
            if (!v9)
            {
LABEL_9:
              if (v10)
              {
                int v11 = *(_DWORD *)(*(void *)(a1 + 32) + 12);
                unsigned int v12 = *(_DWORD *)(a1 + 80);
                int v13 = *(unsigned __int8 *)(a1 + 48);
                if (v3)
                {
                  long long v20 = v18;
                  char v21 = v3;
                  v22[0] = *(_DWORD *)v17;
                  *(_DWORD *)((char *)v22 + 3) = *(_DWORD *)&v17[3];
                  StewieDataController::submitMessageIncomingMetric(v5, v11, v12, v13, 1, 1, (unsigned int *)&v20);
                  uint64_t v14 = *(void *)(a1 + 32);
                  uint64_t v15 = *(unsigned __int8 *)(a1 + 48);
                  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 32));
                  (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v5 + 144) + 24))(*(void *)(v5 + 144), v14, a1 + 56, v15);
                  sub_10025DC48(v5);
                }
                else
                {
                  LOBYTE(v20) = 0;
                  char v21 = 0;
                  StewieDataController::submitMessageIncomingMetric(v5, v11, v12, v13, 0, 1, (unsigned int *)&v20);
                  char v16 = *(NSObject **)(v5 + 48);
                  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)std::string buf = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Hit failure, but still going to ack because we don't want this message to be re-transmitted", buf, 2u);
                  }
                  (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 40))(v10, a1 + 56);
                }
              }
              if (v9) {
                sub_10004D2C8(v9);
              }
              goto LABEL_14;
            }
LABEL_8:
            atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
            goto LABEL_9;
          }
        }
      }
LABEL_14:
      sub_10004D2C8(v7);
    }
  }
}

void sub_100274540(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100274568(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002745A8()
{
}

uint64_t sub_1002745B4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  char v6 = *(unsigned char *)(a2 + 40);
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 40) = v6;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  sub_10005C928((void *)(a1 + 48), *(const void **)(a2 + 48), *(void *)(a2 + 56), *(void *)(a2 + 56) - *(void *)(a2 + 48));
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  return a1;
}

void sub_10027463C(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 32);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_100274660(void *a1)
{
  uint64_t v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void *sub_1002746C0(void *a1)
{
  *a1 = off_101A917F0;
  *a1 = off_101A917F0;
  a1[2] = &unk_101A91858;
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (void *)a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1002747C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1668;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002747E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1668;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100274834(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16))();
}

void *sub_10027485C(void *a1)
{
  *a1 = off_1019B16B8;
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_1002748C4(void *a1)
{
  *a1 = off_1019B16B8;
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void *sub_10027494C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_1019B16B8;
  sub_100274C84((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1002749A0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002749B4(uint64_t a1, void *a2)
{
  *a2 = off_1019B16B8;
  return sub_100274C84((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1002749E0(uint64_t a1)
{
}

void sub_1002749E8(void *a1)
{
  sub_100274660(a1 + 1);

  operator delete(a1);
}

void sub_100274A24(uint64_t a1, long long *a2)
{
  long long v18 = *a2;
  int v3 = *((unsigned __int8 *)a2 + 16);
  *(_DWORD *)uint64_t v17 = *(_DWORD *)((char *)a2 + 17);
  *(_DWORD *)&uint64_t v17[3] = *((_DWORD *)a2 + 5);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    char v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      long long v7 = v6;
      if (*(void *)(a1 + 16))
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 32));
        if (*(_WORD *)(v5 + 416))
        {
          int v8 = *(unsigned __int8 *)(a1 + 48);
          if (v8 == 2)
          {
            uint64_t v10 = *(void *)(v5 + 128);
            uint64_t v9 = *(std::__shared_weak_count **)(v5 + 136);
            if (!v9) {
              goto LABEL_9;
            }
            goto LABEL_8;
          }
          if (v8 == 1)
          {
            uint64_t v10 = *(void *)(v5 + 112);
            uint64_t v9 = *(std::__shared_weak_count **)(v5 + 120);
            if (!v9)
            {
LABEL_9:
              if (v10)
              {
                int v11 = *(_DWORD *)(*(void *)(a1 + 32) + 12);
                unsigned int v12 = *(_DWORD *)(a1 + 80);
                int v13 = *(unsigned __int8 *)(a1 + 48);
                if (v3)
                {
                  long long v20 = v18;
                  char v21 = v3;
                  v22[0] = *(_DWORD *)v17;
                  *(_DWORD *)((char *)v22 + 3) = *(_DWORD *)&v17[3];
                  StewieDataController::submitMessageIncomingMetric(v5, v11, v12, v13, 1, 1, (unsigned int *)&v20);
                  uint64_t v14 = *(void *)(a1 + 32);
                  uint64_t v15 = *(unsigned __int8 *)(a1 + 48);
                  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 32));
                  (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v5 + 144) + 32))(*(void *)(v5 + 144), v14, a1 + 56, v15);
                  sub_10025DC48(v5);
                }
                else
                {
                  LOBYTE(v20) = 0;
                  char v21 = 0;
                  StewieDataController::submitMessageIncomingMetric(v5, v11, v12, v13, 0, 1, (unsigned int *)&v20);
                  char v16 = *(NSObject **)(v5 + 48);
                  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)std::string buf = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Hit failure, but still going to ack because we don't want this message to be re-transmitted", buf, 2u);
                  }
                  (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 40))(v10, a1 + 56);
                }
              }
              if (v9) {
                sub_10004D2C8(v9);
              }
              goto LABEL_14;
            }
LABEL_8:
            atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
            goto LABEL_9;
          }
        }
      }
LABEL_14:
      sub_10004D2C8(v7);
    }
  }
}

void sub_100274C10(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100274C38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100274C78()
{
}

uint64_t sub_100274C84(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  char v6 = *(unsigned char *)(a2 + 40);
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 40) = v6;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  sub_10005C928((void *)(a1 + 48), *(const void **)(a2 + 48), *(void *)(a2 + 56), *(void *)(a2 + 56) - *(void *)(a2 + 48));
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  return a1;
}

void sub_100274D0C(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 32);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100274D30(uint64_t a1)
{
  *(void *)a1 = off_1019D3880;
  *(void *)a1 = off_1019D3880;
  *(void *)(a1 + 16) = &unk_1019D38E8;
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
  uint64_t v4 = (void **)(a1 + 32);
  sub_100274E3C(&v4);
  return a1;
}

void sub_100274E3C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 7;
        sub_100274EC0(v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100274EC0(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  int v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
}

void *sub_100274F18(void *a1)
{
  *a1 = off_1019D3988;
  *a1 = off_1019D3988;
  a1[2] = &unk_1019D39F0;
  uint64_t v2 = (void *)a1[10];
  if (v2)
  {
    a1[11] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_10027500C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)a1 = *a2;
  *(void *)(a1 + *(void *)(v3 - 48)) = a2[5];
  *(void *)(a1 + 16) = a2[6];
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 176);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  uint64_t v5 = *(void **)(a1 + 112);
  if (v5)
  {
    *(void *)(a1 + 120) = v5;
    operator delete(v5);
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  char v6 = *(void **)(a1 + 56);
  if (v6)
  {
    *(void *)(a1 + 64) = v6;
    operator delete(v6);
  }
  return a1;
}

uint64_t sub_100275134(uint64_t a1)
{
  *(void *)a1 = off_1019B1738;
  sub_10012577C((const void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100275184(uint64_t a1)
{
  *(void *)a1 = off_1019B1738;
  sub_10012577C((const void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

char *sub_1002751F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  uint64_t v3 = v2;
  *(void *)uint64_t v2 = off_1019B1738;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 24);
  *((void *)v2 + 3) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_10012A394((const void **)v2 + 4, (const void **)(a1 + 32));
  return v3;
}

const void **sub_10027526C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B1738;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_10012A394((const void **)(a2 + 32), (const void **)(a1 + 32));
}

void sub_1002752B8(uint64_t a1)
{
}

void sub_1002752C0(void *a1)
{
  sub_10026E570((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1002752FC(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    char v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      long long v7 = v6;
      if (a1[2])
      {
        uint64_t v8 = *(void *)(v5 + 144);
        uint64_t v9 = 0;
        (*(void (**)(uint64_t, void *, uint64_t, BOOL, const void **, uint64_t))(*(void *)v8 + 64))(v8, a1 + 4, 16, v4 != 0, &v9, 1);
        sub_100057D78(&v9);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1002753A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1002753C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100275400()
{
}

void sub_10027540C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B17B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10027542C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B17B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100275488(void *a1)
{
  *a1 = off_1019B1808;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1002754D4(void *a1)
{
  *a1 = off_1019B1808;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100275540(void *a1)
{
  __n128 result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  void *result = off_1019B1808;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_1002755A4(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_1019B1808;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_1002755E4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1002755F4(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100275634(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 24);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100275754(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100275794()
{
}

void sub_1002757A0(uint64_t **a1)
{
  uint64_t v1 = **a1;
  int v2 = *((unsigned __int8 *)*a1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
  *(unsigned char *)(v1 + 452) = 0;
  uint64_t v3 = *(NSObject **)(v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "success";
    if (!v2) {
      uint64_t v4 = "failure";
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Location popup complete with %s", buf, 0xCu);
  }
  if (!v2)
  {
    uint64_t v5 = *(std::__shared_weak_count **)(v1 + 88);
    if (v5)
    {
      char v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        long long v7 = v6;
        uint64_t v8 = *(void *)(v1 + 80);
        if (v8)
        {
          *(_DWORD *)std::string buf = 8;
          LOBYTE(v10) = 0;
          BYTE2(v10) = 0;
          BYTE4(v10) = 1;
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v8 + 40))(v8, buf);
        }
        sub_10004D2C8(v7);
      }
    }
  }
  operator delete();
}

void sub_100275900()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_100275940()
{
}

void *sub_100275954(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B1888;
  result[1] = v3;
  return result;
}

uint64_t sub_10027599C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B1888;
  a2[1] = v2;
  return result;
}

void sub_1002759C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 184);
  *(void *)(v1 + 176) = 0;
  *(void *)(v1 + 184) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(NSObject **)(v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Non emergency use cases satisfy off grid criteria", v4, 2u);
  }
  *(unsigned char *)(v1 + 426) = 1;
  sub_10025BAD4(v1);
}

uint64_t sub_100275A4C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100275A8C()
{
}

void sub_100275A9C()
{
}

void *sub_100275AB0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B1908;
  result[1] = v3;
  return result;
}

uint64_t sub_100275AF8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B1908;
  a2[1] = v2;
  return result;
}

void sub_100275B24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 200);
  *(void *)(v1 + 192) = 0;
  *(void *)(v1 + 200) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(NSObject **)(v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Emergency use cases satisfy off grid criteria", v4, 2u);
  }
  *(unsigned char *)(v1 + 427) = 1;
  sub_10025BAD4(v1);
}

uint64_t sub_100275BA8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100275BE8()
{
}

void sub_100275BF8()
{
}

void *sub_100275C0C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B1988;
  result[1] = v3;
  return result;
}

uint64_t sub_100275C54(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B1988;
  a2[1] = v2;
  return result;
}

void sub_100275C80(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 168);
  *(void *)(v1 + 160) = 0;
  *(void *)(v1 + 168) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 32));
  if (*(_WORD *)(v1 + 416))
  {
    uint64_t v3 = *(NSObject **)(v1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 134217984;
      uint64_t v5 = 10;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Handover timer expired (after %lld seconds)", (uint8_t *)&v4, 0xCu);
    }
    sub_10026A770(v1, 1);
  }
}

uint64_t sub_100275D4C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100275D8C()
{
}

void sub_100275D9C()
{
}

void *sub_100275DB0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B1A08;
  result[1] = v3;
  return result;
}

uint64_t sub_100275DF8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B1A08;
  a2[1] = v2;
  return result;
}

void sub_100275E24(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v2 = v1[6];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [Timer expired] Emergency conversation is no longer eligible for resume", v4, 2u);
  }
  uint64_t v3 = (std::__shared_weak_count *)v1[27];
  v1[26] = 0;
  v1[27] = 0;
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10025CE9C((uint64_t)v1);
}

uint64_t sub_100275EA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100275EE0()
{
}

void sub_100275EF0()
{
}

__n128 sub_100275F04(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019B1A88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100275F50(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B1A88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100275F80(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 16);
    int v6 = 134217984;
    uint64_t v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [Timer expired] Roadside conversation is no longer eligible for resume for providerId: %llu", (uint8_t *)&v6, 0xCu);
  }
  if (*(unsigned char *)(v2 + 256))
  {
    uint64_t v5 = *(std::__shared_weak_count **)(v2 + 240);
    if (v5) {
      sub_10004D2C8(v5);
    }
    *(unsigned char *)(v2 + 256) = 0;
  }
  sub_10025CE9C(v2);
}

uint64_t sub_10027604C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10027608C()
{
}

void sub_100276098(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1B08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002760B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1B08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100276114(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1B58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100276134(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B1B58;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100276188(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }

  return sub_10003B34C((void *)(a1 + 24));
}

void *sub_1002761F0(void *a1)
{
  *a1 = off_1019B1BA8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10027623C(void *a1)
{
  *a1 = off_1019B1BA8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1002762A8(uint64_t a1)
{
  __n128 result = (char *)operator new(0x28uLL);
  *(void *)__n128 result = off_1019B1BA8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *((_WORD *)result + 16) = *(_WORD *)(a1 + 32);
  return result;
}

uint64_t sub_100276314(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B1BA8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(_WORD *)(a2 + 32) = *(_WORD *)(result + 32);
  return result;
}

void sub_10027635C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10027636C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1002763AC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 24);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_1002764CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10027650C()
{
}

void sub_100276518(uint64_t **a1)
{
  long long v18 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  uint64_t v3 = *(void *)(v2 + 872);
  if (v3)
  {
    unsigned int v4 = *((unsigned __int16 *)v1 + 4);
    uint64_t v5 = v2 + 872;
    do
    {
      unsigned int v6 = *(unsigned __int16 *)(v3 + 32);
      BOOL v7 = v6 >= v4;
      if (v6 >= v4) {
        uint64_t v8 = (uint64_t *)v3;
      }
      else {
        uint64_t v8 = (uint64_t *)(v3 + 8);
      }
      if (v7) {
        uint64_t v5 = v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 != v2 + 872 && v4 >= *(unsigned __int16 *)(v5 + 32))
    {
      unint64_t v9 = *(void *)(v5 + 40);
      if (v9 < 2)
      {
        int v13 = *(NSObject **)(v2 + 48);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315138;
          long long v20 = sub_100BC87FC(v4);
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Destroyed ForceEnableDataPathAssertion for service: %s [count: 0]", buf, 0xCu);
        }
        uint64_t v14 = *(void **)(v5 + 8);
        if (v14)
        {
          do
          {
            uint64_t v15 = v14;
            uint64_t v14 = (void *)*v14;
          }
          while (v14);
        }
        else
        {
          char v16 = (void *)v5;
          do
          {
            uint64_t v15 = (void *)v16[2];
            BOOL v17 = *v15 == (void)v16;
            char v16 = v15;
          }
          while (!v17);
        }
        if (*(void *)(v2 + 864) == v5) {
          *(void *)(v2 + 864) = v15;
        }
        --*(void *)(v2 + 880);
        sub_10005EE6C(*(uint64_t **)(v2 + 872), (uint64_t *)v5);
        operator delete((void *)v5);
        *(_WORD *)(v2 + 418) &= ~*((_WORD *)v1 + 4);
        sub_10025BAD4(v2);
      }
      else
      {
        unint64_t v10 = v9 - 1;
        *(void *)(v5 + 40) = v9 - 1;
        int v11 = *(NSObject **)(v2 + 48);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v12 = sub_100BC87FC(*((unsigned __int16 *)v1 + 4));
          *(_DWORD *)std::string buf = 136315394;
          long long v20 = v12;
          __int16 v21 = 2048;
          unint64_t v22 = v10;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Decrement ForceEnableDataPathAssertion count for service: %s [updated count: %llu]", buf, 0x16u);
        }
      }
    }
  }
  operator delete();
}

void sub_10027672C()
{
}

uint64_t *sub_100276758(uint64_t a1)
{
  sub_100C62700(a1, "kRadioEnhancedLQMQuery", (unint64_t)sub_100276810, 3u);
  sub_100C62700(a1, "kRadioEnhancedLQMRegister", (unint64_t)sub_100276A8C, 3u);
  sub_100C62700(a1, "kRadioEnhancedLQMSendTrafficInfo", (unint64_t)sub_10002FDD4, 3u);

  return sub_100C62700(a1, "kRadioEnhancedLQMGetSupportedMetrics", (unint64_t)sub_100277394, 3u);
}

void sub_100276810(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    unint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v23 = v9;
  int v13 = sub_10004D37C(&v8[1].__m_.__sig, &v23);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_7;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15)
  {
LABEL_7:
    xpc_object_t v25 = xpc_int64_create(45);
    if (!v25) {
      xpc_object_t v25 = xpc_null_create();
    }
    unint64_t v23 = *a5;
    std::string v24 = "kError";
    sub_100035E70((uint64_t)&v23, &v25, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v25);
    xpc_object_t v25 = 0;
    if (v16) {
      return;
    }
LABEL_19:
    sub_10004D2C8(v14);
    return;
  }
LABEL_13:
  if (xpc_dictionary_get_value(*a4, "kRadioEnhancedLQMQueryPayload"))
  {
    unint64_t v23 = (unint64_t)a4;
    std::string v24 = "kRadioEnhancedLQMQueryPayload";
    sub_100048BAC((uint64_t)&v23, &v22);
    xpc::dyn_cast_or_default((xpc *)&v22, 0, v17);
    xpc_release(v22);
    long long v18 = (std::__shared_weak_count *)a5[1];
    v20[1] = (xpc_object_t)*a5;
    __int16 v21 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    EnhancedLQMInterface::query();
    if (v21) {
      sub_10004D2C8(v21);
    }
    if ((v16 & 1) == 0) {
      goto LABEL_19;
    }
  }
  else
  {
    xpc_object_t v19 = xpc_int64_create(22);
    if (!v19) {
      xpc_object_t v19 = xpc_null_create();
    }
    unint64_t v23 = *a5;
    std::string v24 = "kError";
    sub_100035E70((uint64_t)&v23, &v19, v20);
    xpc_release(v20[0]);
    v20[0] = 0;
    xpc_release(v19);
    xpc_object_t v19 = 0;
    if ((v16 & 1) == 0) {
      goto LABEL_19;
    }
  }
}

void sub_100276A40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, xpc_object_t object)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100276A8C(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    unint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v61 = v9;
  int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v61);
  if (!v13)
  {
    char v15 = 0;
LABEL_11:
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v48 = 1;
    if (!v15) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  char v15 = (EnhancedLQMInterface *)v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v48 = 0;
  if (!v15)
  {
LABEL_7:
    xpc_object_t v59 = xpc_int64_create(45);
    if (!v59) {
      xpc_object_t v59 = xpc_null_create();
    }
    *(void *)&long long v61 = *a5;
    *((void *)&v61 + 1) = "kError";
    sub_100035E70((uint64_t)&v61, &v59, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v59);
    xpc_object_t v59 = 0;
    goto LABEL_52;
  }
LABEL_12:
  xpc_object_t v58 = 0;
  *(void *)&long long v61 = a4;
  *((void *)&v61 + 1) = "kRadioEnhancedLQMRegisterSupportedMetrics";
  sub_10000CB28((uint64_t)&v61, &v58);
  if (xpc_get_type(v58) == (xpc_type_t)&_xpc_type_dictionary)
  {
    long long v61 = 0uLL;
    uint64_t v62 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v61;
    uint64_t v54 = v62;
    unint64_t v23 = (xpc_object_t *)v61;
    if (v62 >= 0) {
      unint64_t v23 = __p;
    }
    unsigned __int8 v55 = &v58;
    unsigned int v56 = v23;
    sub_100048BAC((uint64_t)&v55, &v57);
    char v47 = xpc::dyn_cast_or_default((xpc *)&v57, 0, v24);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(__p[0]);
    }
    long long v61 = 0uLL;
    uint64_t v62 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v61;
    uint64_t v54 = v62;
    xpc_object_t v25 = (xpc_object_t *)v61;
    if (v62 >= 0) {
      xpc_object_t v25 = __p;
    }
    unsigned __int8 v55 = &v58;
    unsigned int v56 = v25;
    sub_100048BAC((uint64_t)&v55, &v57);
    char v27 = xpc::dyn_cast_or_default((xpc *)&v57, 0, v26);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(__p[0]);
    }
    long long v61 = 0uLL;
    uint64_t v62 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v61;
    uint64_t v54 = v62;
    BOOL v28 = (xpc_object_t *)v61;
    if (v62 >= 0) {
      BOOL v28 = __p;
    }
    unsigned __int8 v55 = &v58;
    unsigned int v56 = v28;
    sub_100048BAC((uint64_t)&v55, &v57);
    char v30 = xpc::dyn_cast_or_default((xpc *)&v57, 0, v29);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(__p[0]);
    }
    long long v61 = 0uLL;
    uint64_t v62 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v61;
    uint64_t v54 = v62;
    int v31 = (xpc_object_t *)v61;
    if (v62 >= 0) {
      int v31 = __p;
    }
    unsigned __int8 v55 = &v58;
    unsigned int v56 = v31;
    sub_100048BAC((uint64_t)&v55, &v57);
    char v33 = xpc::dyn_cast_or_default((xpc *)&v57, 0, v32);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(__p[0]);
    }
    long long v61 = 0uLL;
    uint64_t v62 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v61;
    uint64_t v54 = v62;
    int v34 = (xpc_object_t *)v61;
    if (v62 >= 0) {
      int v34 = __p;
    }
    unsigned __int8 v55 = &v58;
    unsigned int v56 = v34;
    sub_100048BAC((uint64_t)&v55, &v57);
    char v36 = xpc::dyn_cast_or_default((xpc *)&v57, 0, v35);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(__p[0]);
    }
    long long v61 = 0uLL;
    uint64_t v62 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v61;
    uint64_t v54 = v62;
    uint64_t v37 = (xpc_object_t *)v61;
    if (v62 >= 0) {
      uint64_t v37 = __p;
    }
    unsigned __int8 v55 = &v58;
    unsigned int v56 = v37;
    sub_100048BAC((uint64_t)&v55, &v57);
    char v39 = xpc::dyn_cast_or_default((xpc *)&v57, 0, v38);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(__p[0]);
    }
    long long v61 = 0uLL;
    uint64_t v62 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v61;
    uint64_t v54 = v62;
    uint64_t v40 = (xpc_object_t *)v61;
    if (v62 >= 0) {
      uint64_t v40 = __p;
    }
    unsigned __int8 v55 = &v58;
    unsigned int v56 = v40;
    sub_100048BAC((uint64_t)&v55, &v57);
    char v42 = xpc::dyn_cast_or_default((xpc *)&v57, 0, v41);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(__p[0]);
    }
    long long v61 = 0uLL;
    uint64_t v62 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v61;
    uint64_t v54 = v62;
    int v43 = (xpc_object_t *)v61;
    if (v62 >= 0) {
      int v43 = __p;
    }
    unsigned __int8 v55 = &v58;
    unsigned int v56 = v43;
    sub_100048BAC((uint64_t)&v55, &v57);
    char v45 = xpc::dyn_cast_or_default((xpc *)&v57, 0, v44);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    if (SHIBYTE(v54) < 0) {
      operator delete(__p[0]);
    }
    char v46 = EnhancedLQMInterface::registerForNotifications(v15, v47, v27, v30, v33, v36, v39, v42, v45);
    xpc_object_t v51 = xpc_BOOL_create(v46);
    if (!v51) {
      xpc_object_t v51 = xpc_null_create();
    }
    *(void *)&long long v61 = *a5;
    *((void *)&v61 + 1) = "kDidSucceed";
    sub_100035E70((uint64_t)&v61, &v51, &v52);
    xpc_release(v52);
    xpc_object_t v52 = 0;
    xpc_release(v51);
    xpc_object_t v51 = 0;
  }
  else
  {
    *(void *)&long long v61 = a4;
    *((void *)&v61 + 1) = "kRadioEnhancedLQMRegisterLinkState";
    sub_100048BAC((uint64_t)&v61, __p);
    __int16 v17 = xpc::dyn_cast_or_default((xpc *)__p, 0, v16);
    xpc_release(__p[0]);
    *(void *)&long long v61 = a4;
    *((void *)&v61 + 1) = "kRadioEnhancedLQMRegisterLinkQualityFingerPrint";
    sub_100048BAC((uint64_t)&v61, __p);
    __int16 v19 = xpc::dyn_cast_or_default((xpc *)__p, 0, v18);
    xpc_release(__p[0]);
    *(void *)&long long v61 = a4;
    *((void *)&v61 + 1) = "kRadioEnhancedLQMRegisterTrafficClass";
    sub_100048BAC((uint64_t)&v61, __p);
    __int16 v21 = xpc::dyn_cast_or_default((xpc *)__p, 0, v20);
    xpc_release(__p[0]);
    char v22 = EnhancedLQMInterface::registerForNotifications(v15, v17 != 0, v19 != 0, v21 != 0, 0, 0, 0, 0, 0);
    xpc_object_t v49 = xpc_BOOL_create(v22);
    if (!v49) {
      xpc_object_t v49 = xpc_null_create();
    }
    *(void *)&long long v61 = *a5;
    *((void *)&v61 + 1) = "kDidSucceed";
    sub_100035E70((uint64_t)&v61, &v49, &v50);
    xpc_release(v50);
    xpc_object_t v50 = 0;
    xpc_release(v49);
    xpc_object_t v49 = 0;
  }
  xpc_release(v58);
LABEL_52:
  if ((v48 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1002771BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,xpc_object_t a24,xpc_object_t object)
{
  xpc_release(object);
  if ((a11 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  _Unwind_Resume(a1);
}

void sub_100277384()
{
}

void sub_100277394(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  BOOL v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  v18[0] = v8;
  unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, v18);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_11:
    std::mutex::unlock(v7);
    int v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v14 = v12[3];
  int v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (!v14)
  {
LABEL_7:
    xpc_object_t v19 = xpc_int64_create(45);
    if (!v19) {
      xpc_object_t v19 = xpc_null_create();
    }
    v18[0] = *a5;
    v18[1] = (unint64_t)"kError";
    sub_100035E70((uint64_t)v18, &v19, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v19);
    xpc_object_t v19 = 0;
    goto LABEL_16;
  }
LABEL_12:
  int v16 = (std::__shared_weak_count *)a5[1];
  __int16 v17 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  EnhancedLQMInterface::query();
  if (v17) {
    sub_10004D2C8(v17);
  }
LABEL_16:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_10027750C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100277534()
{
  return sub_100C624B8((uint64_t)&unk_101B0CA18, (uint64_t)sub_100276758);
}

uint64_t sub_100277550(void *a1)
{
  uint64_t v3 = (void *)*a1;
  uint64_t v1 = a1 + 1;
  uint64_t v2 = v3;
  if (v3 == v1) {
    return 1;
  }
  do
  {
    int v4 = *((unsigned __int8 *)v2 + 58) | *((unsigned __int8 *)v2 + 59);
    BOOL v5 = v4 == 0;
    if (v4) {
      break;
    }
    unsigned int v6 = (void *)v2[1];
    if (v6)
    {
      do
      {
        BOOL v7 = v6;
        unsigned int v6 = (void *)*v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        BOOL v7 = (void *)v2[2];
        BOOL v8 = *v7 == (void)v2;
        uint64_t v2 = v7;
      }
      while (!v8);
    }
    uint64_t v2 = v7;
  }
  while (v7 != v1);
  return v5;
}

void *sub_1002775BC(void *a1)
{
  *a1 = off_1019B1EC0;
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void *sub_10027763C(void *a1, NSObject **a2, uint64_t a3)
{
  unsigned int v6 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "cu.policy.ne");
  sub_10027774C(v6, a2, &v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *a1 = off_1019B1EC0;
  sub_1002785E8((Registry **)a3, a1 + 6);
  sub_100278758((Registry **)a3, a1 + 8);
  a1[10] = *(void *)a3;
  uint64_t v7 = *(void *)(a3 + 8);
  a1[11] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_10027770C(_Unwind_Exception *a1)
{
  int v4 = *(std::__shared_weak_count **)(v1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 40));
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void *sub_10027774C(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  BOOL v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_1002777B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void sub_1002777D8(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  uint64_t v44 = a4 + 8;
  *(void *)a4 = a4 + 8;
  uint64_t v47 = *(unsigned __int8 *)(a2 + 24);
  uint64_t v7 = *(unsigned __int8 *)(a2 + 25);
  uint64_t v48 = *(unsigned __int8 *)(a2 + 26);
  int v8 = *(unsigned __int8 *)(a2 + 27);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)a1[10]);
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    unsigned int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v53 = v11;
  char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)v53);
  unsigned int v45 = a3;
  if (v15)
  {
    uint64_t v17 = v15[3];
    int v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      a3 = a3;
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  int v16 = 0;
  char v18 = 1;
LABEL_9:
  int v19 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 72))(v17);
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  if (!v19) {
    goto LABEL_15;
  }
  if (v7 && !v47)
  {
    uint64_t v47 = 0;
LABEL_15:
    uint64_t v48 = 0;
LABEL_16:
    int v8 = 1;
    goto LABEL_17;
  }
  if (v8 && v48 == 2)
  {
    uint64_t v7 = 1;
    uint64_t v47 = 2;
    uint64_t v48 = 2;
    goto LABEL_16;
  }
LABEL_17:
  int v20 = *(void ***)a2;
  __int16 v21 = *(void ***)(a2 + 8);
  if (*(void ***)a2 != v21)
  {
    do
    {
      if (*((char *)v20 + 23) < 0)
      {
        if (!v20[1])
        {
LABEL_49:
          int v34 = a1[5];
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v53 = 0;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#E Found empty bundle id while adding cellular data usage rule", v53, 2u);
          }
          goto LABEL_75;
        }
      }
      else if (!*((unsigned char *)v20 + 23))
      {
        goto LABEL_49;
      }
      *(_OWORD *)std::string __p = 0u;
      long long v56 = 0u;
      *(_OWORD *)uint64_t v53 = 0u;
      long long v54 = 0u;
      (*(void (**)(uint8_t *__return_ptr, void *, void **, uint64_t))(*a1 + 192))(v53, a1, v20, 1);
      if (v7)
      {
        char v22 = (std::__shared_weak_count *)a1[9];
        uint64_t v51 = a1[8];
        xpc_object_t v52 = v22;
        if (v22) {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v23 = (*(uint64_t (**)(void *, uint64_t *, void **, uint64_t, uint64_t))(*a1 + 176))(a1, &v51, v20, v47, a3);
        if (v52) {
          sub_10004D2C8(v52);
        }
        BOOL v24 = a1[5];
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          xpc_object_t v25 = v20;
          if (*((char *)v20 + 23) < 0) {
            xpc_object_t v25 = *v20;
          }
          BOOL v26 = "???";
          if (v47 <= 2) {
            BOOL v26 = off_1019B21D0[(char)v47];
          }
          *(_DWORD *)std::string buf = 136446722;
          char v27 = "false";
          if (v23) {
            char v27 = "true";
          }
          *(void *)&uint8_t buf[4] = v25;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v26;
          *(_WORD *)&unsigned char buf[22] = 2080;
          long long v61 = v27;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Setting cellular network data usage policy for bundleID: %{public}s, policy: %s, changed: %s", buf, 0x20u);
        }
        if (!v8)
        {
LABEL_52:
          int v29 = 0;
          if (v23) {
            goto LABEL_54;
          }
          goto LABEL_53;
        }
      }
      else
      {
        LOBYTE(v23) = 0;
        if (!v8) {
          goto LABEL_52;
        }
      }
      BOOL v28 = (std::__shared_weak_count *)a1[7];
      uint64_t v49 = a1[6];
      xpc_object_t v50 = v28;
      if (v28) {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v29 = (*(uint64_t (**)(void *, uint64_t *, void **, uint64_t, uint64_t))(*a1 + 176))(a1, &v49, v20, v48, a3);
      if (v50) {
        sub_10004D2C8(v50);
      }
      char v30 = a1[5];
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        int v31 = v20;
        if (*((char *)v20 + 23) < 0) {
          int v31 = *v20;
        }
        BOOL v32 = "???";
        if (v48 <= 2) {
          BOOL v32 = off_1019B21D0[(char)v48];
        }
        *(_DWORD *)std::string buf = 136446722;
        char v33 = "false";
        if (v29) {
          char v33 = "true";
        }
        *(void *)&uint8_t buf[4] = v31;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v32;
        *(_WORD *)&unsigned char buf[22] = 2080;
        long long v61 = v33;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Setting WiFi network data usage policy for bundleID: %{public}s, policy: %s, changed: %s", buf, 0x20u);
      }
      if (v23)
      {
LABEL_54:
        uint64_t v59 = 0;
        BOOL v35 = (char *)operator new(0x40uLL);
        xpc_object_t v57 = (void **)v35;
        uint64_t v58 = v44;
        LOBYTE(v59) = 0;
        if (*((char *)v20 + 23) < 0)
        {
          sub_10004FC84(buf, *v20, (unint64_t)v20[1]);
        }
        else
        {
          long long v36 = *(_OWORD *)v20;
          *(void *)&uint8_t buf[16] = v20[2];
          *(_OWORD *)std::string buf = v36;
        }
        uint64_t v37 = v35 + 32;
        uint64_t v38 = v7;
        if (v7) {
          char v39 = v47;
        }
        else {
          char v39 = BYTE8(v54);
        }
        if (v8) {
          char v40 = v48;
        }
        else {
          char v40 = BYTE9(v54);
        }
        if ((buf[23] & 0x80000000) != 0)
        {
          sub_10004FC84(v37, *(void **)buf, *(unint64_t *)&buf[8]);
          int v41 = buf[23];
          v35[56] = v39;
          v35[57] = v40;
          v35[58] = v23;
          v35[59] = v29;
          if (v41 < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          *(_OWORD *)uint64_t v37 = *(_OWORD *)buf;
          *((void *)v35 + 6) = *(void *)&buf[16];
          v35[56] = v39;
          v35[57] = v40;
          v35[58] = v23;
          v35[59] = v29;
        }
        LOBYTE(v59) = 1;
        *(void *)std::string buf = 0;
        a3 = v45;
        char v42 = (uint64_t **)sub_100046ED4(a4, buf, v57 + 4);
        uint64_t v7 = v38;
        if (*v42)
        {
          int v43 = v57;
          xpc_object_t v57 = 0;
          if (v43) {
            sub_1000C6EE8((uint64_t)&v58, v43);
          }
        }
        else
        {
          sub_100046C38((uint64_t **)a4, *(uint64_t *)buf, v42, (uint64_t *)v57);
        }
        goto LABEL_71;
      }
LABEL_53:
      if (v29) {
        goto LABEL_54;
      }
LABEL_71:
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (SBYTE7(v54) < 0) {
        operator delete(*(void **)v53);
      }
LABEL_75:
      v20 += 3;
    }
    while (v20 != v21);
  }
}

void sub_100277DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  sub_10005CD2C(a18, *(char **)(a18 + 8));
  _Unwind_Resume(a1);
}

void sub_100277EB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = a1;
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  uint64_t v13 = 0;
  sub_1000302C0((char *)&v11, *(long long **)a2, *(long long **)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  int v14 = *(_DWORD *)(a2 + 24);
  sub_1000E725C((uint64_t)v15, a3);
  uint64_t v17 = 0;
  unsigned int v6 = operator new(0x50uLL);
  uint64_t v8 = v10;
  uint64_t v7 = v11;
  *(void *)unsigned int v6 = off_1019B20D0;
  *((void *)v6 + 1) = v8;
  *((void *)v6 + 2) = 0;
  *((void *)v6 + 3) = 0;
  *((void *)v6 + 4) = 0;
  sub_1000302C0((char *)v6 + 16, v7, v12, 0xAAAAAAAAAAAAAAABLL * (((char *)v12 - (char *)v7) >> 3));
  *((_DWORD *)v6 + 10) = v14;
  sub_1000EC8E8((uint64_t)v6 + 48, (uint64_t)v15);
  uint64_t v17 = v6;
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 160))(a1, v16);
  sub_100278CB4(v16);
  sub_1000E0D60(v15);
  OsLogContext v9 = &v11;
  sub_100047F64((void ***)&v9);
}

void sub_10027801C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  sub_100278CB4((uint64_t *)va1);
  sub_10027806C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10027806C(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 40));
  uint64_t v3 = (void **)(a1 + 8);
  sub_100047F64(&v3);
  return a1;
}

void sub_1002780B0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = 0;
  char v18 = 0;
  uint64_t v19 = 0;
  sub_1002777D8(a1, a2, 2, (uint64_t)&v17);
  if (!*(unsigned char *)(a4 + 24))
  {
    sub_1000DB02C((uint64_t *)a4, (uint64_t)&v17);
    *(unsigned char *)(a4 + 24) = 1;
  }
  if (sub_100277550((void *)a4))
  {
    v16[0] = 0;
    v16[1] = 0;
    char v15 = v16;
    sub_1000D2234(a3, (uint64_t)&v15, 1);
    sub_10005CD2C((uint64_t)&v15, v16[0]);
  }
  else
  {
    int v20 = a1;
    __int16 v21 = 0;
    char v22 = 0;
    uint64_t v23 = 0;
    sub_1000302C0((char *)&v21, *(long long **)a2, *(long long **)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
    int v24 = *(_DWORD *)(a2 + 24);
    sub_100278584((uint64_t)&v25, a4);
    sub_1000E725C((uint64_t)v29, a3);
    int v31 = 0;
    uint64_t v8 = (char *)operator new(0x70uLL);
    uint64_t v10 = v20;
    uint64_t v9 = v21;
    *(void *)uint64_t v8 = off_1019B2160;
    *((void *)v8 + 1) = v10;
    *((void *)v8 + 2) = 0;
    *((void *)v8 + 3) = 0;
    *((void *)v8 + 4) = 0;
    sub_1000302C0(v8 + 16, v9, v22, 0xAAAAAAAAAAAAAAABLL * (((char *)v22 - (char *)v9) >> 3));
    *((_DWORD *)v8 + 10) = v24;
    v8[48] = 0;
    v8[72] = 0;
    if (v28)
    {
      uint64_t v12 = v25;
      uint64_t v11 = v26;
      *((void *)v8 + 7) = v26;
      uint64_t v13 = v8 + 56;
      *((void *)v8 + 6) = v12;
      uint64_t v14 = v27;
      *((void *)v8 + 8) = v27;
      if (v14)
      {
        *((void *)v11 + 2) = v13;
        xpc_object_t v25 = &v26;
        BOOL v26 = 0;
        uint64_t v27 = 0;
      }
      else
      {
        *((void *)v8 + 6) = v13;
      }
      v8[72] = 1;
    }
    sub_1000EC8E8((uint64_t)(v8 + 80), (uint64_t)v29);
    int v31 = v8;
    (*(void (**)(void *, void *))(*a1 + 168))(a1, v30);
    sub_100278CB4(v30);
    sub_1000E0D60(v29);
    if (v28) {
      sub_10005CD2C((uint64_t)&v25, v26);
    }
    char v15 = (char **)&v21;
    sub_100047F64((void ***)&v15);
  }
  sub_10005CD2C((uint64_t)&v17, v18);
}

void sub_100278314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char *a13)
{
}

uint64_t sub_1002783AC(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 72));
  if (*(unsigned char *)(a1 + 64)) {
    sub_10005CD2C(a1 + 40, *(char **)(a1 + 48));
  }
  uint64_t v3 = (void **)(a1 + 8);
  sub_100047F64(&v3);
  return a1;
}

void sub_100278404(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_WORD *)(a3 + 26) = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48)) | 0x100;
  *(_WORD *)(a3 + 24) = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64)) | 0x100;
  if (a3 != a2) {
    sub_10005CA3C(a3, *(std::string **)a2, *(long long **)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  }
}

void sub_1002784CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

void *sub_1002784EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000E725C((uint64_t)v6, a3);
  sub_100277EB0(a1, a2, (uint64_t)v6);
  return sub_1000E0D60(v6);
}

void sub_100278568(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E0D60((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100278584(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    sub_1000DB02C((uint64_t *)a1, a2);
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_1002785C8(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24)) {
    sub_10005CD2C(v1, *(char **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002785E8@<X0>(Registry **a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x28uLL);
  __n128 result = sub_100278644(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100278630(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100278644(void *a1, Registry **a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019B2030;
  sub_10014F61C((uint64_t)(a1 + 3), a2);
  a1[3] = off_101A3AE50;
  return a1;
}

void sub_1002786A8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1002786BC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B2030;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002786DC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B2030;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100278730(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void *sub_100278758@<X0>(Registry **a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x28uLL);
  __n128 result = sub_1002787B4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1002787A0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1002787B4(void *a1, Registry **a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019B2080;
  sub_10014F61C((uint64_t)(a1 + 3), a2);
  a1[3] = off_1019C76B8;
  return a1;
}

void sub_100278818(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10027882C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B2080;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10027884C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B2080;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002788A0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

uint64_t sub_1002788C8(uint64_t a1)
{
  *(void *)a1 = off_1019B20D0;
  sub_1000E0D60((void *)(a1 + 48));
  uint64_t v3 = (void **)(a1 + 16);
  sub_100047F64(&v3);
  return a1;
}

void sub_100278924(uint64_t a1)
{
  *(void *)a1 = off_1019B20D0;
  sub_1000E0D60((void *)(a1 + 48));
  uint64_t v2 = (void **)(a1 + 16);
  sub_100047F64(&v2);
  operator delete();
}

void *sub_100278994(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x50uLL);
  *uint64_t v2 = off_1019B20D0;
  sub_100278C18((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1002789E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002789FC(uint64_t a1, void *a2)
{
  *a2 = off_1019B20D0;
  return sub_100278C18((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100278A28(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 48));
  uint64_t v2 = (void **)(a1 + 16);
  sub_100047F64(&v2);
}

void sub_100278A68(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 48));
  uint64_t v2 = (void **)(a1 + 16);
  sub_100047F64(&v2);
  operator delete((void *)a1);
}

void sub_100278AB0(uint64_t a1, unsigned char *a2)
{
  if (*a2 == 2)
  {
    uint64_t v3 = *(void **)(a1 + 8);
    sub_1000E725C((uint64_t)&v7, a1 + 48);
    v4[0] = 0;
    char v6 = 0;
    sub_1002780B0(v3, a1 + 16, (uint64_t)&v7, (uint64_t)v4);
    if (v6) {
      sub_10005CD2C((uint64_t)v4, v5);
    }
    sub_1000E0D60(&v7);
  }
  else
  {
    v8[0] = 0;
    v8[1] = 0;
    uint64_t v7 = v8;
    sub_1000D2234(a1 + 48, (uint64_t)&v7, 0);
    sub_10005CD2C((uint64_t)&v7, v8[0]);
  }
}

void sub_100278B88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  BOOL v5 = va_arg(va1, char *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  if ((_BYTE)v7) {
    sub_10005CD2C((uint64_t)va, v5);
  }
  sub_1000E0D60((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100278BCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100278C0C()
{
}

uint64_t sub_100278C18(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1000302C0((char *)(a1 + 8), *(long long **)(a2 + 8), *(long long **)(a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3));
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_1000E725C(a1 + 40, a2 + 40);
  return a1;
}

void sub_100278C9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

void *sub_100278CB4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100278D38(uint64_t a1)
{
  *(void *)a1 = off_1019B2160;
  sub_1000E0D60((void *)(a1 + 80));
  if (*(unsigned char *)(a1 + 72)) {
    sub_10005CD2C(a1 + 48, *(char **)(a1 + 56));
  }
  uint64_t v3 = (void **)(a1 + 16);
  sub_100047F64(&v3);
  return a1;
}

void sub_100278DA8(uint64_t a1)
{
  *(void *)a1 = off_1019B2160;
  sub_1000E0D60((void *)(a1 + 80));
  if (*(unsigned char *)(a1 + 72)) {
    sub_10005CD2C(a1 + 48, *(char **)(a1 + 56));
  }
  uint64_t v2 = (void **)(a1 + 16);
  sub_100047F64(&v2);
  operator delete();
}

void *sub_100278E2C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x70uLL);
  *uint64_t v2 = off_1019B2160;
  sub_1002790C8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100278E80(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100278E94(uint64_t a1, void *a2)
{
  *a2 = off_1019B2160;
  return sub_1002790C8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100278EC0(uint64_t a1)
{
}

void sub_100278EC8(void *a1)
{
  sub_100279190((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100278F04(uint64_t a1, unsigned char *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    if (v3 == 2)
    {
      uint64_t v5 = a1 + 80;
      sub_1000D2234(v5, a1 + 48, 1);
    }
    else if (v3 == 1)
    {
      uint64_t v4 = *(void **)(a1 + 8);
      sub_1000E725C((uint64_t)&v9, a1 + 80);
      sub_100278584((uint64_t)v6, a1 + 48);
      sub_1002780B0(v4, a1 + 16, (uint64_t)&v9, (uint64_t)v6);
      if (v8) {
        sub_10005CD2C((uint64_t)v6, v7);
      }
      sub_1000E0D60(&v9);
    }
  }
  else
  {
    v10[0] = 0;
    v10[1] = 0;
    uint64_t v9 = v10;
    sub_1000D2234(a1 + 80, (uint64_t)&v9, 0);
    sub_10005CD2C((uint64_t)&v9, v10[0]);
  }
}

void sub_100279030(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, char *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  if ((_BYTE)v7) {
    sub_10005CD2C((uint64_t)va, v5);
  }
  sub_1000E0D60((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10027907C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002790BC()
{
}

uint64_t sub_1002790C8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1000302C0((char *)(a1 + 8), *(long long **)(a2 + 8), *(long long **)(a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3));
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100278584(a1 + 40, a2 + 40);
  sub_1000E725C(a1 + 72, a2 + 72);
  return a1;
}

void sub_10027915C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(unsigned char *)(v2 + 64)) {
    sub_10005CD2C(v3, *(char **)(v2 + 48));
  }
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

void sub_100279190(uint64_t a1)
{
  sub_1000E0D60((void *)(a1 + 72));
  if (*(unsigned char *)(a1 + 64)) {
    sub_10005CD2C(a1 + 40, *(char **)(a1 + 48));
  }
  uint64_t v2 = (void **)(a1 + 8);
  sub_100047F64(&v2);
}

void sub_1002791E4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100279690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17, dispatch_object_t a18, void *a19, std::__shared_weak_count *a20,int a21,__int16 a22,char a23,char a24)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8))(__p);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  sub_10004D2C8(v24);
  _Unwind_Resume(a1);
}

void sub_100279850(unint64_t *a1, dispatch_object_t object)
{
  unint64_t v4 = a1[2];
  uint64_t v5 = (void *)a1[1];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = *a1;
    uint64_t v8 = (uint64_t)((uint64_t)v5 - *a1) >> 3;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      sub_10006A748();
    }
    uint64_t v10 = v4 - v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    __int16 v21 = a1 + 2;
    if (v11)
    {
      if (v11 >> 61) {
        sub_10006A7CC();
      }
      uint64_t v12 = (char *)operator new(8 * v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    uint64_t v13 = &v12[8 * v8];
    uint64_t v14 = &v12[8 * v11];
    int v20 = v14;
    *(void *)uint64_t v13 = object;
    if (object)
    {
      dispatch_retain(object);
      unint64_t v7 = *a1;
      uint64_t v5 = (void *)a1[1];
    }
    uint64_t v6 = v13 + 8;
    v19.i64[1] = (uint64_t)(v13 + 8);
    if (v5 == (void *)v7)
    {
      int64x2_t v16 = vdupq_n_s64(v7);
    }
    else
    {
      do
      {
        uint64_t v15 = *--v5;
        *((void *)v13 - 1) = v15;
        v13 -= 8;
        void *v5 = 0;
      }
      while (v5 != (void *)v7);
      int64x2_t v16 = *(int64x2_t *)a1;
      uint64_t v6 = (void *)v19.i64[1];
      uint64_t v14 = v20;
    }
    *a1 = (unint64_t)v13;
    a1[1] = (unint64_t)v6;
    int64x2_t v19 = v16;
    unint64_t v17 = a1[2];
    a1[2] = (unint64_t)v14;
    int v20 = (char *)v17;
    uint64_t v18 = v16.i64[0];
    sub_10027A9C4((uint64_t)&v18);
  }
  else
  {
    void *v5 = object;
    if (object) {
      dispatch_retain(object);
    }
    uint64_t v6 = v5 + 1;
  }
  a1[1] = (unint64_t)v6;
}

void sub_100279990(uint64_t a1)
{
  *(void *)a1 = off_1019B21F8;
  unint64_t v4 = (void **)(a1 + 80);
  sub_10027AA18(&v4);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  WatchdogRegistrationInterface::~WatchdogRegistrationInterface((WatchdogRegistrationInterface *)a1);
}

void sub_100279A28(uint64_t a1)
{
  sub_100279990(a1);

  operator delete();
}

void sub_100279A60(uint64_t a1, dispatch_object_t *a2, uint64_t a3)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    xpc_object_t __p[2] = *(void **)(a3 + 16);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100279BBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100279BDC(uint64_t a1, dispatch_object_t *a2, char *a3)
{
  uint64_t v6 = *(dispatch_object_t **)(a1 + 80);
  unint64_t v7 = *(dispatch_object_t **)(a1 + 88);
  uint64_t v5 = (unint64_t *)(a1 + 80);
  if (v6 == v7)
  {
    uint64_t v8 = *(dispatch_object_t **)(a1 + 80);
  }
  else
  {
    uint64_t v8 = *(dispatch_object_t **)(a1 + 80);
    while (*v8 != *a2)
    {
      if (++v8 == v7)
      {
        uint64_t v8 = *(dispatch_object_t **)(a1 + 88);
        break;
      }
    }
  }
  if (v8 != v7)
  {
    unint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (a3[23] < 0) {
        a3 = *(char **)a3;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = a3;
      uint64_t v10 = "%s's queue has already been added";
      unint64_t v11 = v9;
      uint32_t v12 = 12;
      goto LABEL_31;
    }
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v14 = ServiceMap;
  uint64_t v16 = v15;
  if (v15 < 0)
  {
    unint64_t v17 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v16;
  int v20 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
  if (v20)
  {
    uint64_t v22 = v20[3];
    __int16 v21 = (std::__shared_weak_count *)v20[4];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v53 = v21;
      sub_10004D2C8(v21);
      char v23 = 0;
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  std::mutex::unlock(v14);
  uint64_t v53 = 0;
  char v23 = 1;
LABEL_20:
  unint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 40))(v22);
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v53);
  }
  if (v7 - v6 < v24)
  {
    xpc_object_t v25 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    BOOL v26 = v25;
    if (v27 < 0)
    {
      char v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        uint64_t v27 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(v25);
    *(void *)std::string buf = v27;
    int v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
    if (v31)
    {
      uint64_t v32 = v31[3];
      char v33 = (std::__shared_weak_count *)v31[4];
      if (v33)
      {
        atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v26);
        atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v33);
        char v34 = 0;
LABEL_34:
        if (!*(unsigned char *)(a1 + 104) && v32 && (*(unsigned int (**)(uint64_t))(*(void *)v32 + 16))(v32))
        {
          long long v36 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v36 || (uint64_t v37 = *(void *)(a1 + 8), (v38 = std::__shared_weak_count::lock(v36)) == 0)) {
            sub_100088B9C();
          }
          char v39 = v38;
          atomic_fetch_add_explicit(&v38->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v38);
          Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 48));
          uint64_t v40 = *(void *)buf;
          sub_100058DB0(__p, "Watchdog queue add timer");
          int v41 = *(NSObject **)(a1 + 24);
          dispatch_object_t object = v41;
          if (v41) {
            dispatch_retain(v41);
          }
          aBlock[0] = _NSConcreteStackBlock;
          aBlock[1] = 1174405120;
          aBlock[2] = sub_10027A3A4;
          aBlock[3] = &unk_1019B2210;
          aBlock[4] = a1;
          void aBlock[5] = v37;
          unsigned __int8 v55 = v39;
          atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          char v42 = *a2;
          dispatch_object_t v56 = v42;
          if (v42) {
            dispatch_retain(v42);
          }
          if (a3[23] < 0)
          {
            sub_10004FC84(&v57, *(void **)a3, *((void *)a3 + 1));
          }
          else
          {
            long long v57 = *(_OWORD *)a3;
            uint64_t v58 = *((void *)a3 + 2);
          }
          uint64_t v59 = _Block_copy(aBlock);
          sub_10027A2C0(v40, (uint64_t)__p, 2, 60000000, &object, &v59);
          if (v59) {
            _Block_release(v59);
          }
          if (object) {
            dispatch_release(object);
          }
          if (v62 < 0) {
            operator delete(__p[0]);
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          if (SHIBYTE(v58) < 0) {
            operator delete((void *)v57);
          }
          if (v56) {
            dispatch_release(v56);
          }
          if (v55) {
            std::__shared_weak_count::__release_weak(v55);
          }
          std::__shared_weak_count::__release_weak(v39);
          if (v34) {
            return;
          }
          goto LABEL_61;
        }
        int v43 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
        uint64_t v44 = v43;
        if (v15 < 0)
        {
          unsigned int v45 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v46 = 5381;
          do
          {
            uint64_t v15 = v46;
            unsigned int v47 = *v45++;
            uint64_t v46 = (33 * v46) ^ v47;
          }
          while (v47);
        }
        std::mutex::lock(v43);
        *(void *)std::string buf = v15;
        uint64_t v48 = sub_10004D37C(&v44[1].__m_.__sig, (unint64_t *)buf);
        if (v48)
        {
          uint64_t v50 = v48[3];
          uint64_t v49 = (std::__shared_weak_count *)v48[4];
          if (v49)
          {
            atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v44);
            atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v49);
            char v51 = 0;
            goto LABEL_53;
          }
        }
        else
        {
          uint64_t v50 = 0;
        }
        std::mutex::unlock(v44);
        uint64_t v49 = 0;
        char v51 = 1;
LABEL_53:
        if (a3[23] < 0)
        {
          sub_10004FC84(buf, *(void **)a3, *((void *)a3 + 1));
        }
        else
        {
          *(_OWORD *)std::string buf = *(_OWORD *)a3;
          uint64_t v64 = *((void *)a3 + 2);
        }
        (*(void (**)(uint64_t, dispatch_object_t *, uint8_t *))(*(void *)v50 + 24))(v50, a2, buf);
        if (SHIBYTE(v64) < 0) {
          operator delete(*(void **)buf);
        }
        if ((v51 & 1) == 0) {
          sub_10004D2C8(v49);
        }
        sub_100279850(v5, *a2);
        if (v34) {
          return;
        }
LABEL_61:
        sub_10004D2C8(v33);
        return;
      }
    }
    else
    {
      uint64_t v32 = 0;
    }
    std::mutex::unlock(v26);
    char v33 = 0;
    char v34 = 1;
    goto LABEL_34;
  }
  BOOL v35 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    uint64_t v10 = "We have already added the max number of queues possible for watchdogd monitoring";
    unint64_t v11 = v35;
    uint32_t v12 = 2;
LABEL_31:
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
  }
}

void sub_10027A198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, dispatch_object_t object, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *aBlock,dispatch_object_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (object) {
    dispatch_release(object);
  }
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (a26) {
    dispatch_release(a26);
  }
  if (a32 < 0) {
    operator delete(__p);
  }
  uint64_t v37 = *(std::__shared_weak_count **)(v35 - 120);
  if (v37) {
    sub_10004D2C8(v37);
  }
  std::__shared_weak_count::__release_weak(v32);
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  _Unwind_Resume(a1);
}

void sub_10027A2C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, NSObject **a5, void **a6)
{
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  uint64_t v10 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v6 = *a5;
  *a5 = 0;
  aBlock = *a6;
  dispatch_object_t object = v6;
  *a6 = 0;
  (*(void (**)(uint64_t, void **, uint64_t, uint64_t, dispatch_object_t *, void **))(*(void *)a1 + 8))(a1, __p, a3, a4, &object, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10027A36C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10027A3A4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    unint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Watchdog queue add timer expired", buf, 2u);
        }
        unint64_t v7 = *(NSObject **)(a1 + 56);
        dispatch_object_t object = v7;
        if (v7) {
          dispatch_retain(v7);
        }
        if (*(char *)(a1 + 87) < 0)
        {
          sub_10004FC84(__p, *(void **)(a1 + 64), *(void *)(a1 + 72));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 64);
          uint64_t v9 = *(void *)(a1 + 80);
        }
        sub_100279BDC(v3, &object, __p);
        if (SHIBYTE(v9) < 0) {
          operator delete(__p[0]);
        }
        if (object) {
          dispatch_release(object);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10027A4A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

unsigned char *sub_10027A4D8(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(NSObject **)(a2 + 56);
  a1[7] = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  __n128 result = a1 + 8;
  if (*(char *)(a2 + 87) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  long long v7 = *(_OWORD *)(a2 + 64);
  a1[10] = *(void *)(a2 + 80);
  *(_OWORD *)__n128 result = v7;
  return result;
}

void sub_10027A550(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(NSObject **)(v1 + 56);
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 48);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_10027A574(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_10027A5D4(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10027A6D4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I =====DumpState for WatchdogRegistrationController======", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (!v9)
  {
    uint64_t v11 = 0;
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10)
  {
LABEL_10:
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
LABEL_11:
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (v11 && os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I DMIsMigrationNeeded = %d", buf, 8u);
    uint64_t v13 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = *(unsigned __int8 *)(a1 + 104);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I fActivateFailsafe = %d", buf, 8u);
    uint64_t v13 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I fQueuesRegistered:", buf, 2u);
  }
  uint64_t v16 = *(dispatch_queue_t **)(a1 + 80);
  for (uint64_t i = *(dispatch_queue_t **)(a1 + 88); v16 != i; ++v16)
  {
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      label = dispatch_queue_get_label(*v16);
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = label;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
    }
  }
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_10027A994(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10027A9C4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v5 = *(NSObject **)(v2 - 8);
    v2 -= 8;
    uint64_t v4 = v5;
    *(void *)(a1 + 16) = v2;
    if (v5)
    {
      dispatch_release(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10027AA18(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *((void *)v4 - 1);
        v4 -= 8;
        uint64_t v6 = v7;
        if (v7) {
          dispatch_release(v6);
        }
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10027AAA0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10027AAD8(uint64_t a1)
{
}

uint64_t sub_10027AAF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10027AB38(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10027AB64(ServiceManager::Service *this)
{
  *(void *)this = off_1019B2358;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10027ABC0(ServiceManager::Service *this)
{
  *(void *)this = off_1019B2358;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10027AC30@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "WatchdogRegistrationController");
}

unsigned char *sub_10027AC40@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10027AC80(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10027A5D4(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_10027A5D4(v4, 0);
}

uint64_t sub_10027AD04()
{
  return 0;
}

uint64_t sub_10027AD0C()
{
  return 1;
}

uint64_t sub_10027AD14()
{
  return 0;
}

void sub_10027AD20(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10027AE00(uint64_t result, int a2, ServiceStage *this)
{
  if (a2 == 2)
  {
    uint64_t v3 = *(void *)(result + 8);
    ServiceStage::holdOffStage((uint64_t *)&group[1], this);
    uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
    if (v4)
    {
      if (std::__shared_weak_count::lock(v4)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

uint64_t *sub_10027AF1C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v3 = *(void *)v1;
  uint64_t v2 = *(NSObject **)(v1 + 8);
  dispatch_object_t v9 = v2;
  if (v2) {
    dispatch_retain(v2);
  }
  if (*(char *)(v1 + 39) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 16), *(void *)(v1 + 24));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(v1 + 16);
    uint64_t v8 = *(void *)(v1 + 32);
  }
  sub_100279BDC(v3, &v9, (char *)__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  if (v9) {
    dispatch_release(v9);
  }
  sub_10027B000(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10027AFC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v18 = *(NSObject **)(v16 - 24);
  if (v18) {
    dispatch_release(v18);
  }
  sub_10027B000(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10027B000(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    uint64_t v2 = *(NSObject **)(v1 + 8);
    if (v2) {
      dispatch_release(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10027B064(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 64));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_10027B0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10027B0C8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(*(void *)v1 + 48));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100058DB0(&__p, "/cc/events/dump_state");
  uint64_t v3 = operator new(0x20uLL);
  *uint64_t v3 = off_1019B23D8;
  v3[1] = v2;
  void v3[2] = sub_10027A6D4;
  double v3[3] = 0;
  v11[3] = v3;
  ctu::RestModule::observeEvent();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10027B1D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10027B22C()
{
}

__n128 sub_10027B240(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019B23D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10027B294(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B23D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10027B2CC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10027B314(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10027B354()
{
}

void sub_10027B360(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 8);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v4);
      Registry::getTimerService(&v14, *(Registry **)(v1 + 48));
      uint64_t v6 = v14;
      sub_100058DB0(__p, "Watchdog failsafe activation timer");
      uint64_t v7 = *(NSObject **)(v1 + 24);
      dispatch_object_t object = v7;
      if (v7) {
        dispatch_retain(v7);
      }
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 1174405120;
      aBlock[2] = sub_10027B584;
      aBlock[3] = &unk_1019B2448;
      aBlock[4] = v1;
      void aBlock[5] = v3;
      dispatch_object_t v9 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      char v10 = _Block_copy(aBlock);
      sub_10027A2C0(v6, (uint64_t)__p, 2, 1800000000, &object, &v10);
      if (v10) {
        _Block_release(v10);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v13 < 0) {
        operator delete(__p[0]);
      }
      if (v15) {
        sub_10004D2C8(v15);
      }
      if (v9) {
        std::__shared_weak_count::__release_weak(v9);
      }
      std::__shared_weak_count::__release_weak(v5);
      operator delete();
    }
  }
  sub_100088B9C();
}

void sub_10027B4F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, void *aBlock, dispatch_object_t object, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a25 < 0) {
    operator delete(__p);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v26 - 56);
  if (v27) {
    sub_10004D2C8(v27);
  }
  std::__shared_weak_count::__release_weak(v25);
  operator delete();
}

void sub_10027B584(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Watchdog failsafe activation timer expired", v7, 2u);
        }
        *(unsigned char *)(v3 + 104) = 1;
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_10027B620(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10027B63C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

BOOL sub_10027B64C(NSObject ***a1)
{
  uint64_t v2 = (const __SCPreferences *)a1[1];
  uint64_t v3 = **a1;
  BOOL result = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (!v2)
  {
    if (!result) {
      return result;
    }
    LOWORD(v15) = 0;
    uint64_t v7 = "#E lock: fPrefs nullptr !";
    uint64_t v8 = v3;
    uint32_t v9 = 2;
    goto LABEL_18;
  }
  if (result)
  {
    LOWORD(v15) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I lockPreferences start...", (uint8_t *)&v15, 2u);
    uint64_t v2 = (const __SCPreferences *)a1[1];
  }
  if (SCPreferencesLock(v2, 1u))
  {
    int v5 = 0;
LABEL_6:
    uint64_t v6 = **a1;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 67109120;
      LODWORD(v16) = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I lockPreferences complete (attempt %u)", (uint8_t *)&v15, 8u);
    }
    BOOL result = 1;
    *((unsigned char *)a1 + 16) = 1;
    return result;
  }
  char v10 = 1;
  int v5 = 1;
  while (SCError() == 3005)
  {
    SCPreferencesSynchronize((SCPreferencesRef)a1[1]);
    if ((v10 & 1) == 0) {
      break;
    }
    char v10 = 0;
    if (SCPreferencesLock((SCPreferencesRef)a1[1], 1u)) {
      goto LABEL_6;
    }
  }
  uint64_t v11 = **a1;
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  BOOL result = 0;
  if (v12)
  {
    int v13 = SCError();
    uint64_t v14 = SCErrorString(v13);
    int v15 = 136446210;
    uint64_t v16 = v14;
    uint64_t v7 = "#E Unable to lock SCPreferences: %{public}s";
    uint64_t v8 = v11;
    uint32_t v9 = 12;
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v15, v9);
    return 0;
  }
  return result;
}

BOOL sub_10027B820(NSObject ***a1)
{
  uint64_t v2 = (const __SCPreferences *)a1[1];
  if (!v2)
  {
    uint64_t v7 = **a1;
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v8) {
      return result;
    }
    LOWORD(v15) = 0;
    uint32_t v9 = "#E apply: fPrefs nullptr !";
    char v10 = v7;
    uint32_t v11 = 2;
    goto LABEL_16;
  }
  int v3 = SCPreferencesCommitChanges(v2);
  uint64_t v4 = **a1;
  BOOL result = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (!v3)
  {
    if (!result) {
      return result;
    }
    int v12 = SCError();
    int v15 = 136446210;
    uint64_t v16 = SCErrorString(v12);
    uint32_t v9 = "#E SCPreferencesCommitChanges failed with %{public}s";
LABEL_15:
    char v10 = v4;
    uint32_t v11 = 12;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v15, v11);
    return 0;
  }
  if (result)
  {
    LOWORD(v15) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SCPreferencesCommitChanges succeeded", (uint8_t *)&v15, 2u);
  }
  int v6 = SCPreferencesApplyChanges((SCPreferencesRef)a1[1]);
  uint64_t v4 = **a1;
  BOOL result = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (!v6)
  {
    if (!result) {
      return result;
    }
    int v13 = SCError();
    uint64_t v14 = SCErrorString(v13);
    int v15 = 136446210;
    uint64_t v16 = v14;
    uint32_t v9 = "#E SCPreferencesApplyChanges failed with %{public}s";
    goto LABEL_15;
  }
  if (result)
  {
    LOWORD(v15) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I SCPreferencesApplyChanges succeeded", (uint8_t *)&v15, 2u);
  }
  return 1;
}

void sub_10027B9E4()
{
}

void sub_10027BAB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10028E020((NSObject ****)va);
  _Unwind_Resume(a1);
}

void sub_10027BAE8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10027BC1C(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10027BC9C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPManager: bootstrap ...", buf, 2u);
  }
  sub_10027CAB8((void *)a1);
  *(_DWORD *)(a1 + 416) = 1;
  *(_DWORD *)(a1 + 608) = 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a1 + 272, a1 + 276, a1 + 280, a1 + 284);
  int v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Created PDP manager", v4, 2u);
  }
}

uint64_t sub_10027BD8C(uint64_t a1)
{
  return *(void *)a1;
}

const void **sub_10027BD94(const void **a1, uint64_t a2)
{
  *a1 = 0;
  CFTypeRef cf2 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"ip%d", (*(_DWORD *)(a2 + 120) + 1));
  if (cf2) {
    uint64_t v4 = sub_1000810B8;
  }
  else {
    uint64_t v4 = 0;
  }
  if (!v4) {
    return sub_1000558F4(&cf2);
  }
  NetworkServiceEntity = (__CFString *)SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetInterface);
  char v34 = NetworkServiceEntity;
  if (NetworkServiceEntity) {
    int v6 = sub_1000810B8;
  }
  else {
    int v6 = 0;
  }
  if (!v6)
  {
    int v15 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "serviceID: no pattern key", buf, 2u);
    }
    goto LABEL_52;
  }
  values = NetworkServiceEntity;
  CFArrayRef v7 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
  CFArrayRef v32 = v7;
  if (v7) {
    BOOL v8 = sub_100083F10;
  }
  else {
    BOOL v8 = 0;
  }
  if (!v8)
  {
    uint64_t v16 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "serviceID: no patterns", buf, 2u);
    }
    goto LABEL_51;
  }
  CFDictionaryRef v9 = SCDynamicStoreCopyMultiple(0, 0, v7);
  CFDictionaryRef theDict = v9;
  if (v9) {
    char v10 = sub_100080778;
  }
  else {
    char v10 = 0;
  }
  if (!v10)
  {
    unint64_t v17 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "serviceID: no interfaces", buf, 2u);
    }
    goto LABEL_50;
  }
  CFIndex Count = CFDictionaryGetCount(v9);
  CFIndex v12 = Count;
  if (Count < 1)
  {
    uint64_t v18 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Found no interfaces", buf, 2u);
    }
    goto LABEL_50;
  }
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  *(_OWORD *)std::string buf = 0u;
  long long v38 = 0u;
  memset(v36, 0, sizeof(v36));
  if ((unint64_t)Count < 0x11)
  {
    uint64_t v14 = (const void **)v36;
    int v13 = (const void **)buf;
  }
  else
  {
    int v13 = (const void **)CFAllocatorAllocate(kCFAllocatorDefault, 8 * Count, 0);
    uint64_t v14 = (const void **)CFAllocatorAllocate(kCFAllocatorDefault, 8 * v12, 0);
  }
  CFDictionaryGetKeysAndValues(theDict, v13, v14);
  ptr = v13;
  uint64_t v19 = 0;
  while (1)
  {
    CFTypeID v20 = CFGetTypeID(v14[v19]);
    if (v20 != CFDictionaryGetTypeID()) {
      goto LABEL_40;
    }
    CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)v14[v19], kSCPropNetInterfaceType);
    if (!Value) {
      goto LABEL_40;
    }
    if (!CFEqual(Value, @"com.apple.CommCenter")) {
      goto LABEL_40;
    }
    uint64_t v22 = CFDictionaryGetValue((CFDictionaryRef)v14[v19], kSCPropNetInterfaceDeviceName);
    if (!v22 || !CFEqual(v22, cf2)) {
      goto LABEL_40;
    }
    CFArrayRef theArray = 0;
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, (CFStringRef)ptr[v19], @"/");
    CFArrayRef theArray = ArrayBySeparatingStrings;
    if (ArrayBySeparatingStrings ? sub_100083F10 : 0) {
      break;
    }
    sub_100044D00((const void **)&theArray);
LABEL_40:
    if (v12 == ++v19) {
      goto LABEL_41;
    }
  }
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 5)
  {
    CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, 3);
    sub_100013168(a1, &ValueAtIndex);
  }
  sub_100044D00((const void **)&theArray);
LABEL_41:
  if (*a1) {
    xpc_object_t v25 = sub_1000810B8;
  }
  else {
    xpc_object_t v25 = 0;
  }
  if (!v25)
  {
    CFDictionaryRef v28 = theDict;
    if (theDict) {
      CFRetain(theDict);
    }
    sub_10027C2D0(a2, "serviceID: if dict: ", &v28);
    sub_100057D78((const void **)&v28);
  }
  if (ptr != (const void **)buf)
  {
    CFAllocatorDeallocate(kCFAllocatorDefault, ptr);
    CFAllocatorDeallocate(kCFAllocatorDefault, v14);
  }
LABEL_50:
  sub_100057D78((const void **)&theDict);
LABEL_51:
  sub_100044D00((const void **)&v32);
LABEL_52:
  sub_1000558F4((const void **)&v34);
  return sub_1000558F4(&cf2);
}

void sub_10027C230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va4, a5);
  va_start(va3, a5);
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  CFArrayRef v7 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFDictionaryRef v9 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint32_t v11 = va_arg(va3, const void *);
  uint64_t v13 = va_arg(va3, void);
  va_copy(va4, va3);
  uint64_t v14 = va_arg(va4, const void *);
  sub_100044D00((const void **)va);
  sub_100057D78((const void **)va1);
  sub_100044D00((const void **)va2);
  sub_1000558F4((const void **)va3);
  sub_1000558F4((const void **)va4);
  sub_1000558F4(v5);
  _Unwind_Resume(a1);
}

void sub_10027C2D0(uint64_t a1, const char *a2, const __CFDictionary **a3)
{
  if (a2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = "";
  }
  CFDictionaryRef v5 = *a3;
  if (*a3) {
    int v6 = sub_100080778;
  }
  else {
    int v6 = 0;
  }
  if (!v6)
  {
    CFDictionaryRef v9 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v13 = v4;
    char v10 = "#I %s: {null};";
    goto LABEL_14;
  }
  uint64_t context = a1;
  BOOL v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: {", buf, 0xCu);
    CFDictionaryRef v5 = *a3;
  }
  CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)sub_10028DCA8, &context);
  CFDictionaryRef v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v13 = v4;
    char v10 = "#I }; <<== %s";
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 0xCu);
  }
}

void sub_10027C450(void *a1, uint64_t a2)
{
  uint64_t v14 = 0;
  int v15 = 0;
  sub_10027C5D8(&v14, a2);
  if (v14)
  {
    uint64_t v4 = v15;
    *a1 = v14;
    a1[1] = v4;
    uint64_t v14 = 0;
    int v15 = 0;
    goto LABEL_15;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 48));
  int v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    BOOL v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v7;
  uint32_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v16);
  if (!v11)
  {
    std::mutex::unlock(v6);
    goto LABEL_11;
  }
  uint64_t v13 = v11[3];
  CFIndex v12 = (std::__shared_weak_count *)v11[4];
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v6);
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    if (!v13)
    {
      sub_10004D2C8(v12);
LABEL_11:
      *a1 = 0;
      a1[1] = 0;
      goto LABEL_15;
    }
  }
  else
  {
    std::mutex::unlock(v6);
    if (!v13) {
      goto LABEL_11;
    }
  }
  (*(void (**)(uint64_t, void))(*(void *)v13 + 64))(v13, *(int *)(a2 + 120));
  if (v12) {
    sub_10004D2C8(v12);
  }
LABEL_15:
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_10027C5A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10027C5D8(void *a1, uint64_t a2)
{
  int v3 = *(std::__shared_weak_count **)(a2 + 752);
  if (v3 && (CFDictionaryRef v5 = std::__shared_weak_count::lock(v3)) != 0)
  {
    int v6 = v5;
    uint64_t v7 = *(void *)(a2 + 744);
    if (v7)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    else
    {
      *a1 = 0;
      a1[1] = 0;
    }
    sub_10004D2C8(v6);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
}

void sub_10027C678(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void *sub_10027C68C(uint64_t a1, const void **a2)
{
  uint64_t v4 = *a2;
  if (v4) {
    CFDictionaryRef v5 = sub_1000810B8;
  }
  else {
    CFDictionaryRef v5 = 0;
  }
  uint64_t v7 = (const void **)(a1 + 128);
  BOOL result = *(const void **)(a1 + 128);
  if (result) {
    BOOL v8 = sub_1000810B8;
  }
  else {
    BOOL v8 = 0;
  }
  if (v5)
  {
    if (!v8 || (BOOL result = (const void *)CFEqual(result, v4), !result))
    {
LABEL_12:
      sub_100083EB8(v7, a2);
      uint64_t v9 = *(std::__shared_weak_count **)(a1 + 16);
      if (v9)
      {
        if (std::__shared_weak_count::lock(v9)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  else if (v8)
  {
    goto LABEL_12;
  }
  return result;
}

void sub_10027C7C0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = v1[97];
  if (v2)
  {
    v1[97] = 0;
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (v1[10]) {
    int v3 = sub_100142574;
  }
  else {
    int v3 = 0;
  }
  if (!v3)
  {
    sub_10027CAB8(v1);
    sub_10027CB80(v1);
  }
  sub_10027CC98(&v9, (uint64_t)v1);
  sub_1000558F4(&v9);
  uint64_t v4 = (std::__shared_weak_count *)v1[2];
  if (v4)
  {
    uint64_t v5 = v1[1];
    int v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = v6;
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      uint32_t v11 = 0;
      BOOL v8 = operator new(0x20uLL);
      *BOOL v8 = off_1019B28D0;
      v8[1] = v1;
      void v8[2] = v5;
      v8[3] = v7;
      uint32_t v11 = v8;
      sub_10027CD08((uint64_t)v1, 1, (uint64_t)v10);
    }
  }
  sub_100088B9C();
}

void sub_10027CA4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  sub_100057D78(&a10);
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void sub_10027CAB8(void *a1)
{
  context.version = 0;
  context.info = a1;
  memset(&context.retain, 0, 24);
  SCDynamicStoreRef v2 = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:SCDisconnectCallBack", 0, &context);
  uint64_t v3 = a1[10];
  a1[10] = v2;
  *(void *)std::string buf = v3;
  sub_100142A3C((const void **)buf);
  if (a1[10]) {
    uint64_t v4 = sub_100142574;
  }
  else {
    uint64_t v4 = 0;
  }
  if (!v4)
  {
    uint64_t v5 = a1[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Dynamic Store Disconnect Callback Create failed !", buf, 2u);
    }
  }
}

void sub_10027CB80(uint64_t a1)
{
  int v2 = SCDynamicStoreSetDisconnectCallBack();
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (v2 == 1)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Disconnect Callback for Dynamic Store registered successfully!", buf, 2u);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Disconnect Callback for Dynamic Store registeration failed", v7, 2u);
  }
  if (SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 80), *(dispatch_queue_t *)(a1 + 24)) != 1)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Disconnect Callback for Dynamic Store dispatch queue setting failed", v5, 2u);
    }
  }
}

const void **sub_10027CC98(const void **a1, uint64_t a2)
{
  *a1 = 0;
  sub_10027BD94(a1, a2);
  sub_100083DA4(&v5, a1);
  sub_10027C68C(a2, &v5);
  return sub_1000558F4(&v5);
}

void sub_10027CCEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  sub_1000558F4(v2);
  _Unwind_Resume(a1);
}

void sub_10027CD08(uint64_t a1, int a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 680);
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  uint64_t v9 = a1;
  uint64_t v10 = v6;
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5))
    {
      int v11 = a2;
      sub_1000DFC90((uint64_t)v12, a3);
      unsigned char v12[8] = v4;
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10027CE44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10027CE6C(uint64_t a1, uint64_t *a2, int a3, const void **a4, CSIPacketAddress **a5)
{
  if (*a4) {
    uint64_t v10 = sub_100080778;
  }
  else {
    uint64_t v10 = 0;
  }
  int v11 = *(NSObject **)(a1 + 40);
  BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    if (v12)
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I notifySystemConfigOfSettings: family %s", buf, 0xCu);
    }
    sub_100058198(&v91, a4);
    sub_10027C2D0(a1, "notifySystemConfigOfSettings: ip dict: special dict", (const __CFDictionary **)&v91);
    sub_100057D78(&v91);
  }
  else if (v12)
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = asString();
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I notifySystemConfigOfSettings for %s", buf, 0xCu);
  }
  CFStringRef serviceID = 0;
  sub_10027CC98((const void **)&serviceID, a1);
  if (serviceID) {
    uint64_t v13 = sub_1000810B8;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13)
  {
    CFDictionaryRef keysToSet = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (keysToSet) {
      uint64_t v14 = sub_1000C06D0;
    }
    else {
      uint64_t v14 = 0;
    }
    if (!v14)
    {
      BOOL v21 = 0;
LABEL_149:
      sub_10005717C((const void **)&keysToSet);
      goto LABEL_150;
    }
    value = 0;
    CFMutableDictionaryRef theDict = 0;
    CFDictionaryRef v15 = (const __CFDictionary *)*a4;
    if (*a4) {
      unint64_t v16 = sub_100080778;
    }
    else {
      unint64_t v16 = 0;
    }
    if (a3 == 1)
    {
      if (v16)
      {
        MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v15);
        CFMutableDictionaryRef v18 = theDict;
        CFMutableDictionaryRef theDict = MutableCopy;
        *(void *)std::string buf = v18;
        uint64_t v19 = sub_10005717C((const void **)buf);
LABEL_82:
        if (capabilities::ct::supportsGemini((capabilities::ct *)v19))
        {
          *(_OWORD *)std::string buf = 0uLL;
          sub_10028583C(buf, a1);
          uint64_t v52 = *(unsigned int *)(a1 + 120);
          uint64_t v53 = subscriber::simSlotAsInstance();
          long long v54 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Cellular WAN: pdp_ip%d: SIM %u", v52, v53);
          CFStringRef v55 = (const __CFString *)value;
          value = v54;
          CFStringRef v97 = v55;
          sub_1000558F4((const void **)&v97);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
        }
        else
        {
          dispatch_object_t v56 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Cellular WAN: pdp_ip%d", *(unsigned int *)(a1 + 120));
          long long v57 = value;
          value = v56;
          *(void *)std::string buf = v57;
          sub_1000558F4((const void **)buf);
        }
        int v31 = &kSCEntNetIPv4;
        goto LABEL_87;
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      uint64_t v86 = Mutable;
      *(void *)std::string buf = 0;
      sub_10005717C((const void **)buf);
      if (Mutable) {
        char v33 = sub_1000C06D0;
      }
      else {
        char v33 = 0;
      }
      if (v33)
      {
        CFStringRef v97 = 0;
        CSIPacketAddress::operator std::string();
        if (v99 >= 0) {
          char v34 = buf;
        }
        else {
          char v34 = *(uint8_t **)buf;
        }
        CFStringRef v35 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v34, 0x8000100u);
        CFStringRef v97 = v35;
        if (v99 < 0)
        {
          operator delete(*(void **)buf);
          CFStringRef v35 = v97;
        }
        if (v35) {
          long long v36 = sub_1000810B8;
        }
        else {
          long long v36 = 0;
        }
        if (v36)
        {
          *(void *)std::string buf = v35;
          SCDynamicStoreRef store = 0;
          uint64_t v37 = CFArrayCreate(kCFAllocatorDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
          SCDynamicStoreRef store = v37;
          if (v37) {
            long long v38 = sub_100083F10;
          }
          else {
            long long v38 = 0;
          }
          if (v38)
          {
            CFDictionarySetValue(Mutable, kSCPropNetIPv4Addresses, v37);
            CFDictionarySetValue(Mutable, kSCPropNetIPv4Router, *(const void **)buf);
            values = @"255.255.255.255";
            CFArrayRef v39 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
            *(void *)unsigned int v94 = v39;
            if (v39) {
              long long v40 = sub_100083F10;
            }
            else {
              long long v40 = 0;
            }
            if (v40)
            {
              CFDictionarySetValue(Mutable, kSCPropNetIPv4SubnetMasks, v39);
              uint64_t v41 = *(unsigned int *)(a1 + 120);
              if (v41 > 0xF) {
                long long v42 = "";
              }
              else {
                long long v42 = off_1019B2768[v41];
              }
              CFStringRef v49 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s", v42);
              CFStringRef v93 = v49;
              if (v49) {
                uint64_t v50 = sub_1000810B8;
              }
              else {
                uint64_t v50 = 0;
              }
              if (v50)
              {
                CFDictionarySetValue(Mutable, kSCPropInterfaceName, v49);
                sub_10004EFE4(&v92, (CFTypeRef *)&v86);
                sub_10027C2D0(a1, "createSCDictForIPv4: ip dict", (const __CFDictionary **)&v92);
                sub_100057D78(&v92);
              }
              sub_1000558F4((const void **)&v93);
            }
            sub_100044D00((const void **)v94);
          }
          sub_100044D00((const void **)&store);
        }
        sub_1000558F4((const void **)&v97);
      }
      *(void *)std::string buf = theDict;
      CFMutableDictionaryRef theDict = v86;
      uint64_t v86 = 0;
      sub_10005717C((const void **)buf);
      uint64_t v19 = sub_10005717C((const void **)&v86);
      if (theDict) {
        char v51 = sub_1000C06D0;
      }
      else {
        char v51 = 0;
      }
      if (v51) {
        goto LABEL_82;
      }
      uint64_t v71 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "Creating IPv4 dictionary for SC failed, bailing out", buf, 2u);
      }
      goto LABEL_120;
    }
    if (v16)
    {
      uint64_t v22 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v15);
      CFMutableDictionaryRef v23 = theDict;
      CFMutableDictionaryRef theDict = v22;
      *(void *)std::string buf = v23;
      unint64_t v24 = sub_10005717C((const void **)buf);
LABEL_29:
      if (capabilities::ct::supportsGemini((capabilities::ct *)v24))
      {
        *(_OWORD *)std::string buf = 0uLL;
        sub_10028583C(buf, a1);
        uint64_t v25 = *(unsigned int *)(a1 + 120);
        uint64_t v26 = subscriber::simSlotAsInstance();
        uint64_t v27 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Cellular WAN: pdp_ip%d: SIM %u: ipv6", v25, v26);
        CFStringRef v28 = (const __CFString *)value;
        value = v27;
        CFStringRef v97 = v28;
        sub_1000558F4((const void **)&v97);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      else
      {
        uint64_t v29 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Cellular WAN: pdp_ip%d: ipv6", *(unsigned int *)(a1 + 120));
        unsigned int v30 = value;
        value = v29;
        *(void *)std::string buf = v30;
        sub_1000558F4((const void **)buf);
      }
      int v31 = &kSCEntNetIPv6;
LABEL_87:
      CFStringRef v58 = *v31;
      if (theDict) {
        uint64_t v59 = sub_1000C06D0;
      }
      else {
        uint64_t v59 = 0;
      }
      if (v59)
      {
        if (value ? sub_1000810B8 : 0) {
          CFDictionarySetValue(theDict, @"NetworkSignature", value);
        }
      }
      CFStringRef v97 = 0;
      CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, serviceID, v58);
      CFStringRef v97 = NetworkServiceEntity;
      if (NetworkServiceEntity) {
        char v62 = sub_1000810B8;
      }
      else {
        char v62 = 0;
      }
      if (!v62)
      {
        char v68 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "Creating key for IP address failed, bailing out", buf, 2u);
        }
        BOOL v21 = 0;
        goto LABEL_147;
      }
      CFDictionarySetValue(keysToSet, NetworkServiceEntity, theDict);
      SCDynamicStoreRef store = 0;
      uint64_t v63 = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:notifySystemConfigOfSettings", 0, 0);
      SCDynamicStoreRef store = v63;
      if (v63) {
        uint64_t v64 = sub_100142574;
      }
      else {
        uint64_t v64 = 0;
      }
      if (v64)
      {
        if (*a4) {
          uint64_t v65 = sub_100080778;
        }
        else {
          uint64_t v65 = 0;
        }
        if (v65) {
          goto LABEL_108;
        }
        if (a3 == 2)
        {
          uint64_t v70 = a1 + 488;
          goto LABEL_122;
        }
        if (a3 == 1)
        {
          uint64_t v70 = a1 + 296;
LABEL_122:
          values = 0;
          uint64_t v72 = *a2;
          char v73 = (std::__shared_weak_count *)a2[1];
          v85[0] = v72;
          v85[1] = (uint64_t)v73;
          if (v73) {
            atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFStringRef v74 = serviceID;
          uint64_t v84 = v63;
          if (v63) {
            CFRetain(v63);
          }
          sub_100284ACC((CFTypeRef *)&values, a1, v85, v70, a5, v74, &v84);
          sub_100142A3C((const void **)&v84);
          if (v73) {
            sub_10004D2C8(v73);
          }
          if (values) {
            uint64_t v75 = sub_100080778;
          }
          else {
            uint64_t v75 = 0;
          }
          if (v75)
          {
            CFStringRef v76 = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, serviceID, kSCEntNetDNS);
            *(void *)std::string buf = v76;
            if (v76) {
              uint64_t v77 = sub_1000810B8;
            }
            else {
              uint64_t v77 = 0;
            }
            if (v77)
            {
              CFDictionarySetValue(keysToSet, v76, values);
              sub_1000558F4((const void **)buf);
              sub_100057D78((const void **)&values);
LABEL_108:
              sub_10004EFE4(&v83, (CFTypeRef *)&keysToSet);
              sub_10027C2D0(a1, "notifySystemConfigOfSettings: ip dict", (const __CFDictionary **)&v83);
              sub_100057D78(&v83);
              int v66 = SCDynamicStoreSetMultiple(store, keysToSet, 0, 0);
              BOOL v21 = v66 != 0;
              uint64_t v67 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)std::string buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v66 != 0;
                _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I SCDynamicStoreSetMultiple() result %u", buf, 8u);
              }
              goto LABEL_146;
            }
            unint64_t v81 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)unsigned int v94 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "Creating key for DNS failed, bailing out", v94, 2u);
            }
            sub_1000558F4((const void **)buf);
          }
          else
          {
            uint64_t v79 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v80 = asString();
              *(_DWORD *)std::string buf = 136315138;
              *(void *)&uint8_t buf[4] = v80;
              _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#E Failed to create SCD Dict for DNS for %s, bailing out", buf, 0xCu);
            }
          }
          sub_100057D78((const void **)&values);
          goto LABEL_145;
        }
        long long v78 = *(NSObject **)(a1 + 40);
        BOOL v21 = 0;
        if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
        {
LABEL_146:
          sub_100142A3C((const void **)&store);
LABEL_147:
          sub_1000558F4((const void **)&v97);
          goto LABEL_148;
        }
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a3;
        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#E no IP model available: family=%u", buf, 8u);
      }
      else
      {
        int v69 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "Failed to create SCDynamicStore for notifySystemConfigOfSettings, bailing out", buf, 2u);
        }
      }
LABEL_145:
      BOOL v21 = 0;
      goto LABEL_146;
    }
    CFDictionaryRef v43 = *(const __CFDictionary **)(a1 + 88);
    if (v43) {
      long long v44 = sub_100080778;
    }
    else {
      long long v44 = 0;
    }
    if (v44)
    {
      unsigned int v45 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v43);
      CFMutableDictionaryRef v46 = theDict;
      CFMutableDictionaryRef theDict = v45;
      *(void *)std::string buf = v46;
      unint64_t v24 = sub_10005717C((const void **)buf);
      if (theDict) {
        unsigned int v47 = sub_1000C06D0;
      }
      else {
        unsigned int v47 = 0;
      }
      if (v47) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v48 = *(NSObject **)(a1 + 40);
      BOOL v21 = 0;
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
      {
LABEL_148:
        sub_1000558F4((const void **)&value);
        sub_10005717C((const void **)&theDict);
        goto LABEL_149;
      }
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#N IPv6 dictionary for SC is not ready yet, bailing out", buf, 2u);
    }
LABEL_120:
    BOOL v21 = 0;
    goto LABEL_148;
  }
  CFTypeID v20 = *(NSObject **)(a1 + 40);
  BOOL v21 = 0;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N not setting IP address or DNS", buf, 2u);
    BOOL v21 = 0;
  }
LABEL_150:
  sub_1000558F4((const void **)&serviceID);
  return v21;
}

void sub_10027DA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va5, a8);
  va_start(va4, a8);
  va_start(va3, a8);
  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v10 = va_arg(va1, const void *);
  va_copy(va2, va1);
  BOOL v12 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v14 = va_arg(va3, const void *);
  va_copy(va4, va3);
  unint64_t v16 = va_arg(va4, const void *);
  uint64_t v18 = va_arg(va4, void);
  uint64_t v19 = va_arg(va4, void);
  uint64_t v20 = va_arg(va4, void);
  uint64_t v21 = va_arg(va4, void);
  va_copy(va5, va4);
  uint64_t v22 = va_arg(va5, const void *);
  sub_100057D78((const void **)va4);
  sub_100142A3C((const void **)va5);
  sub_1000558F4((const void **)(v8 - 120));
  sub_1000558F4((const void **)va);
  sub_10005717C((const void **)va1);
  sub_10005717C((const void **)va2);
  sub_1000558F4((const void **)va3);
  _Unwind_Resume(a1);
}

uint64_t sub_10027DB90(uint64_t a1, void *a2, NSObject **a3, NSObject **a4, NSObject **a5, unsigned int a6)
{
  PDPManagerInterface::PDPManagerInterface((PDPManagerInterface *)a1);
  if (a6 > 9) {
    BOOL v12 = "DATA.pkt:N:";
  }
  else {
    BOOL v12 = off_1019B2AF0[a6];
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v24, kCtLoggingSystemName, v12);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v13 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v13) {
    dispatch_retain(v13);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v25, &v24);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v25);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v25);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
  *(void *)a1 = off_1019B24A8;
  *(void *)(a1 + 48) = *a2;
  uint64_t v14 = a2[1];
  *(void *)(a1 + 56) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  CFDictionaryRef v15 = *a4;
  *(void *)(a1 + 64) = *a4;
  if (v15) {
    dispatch_retain(v15);
  }
  unint64_t v16 = *a5;
  *(void *)(a1 + 72) = *a5;
  if (v16) {
    dispatch_retain(v16);
  }
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 120) = a6;
  *(_DWORD *)(a1 + 136) = -1;
  *(_WORD *)(a1 + 140) = 257;
  *(void *)(a1 + 144) = 850045863;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 850045863;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 276) = 0u;
  unint64_t v17 = *a3;
  CFMutableDictionaryRef v23 = v17;
  if (v17) {
    dispatch_retain(v17);
  }
  if (a6 > 9) {
    uint64_t v18 = "DATA.pkt:N:m4:";
  }
  else {
    uint64_t v18 = off_1019B2B40[a6];
  }
  sub_10028CDC8(a1 + 296, &v23, v18);
  if (v17) {
    dispatch_release(v17);
  }
  uint64_t v19 = *a3;
  uint64_t v22 = v19;
  if (v19) {
    dispatch_retain(v19);
  }
  if (a6 > 9) {
    uint64_t v20 = "DATA.pkt:N:m6:";
  }
  else {
    uint64_t v20 = off_1019B2B90[a6];
  }
  sub_10028CDC8(a1 + 488, &v22, v20);
  if (v19) {
    dispatch_release(v19);
  }
  *(void *)(a1 + 680) = 0xFFFFFFFF00000000;
  *(_OWORD *)(a1 + 728) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(void *)(a1 + 720) = a1 + 728;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_DWORD *)(a1 + 760) = 1450;
  *(_WORD *)(a1 + 764) = 0;
  *(unsigned char *)(a1 + 766) = 0;
  *(_OWORD *)(a1 + 768) = 0u;
  *(unsigned char *)(a1 + 784) = 0;
  return a1;
}

void sub_10027DE28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, const void **a9, ctu::OsLogLogger *a10, void *a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16)
{
  if (v19) {
    dispatch_release(v19);
  }
  sub_10028CEF4(v17);
  std::mutex::~mutex(v18);
  std::mutex::~mutex(v23);
  sub_1000558F4(v22);
  sub_100044D00(v21);
  sub_100044D00(v20 + 3);
  sub_100057D78(a9);
  sub_100057D78(v20 + 1);
  sub_100142A3C(v20);
  uint64_t v25 = *((void *)v16 + 9);
  if (v25) {
    dispatch_release(v25);
  }
  uint64_t v26 = *((void *)v16 + 8);
  if (v26) {
    dispatch_release(v26);
  }
  uint64_t v27 = (std::__shared_weak_count *)*((void *)v16 + 7);
  if (v27) {
    sub_10004D2C8(v27);
  }
  ctu::OsLogLogger::~OsLogLogger(a10);
  sub_100087E88(a11);
  PDPManagerInterface::~PDPManagerInterface(v16);
  _Unwind_Resume(a1);
}

void sub_10027DF10(uint64_t a1)
{
  *(void *)a1 = off_1019B24A8;
  uint64_t v2 = *(void *)(a1 + 776);
  *(void *)(a1 + 776) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 768);
  *(void *)(a1 + 768) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 752);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  sub_10005D144(*(void **)(a1 + 728));
  sub_100142A3C((const void **)(a1 + 712));
  sub_100142A3C((const void **)(a1 + 704));
  sub_10028E6F8((const void **)(a1 + 696), 0);
  sub_10028E6F8((const void **)(a1 + 688), 0);
  sub_10028CEF4(a1 + 488);
  sub_10028CEF4(a1 + 296);
  std::mutex::~mutex((std::mutex *)(a1 + 208));
  std::mutex::~mutex((std::mutex *)(a1 + 144));
  sub_1000558F4((const void **)(a1 + 128));
  sub_100044D00((const void **)(a1 + 112));
  sub_100044D00((const void **)(a1 + 104));
  sub_100057D78((const void **)(a1 + 96));
  sub_100057D78((const void **)(a1 + 88));
  sub_100142A3C((const void **)(a1 + 80));
  uint64_t v5 = *(NSObject **)(a1 + 72);
  if (v5) {
    dispatch_release(v5);
  }
  uint64_t v6 = *(NSObject **)(a1 + 64);
  if (v6) {
    dispatch_release(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 56);
  if (v7) {
    sub_10004D2C8(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  PDPManagerInterface::~PDPManagerInterface((PDPManagerInterface *)a1);
}

void sub_10027E088(uint64_t a1)
{
  sub_10027DF10(a1);

  operator delete();
}

void sub_10027E0C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Received the disconnect callback on SCDynamicStore restart at object: %p", buf, 0xCu);
    uint64_t v3 = *(NSObject **)(a2 + 40);
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Writing Service Entry after SCDynamicStore restart at object: %p", buf, 0xCu);
  }
  int v4 = *(std::__shared_weak_count **)(a2 + 16);
  if (v4 && std::__shared_weak_count::lock(v4))
  {
    uint64_t v5 = *(std::__shared_weak_count **)(a2 + 16);
    if (v5)
    {
      if (std::__shared_weak_count::lock(v5)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  sub_100088B9C();
}

void sub_10027E27C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10027E294(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 744) = v2;
  int v4 = *(std::__shared_weak_count **)(a1 + 752);
  *(void *)(a1 + 752) = v3;
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_10027E2C4(uint64_t a1, uint64_t *a2)
{
  if (capabilities::ct::supportsIPCInterfaceConfig((capabilities::ct *)a1) && !*(unsigned char *)(a1 + 784))
  {
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v5 = a2;
      }
      else {
        uint64_t v5 = (uint64_t *)*a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      CFMutableDictionaryRef v23 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ipcInterfaceConfig: trying to start: %s", buf, 0xCu);
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 752);
    if (v6)
    {
      uint64_t v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        uint64_t v8 = *(void *)(a1 + 744);
        if (v8)
        {
          char v21 = 0;
          int v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char *))(*(void *)v8 + 64))(v8, 2, 0, 0, &v21);
          uint64_t v10 = *(NSObject **)(a1 + 40);
          BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
          if (v9)
          {
            if (!v11) {
              goto LABEL_22;
            }
            *(_WORD *)std::string buf = 0;
            BOOL v12 = "#I ipcInterfaceConfig: down success (2)";
          }
          else
          {
            if (!v11) {
              goto LABEL_22;
            }
            *(_WORD *)std::string buf = 0;
            BOOL v12 = "#I ipcInterfaceConfig: down failed (2)";
          }
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
LABEL_22:
          int v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char *))(*(void *)v8 + 64))(v8, 1, 0, 0, &v21);
          CFDictionaryRef v15 = *(NSObject **)(a1 + 40);
          BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
          if (v14)
          {
            if (!v16) {
              goto LABEL_28;
            }
            *(_WORD *)std::string buf = 0;
            uint64_t v17 = "#I ipcInterfaceConfig: down success (1)";
          }
          else
          {
            if (!v16) {
              goto LABEL_28;
            }
            *(_WORD *)std::string buf = 0;
            uint64_t v17 = "#I ipcInterfaceConfig: down failed (1)";
          }
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v17, buf, 2u);
LABEL_28:
          BOOL v18 = *(_DWORD *)(a1 + 120) == 0;
          char v21 = 0;
          int v19 = (*(uint64_t (**)(uint64_t, void, uint64_t, BOOL, char *))(*(void *)v8 + 64))(v8, 0, 1, v18, &v21);
          uint64_t v20 = *(NSObject **)(a1 + 40);
          if (v19)
          {
            if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I ipcInterfaceConfig: up success", buf, 2u);
            }
            *(unsigned char *)(a1 + 784) = v21;
          }
          else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "ipcInterfaceConfig: up failed", buf, 2u);
          }
LABEL_34:
          sub_10004D2C8(v7);
          return;
        }
      }
    }
    else
    {
      uint64_t v7 = 0;
    }
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "ipcInterfaceConfig: Cannot find observer", buf, 2u);
    }
    if (v7) {
      goto LABEL_34;
    }
  }
}

void sub_10027E604(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10027E61C(uint64_t a1, uint64_t *a2)
{
  if (capabilities::ct::supportsIPCInterfaceConfig((capabilities::ct *)a1) && *(unsigned char *)(a1 + 784))
  {
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v5 = a2;
      }
      else {
        uint64_t v5 = (uint64_t *)*a2;
      }
      *(_DWORD *)std::string buf = 136315138;
      int v19 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ipcInterfaceConfig: trying to reset: %s", buf, 0xCu);
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 752);
    if (v6)
    {
      uint64_t v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        uint64_t v8 = *(void *)(a1 + 744);
        if (v8)
        {
          char v17 = 0;
          int v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char *))(*(void *)v8 + 64))(v8, 2, 0, 0, &v17);
          uint64_t v10 = *(NSObject **)(a1 + 40);
          BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
          if (v9)
          {
            if (v11)
            {
              *(_WORD *)std::string buf = 0;
              BOOL v12 = "#I ipcInterfaceConfig: down success (2)";
LABEL_21:
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
            }
          }
          else if (v11)
          {
            *(_WORD *)std::string buf = 0;
            BOOL v12 = "#I ipcInterfaceConfig: down failed (2)";
            goto LABEL_21;
          }
          int v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char *))(*(void *)v8 + 64))(v8, 1, 0, 0, &v17);
          CFDictionaryRef v15 = *(NSObject **)(a1 + 40);
          BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
          if (v14)
          {
            if (v16)
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I ipcInterfaceConfig: down success (1)", buf, 2u);
            }
            if (v9) {
              (*(void (**)(uint64_t))(*(void *)v8 + 72))(v8);
            }
          }
          else if (v16)
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I ipcInterfaceConfig: down failed (1)", buf, 2u);
          }
          *(unsigned char *)(a1 + 784) = 0;
LABEL_30:
          sub_10004D2C8(v7);
          return;
        }
      }
    }
    else
    {
      uint64_t v7 = 0;
    }
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "ipcInterfaceConfig: Cannot find observer", buf, 2u);
    }
    if (v7) {
      goto LABEL_30;
    }
  }
}

void sub_10027E8D4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10027E8E8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPManager: starting ...", buf, 2u);
  }
  *(void *)std::string buf = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  if ((CSIPDPManager::getInterfaceNameById() & 1) == 0)
  {
    int v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      int v15 = *(_DWORD *)(a1 + 120);
      *(_DWORD *)CFStringRef v28 = 67109120;
      *(_DWORD *)&v28[4] = v15;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get name for unit: %d", v28, 8u);
    }
LABEL_19:
    if (SHIBYTE(v25) < 0) {
      operator delete(*(void **)buf);
    }
    sub_10027C450(&v21, a1);
    sub_10027EC44(a1, &v21);
    if (v22) {
      sub_10004D2C8(v22);
    }
    sub_10027CB80(a1);
    BOOL v16 = *(std::__shared_weak_count **)(a1 + 16);
    if (v16)
    {
      uint64_t v17 = *(void *)(a1 + 8);
      BOOL v18 = std::__shared_weak_count::lock(v16);
      if (v18)
      {
        int v19 = v18;
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v27 = 0;
        uint64_t v20 = operator new(0x20uLL);
        *uint64_t v20 = off_1019B2950;
        v20[1] = a1;
        xpc_object_t v20[2] = v17;
        void v20[3] = v19;
        uint64_t v27 = v20;
        sub_10027CD08(a1, 2, (uint64_t)v26);
      }
    }
    sub_100088B9C();
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  int v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CFStringRef v28 = v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)v28);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_10;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_10:
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFStringRef v28 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "NetworkConfigInterface not found", v28, 2u);
    }
    goto LABEL_17;
  }
LABEL_16:
  (*(void (**)(uint64_t, uint8_t *, void))(*(void *)v11 + 24))(v11, buf, 0);
LABEL_17:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  goto LABEL_19;
}

void sub_10027EBC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10027EC44(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v6 = sub_100288178(a1, v4, v5, a1 + 296);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v7 = *a2;
  unsigned int v8 = (std::__shared_weak_count *)a2[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v9 = sub_100288178(a1, v7, v8, a1 + 488);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (*(unsigned char *)(a1 + 433)) {
    BOOL v10 = *(unsigned char *)(a1 + 432) != 0;
  }
  else {
    BOOL v10 = 0;
  }
  std::mutex::lock((std::mutex *)(a1 + 144));
  if (v9 >= v6) {
    unsigned int v11 = v6;
  }
  else {
    unsigned int v11 = v9;
  }
  *(_DWORD *)(a1 + 760) = v11;
  if (v10 && v11 >= 0x4ED)
  {
    char v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I computeMTU_sync: adjusted for XLAT464", (uint8_t *)v15, 2u);
    }
    *(_DWORD *)(a1 + 760) = 1260;
  }
  std::mutex::unlock((std::mutex *)(a1 + 144));
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = *(_DWORD *)(a1 + 760);
    v15[0] = 67109120;
    v15[1] = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I computeMTU_sync: MTU = %u", (uint8_t *)v15, 8u);
  }
}

void sub_10027EDF0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10027EE0C(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DarwinPDPManager: shutting down", v6, 2u);
  }
  if (a1[10]) {
    uint64_t v3 = sub_100142574;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    SCDynamicStoreSetDisconnectCallBack();
    uint64_t v4 = (const void *)a1[10];
    a1[10] = 0;
    uint64_t v7 = v4;
    sub_100142A3C(&v7);
  }
  (*(void (**)(void *, uint64_t))(*a1 + 80))(a1, 1);
  return (*(uint64_t (**)(void *, uint64_t))(*a1 + 80))(a1, 2);
}

void sub_10027EF04(uint64_t a1@<X0>, int a2@<W1>, CSIPacketAddress *a3@<X8>)
{
  if (a2 == 2)
  {
    uint64_t v5 = a1 + 488;
  }
  else
  {
    if (a2 != 1) {
      goto LABEL_7;
    }
    uint64_t v5 = a1 + 296;
  }
  if (*(_DWORD *)(v5 + 116) == 4)
  {
    CSIPacketAddress::CSIPacketAddress(a3, (const CSIPacketAddress *)(v5 + 40));
    return;
  }
LABEL_7:
  CSIPacketAddress::CSIPacketAddress(a3);
}

void sub_10027EF40(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)std::string __str = 0u;
  long long v19 = 0u;
  memset(&__p, 0, sizeof(__p));
  int v15 = &a9;
  vsnprintf(__str, 0x100uLL, a3, &a9);
  sub_10003ED78(&__p, __str);
  unsigned int v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 136446210;
    uint64_t v17 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E %{public}s", buf, 0xCu);
  }
  if (a2)
  {
    uint64_t v13 = (void **)(a2 + 152);
    if (*(char *)(a2 + 175) < 0) {
      operator delete(*v13);
    }
    *(_OWORD *)uint64_t v13 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *(void *)(a2 + 168) = *((void *)&__p.__r_.__value_.__l + 2);
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
  }
  sub_10027F0B8(a1, a2, 0);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_10027F09C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10027F0B8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!a2) {
    return;
  }
  if (a3 == 1)
  {
    unsigned int v6 = *(std::__shared_weak_count **)(a2 + 184);
    *(void *)(a2 + 176) = 0;
    *(void *)(a2 + 184) = 0;
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
  uint64_t v7 = *(int *)(a2 + 116);
  if (v7 == a3) {
    return;
  }
  unsigned int v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (v7 > 4) {
      unsigned int v9 = "???";
    }
    else {
      unsigned int v9 = off_1019B2C30[v7];
    }
    if (a3 > 4) {
      BOOL v10 = "???";
    }
    else {
      BOOL v10 = off_1019B2C30[a3];
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v10;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v51 = asString();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s->%s (change states) (%s)", buf, 0x20u);
  }
  *(_DWORD *)(a2 + 116) = a3;
  if (a3 != 4) {
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  char v12 = ServiceMap;
  if (v13 < 0)
  {
    int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (v17)
  {
    uint64_t v19 = v17[3];
    BOOL v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      if (!v19) {
        goto LABEL_26;
      }
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  BOOL v18 = 0;
  char v20 = 1;
  if (!v19) {
    goto LABEL_26;
  }
LABEL_24:
  uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 872))(v19);
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 160))(v21);
  }
LABEL_26:
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  if (*(_DWORD *)(a2 + 116) == 4)
  {
    uint64_t v22 = a1 + 296;
    if (a1 + 296 == a2) {
      uint64_t v22 = a1 + 488;
    }
    if (*(_DWORD *)(v22 + 116) != 4)
    {
      long long v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I online: writing current apn info", buf, 2u);
      }
      int v44 = *(_DWORD *)(a1 + 680);
      CFTypeRef v47 = 0;
      CFTypeRef cf = 0;
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      sub_10027C5D8(&v45, a1);
      if (v45)
      {
        sub_100C940DC(v45, 0, &v56);
        *(void *)std::string buf = cf;
        CFTypeRef cf = (CFTypeRef)v56;
        *(void *)&long long v56 = 0;
        sub_100057D78((const void **)buf);
        sub_100057D78((const void **)&v56);
        CFDictionaryRef v24 = *(const __CFDictionary **)(v45 + 208);
        if (v24 ? sub_100080778 : 0)
        {
          CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v24);
          CFTypeRef v27 = v47;
          CFTypeRef v47 = Copy;
          *(void *)std::string buf = v27;
          sub_100057D78((const void **)buf);
        }
      }
      if (!*(_DWORD *)(a1 + 120) && (v44 & 8) != 0)
      {
        long long v28 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
        long long v29 = v28;
        if (v30 < 0)
        {
          long long v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v32 = 5381;
          do
          {
            uint64_t v30 = v32;
            unsigned int v33 = *v31++;
            uint64_t v32 = (33 * v32) ^ v33;
          }
          while (v33);
        }
        std::mutex::lock(v28);
        *(void *)std::string buf = v30;
        char v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
        if (v34)
        {
          uint64_t v36 = v34[3];
          CFStringRef v35 = (std::__shared_weak_count *)v34[4];
          if (v35)
          {
            atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v29);
            atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v35);
            if (!v36)
            {
LABEL_65:
              sub_10004D2C8(v35);
              goto LABEL_66;
            }
          }
          else
          {
            std::mutex::unlock(v29);
            if (!v36) {
              goto LABEL_66;
            }
          }
          *(void *)std::string buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          sub_10028583C(&v56, a1);
          (*(void (**)(unsigned char *__return_ptr, uint64_t, void))(*(void *)v36 + 16))(buf, v36, *(unsigned int *)(v56 + 52));
          if (*((void *)&v56 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v56 + 1));
          }
          if (*(void *)buf && (*(unsigned int (**)(void))(**(void **)buf + 88))(*(void *)buf))
          {
            CFDictionaryRef theDict = 0;
            (*(void (**)(CFDictionaryRef *__return_ptr))(**(void **)buf + 72))(&theDict);
            if (theDict) {
              uint64_t v37 = sub_100080778;
            }
            else {
              uint64_t v37 = 0;
            }
            if (v37)
            {
              *(void *)&long long v56 = CFDictionaryGetValue(theDict, @"ProxyConfiguration");
              sub_100289870(&v47, (CFTypeRef *)&v56);
            }
            else
            {
              CFTypeRef v38 = v47;
              CFTypeRef v47 = 0;
              *(void *)&long long v56 = v38;
              sub_100057D78((const void **)&v56);
            }
            sub_100057D78((const void **)&theDict);
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          if (v35) {
            goto LABEL_65;
          }
        }
        else
        {
          std::mutex::unlock(v29);
        }
      }
LABEL_66:
      CFArrayRef v39 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        WirelessTechnologyList::asString((uint64_t *)buf, (WirelessTechnologyList *)&v44);
        long long v40 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
        LODWORD(v56) = 136446210;
        *(void *)((char *)&v56 + 4) = v40;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I writeCurrentApnInfoToSystemConfig_sync: schedule start: technology %{public}s", (uint8_t *)&v56, 0xCu);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
      uint64_t v41 = *(std::__shared_weak_count **)(a1 + 16);
      if (v41)
      {
        uint64_t v42 = *(void *)(a1 + 8);
        CFDictionaryRef v43 = std::__shared_weak_count::lock(v41);
        if (v43)
        {
          *(void *)std::string buf = v42;
          *(void *)&uint8_t buf[8] = v43;
          atomic_fetch_add_explicit(&v43->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v43);
          *(void *)&uint8_t buf[16] = a1;
          LODWORD(v51) = v44;
          uint64_t v52 = v45;
          uint64_t v53 = v46;
          if (v46) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v46 + 8), 1uLL, memory_order_relaxed);
          }
          CFTypeRef v54 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v55 = v47;
          if (v47) {
            CFRetain(v47);
          }
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
}

void sub_10027F798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, const void *a12, const void *a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  sub_100057D78(&a12);
  sub_100057D78(&a13);
  _Unwind_Resume(a1);
}

void sub_10027F860(uint64_t a1)
{
}

void sub_10027F86C(uint64_t a1, char a2)
{
  int v89 = 0;
  long long v90 = 0uLL;
  int v87 = 0;
  long long v88 = 0uLL;
  CFTypeRef cf = 0;
  sub_10027CC98(&v85, a1);
  sub_1000558F4(&v85);
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 112);
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Run into ipv4ServiceChanged, fIPv4Addresses value is %p", buf, 0xCu);
  }
  if (!*(void *)(a1 + 696))
  {
    uint64_t v21 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v22 = "#I Got ipv4ServiceChanged without valid fIPv4Service, bailing out";
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v22, buf, 2u);
    goto LABEL_24;
  }
  unsigned int v6 = (const void *)IPConfigurationServiceCopyInformation();
  CFTypeRef v7 = cf;
  CFTypeRef cf = v6;
  *(void *)std::string buf = v7;
  sub_100057D78((const void **)buf);
  if (!cf)
  {
    long long v25 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_36;
    }
    *(_WORD *)std::string buf = 0;
    long long v26 = "#I Get IPv4Service Information Failed: serviceInfo is empty";
    goto LABEL_34;
  }
  CFTypeID v8 = CFGetTypeID(cf);
  unsigned int v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Get IPv4Service Information Type: %lu", buf, 0xCu);
  }
  CFTypeRef v10 = cf;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!v10 || CFGetTypeID(v10) != TypeID)
  {
    long long v25 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_36;
    }
    *(_WORD *)std::string buf = 0;
    long long v26 = "#I Get IPv4Service Information Failed. Maybe configd restarted, ignore";
LABEL_34:
    CFTypeRef v27 = v25;
    goto LABEL_35;
  }
  CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)cf, kSCEntNetIPv4);
  uint64_t v13 = Value;
  if (!Value || (CFTypeID v14 = CFGetTypeID(Value), v14 != CFDictionaryGetTypeID()))
  {
    uint64_t v21 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v22 = "#I No kSCEntNetIPv4 key in IPv4Service Information";
    goto LABEL_23;
  }
  uint64_t v15 = (CFTypeRef *)(a1 + 96);
  sub_100058198(&v84, (const void **)(a1 + 96));
  sub_10027C2D0(a1, "IPv4Service: ip dict: old dictionary", (const __CFDictionary **)&v84);
  sub_100057D78(&v84);
  CFTypeRef v83 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_10027C2D0(a1, "IPv4Service: ip dict: new (full) dictionary", (const __CFDictionary **)&v83);
  sub_100057D78(&v83);
  if (*v15) {
    unsigned int v16 = sub_100080778;
  }
  else {
    unsigned int v16 = 0;
  }
  if (v16 && CFEqual(*v15, v13))
  {
    uint64_t v17 = *(NSObject **)(a1 + 40);
    BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
    if (a2)
    {
      if (v18)
      {
        *(_WORD *)std::string buf = 0;
        uint64_t v19 = "#I ipv4ToBeUpdated is true due to refresh";
        char v20 = v17;
LABEL_45:
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, 2u);
        goto LABEL_46;
      }
      goto LABEL_46;
    }
    if (!v18) {
      goto LABEL_36;
    }
    *(_WORD *)std::string buf = 0;
    long long v26 = "#I Nothing is changed for IPv4Service Information";
    CFTypeRef v27 = v17;
LABEL_35:
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v26, buf, 2u);
    goto LABEL_36;
  }
  long long v28 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    uint64_t v19 = "#I New fIPv4SCDict to be set";
    char v20 = v28;
    goto LABEL_45;
  }
LABEL_46:
  CFArrayRef v29 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v13, kSCPropNetIPv4Addresses);
  CFArrayRef v30 = v29;
  if (!v29 || (CFTypeID v31 = CFGetTypeID(v29), v31 != CFArrayGetTypeID()))
  {
    uint64_t v21 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v22 = "#I No kSCPropNetIPv4Addresses array in IPv4Service Info";
    goto LABEL_23;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v82 = 0;
  CSIPDPManager::getInterfaceNameById();
  CFIndex Count = CFArrayGetCount(v30);
  if (Count >= 1)
  {
    CFIndex v33 = 0;
    while (1)
    {
      CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(v30, v33);
      if (ValueAtIndex)
      {
        CFTypeID v35 = CFGetTypeID(ValueAtIndex);
        if (v35 == CFStringGetTypeID()) {
          break;
        }
      }
      if (Count == ++v33) {
        goto LABEL_68;
      }
    }
    memset(v92, 0, 24);
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    *(_OWORD *)unsigned int v92 = *(_OWORD *)buf;
    *(void *)&v92[16] = *(void *)&buf[16];
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    uint64_t v36 = *(void **)buf;
    v91[0] = *(void *)&buf[8];
    *(void *)((char *)v91 + 7) = *(void *)&buf[15];
    uint8_t v37 = buf[23];
    if (SHIBYTE(v90) < 0) {
      operator delete(v89);
    }
    int v89 = v36;
    *(void *)&long long v90 = v91[0];
    *(void *)((char *)&v90 + 7) = *(void *)((char *)v91 + 7);
    HIBYTE(v90) = v37;
    CFTypeRef v38 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      CFArrayRef v39 = __p;
      if (v82 < 0) {
        CFArrayRef v39 = (void **)__p[0];
      }
      long long v40 = v92;
      if ((v92[23] & 0x80u) != 0) {
        long long v40 = *(uint8_t **)v92;
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v39;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v40;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I IPv4Service: IPv4iface:%s: Found ipv4 address %s from IPv4Service Info", buf, 0x16u);
    }
    if ((char)v92[23] < 0) {
      operator delete(*(void **)v92);
    }
  }
LABEL_68:
  if (v90 >= 0) {
    uint64_t v41 = HIBYTE(v90);
  }
  else {
    uint64_t v41 = v90;
  }
  if (v41)
  {
    uint64_t v42 = CFDictionaryGetValue((CFDictionaryRef)v13, kSCPropNetIPv4Router);
    if (v42)
    {
      CFTypeID v43 = CFGetTypeID(v42);
      if (v43 == CFStringGetTypeID())
      {
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        int v44 = *(void **)buf;
        *(void *)unsigned int v92 = *(void *)&buf[8];
        *(void *)&v92[7] = *(void *)&buf[15];
        int v45 = (char)buf[23];
        if (SHIBYTE(v88) < 0) {
          operator delete(v87);
        }
        int v87 = v44;
        *(void *)&long long v88 = *(void *)v92;
        *(void *)((char *)&v88 + 7) = *(void *)&v92[7];
        HIBYTE(v88) = v45;
        uint64_t v46 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          CFTypeRef v47 = &v87;
          if (v45 < 0) {
            CFTypeRef v47 = (void **)v44;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v47;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Use %s as Router in IPv4Service Information (received from network)", buf, 0xCu);
        }
      }
    }
    *(void *)std::string buf = v13;
    sub_100282490((const void **)(a1 + 96), (CFTypeRef *)buf);
    sub_100058198(&v80, (const void **)(a1 + 96));
    sub_10027C2D0(a1, "IPv4Service: ip dict: fIPv4SCDict", (const __CFDictionary **)&v80);
    sub_100057D78(&v80);
    uint64_t v48 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v49 = *(void *)(a1 + 112);
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = v49;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I ipv4ServiceChanged succeeded, old fIPv4Addresses value is %p", buf, 0xCu);
    }
    uint64_t v50 = *(const void **)(a1 + 112);
    if (v50) {
      uint64_t v51 = sub_100083F10;
    }
    else {
      uint64_t v51 = 0;
    }
    if (!v51 || !CFEqual(v50, v30))
    {
      *(void *)std::string buf = v30;
      sub_1002824E4((const void **)(a1 + 112), (CFTypeRef *)buf);
    }
  }
  else
  {
    uint64_t v52 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "firstIPv4Addr is Null", buf, 2u);
    }
  }
  if (SHIBYTE(v82) < 0) {
    operator delete(__p[0]);
  }
  if (v41)
  {
    uint64_t v53 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I IPv4Service: publishing IPv4:", buf, 2u);
    }
    sub_10027C5D8(&v78, a1);
    uint64_t v77 = 0;
    BOOL v54 = sub_10027CE6C(a1, &v78, 1, &v77, (CSIPacketAddress **)(a1 + 552));
    sub_100057D78(&v77);
    if (v79) {
      sub_10004D2C8(v79);
    }
    CFTypeRef v55 = *(NSObject **)(a1 + 40);
    BOOL v56 = os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT);
    if (v54)
    {
      if (!v56) {
        goto LABEL_103;
      }
      *(_WORD *)std::string buf = 0;
      long long v57 = "#I IPv4Service: publishing IPv4: success";
    }
    else
    {
      if (!v56) {
        goto LABEL_103;
      }
      *(_WORD *)std::string buf = 0;
      long long v57 = "#N IPv4Service: publishing IPv4: failure";
    }
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, v57, buf, 2u);
LABEL_103:
    CFStringRef v58 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I IPv4Service onlineSuccess", buf, 2u);
    }
    memset(buf, 0, sizeof(buf));
    CSIPacketAddress::CSIPacketAddress();
    CSIPacketAddress::operator=();
    uint64_t v59 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      CSIPacketAddress::operator std::string();
      if (v82 >= 0) {
        int v60 = __p;
      }
      else {
        int v60 = (void **)__p[0];
      }
      long long v61 = &v87;
      if (v88 < 0) {
        long long v61 = v87;
      }
      *(_DWORD *)unsigned int v92 = 136315394;
      *(void *)&v92[4] = v60;
      *(_WORD *)&v92[12] = 2080;
      *(void *)&v92[14] = v61;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I IPv4Service: online for IPv4 with IP address %s, router %s", v92, 0x16u);
      if (SHIBYTE(v82) < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v62 = *(void *)(a1 + 360);
    for (uint64_t i = *(void *)(a1 + 368); v62 != i; v62 += 24)
    {
      uint64_t v64 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        CSIPacketAddress::operator std::string();
        uint64_t v65 = v82 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)unsigned int v92 = 136446210;
        *(void *)&v92[4] = v65;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I fDns:  %{public}s", v92, 0xCu);
        if (SHIBYTE(v82) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    if (*(_DWORD *)(a1 + 412) != 4) {
      sub_10027F0B8(a1, a1 + 296, 4u);
    }
    int v66 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I IPv4ServiceUp to be fired", (uint8_t *)__p, 2u);
    }
    uint64_t v67 = *(std::__shared_weak_count **)(a1 + 752);
    if (v67)
    {
      char v68 = std::__shared_weak_count::lock(v67);
      if (v68)
      {
        uint64_t v69 = *(void *)(a1 + 744);
        if (v69)
        {
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v69 + 24))(v69, buf);
          goto LABEL_132;
        }
      }
    }
    else
    {
      char v68 = 0;
    }
    uint64_t v70 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "IPv4ServiceUp cannot be fired: PDPManager observer is nullptr !", (uint8_t *)__p, 2u);
      if (!v68) {
        goto LABEL_133;
      }
    }
    else if (!v68)
    {
LABEL_133:
      uint64_t v71 = *(void *)(a1 + 472);
      if (v71) {
        goto LABEL_134;
      }
      uint64_t v71 = *(void *)(a1 + 664);
      if (v71)
      {
        uint64_t v73 = *(void *)(a1 + 672);
        if (v73) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v73 + 8), 1uLL, memory_order_relaxed);
        }
        CFStringRef v74 = *(std::__shared_weak_count **)(a1 + 480);
        *(void *)(a1 + 472) = v71;
        *(void *)(a1 + 480) = v73;
        if (!v74 || (sub_10004D2C8(v74), (uint64_t v71 = *(void *)(a1 + 472)) != 0))
        {
LABEL_134:
          uint64_t v72 = *(std::__shared_weak_count **)(a1 + 480);
          uint64_t v75 = v71;
          CFStringRef v76 = v72;
          if (v72) {
            atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          memset(buf, 0, sizeof(buf));
          (*(void (**)(uint64_t, uint64_t *, uint8_t *))(*(void *)a1 + 168))(a1, &v75, buf);
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          if (v76) {
            sub_10004D2C8(v76);
          }
        }
      }
      goto LABEL_36;
    }
LABEL_132:
    sub_10004D2C8(v68);
    goto LABEL_133;
  }
LABEL_24:
  uint64_t v23 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  *(void *)std::string buf = v23;
  sub_100057D78((const void **)buf);
  sub_100282538((void *)a1);
  sub_100282740((void *)a1, 1);
  CFDictionaryRef v24 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I IPv4Service NOT onlineSuccess", buf, 2u);
  }
  sub_100058DB0(__p, "0.0.0.0");
  CSIPacketAddress::CSIPacketAddress();
  CSIPacketAddress::operator=();
  if (SHIBYTE(v82) < 0) {
    operator delete(__p[0]);
  }
  *(void *)(a1 + 368) = *(void *)(a1 + 360);
  if (*(_DWORD *)(a1 + 412) != 1) {
    sub_10027F0B8(a1, a1 + 296, 1u);
  }
LABEL_36:
  sub_100057D78(&cf);
  if (SHIBYTE(v88) < 0) {
    operator delete(v87);
  }
  if (SHIBYTE(v90) < 0) {
    operator delete(v89);
  }
}

void sub_1002804E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,const void *a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  sub_10004D2C8(v42);
  sub_100057D78(&a30);
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  _Unwind_Resume(a1);
}

void sub_10028064C(uint64_t a1)
{
}

void sub_10028065C(uint64_t a1, char a2)
{
  std::string __p = 0;
  long long v176 = 0uLL;
  memset(v174, 0, 24);
  CFTypeRef cf = 0;
  CFTypeRef v173 = 0;
  sub_10027CC98(&v171, a1);
  sub_1000558F4(&v171);
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 104);
    *(_DWORD *)std::string buf = 138543362;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Run into ipv6ServiceChanged, fIPv6Addresses value is %{public}@", buf, 0xCu);
  }
  if (!*(void *)(a1 + 688))
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      CFTypeID v14 = "#I Got ipv6ServiceChanged without valid fIPv6Service, bailing out";
LABEL_40:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, buf, 2u);
    }
LABEL_41:
    int v26 = 0;
    goto LABEL_42;
  }
  unsigned int v6 = (const void *)IPConfigurationServiceCopyInformation();
  CFTypeRef v7 = cf;
  CFTypeRef cf = v6;
  *(void *)std::string buf = v7;
  sub_100057D78((const void **)buf);
  if (!cf)
  {
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v16 = 0;
      goto LABEL_13;
    }
    *(_WORD *)std::string buf = 0;
    CFTypeRef v10 = "#I Get IPv6Service Information Failed: serviceInfo is empty";
    unsigned int v11 = v15;
    uint32_t v12 = 2;
    goto LABEL_11;
  }
  CFTypeID v8 = CFGetTypeID(cf);
  unsigned int v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = v8;
    CFTypeRef v10 = "#I Get IPv6Service Information Type: %lu";
    unsigned int v11 = v9;
    uint32_t v12 = 12;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
  }
  CFTypeRef v16 = cf;
LABEL_13:
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (v16 && CFGetTypeID(v16) == TypeID)
  {
    CFDictionaryRef v18 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, kSCEntNetIPv6);
    CFDictionaryRef v19 = v18;
    if (v18)
    {
      CFTypeID v20 = CFGetTypeID(v18);
      if (v20 == CFDictionaryGetTypeID())
      {
        uint64_t v21 = (CFTypeRef *)(a1 + 88);
        sub_100058198(&v170, (const void **)(a1 + 88));
        sub_10027C2D0(a1, "IPv6Service: ip dict: old dictionary", (const __CFDictionary **)&v170);
        sub_100057D78(&v170);
        CFTypeRef v169 = cf;
        if (cf) {
          CFRetain(cf);
        }
        sub_10027C2D0(a1, "IPv6Service: ip dict: new (full) dictionary", (const __CFDictionary **)&v169);
        sub_100057D78(&v169);
        uint64_t v22 = CFDictionaryGetValue((CFDictionaryRef)cf, kSCEntNetIPv4);
        uint64_t v23 = v22;
        if (v22)
        {
          CFTypeID v24 = CFGetTypeID(v22);
          if (v24 == CFDictionaryGetTypeID())
          {
            *(void *)std::string buf = v23;
            sub_100282490(&v173, (CFTypeRef *)buf);
            CFTypeRef v168 = v173;
            if (v173) {
              CFRetain(v173);
            }
            sub_10027C2D0(a1, "IPv6Service - IPv4 info: ip dict", (const __CFDictionary **)&v168);
            sub_100057D78(&v168);
          }
        }
        if (*v21) {
          long long v25 = sub_100080778;
        }
        else {
          long long v25 = 0;
        }
        if (!v25)
        {
          int v26 = 1;
LABEL_49:
          CFDictionaryRef theDict = v19;
          CFArrayRef v36 = (const __CFArray *)CFDictionaryGetValue(v19, kSCPropNetIPv6Addresses);
          CFArrayRef v37 = v36;
          if (v36)
          {
            CFTypeID v38 = CFGetTypeID(v36);
            if (v38 == CFArrayGetTypeID())
            {
              long long v180 = 0uLL;
              uint64_t v181 = 0;
              CSIPDPManager::getInterfaceNameById();
              CFIndex Count = CFArrayGetCount(v37);
              char v138 = (const void **)(a1 + 88);
              CFArrayRef cf2 = v37;
              if (Count >= 1)
              {
                int v139 = 0;
                CFIndex v40 = 0;
                while (1)
                {
                  CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(v37, v40);
                  if (ValueAtIndex)
                  {
                    CFTypeID v42 = CFGetTypeID(ValueAtIndex);
                    if (v42 == CFStringGetTypeID()) {
                      break;
                    }
                  }
LABEL_100:
                  if (Count == ++v40) {
                    goto LABEL_211;
                  }
                }
                long long v166 = 0uLL;
                uint64_t v167 = 0;
                memset(buf, 0, 24);
                ctu::cf::assign();
                long long v166 = *(_OWORD *)buf;
                uint64_t v167 = *(void *)&buf[16];
                if (buf[23] >= 0) {
                  CFTypeID v43 = (const char *)&v166;
                }
                else {
                  CFTypeID v43 = (const char *)v166;
                }
                memset(&v182[8], 0, 20);
                *(void *)v182 = 7708;
                if (inet_pton(30, v43, &v182[8]) == 1)
                {
                  int v44 = socket(30, 2, 0);
                  if (v44 < 0)
                  {
                    CFStringRef v58 = *(NSObject **)(a1 + 40);
                    if (!os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_98;
                    }
                    uint64_t v59 = &v180;
                    if (v181 < 0) {
                      uint64_t v59 = (long long *)v180;
                    }
                    *(_DWORD *)std::string buf = 136315394;
                    *(void *)&uint8_t buf[4] = v59;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = v43;
                    BOOL v56 = v58;
                    long long v57 = "#I IPv6Service: IPv6iface:%s:sock: %s";
                  }
                  else
                  {
                    if (v181 >= 0) {
                      int v45 = (const char *)&v180;
                    }
                    else {
                      int v45 = (const char *)v180;
                    }
                    uint64_t v198 = 0;
                    long long v196 = 0u;
                    long long v197 = 0u;
                    long long v194 = 0u;
                    long long v195 = 0u;
                    long long v192 = 0u;
                    long long v193 = 0u;
                    long long v190 = 0u;
                    long long v191 = 0u;
                    long long v188 = 0u;
                    long long v189 = 0u;
                    long long v186 = 0u;
                    long long v187 = 0u;
                    long long v184 = 0u;
                    long long v185 = 0u;
                    *(_OWORD *)&buf[40] = 0u;
                    strncpy(buf, v45, 0x10uLL);
                    *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)v182;
                    *(_OWORD *)&buf[28] = *(_OWORD *)&v182[12];
                    if (ioctl(v44, 0xC1206949uLL, buf) >= 0) {
                      int v46 = *(_DWORD *)&buf[16];
                    }
                    else {
                      int v46 = 0;
                    }
                    close(v44);
                    CFTypeRef v47 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v48 = &v180;
                      if (v181 < 0) {
                        uint64_t v48 = (long long *)v180;
                      }
                      *(_DWORD *)std::string buf = 136315394;
                      *(void *)&uint8_t buf[4] = v48;
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v46;
                      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: IPv6iface:%s:flags: %x", buf, 0x12u);
                    }
                    if ((v46 & 0x80) == 0)
                    {
                      memset(buf, 0, 24);
                      ctu::cf::assign();
                      uint64_t v49 = *(void **)buf;
                      *(void *)v182 = *(void *)&buf[8];
                      *(void *)&v182[7] = *(void *)&buf[15];
                      char v50 = buf[23];
                      if (SHIBYTE(v176) < 0) {
                        operator delete(__p);
                      }
                      std::string __p = v49;
                      *(void *)&long long v176 = *(void *)v182;
                      *(void *)((char *)&v176 + 7) = *(void *)&v182[7];
                      HIBYTE(v176) = v50;
                      uint64_t v51 = *(NSObject **)(a1 + 40);
                      int v139 = 0;
                      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v52 = &v180;
                        if (v181 < 0) {
                          uint64_t v52 = (long long *)v180;
                        }
                        uint64_t v53 = &v166;
                        if (v167 < 0) {
                          uint64_t v53 = (long long *)v166;
                        }
                        *(_DWORD *)std::string buf = 136315394;
                        *(void *)&uint8_t buf[4] = v52;
                        *(_WORD *)&unsigned char buf[12] = 2080;
                        *(void *)&buf[14] = v53;
                        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: IPv6iface:%s: Found non temporary address %s, using it", buf, 0x16u);
                        int v139 = 0;
                      }
                      goto LABEL_98;
                    }
                    if (v176 >= 0) {
                      uint64_t v60 = HIBYTE(v176);
                    }
                    else {
                      uint64_t v60 = v176;
                    }
                    long long v61 = *(NSObject **)(a1 + 40);
                    BOOL v62 = os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT);
                    if (!v60)
                    {
                      if (v62)
                      {
                        uint64_t v65 = &v180;
                        if (v181 < 0) {
                          uint64_t v65 = (long long *)v180;
                        }
                        int v66 = &v166;
                        if (v167 < 0) {
                          int v66 = (long long *)v166;
                        }
                        *(_DWORD *)std::string buf = 136315394;
                        *(void *)&uint8_t buf[4] = v65;
                        *(_WORD *)&unsigned char buf[12] = 2080;
                        *(void *)&buf[14] = v66;
                        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: IPv6iface:%s: Temporary address found first %s", buf, 0x16u);
                      }
                      memset(buf, 0, 24);
                      ctu::cf::assign();
                      uint64_t v67 = *(void **)buf;
                      *(void *)v182 = *(void *)&buf[8];
                      *(void *)&v182[7] = *(void *)&buf[15];
                      char v68 = buf[23];
                      if (SHIBYTE(v176) < 0) {
                        operator delete(__p);
                      }
                      std::string __p = v67;
                      *(void *)&long long v176 = *(void *)v182;
                      *(void *)((char *)&v176 + 7) = *(void *)&v182[7];
                      HIBYTE(v176) = v68;
                      int v139 = 1;
                      goto LABEL_98;
                    }
                    if (!v62)
                    {
LABEL_98:
                      CFArrayRef v37 = cf2;
                      if (SHIBYTE(v167) < 0) {
                        operator delete((void *)v166);
                      }
                      goto LABEL_100;
                    }
                    uint64_t v63 = &v180;
                    if (v181 < 0) {
                      uint64_t v63 = (long long *)v180;
                    }
                    uint64_t v64 = &v166;
                    if (v167 < 0) {
                      uint64_t v64 = (long long *)v166;
                    }
                    *(_DWORD *)std::string buf = 136315394;
                    *(void *)&uint8_t buf[4] = v63;
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = v64;
                    BOOL v56 = v61;
                    long long v57 = "#I IPv6Service: IPv6iface:%s: ignoring temporary address %s";
                  }
                }
                else
                {
                  BOOL v54 = *(NSObject **)(a1 + 40);
                  if (!os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_98;
                  }
                  CFTypeRef v55 = &v180;
                  if (v181 < 0) {
                    CFTypeRef v55 = (long long *)v180;
                  }
                  *(_DWORD *)std::string buf = 136315394;
                  *(void *)&uint8_t buf[4] = v55;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = v43;
                  BOOL v56 = v54;
                  long long v57 = "#I IPv6Service: IPv6iface:%s:inet_pton: %s";
                }
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, v57, buf, 0x16u);
                goto LABEL_98;
              }
              int v139 = 0;
LABEL_211:
              if (v176 >= 0) {
                uint64_t v99 = HIBYTE(v176);
              }
              else {
                uint64_t v99 = v176;
              }
              if (v99)
              {
                CFArrayRef v100 = (const __CFArray *)CFDictionaryGetValue(theDict, kSCPropNetIPv6PrefixLength);
                CFArrayRef v101 = v100;
                if (v100
                  && (CFTypeID v102 = CFGetTypeID(v100), v102 == CFArrayGetTypeID())
                  && (unsigned int v103 = (void *)CFArrayGetValueAtIndex(v101, 0), (v104 = (unsigned int *)v103) != 0))
                {
                  CFTypeID v105 = CFGetTypeID(v103);
                  unsigned int v34 = 128;
                  if (v105 == CFNumberGetTypeID())
                  {
                    *(_DWORD *)std::string buf = 128;
                    ctu::cf::assign((ctu::cf *)buf, v104, v106);
                    unsigned int v34 = *(_DWORD *)buf;
                  }
                }
                else
                {
                  unsigned int v34 = 128;
                }
                uint64_t v107 = CFDictionaryGetValue(theDict, kSCPropNetIPv6Router);
                if (v107 && (CFTypeID v108 = CFGetTypeID(v107), v108 == CFStringGetTypeID()))
                {
                  *(void *)std::string buf = theDict;
                  sub_100282490(v138, (CFTypeRef *)buf);
                  memset(buf, 0, 24);
                  ctu::cf::assign();
                  unsigned int v109 = *(void **)buf;
                  *(void *)v182 = *(void *)&buf[8];
                  *(void *)&v182[7] = *(void *)&buf[15];
                  int v110 = buf[23];
                  if (SHIBYTE(v174[2]) < 0) {
                    operator delete(v174[0]);
                  }
                  v174[0] = v109;
                  v174[1] = *(void **)v182;
                  *(void **)((char *)&v174[1] + 7) = *(void **)&v182[7];
                  HIBYTE(v174[2]) = v110;
                  __int16 v111 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
                  {
                    unsigned int v112 = v174;
                    if (v110 < 0) {
                      unsigned int v112 = (void **)v109;
                    }
                    *(_DWORD *)std::string buf = 136315138;
                    *(void *)&uint8_t buf[4] = v112;
                    _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I Use %s as Router in IPv6Service Information (received from network)", buf, 0xCu);
                  }
                }
                else
                {
                  long long v166 = 0uLL;
                  uint64_t v167 = 0;
                  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v166);
                  if (*(unsigned char *)(a1 + 600) && !CSIPacketAddress::isZeroIP((CSIPacketAddress *)(a1 + 576)))
                  {
                    __int16 v114 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)std::string buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_DEFAULT, "#I No kSCPropNetIPv6Router in IPv6Service Information, use last configured router", buf, 2u);
                    }
                    CSIPacketAddress::operator=();
                  }
                  else
                  {
                    int v113 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)std::string buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEFAULT, "#I No kSCPropNetIPv6Router in IPv6Service Information, use first IP Prefix", buf, 2u);
                    }
                    CSIPacketAddress::CSIPacketAddress();
                    CSIPacketAddress::operator=();
                    CSIPacketAddress::applyMaskPrefix((CSIPacketAddress *)&v166, v34);
                  }
                  CSIPacketAddress::operator std::string();
                  if (SHIBYTE(v174[2]) < 0) {
                    operator delete(v174[0]);
                  }
                  v174[2] = *(void **)&buf[16];
                  *(_OWORD *)v174 = *(_OWORD *)buf;
                  value = 0;
                  if ((buf[23] & 0x80000000) != 0)
                  {
                    sub_10004FC84(&__dst, v174[0], (unint64_t)v174[1]);
                  }
                  else
                  {
                    long long __dst = *(_OWORD *)v174;
                    uint64_t v164 = v174[2];
                  }
                  if (SHIBYTE(v164) < 0)
                  {
                    sub_10004FC84(v182, (void *)__dst, *((unint64_t *)&__dst + 1));
                  }
                  else
                  {
                    *(_OWORD *)v182 = __dst;
                    *(void *)&v182[16] = v164;
                  }
                  v177 = 0;
                  if ((char)v182[23] < 0)
                  {
                    sub_10004FC84(buf, *(void **)v182, *(unint64_t *)&v182[8]);
                  }
                  else
                  {
                    *(_OWORD *)std::string buf = *(_OWORD *)v182;
                    *(void *)&uint8_t buf[16] = *(void *)&v182[16];
                  }
                  v178 = 0;
                  if (ctu::cf::convert_copy())
                  {
                    uint64_t v115 = v177;
                    v177 = v178;
                    v179 = v115;
                    sub_1000558F4(&v179);
                  }
                  if ((buf[23] & 0x80000000) != 0) {
                    operator delete(*(void **)buf);
                  }
                  value = v177;
                  v177 = 0;
                  sub_1000558F4((const void **)&v177);
                  if ((char)v182[23] < 0) {
                    operator delete(*(void **)v182);
                  }
                  if (SHIBYTE(v164) < 0) {
                    operator delete((void *)__dst);
                  }
                  int v116 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
                  {
                    CSIPacketAddress::operator std::string();
                    __int16 v117 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
                    *(_DWORD *)v182 = 136315138;
                    *(void *)&v182[4] = v117;
                    _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "#I Use %s as Router in IPv6Service Information (constructed)", v182, 0xCu);
                    if ((buf[23] & 0x80000000) != 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                  *(void *)v182 = 0;
                  *(void *)v182 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
                  CFDictionarySetValue(*(CFMutableDictionaryRef *)v182, kSCPropNetIPv6Router, value);
                  sub_10004EFE4(&v179, (CFTypeRef *)v182);
                  if (v138 != &v179)
                  {
                    *(void *)std::string buf = *v138;
                    *char v138 = v179;
                    v179 = 0;
                    sub_100057D78((const void **)buf);
                  }
                  sub_100057D78(&v179);
                  sub_10005717C((const void **)v182);
                  sub_1000558F4((const void **)&value);
                }
                sub_100058198(&v162, v138);
                sub_10027C2D0(a1, "IPv6Service: ip dict: fIPv6SCDict", (const __CFDictionary **)&v162);
                sub_100057D78(&v162);
                int v118 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v119 = *(void *)(a1 + 104);
                  *(_DWORD *)std::string buf = 138543362;
                  *(void *)&uint8_t buf[4] = v119;
                  _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "#I ipv6ServiceChanged succeeded, fIPv6Addresses value is %{public}@", buf, 0xCu);
                }
                uint64_t v120 = *(const void **)(a1 + 104);
                if (v120) {
                  uint64_t v121 = sub_100083F10;
                }
                else {
                  uint64_t v121 = 0;
                }
                if (v121 && CFEqual(v120, cf2))
                {
                  int v141 = 0;
                }
                else
                {
                  *(void *)std::string buf = cf2;
                  sub_1002824E4((const void **)(a1 + 104), (CFTypeRef *)buf);
                  int v141 = 1;
                }
              }
              else
              {
                int v141 = 0;
                LOBYTE(v34) = 0x80;
              }
              if (SHIBYTE(v181) < 0) {
                operator delete((void *)v180);
              }
              int v31 = v139;
              if (v99)
              {
                if (!v26) {
                  goto LABEL_291;
                }
                uint64_t v122 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)std::string buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: publishing IPv6:", buf, 2u);
                }
                sub_10027C5D8(&v160, a1);
                uint64_t v159 = 0;
                BOOL v123 = sub_10027CE6C(a1, &v160, 2, &v159, (CSIPacketAddress **)(a1 + 360));
                sub_100057D78(&v159);
                if (v161) {
                  sub_10004D2C8(v161);
                }
                long long v124 = *(NSObject **)(a1 + 40);
                BOOL v125 = os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT);
                if (v123)
                {
                  if (!v125) {
                    goto LABEL_291;
                  }
                  *(_WORD *)std::string buf = 0;
                  v126 = "#I IPv6Service: publishing IPv6: success";
                }
                else
                {
                  if (!v125) {
                    goto LABEL_291;
                  }
                  *(_WORD *)std::string buf = 0;
                  v126 = "#N IPv6Service: publishing IPv6: failure";
                }
                _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, v126, buf, 2u);
LABEL_291:
                if (v173) {
                  CFIndex v33 = sub_100080778;
                }
                else {
                  CFIndex v33 = 0;
                }
                if (!v33) {
                  goto LABEL_326;
                }
                std::string::size_type v127 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)std::string buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: xlat464: publishing IPv4:", buf, 2u);
                }
                sub_10027C5D8(&v157, a1);
                CFTypeRef v156 = v173;
                if (v173) {
                  CFRetain(v173);
                }
                sub_10027CE6C(a1, &v157, 1, &v156, (CSIPacketAddress **)(a1 + 552));
                sub_100057D78(&v156);
                if (v158) {
                  sub_10004D2C8(v158);
                }
                if (CSIPacketAddress::isZeroIP((CSIPacketAddress *)(a1 + 336)))
                {
                  CFArrayRef v128 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v173, kSCPropNetIPv4Addresses);
                  CFArrayRef v129 = v128;
                  if (v128 && (CFTypeID v130 = CFGetTypeID(v128), v130 == CFArrayGetTypeID()))
                  {
                    CFIndex cf2a = CFArrayGetCount(v129);
                    if (cf2a >= 1)
                    {
                      for (CFIndex i = 0; i != cf2a; ++i)
                      {
                        std::string v132 = CFArrayGetValueAtIndex(v129, i);
                        if (v132)
                        {
                          CFTypeID v133 = CFGetTypeID(v132);
                          if (v133 == CFStringGetTypeID())
                          {
                            memset(v182, 0, 24);
                            memset(buf, 0, 24);
                            ctu::cf::assign();
                            *(_OWORD *)v182 = *(_OWORD *)buf;
                            *(void *)&v182[16] = *(void *)&buf[16];
                            std::string v134 = *(NSObject **)(a1 + 40);
                            if (os_log_type_enabled(v134, OS_LOG_TYPE_DEFAULT))
                            {
                              std::string v135 = v182;
                              if ((v182[23] & 0x80u) != 0) {
                                std::string v135 = *(uint8_t **)v182;
                              }
                              *(_DWORD *)std::string buf = 136315138;
                              *(void *)&uint8_t buf[4] = v135;
                              _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: xlat464: IPv4 addr: Found address %s, using it", buf, 0xCu);
                            }
                            CSIPacketAddress::CSIPacketAddress();
                            CSIPacketAddress::operator=();
                            if (*(_DWORD *)(a1 + 412) != 4) {
                              sub_10027F0B8(a1, a1 + 296, 4u);
                            }
                            if ((char)v182[23] < 0) {
                              operator delete(*(void **)v182);
                            }
                          }
                        }
                      }
                    }
                    if (!CSIPacketAddress::isZeroIP((CSIPacketAddress *)(a1 + 336)))
                    {
                      *(_WORD *)(a1 + 432) = 257;
                      sub_100283188(a1 + 432);
                      sub_10027C5D8(&v154, a1);
                      sub_10027EC44(a1, &v154);
                      if (v155) {
                        sub_10004D2C8(v155);
                      }
                      goto LABEL_325;
                    }
                    uint64_t v136 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)std::string buf = 0;
                      uint64_t v137 = "#N IPv6Service: xlat464: IPv4 address empty";
LABEL_324:
                      _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, v137, buf, 2u);
                    }
                  }
                  else
                  {
                    uint64_t v136 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)std::string buf = 0;
                      uint64_t v137 = "#E IPv6Service: xlat464: No kSCPropNetIPv4Addresses array in IPv6Service XLAT46 Information";
                      goto LABEL_324;
                    }
                  }
                }
                else
                {
                  uint64_t v136 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)std::string buf = 0;
                    uint64_t v137 = "#N IPv6Service: xlat464: IPv4 address already filled in";
                    goto LABEL_324;
                  }
                }
LABEL_325:
                LODWORD(v33) = 0;
LABEL_326:
                int v32 = 1;
LABEL_44:
                if (v26) {
                  int v30 = 1;
                }
                else {
                  int v30 = (int)v33;
                }
                goto LABEL_117;
              }
LABEL_43:
              uint64_t v35 = *(void *)(a1 + 88);
              *(void *)(a1 + 88) = 0;
              *(void *)std::string buf = v35;
              sub_100057D78((const void **)buf);
              sub_100282DDC((void *)a1);
              sub_100282740((void *)a1, 2);
              int v32 = 0;
              LODWORD(v33) = 1;
              goto LABEL_44;
            }
          }
          uint64_t v69 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "#I No kSCPropNetIPv6Addresses array in IPv6Service Information", buf, 2u);
          }
LABEL_42:
          int v141 = 0;
          int v31 = 0;
          LOBYTE(v34) = 0x80;
          goto LABEL_43;
        }
        int v26 = 1;
        if (!CFEqual(*v21, v19) || (a2 & 1) != 0) {
          goto LABEL_49;
        }
        if (v173) {
          CFTypeRef v27 = sub_100080778;
        }
        else {
          CFTypeRef v27 = 0;
        }
        if (v27)
        {
          int v26 = 0;
          goto LABEL_49;
        }
        long long v28 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          CFArrayRef v29 = "#I Nothing is changed for IPv6Service Information, ignore";
          goto LABEL_37;
        }
LABEL_115:
        int v31 = 0;
        int v141 = 0;
        int v32 = 0;
        LODWORD(v33) = 0;
        int v30 = 2;
        goto LABEL_116;
      }
    }
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      CFTypeID v14 = "#I No kSCEntNetIPv6 key in IPv6Service Information";
      goto LABEL_40;
    }
    goto LABEL_41;
  }
  long long v28 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_115;
  }
  *(_WORD *)std::string buf = 0;
  CFArrayRef v29 = "#I Get IPv6Service Information Failed. Maybe configd restarted, ignore";
LABEL_37:
  int v30 = 2;
  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v29, buf, 2u);
  int v31 = 0;
  int v141 = 0;
  int v32 = 0;
  LODWORD(v33) = 0;
LABEL_116:
  LOBYTE(v34) = 0x80;
LABEL_117:
  if (v173) {
    uint64_t v70 = sub_100080778;
  }
  else {
    uint64_t v70 = 0;
  }
  if (v30 != 1 && v70) {
    goto LABEL_122;
  }
  if (v32)
  {
    uint64_t v73 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#I IPv6Service onlineSuccess", buf, 2u);
    }
    memset(v182, 0, 24);
    CSIPacketAddress::CSIPacketAddress();
    CSIPacketAddress::setPrefixLen((CSIPacketAddress *)v182, v34);
    CSIPacketAddress::operator=();
    CSIPacketAddress::CSIPacketAddress();
    CSIPacketAddress::operator=();
    CFStringRef v74 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
    {
      CSIPacketAddress::operator std::string();
      if (v181 >= 0) {
        uint64_t v75 = &v180;
      }
      else {
        uint64_t v75 = (long long *)v180;
      }
      CFStringRef v76 = "";
      if (v31) {
        CFStringRef v76 = "(temporary only)";
      }
      uint64_t v77 = v174;
      *(_DWORD *)std::string buf = 136315650;
      if (SHIBYTE(v174[2]) < 0) {
        uint64_t v77 = (void **)v174[0];
      }
      *(void *)&uint8_t buf[4] = v75;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v76;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = v77;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I IPv6Service: online for IPv6 with IP address %s%s, router %s", buf, 0x20u);
      if (SHIBYTE(v181) < 0) {
        operator delete((void *)v180);
      }
    }
    uint64_t v78 = *(void *)(a1 + 552);
    for (uint64_t j = *(void *)(a1 + 560); v78 != j; v78 += 24)
    {
      uint64_t v80 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
      {
        CSIPacketAddress::operator std::string();
        unint64_t v81 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
        LODWORD(v180) = 136446210;
        *(void *)((char *)&v180 + 4) = v81;
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I fDns:  %{public}s", (uint8_t *)&v180, 0xCu);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
    }
    if (*(_DWORD *)(a1 + 604) != 4) {
      sub_10027F0B8(a1, a1 + 488, 4u);
    }
    if ((v31 & 1) == 0)
    {
      uint64_t v82 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v83 = asStringBool();
        uint64_t v84 = asStringBool(*(void *)(a1 + 440) != 0);
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v83;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v84;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I IPv6ServiceUp: ipv4ConfigState=%s, ipv4Timer=%s", buf, 0x16u);
      }
      if (*(unsigned char *)(a1 + 433))
      {
        uint64_t v85 = *(NSObject **)(a1 + 40);
        if (!*(unsigned char *)(a1 + 432))
        {
          uint64_t v86 = *(void *)(a1 + 440);
          BOOL v87 = os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT);
          if (v86)
          {
            if (v87)
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I IPv6ServiceUp to be fired after timer - the timer already set", buf, 2u);
            }
          }
          else
          {
            if (v87)
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I IPv6ServiceUp to be fired after timer anyway if XLAT not configured properly", buf, 2u);
            }
            *(void *)&uint8_t buf[8] = 0;
            *(void *)std::string buf = 0;
            sub_1002598D0(buf, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
            Registry::getTimerService((uint64_t *)&v180, *(Registry **)(a1 + 48));
            uint64_t v95 = v180;
            sub_100058DB0(v151, "XlatTimer");
            unsigned int v96 = *(NSObject **)(a1 + 24);
            dispatch_object_t object = v96;
            if (v96) {
              dispatch_retain(v96);
            }
            aBlock[0] = _NSConcreteStackBlock;
            aBlock[1] = 1174405120;
            aBlock[2] = sub_100282FE4;
            aBlock[3] = &unk_1019B2600;
            CFStringRef v97 = *(std::__shared_weak_count **)&buf[8];
            aBlock[4] = a1;
            void aBlock[5] = *(void *)buf;
            uint64_t v147 = *(std::__shared_weak_count **)&buf[8];
            if (*(void *)&buf[8]) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
            }
            CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v148, (const CSIPacketAddress *)v182);
            int v149 = _Block_copy(aBlock);
            sub_100118A44(v95, (uint64_t)v151, 0, 1000000, &object, &v149);
            uint64_t v98 = *(void *)(a1 + 440);
            *(void *)(a1 + 440) = v153;
            uint64_t v153 = 0;
            if (v98) {
              (*(void (**)(uint64_t))(*(void *)v98 + 8))(v98);
            }
            if (v149) {
              _Block_release(v149);
            }
            if (object) {
              dispatch_release(object);
            }
            if (v152 < 0) {
              operator delete(v151[0]);
            }
            if (*((void *)&v180 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v180 + 1));
            }
            if (v147) {
              std::__shared_weak_count::__release_weak(v147);
            }
            if (v97) {
              std::__shared_weak_count::__release_weak(v97);
            }
          }
          goto LABEL_122;
        }
      }
      else
      {
        uint64_t v85 = *(NSObject **)(a1 + 40);
      }
      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I IPv6ServiceUp to be fired", buf, 2u);
      }
      int v91 = *(std::__shared_weak_count **)(a1 + 752);
      if (v91)
      {
        unsigned int v92 = std::__shared_weak_count::lock(v91);
        if (v92)
        {
          uint64_t v93 = *(void *)(a1 + 744);
          if (v93)
          {
            (*(void (**)(uint64_t, uint8_t *))(*(void *)v93 + 16))(v93, v182);
            goto LABEL_189;
          }
        }
      }
      else
      {
        unsigned int v92 = 0;
      }
      unsigned int v94 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "IPv6ServiceUp cannot be fired: PDPManager observer is nullptr !", buf, 2u);
        if (!v92) {
          goto LABEL_122;
        }
      }
      else if (!v92)
      {
        goto LABEL_122;
      }
LABEL_189:
      sub_10004D2C8(v92);
    }
  }
  else if (v33)
  {
    long long v88 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I IPv6Service NOT onlineSuccess", buf, 2u);
    }
    sub_100058DB0(v182, "0.0.0.0");
    CSIPacketAddress::CSIPacketAddress();
    CSIPacketAddress::operator=();
    if ((char)v182[23] < 0) {
      operator delete(*(void **)v182);
    }
    *(void *)(a1 + 560) = *(void *)(a1 + 552);
    if (*(_DWORD *)(a1 + 604) != 1) {
      sub_10027F0B8(a1, a1 + 488, 1u);
    }
  }
LABEL_122:
  if (v141)
  {
    uint64_t v71 = *(void *)(a1 + 664);
    if (v71) {
      goto LABEL_124;
    }
    uint64_t v71 = *(void *)(a1 + 472);
    if (v71)
    {
      uint64_t v89 = *(void *)(a1 + 480);
      if (v89) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v89 + 8), 1uLL, memory_order_relaxed);
      }
      *(void *)(a1 + 664) = v71;
      long long v90 = *(std::__shared_weak_count **)(a1 + 672);
      *(void *)(a1 + 672) = v89;
      if (!v90 || (sub_10004D2C8(v90), (uint64_t v71 = *(void *)(a1 + 664)) != 0))
      {
LABEL_124:
        uint64_t v72 = *(std::__shared_weak_count **)(a1 + 672);
        uint64_t v144 = v71;
        int v145 = v72;
        if (v72) {
          atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        memset(buf, 0, 24);
        (*(void (**)(uint64_t, uint64_t *, unsigned char *))(*(void *)a1 + 168))(a1, &v144, buf);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (v145) {
          sub_10004D2C8(v145);
        }
      }
    }
    sub_100283288((wis::MetricFactory *)0x8004F);
  }
  sub_100057D78(&cf);
  sub_100057D78(&v173);
  if (SHIBYTE(v174[2]) < 0) {
    operator delete(v174[0]);
  }
  if (SHIBYTE(v176) < 0) {
    operator delete(__p);
  }
}

void sub_100282168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30,uint64_t a31,uint64_t a32,uint64_t a33,void *aBlock,dispatch_object_t object,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,std::__shared_weak_count *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,const void *a61,const void *a62,void *__p)
{
  if (a41) {
    sub_10004D2C8(a41);
  }
  sub_100057D78(&a61);
  sub_100057D78(&a62);
  if (a68 < 0) {
    operator delete(__p);
  }
  if (a72 < 0) {
    operator delete(a70);
  }
  _Unwind_Resume(a1);
}

const void **sub_100282490(const void **a1, CFTypeRef *a2)
{
  CFTypeRef v3 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  uint64_t v4 = *a1;
  *a1 = v3;
  unsigned int v6 = v4;
  sub_100057D78(&v6);
  return a1;
}

const void **sub_1002824E4(const void **a1, CFTypeRef *a2)
{
  CFTypeRef v3 = *a2;
  if (*a2) {
    CFRetain(*a2);
  }
  uint64_t v4 = *a1;
  *a1 = v3;
  unsigned int v6 = v4;
  sub_100044D00(&v6);
  return a1;
}

void sub_100282538(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I IPv4Service tear down: fIPv4SCDict...", buf, 2u);
  }
  uint64_t v3 = a1[12];
  if (v3) {
    uint64_t v4 = sub_100080778;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    a1[12] = 0;
    *(void *)std::string buf = v3;
    sub_100057D78((const void **)buf);
  }
  uint64_t v5 = a1[5];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I IPv4Service tear down: fDSRefForIPv4...", buf, 2u);
  }
  unsigned int v6 = (const __SCDynamicStore *)a1[89];
  if (v6) {
    CFTypeRef v7 = sub_100142574;
  }
  else {
    CFTypeRef v7 = 0;
  }
  if (v7)
  {
    SCDynamicStoreSetDispatchQueue(v6, 0);
    uint64_t v8 = a1[89];
    a1[89] = 0;
    *(void *)std::string buf = v8;
    sub_100142A3C((const void **)buf);
  }
  unsigned int v9 = a1[5];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I IPv4Service tear down: fIPv4Service...", buf, 2u);
    unsigned int v9 = a1[5];
  }
  CFTypeRef v10 = (const void *)a1[87];
  BOOL v11 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    if (v11)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I non-empty IPv4Service tear down...", buf, 2u);
      CFTypeRef v10 = (const void *)a1[87];
    }
    a1[87] = 0;
    CFTypeRef cf = v10;
    sub_100285348((uint64_t)a1, &cf);
    CFTypeRef v12 = cf;
    CFTypeRef cf = 0;
    if (v12) {
      CFRelease(v12);
    }
  }
  else if (v11)
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I IPv4Service tear down: already empty", buf, 2u);
  }
}

void sub_100282728(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10028E6F8((const void **)va, 0);
  _Unwind_Resume(a1);
}

const void **sub_100282740(void *a1, int a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Doing SC cleanup while during offline for IPFamily %u", buf, 8u);
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t v5 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFMutableDictionaryRef v35 = v5;
  if (Mutable) {
    unsigned int v6 = sub_100289354;
  }
  else {
    unsigned int v6 = 0;
  }
  if (v6)
  {
    if (v5 ? sub_1000C06D0 : 0)
    {
      CFStringRef serviceID = 0;
      sub_10027CC98((const void **)&serviceID, (uint64_t)a1);
      if (serviceID) {
        uint64_t v8 = sub_1000810B8;
      }
      else {
        uint64_t v8 = 0;
      }
      if (!v8)
      {
        CFTypeID v20 = a1[5];
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N failed to get serviceID for IPFamily %u", buf, 8u);
        }
        goto LABEL_71;
      }
      SCDynamicStoreRef store = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:offline", 0, 0);
      if (store) {
        unsigned int v9 = sub_100142574;
      }
      else {
        unsigned int v9 = 0;
      }
      if (!v9)
      {
        uint64_t v21 = a1[5];
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I failed create dynamic store for IPFamily %u", buf, 8u);
        }
        goto LABEL_70;
      }
      key = (void *)SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, serviceID, kSCEntNetDNS);
      if (key) {
        CFTypeRef v10 = sub_1000810B8;
      }
      else {
        CFTypeRef v10 = 0;
      }
      if (!v10)
      {
        uint64_t v22 = a1[5];
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I failed create service entity key for DNS for IPFamily %u", buf, 8u);
        }
        goto LABEL_69;
      }
      CFMutableArrayRef theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (theArray) {
        BOOL v11 = sub_100289354;
      }
      else {
        BOOL v11 = 0;
      }
      if (!v11)
      {
LABEL_68:
        sub_1000440D4((const void **)&theArray);
LABEL_69:
        sub_1000558F4((const void **)&key);
LABEL_70:
        sub_100142A3C((const void **)&store);
LABEL_71:
        sub_1000558F4((const void **)&serviceID);
        goto LABEL_72;
      }
      CFDictionaryRef theDict = 0;
      *(void *)std::string buf = SCDynamicStoreCopyValue(store, (CFStringRef)key);
      sub_100084068(&theDict, (CFTypeRef *)buf);
      if (theDict) {
        CFTypeRef v12 = sub_100080778;
      }
      else {
        CFTypeRef v12 = 0;
      }
      if (v12 && CFDictionaryContainsKey(theDict, kSCPropNetDNSServerAddresses))
      {
        *(void *)std::string buf = 0;
        CFTypeRef Value = CFDictionaryGetValue(theDict, kSCPropNetDNSServerAddresses);
        sub_100044D6C(buf, &Value);
        if (*(void *)buf) {
          uint64_t v13 = sub_100083F10;
        }
        else {
          uint64_t v13 = 0;
        }
        if (v13)
        {
          CFIndex Count = CFArrayGetCount(*(CFArrayRef *)buf);
          if (Count >= 1)
          {
            for (CFIndex i = 0; i != Count; ++i)
            {
              CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)buf, i);
              if (sub_10028935C() != a2) {
                CFArrayAppendValue(theArray, ValueAtIndex);
              }
            }
          }
        }
        sub_100044D00((const void **)buf);
      }
      if (CFArrayGetCount(theArray))
      {
        uint64_t v17 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(void *)std::string buf = v17;
        if (v17) {
          CFDictionaryRef v18 = sub_1000C06D0;
        }
        else {
          CFDictionaryRef v18 = 0;
        }
        if (!v18)
        {
          sub_10005717C((const void **)buf);
LABEL_67:
          sub_100057D78((const void **)&theDict);
          goto LABEL_68;
        }
        CFDictionarySetValue(v17, kSCPropNetDNSServerAddresses, theArray);
        CFDictionarySetValue(v35, key, *(const void **)buf);
        sub_10005717C((const void **)buf);
      }
      else
      {
        CFArrayAppendValue(Mutable, key);
      }
      uint64_t v23 = (CFStringRef *)&kSCEntNetIPv6;
      if (a2 != 2) {
        uint64_t v23 = (CFStringRef *)&kSCEntNetIPv4;
      }
      CFStringRef NetworkServiceEntity = (__CFString *)SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, serviceID, *v23);
      long long v25 = key;
      key = NetworkServiceEntity;
      *(void *)std::string buf = v25;
      sub_1000558F4((const void **)buf);
      if (key) {
        int v26 = sub_1000810B8;
      }
      else {
        int v26 = 0;
      }
      if (v26)
      {
        CFArrayAppendValue(Mutable, key);
        SCDynamicStoreSetMultiple(store, v35, Mutable, 0);
        (*(void (**)(void *))(*a1 + 208))(a1);
      }
      else
      {
        CFTypeRef v27 = a1[5];
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I failed create service entity key for IPFamily %u", buf, 8u);
        }
      }
      goto LABEL_67;
    }
  }
  CFDictionaryRef v19 = a1[5];
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I failed to create array for keys to remove for IPFamily %u", buf, 8u);
  }
LABEL_72:
  sub_10005717C((const void **)&v35);
  return sub_1000440D4((const void **)&Mutable);
}

void sub_100282D2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va7, a2);
  va_start(va6, a2);
  va_start(va5, a2);
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, const void *);
  va_copy(va3, va2);
  CFTypeRef v7 = va_arg(va3, const void *);
  va_copy(va4, va3);
  unsigned int v9 = va_arg(va4, const void *);
  va_copy(va5, va4);
  BOOL v11 = va_arg(va5, const void *);
  va_copy(va6, va5);
  uint64_t v13 = va_arg(va6, const void *);
  va_copy(va7, va6);
  uint64_t v15 = va_arg(va7, const void *);
  sub_100044D00((const void **)va7);
  sub_100057D78((const void **)va);
  sub_1000440D4((const void **)va1);
  sub_1000558F4((const void **)va2);
  sub_100142A3C((const void **)va3);
  sub_1000558F4((const void **)va4);
  sub_10005717C((const void **)va5);
  sub_1000440D4((const void **)va6);
  _Unwind_Resume(a1);
}

void sub_100282DDC(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I IPv6Service tear down: fIPv6SCDict...", buf, 2u);
  }
  uint64_t v3 = a1[11];
  if (v3) {
    uint64_t v4 = sub_100080778;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    a1[11] = 0;
    *(void *)std::string buf = v3;
    sub_100057D78((const void **)buf);
  }
  uint64_t v5 = a1[5];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I IPv6Service tear down: fDSRefForIPv6...", buf, 2u);
  }
  unsigned int v6 = (const __SCDynamicStore *)a1[88];
  if (v6) {
    CFTypeRef v7 = sub_100142574;
  }
  else {
    CFTypeRef v7 = 0;
  }
  if (v7)
  {
    SCDynamicStoreSetDispatchQueue(v6, 0);
    uint64_t v8 = a1[88];
    a1[88] = 0;
    *(void *)std::string buf = v8;
    sub_100142A3C((const void **)buf);
  }
  unsigned int v9 = a1[5];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I IPv6Service tear down: fIPv6Service...", buf, 2u);
    unsigned int v9 = a1[5];
  }
  CFTypeRef v10 = (const void *)a1[86];
  BOOL v11 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v10)
  {
    if (v11)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I non-empty IPv6Service tear down...", buf, 2u);
      CFTypeRef v10 = (const void *)a1[86];
    }
    a1[86] = 0;
    CFTypeRef cf = v10;
    sub_10028542C((uint64_t)a1, &cf);
    CFTypeRef v12 = cf;
    CFTypeRef cf = 0;
    if (v12) {
      CFRelease(v12);
    }
  }
  else if (v11)
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I IPv6Service tear down: already empty", buf, 2u);
  }
}

void sub_100282FCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10028E6F8((const void **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100282FE4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        unsigned int v6 = v3[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#E ipv4Timer: XLAT464 config has not completed in time", buf, 2u);
        }
        sub_100283188((uint64_t)(v3 + 54));
        CFTypeRef v7 = (std::__shared_weak_count *)v3[94];
        if (v7)
        {
          uint64_t v8 = std::__shared_weak_count::lock(v7);
          if (v8)
          {
            uint64_t v9 = v3[93];
            if (v9)
            {
              CFTypeRef v10 = v3[5];
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)uint64_t v13 = 0;
                _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I IPv6ServiceUp to be fired - timer expired", v13, 2u);
              }
              (*(void (**)(uint64_t, void *))(*(void *)v9 + 16))(v9, a1 + 7);
              goto LABEL_15;
            }
          }
        }
        else
        {
          uint64_t v8 = 0;
        }
        BOOL v11 = v3[5];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)CFTypeRef v12 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "IPv6ServiceUp cannot be fired: PDPManager observer is nullptr !", v12, 2u);
          if (!v8) {
            goto LABEL_16;
          }
          goto LABEL_15;
        }
        if (v8) {
LABEL_15:
        }
          sub_10004D2C8(v8);
      }
LABEL_16:
      sub_10004D2C8(v5);
    }
  }
}

void sub_100283164(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100283188(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 16))(result);
    uint64_t result = *(void *)(a1 + 8);
    *(void *)(a1 + 8) = 0;
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 8);
      return v3();
    }
  }
  return result;
}

void sub_10028321C(void *a1, void *a2)
{
  uint64_t v2 = a2[6];
  a1[5] = a2[5];
  a1[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 7), (const CSIPacketAddress *)(a2 + 7));
}

void sub_100283260(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100283278(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100283288(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    uint64_t v4 = (wis::MetricContainer *)v3;
    uint64_t v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    unsigned int v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_1002833E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100283468(id a1, void *a2)
{
  int v2 = *((_DWORD *)a2 + 9);
  *((unsigned char *)a2 + 24) = 1;
  *((_DWORD *)a2 + 9) = v2 | 0xA;
  *((_DWORD *)a2 + 7) = 6;
}

void sub_10028348C(uint64_t a1, int a2)
{
  int v4 = socket(2, 2, 0);
  if (v4 < 0)
  {
    unsigned int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "socket failed", buf, 2u);
    }
  }
  else
  {
    int v5 = v4;
    *(_OWORD *)long long __dst = 0u;
    long long v16 = 0u;
    *(void *)std::string buf = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    CSIPDPManager::getInterfaceNameById();
    strlcpy(__dst, (const char *)buf, 0x10uLL);
    LODWORD(v16) = a2;
    if (ioctl(v5, 0xC02069D0uLL, __dst) < 0)
    {
      uint64_t v7 = __error();
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        int v9 = *v7;
        *(_DWORD *)uint64_t v13 = 67109120;
        int v14 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "ioctl SIOCSIFNOACKPRIO failed: %d", v13, 8u);
      }
    }
    else
    {
      close(v5);
    }
    if (SHIBYTE(v12) < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_100283614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100283634(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 696);
  if (v1)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Refresh IPv4Service", v5, 2u);
    }
    sub_10027F86C(a1, 1);
  }
  return v1 != 0;
}

BOOL sub_1002836BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 688);
  if (v1)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Refresh IPv6Service", buf, 2u);
    }
    IPConfigurationServiceRefreshConfiguration();
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I ipv6ServiceChanged to be called", v6, 2u);
    }
    sub_10028065C(a1, 1);
  }
  return v1 != 0;
}

BOOL sub_100283790(uint64_t a1, int a2, uint64_t *a3, CSIPacketAddress **a4)
{
  if (a2 == 2)
  {
    CFArrayRef v37 = a4;
    uint64_t v7 = a1 + 488;
    goto LABEL_5;
  }
  if (a2 == 1)
  {
    CFArrayRef v37 = a4;
    uint64_t v7 = a1 + 296;
LABEL_5:
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I refreshing DNS, ipFamily %u", buf, 8u);
    }
    int v9 = (const CSIPacketAddress *)*a3;
    CFTypeRef v10 = (const CSIPacketAddress *)a3[1];
    if ((const CSIPacketAddress *)*a3 == v10)
    {
      uint64_t v13 = (const CSIPacketAddress *)*a3;
    }
    else
    {
      do
      {
        uint64_t v11 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          CSIPacketAddress::operator std::string();
          uint64_t v12 = v48 >= 0 ? buf : *(unsigned char **)buf;
          *(_DWORD *)uint64_t v49 = 136446210;
          *(void *)&v49[4] = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I refreshing DNS:%{public}s", v49, 0xCu);
          if (v48 < 0) {
            operator delete(*(void **)buf);
          }
        }
        int v9 = (const CSIPacketAddress *)((char *)v9 + 24);
      }
      while (v9 != v10);
      uint64_t v13 = (const CSIPacketAddress *)*a3;
      int v9 = (const CSIPacketAddress *)a3[1];
    }
    if (*(_DWORD *)(v7 + 120) == 2) {
      long long v16 = "IPv6Service: ";
    }
    else {
      long long v16 = "IPv4Service: ";
    }
    sub_100283E70(a1, v13, v9, (void *)v7, v16);
    sub_100284508(a1, *a3, a3[1], (void *)v7);
    sub_1002848A8(a3, v7);
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I In Function", buf, 2u);
    }
    *(void *)uint64_t v49 = 0;
    sub_10027CC98((const void **)v49, a1);
    if (*(void *)v49) {
      CFDictionaryRef v18 = sub_1000810B8;
    }
    else {
      CFDictionaryRef v18 = 0;
    }
    if (v18)
    {
      CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (theDict) {
        CFDictionaryRef v19 = sub_1000C06D0;
      }
      else {
        CFDictionaryRef v19 = 0;
      }
      if (v19)
      {
        CFTypeRef cf = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:refreshDNS", 0, 0);
        if (cf) {
          CFTypeID v20 = sub_100142574;
        }
        else {
          CFTypeID v20 = 0;
        }
        if (v20)
        {
          value = 0;
          sub_10027C5D8(&v40, a1);
          CFStringRef v21 = *(const __CFString **)v49;
          CFTypeRef v39 = cf;
          if (cf) {
            CFRetain(cf);
          }
          sub_100284ACC((CFTypeRef *)&value, a1, &v40, v7, v37, v21, (SCDynamicStoreRef *)&v39);
          sub_100142A3C(&v39);
          if (v41) {
            sub_10004D2C8(v41);
          }
          if (value) {
            uint64_t v22 = sub_100080778;
          }
          else {
            uint64_t v22 = 0;
          }
          if (v22)
          {
            CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, *(CFStringRef *)v49, kSCEntNetDNS);
            *(void *)std::string buf = NetworkServiceEntity;
            if (NetworkServiceEntity) {
              CFTypeID v24 = sub_1000810B8;
            }
            else {
              CFTypeID v24 = 0;
            }
            if (v24)
            {
              CFDictionarySetValue(theDict, NetworkServiceEntity, value);
              sub_10004EFE4(&v38, (CFTypeRef *)&theDict);
              sub_10027C2D0(a1, "refreshDNS: ip dict: DNS", (const __CFDictionary **)&v38);
              sub_100057D78(&v38);
              int v25 = SCDynamicStoreSetMultiple((SCDynamicStoreRef)cf, theDict, 0, 0);
              BOOL v15 = v25 != 0;
              int v26 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int v45 = 67109120;
                BOOL v46 = v25 != 0;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I SCDynamicStoreSetMultiple() result %u", v45, 8u);
              }
            }
            else
            {
              unsigned int v34 = *(NSObject **)(a1 + 40);
              BOOL v15 = 0;
              if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)int v45 = 0;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Creating key for DNS failed, bailing out", v45, 2u);
                BOOL v15 = 0;
              }
            }
            sub_1000558F4((const void **)buf);
          }
          else
          {
            CFArrayRef v29 = *v37;
            int v30 = v37[1];
            int v31 = *(NSObject **)(a1 + 40);
            BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
            if (v29 == v30)
            {
              if (v32)
              {
                uint64_t v36 = asString();
                *(_DWORD *)std::string buf = 136315138;
                *(void *)&uint8_t buf[4] = v36;
                _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Failed to create SCD Dict for DNS for %s, bailing out", buf, 0xCu);
              }
              BOOL v15 = 0;
            }
            else
            {
              if (v32)
              {
                uint64_t v33 = asString();
                *(_DWORD *)std::string buf = 136315138;
                *(void *)&uint8_t buf[4] = v33;
                _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I DNS for %s is empty, but other DNS is available, bailing out", buf, 0xCu);
              }
              BOOL v15 = 1;
            }
          }
          sub_100057D78((const void **)&value);
        }
        else
        {
          long long v28 = *(NSObject **)(a1 + 40);
          BOOL v15 = 0;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Failed to create SCDynamicStore for notifySystemConfigOfSettings, bailing out", buf, 2u);
            BOOL v15 = 0;
          }
        }
        sub_100142A3C(&cf);
      }
      else
      {
        BOOL v15 = 0;
      }
      sub_10005717C((const void **)&theDict);
    }
    else
    {
      CFTypeRef v27 = *(NSObject **)(a1 + 40);
      BOOL v15 = 0;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I not setting DNS", buf, 2u);
        BOOL v15 = 0;
      }
    }
    sub_1000558F4((const void **)v49);
    return v15;
  }
  int v14 = *(NSObject **)(a1 + 40);
  BOOL v15 = 0;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#E no IP model available: family=%u", buf, 8u);
    return 0;
  }
  return v15;
}

void sub_100283DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v12 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v14 = va_arg(va2, const void *);
  sub_100057D78((const void **)va);
  sub_100142A3C((const void **)va1);
  sub_10005717C((const void **)va2);
  sub_1000558F4((const void **)(v10 - 112));
  _Unwind_Resume(a1);
}

void sub_100283E70(uint64_t a1, const CSIPacketAddress *a2, const CSIPacketAddress *a3, void *a4, void *a5)
{
  memset(v51, 0, sizeof(v51));
  if (a3 == a2) {
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v51);
  }
  else {
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v51, a2);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  int v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  v49[0] = (void *)v10;
  int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)v49);
  if (v14)
  {
    uint64_t v16 = v14[3];
    BOOL v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  BOOL v15 = 0;
  char v17 = 1;
LABEL_12:
  if (CSIPacketAddress::isZeroIP((CSIPacketAddress *)v51))
  {
    if (!v16) {
      goto LABEL_34;
    }
    goto LABEL_21;
  }
  if (!v16) {
    goto LABEL_42;
  }
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v16 + 120))(v49, v16);
  if (v50 >= 0) {
    CFDictionaryRef v18 = (void *)HIBYTE(v50);
  }
  else {
    CFDictionaryRef v18 = v49[1];
  }
  if ((SHIBYTE(v50) & 0x80000000) == 0)
  {
    if (v18) {
      goto LABEL_21;
    }
LABEL_42:
    uint64_t v32 = a4[8];
    uint64_t v33 = a4[9];
    while (v33 == v32)
    {
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v49);
      unint64_t v34 = a4[9];
      if (v34 >= a4[10])
      {
        uint64_t v33 = sub_10028D9BC((uint64_t)(a4 + 8), (const CSIPacketAddress *)v49);
      }
      else
      {
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)a4[9], (const CSIPacketAddress *)v49);
        uint64_t v33 = v34 + 24;
        a4[9] = v34 + 24;
      }
      a4[9] = v33;
      uint64_t v32 = a4[8];
    }
    CSIPacketAddress::operator=();
    goto LABEL_76;
  }
  operator delete(v49[0]);
  if (!v18) {
    goto LABEL_42;
  }
LABEL_21:
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v16 + 120))(v49, v16);
  if (v50 >= 0) {
    CFDictionaryRef v19 = (void *)HIBYTE(v50);
  }
  else {
    CFDictionaryRef v19 = v49[1];
  }
  if (SHIBYTE(v50) < 0)
  {
    operator delete(v49[0]);
    if (v19) {
      goto LABEL_26;
    }
  }
  else if (v19)
  {
LABEL_26:
    if (a4[9] == a4[8])
    {
      do
      {
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v49);
        unint64_t v20 = a4[9];
        if (v20 >= a4[10])
        {
          uint64_t v21 = sub_10028D9BC((uint64_t)(a4 + 8), (const CSIPacketAddress *)v49);
        }
        else
        {
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)a4[9], (const CSIPacketAddress *)v49);
          uint64_t v21 = v20 + 24;
          a4[9] = v20 + 24;
        }
        a4[9] = v21;
      }
      while (v21 == a4[8]);
    }
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v16 + 120))(__p, v16);
    CSIPacketAddress::CSIPacketAddress();
    CSIPacketAddress::operator=();
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_76;
  }
LABEL_34:
  if (!CSIPacketAddress::isZeroIP((CSIPacketAddress *)v51)) {
    goto LABEL_76;
  }
  uint64_t v47 = 0;
  char v48 = 0;
  sub_10028583C(&v47, a1);
  v49[0] = 0;
  v49[1] = 0;
  uint64_t v50 = 0;
  uint64_t v22 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v23 = v22;
  if (v24 < 0)
  {
    int v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v26 = 5381;
    do
    {
      uint64_t v24 = v26;
      unsigned int v27 = *v25++;
      uint64_t v26 = (33 * v26) ^ v27;
    }
    while (v27);
  }
  std::mutex::lock(v22);
  __p[0] = (void *)v24;
  long long v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)__p);
  if (!v28)
  {
    uint64_t v30 = 0;
    goto LABEL_50;
  }
  uint64_t v30 = v28[3];
  CFArrayRef v29 = (std::__shared_weak_count *)v28[4];
  if (!v29)
  {
LABEL_50:
    std::mutex::unlock(v23);
    CFArrayRef v29 = 0;
    char v31 = 1;
    goto LABEL_51;
  }
  atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v23);
  atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v29);
  char v31 = 0;
LABEL_51:
  (*(void (**)(void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, uint64_t))(*(void *)v30 + 80))(v43, v30, *(unsigned int *)(v47 + 52), 1, @"FallbackDNSAddress", 0, 1);
  uint64_t v46 = 0;
  long long v45 = 0uLL;
  ctu::cf::assign();
  *(_OWORD *)uint64_t v49 = v45;
  uint64_t v50 = v46;
  uint64_t v46 = 0;
  long long v45 = 0uLL;
  sub_1000577C4((const void **)v43);
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  CFMutableDictionaryRef v35 = (void *)HIBYTE(v50);
  int v36 = SHIBYTE(v50);
  if (v50 < 0) {
    CFMutableDictionaryRef v35 = v49[1];
  }
  if (v35)
  {
    CFArrayRef v37 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeID v38 = (void **)v49[0];
      if (v36 >= 0) {
        CFTypeID v38 = v49;
      }
      LODWORD(__p[0]) = 136315394;
      *(void **)((char *)__p + 4) = a5;
      WORD2(__p[1]) = 2082;
      *(void **)((char *)&__p[1] + 6) = v38;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %sNo DNS address given but falling back to carrier's default DNS address: %{public}s", (uint8_t *)__p, 0x16u);
      LOBYTE(v36) = HIBYTE(v50);
    }
    memset(__p, 0, 24);
    if ((v36 & 0x80u) == 0) {
      CFTypeRef v39 = (char *)v49;
    }
    else {
      CFTypeRef v39 = (char *)v49[0];
    }
    sub_100058DB0(v43, v39);
    CSIPacketAddress::CSIPacketAddress();
    if (v44 < 0) {
      operator delete(v43[0]);
    }
    uint64_t v40 = a4[8];
    uint64_t v41 = a4[9];
    while (v41 == v40)
    {
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v43);
      unint64_t v42 = a4[9];
      if (v42 >= a4[10])
      {
        uint64_t v41 = sub_10028D9BC((uint64_t)(a4 + 8), (const CSIPacketAddress *)v43);
      }
      else
      {
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)a4[9], (const CSIPacketAddress *)v43);
        uint64_t v41 = v42 + 24;
        a4[9] = v42 + 24;
      }
      a4[9] = v41;
      uint64_t v40 = a4[8];
    }
    CSIPacketAddress::operator=();
    LOBYTE(v36) = HIBYTE(v50);
  }
  if ((v36 & 0x80) != 0) {
    operator delete(v49[0]);
  }
  if (v48) {
    sub_10004D2C8(v48);
  }
LABEL_76:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_100284408(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,std::__shared_weak_count *a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  if ((v38 & 1) == 0) {
    sub_10004D2C8(v37);
  }
  _Unwind_Resume(exception_object);
}

void sub_100284508(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  memset(v27, 0, sizeof(v27));
  if (0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 3) < 2) {
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v27);
  }
  else {
    CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v27, (const CSIPacketAddress *)(a2 + 24));
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&__p);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
LABEL_12:
  if (CSIPacketAddress::isZeroIP((CSIPacketAddress *)v27))
  {
    if (!v14) {
      goto LABEL_42;
    }
    goto LABEL_21;
  }
  if (!v14) {
    goto LABEL_36;
  }
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v14 + 128))(&__p, v14);
  if ((v26 & 0x80u) == 0) {
    uint64_t v16 = v26;
  }
  else {
    uint64_t v16 = v25;
  }
  if ((char)v26 < 0)
  {
    operator delete(__p);
    if (v16) {
      goto LABEL_21;
    }
LABEL_36:
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[9] - a4[8]) >> 3) <= 1)
    {
      do
      {
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&__p);
        unint64_t v20 = a4[9];
        if (v20 >= a4[10])
        {
          uint64_t v21 = sub_10028D9BC((uint64_t)(a4 + 8), (const CSIPacketAddress *)&__p);
        }
        else
        {
          CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)a4[9], (const CSIPacketAddress *)&__p);
          uint64_t v21 = v20 + 24;
          a4[9] = v20 + 24;
        }
        a4[9] = v21;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((v21 - a4[8]) >> 3) < 2);
    }
    CSIPacketAddress::operator=();
    goto LABEL_42;
  }
  if (!v16) {
    goto LABEL_36;
  }
LABEL_21:
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v14 + 128))(&__p, v14);
  if ((v26 & 0x80u) == 0) {
    uint64_t v17 = v26;
  }
  else {
    uint64_t v17 = v25;
  }
  if ((char)v26 < 0)
  {
    operator delete(__p);
    if (!v17) {
      goto LABEL_42;
    }
  }
  else if (!v17)
  {
    goto LABEL_42;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[9] - a4[8]) >> 3) <= 1)
  {
    do
    {
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&__p);
      unint64_t v18 = a4[9];
      if (v18 >= a4[10])
      {
        uint64_t v19 = sub_10028D9BC((uint64_t)(a4 + 8), (const CSIPacketAddress *)&__p);
      }
      else
      {
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)a4[9], (const CSIPacketAddress *)&__p);
        uint64_t v19 = v18 + 24;
        a4[9] = v18 + 24;
      }
      a4[9] = v19;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((v19 - a4[8]) >> 3) < 2);
  }
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v14 + 128))(&v22, v14);
  CSIPacketAddress::CSIPacketAddress();
  CSIPacketAddress::operator=();
  if (v23 < 0) {
    operator delete(v22);
  }
LABEL_42:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_100284848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002848A8(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3) >= 3)
  {
    int v5 = (const CSIPacketAddress **)(a2 + 64);
    uint64_t v6 = a2 + 80;
    unint64_t v7 = 2;
    uint64_t v8 = 48;
    do
    {
      if ((CSIPacketAddress::isZeroIP((CSIPacketAddress *)(v2 + v8)) & 1) == 0)
      {
        if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3) <= v7) {
          sub_10015B728();
        }
        int v9 = (const CSIPacketAddress *)(*a1 + v8);
        unint64_t v11 = *(void *)(a2 + 72);
        unint64_t v10 = *(void *)(a2 + 80);
        if (v11 >= v10)
        {
          unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (void)*v5) >> 3);
          unint64_t v14 = v13 + 1;
          if (v13 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_10006A748();
          }
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - (void)*v5) >> 3);
          if (2 * v15 > v14) {
            unint64_t v14 = 2 * v15;
          }
          if (v15 >= 0x555555555555555) {
            unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v16 = v14;
          }
          uint64_t v22 = v6;
          if (v16) {
            uint64_t v17 = (char *)sub_10004812C(v6, v16);
          }
          else {
            uint64_t v17 = 0;
          }
          std::string __p = v17;
          uint64_t v19 = (CSIPacketAddress *)&v17[24 * v13];
          unint64_t v20 = v19;
          uint64_t v21 = &v17[24 * v16];
          CSIPacketAddress::CSIPacketAddress(v19, v9);
          unint64_t v20 = (CSIPacketAddress *)((char *)v20 + 24);
          sub_10028DB34(v5, &__p);
          if (v20 != v19) {
            unint64_t v20 = (CSIPacketAddress *)((char *)v20 - 24 - 24 * ((v20 - v19 - 24) / 0x18uLL));
          }
          unint64_t v12 = *(void *)(a2 + 72);
          if (__p) {
            operator delete(__p);
          }
        }
        else
        {
          CSIPacketAddress::CSIPacketAddress(*(CSIPacketAddress **)(a2 + 72), v9);
          unint64_t v12 = v11 + 24;
          *(void *)(a2 + 72) = v11 + 24;
        }
        *(void *)(a2 + 72) = v12;
      }
      ++v7;
      uint64_t v2 = *a1;
      v8 += 24;
    }
    while (v7 < 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3));
  }
}

void sub_100284A74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 72) = v13;
  _Unwind_Resume(exception_object);
}

const void **sub_100284ACC(CFTypeRef *a1, uint64_t a2, uint64_t *a3, uint64_t a4, CSIPacketAddress **a5, const __CFString *a6, SCDynamicStoreRef *a7)
{
  CFMutableDictionaryRef v70 = 0;
  CFMutableArrayRef theArray = CFArrayCreateMutable(kCFAllocatorDefault, 4, &kCFTypeArrayCallBacks);
  if (theArray) {
    uint64_t v13 = sub_100289354;
  }
  else {
    uint64_t v13 = 0;
  }
  if (!v13)
  {
    CFArrayRef v37 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_90;
    }
    *(_WORD *)std::string buf = 0;
    char v38 = "#E Cannot create DNS Servers array";
    goto LABEL_59;
  }
  unint64_t v14 = (CSIPacketAddress **)(a4 + 64);
  CFStringRef v62 = a6;
  uint64_t v63 = a7;
  if (*(void *)(a4 + 64) != *(void *)(a4 + 72))
  {
    unint64_t v15 = a1;
    goto LABEL_7;
  }
  uint64_t v39 = *a3;
  uint64_t v40 = (std::__shared_weak_count *)a3[1];
  if (!v40)
  {
    unint64_t v15 = a1;
    if ((sub_10028878C(a2, v39) & 1) != 0 || *a5 == a5[1]) {
      goto LABEL_7;
    }
    goto LABEL_61;
  }
  unint64_t v15 = a1;
  atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
  if (sub_10028878C(a2, v39))
  {
    sub_10004D2C8(v40);
    goto LABEL_7;
  }
  long long v45 = *a5;
  uint64_t v46 = a5[1];
  sub_10004D2C8(v40);
  if (v45 != v46)
  {
LABEL_61:
    uint64_t v47 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#N Empty DNS for %s, not empty for other", buf, 0xCu);
    }
    unint64_t v14 = a5;
  }
LABEL_7:
  uint64_t v17 = *v14;
  unint64_t v16 = v14[1];
  if (*v14 != v16)
  {
    do
    {
      if (CSIPacketAddress::isZeroIP(v17))
      {
        unint64_t v18 = *(NSObject **)(a2 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#E Empty DNS addr ?", buf, 2u);
        }
      }
      else
      {
        value = 0;
        CSIPacketAddress::operator std::string();
        if (v74 >= 0) {
          uint64_t v19 = buf;
        }
        else {
          uint64_t v19 = *(uint8_t **)buf;
        }
        unint64_t v20 = (void *)CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v19, 0x8000100u);
        value = v20;
        if (v74 < 0)
        {
          operator delete(*(void **)buf);
          unint64_t v20 = value;
        }
        if (v20) {
          uint64_t v21 = sub_1000810B8;
        }
        else {
          uint64_t v21 = 0;
        }
        if (v21) {
          CFArrayAppendValue(theArray, v20);
        }
        sub_1000558F4((const void **)&value);
      }
      uint64_t v17 = (CSIPacketAddress *)((char *)v17 + 24);
    }
    while (v17 != v16);
  }
  a1 = v15;
  if (!CFArrayGetCount(theArray))
  {
    uint64_t v41 = *a3;
    unint64_t v42 = (std::__shared_weak_count *)a3[1];
    if (v42)
    {
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      char v43 = sub_10028878C(a2, v41);
      sub_10004D2C8(v42);
      if (v43) {
        goto LABEL_24;
      }
    }
    else if (sub_10028878C(a2, v41))
    {
      goto LABEL_24;
    }
    CFArrayRef v37 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_90;
    }
    *(_WORD *)std::string buf = 0;
    char v38 = "#E Empty DNS Servers list is not allowed";
LABEL_59:
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v38, buf, 2u);
    goto LABEL_90;
  }
LABEL_24:
  CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, v62, kSCEntNetDNS);
  CFStringRef v68 = NetworkServiceEntity;
  if (NetworkServiceEntity) {
    char v23 = sub_1000810B8;
  }
  else {
    char v23 = 0;
  }
  if (!v23)
  {
    char v44 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Creating key for DNS failed, bailing out", buf, 2u);
    }
    goto LABEL_89;
  }
  uint64_t v24 = v15;
  CFDictionaryRef theDict = 0;
  *(void *)std::string buf = SCDynamicStoreCopyValue(*v63, NetworkServiceEntity);
  sub_100084068(&theDict, (CFTypeRef *)buf);
  if (theDict) {
    uint64_t v25 = sub_100080778;
  }
  else {
    uint64_t v25 = 0;
  }
  if (v25 && CFDictionaryContainsKey(theDict, kSCPropNetDNSServerAddresses))
  {
    CFArrayRef v66 = 0;
    *(void *)std::string buf = CFDictionaryGetValue(theDict, kSCPropNetDNSServerAddresses);
    sub_100044D6C(&v66, (CFTypeRef *)buf);
    if (v66) {
      unsigned __int8 v26 = sub_100083F10;
    }
    else {
      unsigned __int8 v26 = 0;
    }
    if (!v26)
    {
LABEL_82:
      sub_100044D00((const void **)&v66);
      goto LABEL_83;
    }
    *(_OWORD *)std::string buf = 0uLL;
    sub_10028583C(buf, a2);
    CFTypeRef cf = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 48));
    long long v28 = ServiceMap;
    if (v29 < 0)
    {
      uint64_t v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v31 = 5381;
      do
      {
        uint64_t v29 = v31;
        unsigned int v32 = *v30++;
        uint64_t v31 = (33 * v31) ^ v32;
      }
      while (v32);
    }
    std::mutex::lock(ServiceMap);
    value = (void *)v29;
    uint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)&value);
    if (v33)
    {
      uint64_t v35 = v33[3];
      unint64_t v34 = (std::__shared_weak_count *)v33[4];
      if (v34)
      {
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v28);
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v34);
        char v36 = 0;
LABEL_66:
        (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v35 + 96))(&cf, v35, *(unsigned int *)(*(void *)buf + 52), 1, @"PreferPrimaryDNS", kCFBooleanFalse, 0);
        if ((v36 & 1) == 0) {
          sub_10004D2C8(v34);
        }
        char v48 = (BOOL *)cf;
        LOBYTE(value) = 0;
        if (cf && (CFTypeID v49 = CFGetTypeID(cf), v49 == CFBooleanGetTypeID()))
        {
          ctu::cf::assign((ctu::cf *)&value, v48, v50);
          int v51 = value;
        }
        else
        {
          int v51 = 0;
        }
        sub_1000577C4(&cf);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        CFIndex Count = CFArrayGetCount(v66);
        if (Count >= 1)
        {
          CFIndex v53 = 0;
          char v54 = 1;
          do
          {
            CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(v66, v53);
            if (sub_10028935C() != *(_DWORD *)(a4 + 120))
            {
              if (((v51 != 0) & v54) == 1 && CFArrayGetCount(theArray))
              {
                CFArrayInsertValueAtIndex(theArray, 1, ValueAtIndex);
                char v54 = 0;
              }
              else
              {
                CFArrayAppendValue(theArray, ValueAtIndex);
              }
            }
            ++v53;
          }
          while (Count != v53);
        }
        goto LABEL_82;
      }
    }
    else
    {
      uint64_t v35 = 0;
    }
    std::mutex::unlock(v28);
    unint64_t v34 = 0;
    char v36 = 1;
    goto LABEL_66;
  }
LABEL_83:
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFMutableDictionaryRef v57 = v70;
  CFMutableDictionaryRef v70 = Mutable;
  *(void *)std::string buf = v57;
  sub_10005717C((const void **)buf);
  if (v70) {
    CFStringRef v58 = sub_1000C06D0;
  }
  else {
    CFStringRef v58 = 0;
  }
  if (v58) {
    CFDictionarySetValue(v70, kSCPropNetDNSServerAddresses, theArray);
  }
  sub_100057D78((const void **)&theDict);
  a1 = v24;
LABEL_89:
  sub_1000558F4((const void **)&v68);
LABEL_90:
  sub_1000440D4((const void **)&theArray);
  CFMutableDictionaryRef v59 = v70;
  CFMutableDictionaryRef v65 = v70;
  if (v70)
  {
    CFRetain(v70);
    value = v59;
    CFRetain(v59);
  }
  else
  {
    value = 0;
  }
  CFTypeRef cf = 0;
  *(void *)std::string buf = 0;
  sub_10004EFE4(buf, (CFTypeRef *)&value);
  if (*(void *)buf) {
    uint64_t v60 = sub_100080778;
  }
  else {
    uint64_t v60 = 0;
  }
  if (v60) {
    sub_100058140(&cf, (const void **)buf);
  }
  sub_100057D78((const void **)buf);
  *a1 = cf;
  CFTypeRef cf = 0;
  sub_100057D78(&cf);
  sub_10005717C((const void **)&value);
  sub_10005717C((const void **)&v65);
  return sub_10005717C((const void **)&v70);
}

void sub_100285240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,int a22,__int16 a23,char a24,char a25,int a26,const void *a27,const void *a28,__int16 a29,char a30,char a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
}

uint64_t sub_100285348(uint64_t result, void *a2)
{
  if (*a2)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(result + 16);
    if (v2)
    {
      int v4 = std::__shared_weak_count::lock(v2);
      if (v4)
      {
        p_shared_weak_owners = &v4->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v4);
        *a2 = 0;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

uint64_t sub_10028542C(uint64_t result, void *a2)
{
  if (*a2)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(result + 16);
    if (v2)
    {
      int v4 = std::__shared_weak_count::lock(v2);
      if (v4)
      {
        p_shared_weak_owners = &v4->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v4);
        *a2 = 0;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_100285510(uint64_t a1, uint64_t a2, void *a3)
{
  int v4 = a3[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = a3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received callback for IPv4 SCDynamicStore change at object: %p, ipv4ServiceChanged to be called", (uint8_t *)&buf, 0xCu);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10027F860;
  v10[3] = &unk_1019B25C0;
  void v10[4] = a3;
  int v5 = (std::__shared_weak_count *)a3[2];
  if (!v5 || (v6 = a3[1], (unint64_t v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  int v9 = a3[3];
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 1174405120;
  uint64_t v12 = sub_10028EC34;
  uint64_t v13 = &unk_1019B29C8;
  uint64_t v15 = v6;
  unint64_t v16 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v14 = v10;
  dispatch_async(v9, &buf);
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v8);
}

void sub_100285698(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1002856A4(uint64_t a1, uint64_t a2, void *a3)
{
  int v4 = a3[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = a3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received callback for IPv6 SCDynamicStore change at object: %p, ipv6ServiceChanged to be called", (uint8_t *)&buf, 0xCu);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10028064C;
  v10[3] = &unk_1019B25E0;
  void v10[4] = a3;
  char v11 = 0;
  int v5 = (std::__shared_weak_count *)a3[2];
  if (!v5 || (v6 = a3[1], (unint64_t v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  int v9 = a3[3];
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 1174405120;
  uint64_t v13 = sub_10028EC34;
  unint64_t v14 = &unk_1019B29C8;
  uint64_t v16 = v6;
  uint64_t v17 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v15 = v10;
  dispatch_async(v9, &buf);
  if (v17) {
    sub_10004D2C8(v17);
  }
  sub_10004D2C8(v8);
}

void sub_100285830(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10028583C(void *a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 752);
  if (!v3 || (int v5 = std::__shared_weak_count::lock(v3)) == 0 || (v6 = *(void *)(a2 + 744)) == 0) {
LABEL_7:
  }
    operator new();
  *a1 = 0;
  a1[1] = 0;
  (*(void (**)(uint64_t))(*(void *)v6 + 32))(v6);
  if ((DataUtils::validPersonality() & 1) == 0)
  {
    unint64_t v7 = (std::__shared_weak_count *)a1[1];
    if (v7) {
      sub_10004D2C8(v7);
    }
    goto LABEL_7;
  }

  sub_10004D2C8(v5);
}

void sub_100285994(_Unwind_Exception *a1)
{
  int v4 = *(std::__shared_weak_count **)(v2 + 8);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002859E0(uint64_t a1, CSIPacketAddress *a2, CSIPacketAddress *a3, const CSIPacketAddress **a4, uint64_t a5, int a6, int a7, char a8, char a9)
{
  if (!*(unsigned char *)(a1 + 764))
  {
    uint64_t v16 = *(NSObject **)(a1 + 40);
    uint64_t v17 = 0;
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      return v17;
    }
    LOWORD(buf[0]) = 0;
    unint64_t v18 = "#E too early start";
    goto LABEL_13;
  }
  if (*(void *)(a1 + 128)) {
    unint64_t v10 = sub_1000810B8;
  }
  else {
    unint64_t v10 = 0;
  }
  if (!v10)
  {
    uint64_t v16 = *(NSObject **)(a1 + 40);
    uint64_t v17 = 0;
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      return v17;
    }
    LOWORD(buf[0]) = 0;
    unint64_t v18 = "#E service ID not ready";
LABEL_13:
    uint64_t v19 = v16;
    uint32_t v20 = 2;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)buf, v20);
    return 0;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a1 + 272, a1 + 276, a1 + 280, a1 + 284);
  if (a6 == 2)
  {
    uint64_t v15 = a1 + 488;
    goto LABEL_16;
  }
  if (a6 != 1)
  {
    uint64_t v35 = *(NSObject **)(a1 + 40);
    uint64_t v17 = 0;
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
      return v17;
    }
    LODWORD(buf[0]) = 67109120;
    HIDWORD(buf[0]) = a6;
    unint64_t v18 = "#E no IP model available: family=%u";
    uint64_t v19 = v35;
    uint32_t v20 = 8;
    goto LABEL_14;
  }
  uint64_t v15 = a1 + 296;
LABEL_16:
  __int16 v142 = a3;
  uint64_t v143 = v15;
  if (*(_DWORD *)(v15 + 120) == 2)
  {
    uint64_t v21 = a1 + 488;
    if (a6 == 1) {
      uint64_t v21 = a1 + 296;
    }
    *(unsigned char *)(v21 + 112) = a8;
    uint64_t v22 = "IPv6Service: ";
  }
  else
  {
    uint64_t v22 = "IPv4Service: ";
  }
  char v23 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    CSIPacketAddress::operator std::string();
    CSIPacketAddress::operator std::string();
    uint64_t v24 = v187;
    if (v187[2] < 0) {
      uint64_t v24 = (void *)v187[0];
    }
    if (__p[23] >= 0) {
      uint64_t v25 = __p;
    }
    else {
      uint64_t v25 = *(unsigned char **)__p;
    }
    LODWORD(buf[0]) = 136315906;
    *(void *)((char *)buf + 4) = v22;
    WORD2(buf[1]) = 2080;
    *(void *)((char *)&buf[1] + 6) = v24;
    HIWORD(buf[2]) = 2080;
    buf[3] = v25;
    LOWORD(v190) = 1024;
    *(_DWORD *)((char *)&v190 + 2) = a6;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %sgoing online with IP %s, LLA %s, ipFamily %u", (uint8_t *)buf, 0x26u);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    if (SHIBYTE(v187[2]) < 0) {
      operator delete((void *)v187[0]);
    }
  }
  unsigned int v27 = *a4;
  unsigned __int8 v26 = a4[1];
  if (*a4 != v26)
  {
    do
    {
      long long v28 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        CSIPacketAddress::operator std::string();
        uint64_t v29 = buf[2] >= 0 ? buf : (void *)buf[0];
        LODWORD(v187[0]) = 136315394;
        *(void *)((char *)v187 + 4) = v22;
        WORD2(v187[1]) = 2082;
        *(void *)((char *)&v187[1] + 6) = v29;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %sgoing online with DNS %{public}s", (uint8_t *)v187, 0x16u);
        if (SHIBYTE(buf[2]) < 0) {
          operator delete((void *)buf[0]);
        }
      }
      unsigned int v27 = (const CSIPacketAddress *)((char *)v27 + 24);
    }
    while (v27 != v26);
  }
  if (CSIPacketAddress::isZeroIP(a2))
  {
    if (*(_DWORD *)(v143 + 120) != 2) {
      __TUAssertTrigger();
    }
    uint64_t v30 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I going online with IPv6Service", (uint8_t *)buf, 2u);
    }
  }
  memset(v153, 0, sizeof(v153));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v153, a2);
  char v152 = 0;
  unsigned int v31 = *(_DWORD *)(v143 + 116);
  if (v31 == 1)
  {
    if (*(_DWORD *)(v143 + 120) == 2) {
      goto LABEL_117;
    }
    memset(buf, 0, 24);
    CSIPDPManager::getInterfaceNameById();
    *(void *)uint64_t v154 = 0;
    int v32 = getifaddrs((ifaddrs **)v154);
    uint64_t v33 = *(ifaddrs **)v154;
    if (v32)
    {
      int v34 = 0;
      if (*(void *)v154) {
        goto LABEL_110;
      }
      goto LABEL_111;
    }
    char v46 = 0;
    if (!*(void *)v154) {
      goto LABEL_109;
    }
    while (1)
    {
      ifa_addr = v33->ifa_addr;
      if (!ifa_addr || ifa_addr->sa_family != 2) {
        goto LABEL_98;
      }
      sub_100058DB0(v187, v33->ifa_name);
      if (buf[2] >= 0) {
        uint64_t v48 = HIBYTE(buf[2]);
      }
      else {
        uint64_t v48 = buf[1];
      }
      uint64_t v49 = HIBYTE(v187[2]);
      int v50 = SHIBYTE(v187[2]);
      if (v187[2] < 0) {
        uint64_t v49 = v187[1];
      }
      if (v48 != v49)
      {
        BOOL v60 = 0;
        if (SHIBYTE(v187[2]) < 0) {
          goto LABEL_89;
        }
        goto LABEL_93;
      }
      int v51 = v187[2] >= 0 ? v187 : (void *)v187[0];
      if ((buf[2] & 0x8000000000000000) != 0) {
        break;
      }
      if (HIBYTE(buf[2]))
      {
        uint64_t v52 = HIBYTE(buf[2]) - 1;
        CFIndex v53 = buf;
        do
        {
          int v55 = *(unsigned __int8 *)v53;
          CFIndex v53 = (void *)((char *)v53 + 1);
          int v54 = v55;
          int v57 = *(unsigned __int8 *)v51;
          int v51 = (void *)((char *)v51 + 1);
          int v56 = v57;
          BOOL v59 = v52-- != 0;
          BOOL v60 = v54 == v56;
        }
        while (v54 == v56 && v59);
LABEL_92:
        if (v50 < 0) {
          goto LABEL_89;
        }
        goto LABEL_93;
      }
      BOOL v60 = 1;
      if (SHIBYTE(v187[2]) < 0)
      {
LABEL_89:
        operator delete((void *)v187[0]);
        if (v60) {
          goto LABEL_94;
        }
        goto LABEL_98;
      }
LABEL_93:
      if (v60)
      {
LABEL_94:
        long long v61 = v33->ifa_addr;
        memset(v187, 0, 24);
        v62.s_addr = *(_DWORD *)&v61->sa_data[2];
        uint64_t v63 = inet_ntoa(v62);
        sub_100058DB0(v187, v63);
        uint64_t v64 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        {
          if (v187[2] >= 0) {
            CFMutableDictionaryRef v65 = v187;
          }
          else {
            CFMutableDictionaryRef v65 = (void *)v187[0];
          }
          if (buf[2] >= 0) {
            CFArrayRef v66 = buf;
          }
          else {
            CFArrayRef v66 = (void *)buf[0];
          }
          *(_DWORD *)std::string __p = 136446466;
          *(void *)&__p[4] = v65;
          *(_WORD *)&unsigned char __p[12] = 2080;
          *(void *)&__p[14] = v66;
          _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "IPv4 address %{public}s already configured on %s", __p, 0x16u);
        }
        if (SHIBYTE(v187[2]) < 0) {
          operator delete((void *)v187[0]);
        }
        char v46 = 1;
      }
LABEL_98:
      uint64_t v33 = v33->ifa_next;
      if (!v33)
      {
        uint64_t v33 = *(ifaddrs **)v154;
LABEL_109:
        int v34 = v46 & 1;
        if (v33) {
LABEL_110:
        }
          freeifaddrs(v33);
LABEL_111:
        if (SHIBYTE(buf[2]) < 0) {
          operator delete((void *)buf[0]);
        }
        if (v34)
        {
          uint64_t v67 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I force removing all IPv4 addresses from the interface", (uint8_t *)buf, 2u);
          }
          sub_100282538((void *)a1);
        }
LABEL_117:
        if (a7 == 1 && (int v68 = *(_DWORD *)(v143 + 124)) != 0)
        {
          uint64_t v69 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf[0]) = 136315650;
            *(void *)((char *)buf + 4) = v22;
            WORD2(buf[1]) = 1024;
            *(_DWORD *)((char *)&buf[1] + 6) = 1;
            WORD1(buf[2]) = 1024;
            HIDWORD(buf[2]) = v68;
            CFMutableDictionaryRef v70 = "#I %sReason for going online is resume(%d). Using last known MTU %d";
            goto LABEL_125;
          }
        }
        else
        {
          sub_10027C5D8(&v150, a1);
          int v68 = sub_100288178(a1, v150, v151, v143);
          if (v151) {
            sub_10004D2C8(v151);
          }
          *(_DWORD *)(v143 + 124) = v68;
          uint64_t v69 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf[0]) = 136315650;
            *(void *)((char *)buf + 4) = v22;
            WORD2(buf[1]) = 1024;
            *(_DWORD *)((char *)&buf[1] + 6) = a7;
            WORD1(buf[2]) = 1024;
            HIDWORD(buf[2]) = v68;
            CFMutableDictionaryRef v70 = "#I %sReason for going online is not resume(%d) or there is no last known MTU. Using current RAT MTU %d";
LABEL_125:
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, v70, (uint8_t *)buf, 0x18u);
          }
        }
        sub_100283E70(a1, *a4, a4[1], (void *)v143, v22);
        sub_100284508(a1, (uint64_t)*a4, (uint64_t)a4[1], (void *)v143);
        sub_1002848A8((uint64_t *)a4, v143);
        if (*(void *)(v143 + 64) != *(void *)(v143 + 72)) {
          goto LABEL_134;
        }
        uint64_t v71 = *(_DWORD *)(v143 + 120) == 1 ? a1 + 488 : a1 + 296;
        if (*(void *)(v71 + 64) != *(void *)(v71 + 72)) {
          goto LABEL_134;
        }
        sub_10027C5D8(&v148, a1);
        char v72 = sub_10028878C(a1, v148);
        if (v149) {
          sub_10004D2C8(v149);
        }
        if (v72)
        {
LABEL_134:
          sub_10027C5D8(&v146, a1);
          sub_10027EC44(a1, &v146);
          if (v147) {
            sub_10004D2C8(v147);
          }
          if (*(_DWORD *)(v143 + 120) == 2)
          {
            LODWORD(valuePtr) = v68;
            uint64_t v73 = *(void *)(a1 + 688);
            char v74 = *(NSObject **)(a1 + 40);
            BOOL v75 = os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT);
            if (v73)
            {
              if (v75)
              {
                LOWORD(buf[0]) = 0;
                CFStringRef v76 = "#I IPv6Service is going up in progress";
                goto LABEL_145;
              }
            }
            else if (v75)
            {
              LOWORD(buf[0]) = 0;
              CFStringRef v76 = "#I IPv6Service is new";
LABEL_145:
              _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, v76, (uint8_t *)buf, 2u);
            }
            CFTypeRef v180 = 0;
            CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
            CFTypeRef v180 = Mutable;
            uint64_t v82 = *(unsigned int *)(a1 + 120);
            if (v82 > 0xF) {
              uint64_t v83 = "";
            }
            else {
              uint64_t v83 = off_1019B2768[v82];
            }
            CFStringAppendFormat(Mutable, 0, @"%s", v83);
            long long v190 = 0u;
            long long v188 = 0u;
            memset(buf, 0, sizeof(buf));
            memset(v187, 0, sizeof(v187));
            v179 = 0;
            CFNumberRef v84 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
            v179 = v84;
            buf[0] = kIPConfigurationServiceOptionMTU;
            buf[1] = kIPConfigurationServiceOptionPerformNUD;
            v187[0] = v84;
            v187[1] = kCFBooleanFalse;
            if (a9)
            {
              unsigned int v85 = 2;
            }
            else
            {
              buf[2] = kIPConfigurationServiceOptionEnableDAD;
              v187[2] = kCFBooleanFalse;
              unsigned int v85 = 3;
            }
            if (!capabilities::ct::supportsCellRadio(v84))
            {
              uint64_t v86 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)std::string __p = 0;
                BOOL v87 = "#I IPv6Service: xlat464: cellular radio not supported";
LABEL_158:
                _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, v87, __p, 2u);
              }
LABEL_291:
              long long v176 = 0;
              CFTypeRef cf = 0;
              CFMutableDictionaryRef v174 = 0;
              long long v175 = 0;
              if ((CSIPacketAddress::isZeroIP(a2) & 1) == 0)
              {
                v169[0] = 0;
                v169[1] = 0;
                v170 = 0;
                CSIPacketAddress::operator std::string();
                if (SHIBYTE(v170) < 0)
                {
                  sub_10004FC84(__dst, v169[0], (unint64_t)v169[1]);
                }
                else
                {
                  *(_OWORD *)long long __dst = *(_OWORD *)v169;
                  CFTypeRef v168 = v170;
                }
                if (SHIBYTE(v168) < 0)
                {
                  sub_10004FC84(v154, __dst[0], (unint64_t)__dst[1]);
                }
                else
                {
                  *(_OWORD *)uint64_t v154 = *(_OWORD *)__dst;
                  v155 = v168;
                }
                v159[0] = 0;
                if (SHIBYTE(v155) < 0)
                {
                  sub_10004FC84(__p, *(void **)v154, *(unint64_t *)&v154[8]);
                }
                else
                {
                  *(_OWORD *)std::string __p = *(_OWORD *)v154;
                  *(void *)&__p[16] = v155;
                }
                v162[0] = 0;
                if (ctu::cf::convert_copy())
                {
                  int v116 = v159[0];
                  v159[0] = v162[0];
                  v164[0] = v116;
                  sub_1000558F4((const void **)v164);
                }
                if ((__p[23] & 0x80000000) != 0) {
                  operator delete(*(void **)__p);
                }
                values[0] = v159[0];
                v159[0] = 0;
                sub_1000558F4((const void **)v159);
                if (SHIBYTE(v155) < 0) {
                  operator delete(*(void **)v154);
                }
                *(void *)std::string __p = cf;
                CFTypeRef cf = values[0];
                values[0] = 0;
                sub_1000558F4((const void **)__p);
                sub_1000558F4((const void **)values);
                if (SHIBYTE(v168) < 0) {
                  operator delete(__dst[0]);
                }
                __int16 v117 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
                {
                  int v118 = SHIBYTE(v170);
                  uint64_t v119 = (void **)v169[0];
                  int PrefixLen = CSIPacketAddress::getPrefixLen(a2);
                  uint64_t v121 = v169;
                  if (v118 < 0) {
                    uint64_t v121 = v119;
                  }
                  *(_DWORD *)std::string __p = 136315394;
                  *(void *)&__p[4] = v121;
                  *(_WORD *)&unsigned char __p[12] = 1024;
                  *(_DWORD *)&__p[14] = PrefixLen;
                  _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#I IPv6Service is going up with address %s/%d", __p, 0x12u);
                }
                uint64_t v122 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                CFMutableDictionaryRef v123 = v174;
                CFMutableDictionaryRef v174 = v122;
                *(void *)std::string __p = v123;
                sub_10005717C((const void **)__p);
                CFDictionarySetValue(v174, kSCPropNetIPv6ConfigMethod, kSCValNetIPv6ConfigMethodManual);
                *(void *)std::string __p = cf;
                *(void *)&__p[8] = 0;
                v162[0] = 0;
                v162[0] = CFArrayCreate(0, (const void **)__p, 1, &kCFTypeArrayCallBacks);
                CFDictionarySetValue(v174, kSCPropNetIPv6Addresses, v162[0]);
                v159[0] = 0;
                unsigned int v124 = CSIPacketAddress::getPrefixLen(a2);
                v164[0] = 0;
                *(void *)uint64_t v154 = v124;
                CFNumberRef v125 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, v154);
                if (v125)
                {
                  v126 = v164[0];
                  v164[0] = v125;
                  *(void *)uint64_t v154 = v126;
                  sub_1000570E8((const void **)v154);
                }
                v159[0] = v164[0];
                v164[0] = 0;
                sub_1000570E8((const void **)v164);
                *(void **)std::string __p = v159[0];
                *(void *)uint64_t v154 = 0;
                *(void *)uint64_t v154 = CFArrayCreate(0, (const void **)__p, 1, &kCFTypeArrayCallBacks);
                CFDictionarySetValue(v174, kSCPropNetIPv6PrefixLength, *(const void **)v154);
                buf[v85] = kIPConfigurationServiceOptionIPv6Entity;
                v187[v85++] = v174;
                sub_100044D00((const void **)v154);
                sub_1000570E8((const void **)v159);
                sub_100044D00((const void **)v162);
                if (SHIBYTE(v170) < 0) {
                  operator delete(v169[0]);
                }
              }
              if ((CSIPacketAddress::isZeroIP(v142) & 1) == 0)
              {
                v169[0] = 0;
                v169[1] = 0;
                v170 = 0;
                CSIPacketAddress::operator std::string();
                if (SHIBYTE(v170) < 0)
                {
                  sub_10004FC84(v164, v169[0], (unint64_t)v169[1]);
                }
                else
                {
                  *(_OWORD *)uint64_t v164 = *(_OWORD *)v169;
                  v165 = v170;
                }
                if (SHIBYTE(v165) < 0)
                {
                  sub_10004FC84(v154, v164[0], (unint64_t)v164[1]);
                }
                else
                {
                  *(_OWORD *)uint64_t v154 = *(_OWORD *)v164;
                  v155 = v165;
                }
                values[0] = 0;
                if (SHIBYTE(v155) < 0)
                {
                  sub_10004FC84(__p, *(void **)v154, *(unint64_t *)&v154[8]);
                }
                else
                {
                  *(_OWORD *)std::string __p = *(_OWORD *)v154;
                  *(void *)&__p[16] = v155;
                }
                v159[0] = 0;
                if (ctu::cf::convert_copy())
                {
                  std::string::size_type v127 = values[0];
                  values[0] = v159[0];
                  v162[0] = v127;
                  sub_1000558F4((const void **)v162);
                }
                if ((__p[23] & 0x80000000) != 0) {
                  operator delete(*(void **)__p);
                }
                CFTypeRef v181 = values[0];
                values[0] = 0;
                sub_1000558F4((const void **)values);
                if (SHIBYTE(v155) < 0) {
                  operator delete(*(void **)v154);
                }
                CFArrayRef v128 = v176;
                long long v176 = (void *)v181;
                CFTypeRef v181 = 0;
                *(void *)std::string __p = v128;
                sub_1000558F4((const void **)__p);
                sub_1000558F4(&v181);
                if (SHIBYTE(v165) < 0) {
                  operator delete(v164[0]);
                }
                CFArrayRef v129 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
                {
                  CFTypeID v130 = v169;
                  if (SHIBYTE(v170) < 0) {
                    CFTypeID v130 = (void **)v169[0];
                  }
                  *(_DWORD *)std::string __p = 136315138;
                  *(void *)&__p[4] = v130;
                  _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_DEFAULT, "#I IPv6Service is going up with link local address %s", __p, 0xCu);
                }
                buf[v85] = kIPConfigurationServiceOptionIPv6LinkLocalAddress;
                v187[v85++] = v176;
                if (SHIBYTE(v170) < 0) {
                  operator delete(v169[0]);
                }
              }
              v162[0] = 0;
              v162[1] = 0;
              sub_10027C5D8(v162, a1);
              if (v162[0])
              {
                if (*((char *)v162[0] + 71) < 0)
                {
                  sub_10004FC84(v169, *((void **)v162[0] + 6), *((void *)v162[0] + 7));
                }
                else
                {
                  *(_OWORD *)CFTypeRef v169 = *((_OWORD *)v162[0] + 3);
                  v170 = (std::__shared_weak_count *)*((void *)v162[0] + 8);
                }
                if (SHIBYTE(v170) < 0)
                {
                  sub_10004FC84(v154, v169[0], (unint64_t)v169[1]);
                }
                else
                {
                  *(_OWORD *)uint64_t v154 = *(_OWORD *)v169;
                  v155 = v170;
                }
                CFTypeRef v181 = 0;
                if (SHIBYTE(v155) < 0)
                {
                  sub_10004FC84(__p, *(void **)v154, *(unint64_t *)&v154[8]);
                }
                else
                {
                  *(_OWORD *)std::string __p = *(_OWORD *)v154;
                  *(void *)&__p[16] = v155;
                }
                values[0] = 0;
                if (ctu::cf::convert_copy())
                {
                  CFTypeRef v131 = v181;
                  CFTypeRef v181 = values[0];
                  v159[0] = (void *)v131;
                  sub_1000558F4((const void **)v159);
                }
                if ((__p[23] & 0x80000000) != 0) {
                  operator delete(*(void **)__p);
                }
                CFTypeRef v173 = v181;
                CFTypeRef v181 = 0;
                sub_1000558F4(&v181);
                if (SHIBYTE(v155) < 0) {
                  operator delete(*(void **)v154);
                }
                *(void *)std::string __p = v175;
                long long v175 = (void *)v173;
                CFTypeRef v173 = 0;
                sub_1000558F4((const void **)__p);
                sub_1000558F4(&v173);
                if (SHIBYTE(v170) < 0) {
                  operator delete(v169[0]);
                }
                std::string v132 = v175;
                if (v175) {
                  CFTypeID v133 = sub_1000810B8;
                }
                else {
                  CFTypeID v133 = 0;
                }
                if (v133)
                {
                  buf[v85] = kIPConfigurationServiceOptionAPNName;
                  v187[v85++] = v132;
                }
              }
              if (v162[1]) {
                sub_10004D2C8((std::__shared_weak_count *)v162[1]);
              }
              values[0] = 0;
              CFDictionaryRef v134 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)buf, (const void **)v187, v85, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              values[0] = v134;
              CFTypeRef v181 = v134;
              if (v134) {
                CFRetain(v134);
              }
              sub_10027C2D0(a1, "IPv6Service: ip dict: bringUpIPv6Interface_sync", (const __CFDictionary **)&v181);
              sub_100057D78(&v181);
              sub_10027F0B8(a1, a1 + 488, 2u);
              CFTypeRef v184 = 0;
              uint64_t v185 = 0;
              *(void *)std::string __p = a1;
              std::string v135 = *(std::__shared_weak_count **)(a1 + 16);
              if (v135)
              {
                uint64_t v136 = *(void *)(a1 + 8);
                uint64_t v137 = std::__shared_weak_count::lock(v135);
                if (v137)
                {
                  char v138 = v137;
                  *(void *)&__p[8] = v136;
                  *(void *)&__p[16] = v137;
                  atomic_fetch_add_explicit(&v137->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v137);
                  CFTypeRef v139 = v180;
                  CFTypeRef v183 = v180;
                  if (v180) {
                    CFRetain(v180);
                  }
                  __int16 v140 = values[0];
                  CFTypeRef v184 = values[0];
                  if (values[0]) {
                    CFRetain(values[0]);
                  }
                  uint64_t v185 = a1 + 488;
                  *(void *)uint64_t v154 = a1;
                  *(void *)&v154[8] = v136;
                  v155 = v138;
                  atomic_fetch_add_explicit(&v138->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  CFTypeRef v156 = v139;
                  if (v139) {
                    CFRetain(v139);
                  }
                  CFTypeRef v157 = v140;
                  if (v140) {
                    CFRetain(v140);
                  }
                  uint64_t v158 = a1 + 488;
                  operator new();
                }
              }
              sub_100088B9C();
            }
            if (*(_DWORD *)(a1 + 412) == 4)
            {
              uint64_t v86 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)std::string __p = 0;
                BOOL v87 = "#N IPv6Service: xlat464: ipv4Model is already online";
                goto LABEL_158;
              }
              goto LABEL_291;
            }
            *(void *)std::string __p = 0;
            *(void *)&__p[8] = 0;
            sub_10027C5D8(__p, a1);
            if (*(void *)__p)
            {
              if (*(unsigned char *)(*(void *)__p + 344))
              {
                buf[v85] = kIPConfigurationServiceOptionEnableCLAT46;
                v187[v85++] = kCFBooleanTrue;
                if (!*(unsigned char *)(a1 + 433)) {
                  *(_WORD *)(a1 + 432) = 256;
                }
                unsigned int v92 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)uint64_t v154 = 0;
                  uint64_t v93 = "#I IPv6Service: xlat464: enabled";
                  goto LABEL_288;
                }
LABEL_289:
                if (*(void *)&__p[8]) {
                  sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
                }
                goto LABEL_291;
              }
              unsigned int v92 = *(NSObject **)(a1 + 40);
              if (!os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_289;
              }
              *(_WORD *)uint64_t v154 = 0;
              uint64_t v93 = "#I IPv6Service: xlat464: EnableXLAT464 is not configured in APN";
            }
            else
            {
              unsigned int v92 = *(NSObject **)(a1 + 40);
              if (!os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_289;
              }
              *(_WORD *)uint64_t v154 = 0;
              uint64_t v93 = "#N IPv6Service: xlat464: APN info empty";
            }
LABEL_288:
            _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, v93, v154, 2u);
            goto LABEL_289;
          }
          int v178 = v68;
          uint64_t v77 = *(void *)(a1 + 696);
          uint64_t v78 = *(NSObject **)(a1 + 40);
          BOOL v79 = os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT);
          if (v77)
          {
            if (v79)
            {
              LOWORD(buf[0]) = 0;
              uint64_t v80 = "#I IPv4Service is going up in progress";
              goto LABEL_161;
            }
          }
          else if (v79)
          {
            LOWORD(buf[0]) = 0;
            uint64_t v80 = "#I IPv4Service is new";
LABEL_161:
            _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, v80, (uint8_t *)buf, 2u);
          }
          CFTypeRef cf = 0;
          CFMutableStringRef v88 = CFStringCreateMutable(kCFAllocatorDefault, 0);
          CFTypeRef cf = v88;
          uint64_t v89 = *(unsigned int *)(a1 + 120);
          if (v89 > 0xF) {
            long long v90 = "";
          }
          else {
            long long v90 = off_1019B2768[v89];
          }
          CFStringAppendFormat(v88, 0, @"%s", v90);
          long long v190 = 0u;
          long long v188 = 0u;
          memset(buf, 0, sizeof(buf));
          memset(v187, 0, sizeof(v187));
          long long v176 = 0;
          long long v176 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v178);
          buf[0] = kIPConfigurationServiceOptionMTU;
          v187[0] = v176;
          CFMutableDictionaryRef v174 = 0;
          long long v175 = 0;
          unint64_t valuePtr = 0;
          CFTypeRef v173 = 0;
          CFMutableDictionaryRef theDict = 0;
          if (CSIPacketAddress::isZeroIP(a2))
          {
            unsigned int v91 = 1;
          }
          else
          {
            v169[0] = 0;
            v169[1] = 0;
            v170 = 0;
            CSIPacketAddress::operator std::string();
            if (SHIBYTE(v170) < 0)
            {
              sub_10004FC84(__dst, v169[0], (unint64_t)v169[1]);
            }
            else
            {
              *(_OWORD *)long long __dst = *(_OWORD *)v169;
              CFTypeRef v168 = v170;
            }
            if (SHIBYTE(v168) < 0)
            {
              sub_10004FC84(v154, __dst[0], (unint64_t)__dst[1]);
            }
            else
            {
              *(_OWORD *)uint64_t v154 = *(_OWORD *)__dst;
              v155 = v168;
            }
            v159[0] = 0;
            if (SHIBYTE(v155) < 0)
            {
              sub_10004FC84(__p, *(void **)v154, *(unint64_t *)&v154[8]);
            }
            else
            {
              *(_OWORD *)std::string __p = *(_OWORD *)v154;
              *(void *)&__p[16] = v155;
            }
            v162[0] = 0;
            if (ctu::cf::convert_copy())
            {
              unsigned int v94 = v159[0];
              v159[0] = v162[0];
              v164[0] = v94;
              sub_1000558F4((const void **)v164);
            }
            if ((__p[23] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
            values[0] = v159[0];
            v159[0] = 0;
            sub_1000558F4((const void **)v159);
            if (SHIBYTE(v155) < 0) {
              operator delete(*(void **)v154);
            }
            *(void *)std::string __p = v175;
            long long v175 = values[0];
            values[0] = 0;
            sub_1000558F4((const void **)__p);
            sub_1000558F4((const void **)values);
            if (SHIBYTE(v168) < 0) {
              operator delete(__dst[0]);
            }
            uint64_t v95 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v96 = v169;
              if (SHIBYTE(v170) < 0) {
                unsigned int v96 = (void **)v169[0];
              }
              *(_DWORD *)std::string __p = 136315138;
              *(void *)&__p[4] = v96;
              _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "#I IPv4Service is going up with address %s", __p, 0xCu);
            }
            CFStringRef v97 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFMutableDictionaryRef v98 = theDict;
            CFMutableDictionaryRef theDict = v97;
            *(void *)std::string __p = v98;
            sub_10005717C((const void **)__p);
            CFDictionarySetValue(theDict, kSCPropNetIPv4ConfigMethod, kSCValNetIPv4ConfigMethodManual);
            values[0] = v175;
            values[1] = 0;
            CFArrayRef v166 = 0;
            CFArrayRef v166 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
            CFDictionarySetValue(theDict, kSCPropNetIPv4Addresses, v166);
            if ((CSIPacketAddress::isZeroIP((CSIPacketAddress *)v153) & 1) == 0)
            {
              v164[0] = 0;
              v164[1] = 0;
              v165 = 0;
              CSIPacketAddress::operator std::string();
              if (SHIBYTE(v165) < 0)
              {
                sub_10004FC84(v162, v164[0], (unint64_t)v164[1]);
              }
              else
              {
                *(_OWORD *)uint64_t v162 = *(_OWORD *)v164;
                uint64_t v163 = v165;
              }
              if (SHIBYTE(v163) < 0)
              {
                sub_10004FC84(v154, v162[0], (unint64_t)v162[1]);
              }
              else
              {
                *(_OWORD *)uint64_t v154 = *(_OWORD *)v162;
                v155 = v163;
              }
              CFTypeRef v180 = 0;
              if (SHIBYTE(v155) < 0)
              {
                sub_10004FC84(__p, *(void **)v154, *(unint64_t *)&v154[8]);
              }
              else
              {
                *(_OWORD *)std::string __p = *(_OWORD *)v154;
                *(void *)&__p[16] = v155;
              }
              CFTypeRef v181 = 0;
              if (ctu::cf::convert_copy())
              {
                CFTypeRef v100 = v180;
                CFTypeRef v180 = v181;
                v159[0] = (void *)v100;
                sub_1000558F4((const void **)v159);
              }
              if ((__p[23] & 0x80000000) != 0) {
                operator delete(*(void **)__p);
              }
              v179 = (__CFDictionary *)v180;
              CFTypeRef v180 = 0;
              sub_1000558F4(&v180);
              if (SHIBYTE(v155) < 0) {
                operator delete(*(void **)v154);
              }
              *(void *)std::string __p = v174;
              CFMutableDictionaryRef v174 = v179;
              v179 = 0;
              sub_1000558F4((const void **)__p);
              sub_1000558F4((const void **)&v179);
              if (SHIBYTE(v163) < 0) {
                operator delete(v162[0]);
              }
              CFArrayRef v101 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
              {
                CFTypeID v102 = v164;
                if (SHIBYTE(v165) < 0) {
                  CFTypeID v102 = (void **)v164[0];
                }
                *(_DWORD *)std::string __p = 136315138;
                *(void *)&__p[4] = v102;
                _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "#I IPv4Service is going up with broadcastAddr %s", __p, 0xCu);
              }
              values[0] = v174;
              *(void *)std::string __p = 0;
              *(void *)std::string __p = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
              CFDictionarySetValue(theDict, kSCPropNetIPv4DestAddresses, *(const void **)__p);
              sub_100044D00((const void **)__p);
              if (SHIBYTE(v165) < 0) {
                operator delete(v164[0]);
              }
            }
            v164[0] = 0;
            v164[1] = 0;
            v165 = 0;
            sub_100058DB0(v164, "255.255.255.255");
            if (SHIBYTE(v165) < 0)
            {
              sub_10004FC84(v159, v164[0], (unint64_t)v164[1]);
            }
            else
            {
              *(_OWORD *)uint64_t v159 = *(_OWORD *)v164;
              uint64_t v160 = v165;
            }
            if (SHIBYTE(v160) < 0)
            {
              sub_10004FC84(v154, v159[0], (unint64_t)v159[1]);
            }
            else
            {
              *(_OWORD *)uint64_t v154 = *(_OWORD *)v159;
              v155 = v160;
            }
            v179 = 0;
            if (SHIBYTE(v155) < 0)
            {
              sub_10004FC84(__p, *(void **)v154, *(unint64_t *)&v154[8]);
            }
            else
            {
              *(_OWORD *)std::string __p = *(_OWORD *)v154;
              *(void *)&__p[16] = v155;
            }
            CFTypeRef v180 = 0;
            if (ctu::cf::convert_copy())
            {
              unsigned int v103 = v179;
              v179 = (__CFDictionary *)v180;
              CFTypeRef v181 = v103;
              sub_1000558F4(&v181);
            }
            if ((__p[23] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
            unint64_t v161 = v179;
            v179 = 0;
            sub_1000558F4((const void **)&v179);
            if (SHIBYTE(v155) < 0) {
              operator delete(*(void **)v154);
            }
            *(void *)std::string __p = v173;
            CFTypeRef v173 = v161;
            unint64_t v161 = 0;
            sub_1000558F4((const void **)__p);
            sub_1000558F4((const void **)&v161);
            if (SHIBYTE(v160) < 0) {
              operator delete(v159[0]);
            }
            unsigned int v104 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
            {
              CFTypeID v105 = v164;
              if (SHIBYTE(v165) < 0) {
                CFTypeID v105 = (void **)v164[0];
              }
              *(_DWORD *)std::string __p = 136315138;
              *(void *)&__p[4] = v105;
              _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I IPv4Service is going up with subnetMask %s", __p, 0xCu);
            }
            values[0] = (void *)v173;
            *(void *)std::string __p = 0;
            *(void *)std::string __p = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
            CFDictionarySetValue(theDict, kSCPropNetIPv4SubnetMasks, *(const void **)__p);
            buf[1] = kIPConfigurationServiceOptionIPv4Entity;
            v187[1] = theDict;
            sub_100044D00((const void **)__p);
            if (SHIBYTE(v165) < 0) {
              operator delete(v164[0]);
            }
            sub_100044D00((const void **)&v166);
            if (SHIBYTE(v170) < 0) {
              operator delete(v169[0]);
            }
            unsigned int v91 = 2;
          }
          v164[0] = 0;
          v164[1] = 0;
          sub_10027C5D8(v164, a1);
          if (v164[0])
          {
            if (*((char *)v164[0] + 71) < 0)
            {
              sub_10004FC84(v169, *((void **)v164[0] + 6), *((void *)v164[0] + 7));
            }
            else
            {
              *(_OWORD *)CFTypeRef v169 = *((_OWORD *)v164[0] + 3);
              v170 = (std::__shared_weak_count *)*((void *)v164[0] + 8);
            }
            if (SHIBYTE(v170) < 0)
            {
              sub_10004FC84(v154, v169[0], (unint64_t)v169[1]);
            }
            else
            {
              *(_OWORD *)uint64_t v154 = *(_OWORD *)v169;
              v155 = v170;
            }
            CFTypeRef v180 = 0;
            if (SHIBYTE(v155) < 0)
            {
              sub_10004FC84(__p, *(void **)v154, *(unint64_t *)&v154[8]);
            }
            else
            {
              *(_OWORD *)std::string __p = *(_OWORD *)v154;
              *(void *)&__p[16] = v155;
            }
            CFTypeRef v181 = 0;
            if (ctu::cf::convert_copy())
            {
              CFTypeRef v106 = v180;
              CFTypeRef v180 = v181;
              values[0] = (void *)v106;
              sub_1000558F4((const void **)values);
            }
            if ((__p[23] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
            v179 = (__CFDictionary *)v180;
            CFTypeRef v180 = 0;
            sub_1000558F4(&v180);
            if (SHIBYTE(v155) < 0) {
              operator delete(*(void **)v154);
            }
            *(void *)std::string __p = valuePtr;
            unint64_t valuePtr = v179;
            v179 = 0;
            sub_1000558F4((const void **)__p);
            sub_1000558F4((const void **)&v179);
            if (SHIBYTE(v170) < 0) {
              operator delete(v169[0]);
            }
            uint64_t v107 = valuePtr;
            if (valuePtr) {
              CFTypeID v108 = sub_1000810B8;
            }
            else {
              CFTypeID v108 = 0;
            }
            if (v108)
            {
              buf[v91] = kIPConfigurationServiceOptionAPNName;
              v187[v91++] = v107;
            }
          }
          if (v164[1]) {
            sub_10004D2C8((std::__shared_weak_count *)v164[1]);
          }
          CFTypeRef v181 = 0;
          CFDictionaryRef v109 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)buf, (const void **)v187, v91, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFTypeRef v180 = v109;
          CFTypeRef v181 = v109;
          if (v109) {
            CFRetain(v109);
          }
          sub_10027C2D0(a1, "IPv4Service: ip dict: bringUpIPv4Interface_sync", (const __CFDictionary **)&v180);
          sub_100057D78(&v180);
          sub_10027F0B8(a1, a1 + 296, 2u);
          CFTypeRef v184 = 0;
          uint64_t v185 = 0;
          *(void *)std::string __p = a1;
          int v110 = *(std::__shared_weak_count **)(a1 + 16);
          if (v110)
          {
            uint64_t v111 = *(void *)(a1 + 8);
            unsigned int v112 = std::__shared_weak_count::lock(v110);
            if (v112)
            {
              int v113 = v112;
              *(void *)&__p[8] = v111;
              *(void *)&__p[16] = v112;
              atomic_fetch_add_explicit(&v112->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v112);
              CFTypeRef v114 = cf;
              CFTypeRef v183 = cf;
              if (cf) {
                CFRetain(cf);
              }
              CFTypeRef v115 = v181;
              CFTypeRef v184 = v181;
              if (v181) {
                CFRetain(v181);
              }
              uint64_t v185 = a1 + 296;
              *(void *)uint64_t v154 = a1;
              *(void *)&v154[8] = v111;
              v155 = v113;
              atomic_fetch_add_explicit(&v113->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              CFTypeRef v156 = v114;
              if (v114) {
                CFRetain(v114);
              }
              CFTypeRef v157 = v115;
              if (v115) {
                CFRetain(v115);
              }
              uint64_t v158 = a1 + 296;
              operator new();
            }
          }
          sub_100088B9C();
        }
        uint64_t v99 = *(NSObject **)(a1 + 40);
        uint64_t v17 = 0;
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf[0]) = 0;
          char v43 = "#E empty DNS not allowed. abort bringupOnline";
          char v44 = v99;
          uint32_t v45 = 2;
LABEL_64:
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, v43, (uint8_t *)buf, v45);
          uint64_t v17 = 0;
        }
        goto LABEL_380;
      }
    }
    BOOL v60 = memcmp((const void *)buf[0], v51, buf[1]) == 0;
    goto LABEL_92;
  }
  char v36 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    if (v31 > 4) {
      CFArrayRef v37 = "???";
    }
    else {
      CFArrayRef v37 = off_1019B2BE0[v31];
    }
    char isZeroIP = CSIPacketAddress::isZeroIP((CSIPacketAddress *)(v143 + 40));
    uint64_t v39 = asStringBool(isZeroIP);
    uint64_t v40 = (void *)(v143 + 152);
    if (*(char *)(v143 + 175) < 0) {
      uint64_t v40 = (void *)*v40;
    }
    LODWORD(buf[0]) = 136315906;
    *(void *)((char *)buf + 4) = v22;
    WORD2(buf[1]) = 2080;
    *(void *)((char *)&buf[1] + 6) = v37;
    HIWORD(buf[2]) = 2080;
    buf[3] = v39;
    LOWORD(v190) = 2082;
    *(void *)((char *)&v190 + 2) = v40;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#N %sCannot go online because we are not offline, the state is: %s; current ip is empty: %s; last error reason = %{public}s",
      (uint8_t *)buf,
      0x2Au);
    unsigned int v31 = *(_DWORD *)(v143 + 116);
  }
  if (v31 == 4 && !CSIPacketAddress::isZeroIP((CSIPacketAddress *)(v143 + 40)))
  {
    if (*(_DWORD *)(v143 + 120) == 2) {
      sub_1002836BC(a1);
    }
    uint64_t v17 = 1;
  }
  else
  {
    uint64_t v41 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = v22;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#E %sFailed activation, trying to recover ==>>", (uint8_t *)buf, 0xCu);
    }
    sub_100287ED0((void *)a1, *(_DWORD *)(v143 + 120), 1);
    unint64_t v42 = *(NSObject **)(a1 + 40);
    uint64_t v17 = 0;
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = v22;
      char v43 = "#E <<== %sFailed activation, recovery over";
      char v44 = v42;
      uint32_t v45 = 12;
      goto LABEL_64;
    }
  }
LABEL_380:
  sub_10028DBBC(&v152);
  return v17;
}

void sub_1002879D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,const void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,const void *a53,void *a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  sub_1000558F4(&a72);
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  sub_100044D00(&a53);
  if (a63 < 0) {
    operator delete(a58);
  }
  sub_10005717C(&a64);
  sub_1000558F4(&a65);
  sub_1000558F4(&a66);
  sub_1000558F4(&a67);
  sub_1000558F4(&a68);
  sub_1000570E8(&a69);
  sub_10028D988(&a70);
  sub_10028DBBC(&a23);
  _Unwind_Resume(a1);
}

void sub_100287ED0(void *a1, int a2, char a3)
{
  if (a2 == 2)
  {
    uint64_t v6 = (uint64_t)(a1 + 61);
    goto LABEL_5;
  }
  if (a2 == 1)
  {
    uint64_t v6 = (uint64_t)(a1 + 37);
LABEL_5:
    unint64_t v7 = a1[5];
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *(_DWORD *)(v6 + 120);
      *(_DWORD *)long long buf = 67109120;
      int v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I going offline, fIPFamily %u", buf, 8u);
    }
    (*(void (**)(void *, void *, uint64_t, void *, uint64_t))(*a1 + 24))(a1, a1 + 34, (uint64_t)a1 + 276, a1 + 35, (uint64_t)a1 + 284);
    if (*(_DWORD *)(v6 + 116) == 4 || (a3 & 1) != 0)
    {
      if (*(_DWORD *)(v6 + 120) == 2) {
        sub_100282DDC(a1);
      }
      else {
        sub_100282538(a1);
      }
    }
    else
    {
      int v9 = a1[5];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = *(_DWORD *)(v6 + 120);
        *(_DWORD *)long long buf = 67109120;
        int v17 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I already offline for IPfamily %u", buf, 8u);
      }
    }
    sub_100058DB0(&__p, "0.0.0.0");
    CSIPacketAddress::CSIPacketAddress();
    CSIPacketAddress::operator=();
    if (v15 < 0) {
      operator delete(__p);
    }
    *(void *)(v6 + 72) = *(void *)(v6 + 64);
    sub_100282740(a1, *(_DWORD *)(v6 + 120));
    if (*(_DWORD *)(v6 + 116) != 1)
    {
      sub_10027F0B8((uint64_t)a1, v6, 1u);
      uint64_t v12 = a1[5];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *(_DWORD *)(v6 + 120);
        *(_DWORD *)long long buf = 67109120;
        int v17 = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I is offline for IPfamily %u", buf, 8u);
      }
    }
    return;
  }
  char v11 = a1[5];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 67109120;
    int v17 = a2;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "unable to bring down interface: for IPfamily %u: model is empty", buf, 8u);
  }
}

void sub_100288154(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100288178(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4)
{
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!a2)
  {
    BOOL v6 = 0;
    if (!a3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  BOOL v6 = *(unsigned char *)(a2 + 216) != 0;
  if (a3) {
LABEL_5:
  }
    sub_10004D2C8(a3);
LABEL_6:
  if (a4)
  {
    if (v6)
    {
      uint64_t v7 = *(unsigned int *)(a4 + 128);
      if (v7) {
        goto LABEL_94;
      }
    }
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v7 = (uint64_t)ServiceMap;
  if (v9 < 0)
  {
    int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string __p = v9;
  int v13 = sub_10004D37C((void *)(v7 + 64), (unint64_t *)__p);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_20:
    std::mutex::unlock((std::mutex *)v7);
    unint64_t v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_18;
    }
LABEL_21:
    if (*(_DWORD *)(a1 + 684) != 0 && *(_DWORD *)(a1 + 684) < 0xFFFFFFFE)
    {
LABEL_86:
      sub_10028583C(__p, a1);
      uint64_t v7 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v15 + 152))(v15, *(unsigned int *)(*(void *)__p + 52), *(unsigned int *)(a1 + 684));
      if (*(void *)&__p[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
      }
      goto LABEL_88;
    }
    uint64_t v52 = 0;
    CFIndex v53 = 0;
    sub_10027C5D8(&v52, a1);
    uint64_t v50 = 0;
    int v51 = 0;
    sub_10028583C(&v50, a1);
    char v17 = 1;
    if (!v52 || !v50 || !*(unsigned char *)(v52 + 193))
    {
LABEL_81:
      if (v51) {
        sub_10004D2C8(v51);
      }
      if (v53) {
        sub_10004D2C8(v53);
      }
      if ((v17 & 1) == 0) {
        goto LABEL_88;
      }
      goto LABEL_86;
    }
    unint64_t v18 = operator new(4uLL);
    *(void *)std::string __p = v18;
    _DWORD *v18 = 14;
    *(void *)&__p[8] = v18 + 1;
    *(void *)&__p[16] = v18 + 1;
    int v19 = capabilities::ct::supports5G((capabilities::ct *)(v18 + 1));
    uint32_t v20 = *(unsigned int **)&__p[8];
    if (v19)
    {
      uint64_t v21 = *(char **)&__p[16];
      if (*(void *)&__p[8] >= *(void *)&__p[16])
      {
        char v23 = *(unsigned int **)__p;
        uint64_t v24 = (uint64_t)(*(void *)&__p[8] - *(void *)__p) >> 2;
        unint64_t v25 = v24 + 1;
        if ((unint64_t)(v24 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v26 = *(void *)&__p[16] - *(void *)__p;
        if ((uint64_t)(*(void *)&__p[16] - *(void *)__p) >> 1 > v25) {
          unint64_t v25 = v26 >> 1;
        }
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v27 = v25;
        }
        if (v27)
        {
          long long v28 = (char *)sub_10005ECD8((uint64_t)&__p[16], v27);
          char v23 = *(unsigned int **)__p;
          uint32_t v20 = *(unsigned int **)&__p[8];
        }
        else
        {
          long long v28 = 0;
        }
        uint64_t v29 = &v28[4 * v24];
        uint64_t v21 = &v28[4 * v27];
        *(_DWORD *)uint64_t v29 = 17;
        uint64_t v22 = v29 + 4;
        while (v20 != v23)
        {
          int v30 = *--v20;
          *((_DWORD *)v29 - 1) = v30;
          v29 -= 4;
        }
        *(void *)std::string __p = v29;
        *(void *)&__p[8] = v22;
        *(void *)&__p[16] = v21;
        if (v23)
        {
          operator delete(v23);
          uint64_t v21 = *(char **)&__p[16];
        }
      }
      else
      {
        **(_DWORD **)&__p[8] = 17;
        uint64_t v22 = (char *)(v20 + 1);
      }
      *(void *)&__p[8] = v22;
      if (v22 >= v21)
      {
        unsigned int v31 = *(char **)__p;
        uint64_t v32 = (uint64_t)&v22[-*(void *)__p] >> 2;
        unint64_t v33 = v32 + 1;
        if ((unint64_t)(v32 + 1) >> 62) {
          sub_10006A748();
        }
        uint64_t v34 = (uint64_t)&v21[-*(void *)__p];
        if (v34 >> 1 > v33) {
          unint64_t v33 = v34 >> 1;
        }
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v35 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v35 = v33;
        }
        if (v35)
        {
          char v36 = (char *)sub_10005ECD8((uint64_t)&__p[16], v35);
          unsigned int v31 = *(char **)__p;
          uint64_t v22 = *(char **)&__p[8];
        }
        else
        {
          char v36 = 0;
        }
        CFArrayRef v37 = &v36[4 * v32];
        char v38 = &v36[4 * v35];
        *(_DWORD *)CFArrayRef v37 = 16;
        uint32_t v20 = (unsigned int *)(v37 + 4);
        while (v22 != v31)
        {
          int v39 = *((_DWORD *)v22 - 1);
          v22 -= 4;
          *((_DWORD *)v37 - 1) = v39;
          v37 -= 4;
        }
        *(void *)std::string __p = v37;
        *(void *)&__p[8] = v20;
        *(void *)&__p[16] = v38;
        if (v31) {
          operator delete(v31);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v22 = 16;
        uint32_t v20 = (unsigned int *)(v22 + 4);
      }
      *(void *)&__p[8] = v20;
    }
    uint64_t v40 = *(unsigned int **)__p;
    if (*(unsigned int **)__p == v20)
    {
      uint64_t v7 = 0;
      if (v20)
      {
LABEL_73:
        *(void *)&__p[8] = v20;
        operator delete(v20);
      }
    }
    else
    {
      LODWORD(v7) = 0;
      do
      {
        unsigned int v41 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v15 + 152))(v15, *(unsigned int *)(v50 + 52), *v40);
        if (v7 < v41 && v7 != 0 || v41 == 0) {
          uint64_t v7 = v7;
        }
        else {
          uint64_t v7 = v41;
        }
        ++v40;
      }
      while (v40 != v20);
      uint32_t v20 = *(unsigned int **)__p;
      if (*(void *)__p) {
        goto LABEL_73;
      }
    }
    if (v7)
    {
      char v44 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v45 = asString();
        *(_DWORD *)std::string __p = 136315394;
        *(void *)&__p[4] = v45;
        *(_WORD *)&unsigned char __p[12] = 2048;
        *(void *)&__p[14] = v7;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I DataMode unknown: %s, using min(LTE/5G) mtu: %lu", __p, 0x16u);
      }
      char v17 = 0;
    }
    else
    {
      char v17 = 1;
    }
    goto LABEL_81;
  }
  uint64_t v15 = v13[3];
  unint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_20;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock((std::mutex *)v7);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (v15) {
    goto LABEL_21;
  }
LABEL_18:
  uint64_t v7 = 0;
LABEL_88:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if ((v7 - 0xFFFF) <= 0xFFFF0001)
  {
    char v46 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string __p = 67109376;
      *(_DWORD *)&__p[4] = v7;
      *(_WORD *)&__p[8] = 1024;
      *(_DWORD *)&__p[10] = 1450;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I MTU from Carrier Bundle is %d exceeds min./max. limit, using default value of %d!", __p, 0xEu);
    }
    uint64_t v7 = 1450;
  }
LABEL_94:
  uint64_t v47 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v48 = asString();
    *(_DWORD *)std::string __p = 136315394;
    *(void *)&__p[4] = v48;
    *(_WORD *)&unsigned char __p[12] = 1024;
    *(_DWORD *)&__p[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I computed MTU[%s]: %u", __p, 0x12u);
  }
  return v7;
}

void sub_100288700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028878C(uint64_t a1, uint64_t a2)
{
  if (!a2 || !*(unsigned char *)(a2 + 192)) {
    return 0;
  }
  int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)(a1 + 120);
    int v6 = *(_DWORD *)(a2 + 148);
    v8[0] = 67109376;
    v8[1] = v5;
    __int16 v9 = 1024;
    int v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I pdp%d, APN %d allows no DNS", (uint8_t *)v8, 0xEu);
  }
  return 1;
}

void sub_100288860(uint64_t a1, int a2)
{
  sub_100287ED0((void *)a1, a2, 0);
  if (a2 == 2)
  {
    int v4 = (unsigned char *)(a1 + 432);
    if (*(unsigned char *)(a1 + 433) && *v4) {
      sub_100287ED0((void *)a1, 1, 0);
    }
    *(_WORD *)int v4 = 0;
    sub_100283188(a1 + 432);
  }
}

uint64_t sub_1002888DC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a6 == 2)
  {
    uint64_t v17 = (uint64_t)(a1 + 61);
  }
  else
  {
    if (a6 != 1) {
      return 0;
    }
    uint64_t v17 = (uint64_t)(a1 + 37);
  }
  unint64_t v18 = a1[5];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = *(_DWORD *)(v17 + 120);
    *(_DWORD *)long long buf = 67109120;
    int v26 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I going reset, fIPFamily %u", buf, 8u);
  }
  (*(void (**)(void *))(*a1 + 16))(a1);
  if (*(_DWORD *)(v17 + 120) == 2) {
    sub_100282DDC(a1);
  }
  else {
    sub_100282538(a1);
  }
  sub_100058DB0(&__p, "0.0.0.0");
  CSIPacketAddress::CSIPacketAddress();
  CSIPacketAddress::operator=();
  if (v24 < 0) {
    operator delete(__p);
  }
  *(void *)(v17 + 72) = *(void *)(v17 + 64);
  sub_100282740(a1, *(_DWORD *)(v17 + 120));
  if (*(_DWORD *)(v17 + 116) != 1)
  {
    sub_10027F0B8((uint64_t)a1, v17, 1u);
    uint64_t v21 = a1[5];
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = *(_DWORD *)(v17 + 120);
      *(_DWORD *)long long buf = 67109120;
      int v26 = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I is offline (to restart) for IPfamily %u", buf, 8u);
    }
  }
  return (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char))(*a1 + 64))(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

void sub_100288B24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100288B48(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100288C60;
  void v7[3] = &unk_1019B2670;
  void v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = a1[1], (int v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  int v5 = v4;
  int v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10028EC34;
  block[3] = &unk_1019B29C8;
  block[5] = v3;
  __int16 v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  void block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

uint64_t sub_100288C60(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32), *(void *)(a1 + 32) + 272, *(void *)(a1 + 32) + 276, *(void *)(a1 + 32) + 280, *(void *)(a1 + 32) + 284);
}

void sub_100288C98(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  unint64_t v33 = 0;
  int v10 = getifaddrs(&v33);
  std::mutex::lock((std::mutex *)(a1 + 208));
  *a5 = 0;
  *a4 = 0;
  *a3 = 0;
  *a2 = 0;
  if (v33) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    goto LABEL_40;
  }
  std::string __s1 = 0;
  size_t __n = 0;
  uint64_t v32 = 0;
  sub_100058DB0(&__s1, "");
  CSIPDPManager::getInterfaceNameById();
  unsigned int v12 = v33;
  if (v33)
  {
    while (1)
    {
      ifa_addr = v12->ifa_addr;
      if (!ifa_addr || ifa_addr->sa_family != 18) {
        goto LABEL_33;
      }
      sub_100058DB0(__p, v12->ifa_name);
      if (v32 >= 0) {
        size_t v14 = HIBYTE(v32);
      }
      else {
        size_t v14 = __n;
      }
      unint64_t v15 = v29;
      int v16 = (char)v29;
      if ((v29 & 0x80u) != 0) {
        unint64_t v15 = (unint64_t)__p[1];
      }
      if (v14 != v15) {
        break;
      }
      if ((v29 & 0x80u) == 0) {
        uint64_t v17 = __p;
      }
      else {
        uint64_t v17 = (void **)__p[0];
      }
      if (v32 < 0)
      {
        BOOL v26 = memcmp(__s1, v17, __n) == 0;
LABEL_30:
        if ((v16 & 0x80000000) == 0) {
          goto LABEL_32;
        }
LABEL_31:
        operator delete(__p[0]);
        goto LABEL_32;
      }
      if (HIBYTE(v32))
      {
        uint64_t v18 = HIBYTE(v32) - 1;
        p_s1 = &__s1;
        do
        {
          int v21 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          int v20 = v21;
          int v23 = *(unsigned __int8 *)v17;
          uint64_t v17 = (void **)((char *)v17 + 1);
          int v22 = v23;
          BOOL v25 = v18-- != 0;
          BOOL v26 = v20 == v22;
        }
        while (v20 == v22 && v25);
        goto LABEL_30;
      }
      BOOL v26 = 1;
      if ((char)v29 < 0) {
        goto LABEL_31;
      }
LABEL_32:
      if (v26)
      {
        ifa_std::string::pointer data = v12->ifa_data;
        *a2 = ifa_data[7] - *(_DWORD *)(a1 + 272);
        *a3 = ifa_data[5] - *(_DWORD *)(a1 + 276);
        *a4 = ifa_data[11] - *(_DWORD *)(a1 + 280);
        *a5 = ifa_data[10] - *(_DWORD *)(a1 + 284);
        goto LABEL_38;
      }
LABEL_33:
      unsigned int v12 = v12->ifa_next;
      if (!v12) {
        goto LABEL_38;
      }
    }
    BOOL v26 = 0;
    if (((char)v29 & 0x80000000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
LABEL_38:
  if (SHIBYTE(v32) < 0) {
    operator delete(__s1);
  }
LABEL_40:
  std::mutex::unlock((std::mutex *)(a1 + 208));
  if (v33) {
    freeifaddrs(v33);
  }
}

void sub_100288E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::mutex::unlock(v18);
  _Unwind_Resume(a1);
}

const void **sub_100288EC8(const void **a1, uint64_t a2)
{
  *a1 = 0;
  uint64_t result = sub_100083DA4(a1, (const void **)(a2 + 128));
  if (*result) {
    int v5 = sub_1000810B8;
  }
  else {
    int v5 = 0;
  }
  if (!v5)
  {
    sub_10027BD94(&v9, a2);
    if (&v9 != a1)
    {
      int v6 = *a1;
      *a1 = v9;
      __int16 v9 = 0;
      int v10 = v6;
      sub_1000558F4(&v10);
    }
    uint64_t result = sub_1000558F4(&v9);
    if (*a1) {
      uint64_t v7 = sub_1000810B8;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7)
    {
      sub_100083DA4(&v8, a1);
      sub_10027C68C(a2, &v8);
      return sub_1000558F4(&v8);
    }
  }
  return result;
}

void sub_100288FA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  sub_1000558F4(v2);
  _Unwind_Resume(a1);
}

void sub_100288FC4(uint64_t a1, BOOL a2, int a3)
{
  BOOL v4 = a2;
  if (a2)
  {
    *(_DWORD *)(a1 + 680) = asWirelessTechnology();
    *(_DWORD *)(a1 + 684) = a3;
  }
  sub_10027C450(&v10, a1);
  sub_10027EC44(a1, &v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = asStringBool(v4);
    uint64_t v8 = asString();
    int v9 = *(_DWORD *)(a1 + 760);
    *(_DWORD *)long long buf = 136315650;
    uint64_t v13 = v7;
    __int16 v14 = 2080;
    uint64_t v15 = v8;
    __int16 v16 = 1024;
    int v17 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I dataModeChange: %s, dataMode: %s, MTU: %u", buf, 0x1Cu);
  }
}

void sub_1002890D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002890F8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2 && std::__shared_weak_count::lock(v2))
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (v3)
    {
      if (std::__shared_weak_count::lock(v3)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  sub_100088B9C();
}

void sub_100289218(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2 && std::__shared_weak_count::lock(v2))
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (v3)
    {
      if (std::__shared_weak_count::lock(v3)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  sub_100088B9C();
}

uint64_t sub_100289354(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t sub_10028935C()
{
  ctu::cf::assign();
  long long v1 = 0uLL;
  uint64_t v2 = 0;
  CSIPacketAddress::CSIPacketAddress();
  if (CSIPacketAddress::toIPv4((CSIPacketAddress *)&v1) == -1) {
    return 2;
  }
  else {
    return 1;
  }
}

void sub_1002893DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028940C(uint64_t a1)
{
  CFStringRef serviceID = 0;
  sub_100288EC8((const void **)&serviceID, a1);
  CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, serviceID, @"com.apple.CommCenter");
  CFStringRef v18 = NetworkServiceEntity;
  if (NetworkServiceEntity) {
    uint64_t v3 = sub_1000810B8;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFDictionaryRef theDict = 0;
    *(void *)long long buf = SCDynamicStoreCopyValue(0, NetworkServiceEntity);
    sub_100084068(&theDict, (CFTypeRef *)buf);
    if (theDict) {
      BOOL v4 = sub_100080778;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      CFNumberRef number = 0;
      *(void *)long long buf = CFDictionaryGetValue(theDict, @"Available");
      sub_1000842D0(&number, (CFTypeRef *)buf);
      if (number) {
        int v5 = sub_100081E58;
      }
      else {
        int v5 = 0;
      }
      if (v5)
      {
        int valuePtr = 0;
        int Value = CFNumberGetValue(number, kCFNumberIntType, &valuePtr);
        uint64_t v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = valuePtr;
          uint64_t v9 = asStringBool(Value != 0);
          *(_DWORD *)long long buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = v8;
          __int16 v21 = 2080;
          uint64_t v22 = v9;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I  kSCPropNetCommCenterAvailable Value = %d, retreival uint64_t result = %s", buf, 0x12u);
        }
        if (valuePtr) {
          uint64_t v10 = 1;
        }
        else {
          uint64_t v10 = 2;
        }
      }
      else
      {
        uint64_t v13 = *(NSObject **)(a1 + 40);
        uint64_t v10 = 0;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I No key kSCPropNetCommCenterAvailable value", buf, 2u);
          uint64_t v10 = 0;
        }
      }
      sub_1000570E8((const void **)&number);
    }
    else
    {
      unsigned int v12 = *(NSObject **)(a1 + 40);
      uint64_t v10 = 0;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I dictionary com.apple.CommCenter in State:// is not present", buf, 2u);
        uint64_t v10 = 0;
      }
    }
    sub_100057D78((const void **)&theDict);
  }
  else
  {
    BOOL v11 = *(NSObject **)(a1 + 40);
    uint64_t v10 = 0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I SC (service) key is not present", buf, 2u);
      uint64_t v10 = 0;
    }
  }
  sub_1000558F4((const void **)&v18);
  sub_1000558F4((const void **)&serviceID);
  return v10;
}

void sub_1002896C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  BOOL v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  int v8 = va_arg(va3, const void *);
  sub_1000570E8((const void **)va);
  sub_100057D78((const void **)va1);
  sub_1000558F4((const void **)va2);
  sub_1000558F4((const void **)va3);
  _Unwind_Resume(a1);
}

BOOL sub_100289714(uint64_t a1)
{
  int v1 = 0;
  uint64_t v2 = a1 + 488;
  uint64_t v3 = a1 + 296;
  int v4 = 1;
  do
  {
    int v5 = v1;
    uint64_t v6 = v3;
    if (v4 != 1) {
      uint64_t v6 = v2;
    }
    BOOL result = *(_DWORD *)(v6 + 116) == 4;
    int v1 = 1;
    int v4 = 2;
  }
  while (!(v5 | result));
  return result;
}

const void **sub_100289774(CFStringRef *a1, uint64_t a2)
{
  *a1 = 0;
  uint64_t v6 = 0;
  sub_100288EC8(&v6, a2);
  if (v6) {
    uint64_t v3 = sub_1000810B8;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3) {
    CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/%@/%@/%@/com.apple.CommCenter/Setup", kSCDynamicStoreDomainSetup, kSCCompNetwork, kSCCompService, v6);
  }
  else {
    CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"com.apple.CommCenter/Setup");
  }
  *a1 = v4;
  uint64_t v7 = 0;
  sub_1000558F4(&v7);
  return sub_1000558F4(&v6);
}

void sub_100289840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000558F4((const void **)va);
  sub_1000558F4(v5);
  _Unwind_Resume(a1);
}

uint64_t sub_100289868(uint64_t a1)
{
  return *(void *)a1;
}

const void **sub_100289870(const void **a1, CFTypeRef *a2)
{
  int v5 = 0;
  sub_10004EFE4(&v5, a2);
  uint64_t v3 = *a1;
  *a1 = v5;
  int v5 = v3;
  sub_100057D78(&v5);
  return a1;
}

uint64_t sub_1002898C0(uint64_t a1)
{
  return *(void *)a1;
}

const void **sub_1002898C8(uint64_t a1, SCNetworkInterfaceRef interface)
{
  BOOL result = (const void **)SCNetworkInterfaceGetConfiguration(interface);
  if (result)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)result;
    BOOL result = (const void **)CFDictionaryGetValue((CFDictionaryRef)result, @"Setup");
    if (result)
    {
      MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v5);
      CFDictionaryRef config = MutableCopy;
      if (MutableCopy) {
        uint64_t v7 = sub_1000C06D0;
      }
      else {
        uint64_t v7 = 0;
      }
      if (v7)
      {
        CFDictionaryRemoveValue(MutableCopy, @"Setup");
        if (!SCNetworkInterfaceSetConfiguration(interface, config))
        {
          int v8 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            int v9 = SCError();
            *(_DWORD *)long long buf = 136446210;
            unsigned int v12 = SCErrorString(v9);
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E SCNetworkInterfaceSetConfiguration failed with %{public}s", buf, 0xCu);
          }
        }
      }
      return sub_10005717C((const void **)&config);
    }
  }
  return result;
}

void sub_1002899F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100289A10(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)long long buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = v7;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = asString();
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I setting interface availability, pdp: %d, source: %s available: %d", buf, 0x18u);
  }
  if (a3)
  {
    int v8 = *(uint64_t **)(a1 + 728);
    if (v8)
    {
      do
      {
        while (1)
        {
          int v9 = (uint64_t **)v8;
          int v10 = *((_DWORD *)v8 + 7);
          if (v10 <= a3) {
            break;
          }
          int v8 = *v9;
          BOOL v11 = v9;
          if (!*v9) {
            goto LABEL_13;
          }
        }
        if (v10 >= a3)
        {
          __int16 v14 = v9;
          goto LABEL_16;
        }
        int v8 = v9[1];
      }
      while (v8);
      BOOL v11 = v9 + 1;
    }
    else
    {
      BOOL v11 = (uint64_t **)(a1 + 728);
      int v9 = (uint64_t **)(a1 + 728);
    }
LABEL_13:
    __int16 v14 = operator new(0x28uLL);
    v14[7] = a3;
    *((unsigned char *)v14 + 32) = 0;
    *(void *)__int16 v14 = 0;
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = v9;
    *BOOL v11 = (uint64_t *)v14;
    uint64_t v12 = **(void **)(a1 + 720);
    uint64_t v13 = (uint64_t *)v14;
    if (v12)
    {
      *(void *)(a1 + 720) = v12;
      uint64_t v13 = *v11;
    }
    sub_100046C90(*(uint64_t **)(a1 + 728), v13);
    ++*(void *)(a1 + 736);
LABEL_16:
    *((unsigned char *)v14 + 32) = a2;
  }
  uint64_t v78 = 0;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v65 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_10004BD84((uint64_t)buf);
  sub_10004B96C(&buf[16], (uint64_t)"map for pdp:", 12);
  uint64_t v15 = (void *)std::ostream::operator<<();
  sub_10004B96C(v15, (uint64_t)" { ", 3);
  __int16 v16 = *(void **)(a1 + 720);
  int v17 = (void *)(a1 + 728);
  if (v16 != (void *)(a1 + 728))
  {
    do
    {
      CFStringRef v18 = sub_10004B96C(&buf[16], (uint64_t)" (", 2);
      int v19 = (const char *)asString();
      size_t v20 = strlen(v19);
      __int16 v21 = sub_10004B96C(v18, (uint64_t)v19, v20);
      sub_10004B96C(v21, (uint64_t)":", 1);
      uint64_t v22 = (void *)std::ostream::operator<<();
      sub_10004B96C(v22, (uint64_t)")", 1);
      int v23 = (void *)v16[1];
      if (v23)
      {
        do
        {
          char v24 = v23;
          int v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          char v24 = (void *)v16[2];
          BOOL v25 = *v24 == (void)v16;
          __int16 v16 = v24;
        }
        while (!v25);
      }
      __int16 v16 = v24;
    }
    while (v24 != v17);
  }
  sub_10004B96C(&buf[16], (uint64_t)" } ", 3);
  BOOL v26 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)&buf[24], __p);
    unint64_t v27 = v56 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)long long v61 = 136446210;
    *(void *)&void v61[4] = v27;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %{public}s", v61, 0xCu);
    if (v56 < 0) {
      operator delete(__p[0]);
    }
  }
  *(void *)&uint8_t buf[16] = v28;
  if (SHIBYTE(v67) < 0) {
    operator delete(*((void **)&v66 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if (a2)
  {
    unsigned __int8 v29 = *(void **)(a1 + 720);
    int v30 = 1;
    if (v29 != v17)
    {
      while (*((unsigned char *)v29 + 32))
      {
        unsigned int v31 = (void *)v29[1];
        if (v31)
        {
          do
          {
            uint64_t v32 = v31;
            unsigned int v31 = (void *)*v31;
          }
          while (v31);
        }
        else
        {
          do
          {
            uint64_t v32 = (void *)v29[2];
            BOOL v25 = *v32 == (void)v29;
            unsigned __int8 v29 = v32;
          }
          while (!v25);
        }
        unsigned __int8 v29 = v32;
        if (v32 == v17) {
          goto LABEL_44;
        }
      }
      int v30 = 0;
    }
LABEL_44:
    int v33 = v30;
  }
  else
  {
    int v33 = 0;
  }
  uint64_t v34 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    int v35 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v35;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v33;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I changing interface availability, pdp: %d, available: %d", buf, 0xEu);
  }
  int v36 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
  CFArrayRef v37 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v36;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v33;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I (PDPManagerInterface::ifstatus = %d, Boolean newstate =%d", buf, 0xEu);
  }
  if (!v36)
  {
    uint64_t v40 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = 1;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I returning value PDPManagerInterface::ifstatus =  unknown %d", buf, 8u);
    }
    goto LABEL_59;
  }
  if (v33) {
    int v38 = 2;
  }
  else {
    int v38 = 1;
  }
  int v39 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v38 == v36;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I returning value %d", buf, 8u);
  }
  if (v38 == v36)
  {
LABEL_59:
    __p[0] = 0;
    sub_100288EC8((const void **)__p, a1);
    if (__p[0]) {
      unsigned int v41 = sub_1000810B8;
    }
    else {
      unsigned int v41 = 0;
    }
    if (v41)
    {
      *(void *)long long v61 = 0;
      *(void *)long long v61 = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, (CFStringRef)__p[0], @"com.apple.CommCenter");
      if (*(void *)v61) {
        unint64_t v42 = sub_1000810B8;
      }
      else {
        unint64_t v42 = 0;
      }
      if (v42)
      {
        SCDynamicStoreRef store = 0;
        SCDynamicStoreRef store = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:setInterfaceAvailability", 0, 0);
        if (store) {
          char v43 = sub_100142574;
        }
        else {
          char v43 = 0;
        }
        if (v43)
        {
          *(void *)long long buf = 0;
          *(void *)long long buf = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (*(void *)buf) {
            char v44 = sub_1000C06D0;
          }
          else {
            char v44 = 0;
          }
          if (v44)
          {
            CFMutableDictionaryRef theDict = 0;
            CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (theDict) {
              uint64_t v45 = sub_1000C06D0;
            }
            else {
              uint64_t v45 = 0;
            }
            if (v45)
            {
              if (v33) {
                char v46 = &unk_10147A194;
              }
              else {
                char v46 = &unk_10147A198;
              }
              CFNumberRef v47 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, v46);
              CFNumberRef v58 = v47;
              if (v47) {
                uint64_t v48 = sub_100081E58;
              }
              else {
                uint64_t v48 = 0;
              }
              if (v48)
              {
                CFDictionarySetValue(theDict, @"Available", v47);
                CFNumberRef v57 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (const void *)(a1 + 288));
                CFDictionarySetValue(theDict, @"AvailableProtocols", v57);
                CFDictionaryAddValue(*(CFMutableDictionaryRef *)buf, *(const void **)v61, theDict);
                if (*(void *)buf)
                {
                  if (CFDictionaryGetCount(*(CFDictionaryRef *)buf) >= 1) {
                    SCDynamicStoreSetMultiple(store, *(CFDictionaryRef *)buf, 0, 0);
                  }
                }
                sub_1000570E8((const void **)&v57);
              }
              sub_1000570E8((const void **)&v58);
            }
            sub_10005717C((const void **)&theDict);
          }
          sub_10005717C((const void **)buf);
        }
        else
        {
          uint64_t v52 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            int v53 = SCError();
            int v54 = SCErrorString(v53);
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = v54;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I setInterface: SCDynamicStoreCreate error: %{public}s", buf, 0xCu);
          }
        }
        sub_100142A3C((const void **)&store);
      }
      else
      {
        uint64_t v49 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
        {
          int v50 = SCError();
          int v51 = SCErrorString(v50);
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = v51;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I setInterface: SCDynamicStoreKeyCreateNetworkServiceEntity error: %{public}s", buf, 0xCu);
        }
      }
      sub_1000558F4((const void **)v61);
    }
    sub_1000558F4((const void **)__p);
  }
}

void sub_10028A328(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va5, a2);
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  int v8 = va_arg(va2, const void *);
  va_copy(va3, va2);
  int v10 = va_arg(va3, const void *);
  va_copy(va4, va3);
  uint64_t v12 = va_arg(va4, const void *);
  va_copy(va5, va4);
  __int16 v14 = va_arg(va5, const void *);
  uint64_t v16 = va_arg(va5, void);
  sub_1000570E8((const void **)va1);
  sub_10005717C((const void **)va2);
  sub_10005717C((const void **)va5);
  sub_100142A3C((const void **)va3);
  sub_1000558F4((const void **)va4);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10028A3C8(uint64_t a1, void *a2, uint64_t a3)
{
  if (!*a2)
  {
    char v65 = 0;
    return v65 & 1;
  }
  CFMutableArrayRef theArray = 0;
  CFMutableStringRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    CFMutableArrayRef v7 = theArray;
    CFMutableArrayRef theArray = Mutable;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
    sub_1000440D4((const void **)&buf.__r_.__value_.__l.__data_);
  }
  char v8 = 0;
  uint64_t v9 = 0;
  uint64_t v84 = 0x200000001;
  char v70 = 1;
  do
  {
    char v10 = v8;
    int v11 = *((_DWORD *)&v84 + v9);
    uint64_t v12 = a1 + 296;
    if (v11 != 1)
    {
      if (v11 != 2) {
        goto LABEL_79;
      }
      uint64_t v12 = a1 + 488;
    }
    if (*(_DWORD *)(v12 + 116) == 4)
    {
      uint64_t v14 = *a2;
      uint64_t v13 = a2[1];
      if (v13) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v15 = *(std::__shared_weak_count **)(v12 + 184);
      *(void *)(v12 + 176) = v14;
      *(void *)(v12 + 184) = v13;
      if (v15) {
        sub_10004D2C8(v15);
      }
      memset(v83, 0, sizeof(v83));
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v83, (const CSIPacketAddress *)(v12 + 40));
      if ((CSIPacketAddress::isZeroIP(v16) & 1) == 0)
      {
        long long v76 = 0;
        long long v77 = 0;
        memset(v75, 0, sizeof(v75));
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)v75);
        if (CSIPacketAddress::isIPv6((CSIPacketAddress *)v83))
        {
          sub_100058DB0(&__dst, "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff");
          CSIPacketAddress::CSIPacketAddress();
          CSIPacketAddress::operator=();
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          unsigned int PrefixLen = CSIPacketAddress::getPrefixLen((CSIPacketAddress *)v83);
          CSIPacketAddress::applyMaskPrefix((CSIPacketAddress *)v75, PrefixLen);
        }
        else
        {
          CSIPacketAddress::ipv4PrefixLenToMaskAddr((uint64_t *)&buf, (CSIPacketAddress *)v83);
          CSIPacketAddress::operator=();
        }
        CSIPacketAddress::operator std::string();
        if ((__p[23] & 0x80000000) != 0) {
          sub_10004FC84(&__dst, *(void **)__p, *(unint64_t *)&__p[8]);
        }
        else {
          std::string __dst = *(std::string *)__p;
        }
        BOOL v79 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          std::string buf = __dst;
        }
        uint64_t v80 = 0;
        if (ctu::cf::convert_copy())
        {
          CFStringRef v18 = v79;
          BOOL v79 = v80;
          unint64_t v81 = v18;
          sub_1000558F4(&v81);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        value = v79;
        BOOL v79 = 0;
        sub_1000558F4((const void **)&v79);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v76;
        long long v76 = value;
        value = 0;
        sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
        sub_1000558F4((const void **)&value);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
        CSIPacketAddress::operator std::string();
        if ((v72[23] & 0x80000000) != 0) {
          sub_10004FC84(&__dst, *(void **)v72, *(unint64_t *)&v72[8]);
        }
        else {
          std::string __dst = *(std::string *)v72;
        }
        BOOL v79 = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          std::string buf = __dst;
        }
        uint64_t v80 = 0;
        if (ctu::cf::convert_copy())
        {
          int v19 = v79;
          BOOL v79 = v80;
          unint64_t v81 = v19;
          sub_1000558F4(&v81);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        value = v79;
        BOOL v79 = 0;
        sub_1000558F4((const void **)&v79);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v77;
        long long v77 = value;
        value = 0;
        sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
        sub_1000558F4((const void **)&value);
        if ((v72[23] & 0x80000000) != 0) {
          operator delete(*(void **)v72);
        }
        size_t v20 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = asString();
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"configureHOVirtualInterface";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s: HO interface config: to be called for %s...", (uint8_t *)&buf, 0x16u);
        }
        int v22 = (*(uint64_t (**)(void, void *, void *))(*(void *)*a2 + 144))(*a2, v77, v76);
        int v23 = *(NSObject **)(a1 + 40);
        BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
        if (v22)
        {
          if (v24)
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"configureHOVirtualInterface";
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v77;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s: HO interface config: addHOAddress: success: %{public}@", (uint8_t *)&buf, 0x16u);
          }
        }
        else
        {
          if (v24)
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"configureHOVirtualInterface";
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v77;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#E %s: HO interface config: addHOAddress: failure: %{public}@", (uint8_t *)&buf, 0x16u);
          }
          char v70 = 0;
        }
        if (theArray) {
          BOOL v25 = sub_100289354;
        }
        else {
          BOOL v25 = 0;
        }
        if (v25)
        {
          unint64_t v27 = *(CSIPacketAddress **)(v12 + 64);
          BOOL v26 = *(CSIPacketAddress **)(v12 + 72);
          while (v27 != v26)
          {
            if ((CSIPacketAddress::isZeroIP(v27) & 1) == 0)
            {
              value = 0;
              CSIPacketAddress::operator std::string();
              if ((v71[23] & 0x80000000) != 0) {
                sub_10004FC84(&__dst, *(void **)v71, *(unint64_t *)&v71[8]);
              }
              else {
                std::string __dst = *(std::string *)v71;
              }
              BOOL v79 = 0;
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
              }
              else {
                std::string buf = __dst;
              }
              uint64_t v80 = 0;
              if (ctu::cf::convert_copy())
              {
                xpc_object_t v28 = v79;
                BOOL v79 = v80;
                unint64_t v81 = v28;
                sub_1000558F4(&v81);
              }
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
              value = v79;
              BOOL v79 = 0;
              sub_1000558F4((const void **)&v79);
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__dst.__r_.__value_.__l.__data_);
              }
              if ((v71[23] & 0x80000000) != 0) {
                operator delete(*(void **)v71);
              }
              CFArrayAppendValue(theArray, value);
              sub_1000558F4((const void **)&value);
            }
            unint64_t v27 = (CSIPacketAddress *)((char *)v27 + 24);
          }
        }
        sub_1000558F4((const void **)&v76);
        sub_1000558F4((const void **)&v77);
      }
    }
LABEL_79:
    char v8 = 1;
    uint64_t v9 = 1;
  }
  while ((v10 & 1) == 0);
  uint64_t v30 = *a2;
  unsigned __int8 v29 = (std::__shared_weak_count *)a2[1];
  if (v29) {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v31 = a3;
  if (v30)
  {
    long long v69 = v29;
    unsigned int v32 = 0;
    char v33 = 0;
    uint64_t v34 = 0;
    v83[0] = 0x200000001;
    while (1)
    {
      char v35 = v33;
      int v36 = *((_DWORD *)v83 + v34);
      uint64_t v37 = a1 + 296;
      if (v36 == 1) {
        goto LABEL_87;
      }
      if (v36 == 2) {
        break;
      }
LABEL_142:
      char v33 = 1;
      uint64_t v34 = 1;
      if (v35)
      {
        if (v32) {
          uint64_t v61 = v32;
        }
        else {
          uint64_t v61 = 1450;
        }
        unsigned __int8 v29 = v69;
        (*(void (**)(uint64_t, uint64_t))(*(void *)v30 + 160))(v30, v61);
        goto LABEL_147;
      }
    }
    uint64_t v37 = a1 + 488;
LABEL_87:
    if (*(_DWORD *)(v37 + 116) == 4)
    {
      unsigned int v38 = *(_DWORD *)(v37 + 124);
      unsigned int v39 = v32 - 1 >= v38 ? v38 : v32;
      if (v38) {
        unsigned int v32 = v39;
      }
    }
    if (v36 != 2) {
      goto LABEL_142;
    }
    memset(&__dst, 0, sizeof(__dst));
    if (*(char *)(v31 + 23) < 0) {
      sub_10004FC84(&__dst, *(void **)v31, *(void *)(v31 + 8));
    }
    else {
      std::string __dst = *(std::string *)v31;
    }
    std::string::size_type v40 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    char v41 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v43 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v43 = __dst.__r_.__value_.__l.__size_;
    }
    if (!v43)
    {
      (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v30 + 136))(&buf, v30);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      std::string __dst = buf;
      std::string::size_type v40 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      std::string::size_type size = buf.__r_.__value_.__l.__size_;
      char v41 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    }
    if (v41 < 0) {
      std::string::size_type v40 = size;
    }
    if (!v40)
    {
      uint64_t v44 = *(unsigned int *)(a1 + 120);
      uint64_t v45 = "";
      if (v44 <= 0xF) {
        uint64_t v45 = off_1019B2768[v44];
      }
      sub_10003ED78(&__dst, v45);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      if (!__dst.__r_.__value_.__l.__size_) {
        goto LABEL_137;
      }
      char v46 = (std::string *)__dst.__r_.__value_.__r.__words[0];
LABEL_115:
      unsigned int v47 = sub_100A194B0((const char *)v46);
      unsigned int v48 = v47;
      if (v47 >= v32) {
        unsigned int v49 = v32;
      }
      else {
        unsigned int v49 = v47;
      }
      if (!v32) {
        unsigned int v49 = v47;
      }
      if (v47) {
        unsigned int v32 = v49;
      }
      int v50 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        p_dst = &__dst;
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"configureHOVirtualInterfaceMTU";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_dst;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
        unsigned int v86 = v48;
        __int16 v87 = 1024;
        unsigned int v88 = v32;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I %s: HO interface MTU config V1 (over %s): default route mtu = %u, new mtu %u", (uint8_t *)&buf, 0x22u);
      }
      unsigned int v52 = sub_100A1997C();
      unsigned int v53 = v52;
      if (v52 >= v32) {
        unsigned int v54 = v32;
      }
      else {
        unsigned int v54 = v52;
      }
      if (!v32) {
        unsigned int v54 = v52;
      }
      if (v52) {
        unsigned int v32 = v54;
      }
      int v55 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        char v56 = &__dst;
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          char v56 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"configureHOVirtualInterfaceMTU";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v56;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
        unsigned int v86 = v53;
        __int16 v87 = 1024;
        unsigned int v88 = v32;
        CFNumberRef v57 = v55;
        CFNumberRef v58 = "#I %s: HO interface MTU config V2 (over %s): default route mtu = %u, new mtu %u";
        uint32_t v59 = 34;
LABEL_139:
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, v58, (uint8_t *)&buf, v59);
      }
    }
    else
    {
      if (*((unsigned char *)&__dst.__r_.__value_.__s + 23))
      {
        char v46 = &__dst;
        goto LABEL_115;
      }
LABEL_137:
      BOOL v60 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"configureHOVirtualInterfaceMTU";
        CFNumberRef v57 = v60;
        CFNumberRef v58 = "#I %s: HO interface MTU config: ifaceName is empty";
        uint32_t v59 = 12;
        goto LABEL_139;
      }
    }
    uint64_t v31 = a3;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    goto LABEL_142;
  }
LABEL_147:
  if (v29) {
    sub_10004D2C8(v29);
  }
  if (theArray) {
    in_addr v62 = sub_100289354;
  }
  else {
    in_addr v62 = 0;
  }
  if (v62 && CFArrayGetCount(theArray) >= 1)
  {
    char v63 = (*(uint64_t (**)(void, CFMutableArrayRef))(*(void *)*a2 + 152))(*a2, theArray);
    long long v64 = *(NSObject **)(a1 + 40);
    if (v63)
    {
      if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"configureHOVirtualInterface";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)theArray;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I %s: HO interface config: setDNSServers: success: %{public}@", (uint8_t *)&buf, 0x16u);
      }
    }
    else
    {
      if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"configureHOVirtualInterface";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)theArray;
        _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "%s: HO interface config: setDNSServers failed with dnses: %{public}@", (uint8_t *)&buf, 0x16u);
      }
      char v70 = 0;
    }
  }
  char v66 = (*(uint64_t (**)(void))(*(void *)*a2 + 168))();
  long long v67 = *(NSObject **)(a1 + 40);
  if (v66)
  {
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"configureHOVirtualInterface";
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I %s: HO interface config: success", (uint8_t *)&buf, 0xCu);
    }
    char v65 = v70;
  }
  else
  {
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"configureHOVirtualInterface";
      _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "%s: HO interface config: updateHOAdHocService failed", (uint8_t *)&buf, 0xCu);
    }
    char v65 = 0;
  }
  sub_1000440D4((const void **)&theArray);
  return v65 & 1;
}

void sub_10028AFE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,int a45,__int16 a46,char a47,char a48,int a49,const void *a50,__int16 a51,char a52,char a53)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_1000440D4(&a50);
  _Unwind_Resume(a1);
}

const void **sub_10028B180(const void **a1, int a2)
{
  if (a2) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = 4;
  }
  return sub_10028B190(a1, v2);
}

const void **sub_10028B190(const void **result, unsigned int a2)
{
  uint64_t v3 = (uint64_t)result;
  if (*((unsigned char *)result + 140) || *((unsigned char *)result + 141) || *((_DWORD *)result + 34) != a2)
  {
    unsigned int v47 = 0;
    SCDynamicStoreRef v48 = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:setInterfaceRank", 0, 0);
    *(void *)std::string buf = 0;
    sub_100142A3C((const void **)buf);
    if (v48) {
      CFStringRef v4 = sub_100142574;
    }
    else {
      CFStringRef v4 = 0;
    }
    if (v4)
    {
      sub_100288EC8((const void **)v51, v3);
      *(void *)std::string buf = v47;
      unsigned int v47 = *(const void **)v51;
      *(void *)int v51 = 0;
      sub_1000558F4((const void **)buf);
      sub_1000558F4((const void **)v51);
      if (v47) {
        uint64_t v5 = sub_1000810B8;
      }
      else {
        uint64_t v5 = 0;
      }
      if (v5)
      {
        uint64_t v46 = _SCNetworkServiceCopyActive();
        if (v46) {
          uint64_t v6 = sub_100289868;
        }
        else {
          uint64_t v6 = 0;
        }
        if (v6)
        {
          if (SCNetworkServiceSetPrimaryRank() == 1)
          {
            CFMutableArrayRef v7 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
            {
              if (a2 > 4) {
                char v8 = "Unknown";
              }
              else {
                char v8 = off_1019B2C08[a2];
              }
              *(_DWORD *)std::string buf = 136315138;
              *(void *)&uint8_t buf[4] = v8;
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I interface rank set to %s", buf, 0xCu);
            }
            *(_DWORD *)(v3 + 136) = a2;
            if (*(unsigned char *)(v3 + 140))
            {
LABEL_33:
              ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 48));
              BOOL v25 = ServiceMap;
              if (v26 < 0)
              {
                unint64_t v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v28 = 5381;
                do
                {
                  uint64_t v26 = v28;
                  unsigned int v29 = *v27++;
                  uint64_t v28 = (33 * v28) ^ v29;
                }
                while (v29);
              }
              std::mutex::lock(ServiceMap);
              *(void *)std::string buf = v26;
              uint64_t v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
              if (v30)
              {
                uint64_t v32 = v30[3];
                uint64_t v31 = (std::__shared_weak_count *)v30[4];
                if (v31)
                {
                  atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v25);
                  atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v31);
                  char v33 = 0;
                  if (!v32)
                  {
LABEL_56:
                    if ((v33 & 1) == 0) {
                      sub_10004D2C8(v31);
                    }
                    goto LABEL_58;
                  }
LABEL_48:
                  memset(buf, 0, sizeof(buf));
                  CSIPDPManager::getInterfaceNameById();
                  uint64_t v49 = 0;
                  int v50 = 0;
                  sub_10028583C(&v49, v3);
                  unsigned int v39 = *(NSObject **)(v3 + 40);
                  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
                  {
                    int v40 = (char)buf[23];
                    char v41 = *(uint8_t **)buf;
                    uint64_t v42 = subscriber::asString();
                    std::string::size_type v43 = buf;
                    if (v40 < 0) {
                      std::string::size_type v43 = v41;
                    }
                    *(_DWORD *)int v51 = 136446466;
                    *(void *)&v51[4] = v43;
                    __int16 v52 = 2080;
                    uint64_t v53 = v42;
                    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Setting interface %{public}s expensive cost flag to true, active SIM %s", v51, 0x16u);
                  }
                  (*(void (**)(uint64_t, uint8_t *, uint64_t))(*(void *)v32 + 32))(v32, buf, 1);
                  if (v50) {
                    sub_10004D2C8(v50);
                  }
                  if ((char)buf[23] < 0) {
                    operator delete(*(void **)buf);
                  }
                  goto LABEL_56;
                }
              }
              else
              {
                uint64_t v32 = 0;
              }
              std::mutex::unlock(v25);
              uint64_t v31 = 0;
              char v33 = 1;
              if (!v32) {
                goto LABEL_56;
              }
              goto LABEL_48;
            }
            if (a2)
            {
              uint64_t v34 = *(std::__shared_weak_count **)(v3 + 752);
              if (!v34) {
                goto LABEL_33;
              }
              char v35 = std::__shared_weak_count::lock(v34);
              if (!v35) {
                goto LABEL_33;
              }
              int v36 = v35;
              uint64_t v37 = *(void *)(v3 + 744);
              if (!v37)
              {
                sub_10004D2C8(v36);
                goto LABEL_33;
              }
              char v38 = (*(uint64_t (**)(uint64_t))(*(void *)v37 + 88))(v37);
              sub_10004D2C8(v36);
              if ((v38 & 1) == 0) {
                goto LABEL_33;
              }
            }
LABEL_58:
            *(_WORD *)(v3 + 140) = 0;
            goto LABEL_59;
          }
          *(_DWORD *)(v3 + 136) = -1;
          int v22 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            if (a2 > 4) {
              int v23 = "Unknown";
            }
            else {
              int v23 = off_1019B2C08[a2];
            }
            int v44 = SCError();
            uint64_t v45 = SCErrorString(v44);
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v23;
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v45;
            int v19 = "Failed to store rank: %s: %{public}s";
            size_t v20 = v22;
            uint32_t v21 = 22;
            goto LABEL_65;
          }
        }
        else
        {
          uint64_t v16 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            int v17 = SCError();
            CFStringRef v18 = SCErrorString(v17);
            *(_DWORD *)std::string buf = 136446210;
            *(void *)&uint8_t buf[4] = v18;
            int v19 = "Failed to get network service for rank: %{public}s";
            size_t v20 = v16;
            uint32_t v21 = 12;
LABEL_65:
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v19, buf, v21);
          }
        }
LABEL_59:
        sub_10028D954((const void **)&v46);
        goto LABEL_60;
      }
      uint64_t v15 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        uint64_t v12 = "Failed to get service ID for rank";
        uint64_t v13 = v15;
        uint32_t v14 = 2;
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v9 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        int v10 = SCError();
        int v11 = SCErrorString(v10);
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v11;
        uint64_t v12 = "Failed to create dynamic_store for rank: %{public}s";
        uint64_t v13 = v9;
        uint32_t v14 = 12;
LABEL_24:
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
      }
    }
LABEL_60:
    sub_1000558F4(&v47);
    return sub_100142A3C((const void **)&v48);
  }
  return result;
}

void sub_10028B6EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, const void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  sub_10004D2C8(v24);
  sub_10028D954(&a10);
  sub_1000558F4(&a11);
  sub_100142A3C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10028B784(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 764)) {
    return 0;
  }
  if (*(void *)(a1 + 128)) {
    int v1 = sub_1000810B8;
  }
  else {
    int v1 = 0;
  }
  if (v1) {
    return 1;
  }
  sub_10027BD94(&v5, a1);
  if (v5) {
    uint64_t v3 = sub_1000810B8;
  }
  else {
    uint64_t v3 = 0;
  }
  BOOL v2 = v3 != 0;
  sub_1000558F4(&v5);
  return v2;
}

const void **sub_10028B81C(const void **result, int a2, const char *a3)
{
  if (a3) {
    uint64_t v3 = a3;
  }
  else {
    uint64_t v3 = "unknown";
  }
  if (*((_DWORD *)result + 72) != a2)
  {
    CFStringRef v4 = result;
    *((_DWORD *)result + 72) = a2;
    CFStringRef serviceID = 0;
    sub_100288EC8((const void **)&serviceID, (uint64_t)result);
    if (serviceID) {
      uint64_t v5 = sub_1000810B8;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5)
    {
      key = (void *)SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, serviceID, @"com.apple.CommCenter");
      if (key) {
        uint64_t v6 = sub_1000810B8;
      }
      else {
        uint64_t v6 = 0;
      }
      if (v6)
      {
        unint64_t v27 = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:setProtocolAvailability", 0, 0);
        if (v27) {
          CFMutableArrayRef v7 = sub_100142574;
        }
        else {
          CFMutableArrayRef v7 = 0;
        }
        if (v7)
        {
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (Mutable) {
            char v8 = sub_1000C06D0;
          }
          else {
            char v8 = 0;
          }
          if (v8)
          {
            CFDictionaryRef theDict = 0;
            *(void *)std::string buf = SCDynamicStoreCopyValue(v27, (CFStringRef)key);
            sub_100084068(&theDict, (CFTypeRef *)buf);
            CFMutableDictionaryRef v24 = 0;
            if (theDict) {
              uint64_t v9 = sub_100080778;
            }
            else {
              uint64_t v9 = 0;
            }
            if (v9) {
              MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
            }
            else {
              MutableCFDictionaryRef Copy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            }
            CFMutableDictionaryRef v17 = v24;
            CFMutableDictionaryRef v24 = MutableCopy;
            *(void *)std::string buf = v17;
            sub_10005717C((const void **)buf);
            if (v24) {
              CFStringRef v18 = sub_1000C06D0;
            }
            else {
              CFStringRef v18 = 0;
            }
            if (v18)
            {
              CFNumberRef v19 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, v4 + 36);
              CFNumberRef v23 = v19;
              if (v19) {
                size_t v20 = sub_100081E58;
              }
              else {
                size_t v20 = 0;
              }
              if (v20)
              {
                CFDictionarySetValue(v24, @"AvailableProtocols", v19);
                CFDictionaryAddValue(Mutable, key, v24);
                SCDynamicStoreSetMultiple(v27, Mutable, 0, 0);
                uint32_t v21 = v4[5];
                if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v22 = asString();
                  *(_DWORD *)std::string buf = 136315394;
                  *(void *)&uint8_t buf[4] = v22;
                  __int16 v31 = 2080;
                  uint64_t v32 = v3;
                  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Configuring PDP manager to use protocol family: %s (reason %s)", buf, 0x16u);
                }
              }
              sub_1000570E8((const void **)&v23);
            }
            sub_10005717C((const void **)&v24);
            sub_100057D78((const void **)&theDict);
          }
          sub_10005717C((const void **)&Mutable);
        }
        else
        {
          uint32_t v14 = v4[5];
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            int v15 = SCError();
            uint64_t v16 = SCErrorString(v15);
            *(_DWORD *)std::string buf = 136446210;
            *(void *)&uint8_t buf[4] = v16;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I setProtocol: SCDynamicStoreCreate error: %{public}s", buf, 0xCu);
          }
        }
        sub_100142A3C((const void **)&v27);
      }
      else
      {
        int v11 = v4[5];
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = SCError();
          uint64_t v13 = SCErrorString(v12);
          *(_DWORD *)std::string buf = 136446210;
          *(void *)&uint8_t buf[4] = v13;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I setProtocol: SCDynamicStoreKeyCreateNetworkServiceEntity error: %{public}s", buf, 0xCu);
        }
      }
      sub_1000558F4((const void **)&key);
    }
    return sub_1000558F4((const void **)&serviceID);
  }
  return result;
}

void sub_10028BBD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va6, a2);
  va_start(va5, a2);
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, const void *);
  va_copy(va3, va2);
  CFMutableArrayRef v7 = va_arg(va3, const void *);
  va_copy(va4, va3);
  uint64_t v9 = va_arg(va4, const void *);
  va_copy(va5, va4);
  int v11 = va_arg(va5, const void *);
  va_copy(va6, va5);
  uint64_t v13 = va_arg(va6, const void *);
  sub_1000570E8((const void **)va);
  sub_10005717C((const void **)va1);
  sub_100057D78((const void **)va2);
  sub_10005717C((const void **)va3);
  sub_100142A3C((const void **)va4);
  sub_1000558F4((const void **)va5);
  sub_1000558F4((const void **)va6);
  _Unwind_Resume(a1);
}

uint64_t sub_10028BC5C(uint64_t a1)
{
  BOOL v2 = (std::mutex *)(a1 + 144);
  std::mutex::lock((std::mutex *)(a1 + 144));
  uint64_t v3 = *(unsigned int *)(a1 + 760);
  std::mutex::unlock(v2);
  return v3;
}

void sub_10028BC98(uint64_t a1, int a2, int a3)
{
  if (a2 == 2)
  {
    uint64_t v4 = a1 + 488;
  }
  else
  {
    if (a2 != 1) {
      return;
    }
    uint64_t v4 = a1 + 296;
  }
  *(_DWORD *)(v4 + 128) = a3;
  sub_10027C5D8(&v5, a1);
  sub_10027EC44(a1, &v5);
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_10028BD04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10028BD1C(uint64_t a1)
{
  char v2 = 0;
  uint64_t v3 = (char *)&dword_10147A19C;
  do
  {
    while (1)
    {
      uint64_t v4 = *(int *)v3;
      if (!*(unsigned char *)(a1 + v4 + 765)) {
        break;
      }
      uint64_t v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = asString();
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v13 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I fDNSInProbation %s (change states): true ==>> false", buf, 0xCu);
      }
      *(unsigned char *)(a1 + v4 + 765) = 0;
      v3 += 4;
      char v2 = 1;
      if (v3 == "16DarwinPDPManager") {
        goto LABEL_10;
      }
    }
    v3 += 4;
  }
  while (v3 != "16DarwinPDPManager");
  if ((v2 & 1) == 0) {
    return;
  }
LABEL_10:
  (*(void (**)(void))(**(void **)(a1 + 768) + 16))(*(void *)(a1 + 768));
  uint64_t v7 = *(void *)(a1 + 768);
  *(void *)(a1 + 768) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  char v8 = *(std::__shared_weak_count **)(a1 + 752);
  if (v8)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v8);
    if (v9)
    {
      int v10 = v9;
      uint64_t v11 = *(void *)(a1 + 744);
      if (v11) {
        (*(void (**)(uint64_t))(*(void *)v11 + 56))(v11);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_10028BEE0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10028BEFC(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a1 + 488;
  uint64_t v8 = a1 + 296;
  do
  {
    int v9 = dword_10147A19C[v6];
    if (v9 == a3 || anyContextType())
    {
      uint64_t v10 = a1 + v9;
      if (!*(unsigned char *)(v10 + 765))
      {
        uint64_t v11 = v8;
        if (a2 != 1)
        {
          if (a2 != 2) {
            goto LABEL_5;
          }
          uint64_t v11 = v7;
        }
        if (*(_DWORD *)(v11 + 116) == 4)
        {
          int v12 = *(CSIPacketAddress **)(v11 + 64);
          if (*(CSIPacketAddress **)(v11 + 72) != v12 && (CSIPacketAddress::isZeroIP(v12) & 1) == 0)
          {
            uint64_t v13 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v14 = asString();
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v14;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I fDNSInProbation %s (change states): false ==>> true", (uint8_t *)&buf, 0xCu);
            }
            *(unsigned char *)(v10 + 765) = 1;
            int v15 = *(std::__shared_weak_count **)(a1 + 16);
            if (!v15 || (uint64_t v16 = v7, v17 = *(void *)(a1 + 8), (v18 = std::__shared_weak_count::lock(v15)) == 0)) {
              sub_100088B9C();
            }
            atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            uint64_t v28 = v18;
            sub_10004D2C8(v18);
            Registry::getTimerService((uint64_t *)&buf, *(Registry **)(a1 + 48));
            uint64_t v19 = buf;
            sub_100058DB0(__p, "DNSTimeout");
            size_t v20 = *(NSObject **)(a1 + 24);
            dispatch_object_t object = v20;
            if (v20) {
              dispatch_retain(v20);
            }
            aBlock[0] = _NSConcreteStackBlock;
            aBlock[1] = 1174405120;
            aBlock[2] = sub_10028C308;
            aBlock[3] = &unk_1019B2690;
            aBlock[4] = a1;
            void aBlock[5] = v17;
            uint64_t v30 = v28;
            atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            int v31 = v9;
            uint64_t v32 = _Block_copy(aBlock);
            sub_100118A44(v19, (uint64_t)__p, 0, 21000000, &object, &v32);
            uint64_t v7 = v16;
            uint64_t v21 = v36;
            uint64_t v36 = 0;
            uint64_t v22 = *(void *)(a1 + 768);
            *(void *)(a1 + 768) = v21;
            if (v22)
            {
              (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
              uint64_t v23 = v36;
              uint64_t v36 = 0;
              if (v23) {
                (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
              }
            }
            if (v32) {
              _Block_release(v32);
            }
            if (object) {
              dispatch_release(object);
            }
            if (v35 < 0) {
              operator delete(__p[0]);
            }
            if (*((void *)&buf + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
            }
            CFMutableDictionaryRef v24 = *(std::__shared_weak_count **)(a1 + 752);
            if (v24)
            {
              BOOL v25 = std::__shared_weak_count::lock(v24);
              if (v25)
              {
                uint64_t v26 = v25;
                uint64_t v27 = *(void *)(a1 + 744);
                if (v27) {
                  (*(void (**)(uint64_t))(*(void *)v27 + 48))(v27);
                }
                sub_10004D2C8(v26);
              }
            }
            if (v30) {
              std::__shared_weak_count::__release_weak(v30);
            }
            std::__shared_weak_count::__release_weak(v28);
          }
        }
      }
    }
LABEL_5:
    ++v6;
  }
  while (v6 != 2);
}

void sub_10028C268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,void *aBlock,dispatch_object_t object,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_10004D2C8(v28);
  if (a19) {
    std::__shared_weak_count::__release_weak(a19);
  }
  std::__shared_weak_count::__release_weak(a12);
  _Unwind_Resume(a1);
}

void sub_10028C308(void *a1)
{
  char v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = v3[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          int v7 = 136315138;
          uint64_t v8 = asString();
          _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "fDNSInProbation: DNS config has not completed in time for %s!", (uint8_t *)&v7, 0xCu);
        }
        (*(void (**)(void *))(*v3 + 208))(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10028C408(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10028C420(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10028C43C(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

BOOL sub_10028C44C(uint64_t a1, int a2)
{
  uint64_t v4 = 0;
  BOOL v5 = 0;
  do
  {
    uint64_t v6 = dword_10147A19C[v4];
    if (v6 == a2 || anyContextType()) {
      BOOL v5 = (*(unsigned __int8 *)(a1 + v6 + 765) | v5) != 0;
    }
    ++v4;
  }
  while (v4 != 2);
  return v5;
}

void sub_10028C4D0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)long long buf = 67109120;
    int v35 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ========== start pdp_ip%d: ==========", buf, 8u);
  }
  bzero(buf, 0x401uLL);
  CFStringRef v4 = *(const __CFString **)(a1 + 128);
  if (v4) {
    BOOL v5 = sub_1000810B8;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    int CString = CFStringGetCString(v4, (char *)buf, 1024, 0x8000100u);
    int v7 = *(NSObject **)(a1 + 40);
    if (CString)
    {
      if (!os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      *(_DWORD *)uint64_t v28 = 136446210;
      unsigned int v29 = buf;
      uint64_t v8 = "#I DATA:: fServiceID: %{public}s";
      int v9 = v7;
      uint32_t v10 = 12;
      goto LABEL_13;
    }
  }
  else
  {
    int v7 = *(NSObject **)(a1 + 40);
  }
  if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_14;
  }
  *(_WORD *)uint64_t v28 = 0;
  uint64_t v8 = "#I DATA:: fServiceID: null";
  int v9 = v7;
  uint32_t v10 = 2;
LABEL_13:
  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, v28, v10);
LABEL_14:
  uint64_t v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(int *)(a1 + 136);
    if (v12 > 4) {
      uint64_t v13 = "Unknown";
    }
    else {
      uint64_t v13 = off_1019B2C08[v12];
    }
    uint64_t v14 = asStringBool(*(unsigned char *)(a1 + 140));
    uint64_t v15 = asStringBool(*(unsigned char *)(a1 + 141));
    *(_DWORD *)uint64_t v28 = 136315650;
    unsigned int v29 = (uint8_t *)v13;
    __int16 v30 = 2080;
    uint64_t v31 = v14;
    __int16 v32 = 2080;
    uint64_t v33 = v15;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I DATA:: fRank: %s, fRankFirstTime =%s, fRankNeedsRefresh = %s", v28, 0x20u);
    uint64_t v11 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = asStringBool(*(unsigned char *)(a1 + 764));
    *(_DWORD *)uint64_t v28 = 136315138;
    unsigned int v29 = (uint8_t *)v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I DATA:: fStartCompleted: %s", v28, 0xCu);
  }
  for (uint64_t i = 0; i != 2; ++i)
  {
    CFStringRef v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = dword_10147A19C[i];
      uint64_t v20 = asString();
      uint64_t v21 = asStringBool(*(unsigned char *)(a1 + v19 + 765));
      *(_DWORD *)uint64_t v28 = 136315394;
      unsigned int v29 = (uint8_t *)v20;
      __int16 v30 = 2080;
      uint64_t v31 = v21;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDNSInProbation[%s]: %s", v28, 0x16u);
    }
  }
  uint64_t v22 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = asStringBool(*(void *)(a1 + 768) != 0);
    *(_DWORD *)uint64_t v28 = 136315138;
    unsigned int v29 = (uint8_t *)v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDNSInProbationTimer: %s", v28, 0xCu);
    uint64_t v22 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = asStringBool(*(void *)(a1 + 776) != 0);
    *(_DWORD *)uint64_t v28 = 136315138;
    unsigned int v29 = (uint8_t *)v24;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I DATA:: fConfigdRestartTimer: %s", v28, 0xCu);
    uint64_t v22 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = asStringBool(*(unsigned char *)(a1 + 784));
    *(_DWORD *)uint64_t v28 = 136315138;
    unsigned int v29 = (uint8_t *)v25;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I DATA:: fIpcInterfaceConfigStarted: %s", v28, 0xCu);
  }
  sub_10028C928(a1 + 296);
  sub_10028C928(a1 + 488);
  uint64_t v26 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    int v27 = *(_DWORD *)(a1 + 120);
    *(_DWORD *)uint64_t v28 = 67109120;
    LODWORD(v29) = v27;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I DATA:: ========== end pdp_ip%d ==========", v28, 8u);
  }
}

void sub_10028C928(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fIPFamily: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 32);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 116);
    if (v3 > 4) {
      CFStringRef v4 = "???";
    }
    else {
      CFStringRef v4 = off_1019B2C30[v3];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fState: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 32);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    CSIPacketAddress::operator std::string();
    BOOL v5 = v19 >= 0 ? buf : *(unsigned char **)buf;
    *(_DWORD *)uint64_t v20 = 136315138;
    uint64_t v21 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fIpAddress: %s", v20, 0xCu);
    if (v19 < 0) {
      operator delete(*(void **)buf);
    }
  }
  uint64_t v6 = *(void *)(a1 + 64);
  for (uint64_t i = *(void *)(a1 + 72); v6 != i; v6 += 24)
  {
    uint64_t v8 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      CSIPacketAddress::operator std::string();
      int v9 = v19 >= 0 ? buf : *(unsigned char **)buf;
      *(_DWORD *)uint64_t v20 = 136446210;
      uint64_t v21 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDns: %{public}s", v20, 0xCu);
      if (v19 < 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  uint32_t v10 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    CSIPacketAddress::operator std::string();
    if (v19 >= 0) {
      uint64_t v11 = buf;
    }
    else {
      uint64_t v11 = *(unsigned char **)buf;
    }
    *(_DWORD *)uint64_t v20 = 136315138;
    uint64_t v21 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: fLastIPv6Router: %s", v20, 0xCu);
    if (v19 < 0) {
      operator delete(*(void **)buf);
    }
    uint32_t v10 = *(NSObject **)(a1 + 32);
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asStringBool(*(unsigned char *)(a1 + 112));
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: fUseLastIPv6Router: %s", buf, 0xCu);
    uint32_t v10 = *(NSObject **)(a1 + 32);
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *(_DWORD *)(a1 + 124);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: fLastMTU: %du", buf, 8u);
    uint32_t v10 = *(NSObject **)(a1 + 32);
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = *(_DWORD *)(a1 + 128);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: fNetworkProvidedMTU: %du", buf, 8u);
    uint32_t v10 = *(NSObject **)(a1 + 32);
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = asStringBool();
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: xlatState: ipv4ConfigState: %s", buf, 0xCu);
    uint32_t v10 = *(NSObject **)(a1 + 32);
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = asStringBool(*(void *)(a1 + 144) != 0);
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: xlatState: ipv4Timer: %s", buf, 0xCu);
    uint32_t v10 = *(NSObject **)(a1 + 32);
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = (void *)(a1 + 152);
    if (*(char *)(a1 + 175) < 0) {
      uint64_t v17 = (void *)*v17;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v17;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I DATA:: fErrorReason: %{public}s", buf, 0xCu);
  }
}

uint64_t sub_10028CDC8(uint64_t a1, NSObject **a2, const char *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, a3);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  BOOL v5 = *a2;
  *(void *)(a1 + 16) = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  *(void *)(a1 + 24) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 32), (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 40));
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(a1 + 88));
  *(unsigned char *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 116) = xmmword_10147A180;
  *(_WORD *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  return a1;
}

void sub_10028CE94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  uint64_t v15 = v14;
  uint64_t v17 = *v15;
  if (*v15)
  {
    v12[9] = v17;
    operator delete(v17);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  sub_100087E88(v12);
  _Unwind_Resume(a1);
}

void *sub_10028CEF4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 184);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  uint64_t v3 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  CFStringRef v4 = *(void **)(a1 + 64);
  if (v4)
  {
    *(void *)(a1 + 72) = v4;
    operator delete(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 32));

  return sub_100087E88((void *)a1);
}

void sub_10028CF8C(uint64_t a1@<X0>, int a2@<W1>, CFDictionaryRef *a3@<X2>, CFDictionaryRef *a4@<X8>)
{
  CFDictionaryRef v6 = *a3;
  if (a2)
  {
LABEL_2:
    *a4 = v6;
LABEL_3:
    *a3 = 0;
    return;
  }
  if (v6) {
    uint64_t v8 = sub_100080778;
  }
  else {
    uint64_t v8 = 0;
  }
  if (!v8)
  {
    uint64_t v22 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N convertPacketNotificationFilterRequest: dict empty", buf, 2u);
      CFDictionaryRef v6 = *a3;
    }
    goto LABEL_2;
  }
  CFDictionaryRef v9 = (const __CFDictionary *)CFDictionaryGetValue(*a3, kCTQualityOfServiceFamilyIPv4);
  if (!v9 || (v10 = v9, CFTypeID v11 = CFGetTypeID(v9), v11 != CFDictionaryGetTypeID()))
  {
    sub_100058198(&v71, (const void **)a3);
    sub_10027C2D0(a1, "convertPacketNotificationFilterRequest: no IPv4 addr: orig ip dict", (const __CFDictionary **)&v71);
    sub_100057D78(&v71);
    *a4 = *a3;
    goto LABEL_3;
  }
  unsigned int v70 = 0;
  *(void *)long long v76 = 0;
  uint64_t v77 = 0;
  uint64_t v68 = 0;
  long long v69 = 0;
  v67[0] = 0;
  v67[1] = 0;
  CSIPDPManager::getInterfaceNameById();
  std::string __p = 0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  getCLAT46IPv6Address((uint64_t *)&__p, (const char *)v67, &v70, v76, (const char **)&v69);
  uint64_t v12 = v69;
  if (!v69)
  {
    uint64_t v12 = "";
    long long v69 = "";
  }
  int v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = v67;
    if (v68 < 0) {
      int v14 = (void **)v67[0];
    }
    p_p = &__p;
    if (v66 < 0) {
      p_p = __p;
    }
    *(_DWORD *)long long buf = 136446978;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = p_p;
    *(_WORD *)&unsigned char buf[22] = 1024;
    unsigned int v73 = v70;
    __int16 v74 = 2082;
    long long v75 = v12;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I convertPacketNotificationFilterRequest: if_name=%{public}s, ipv6=%s, prefix_len=%u, status=%{public}s", buf, 0x26u);
  }
  uint64_t v16 = HIBYTE(v66);
  if (v66 < 0) {
    uint64_t v16 = v65;
  }
  if (v16)
  {
    if (v70)
    {
      uint64_t v17 = (void *)kCTQualityOfServiceSourceIP;
      CFDataRef v18 = (const __CFData *)CFDictionaryGetValue(v10, kCTQualityOfServiceSourceIP);
      CFDataRef v19 = v18;
      if (v18)
      {
        CFTypeID v20 = CFGetTypeID(v18);
        if (v20 == CFDataGetTypeID()) {
          CFDataRef v21 = v19;
        }
        else {
          CFDataRef v21 = 0;
        }
      }
      else
      {
        CFDataRef v21 = 0;
      }
      uint64_t v25 = (const void *)kCTQualityOfServiceCallType;
      uint64_t v26 = CFDictionaryGetValue(v10, kCTQualityOfServiceCallType);
      int v27 = v26;
      if (v26)
      {
        CFTypeID v28 = CFGetTypeID(v26);
        if (v28 == CFNumberGetTypeID()) {
          unsigned int v29 = v27;
        }
        else {
          unsigned int v29 = 0;
        }
        uint32_t v59 = v29;
      }
      else
      {
        uint32_t v59 = 0;
      }
      __int16 v30 = (void *)kCTQualityOfServiceSourcePort;
      uint64_t v31 = CFDictionaryGetValue(v10, kCTQualityOfServiceSourcePort);
      __int16 v32 = v31;
      CFNumberRef v57 = v30;
      CFNumberRef v58 = v25;
      if (v31)
      {
        CFTypeID v33 = CFGetTypeID(v31);
        if (v33 == CFNumberGetTypeID()) {
          uint64_t v34 = v32;
        }
        else {
          uint64_t v34 = 0;
        }
      }
      else
      {
        uint64_t v34 = 0;
      }
      int v35 = (const void *)kCTQualityOfServiceDestinationPort;
      uint64_t v36 = CFDictionaryGetValue(v10, kCTQualityOfServiceDestinationPort);
      uint64_t v37 = v36;
      key = v17;
      if (v36)
      {
        CFTypeID v38 = CFGetTypeID(v36);
        if (v38 != CFNumberGetTypeID()) {
          uint64_t v37 = 0;
        }
      }
      unsigned int v39 = (const void *)kCTQualityOfServiceUniqueTag;
      int v40 = CFDictionaryGetValue(v10, kCTQualityOfServiceUniqueTag);
      char v41 = v40;
      if (v40)
      {
        CFTypeID v42 = CFGetTypeID(v40);
        if (v42 != CFNumberGetTypeID()) {
          char v41 = 0;
        }
      }
      value = 0;
      if (v21)
      {
        unsigned int v43 = v70;
        if (v70)
        {
          if (CFDataGetLength(v21) == 4)
          {
            BytePtr = CFDataGetBytePtr(v21);
            if (BytePtr)
            {
              *(void *)long long buf = 0;
              *(void *)&uint8_t buf[8] = 0;
              if (getCLAT46IPv6AddressRemote(BytePtr, v43, v76, buf))
              {
                value = 0;
                CFDataRef v45 = CFDataCreate(0, buf, 16);
              }
              else
              {
                int v55 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)bytes = 0;
                  _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#E convertPacketNotificationFilterRemoteAddress: cannot convert", bytes, 2u);
                }
                CFDataRef v45 = 0;
              }
              value = v45;
              goto LABEL_71;
            }
            uint64_t v46 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              unsigned int v47 = "#E convertPacketNotificationFilterRemoteAddress: empty dataPtr";
              goto LABEL_68;
            }
          }
          else
          {
            SCDynamicStoreRef v48 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
            {
              int Length = CFDataGetLength(v21);
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = Length;
              unsigned int v47 = "#E convertPacketNotificationFilterRemoteAddress: wrong addr len = %d";
              int v50 = v48;
              uint32_t v51 = 8;
LABEL_69:
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v47, buf, v51);
            }
          }
LABEL_70:
          value = 0;
LABEL_71:
          memset(buf, 0, sizeof(buf));
          CSIPacketAddress::CSIPacketAddress();
          *(void *)bytes = 0;
          uint64_t v79 = 0;
          CSIPacketAddress::toIPv6((CSIPacketAddress *)buf, bytes);
          in_addr v62 = CFDataCreate(0, bytes, 16);
          *(void *)long long buf = 0;
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          *(void *)long long buf = Mutable;
          if (value) {
            uint64_t v53 = sub_10008324C;
          }
          else {
            uint64_t v53 = 0;
          }
          if (v53) {
            CFDictionarySetValue(Mutable, key, value);
          }
          if (v62) {
            unsigned int v54 = sub_10008324C;
          }
          else {
            unsigned int v54 = 0;
          }
          if (v54) {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, kCTQualityOfServiceDestinationIP, v62);
          }
          if (v59) {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, v58, v59);
          }
          if (v34) {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, v57, v34);
          }
          if (v37) {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, v35, v37);
          }
          if (v41) {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, v39, v41);
          }
          *(void *)bytes = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)bytes, kCTQualityOfServiceFamilyIPv6, *(const void **)buf);
          sub_100058198(&v61, (const void **)a3);
          sub_10027C2D0(a1, "convertPacketNotificationFilterRequest: orig ip dict", (const __CFDictionary **)&v61);
          sub_100057D78(&v61);
          sub_10004EFE4(&v60, (CFTypeRef *)bytes);
          sub_10027C2D0(a1, "convertPacketNotificationFilterRequest: new ip dict", (const __CFDictionary **)&v60);
          sub_100057D78(&v60);
          sub_10004EFE4(a4, (CFTypeRef *)bytes);
          sub_10005717C((const void **)bytes);
          sub_10005717C((const void **)buf);
          sub_100030068((const void **)&v62);
          sub_100030068((const void **)&value);
          goto LABEL_90;
        }
        uint64_t v46 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_70;
        }
        *(_WORD *)long long buf = 0;
        unsigned int v47 = "#E convertPacketNotificationFilterRemoteAddress: empty prefix length";
      }
      else
      {
        uint64_t v46 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_70;
        }
        *(_WORD *)long long buf = 0;
        unsigned int v47 = "#E convertPacketNotificationFilterRemoteAddress: empty remote addr";
      }
LABEL_68:
      int v50 = v46;
      uint32_t v51 = 2;
      goto LABEL_69;
    }
    uint64_t v23 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v24 = "#N convertPacketNotificationFilterRequest: prefix_len empty";
      goto LABEL_34;
    }
  }
  else
  {
    uint64_t v23 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v24 = "#I convertPacketNotificationFilterRequest: no IPv6 addr";
LABEL_34:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v24, buf, 2u);
    }
  }
  *a4 = *a3;
  *a3 = 0;
LABEL_90:
  if (SHIBYTE(v66) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v68) < 0) {
    operator delete(v67[0]);
  }
}

void sub_10028D728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,char a41,int a42,__int16 a43,char a44,char a45)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028D7E4(uint64_t a1, int a2)
{
  if (a2) {
    return 0;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v5 = 0;
  CSIPDPManager::getInterfaceNameById();
  uint64_t v2 = isXLAT464Interface((const char *)__p);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_10028D858(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10028D874(uint64_t a1, int a2)
{
  sub_10027C5D8(&v8, a1);
  char v4 = sub_10028878C(a1, v8);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v4) {
    return 0;
  }
  if (a2 == 2)
  {
    uint64_t v5 = a1 + 488;
  }
  else
  {
    if (a2 != 1) {
      return 0;
    }
    uint64_t v5 = a1 + 296;
  }
  if (*(void *)(v5 + 64) == *(void *)(v5 + 72)) {
    return 0;
  }
  uint64_t v6 = a1 + 296;
  if (a2 == 1) {
    uint64_t v6 = a1 + 488;
  }
  return *(void *)(v6 + 64) == *(void *)(v6 + 72);
}

const void **sub_10028D920(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_10028D954(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_10028D988(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_10028D9BC(uint64_t a1, const CSIPacketAddress *a2)
{
  uint64_t v3 = *(const CSIPacketAddress **)a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_10006A748();
  }
  uint64_t v7 = a1 + 16;
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - (void)v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 16;
  if (v9) {
    CFDictionaryRef v10 = (char *)sub_10004812C(v7, v9);
  }
  else {
    CFDictionaryRef v10 = 0;
  }
  std::string __p = v10;
  int v14 = (CSIPacketAddress *)&v10[24 * v4];
  uint64_t v16 = &v10[24 * v9];
  CSIPacketAddress::CSIPacketAddress(v14, a2);
  uint64_t v15 = (CSIPacketAddress *)((char *)v14 + 24);
  sub_10028DB34((const CSIPacketAddress **)a1, &__p);
  uint64_t v11 = *(void *)(a1 + 8);
  if (v15 != v14) {
    uint64_t v15 = (CSIPacketAddress *)((char *)v14 + (v15 - v14 - 24) % 0x18uLL);
  }
  if (__p) {
    operator delete(__p);
  }
  return v11;
}

void sub_10028DAE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10028DB34(const CSIPacketAddress **a1, void *a2)
{
  unint64_t v5 = *a1;
  unint64_t v4 = a1[1];
  uint64_t v6 = (const CSIPacketAddress *)a2[1];
  while (v4 != v5)
  {
    unint64_t v4 = (const CSIPacketAddress *)((char *)v4 - 24);
    CSIPacketAddress::CSIPacketAddress((const CSIPacketAddress *)((char *)v6 - 24), v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  unint64_t v8 = a1[1];
  a1[1] = (const CSIPacketAddress *)a2[2];
  a2[2] = v8;
  unint64_t v9 = a1[2];
  a1[2] = (const CSIPacketAddress *)a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

const void **sub_10028DBBC(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_10028DBF0(void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = (const void **)**a1;
  if (v2)
  {
    unint64_t v4 = (const void **)v1[1];
    unint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        unint64_t v4 = sub_10028D954(v4 - 1);
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

const void **sub_10028DC74(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_10028DCA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = *(NSObject **)(*(void *)a3 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (a1)
  {
    if (a2)
    {
      if (!v6) {
        return;
      }
      int v10 = 138543618;
      uint64_t v11 = a1;
      __int16 v12 = 2112;
      uint64_t v13 = a2;
      uint64_t v7 = "#I \t%{public}@ = %@;";
      unint64_t v8 = v5;
      uint32_t v9 = 22;
      goto LABEL_13;
    }
    if (!v6) {
      return;
    }
    int v10 = 138543362;
    uint64_t v11 = a1;
    uint64_t v7 = "#I \t%{public}@ = null;";
    goto LABEL_10;
  }
  if (a2)
  {
    if (!v6) {
      return;
    }
    int v10 = 138412290;
    uint64_t v11 = a2;
    uint64_t v7 = "#I \tnull = %@;";
LABEL_10:
    unint64_t v8 = v5;
    uint32_t v9 = 12;
    goto LABEL_13;
  }
  if (!v6) {
    return;
  }
  LOWORD(v10) = 0;
  uint64_t v7 = "#I \tnull = null;";
  unint64_t v8 = v5;
  uint32_t v9 = 2;
LABEL_13:
  _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v10, v9);
}

void sub_10028DDFC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

NSObject ***sub_10028DE34(uint64_t a1)
{
  BOOL result = *(NSObject ****)(a1 + 24);
  if (result)
  {
    sub_10028DEC0(result);
    operator delete();
  }
  return result;
}

uint64_t sub_10028DE7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

NSObject ***sub_10028DEC0(NSObject ***a1)
{
  uint64_t v2 = (const __SCPreferences *)a1[1];
  if (!v2)
  {
    BOOL v6 = **a1;
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    LOWORD(v13) = 0;
    uint64_t v7 = "#E unlock: fPrefs nullptr !";
    unint64_t v8 = v6;
    uint32_t v9 = 2;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v13, v9);
    goto LABEL_12;
  }
  if (!*((unsigned char *)a1 + 16)) {
    goto LABEL_12;
  }
  int v3 = SCPreferencesUnlock(v2);
  unint64_t v4 = **a1;
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (!v3)
  {
    if (!v5) {
      goto LABEL_12;
    }
    int v10 = SCError();
    int v13 = 136446210;
    int v14 = SCErrorString(v10);
    uint64_t v7 = "#E Unable to unlock SCPreferences: %{public}s";
    unint64_t v8 = v4;
    uint32_t v9 = 12;
    goto LABEL_11;
  }
  if (v5)
  {
    LOWORD(v13) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I unlockPreferences complete", (uint8_t *)&v13, 2u);
  }
  *((unsigned char *)a1 + 16) = 0;
LABEL_12:
  uint64_t v11 = a1[1];
  if (v11)
  {
    CFRelease(v11);
    a1[1] = 0;
  }
  return a1;
}

void sub_10028E014(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

NSObject ***sub_10028E020(NSObject ****a1)
{
  BOOL result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_10028DEC0(result);
    operator delete();
  }
  return result;
}

void sub_10028E070(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10028E13C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10028E214);
  __cxa_rethrow();
}

void sub_10028E164(_Unwind_Exception *a1)
{
}

void sub_10028E17C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10028E1B4(uint64_t a1)
{
}

uint64_t sub_10028E1D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10028E214(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_10028E240(uint64_t *a1)
{
  uint64_t v1 = *a1;
  __int16 v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I revive: trying to reset important stuff", buf, 2u);
  }
  if (!*(void *)(v2 + 776))
  {
    uint64_t v26 = 0;
    sub_10027C68C(v2, &v26);
    sub_1000558F4(&v26);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v22 = 0x40000000;
    uint64_t v23 = sub_10027C7C0;
    uint64_t v24 = &unk_1019B2478;
    uint64_t v25 = v2;
    unint64_t v4 = _Block_copy(buf);
    Registry::getTimerService(&v18, *(Registry **)(v2 + 48));
    uint64_t v5 = v18;
    sub_100058DB0(__p, "ConfigdRestartTimeout");
    BOOL v6 = *(NSObject **)(v2 + 24);
    dispatch_object_t object = v6;
    if (v6) {
      dispatch_retain(v6);
    }
    if (v4) {
      uint64_t v7 = _Block_copy(v4);
    }
    else {
      uint64_t v7 = 0;
    }
    aBlock = v7;
    sub_100118A44(v5, (uint64_t)__p, 0, 5000000, &object, &aBlock);
    uint64_t v8 = v20;
    uint64_t v20 = 0;
    uint64_t v9 = *(void *)(v2 + 776);
    *(void *)(v2 + 776) = v8;
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      uint64_t v10 = v20;
      uint64_t v20 = 0;
      if (v10) {
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      }
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    if (v19) {
      sub_10004D2C8(v19);
    }
    if (v4) {
      _Block_release(v4);
    }
  }
  sub_1000E1A60(&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_10028E458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *aBlock, dispatch_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  if (v20) {
    _Block_release(v20);
  }
  sub_1000E1A60(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void *sub_10028E4E0(void *a1)
{
  *a1 = off_1019B28D0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10028E52C(void *a1)
{
  *a1 = off_1019B28D0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_10028E598(uint64_t a1)
{
  BOOL result = (char *)operator new(0x20uLL);
  *(void *)BOOL result = off_1019B28D0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10028E5FC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B28D0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10028E63C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10028E64C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

const void **sub_10028E68C(uint64_t a1)
{
  BOOL result = *(const void ***)(a1 + 8);
  unsigned int v2 = *((_DWORD *)result + 34);
  if (v2 != -1)
  {
    *((_DWORD *)result + 34) = -1;
    return sub_10028B190(result, v2);
  }
  return result;
}

uint64_t sub_10028E6AC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019B2930)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10028E6EC()
{
  return &off_1019B2930;
}

void sub_10028E6F8(const void **a1, const void *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3) {
    CFRelease(v3);
  }
}

void *sub_10028E724(void *a1)
{
  *a1 = off_1019B2950;
  unsigned int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10028E770(void *a1)
{
  *a1 = off_1019B2950;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_10028E7DC(uint64_t a1)
{
  BOOL result = (char *)operator new(0x20uLL);
  *(void *)BOOL result = off_1019B2950;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10028E840(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019B2950;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10028E880(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10028E890(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10028E8D0(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  (*(void (**)(uint64_t, void))(*(void *)v3 + 136))(v3, 0);
  if (v2)
  {
    __p[0] = 0;
    sub_100288EC8((const void **)__p, v3);
    if (__p[0]) {
      unint64_t v4 = sub_1000810B8;
    }
    else {
      unint64_t v4 = 0;
    }
    if (v4)
    {
      sub_100287ED0((void *)v3, 1, 1);
      sub_100287ED0((void *)v3, 2, 1);
    }
    else
    {
      uint64_t v5 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = *(_DWORD *)(v3 + 120);
        *(_DWORD *)long long buf = 67109120;
        int v31 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E Did not find the service ID for %d; will try again later",
          buf,
          8u);
      }
    }
    sub_1000558F4((const void **)__p);
  }
  uint64_t v7 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Finished starting PDP manager", (uint8_t *)__p, 2u);
  }
  if (!v2)
  {
    sub_10027EF40(v3, v3 + 296, "Failed to get serviceID for IPV4", v8, v9, v10, v11, v12, (char)__p[0]);
    sub_10027EF40(v3, v3 + 488, "Failed to get serviceID for IPV6", v13, v14, v15, v16, v17, (char)__p[0]);
  }
  *(unsigned char *)(v3 + 764) = 1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 48));
  CFDataRef v19 = ServiceMap;
  if (v20 < 0)
  {
    CFDataRef v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v20;
  uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)__p);
  if (!v24)
  {
    uint64_t v26 = 0;
LABEL_22:
    std::mutex::unlock(v19);
    uint64_t v25 = 0;
    char v27 = 1;
    if (!v26) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  uint64_t v26 = v24[3];
  uint64_t v25 = (std::__shared_weak_count *)v24[4];
  if (!v25) {
    goto LABEL_22;
  }
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v19);
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v25);
  char v27 = 0;
  if (!v26)
  {
LABEL_24:
    if (v27) {
      return;
    }
    goto LABEL_25;
  }
LABEL_23:
  sub_100058DB0(__p, "Finished starting PDP manager");
  (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v26 + 1096))(v26, 3, __p, 0);
  if ((v29 & 0x80000000) == 0) {
    goto LABEL_24;
  }
  operator delete(__p[0]);
  if (v27) {
    return;
  }
LABEL_25:
  sub_10004D2C8(v25);
}

void sub_10028EB90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028EBE8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10028EC28()
{
}

uint64_t sub_10028EC34(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10028EC44(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10028EC60(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t *sub_10028EC70(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_100057D78((const void **)(v1 + 32));
    sub_10028D988((const void **)(v1 + 24));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10028ECD4(void *a1)
{
  uint64_t v11 = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = *a1;
    unint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[1])
      {
        uint64_t v5 = IPConfigurationServiceCreate();
        int v6 = *(NSObject **)(v3 + 40);
        BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
        if (v5)
        {
          if (v7)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I IPv6Service successfully created", buf, 2u);
          }
          uint64_t v8 = *(std::__shared_weak_count **)(v3 + 16);
          if (v8)
          {
            if (std::__shared_weak_count::lock(v8)) {
              operator new();
            }
          }
          sub_100088B9C();
        }
        if (v7)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#E Failed to create IPv6Service", buf, 2u);
        }
        uint64_t v9 = *(std::__shared_weak_count **)(v3 + 16);
        if (v9 && std::__shared_weak_count::lock(v9)) {
          operator new();
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
  return sub_10028EC70((uint64_t *)&v11);
}

void sub_10028EF20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10004D2C8(v9);
  sub_10028EC70(&a9);
  _Unwind_Resume(a1);
}

void sub_10028EF44(uint64_t **a1)
{
  uint64_t v2 = (void *)**a1;
  uint64_t v1 = (*a1)[1];
  if (*(_DWORD *)(v1 + 116) == 2)
  {
    sub_10027F0B8(**a1, v1, 1u);
    sub_100282DDC(v2);
    sub_10027F0B8((uint64_t)v2, (uint64_t)(v2 + 61), 1u);
  }
  else
  {
    uint64_t v3 = v2[5];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E IPv6Service: state outdated (failure)", buf, 2u);
    }
    unint64_t v4 = (std::__shared_weak_count *)v2[94];
    if (v4)
    {
      uint64_t v5 = std::__shared_weak_count::lock(v4);
      if (v5)
      {
        int v6 = v5;
        uint64_t v7 = v2[93];
        if (v7) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 80))(v7, 21);
        }
        sub_10004D2C8(v6);
      }
    }
  }
  operator delete();
}

void sub_10028F058()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_10028F094(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = (*a1)[2];
  if (*(_DWORD *)(v3 + 116) != 2)
  {
    uint64_t v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context.version) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E IPv6Service: state outdated (success)", (uint8_t *)&context, 2u);
    }
    context.version = v1[1];
    sub_10028542C(v2, &context);
    version = (const void *)context.version;
    context.version = 0;
    if (version) {
      CFRelease(version);
    }
    char v15 = *(std::__shared_weak_count **)(v2 + 752);
    if (v15)
    {
      uint64_t v16 = std::__shared_weak_count::lock(v15);
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = *(void *)(v2 + 744);
        if (v18) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 80))(v18, 21);
        }
        sub_10004D2C8(v17);
      }
    }
    goto LABEL_45;
  }
  sub_10027F0B8(**a1, v3, 3u);
  unint64_t v4 = (const void *)v1[1];
  if (!v4)
  {
    CFDataRef v19 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context.version) = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E IPv6Service: newService is empty", (uint8_t *)&context, 2u);
    }
    goto LABEL_43;
  }
  uint64_t v5 = *(const void **)(v2 + 688);
  *(void *)(v2 + 688) = 0;
  CFTypeRef cf = v5;
  sub_10028542C(v2, &cf);
  if (cf) {
    CFRelease(cf);
  }
  sub_10028E6F8((const void **)(v2 + 688), v4);
  *(unsigned char *)(v2 + 141) = 1;
  if (!*(void *)(v2 + 688))
  {
LABEL_42:
    sub_100282DDC((void *)v2);
LABEL_43:
    unsigned int v12 = 1;
    goto LABEL_44;
  }
  context.version = 0;
  context.info = (void *)v2;
  memset(&context.retain, 0, 24);
  int v6 = *(const __SCDynamicStore **)(v2 + 704);
  if (v6) {
    uint64_t v7 = sub_100142574;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7) {
    SCDynamicStoreSetDispatchQueue(v6, 0);
  }
  SCDynamicStoreRef v8 = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:IPv6ServiceChange", (SCDynamicStoreCallBack)sub_1002856A4, &context);
  uint64_t v9 = *(void **)(v2 + 704);
  *(void *)(v2 + 704) = v8;
  values[0] = v9;
  sub_100142A3C((const void **)values);
  if (*(void *)(v2 + 704)) {
    uint64_t v10 = sub_100142574;
  }
  else {
    uint64_t v10 = 0;
  }
  if (!v10)
  {
    uint64_t v20 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(values[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#E IPv6Service SCDynamicStore failed", (uint8_t *)values, 2u);
    }
    goto LABEL_40;
  }
  values[0] = (void *)IPConfigurationServiceGetNotificationKey();
  CFArrayRef v26 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
  if (SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(v2 + 704), v26, 0))
  {
    if (SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(v2 + 704), *(dispatch_queue_t *)(v2 + 24)) == 1)
    {
      sub_100044D00((const void **)&v26);
      uint64_t v11 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context.version) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I ipv6ServiceChanged to be called", (uint8_t *)&context, 2u);
      }
      sub_10028065C(v2, 0);
      if (*(_DWORD *)(v2 + 604) != 4)
      {
        unsigned int v12 = 4;
LABEL_44:
        sub_10027F0B8(v2, v2 + 488, v12);
      }
LABEL_45:
      operator delete();
    }
    CFDataRef v21 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_39;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v22 = "#E IPv6Service SCDynamicStoreSetDispatchQueue failed";
  }
  else
  {
    CFDataRef v21 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
LABEL_39:
      sub_100044D00((const void **)&v26);
LABEL_40:
      unsigned int v23 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context.version) = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#E IPv6Service SCDynamicStore monitor setup failed", (uint8_t *)&context, 2u);
      }
      goto LABEL_42;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v22 = "#E IPv6Service SCDynamicStoreSetNotificationKeys failed";
  }
  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v22, buf, 2u);
  goto LABEL_39;
}

void sub_10028F490(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, CFTypeRef cf)
{
  sub_10004D2C8(v13);
  operator delete();
}

uint64_t *sub_10028F524(void *a1)
{
  uint64_t v11 = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = *a1;
    unint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[1])
      {
        uint64_t v5 = IPConfigurationServiceCreate();
        int v6 = *(NSObject **)(v3 + 40);
        BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
        if (v5)
        {
          if (v7)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I IPv4Service successfully created", buf, 2u);
          }
          SCDynamicStoreRef v8 = *(std::__shared_weak_count **)(v3 + 16);
          if (v8)
          {
            if (std::__shared_weak_count::lock(v8)) {
              operator new();
            }
          }
          sub_100088B9C();
        }
        if (v7)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#E Failed to create IPv4Service", buf, 2u);
        }
        uint64_t v9 = *(std::__shared_weak_count **)(v3 + 16);
        if (v9 && std::__shared_weak_count::lock(v9)) {
          operator new();
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
  return sub_10028EC70((uint64_t *)&v11);
}

void sub_10028F770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10004D2C8(v9);
  sub_10028EC70(&a9);
  _Unwind_Resume(a1);
}

void sub_10028F794(uint64_t **a1)
{
  uint64_t v2 = (void *)**a1;
  uint64_t v1 = (*a1)[1];
  if (*(_DWORD *)(v1 + 116) == 2)
  {
    sub_10027F0B8(**a1, v1, 1u);
    sub_100282538(v2);
    sub_10027F0B8((uint64_t)v2, (uint64_t)(v2 + 37), 1u);
  }
  else
  {
    uint64_t v3 = v2[5];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E IPv4Service: state outdated (failure)", buf, 2u);
    }
    unint64_t v4 = (std::__shared_weak_count *)v2[94];
    if (v4)
    {
      uint64_t v5 = std::__shared_weak_count::lock(v4);
      if (v5)
      {
        int v6 = v5;
        uint64_t v7 = v2[93];
        if (v7) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 80))(v7, 21);
        }
        sub_10004D2C8(v6);
      }
    }
  }
  operator delete();
}

void sub_10028F8A8()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_10028F8E4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = (*a1)[2];
  if (*(_DWORD *)(v3 + 116) != 2)
  {
    uint64_t v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context.version) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E IPv4Service: state outdated (success)", (uint8_t *)&context, 2u);
    }
    context.version = v1[1];
    sub_100285348(v2, &context);
    version = (const void *)context.version;
    context.version = 0;
    if (version) {
      CFRelease(version);
    }
    char v15 = *(std::__shared_weak_count **)(v2 + 752);
    if (v15)
    {
      uint64_t v16 = std::__shared_weak_count::lock(v15);
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = *(void *)(v2 + 744);
        if (v18) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 80))(v18, 21);
        }
        sub_10004D2C8(v17);
      }
    }
    goto LABEL_45;
  }
  sub_10027F0B8(**a1, v3, 3u);
  unint64_t v4 = (const void *)v1[1];
  if (!v4)
  {
    CFDataRef v19 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context.version) = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E IPv4Service: newService is empty", (uint8_t *)&context, 2u);
    }
    goto LABEL_43;
  }
  uint64_t v5 = *(const void **)(v2 + 696);
  *(void *)(v2 + 696) = 0;
  CFTypeRef cf = v5;
  sub_100285348(v2, &cf);
  if (cf) {
    CFRelease(cf);
  }
  sub_10028E6F8((const void **)(v2 + 696), v4);
  if (!*(void *)(v2 + 696))
  {
LABEL_42:
    sub_100282538((void *)v2);
LABEL_43:
    unsigned int v12 = 1;
    goto LABEL_44;
  }
  context.version = 0;
  context.info = (void *)v2;
  memset(&context.retain, 0, 24);
  int v6 = *(const __SCDynamicStore **)(v2 + 712);
  if (v6) {
    uint64_t v7 = sub_100142574;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7) {
    SCDynamicStoreSetDispatchQueue(v6, 0);
  }
  SCDynamicStoreRef v8 = SCDynamicStoreCreate(kCFAllocatorDefault, @"com.apple.CommCenter:IPv4ServiceChange", (SCDynamicStoreCallBack)sub_100285510, &context);
  uint64_t v9 = *(void **)(v2 + 712);
  *(void *)(v2 + 712) = v8;
  values[0] = v9;
  sub_100142A3C((const void **)values);
  if (*(void *)(v2 + 712)) {
    uint64_t v10 = sub_100142574;
  }
  else {
    uint64_t v10 = 0;
  }
  if (!v10)
  {
    uint64_t v20 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(values[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#E IPv4Service SCDynamicStore failed", (uint8_t *)values, 2u);
    }
    goto LABEL_40;
  }
  values[0] = (void *)IPConfigurationServiceGetNotificationKey();
  CFArrayRef v26 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
  if (SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(v2 + 712), v26, 0))
  {
    if (SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(v2 + 712), *(dispatch_queue_t *)(v2 + 24)) == 1)
    {
      sub_100044D00((const void **)&v26);
      uint64_t v11 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context.version) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I ipv4ServiceChanged to be called in case we have missed the notification", (uint8_t *)&context, 2u);
      }
      sub_10027F86C(v2, 0);
      if (*(_DWORD *)(v2 + 412) != 4)
      {
        unsigned int v12 = 4;
LABEL_44:
        sub_10027F0B8(v2, v2 + 296, v12);
      }
LABEL_45:
      operator delete();
    }
    CFDataRef v21 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_39;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v22 = "#E IPv4Service SCDynamicStoreSetDispatchQueue failed";
  }
  else
  {
    CFDataRef v21 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
LABEL_39:
      sub_100044D00((const void **)&v26);
LABEL_40:
      unsigned int v23 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context.version) = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#E IPv4Service SCDynamicStore monitor setup failed", (uint8_t *)&context, 2u);
      }
      goto LABEL_42;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v22 = "#E IPv4Service SCDynamicStoreSetNotificationKeys failed";
  }
  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v22, buf, 2u);
  goto LABEL_39;
}

void sub_10028FCD8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, CFTypeRef cf)
{
  sub_10004D2C8(v13);
  operator delete();
}

uint64_t *sub_10028FD6C(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_10028FDC0(void *a1)
{
  unsigned int v12 = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = *a1;
    unint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[1])
      {
        int v6 = (const void *)a1[3];
        uint64_t v7 = *(NSObject **)(v3 + 40);
        BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
        if (v6)
        {
          if (v8)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I non-empty IPv6Service tear down start...", buf, 2u);
          }
          CFRelease(v6);
          uint64_t v7 = *(NSObject **)(v3 + 40);
          if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_12;
          }
          __int16 v14 = 0;
          uint64_t v9 = "#I IPv6Service teared down";
          uint64_t v10 = (uint8_t *)&v14;
          goto LABEL_11;
        }
        if (v8)
        {
          *(_WORD *)uint64_t v13 = 0;
          uint64_t v9 = "#E empty IPv6Service tear down";
          uint64_t v10 = v13;
LABEL_11:
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v9, v10, 2u);
        }
      }
LABEL_12:
      sub_10004D2C8(v5);
    }
  }
  return sub_10028FD6C((uint64_t *)&v12);
}

uint64_t *sub_10028FED0(void *a1)
{
  unsigned int v12 = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = *a1;
    unint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[1])
      {
        int v6 = (const void *)a1[3];
        uint64_t v7 = *(NSObject **)(v3 + 40);
        BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
        if (v6)
        {
          if (v8)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I non-empty IPv4Service tear down start...", buf, 2u);
          }
          CFRelease(v6);
          uint64_t v7 = *(NSObject **)(v3 + 40);
          if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_12;
          }
          __int16 v14 = 0;
          uint64_t v9 = "#I IPv4Service teared down";
          uint64_t v10 = (uint8_t *)&v14;
          goto LABEL_11;
        }
        if (v8)
        {
          *(_WORD *)uint64_t v13 = 0;
          uint64_t v9 = "#E empty IPv4Service tear down";
          uint64_t v10 = v13;
LABEL_11:
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v9, v10, 2u);
        }
      }
LABEL_12:
      sub_10004D2C8(v5);
    }
  }
  return sub_10028FD6C((uint64_t *)&v12);
}

void sub_10028FFE0(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(**(void **)a1 + 48));
  uint64_t v2 = ServiceMap;
  if (v3 < 0)
  {
    unint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      uint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, (unint64_t *)__p);
  if (v7)
  {
    uint64_t v9 = v7[3];
    BOOL v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      if (!v9) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  BOOL v8 = 0;
  char v10 = 1;
  if (!v9) {
    goto LABEL_11;
  }
LABEL_10:
  sub_100058DB0(__p, "DS service ID update");
  (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v9 + 1096))(v9, 3, __p, 0);
  if (v12 < 0)
  {
    operator delete(__p[0]);
    if (v10) {
LABEL_13:
    }
      operator delete();
LABEL_12:
    sub_10004D2C8(v8);
    goto LABEL_13;
  }
LABEL_11:
  if (v10) {
    goto LABEL_13;
  }
  goto LABEL_12;
}

void sub_100290150(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  operator delete();
}

uint64_t *sub_1002901AC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_100288FC4(*(void *)v1, *(unsigned __int8 *)(v1 + 24), *(_DWORD *)(v1 + 28));
  sub_100290214(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1002901F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100290214(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100290268(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  sub_100288FC4(*(void *)v1, *(unsigned __int8 *)(v1 + 25), *(_DWORD *)(v1 + 28));
  if (*(unsigned char *)(v1 + 24)) {
    int v3 = 1;
  }
  else {
    int v3 = 2;
  }
  v6[0] = off_1019B2A08;
  v6[3] = v6;
  sub_10027CD08(v2, v3, (uint64_t)v6);
}

void sub_10029032C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_100060644((uint64_t *)va2);
  sub_100290358((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100290358(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_1002903B0()
{
}

void *sub_1002903C4()
{
  BOOL result = operator new(0x10uLL);
  void *result = off_1019B2A08;
  return result;
}

void sub_1002903FC(uint64_t a1, void *a2)
{
  *a2 = off_1019B2A08;
}

uint64_t sub_100290428(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019B2A68)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100290468()
{
  return &off_1019B2A68;
}

void sub_100290478(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1002904B0(uint64_t a1)
{
}

uint64_t sub_1002904B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1002904FC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(char *)(a2 + 95) < 0) {
      operator delete(*(void **)(a2 + 72));
    }
    if (*(char *)(a2 + 47) < 0) {
      operator delete(*(void **)(a2 + 24));
    }
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    operator delete();
  }
}

uint64_t *sub_100290578(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 32));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_1002905D4(uint64_t *a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = *a1;
  int v5 = *((_DWORD *)a1 + 16);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    WirelessTechnologyList::asString((uint64_t *)__p, (WirelessTechnologyList *)&v5);
    if (v9 >= 0) {
      uint64_t v3 = __p;
    }
    else {
      uint64_t v3 = (void **)__p[0];
    }
    int buf = 136446210;
    *(void *)buf_4 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I writeServiceEntryToSystemConfig: start: technology %{public}s", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_10027B9E4();
}

void sub_100291B10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,char a25,int a26,__int16 a27,char a28,char a29,int a30,__int16 a31,char a32,char a33,int a34,__int16 a35,char a36,char a37,int a38,__int16 a39,char a40,char a41,int a42,__int16 a43,char a44,char a45,int a46,__int16 a47,char a48,char a49,int a50,__int16 a51,char a52,char a53,void *__p,uint64_t a55,int a56,__int16 a57,char a58,char a59)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100291D88(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_1000607A8(v1 + 24, *(unsigned char *)(v1 + 16));
  sub_100291DEC(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100291DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100291DEC(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 24));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100291E48(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100057D78((const void **)(v1 + 56));
    sub_100057D78((const void **)(v1 + 48));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 40);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100291EB8(void *a1)
{
  v5[0] = (uint64_t)a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[1];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      if (*a1)
      {
        v5[7] = 0;
        v5[8] = 0;
        sub_10027B9E4();
      }
      sub_10004D2C8(v3);
    }
  }
  return sub_100291E48(v5);
}

void sub_1002926B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17, int a18, __int16 a19, char a20,char a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34,int a35,__int16 a36,char a37,char a38)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100292800(uint64_t a1)
{
  return *(void *)a1;
}

const void **sub_100292808(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void SubscriberUtility::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100292DF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

void sub_100292E24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 8))(a14);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_10004D2C8(v19);
  JUMPOUT(0x100293024);
}

void sub_100292E8C(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    dispatch_barrier_async_f(v2[3], v2, (dispatch_function_t)sub_10029703C);
    __cxa_rethrow();
  }
  JUMPOUT(0x100293024);
}

void sub_100292EC0()
{
}

void sub_100292ED0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, dispatch_object_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  sub_100087F94(v25, *(void **)(v23 + 200));
  sub_1000C56F4((void ***)&a10);
  sub_100088048(v24, *(void **)(v23 + 152));
  sub_10029767C(*(void **)(v23 + 128));
  CFArrayRef v26 = *(std::__shared_weak_count **)(v23 + 112);
  if (v26) {
    sub_10004D2C8(v26);
  }
  char v27 = *(std::__shared_weak_count **)(v23 + 96);
  if (v27) {
    sub_10004D2C8(v27);
  }
  CFTypeID v28 = *(std::__shared_weak_count **)(v23 + 80);
  if (v28) {
    sub_10004D2C8(v28);
  }
  char v29 = *(std::__shared_weak_count **)(v23 + 64);
  if (v29) {
    sub_10004D2C8(v29);
  }
  uint64_t v30 = *(void *)(v23 + 48);
  *(void *)(v23 + 48) = 0;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  }
  JUMPOUT(0x100292FF8);
}

void sub_10029302C()
{
}

void sub_100293034(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x100293024);
}

const char *sub_100293044(int a1)
{
  uint64_t v1 = "subscr.util.?";
  if (a1 == 2) {
    uint64_t v1 = "subscr.util.2";
  }
  if (a1 == 1) {
    return "subscr.util.1";
  }
  else {
    return v1;
  }
}

void sub_100293070(uint64_t a1)
{
  *(void *)a1 = off_1019B2C68;
  uint64_t v2 = (void *)(a1 + 352);
  sub_10019D5B8(a1 + 384, *(void **)(a1 + 392));
  sub_100296E48(v2);
  sub_10019D5B8(a1 + 328, *(void **)(a1 + 336));
  sub_100296ECC((void *)(a1 + 296));
  sub_100030EE0(a1 + 272, *(char **)(a1 + 280));
  if (*(unsigned char *)(a1 + 240))
  {
    BOOL v8 = (void **)(a1 + 248);
    sub_100047F64(&v8);
    *(unsigned char *)(a1 + 240) = 0;
  }
  sub_1000346F8(a1 + 216, *(void **)(a1 + 224));
  sub_100087F94(a1 + 192, *(void **)(a1 + 200));
  BOOL v8 = (void **)(a1 + 168);
  sub_1000C56F4(&v8);
  sub_100088048(a1 + 144, *(void **)(a1 + 152));
  sub_10029767C(*(void **)(a1 + 128));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 112);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 96);
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 80);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 64);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  SubscriberUtilityInterface::~SubscriberUtilityInterface((SubscriberUtilityInterface *)a1);
}

void sub_1002931C8(uint64_t a1)
{
  sub_100293070(a1);

  operator delete();
}

void sub_100293200(capabilities::ct **a1)
{
  a1[2] = 0;
  uint64_t v2 = a1 + 2;
  *a1 = 0;
  a1[1] = 0;
  uint64_t v3 = (capabilities::ct *)operator new(4uLL);
  *(_DWORD *)uint64_t v3 = 1;
  *uint64_t v2 = (char *)v3 + 4;
  *a1 = v3;
  a1[1] = (capabilities::ct *)((char *)v3 + 4);
  if (capabilities::ct::supportsGemini(v3))
  {
    int v5 = sub_10005ECD8((uint64_t)v2, 2uLL);
    uint64_t v6 = *a1;
    uint64_t v7 = a1[1];
    v5[1] = 2;
    BOOL v8 = (char *)(v5 + 1);
    uint64_t v9 = (capabilities::ct *)(v5 + 2);
    while (v7 != v6)
    {
      int v10 = *((_DWORD *)v7 - 1);
      uint64_t v7 = (capabilities::ct *)((char *)v7 - 4);
      *((_DWORD *)v8 - 1) = v10;
      v8 -= 4;
    }
    *a1 = (capabilities::ct *)v8;
    a1[1] = v9;
    a1[2] = (capabilities::ct *)&v5[v4];
    if (v6) {
      operator delete(v6);
    }
    a1[1] = v9;
  }
}

void sub_1002932AC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002932D4(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1002933D4(uint64_t a1, unsigned int a2, std::string *a3, std::string *a4)
{
  std::string v135 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      std::string::size_type v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  buf.__r_.__value_.__r.__words[0] = v8;
  char v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, void))(*(void *)v14 + 192))(&v135, v14, a2);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (v135) {
    char v16 = sub_1000810B8;
  }
  else {
    char v16 = 0;
  }
  if (!v16)
  {
    uint64_t v30 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    uint64_t v31 = 0;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#E Failed to get bundle name", (uint8_t *)&buf, 2u);
      uint64_t v31 = 0;
    }
    goto LABEL_213;
  }
  memset(&buf, 0, sizeof(buf));
  ctu::cf::assign();
  std::string v134 = buf;
  uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = &v134;
    if ((v134.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v18 = (std::string *)v134.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Bundle name %s", (uint8_t *)&buf, 0xCu);
  }
  memset(&buf, 0, sizeof(buf));
  ctu::cf::assign();
  std::string v133 = buf;
  memset(&buf, 0, sizeof(buf));
  ctu::cf::assign();
  std::string v132 = buf;
  memset(&buf, 0, sizeof(buf));
  ctu::cf::assign();
  std::string v131 = buf;
  CFDataRef v19 = *(Registry **)(a1 + 56);
  CFArrayRef v128 = 0;
  CFArrayRef v129 = 0;
  uint64_t v130 = 0;
  CFArrayRef theArray = 0;
  uint64_t v20 = (std::mutex *)Registry::getServiceMap(v19);
  CFDataRef v21 = v20;
  if ((v22 & 0x8000000000000000) != 0)
  {
    uint64_t v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v24 = 5381;
    do
    {
      std::string::size_type v22 = v24;
      unsigned int v25 = *v23++;
      uint64_t v24 = (33 * v24) ^ v25;
    }
    while (v25);
  }
  std::mutex::lock(v20);
  buf.__r_.__value_.__r.__words[0] = v22;
  CFArrayRef v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)&buf);
  if (!v26)
  {
    uint64_t v28 = 0;
    goto LABEL_28;
  }
  uint64_t v28 = v26[3];
  char v27 = (std::__shared_weak_count *)v26[4];
  if (!v27)
  {
LABEL_28:
    std::mutex::unlock(v21);
    char v27 = 0;
    char v29 = 1;
    goto LABEL_29;
  }
  atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v21);
  atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v27);
  char v29 = 0;
LABEL_29:
  (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v28 + 80))(&__str, v28, a2, 1, @"SupportedSIMs", 0, 0);
  sub_100044D6C(&theArray, (CFTypeRef *)&__str.__r_.__value_.__l.__data_);
  int v113 = a3;
  CFTypeRef v114 = a4;
  sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  if (theArray) {
    __int16 v32 = sub_100083F10;
  }
  else {
    __int16 v32 = 0;
  }
  if (v32)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    CFIndex v34 = Count;
    if (Count >= 1)
    {
      CFIndex v35 = 0;
      uint64_t __pos = qword_101B13EB0;
      if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v36 = &v133;
      }
      else {
        uint64_t v36 = (std::string *)v133.__r_.__value_.__r.__words[0];
      }
      if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int64_t size = HIBYTE(v133.__r_.__value_.__r.__words[2]);
      }
      else {
        int64_t size = v133.__r_.__value_.__l.__size_;
      }
      CFTypeID v38 = &v132;
      if ((v132.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        CFTypeID v38 = (std::string *)v132.__r_.__value_.__r.__words[0];
      }
      __s2 = v38;
      if ((v132.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int64_t v39 = HIBYTE(v132.__r_.__value_.__r.__words[2]);
      }
      else {
        int64_t v39 = v132.__r_.__value_.__l.__size_;
      }
      int v40 = &v131;
      if ((v131.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        int v40 = (std::string *)v131.__r_.__value_.__r.__words[0];
      }
      __int16 v117 = v40;
      if ((v131.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int64_t v41 = HIBYTE(v131.__r_.__value_.__r.__words[2]);
      }
      else {
        int64_t v41 = v131.__r_.__value_.__l.__size_;
      }
      CFIndex v116 = Count;
      do
      {
        memset(&__str, 0, sizeof(__str));
        CFArrayGetValueAtIndex(theArray, v35);
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string __str = buf;
        sub_1000292E0((uint64_t)&buf);
        int v42 = ctu::starts_with();
        int v44 = v42;
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(buf.__r_.__value_.__l.__data_);
          if (v44)
          {
LABEL_57:
            std::string::basic_string(&buf, &__str, __pos, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v125);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            std::string __str = buf;
          }
        }
        else if (v42)
        {
          goto LABEL_57;
        }
        char v45 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_str = &__str;
        }
        else {
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        if (size)
        {
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            int64_t v47 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          }
          else {
            int64_t v47 = __str.__r_.__value_.__l.__size_;
          }
          SCDynamicStoreRef v48 = (char *)p_str + v47;
          if (v47 >= size)
          {
            int v49 = v36->__r_.__value_.__s.__data_[0];
            int64_t v50 = v47;
            uint32_t v51 = p_str;
            do
            {
              int64_t v52 = v50 - size;
              size_t v43 = v52 + 1;
              if (v52 == -1) {
                break;
              }
              uint64_t v53 = (char *)memchr(v51, v49, v43);
              if (!v53) {
                break;
              }
              unsigned int v54 = v53;
              if (!memcmp(v53, v36, size))
              {
                if (v54 - (char *)p_str != -1 && v54 != v48 || v39 == 0) {
                  goto LABEL_123;
                }
                goto LABEL_69;
              }
              uint32_t v51 = (std::string *)(v54 + 1);
              int64_t v50 = v48 - (v54 + 1);
            }
            while (v50 >= size);
          }
          if (v39)
          {
LABEL_69:
            if (v47 >= v39)
            {
              int v55 = __s2->__r_.__value_.__s.__data_[0];
              int64_t v56 = v47;
              CFNumberRef v57 = p_str;
              do
              {
                int64_t v58 = v56 - v39;
                size_t v43 = v58 + 1;
                if (v58 == -1) {
                  break;
                }
                uint32_t v59 = (char *)memchr(v57, v55, v43);
                if (!v59) {
                  break;
                }
                BOOL v60 = v59;
                if (!memcmp(v59, __s2, v39))
                {
                  if (v60 - (char *)p_str != -1 && v60 != v48 || v41 == 0) {
                    goto LABEL_123;
                  }
                  goto LABEL_71;
                }
                CFNumberRef v57 = (std::string *)(v60 + 1);
                int64_t v56 = v48 - (v60 + 1);
              }
              while (v56 >= v39);
            }
            if (v41)
            {
LABEL_71:
              if (v47 >= v41)
              {
                int v61 = v117->__r_.__value_.__s.__data_[0];
                int64_t v62 = v47;
                char v63 = p_str;
                do
                {
                  int64_t v64 = v62 - v41;
                  size_t v43 = v64 + 1;
                  if (v64 == -1) {
                    break;
                  }
                  uint64_t v65 = (char *)memchr(v63, v61, v43);
                  if (!v65) {
                    break;
                  }
                  uint64_t v66 = v65;
                  if (!memcmp(v65, v117, v41))
                  {
                    if (v66 == v48 || v66 - (char *)p_str == -1) {
                      break;
                    }
                    goto LABEL_123;
                  }
                  char v63 = (std::string *)(v66 + 1);
                  int64_t v62 = v48 - (v66 + 1);
                }
                while (v62 >= v41);
              }
              if ((unint64_t)v47 < 4)
              {
                long long v67 = *(NSObject **)(*(uint64_t (**)(void, void, size_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2, v43);
                if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v68 = &__str;
                  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    uint64_t v68 = (std::string *)__str.__r_.__value_.__r.__words[0];
                  }
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v68;
                  _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "PLMN name length is less than 3? : %s", (uint8_t *)&buf, 0xCu);
                }
              }
              else
              {
                std::string::basic_string(&v125, &__str, 0, 3uLL, (std::allocator<char> *)&v124);
                std::string::basic_string(&v124, &__str, 3uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
                std::string buf = v125;
                memset(&v125, 0, sizeof(v125));
                std::string v137 = v124;
                memset(&v124, 0, sizeof(v124));
                sub_1002943D8(&v128, (long long *)&buf);
                if (SHIBYTE(v137.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v137.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(buf.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v124.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v124.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v125.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v125.__r_.__value_.__l.__data_);
                }
              }
            }
          }
LABEL_123:
          char v45 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          CFIndex v34 = v116;
        }
        if (v45 < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        ++v35;
      }
      while (v35 != v34);
    }
  }
  unsigned int v73 = v128;
  __int16 v74 = v129;
  if (v128 == v129)
  {
    char v75 = 0;
    goto LABEL_204;
  }
  memset(&__str, 0, sizeof(__str));
  memset(&v125, 0, sizeof(v125));
  memset(&v124, 0, sizeof(v124));
  char v75 = 1;
  do
  {
    std::string::size_type v76 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v76 = __str.__r_.__value_.__l.__size_;
    }
    if (!v76)
    {
      std::string::operator=(&__str, (const std::string *)v73);
      std::string::operator=(&v125, (const std::string *)v73 + 1);
      uint64_t v77 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
      uint64_t v78 = v77;
      if (v79 < 0)
      {
        uint64_t v80 = (unsigned __int8 *)(v79 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v81 = 5381;
        do
        {
          uint64_t v79 = v81;
          unsigned int v82 = *v80++;
          uint64_t v81 = (33 * v81) ^ v82;
        }
        while (v82);
      }
      std::mutex::lock(v77);
      std::string __p = (void *)v79;
      uint64_t v83 = sub_10004D37C(&v78[1].__m_.__sig, (unint64_t *)&__p);
      if (v83)
      {
        uint64_t v85 = v83[3];
        uint64_t v84 = (std::__shared_weak_count *)v83[4];
        if (v84)
        {
          atomic_fetch_add_explicit(&v84->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v78);
          atomic_fetch_add_explicit(&v84->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v84);
          char v86 = 0;
LABEL_140:
          (*(void (**)(std::string *__return_ptr, uint64_t, std::string *))(*(void *)v85 + 24))(&buf, v85, &__str);
          if (SHIBYTE(v124.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v124.__r_.__value_.__l.__data_);
          }
          std::string v124 = buf;
          *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
          buf.__r_.__value_.__s.__data_[0] = 0;
          if ((v86 & 1) == 0) {
            sub_10004D2C8(v84);
          }
          goto LABEL_144;
        }
      }
      else
      {
        uint64_t v85 = 0;
      }
      std::mutex::unlock(v78);
      uint64_t v84 = 0;
      char v86 = 1;
      goto LABEL_140;
    }
LABEL_144:
    std::string __p = 0;
    uint64_t v122 = 0;
    uint64_t v123 = 0;
    __int16 v87 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
    unsigned int v88 = v87;
    if ((v89 & 0x8000000000000000) != 0)
    {
      long long v90 = (unsigned __int8 *)(v89 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v91 = 5381;
      do
      {
        std::string::size_type v89 = v91;
        unsigned int v92 = *v90++;
        uint64_t v91 = (33 * v91) ^ v92;
      }
      while (v92);
    }
    std::mutex::lock(v87);
    buf.__r_.__value_.__r.__words[0] = v89;
    uint64_t v93 = sub_10004D37C(&v88[1].__m_.__sig, (unint64_t *)&buf);
    if (v93)
    {
      uint64_t v95 = v93[3];
      unsigned int v94 = (std::__shared_weak_count *)v93[4];
      if (v94)
      {
        atomic_fetch_add_explicit(&v94->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v88);
        atomic_fetch_add_explicit(&v94->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v94);
        char v96 = 0;
        goto LABEL_152;
      }
    }
    else
    {
      uint64_t v95 = 0;
    }
    std::mutex::unlock(v88);
    unsigned int v94 = 0;
    char v96 = 1;
LABEL_152:
    (*(void (**)(void **__return_ptr, uint64_t, char *))(*(void *)v95 + 24))(&__p, v95, v73);
    if ((v96 & 1) == 0) {
      sub_10004D2C8(v94);
    }
    uint64_t v97 = HIBYTE(v124.__r_.__value_.__r.__words[2]);
    if ((v124.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v98 = HIBYTE(v124.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v98 = v124.__r_.__value_.__l.__size_;
    }
    uint64_t v99 = HIBYTE(v123);
    if (v123 < 0) {
      uint64_t v99 = v122;
    }
    if (v98 == v99)
    {
      if (v123 >= 0) {
        p_p = (unsigned __int8 *)&__p;
      }
      else {
        p_p = (unsigned __int8 *)__p;
      }
      if ((*((unsigned char *)&v124.__r_.__value_.__s + 23) & 0x80) != 0)
      {
        if (!memcmp(v124.__r_.__value_.__l.__data_, p_p, v124.__r_.__value_.__l.__size_))
        {
LABEL_172:
          char v103 = 0;
          goto LABEL_173;
        }
      }
      else
      {
        if (!*((unsigned char *)&v124.__r_.__value_.__s + 23)) {
          goto LABEL_172;
        }
        CFArrayRef v101 = &v124;
        while (v101->__r_.__value_.__s.__data_[0] == *p_p)
        {
          CFArrayRef v101 = (std::string *)((char *)v101 + 1);
          ++p_p;
          if (!--v97) {
            goto LABEL_172;
          }
        }
      }
    }
    CFTypeID v102 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
    {
      std::string::size_type v105 = (std::string::size_type)v73;
      if (v73[23] < 0) {
        std::string::size_type v105 = *(void *)v73;
      }
      CFTypeRef v106 = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        CFTypeRef v106 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      uint64_t v107 = &__p;
      if (v123 < 0) {
        uint64_t v107 = __p;
      }
      CFTypeID v108 = &v124;
      if ((v124.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        CFTypeID v108 = (std::string *)v124.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v105;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v106;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      v137.__r_.__value_.__r.__words[0] = (std::string::size_type)v107;
      LOWORD(v137.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v137.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v108;
      _os_log_error_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_ERROR, "There is mismatch in the MCCs (%s, %s), ISOs (%s, %s)", (uint8_t *)&buf, 0x2Au);
    }
    char v75 = 0;
    char v103 = 1;
LABEL_173:
    if (SHIBYTE(v123) < 0) {
      operator delete(__p);
    }
    v73 += 48;
    if (v73 == v74) {
      char v104 = 1;
    }
    else {
      char v104 = v103;
    }
  }
  while ((v104 & 1) == 0);
  if (v75)
  {
    CFDictionaryRef v109 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
    {
      int v110 = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        int v110 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      uint64_t v111 = &v125;
      if ((v125.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v111 = (std::string *)v125.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v110;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v111;
      _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "#I Found subscriber's MCC %s, MNC %s from bundle", (uint8_t *)&buf, 0x16u);
    }
    std::string::operator=(v113, &__str);
    std::string::operator=(v114, &v125);
  }
  if (SHIBYTE(v124.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v124.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v125.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v125.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
LABEL_204:
  sub_100044D00((const void **)&theArray);
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v128;
  sub_100155410((void ***)&buf);
  if (SHIBYTE(v131.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v131.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v132.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v133.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v134.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v134.__r_.__value_.__l.__data_);
  }
  uint64_t v31 = v75 & 1;
LABEL_213:
  sub_1000558F4(&v135);
  return v31;
}

void sub_1002941D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,__int16 *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,const void *a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  sub_100044D00(&a47);
  a40 = &a48;
  sub_100155410((void ***)&a40);
  if (a58 < 0) {
    operator delete(a53);
  }
  if (*(char *)(v58 - 233) < 0) {
    operator delete(*(void **)(v58 - 256));
  }
  if (*(char *)(v58 - 201) < 0) {
    operator delete(*(void **)(v58 - 224));
  }
  if (*(char *)(v58 - 169) < 0) {
    operator delete(*(void **)(v58 - 192));
  }
  sub_1000558F4((const void **)(v58 - 168));
  _Unwind_Resume(a1);
}

uint64_t sub_1002943D8(char **a1, long long *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(result - 8);
  if (v7 >= v6)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (void)*a1) >> 4);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555) {
      sub_10006A748();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)*a1) >> 4);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v14 = 0x555555555555555;
    }
    else {
      unint64_t v14 = v12;
    }
    uint64_t v29 = result;
    if (v14) {
      char v15 = (char *)sub_10019F624(result, v14);
    }
    else {
      char v15 = 0;
    }
    char v16 = &v15[48 * v11];
    long long v17 = *a2;
    *((void *)v16 + 2) = *((void *)a2 + 2);
    *(_OWORD *)char v16 = v17;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v18 = *(long long *)((char *)a2 + 24);
    *((void *)v16 + 5) = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = v18;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    uint64_t v20 = *a1;
    unint64_t v19 = (unint64_t)a1[1];
    if ((char *)v19 == *a1)
    {
      int64x2_t v24 = vdupq_n_s64(v19);
      CFDataRef v21 = &v15[48 * v11];
    }
    else
    {
      CFDataRef v21 = &v15[48 * v11];
      do
      {
        long long v22 = *(_OWORD *)(v19 - 48);
        *((void *)v21 - 4) = *(void *)(v19 - 32);
        *((_OWORD *)v21 - 3) = v22;
        *(void *)(v19 - 40) = 0;
        *(void *)(v19 - 32) = 0;
        *(void *)(v19 - 48) = 0;
        long long v23 = *(_OWORD *)(v19 - 24);
        *((void *)v21 - 1) = *(void *)(v19 - 8);
        *(_OWORD *)(v21 - 24) = v23;
        v21 -= 48;
        *(void *)(v19 - 16) = 0;
        *(void *)(v19 - 8) = 0;
        *(void *)(v19 - 24) = 0;
        v19 -= 48;
      }
      while ((char *)v19 != v20);
      int64x2_t v24 = *(int64x2_t *)a1;
    }
    uint64_t v10 = v16 + 48;
    *a1 = v21;
    a1[1] = v16 + 48;
    int64x2_t v27 = v24;
    unsigned int v25 = a1[2];
    a1[2] = &v15[48 * v14];
    uint64_t v28 = v25;
    uint64_t v26 = v24.i64[0];
    uint64_t result = sub_100296F50((uint64_t)&v26);
  }
  else
  {
    long long v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v9 = *(long long *)((char *)a2 + 24);
    *(void *)(v7 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    uint64_t v10 = (char *)(v7 + 48);
  }
  a1[1] = v10;
  return result;
}

void *sub_100294590(void *a1, long long *a2)
{
  uint64_t v4 = *a1;
  if (*(char *)(*a1 + 23) < 0) {
    operator delete(*(void **)v4);
  }
  long long v5 = *a2;
  *(void *)(v4 + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v4 = v5;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  uint64_t v6 = a1[1];
  if (*(char *)(v6 + 23) < 0) {
    operator delete(*(void **)v6);
  }
  long long v7 = *(long long *)((char *)a2 + 24);
  *(void *)(v6 + 16) = *((void *)a2 + 5);
  *(_OWORD *)uint64_t v6 = v7;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  return a1;
}

const void **sub_100294618(const void **result)
{
  uint64_t v1 = (const void **)result[24];
  uint64_t v2 = result + 25;
  if (v1 != result + 25)
  {
    uint64_t v3 = (uint64_t)result;
    do
    {
      uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *((unsigned int *)v1 + 8));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = asString();
        uint64_t v6 = asString();
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v5;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Handle carrier bundle setup for %s (%s)", buf, 0x16u);
      }
      memset(buf, 0, sizeof(buf));
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v3 + 72) + 200))(buf);
      uint64_t v7 = *((unsigned int *)v1 + 8);
      char v8 = *((unsigned char *)v1 + 41);
      char v9 = *((unsigned char *)v1 + 40);
      unint64_t v13 = *(const void **)&buf[8];
      if (*(void *)&buf[8]) {
        CFRetain(*(CFTypeRef *)&buf[8]);
      }
      sub_100294848(v3, v7, v8, v9, &v13);
      sub_100057D78(&v13);
      sub_100057D78((const void **)&buf[16]);
      uint64_t result = sub_100057D78((const void **)&buf[8]);
      uint64_t v10 = (const void **)v1[1];
      if (v10)
      {
        do
        {
          unint64_t v11 = v10;
          uint64_t v10 = (const void **)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          unint64_t v11 = (const void **)v1[2];
          BOOL v12 = *v11 == v1;
          uint64_t v1 = v11;
        }
        while (!v12);
      }
      uint64_t v1 = v11;
    }
    while (v11 != v2);
  }
  return result;
}

void sub_10029480C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100294848(uint64_t a1, uint64_t a2, int a3, uint64_t a4, const void **a5)
{
  unsigned int v97 = a2;
  if (a3 != 2)
  {
    if (a3 == 1)
    {
      char v9 = *(void **)(a1 + 144);
      if (v9 != (void *)(a1 + 152))
      {
        do
        {
          if (*((_DWORD *)v9 + 8) == a2) {
            break;
          }
          uint64_t v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              unint64_t v11 = v10;
              uint64_t v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              unint64_t v11 = (void *)v9[2];
              BOOL v12 = *v11 == (void)v9;
              char v9 = v11;
            }
            while (!v12);
          }
          char v9 = v11;
        }
        while (v11 != (void *)(a1 + 152));
      }
      if (subscriber::isSimReady()) {
        goto LABEL_17;
      }
      unint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = asString();
      char v15 = "#I SIM is not ready, waiting to process %s until it is";
    }
    else
    {
      unint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = asString();
      char v15 = "#I Ignoring bundle setup for unknown technology type: %s";
    }
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)buf, 0xCu);
    return;
  }
  unint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = asString();
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Ignoring SIM state since bundle type is not SIM based (%s)", (uint8_t *)buf, 0xCu);
  }
LABEL_17:
  uint64_t v16 = *(void *)(a1 + 128);
  memset(&v96, 0, sizeof(v96));
  if (v16)
  {
    uint64_t v17 = a1 + 128;
    do
    {
      int v18 = *(_DWORD *)(v16 + 32);
      BOOL v19 = v18 < (int)a2;
      if (v18 >= (int)a2) {
        uint64_t v20 = (uint64_t *)v16;
      }
      else {
        uint64_t v20 = (uint64_t *)(v16 + 8);
      }
      if (!v19) {
        uint64_t v17 = v16;
      }
      uint64_t v16 = *v20;
    }
    while (*v20);
    if (v17 != a1 + 128 && *(_DWORD *)(v17 + 32) <= (int)a2)
    {
      CFDataRef v21 = sub_1002992E4((uint64_t **)(a1 + 120), a2, &v97);
      std::string::operator=(&v96, (const std::string *)(v21 + 5));
    }
  }
  uint64_t v106 = 0;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v103 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_100058198((const void **)&theDict, a5);
  long long v22 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s Carrier bundle setup event received, refreshing MCC, MNC and Last known MCC values", (uint8_t *)&__dst, 0xCu);
  }
  if (theDict) {
    long long v23 = sub_100080778;
  }
  else {
    long long v23 = 0;
  }
  if (!v23)
  {
    uint64_t v28 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_127;
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
    uint64_t v29 = "#N %s Matching info is not present";
    goto LABEL_125;
  }
  if (v106 != a3)
  {
    int64x2_t v24 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = asString();
      uint64_t v26 = asString();
      LODWORD(__dst.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
      WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = v25;
      HIWORD(__dst.__r_.__value_.__r.__words[2]) = 2080;
      *(void *)CFTypeID v108 = v26;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s Bundle type is changing from %s to %s", (uint8_t *)&__dst, 0x20u);
    }
    LOBYTE(v106) = a3;
  }
  if (a3 != 1)
  {
    memset(__str, 0, 24);
    CFDictionaryGetValue(theDict, (const void *)qword_101B13ED0);
    memset(&__dst, 0, sizeof(__dst));
    ctu::cf::assign();
    *(std::string *)std::string __str = __dst;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      unint64_t v27 = *(void *)&__str[8];
      if (!*(void *)&__str[8]) {
        goto LABEL_70;
      }
    }
    else
    {
      unint64_t v27 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      if (!*((unsigned char *)&__dst.__r_.__value_.__s + 23)) {
        goto LABEL_70;
      }
    }
    if (v27 > 3)
    {
      std::string::basic_string(&__dst, (const std::string *)__str, 0, 3uLL, (std::allocator<char> *)&v98);
      if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf[0].__r_.__value_.__l.__data_);
      }
      buf[0] = __dst;
      std::string::basic_string(&__dst, (const std::string *)__str, 3uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v98);
      if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf[1].__r_.__value_.__l.__data_);
      }
      buf[1] = __dst;
      goto LABEL_79;
    }
LABEL_70:
    uint64_t v37 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeID v38 = __str;
      if (__str[23] < 0) {
        CFTypeID v38 = *(unsigned char **)__str;
      }
      LODWORD(__dst.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
      WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v38;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#N %s Carrier ID received from Activation Info (%s) is invalid", (uint8_t *)&__dst, 0x16u);
    }
LABEL_79:
    if ((__str[23] & 0x80000000) != 0) {
      operator delete(*(void **)__str);
    }
    goto LABEL_81;
  }
  v98.__r_.__value_.__r.__words[0] = 0;
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)CFDictionaryGetValue(theDict, (const void *)qword_101B13EC0);
  sub_100056248(&v98, (CFTypeRef *)&__dst.__r_.__value_.__l.__data_);
  if (v98.__r_.__value_.__r.__words[0]) {
    uint64_t v30 = sub_1000810B8;
  }
  else {
    uint64_t v30 = 0;
  }
  if (v30)
  {
    sub_100E63D1C((const __CFString *)v98.__r_.__value_.__l.__data_, (uint64_t)&__dst);
    *(void *)std::string __str = buf;
    *(void *)&__str[8] = &buf[1];
    sub_100294590(__str, (long long *)&__dst);
    if ((v108[23] & 0x80000000) != 0) {
      operator delete(*(void **)v108);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  std::string::size_type size = HIBYTE(buf[0].__r_.__value_.__r.__words[2]);
  if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = buf[0].__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    CFDictionaryGetValue(theDict, @"MCC");
    memset(&__dst, 0, sizeof(__dst));
    ctu::cf::assign();
    *(void *)std::string __str = __dst.__r_.__value_.__l.__size_;
    std::string::size_type v32 = __dst.__r_.__value_.__r.__words[0];
    *(void *)&__str[7] = *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 7);
    char v33 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    buf[0].__r_.__value_.__r.__words[0] = v32;
    buf[0].__r_.__value_.__l.__size_ = *(void *)__str;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 7) = *(void *)&__str[7];
    *((unsigned char *)&buf[0].__r_.__value_.__s + 23) = v33;
  }
  std::string::size_type v34 = HIBYTE(buf[1].__r_.__value_.__r.__words[2]);
  if ((buf[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v34 = buf[1].__r_.__value_.__l.__size_;
  }
  if (!v34)
  {
    CFDictionaryGetValue(theDict, @"MNC");
    memset(&__dst, 0, sizeof(__dst));
    ctu::cf::assign();
    *(void *)std::string __str = __dst.__r_.__value_.__l.__size_;
    std::string::size_type v35 = __dst.__r_.__value_.__r.__words[0];
    *(void *)&__str[7] = *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 7);
    char v36 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[1].__r_.__value_.__l.__data_);
    }
    buf[1].__r_.__value_.__r.__words[0] = v35;
    buf[1].__r_.__value_.__l.__size_ = *(void *)__str;
    *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[1] + 7) = *(void *)&__str[7];
    *((unsigned char *)&buf[1].__r_.__value_.__s + 23) = v36;
  }
  sub_1000558F4((const void **)&v98.__r_.__value_.__l.__data_);
LABEL_81:
  std::string::operator=((std::string *)&v103, buf);
  int64_t v39 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
  {
    int v40 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v40 = buf;
    }
    if ((SBYTE7(v104) & 0x80u) == 0) {
      int64_t v41 = &v103;
    }
    else {
      int64_t v41 = (long long *)v103;
    }
    std::string::pointer data = &buf[1];
    if ((buf[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::pointer data = (std::string *)buf[1].__r_.__value_.__l.__data_;
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315906;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
    WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v40;
    HIWORD(__dst.__r_.__value_.__r.__words[2]) = 2080;
    *(void *)CFTypeID v108 = v41;
    *(_WORD *)&v108[8] = 2080;
    *(void *)&v108[10] = data;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s Activation info provided Subscriber MCC: %s, Last known MCC: %s, MNC: %s", (uint8_t *)&__dst, 0x2Au);
  }
  std::string::size_type v43 = HIBYTE(buf[0].__r_.__value_.__r.__words[2]);
  if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v43 = buf[0].__r_.__value_.__l.__size_;
  }
  if (!v43) {
    goto LABEL_111;
  }
  std::string::size_type v44 = HIBYTE(buf[1].__r_.__value_.__r.__words[2]);
  if ((buf[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v44 = buf[1].__r_.__value_.__l.__size_;
  }
  if (!v44)
  {
LABEL_111:
    uint64_t v28 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_127;
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
    uint64_t v29 = "#N %s Did not find MCC or MNC from subscriber";
    goto LABEL_125;
  }
  std::string::operator=((std::string *)((char *)&v104 + 8), &buf[1]);
  sub_100058198(&v99, (const void **)&theDict);
  BOOL v45 = sub_1004D4A44((const __CFDictionary **)&v99);
  sub_100057D78(&v99);
  if (!v45)
  {
    uint64_t v52 = *(void *)(a1 + 224);
    if (!v52) {
      goto LABEL_123;
    }
    uint64_t v53 = a1 + 224;
    do
    {
      int v54 = *(_DWORD *)(v52 + 28);
      BOOL v55 = v54 < (int)a2;
      if (v54 >= (int)a2) {
        int64_t v56 = (uint64_t *)v52;
      }
      else {
        int64_t v56 = (uint64_t *)(v52 + 8);
      }
      if (!v55) {
        uint64_t v53 = v52;
      }
      uint64_t v52 = *v56;
    }
    while (*v56);
    if (v53 == a1 + 224 || *(_DWORD *)(v53 + 28) > (int)a2)
    {
LABEL_123:
      uint64_t v28 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_127;
      }
      LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
      uint64_t v29 = "#I %s No valid roaming result, leaving extracted MCC";
      goto LABEL_125;
    }
    if (*(_DWORD *)(v53 + 32) != 4)
    {
      uint64_t v79 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (!os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_127;
      }
      uint64_t v80 = asString();
      LODWORD(__dst.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
      WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = v80;
      uint64_t v29 = "#I %s Not roaming (%s), leaving extracted MCC alone";
      goto LABEL_204;
    }
LABEL_188:
    if (a3 == 1)
    {
      memset(__str, 0, 24);
      memset(&v98, 0, sizeof(v98));
      if (sub_1002933D4(a1, a2, (std::string *)__str, &v98))
      {
        BOOL v83 = sub_10001D294(__str, (unsigned __int8 *)buf);
        uint64_t v84 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 16);
        if (v83)
        {
          uint64_t v85 = *(NSObject **)v84();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
          {
            char v86 = __str;
            if (__str[23] < 0) {
              char v86 = *(unsigned char **)__str;
            }
            __int16 v87 = buf;
            if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              __int16 v87 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
            }
            if (v105 >= 0) {
              unsigned int v88 = (char *)&v104 + 8;
            }
            else {
              unsigned int v88 = (char *)*((void *)&v104 + 1);
            }
            LODWORD(__dst.__r_.__value_.__l.__data_) = 136315906;
            *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
            WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v86;
            HIWORD(__dst.__r_.__value_.__r.__words[2]) = 2080;
            *(void *)CFTypeID v108 = v87;
            *(_WORD *)&v108[8] = 2080;
            *(void *)&v108[10] = v88;
            _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I %s Extracted MCC %s matches SIM MCC %s, leaving MNC at %s", (uint8_t *)&__dst, 0x2Au);
          }
        }
        else
        {
          long long v90 = *(NSObject **)v84();
          if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v91 = __str;
            if (__str[23] < 0) {
              uint64_t v91 = *(unsigned char **)__str;
            }
            unsigned int v92 = buf;
            if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              unsigned int v92 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
            }
            if (v105 >= 0) {
              uint64_t v93 = (char *)&v104 + 8;
            }
            else {
              uint64_t v93 = (char *)*((void *)&v104 + 1);
            }
            unsigned int v94 = &v98;
            if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              unsigned int v94 = (std::string *)v98.__r_.__value_.__r.__words[0];
            }
            LODWORD(__dst.__r_.__value_.__l.__data_) = 136316162;
            *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
            WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v91;
            HIWORD(__dst.__r_.__value_.__r.__words[2]) = 2080;
            *(void *)CFTypeID v108 = v92;
            *(_WORD *)&v108[8] = 2080;
            *(void *)&v108[10] = v93;
            *(_WORD *)&v108[18] = 2080;
            *(void *)&v108[20] = v94;
            _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#N %s Extracted MCC %s is not matching %s. Setting Extracted MNC from %s to %s", (uint8_t *)&__dst, 0x34u);
          }
          std::string::operator=(buf, (const std::string *)__str);
          std::string::operator=((std::string *)&v103, buf);
          std::string::operator=((std::string *)((char *)&v104 + 8), &v98);
        }
      }
      if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v98.__r_.__value_.__l.__data_);
      }
      if ((__str[23] & 0x80000000) != 0) {
        operator delete(*(void **)__str);
      }
      goto LABEL_127;
    }
    uint64_t v79 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_127;
    }
    uint64_t v89 = asString();
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
    WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = v89;
    uint64_t v29 = "#N %s Bundle type is not SIM based (%s)";
LABEL_204:
    CFNumberRef v57 = v79;
    uint32_t v58 = 22;
    goto LABEL_126;
  }
  uint64_t v46 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#N %s Using visible MCCs instead of roaming result", (uint8_t *)&__dst, 0xCu);
  }
  uint64_t v47 = *(void *)(a1 + 280);
  if (!v47) {
    goto LABEL_109;
  }
  uint64_t v48 = a1 + 280;
  do
  {
    int v49 = *(_DWORD *)(v47 + 32);
    BOOL v50 = v49 < (int)a2;
    if (v49 >= (int)a2) {
      uint32_t v51 = (uint64_t *)v47;
    }
    else {
      uint32_t v51 = (uint64_t *)(v47 + 8);
    }
    if (!v50) {
      uint64_t v48 = v47;
    }
    uint64_t v47 = *v51;
  }
  while (*v51);
  if (v48 == a1 + 280 || *(_DWORD *)(v48 + 32) > (int)a2)
  {
LABEL_109:
    uint64_t v28 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_127;
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
    uint64_t v29 = "#I %s Last visible MCC not known, leaving extracted MCC";
    goto LABEL_125;
  }
  uint64_t v81 = (MCC *)(v48 + 40);
  if (MCC::valid((MCC *)(v48 + 40)))
  {
    MCC::getStringValue((uint64_t *)&__dst, v81);
    BOOL v82 = sub_10001D294((unsigned __int8 *)&__dst, (unsigned __int8 *)buf);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (v82)
    {
      uint64_t v28 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
        uint64_t v29 = "#I %s MCCs match, leaving extracted MCC";
LABEL_125:
        CFNumberRef v57 = v28;
        uint32_t v58 = 12;
LABEL_126:
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, v29, (uint8_t *)&__dst, v58);
        goto LABEL_127;
      }
      goto LABEL_127;
    }
    goto LABEL_188;
  }
  uint64_t v28 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)"[home]";
    uint64_t v29 = "#I %s Visible MCC invalid, leaving extracted MCC";
    goto LABEL_125;
  }
LABEL_127:
  sub_100057D78((const void **)&theDict);
  uint64_t v59 = v97;
  BOOL v60 = sub_1002992E4((uint64_t **)(a1 + 120), v97, &v97);
  std::string::operator=((std::string *)(v60 + 5), buf);
  std::string::operator=((std::string *)(v60 + 8), &buf[1]);
  std::string::operator=((std::string *)(v60 + 11), (const std::string *)&v103);
  std::string::operator=((std::string *)(v60 + 14), (const std::string *)((char *)&v104 + 8));
  *((unsigned char *)v60 + 136) = v106;
  v98.__r_.__value_.__r.__words[0] = 1;
  v98.__r_.__value_.__l.__size_ = a1 + 296;
  if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, buf[0].__r_.__value_.__l.__data_, buf[0].__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = buf[0];
  }
  if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(v108, buf[1].__r_.__value_.__l.__data_, buf[1].__r_.__value_.__l.__size_);
  }
  else {
    *(std::string *)CFTypeID v108 = buf[1];
  }
  int v61 = sub_100299430((uint64_t **)(v98.__r_.__value_.__l.__size_ + 32), v59, &v97);
  int64_t v62 = (void **)(v61 + 5);
  if (*((char *)v61 + 63) < 0) {
    operator delete(*v62);
  }
  v61[7] = (uint64_t *)__dst.__r_.__value_.__r.__words[2];
  *(_OWORD *)int64_t v62 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
  __dst.__r_.__value_.__s.__data_[0] = 0;
  char v63 = (void **)(v61 + 8);
  if (*((char *)v61 + 87) < 0)
  {
    operator delete(*v63);
    int v64 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
    *(_OWORD *)char v63 = *(_OWORD *)v108;
    v61[10] = *(uint64_t **)&v108[16];
    v108[23] = 0;
    v108[0] = 0;
    if (v64 < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    *(_OWORD *)char v63 = *(_OWORD *)v108;
    v61[10] = *(uint64_t **)&v108[16];
  }
  uint64_t v65 = sub_1002992E4((uint64_t **)(a1 + 120), v59, &v97);
  uint64_t v66 = HIBYTE(v96.__r_.__value_.__r.__words[2]);
  if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v67 = HIBYTE(v96.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v67 = v96.__r_.__value_.__l.__size_;
  }
  uint64_t v68 = (uint64_t *)*((unsigned __int8 *)v65 + 63);
  int v69 = (char)v68;
  if ((char)v68 < 0) {
    uint64_t v68 = v65[6];
  }
  if ((uint64_t *)v67 != v68) {
    goto LABEL_155;
  }
  long long v72 = v65[5];
  unsigned int v70 = v65 + 5;
  long long v71 = v72;
  if (v69 >= 0) {
    unsigned int v73 = v70;
  }
  else {
    unsigned int v73 = (uint64_t **)v71;
  }
  if ((*((unsigned char *)&v96.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    if (!memcmp(v96.__r_.__value_.__l.__data_, v73, v96.__r_.__value_.__l.__size_)) {
      goto LABEL_156;
    }
LABEL_155:
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 104) + 72))(*(void *)(a1 + 104), v59);
    goto LABEL_156;
  }
  if (*((unsigned char *)&v96.__r_.__value_.__s + 23))
  {
    __int16 v74 = &v96;
    while (v74->__r_.__value_.__s.__data_[0] == *(unsigned __int8 *)v73)
    {
      __int16 v74 = (std::string *)((char *)v74 + 1);
      unsigned int v73 = (uint64_t **)((char *)v73 + 1);
      if (!--v66) {
        goto LABEL_156;
      }
    }
    goto LABEL_155;
  }
LABEL_156:
  *(void *)std::string __str = 1;
  *(_OWORD *)&char __str[16] = 0u;
  uint64_t v101 = 0;
  *(void *)&__str[8] = a1 + 352;
  sub_10029950C((uint64_t)&__str[16], (void *)(a1 + 384));
  if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, buf[0].__r_.__value_.__l.__data_, buf[0].__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = buf[0];
  }
  if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(v108, buf[1].__r_.__value_.__l.__data_, buf[1].__r_.__value_.__l.__size_);
  }
  else {
    *(std::string *)CFTypeID v108 = buf[1];
  }
  char v75 = sub_100299430((uint64_t **)&__str[16], v59, &v97);
  std::string::size_type v76 = (void **)(v75 + 5);
  if (*((char *)v75 + 63) < 0) {
    operator delete(*v76);
  }
  v75[7] = (uint64_t *)__dst.__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string::size_type v76 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
  __dst.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v77 = (void **)(v75 + 8);
  if (*((char *)v75 + 87) < 0)
  {
    operator delete(*v77);
    int v78 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
    *(_OWORD *)uint64_t v77 = *(_OWORD *)v108;
    v75[10] = *(uint64_t **)&v108[16];
    v108[23] = 0;
    v108[0] = 0;
    if (v78 < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v77 = *(_OWORD *)v108;
    v75[10] = *(uint64_t **)&v108[16];
  }
  sub_100299748((uint64_t)__str);
  sub_1002993CC((uint64_t)&v98);
  if (SHIBYTE(v105) < 0) {
    operator delete(*((void **)&v104 + 1));
  }
  if (SBYTE7(v104) < 0) {
    operator delete((void *)v103);
  }
  if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf[1].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf[0].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v96.__r_.__value_.__l.__data_);
  }
}

void sub_100295C40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  sub_100057D78(&a10);
  sub_100169704((uint64_t)&a34);
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(a1);
}

void sub_100295D8C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 144);
  int v49 = (void *)(a1 + 152);
  if (v2 != (void *)(a1 + 152))
  {
    uint64_t v4 = (void *)(a2 + 8);
    uint64_t v48 = (void *)(a1 + 128);
    uint64_t v46 = a1 + 328;
    uint64_t v47 = a1 + 296;
    uint64_t v45 = a1 + 352;
    std::string::size_type v44 = (void *)(a1 + 384);
    while (1)
    {
      uint64_t v5 = *v4;
      if (!*v4) {
        goto LABEL_14;
      }
      uint64_t v6 = *((unsigned int *)v2 + 8);
      uint64_t v7 = v4;
      do
      {
        int v8 = *(_DWORD *)(v5 + 32);
        BOOL v9 = v8 < (int)v6;
        if (v8 >= (int)v6) {
          uint64_t v10 = (uint64_t *)v5;
        }
        else {
          uint64_t v10 = (uint64_t *)(v5 + 8);
        }
        if (!v9) {
          uint64_t v7 = (void *)v5;
        }
        uint64_t v5 = *v10;
      }
      while (*v10);
      if (v7 != v4 && (int)v6 >= *((_DWORD *)v7 + 8)) {
        break;
      }
LABEL_15:
      int v52 = v6;
      unint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = subscriber::asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Handle SIM state update, %s", buf, 0xCu);
      }
      if (subscriber::isSimReady())
      {
        memset(buf, 0, sizeof(buf));
        *(void *)&long long v57 = 0;
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 72) + 200))(buf);
        unint64_t v13 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 16);
        if (buf[0] == 1)
        {
          unint64_t v14 = *(NSObject **)v13();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v53 = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I SIM status has become ready", v53, 2u);
          }
          *(void *)uint64_t v53 = *(void *)&buf[8];
          if (*(void *)&buf[8]) {
            CFRetain(*(CFTypeRef *)&buf[8]);
          }
          sub_100294848(a1, v6, 1, 0, (const void **)v53);
          sub_100057D78((const void **)v53);
        }
        else
        {
          long long v22 = *(NSObject **)v13();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v23 = asString();
            *(_DWORD *)uint64_t v53 = 136315138;
            *(void *)&v53[4] = v23;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Ignoring SIM ready while %s is not SIM based", v53, 0xCu);
          }
        }
        sub_100057D78((const void **)&v57);
        sub_100057D78((const void **)&buf[8]);
      }
      else
      {
        uint64_t v15 = *v48;
        if (*v48)
        {
          uint64_t v16 = v48;
          do
          {
            int v17 = *(_DWORD *)(v15 + 32);
            BOOL v18 = v17 < (int)v6;
            if (v17 >= (int)v6) {
              BOOL v19 = (uint64_t *)v15;
            }
            else {
              BOOL v19 = (uint64_t *)(v15 + 8);
            }
            if (!v18) {
              uint64_t v16 = (void *)v15;
            }
            uint64_t v15 = *v19;
          }
          while (*v19);
          if (v16 != v48 && *((_DWORD *)v16 + 8) <= (int)v6)
          {
            if (*((unsigned char *)v16 + 136) != 1)
            {
              uint64_t v28 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v29 = asString();
                *(_DWORD *)std::string buf = 136315138;
                *(void *)&uint8_t buf[4] = v29;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Ignoring SIM state while bundle type (%s) is not SIM based", buf, 0xCu);
              }
              goto LABEL_39;
            }
            unint64_t v27 = v16 + 5;
            __s1[0] = 0;
            __s1[1] = 0;
            uint64_t v51 = 0;
            if (*((char *)v16 + 63) < 0)
            {
              sub_10004FC84(__s1, (void *)v16[5], v16[6]);
            }
            else
            {
              *(_OWORD *)std::string __s1 = *v27;
              uint64_t v51 = v16[7];
            }
            uint64_t v30 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Resetting MCC and MNC as the SIM is not ready, and bundle is SIM based", buf, 2u);
            }
            if (*((char *)v16 + 63) < 0)
            {
              *(unsigned char *)v16[5] = 0;
              v16[6] = 0;
            }
            else
            {
              *((unsigned char *)v16 + 40) = 0;
              *((unsigned char *)v16 + 63) = 0;
            }
            if (*((char *)v16 + 87) < 0)
            {
              *(unsigned char *)v16[8] = 0;
              v16[9] = 0;
            }
            else
            {
              *((unsigned char *)v16 + 64) = 0;
              *((unsigned char *)v16 + 87) = 0;
            }
            if (*((char *)v16 + 135) < 0)
            {
              *(unsigned char *)v16[14] = 0;
              v16[15] = 0;
            }
            else
            {
              *((unsigned char *)v16 + 112) = 0;
              *((unsigned char *)v16 + 135) = 0;
            }
            *(void *)std::string buf = 1;
            long long v57 = 0u;
            uint64_t v58 = 0;
            *(void *)&uint8_t buf[8] = v47;
            sub_1002998C4((uint64_t *)&v57, v46);
            uint64_t v31 = sub_100299430((uint64_t **)&v57, v6, &v52);
            std::string::size_type v32 = (void **)(v31 + 5);
            if (*((char *)v31 + 63) < 0) {
              operator delete(*v32);
            }
            char v33 = (void **)(v31 + 8);
            const void *v32 = 0;
            v31[6] = 0;
            v31[7] = 0;
            if (*((char *)v31 + 87) < 0) {
              operator delete(*v33);
            }
            ifaddrs *v33 = 0;
            v31[9] = 0;
            v31[10] = 0;
            uint64_t v34 = HIBYTE(v51);
            std::string::size_type v35 = (void *)v16[6];
            int v36 = *((char *)v16 + 63);
            if (v51 >= 0) {
              uint64_t v37 = (void *)HIBYTE(v51);
            }
            else {
              uint64_t v37 = __s1[1];
            }
            if (v36 >= 0) {
              std::string::size_type v35 = (void *)*((unsigned __int8 *)v16 + 63);
            }
            if (v37 == v35)
            {
              if (v36 >= 0) {
                CFTypeID v38 = (unsigned __int8 *)(v16 + 5);
              }
              else {
                CFTypeID v38 = *(unsigned __int8 **)v27;
              }
              if (v51 < 0)
              {
                if (memcmp(__s1[0], v38, (size_t)__s1[1])) {
                  goto LABEL_83;
                }
              }
              else if (HIBYTE(v51))
              {
                int64_t v39 = __s1;
                while (*(unsigned __int8 *)v39 == *v38)
                {
                  int64_t v39 = (void **)((char *)v39 + 1);
                  ++v38;
                  if (!--v34) {
                    goto LABEL_84;
                  }
                }
                goto LABEL_83;
              }
            }
            else
            {
LABEL_83:
              (*(void (**)(void, uint64_t))(**(void **)(a1 + 104) + 72))(*(void *)(a1 + 104), v6);
            }
LABEL_84:
            if (subscriber::isSimAbsent())
            {
              *(void *)uint64_t v53 = 1;
              long long v54 = 0u;
              uint64_t v55 = 0;
              *(void *)&char v53[8] = v45;
              int v40 = (uint64_t **)sub_10029950C((uint64_t)&v54, v44);
              int64_t v41 = sub_100299430(v40, v6, &v52);
              int v42 = (void **)(v41 + 5);
              if (*((char *)v41 + 63) < 0) {
                operator delete(*v42);
              }
              std::string::size_type v43 = (void **)(v41 + 8);
              *int v42 = 0;
              v41[6] = 0;
              v41[7] = 0;
              if (*((char *)v41 + 87) < 0) {
                operator delete(*v43);
              }
              *std::string::size_type v43 = 0;
              v41[9] = 0;
              v41[10] = 0;
              sub_100299748((uint64_t)v53);
            }
            sub_100299B70((uint64_t)buf);
            if (SHIBYTE(v51) < 0) {
              operator delete(__s1[0]);
            }
            goto LABEL_39;
          }
        }
        uint64_t v20 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          uint64_t v21 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v21;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid Sim Slot %s", buf, 0xCu);
        }
      }
LABEL_39:
      int64x2_t v24 = (void *)v2[1];
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          int64x2_t v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (void *)v2[2];
          BOOL v26 = *v25 == (void)v2;
          uint64_t v2 = v25;
        }
        while (!v26);
      }
      uint64_t v2 = v25;
      if (v25 == v49) {
        return;
      }
    }
    if (BasicSimInfo::operator==()) {
      goto LABEL_39;
    }
LABEL_14:
    uint64_t v6 = *((unsigned int *)v2 + 8);
    goto LABEL_15;
  }
}

void sub_100296498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,char a28)
{
  sub_100299748((uint64_t)&a28);
  sub_100299B70(v28 - 144);
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100296528(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100299CEC;
  void v7[3] = &unk_1019B3228;
  void v7[4] = a1 + 8;
  void v7[5] = &v5;
  int v8 = v7;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_100299E58;
    uint64_t v12 = &unk_1019B3268;
    unint64_t v13 = a3;
    unint64_t v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_100003D34;
    uint64_t v12 = &unk_1019B3248;
    unint64_t v13 = a3;
    unint64_t v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

void sub_100296654(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_1000278EC((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1002967A0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1002967B8(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10029A0BC;
  void v7[3] = &unk_1019B3288;
  void v7[4] = a1 + 8;
  void v7[5] = &v5;
  int v8 = v7;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_100299E58;
    uint64_t v12 = &unk_1019B3268;
    unint64_t v13 = a3;
    unint64_t v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_100003D34;
    uint64_t v12 = &unk_1019B3248;
    unint64_t v13 = a3;
    unint64_t v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

void sub_1002968E4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_1000278EC((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100296A30(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100296A48(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_1000332B4((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100296B94(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100296BAC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  uint64_t v3 = (void *)(a1 + 128);
  if (v2 != (void *)(a1 + 128))
  {
    do
    {
      uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v2 + 8));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v2 + 63) >= 0) {
          uint64_t v5 = v2 + 5;
        }
        else {
          uint64_t v5 = (void *)v2[5];
        }
        if (*((char *)v2 + 87) >= 0) {
          int v6 = v2 + 8;
        }
        else {
          int v6 = (void *)v2[8];
        }
        if (*((char *)v2 + 135) >= 0) {
          uint64_t v7 = v2 + 14;
        }
        else {
          uint64_t v7 = (void *)v2[14];
        }
        if (*((char *)v2 + 111) >= 0) {
          int v8 = v2 + 11;
        }
        else {
          int v8 = (void *)v2[11];
        }
        uint64_t v9 = asString();
        *(_DWORD *)std::string buf = 136316418;
        BOOL v19 = "[home]";
        __int16 v20 = 2080;
        uint64_t v21 = v5;
        __int16 v22 = 2080;
        uint64_t v23 = v6;
        __int16 v24 = 2080;
        uint64_t v25 = v7;
        __int16 v26 = 2080;
        unint64_t v27 = v8;
        __int16 v28 = 2080;
        uint64_t v29 = v9;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s Subscriber MCC: %s, MNC: %s, Extracted MNC: %s, Last known MCC: %s, bundle type: %s", buf, 0x3Eu);
      }
      uint64_t v10 = (void *)v2[1];
      if (v10)
      {
        do
        {
          unint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          unint64_t v11 = (void *)v2[2];
          BOOL v12 = *v11 == (void)v2;
          uint64_t v2 = v11;
        }
        while (!v12);
      }
      uint64_t v2 = v11;
    }
    while (v11 != v3);
  }
  unint64_t v13 = *(void **)(a1 + 216);
  if (v13 != (void *)(a1 + 224))
  {
    do
    {
      unint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v13 + 7));
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = asString();
        *(_DWORD *)std::string buf = 136315138;
        BOOL v19 = (const char *)v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Roaming result : %s", buf, 0xCu);
      }
      uint64_t v16 = (void *)v13[1];
      if (v16)
      {
        do
        {
          int v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          int v17 = (void *)v13[2];
          BOOL v12 = *v17 == (void)v13;
          unint64_t v13 = v17;
        }
        while (!v12);
      }
      unint64_t v13 = v17;
    }
    while (v17 != (void *)(a1 + 224));
  }
}

void *sub_100296E48(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100296ECC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100296F50(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    sub_1000FECD4(i - 48);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100296FA4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100296FDC(uint64_t a1)
{
}

uint64_t sub_100296FF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10029703C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_100297068(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(std::__shared_weak_count **)(*(void *)v1 + 64);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100293200(&v21);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = v21;
  uint64_t v5 = v22;
  if (v21 != v22)
  {
    int v6 = (uint64_t **)(v2 + 120);
    uint64_t v7 = (uint64_t **)(v2 + 128);
    do
    {
      int v8 = *(_DWORD *)v4;
      memset(__p, 0, sizeof(__p));
      *(_OWORD *)BOOL v19 = 0u;
      *(_OWORD *)int v17 = 0u;
      memset(v18, 0, sizeof(v18));
      uint64_t v9 = v7;
      uint64_t v10 = v7;
      unint64_t v11 = *v7;
      if (*v7)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v10 = (uint64_t **)v11;
            int v12 = *((_DWORD *)v11 + 8);
            if (v12 <= v8) {
              break;
            }
            unint64_t v11 = *v10;
            uint64_t v9 = v10;
            if (!*v10) {
              goto LABEL_14;
            }
          }
          if (v12 >= v8) {
            break;
          }
          unint64_t v11 = v10[1];
          if (!v11)
          {
            uint64_t v9 = v10 + 1;
            goto LABEL_14;
          }
        }
      }
      else
      {
LABEL_14:
        v23[2] = 1;
        unint64_t v13 = (char *)operator new(0x90uLL);
        v23[1] = v7;
        *((_DWORD *)v13 + 8) = v8;
        *((void *)v13 + 6) = 0;
        *((void *)v13 + 7) = 0;
        *((void *)v13 + 5) = 0;
        v17[1] = 0;
        v18[0] = 0;
        v17[0] = 0;
        *((_OWORD *)v13 + 4) = *(_OWORD *)&v18[1];
        *((void **)v13 + 10) = v18[3];
        memset(&v18[1], 0, 24);
        *((void **)v13 + 13) = __p[0];
        *(_OWORD *)(v13 + 88) = *(_OWORD *)v19;
        v19[0] = 0;
        v19[1] = 0;
        __p[0] = 0;
        *((_OWORD *)v13 + 7) = *(_OWORD *)&__p[1];
        *((void **)v13 + 16) = __p[3];
        memset(&__p[1], 0, 24);
        v13[136] = 0;
        sub_100046C38(v6, (uint64_t)v10, v9, (uint64_t *)v13);
        v23[0] = 0;
        sub_100297748((uint64_t)v23);
        if (SHIBYTE(__p[3]) < 0) {
          operator delete(__p[1]);
        }
      }
      if (SHIBYTE(__p[0]) < 0) {
        operator delete(v19[0]);
      }
      if (SHIBYTE(v18[3]) < 0) {
        operator delete(v18[1]);
      }
      if (SHIBYTE(v18[0]) < 0) {
        operator delete(v17[0]);
      }
      uint64_t v4 = (capabilities::ct *)((char *)v4 + 4);
    }
    while (v4 != v5);
    uint64_t v4 = v21;
  }
  if (v4)
  {
    __int16 v22 = v4;
    operator delete(v4);
  }
  sub_1000E3958(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100297260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (v27) {
    sub_10004D2C8(v27);
  }
  sub_1000E3958(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1002972A8(ServiceManager::Service *this)
{
  *(void *)this = off_1019B2DD8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100297304(ServiceManager::Service *this)
{
  *(void *)this = off_1019B2DD8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100297374@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SubscriberUtility");
}

unsigned char *sub_100297384@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1002973C4(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1002932D4(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1002932D4(v4, 0);
}

uint64_t sub_100297448()
{
  return 0;
}

uint64_t sub_100297450()
{
  return 1;
}

uint64_t sub_100297458()
{
  return 0;
}

void sub_100297464(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100297544(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10029765C()
{
}

uint64_t sub_100297670(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_10029767C(void *a1)
{
  if (a1)
  {
    sub_10029767C(*a1);
    sub_10029767C(a1[1]);
    sub_1002976D0((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_1002976D0(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

void sub_100297748(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1002976D0((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

uint64_t *sub_1002977A0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 88));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100297824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100297840(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v25 = a1;
  uint64_t v26 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  sub_100058DB0(&__p, "/cc/events/dump_state");
  uint64_t v4 = (uint8_t *)operator new(0x20uLL);
  uint64_t v5 = v2 + 88;
  *(void *)uint64_t v4 = off_1019B2E98;
  *((void *)v4 + 1) = v2;
  *((void *)v4 + 2) = sub_100296BAC;
  *((void *)v4 + 3) = 0;
  uint64_t v31 = v4;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v34) < 0) {
    operator delete(__p);
  }
  Registry::createRestModuleOneTimeUseConnection(&v27, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v28) {
    sub_10004D2C8(v28);
  }
  sub_10012E338(v2 + 216);
  sub_100058DB0(&__p, "/cc/props/sims_in_use");
  uint64_t v6 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v6 = off_1019B2F18;
  *((void *)v6 + 1) = v2 + 144;
  *((void *)v6 + 2) = v2;
  *((void *)v6 + 3) = sub_100295D8C;
  *((void *)v6 + 4) = 0;
  uint64_t v31 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v34) < 0) {
    operator delete(__p);
  }
  sub_1001067E0(v2 + 168);
  uint64_t v7 = (uint8_t *)(v2 + 296);
  *(void *)std::string buf = off_1019B2F98;
  uint64_t v30 = v2 + 88;
  uint64_t v31 = buf;
  if (buf != (uint8_t *)(v2 + 296))
  {
    int v8 = *(uint8_t **)(v2 + 320);
    if (v8 == v7)
    {
      uint64_t v33 = v2 + 88;
      uint64_t v34 = 0;
      uint64_t v31 = 0;
      std::string __p = off_1019B2F98;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v7 + 24))(v2 + 296, buf);
      (*(void (**)(void))(**(void **)(v2 + 320) + 32))(*(void *)(v2 + 320));
      *(void *)(v2 + 320) = 0;
      uint64_t v31 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, v2 + 296);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(v2 + 296) = off_1019B2F98;
      *(void *)(v2 + 304) = v5;
      uint64_t v31 = v8;
    }
    *(void *)(v2 + 320) = v7;
  }
  sub_100296ECC(buf);
  uint64_t v9 = *(void *)(v2 + 320);
  if (v9) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 48))(v9, v2 + 328);
  }
  uint64_t v10 = (uint8_t *)(v2 + 352);
  *(void *)std::string buf = off_1019B3028;
  uint64_t v30 = v2 + 88;
  uint64_t v31 = buf;
  if (buf != (uint8_t *)(v2 + 352))
  {
    unint64_t v11 = *(uint8_t **)(v2 + 376);
    if (v11 == v10)
    {
      uint64_t v33 = v2 + 88;
      uint64_t v34 = 0;
      uint64_t v31 = 0;
      std::string __p = off_1019B3028;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v10 + 24))(v2 + 352, buf);
      (*(void (**)(void))(**(void **)(v2 + 376) + 32))(*(void *)(v2 + 376));
      *(void *)(v2 + 376) = 0;
      uint64_t v31 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, v2 + 352);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(v2 + 352) = off_1019B3028;
      *(void *)(v2 + 360) = v5;
      uint64_t v31 = v11;
    }
    *(void *)(v2 + 376) = v10;
  }
  sub_100296E48(buf);
  uint64_t v12 = *(void *)(v2 + 376);
  if (v12) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, v2 + 384);
  }
  sub_100058DB0(&__p, "/cc/props/carrier_bundles");
  unint64_t v13 = (uint8_t *)operator new(0x28uLL);
  *(void *)unint64_t v13 = off_1019B30B8;
  *((void *)v13 + 1) = v2 + 192;
  *((void *)v13 + 2) = v2;
  *((void *)v13 + 3) = sub_100294618;
  *((void *)v13 + 4) = 0;
  uint64_t v31 = v13;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v34) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/cellular_plan_selected_plan_home_country");
  *(void *)std::string buf = off_1019B3138;
  uint64_t v30 = v2 + 240;
  uint64_t v31 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v34) < 0) {
    operator delete(__p);
  }
  sub_100297F24(v2 + 272);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 56));
  uint64_t v15 = ServiceMap;
  if (v16 < 0)
  {
    int v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v16;
  __int16 v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
  if (v20)
  {
    uint64_t v22 = v20[3];
    uint64_t v21 = (std::__shared_weak_count *)v20[4];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v15);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  std::mutex::unlock(v15);
  uint64_t v21 = 0;
LABEL_35:
  uint64_t v23 = *(std::__shared_weak_count **)(v2 + 80);
  *(void *)(v2 + 72) = v22;
  *(void *)(v2 + 80) = v21;
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_100088C88(&v26);
  return sub_100046B58((uint64_t *)&v25);
}

void sub_100297EA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100297F24(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/last_visible_mccs");
  v4[0] = off_1019B31B8;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100297FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100298008()
{
}

__n128 sub_10029801C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019B2E98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100298070(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B2E98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1002980A8(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  char v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1002980F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100298130()
{
}

void sub_100298140()
{
}

__n128 sub_100298154(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019B2F18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1002981A8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B2F18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1002981E0(void *a1, xpc_object_t *a2)
{
  char v3 = (std::string *)a1[1];
  long long v21 = 0uLL;
  uint64_t v22 = 0;
  sub_100089CF0((uint64_t *)&v21, a2);
  p_std::string::size_type size = &v3->__r_.__value_.__l.__size_;
  std::string::size_type size = (void *)v3->__r_.__value_.__l.__size_;
  uint64_t v18 = (void **)v3->__r_.__value_.__r.__words[0];
  unsigned int v19 = size;
  std::string::size_type v20 = v3->__r_.__value_.__r.__words[2];
  if (v20)
  {
    size[2] = &v19;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    *p_std::string::size_type size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    uint64_t v18 = (void **)&v19;
  }
  long long v16 = v21;
  uint64_t v17 = v22;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v16);
  uint64_t v23 = (void **)&v16;
  sub_10008A88C(&v23);
  if (v20 == v3->__r_.__value_.__r.__words[2])
  {
    uint64_t v6 = v18;
    if (v18 == (void **)&v19) {
      goto LABEL_24;
    }
    uint64_t v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      int v8 = (void **)v6[1];
      uint64_t v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          uint64_t v6 = v8;
          int v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v6 = v9[2];
          BOOL v10 = *v6 == v9;
          uint64_t v9 = (void ***)v6;
        }
        while (!v10);
      }
      unint64_t v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          uint64_t v7 = v12;
        }
        while (!v10);
      }
      uint64_t v7 = v12;
      if (v6 == (void **)&v19) {
        goto LABEL_24;
      }
    }
  }
  unint64_t v13 = (void (*)(void *, void ***))a1[3];
  uint64_t v14 = a1[4];
  uint64_t v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    unint64_t v13 = *(void (**)(void *, void ***))(*v15 + v13);
  }
  v13(v15, &v18);
LABEL_24:
  sub_100088048((uint64_t)&v18, v19);
  uint64_t v18 = (void **)&v21;
  sub_10008A88C(&v18);
}

void sub_1002983A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, void *a13, uint64_t a14, char a15)
{
  a12 = (void **)&a15;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1002983EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10029842C()
{
}

void sub_10029843C()
{
}

void *sub_100298450(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B2F98;
  result[1] = v3;
  return result;
}

uint64_t sub_100298498(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B2F98;
  a2[1] = v2;
  return result;
}

void sub_1002984C4(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      std::string __p = &v26;
      std::string::size_type v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      rest::write_rest_value();
      std::string __p = &v26;
      std::string::size_type v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          long long v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          long long v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/mcc_mnc_computed_info");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_10029878C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100298844(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100298884()
{
}

void sub_100298894()
{
}

void *sub_1002988A8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B3028;
  result[1] = v3;
  return result;
}

uint64_t sub_1002988F0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B3028;
  a2[1] = v2;
  return result;
}

void sub_10029891C(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      std::string __p = &v26;
      std::string::size_type v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      rest::write_rest_value();
      std::string __p = &v26;
      std::string::size_type v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          long long v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          long long v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/last_known_home_plmn");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_100298BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100298C9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100298CDC()
{
}

void sub_100298CEC()
{
}

__n128 sub_100298D00(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019B30B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100298D54(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B30B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100298D8C(uint64_t *a1, xpc_object_t *a2)
{
  sub_10008AAD8(a1[1], a2);
  xpc_object_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    xpc_object_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100298E08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100298E48()
{
}

void sub_100298E58()
{
}

void *sub_100298E6C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B3138;
  result[1] = v3;
  return result;
}

uint64_t sub_100298EB4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B3138;
  a2[1] = v2;
  return result;
}

void sub_100298EE0(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_null)
  {
    if (*(unsigned char *)v3)
    {
      v4[0] = (void **)(v3 + 8);
      sub_100047F64(v4);
      *(unsigned char *)uint64_t v3 = 0;
    }
  }
  else
  {
    if (!*(unsigned char *)v3)
    {
      *(void *)(v3 + 8) = 0;
      *(void *)(v3 + 16) = 0;
      *(void *)(v3 + 24) = 0;
      memset(v4, 0, sizeof(v4));
      *(unsigned char *)uint64_t v3 = 1;
      uint64_t v5 = v4;
      sub_100047F64((void ***)&v5);
      if (!*(unsigned char *)v3) {
        __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
      }
    }
    sub_100033E28((uint64_t *)(v3 + 8), a2);
  }
}

uint64_t sub_100298FA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100298FE4()
{
}

void sub_100298FF4()
{
}

void *sub_100299008(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B31B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100299050(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B31B8;
  a2[1] = v2;
  return result;
}

uint64_t sub_10029907C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002990BC()
{
}

void sub_1002990C8(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 71) < 0) {
      operator delete(__p[6]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_100299128(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 64);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100293200(&v11);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = v11;
  uint64_t v4 = v12;
  if (v11 != v12)
  {
    do
    {
      uint64_t v5 = *(unsigned int *)v3;
      uint64_t v8 = 0;
      CFTypeRef cf = 0;
      xpc_object_t v10 = 0;
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(v1 + 72) + 200))(&v8);
      char v6 = v8;
      CFTypeRef v7 = cf;
      if (cf) {
        CFRetain(cf);
      }
      sub_100294848(v1, v5, v6, 0, &v7);
      sub_100057D78(&v7);
      sub_100057D78(&v10);
      sub_100057D78(&cf);
      uint64_t v3 = (capabilities::ct *)((char *)v3 + 4);
    }
    while (v3 != v4);
    uint64_t v3 = v11;
  }
  if (v3)
  {
    uint64_t v12 = v3;
    operator delete(v3);
  }
  operator delete();
}

void sub_100299270(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (v15) {
    sub_10004D2C8(v15);
  }
  operator delete();
}

uint64_t **sub_1002992E4(uint64_t **a1, int a2, _DWORD *a3)
{
  char v6 = a1 + 1;
  uint64_t v5 = a1[1];
  CFTypeRef v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        uint64_t v5 = *v8;
        CFTypeRef v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        CFTypeRef v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    void v12[2] = 1;
    xpc_object_t v10 = (char *)operator new(0x90uLL);
    v12[1] = v6;
    *((_DWORD *)v10 + 8) = *a3;
    *(_OWORD *)(v10 + 40) = 0u;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *(_OWORD *)(v10 + 104) = 0u;
    *(_OWORD *)(v10 + 120) = 0u;
    *((void *)v10 + 17) = 0;
    sub_100046C38(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    sub_100297748((uint64_t)v12);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t sub_1002993CC(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t **sub_100299430(uint64_t **a1, int a2, _DWORD *a3)
{
  char v6 = a1 + 1;
  uint64_t v5 = a1[1];
  CFTypeRef v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        uint64_t v5 = *v8;
        CFTypeRef v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        CFTypeRef v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    void v12[2] = 1;
    xpc_object_t v10 = (char *)operator new(0x58uLL);
    v12[1] = v6;
    *((_DWORD *)v10 + 8) = *a3;
    *(_OWORD *)(v10 + 40) = 0u;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    sub_100046C38(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    sub_1001A7E1C((uint64_t)v12, 0);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t sub_10029950C(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      uint64_t v6 = *(void *)(a1 + 8);
      CFTypeRef v7 = v3;
      if (*(uint64_t **)a1 == v3) {
        goto LABEL_8;
      }
      uint64_t v8 = *(uint64_t **)(a1 + 8);
      int v9 = v3;
      if (v6)
      {
        do
        {
          CFTypeRef v7 = v8;
          uint64_t v8 = (uint64_t *)v8[1];
        }
        while (v8);
      }
      else
      {
        do
        {
          CFTypeRef v7 = (uint64_t *)v9[2];
          BOOL v10 = *v7 == (void)v9;
          int v9 = v7;
        }
        while (v10);
      }
      int v11 = *((_DWORD *)v5 + 8);
      if (*((_DWORD *)v7 + 8) < v11)
      {
LABEL_8:
        if (v6) {
          uint64_t v12 = (uint64_t **)v7;
        }
        else {
          uint64_t v12 = (uint64_t **)v3;
        }
        if (v6) {
          unint64_t v13 = (uint64_t **)(v7 + 1);
        }
        else {
          unint64_t v13 = (uint64_t **)v3;
        }
        if (*v13) {
          goto LABEL_31;
        }
      }
      else
      {
        unint64_t v13 = (uint64_t **)v3;
        uint64_t v12 = (uint64_t **)v3;
        if (v6)
        {
          xpc_object_t v14 = *(uint64_t **)(a1 + 8);
          while (1)
          {
            while (1)
            {
              uint64_t v12 = (uint64_t **)v14;
              int v15 = *((_DWORD *)v14 + 8);
              if (v15 <= v11) {
                break;
              }
              xpc_object_t v14 = *v12;
              unint64_t v13 = v12;
              if (!*v12) {
                goto LABEL_24;
              }
            }
            if (v15 >= v11) {
              goto LABEL_31;
            }
            xpc_object_t v14 = v12[1];
            if (!v14)
            {
              unint64_t v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_24:
      uint64_t v25 = 0;
      long long v16 = (char *)operator new(0x58uLL);
      BOOL v17 = v16;
      v24[0] = (uint64_t *)v16;
      v24[1] = v3;
      *((_DWORD *)v16 + 8) = *((_DWORD *)v5 + 8);
      if (*((char *)v5 + 63) < 0)
      {
        sub_10004FC84(v16 + 40, (void *)v5[5], v5[6]);
      }
      else
      {
        long long v18 = *(_OWORD *)(v5 + 5);
        *((void *)v16 + 7) = v5[7];
        *(_OWORD *)(v16 + 40) = v18;
      }
      unsigned int v19 = v17 + 64;
      if (*((char *)v5 + 87) < 0)
      {
        sub_10004FC84(v19, (void *)v5[8], v5[9]);
      }
      else
      {
        long long v20 = *((_OWORD *)v5 + 4);
        *((void *)v17 + 10) = v5[10];
        *(_OWORD *)unsigned int v19 = v20;
      }
      LOBYTE(v25) = 1;
      sub_100046C38((uint64_t **)a1, (uint64_t)v12, v13, v24[0]);
      v24[0] = 0;
      sub_1001A7E1C((uint64_t)v24, 0);
LABEL_31:
      char v21 = (void *)v5[1];
      if (v21)
      {
        do
        {
          xpc_object_t v22 = v21;
          char v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          xpc_object_t v22 = (void *)v5[2];
          BOOL v10 = *v22 == (void)v5;
          uint64_t v5 = v22;
        }
        while (!v10);
      }
      uint64_t v5 = v22;
    }
    while (v22 != v4);
  }
  return a1;
}

void sub_100299700(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v4 + 63) < 0) {
    operator delete(*v3);
  }
  sub_1001A7E1C((uint64_t)va, 0);
  sub_10019D5B8(v2, *v5);
  _Unwind_Resume(a1);
}

uint64_t sub_100299748(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_24;
      }
      uint64_t v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8) && rest::operator==())
      {
        uint64_t v5 = (void *)v3[1];
        uint64_t v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            uint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            uint64_t v6 = v3;
          }
          while (!v7);
        }
        uint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            int v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            int v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            uint64_t v4 = v9;
          }
          while (!v7);
        }
        uint64_t v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    BOOL v10 = v2 + 5;
    sub_10019D5B8((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    int v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      *int v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_10019D5B8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t *sub_1002998C4(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10029991C(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100299904(_Unwind_Exception *a1)
{
  sub_10019D5B8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_10029991C(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      __n128 result = sub_1002999A8(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      BOOL v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          BOOL v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1002999A8(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v6 = sub_1000262C0(a1, a2, &v12, &v11, a3);
  BOOL v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_100299A4C((uint64_t)a1, a4, v10);
    sub_100046C38(a1, (uint64_t)v12, v8, v10[0]);
    BOOL v7 = v10[0];
    v10[0] = 0;
    sub_1001A7E1C((uint64_t)v10, 0);
  }
  return v7;
}

uint64_t sub_100299A4C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = operator new(0x58uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = sub_100299AC0((uint64_t)v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100299AA8(_Unwind_Exception *a1)
{
  sub_1001A7E1C(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100299AC0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  uint64_t v5 = (unsigned char *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_100299B54(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100299B70(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_24;
      }
      long long v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8) && rest::operator==())
      {
        uint64_t v5 = (void *)v3[1];
        long long v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            uint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            long long v6 = v3;
          }
          while (!v7);
        }
        uint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            BOOL v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            BOOL v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            long long v4 = v9;
          }
          while (!v7);
        }
        long long v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    BOOL v10 = v2 + 5;
    sub_10019D5B8((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    uint64_t v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      *uint64_t v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_10019D5B8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_100299CEC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(_DWORD **)(a1 + 40);
  long long v4 = *(uint64_t **)(*(void *)v3 + 128);
  if (!v4) {
    goto LABEL_11;
  }
  int v5 = v3[2];
  uint64_t v6 = *(void *)v3 + 128;
  uint64_t v7 = *(void *)v6;
  do
  {
    int v8 = *(_DWORD *)(v7 + 32);
    BOOL v9 = v8 < v5;
    if (v8 >= v5) {
      BOOL v10 = (uint64_t *)v7;
    }
    else {
      BOOL v10 = (uint64_t *)(v7 + 8);
    }
    if (!v9) {
      uint64_t v6 = v7;
    }
    uint64_t v7 = *v10;
  }
  while (*v10);
  if (v6 != *(void *)v3 + 128 && v5 >= *(_DWORD *)(v6 + 32))
  {
    uint64_t v12 = sub_1000389F8(v4, v5);
    if (*((char *)v12 + 23) < 0)
    {
      uint64_t v13 = (void *)*v12;
      unint64_t v14 = v12[1];
      sub_10004FC84((unsigned char *)a2, v13, v14);
    }
    else
    {
      *(_OWORD *)a2 = *(_OWORD *)v12;
      *(void *)(a2 + 16) = v12[2];
    }
  }
  else
  {
LABEL_11:
    uint64_t v11 = *(NSObject **)(*(void *)v3 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v15 = 136315138;
      uint64_t v16 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid instance %s", (uint8_t *)&v15, 0xCu);
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
}

__n128 sub_100299E58(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

uint64_t *sub_100299EBC(int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v13 = a1;
  unint64_t v14 = v1;
  uint64_t v2 = *(uint64_t **)(*(void *)v1 + 128);
  if (!v2) {
    goto LABEL_11;
  }
  int v3 = v1[2];
  uint64_t v4 = *(void *)v1 + 128;
  uint64_t v5 = *(void *)v4;
  do
  {
    int v6 = *(_DWORD *)(v5 + 32);
    BOOL v7 = v6 < v3;
    if (v6 >= v3) {
      int v8 = (uint64_t *)v5;
    }
    else {
      int v8 = (uint64_t *)(v5 + 8);
    }
    if (!v7) {
      uint64_t v4 = v5;
    }
    uint64_t v5 = *v8;
  }
  while (*v8);
  if (v4 != *(void *)v1 + 128 && v3 >= *(_DWORD *)(v4 + 32))
  {
    uint64_t v12 = sub_1000389F8(v2, v3);
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(buf, (void *)*v12, v12[1]);
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)v12;
      uint64_t v16 = v12[2];
    }
    uint64_t v10 = *((void *)v1 + 5);
    if (!v10) {
      sub_10007B600();
    }
  }
  else
  {
LABEL_11:
    BOOL v9 = *(NSObject **)(*(void *)v1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid instance %s", buf, 0xCu);
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v16 = 0;
    uint64_t v10 = *((void *)v1 + 5);
    if (!v10) {
      sub_10007B600();
    }
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v10 + 48))(v10, buf);
  if (SHIBYTE(v16) < 0) {
    operator delete(*(void **)buf);
  }
  sub_10001E8C4((uint64_t *)&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_10029A080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_10001E8C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10029A0BC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v3 = *(_DWORD **)(a1 + 40);
  uint64_t v4 = *(uint64_t **)(*(void *)v3 + 128);
  if (!v4) {
    goto LABEL_11;
  }
  int v5 = v3[2];
  uint64_t v6 = *(void *)v3 + 128;
  uint64_t v7 = *(void *)v6;
  do
  {
    int v8 = *(_DWORD *)(v7 + 32);
    BOOL v9 = v8 < v5;
    if (v8 >= v5) {
      uint64_t v10 = (uint64_t *)v7;
    }
    else {
      uint64_t v10 = (uint64_t *)(v7 + 8);
    }
    if (!v9) {
      uint64_t v6 = v7;
    }
    uint64_t v7 = *v10;
  }
  while (*v10);
  if (v6 != *(void *)v3 + 128 && v5 >= *(_DWORD *)(v6 + 32))
  {
    uint64_t v12 = sub_1000389F8(v4, v5);
    if (*((char *)v12 + 47) < 0)
    {
      uint64_t v13 = (void *)v12[3];
      unint64_t v14 = v12[4];
      sub_10004FC84((unsigned char *)a2, v13, v14);
    }
    else
    {
      *(_OWORD *)a2 = *(_OWORD *)(v12 + 3);
      *(void *)(a2 + 16) = v12[5];
    }
  }
  else
  {
LABEL_11:
    uint64_t v11 = *(NSObject **)(*(void *)v3 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v15 = 136315138;
      uint64_t v16 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid instance %s", (uint8_t *)&v15, 0xCu);
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
}

uint64_t *sub_10029A22C(int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v13 = a1;
  unint64_t v14 = v1;
  uint64_t v2 = *(uint64_t **)(*(void *)v1 + 128);
  if (!v2) {
    goto LABEL_11;
  }
  int v3 = v1[2];
  uint64_t v4 = *(void *)v1 + 128;
  uint64_t v5 = *(void *)v4;
  do
  {
    int v6 = *(_DWORD *)(v5 + 32);
    BOOL v7 = v6 < v3;
    if (v6 >= v3) {
      int v8 = (uint64_t *)v5;
    }
    else {
      int v8 = (uint64_t *)(v5 + 8);
    }
    if (!v7) {
      uint64_t v4 = v5;
    }
    uint64_t v5 = *v8;
  }
  while (*v8);
  if (v4 != *(void *)v1 + 128 && v3 >= *(_DWORD *)(v4 + 32))
  {
    uint64_t v12 = sub_1000389F8(v2, v3);
    if (*((char *)v12 + 71) < 0)
    {
      sub_10004FC84(buf, (void *)v12[6], v12[7]);
    }
    else
    {
      *(_OWORD *)std::string buf = *((_OWORD *)v12 + 3);
      uint64_t v16 = v12[8];
    }
    uint64_t v10 = *((void *)v1 + 5);
    if (!v10) {
      sub_10007B600();
    }
  }
  else
  {
LABEL_11:
    BOOL v9 = *(NSObject **)(*(void *)v1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid instance %s", buf, 0xCu);
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v16 = 0;
    uint64_t v10 = *((void *)v1 + 5);
    if (!v10) {
      sub_10007B600();
    }
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v10 + 48))(v10, buf);
  if (SHIBYTE(v16) < 0) {
    operator delete(*(void **)buf);
  }
  sub_10001E8C4((uint64_t *)&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_10029A3F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_10001E8C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10029A430(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v51 = a1;
  uint64_t v52 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  sub_1000332B4((uint64_t)v64, v1 + 16);
  CFArrayRef theArray = 0;
  CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    uint64_t v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v68 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to create CFMutableArraySharedRef", v68, 2u);
    }
    sub_100044D6C(v68, (CFTypeRef *)&theArray);
    uint64_t v14 = v65;
    if (!v65) {
      sub_10007B600();
    }
    goto LABEL_42;
  }
  CFArrayRef v5 = theArray;
  CFArrayRef theArray = Mutable;
  *(void *)uint64_t v68 = v5;
  sub_1000440D4((const void **)v68);
  if (!sub_100289354)
  {
    int v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v68 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "array is null", v68, 2u);
    }
    sub_100044D6C(v68, (CFTypeRef *)&theArray);
    uint64_t v14 = v65;
    if (!v65) {
      sub_10007B600();
    }
LABEL_42:
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v65 + 48))(v14, v68);
LABEL_83:
    xpc_object_t v23 = (const void **)v68;
    goto LABEL_84;
  }
  if (!*(unsigned char *)(v2 + 240))
  {
    uint64_t v16 = *(void *)(v2 + 152);
    if (v16)
    {
      uint64_t v17 = v2 + 152;
      do
      {
        int v18 = *(_DWORD *)(v16 + 32);
        BOOL v19 = v18 < (int)v3;
        if (v18 >= (int)v3) {
          long long v20 = (uint64_t *)v16;
        }
        else {
          long long v20 = (uint64_t *)(v16 + 8);
        }
        if (!v19) {
          uint64_t v17 = v16;
        }
        uint64_t v16 = *v20;
      }
      while (*v20);
      if (v17 != v2 + 152 && *(_DWORD *)(v17 + 32) <= (int)v3)
      {
        if (*(char *)(v17 + 135) < 0 ? *(void *)(v17 + 120) : *(unsigned __int8 *)(v17 + 135))
        {
          long long v80 = 0u;
          long long v81 = 0u;
          long long v78 = 0u;
          long long v79 = 0u;
          long long v76 = 0u;
          long long v77 = 0u;
          long long v74 = 0u;
          long long v75 = 0u;
          long long v72 = 0u;
          long long v73 = 0u;
          long long v70 = 0u;
          long long v71 = 0u;
          *(_OWORD *)uint64_t v68 = 0u;
          long long v69 = 0u;
          sGetProfileDetails();
          if (BYTE8(v81))
          {
            int v24 = BYTE8(v73);
            sub_1000C584C((uint64_t)v68);
            if (v24)
            {
              uint64_t v25 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
              if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)uint64_t v68 = 0;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I home country list not applicable for bootstrap profile", v68, 2u);
              }
              goto LABEL_36;
            }
          }
        }
      }
    }
    uint64_t v27 = (uint64_t **)(v2 + 128);
    uint64_t v26 = *(void *)(v2 + 128);
    if (!v26) {
      goto LABEL_79;
    }
    uint64_t v28 = v2 + 128;
    do
    {
      int v29 = *(_DWORD *)(v26 + 32);
      BOOL v30 = v29 < (int)v3;
      if (v29 >= (int)v3) {
        uint64_t v31 = (uint64_t *)v26;
      }
      else {
        uint64_t v31 = (uint64_t *)(v26 + 8);
      }
      if (!v30) {
        uint64_t v28 = v26;
      }
      uint64_t v26 = *v31;
    }
    while (*v31);
    if ((uint64_t **)v28 == v27 || *(_DWORD *)(v28 + 32) > (int)v3)
    {
LABEL_79:
      std::string::size_type v32 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        uint64_t v45 = subscriber::asString();
        *(_DWORD *)uint64_t v68 = 136315138;
        *(void *)&v68[4] = v45;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Invalid instance %s", v68, 0xCu);
      }
      *(void *)uint64_t v68 = 0;
      if (!v65) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v65 + 48))(v65, v68);
      goto LABEL_83;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 56));
    std::string::size_type v35 = ServiceMap;
    if (v36 < 0)
    {
      uint64_t v37 = (unsigned __int8 *)(v36 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v38 = 5381;
      do
      {
        uint64_t v36 = v38;
        unsigned int v39 = *v37++;
        uint64_t v38 = (33 * v38) ^ v39;
      }
      while (v39);
    }
    std::mutex::lock(ServiceMap);
    *(void *)uint64_t v68 = v36;
    int v40 = sub_10004D37C(&v35[1].__m_.__sig, (unint64_t *)v68);
    if (v40)
    {
      uint64_t v42 = v40[3];
      int64_t v41 = (std::__shared_weak_count *)v40[4];
      if (v41)
      {
        atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v35);
        atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v41);
        char v43 = 0;
        goto LABEL_94;
      }
    }
    else
    {
      uint64_t v42 = 0;
    }
    std::mutex::unlock(v35);
    int64_t v41 = 0;
    char v43 = 1;
LABEL_94:
    if (!v42) {
      goto LABEL_134;
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v61 = 0;
    std::string::size_type v44 = sub_1000389F8(*v27, v3);
    if (*((char *)v44 + 23) < 0)
    {
      sub_10004FC84(__p, (void *)*v44, v44[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v44;
      uint64_t v61 = v44[2];
    }
    uint64_t v46 = (void *)HIBYTE(v61);
    if (v61 < 0) {
      uint64_t v46 = __p[1];
    }
    if (!v46)
    {
      uint64_t v48 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v68 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Unknown mcc", v68, 2u);
      }
      *(void *)uint64_t v68 = 0;
      if (!v65) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v65 + 48))(v65, v68);
      sub_100044D00((const void **)v68);
      int v49 = 1;
LABEL_129:
      if (SHIBYTE(v61) < 0) {
        operator delete(__p[0]);
      }
      if (v49)
      {
        if ((v43 & 1) == 0) {
          sub_10004D2C8(v41);
        }
        goto LABEL_85;
      }
LABEL_134:
      if ((v43 & 1) == 0) {
        sub_10004D2C8(v41);
      }
      goto LABEL_36;
    }
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v57 = 0;
    (*(void (**)(void **__return_ptr, uint64_t, void **))(*(void *)v42 + 24))(__dst, v42, __p);
    if (SHIBYTE(v57) < 0)
    {
      if (__dst[1])
      {
        uint64_t v47 = theArray;
        sub_10004FC84(v53, __dst[0], (unint64_t)__dst[1]);
        goto LABEL_110;
      }
    }
    else if (HIBYTE(v57))
    {
      uint64_t v47 = theArray;
      *(_OWORD *)uint64_t v53 = *(_OWORD *)__dst;
      uint64_t v54 = v57;
LABEL_110:
      if (SHIBYTE(v54) < 0)
      {
        sub_10004FC84(buf, v53[0], (unint64_t)v53[1]);
      }
      else
      {
        *(_OWORD *)std::string buf = *(_OWORD *)v53;
        uint64_t v67 = v54;
      }
      uint64_t v59 = 0;
      if (SHIBYTE(v67) < 0)
      {
        sub_10004FC84(v68, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        *(_OWORD *)uint64_t v68 = *(_OWORD *)buf;
        *(void *)&long long v69 = v67;
      }
      int64_t v62 = 0;
      if (ctu::cf::convert_copy())
      {
        BOOL v50 = v59;
        uint64_t v59 = v62;
        char v63 = v50;
        sub_1000558F4(&v63);
      }
      if (SBYTE7(v69) < 0) {
        operator delete(*(void **)v68);
      }
      value = v59;
      uint64_t v59 = 0;
      sub_1000558F4((const void **)&v59);
      if (SHIBYTE(v67) < 0) {
        operator delete(*(void **)buf);
      }
      CFArrayAppendValue(v47, value);
      sub_1000558F4((const void **)&value);
      if (SHIBYTE(v54) < 0) {
        operator delete(v53[0]);
      }
      int v49 = 0;
LABEL_127:
      if (SHIBYTE(v57) < 0) {
        operator delete(__dst[0]);
      }
      goto LABEL_129;
    }
    *(void *)uint64_t v68 = 0;
    if (!v65) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v65 + 48))(v65, v68);
    sub_100044D00((const void **)v68);
    int v49 = 1;
    goto LABEL_127;
  }
  *(_OWORD *)uint64_t v68 = 0u;
  long long v69 = 0u;
  sub_1000302C0((char *)&v68[8], *(long long **)(v2 + 248), *(long long **)(v2 + 256), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v2 + 256) - *(void *)(v2 + 248)) >> 3));
  v68[0] = 1;
  int v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (!v68[0]) {
      __assert_rtn("get", "optional.hpp", 1211, "this->is_initialized()");
    }
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v69 - *(void *)&v68[8]) >> 3);
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Num of countries %lu", buf, 0xCu);
  }
  if (!v68[0]) {
    __assert_rtn("get", "optional.hpp", 1211, "this->is_initialized()");
  }
  BOOL v7 = *(long long **)&v68[8];
  int v8 = (long long *)v69;
  if (*(void *)&v68[8] == (void)v69)
  {
LABEL_35:
    *(void *)std::string buf = &v68[8];
    sub_100047F64((void ***)buf);
    goto LABEL_36;
  }
  do
  {
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v57 = 0;
    if (*((char *)v7 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)v7, *((void *)v7 + 1));
    }
    else
    {
      long long v9 = *v7;
      uint64_t v57 = *((void *)v7 + 2);
      *(_OWORD *)std::string __dst = v9;
    }
    if (SHIBYTE(v57) < 0)
    {
      if (!__dst[1]) {
        goto LABEL_32;
      }
      uint64_t v10 = theArray;
      sub_10004FC84(v53, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      if (!HIBYTE(v57)) {
        goto LABEL_33;
      }
      uint64_t v10 = theArray;
      *(_OWORD *)uint64_t v53 = *(_OWORD *)__dst;
      uint64_t v54 = v57;
    }
    if (SHIBYTE(v54) < 0)
    {
      sub_10004FC84(__p, v53[0], (unint64_t)v53[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v53;
      uint64_t v61 = v54;
    }
    uint64_t v59 = 0;
    if (SHIBYTE(v61) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)__p;
      uint64_t v67 = v61;
    }
    int64_t v62 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v11 = v59;
      uint64_t v59 = v62;
      char v63 = v11;
      sub_1000558F4(&v63);
    }
    if (SHIBYTE(v67) < 0) {
      operator delete(*(void **)buf);
    }
    value = v59;
    uint64_t v59 = 0;
    sub_1000558F4((const void **)&v59);
    if (SHIBYTE(v61) < 0) {
      operator delete(__p[0]);
    }
    CFArrayAppendValue(v10, value);
    sub_1000558F4((const void **)&value);
    if (SHIBYTE(v54) < 0) {
      operator delete(v53[0]);
    }
    if (SHIBYTE(v57) < 0) {
LABEL_32:
    }
      operator delete(__dst[0]);
LABEL_33:
    BOOL v7 = (long long *)((char *)v7 + 24);
  }
  while (v7 != v8);
  if (v68[0]) {
    goto LABEL_35;
  }
LABEL_36:
  if (CFArrayGetCount(theArray))
  {
    sub_100044D6C(buf, (CFTypeRef *)&theArray);
    uint64_t v12 = v65;
    if (!v65) {
      sub_10007B600();
    }
  }
  else
  {
    xpc_object_t v22 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I empty home country list", buf, 2u);
    }
    *(void *)std::string buf = 0;
    uint64_t v12 = v65;
    if (!v65) {
      sub_10007B600();
    }
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v65 + 48))(v12, buf);
  xpc_object_t v23 = (const void **)buf;
LABEL_84:
  sub_100044D00(v23);
LABEL_85:
  sub_1000440D4((const void **)&theArray);
  sub_100033230(v64);
  sub_100032F4C(&v52);
  return sub_100046B58((uint64_t *)&v51);
}

void sub_10029AFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,const void *a25,const void *a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  sub_1000558F4(&a26);
  if (a45 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if ((v53 & 1) == 0) {
    sub_10004D2C8(v52);
  }
  sub_1000440D4(&a25);
  sub_100033230(&a36);
  sub_100032F4C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void *sub_10029B1BC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *a1 = off_101A150C0;
  long long v9 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v15, kCtLoggingSystemName, "DATA.5wi");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v16, &v15);
  ctu::OsLogLogger::OsLogLogger(v9, (const ctu::OsLogLogger *)v16);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v16);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v15);
  *a1 = off_1019B32B8;
  a1[2] = 0;
  uint64_t v10 = a1 + 2;
  a1[3] = 0;
  a1[4] = 0;
  uint64_t v11 = operator new(0x20uLL);
  v11[1] = 0;
  v11[2] = 0;
  *uint64_t v11 = off_1019B3378;
  *((unsigned char *)v11 + 24) = 0;
  a1[5] = v11 + 3;
  a1[6] = v11;
  if (!(*(uint64_t (**)(uint64_t))(*(void *)a5 + 96))(a5))
  {
    if (*v10) {
      return a1;
    }
LABEL_5:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "NEIPSecIKECreateSessionWithInterface failed");
  }
  a1[4] = a6;
  uint64_t v12 = NEIPSecIKECreateSessionWithInterface();
  uint64_t *v10 = v12;
  if (!v12) {
    goto LABEL_5;
  }
  return a1;
}

void sub_10029B384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  __cxa_free_exception(v14);
  uint64_t v16 = *(std::__shared_weak_count **)(v13 + 48);
  if (v16) {
    sub_10004D2C8(v16);
  }
  ctu::OsLogLogger::~OsLogLogger(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_10029B3E4(uint64_t result, int a2, __int16 a3, CFTypeRef cf, uint64_t a5)
{
  if (a5 && *(void *)(a5 + 16) == result)
  {
    if ((a3 & 0xFF00) == 0x1200)
    {
      if (cf)
      {
        CFTypeID v7 = CFGetTypeID(cf);
        if (v7 == CFArrayGetTypeID())
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
          if (Count < 1)
          {
LABEL_14:
            BOOL v18 = 0;
          }
          else
          {
            CFIndex v9 = Count;
            CFIndex v10 = 0;
            while (1)
            {
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)cf, v10);
              if (ValueAtIndex)
              {
                CFDictionaryRef v12 = ValueAtIndex;
                CFTypeID v13 = CFGetTypeID(ValueAtIndex);
                if (v13 == CFDictionaryGetTypeID())
                {
                  int Value = (BOOL *)CFDictionaryGetValue(v12, @"UseNATTraversal");
                  if (Value)
                  {
                    OsLogContext v15 = Value;
                    CFTypeID v16 = CFGetTypeID(Value);
                    if (v16 == CFBooleanGetTypeID()) {
                      break;
                    }
                  }
                }
              }
              if (v9 == ++v10) {
                goto LABEL_14;
              }
            }
            LOBYTE(v22) = 0;
            ctu::cf::assign((ctu::cf *)&v22, v15, v17);
            BOOL v18 = (_BYTE)v22 != 0;
          }
          **(unsigned char **)(a5 + 40) = v18;
          BOOL v19 = *(NSObject **)(a5 + 8);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v20 = asStringBool(v18);
            int v22 = 136315138;
            uint64_t v23 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I checkForNATedNetwork: Session on NAT'ed network: %s", (uint8_t *)&v22, 0xCu);
          }
        }
      }
    }
    __n128 result = *(void *)(a5 + 32);
    if (result)
    {
      char v21 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v21();
    }
  }
  return result;
}

uint64_t sub_10029B614(uint64_t a1)
{
  *(void *)a1 = off_1019B32B8;
  if (*(void *)(a1 + 16))
  {
    NEIPSecIKEInvalidateSession();
    CFRelease(*(CFTypeRef *)(a1 + 16));
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_10029B688(uint64_t a1)
{
  sub_10029B614(a1);

  operator delete();
}

BOOL sub_10029B6C0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = a2;
  return NEIPSecIKESetDispatchQueue() != 0;
}

uint64_t sub_10029B6E8(uint64_t a1)
{
  return _NEIPSecIKEStartConnection(*(void *)(a1 + 16));
}

uint64_t sub_10029B6F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _NEIPSecIKESendDeadPeerDetectionPacket(*(void *)(a1 + 16), a2, a3, *(void *)(a1 + 24), a4);
}

BOOL sub_10029B700()
{
  return NEIPSecIKEConnectionIsMobile() != 0;
}

uint64_t sub_10029B724()
{
  return NEIPSecIKEStartMOBIKE();
}

uint64_t sub_10029B79C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10029B7B4@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 48);
  *a2 = *(void *)(result + 40);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10029B7D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3378;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10029B7F0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3378;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10029BB2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  sub_1000440D4((const void **)&__p);
  sub_100044D00((const void **)(v23 - 64));
  sub_10005717C((const void **)(v23 - 56));
  if (v22) {
    _Block_release(v22);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10029BBCC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48), *(unsigned __int8 *)(a1 + 56));
}

const void **sub_10029BBE8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a2 + 32);
  if (v4) {
    uint64_t v4 = _Block_copy(v4);
  }
  *(void *)(a1 + 32) = v4;
  sub_100057240((const void **)(a1 + 40), (const void **)(a2 + 40));

  return sub_100062740((const void **)(a1 + 48), (const void **)(a2 + 48));
}

void sub_10029BC44(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 40);
  sub_100044D00((const void **)(a1 + 48));
  sub_10005717C(v2);
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
    _Block_release(v3);
  }
}

void sub_10029C0B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10029C138(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  uint64_t v4 = a1[5];
  CFArrayRef v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_10029C198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10029C1B0(void *a1, void *a2)
{
  __n128 result = (void *)a2[4];
  if (result) {
    __n128 result = _Block_copy(result);
  }
  uint64_t v6 = a2[5];
  uint64_t v5 = a2[6];
  a1[4] = result;
  a1[5] = v6;
  a1[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10029C200(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
    _Block_release(v3);
  }
}

void sub_10029C6B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_10029C758(uint64_t a1)
{
  uint64_t v2 = sub_10029C7F8(*(os_log_t **)(*(void *)(a1 + 32) + 64), [*(id *)(*(void *)(a1 + 32) + 8) devices]);
  uint64_t v3 = v2;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_10029C9A8;
  v5[3] = &unk_1019B3420;
  uint64_t v4 = *(NSObject **)(a1 + 40);
  void v5[4] = *(void *)(a1 + 32);
  v5[5] = v2;
  dispatch_async(v4, v5);
}

NSMutableArray *sub_10029C7F8(os_log_t *a1, void *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [a2 count]);
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v5 = [a2 countByEnumeratingWithState:&v14 objects:v20 count:16];
  if (v5)
  {
    id v7 = v5;
    uint64_t v8 = *(void *)v15;
    *(void *)&long long v6 = 138412290;
    long long v13 = v6;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v8) {
          objc_enumerationMutation(a2);
        }
        CFIndex v10 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        if (objc_msgSend(v10, "uniqueIDOverride", v13)
          && [v10 name]
          && [v10 modelIdentifier])
        {
          [(NSMutableArray *)v4 addObject:v10];
        }
        else
        {
          uint64_t v11 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = v13;
            BOOL v19 = v10;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I device %@ has incomplete description and ignored", buf, 0xCu);
          }
        }
      }
      id v7 = [a2 countByEnumeratingWithState:&v14 objects:v20 count:16];
    }
    while (v7);
  }
  return v4;
}

void sub_10029C9A8(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = (os_log_t *)v3[8];
  id v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [v3 getLogPrefix];
    id v7 = [*(id *)(a1 + 40) count];
    int v8 = 136315650;
    id v9 = v6;
    __int16 v10 = 2080;
    uint64_t v11 = " ";
    __int16 v12 = 2048;
    id v13 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sInitial set of devices: %lu devices", (uint8_t *)&v8, 0x20u);
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = (os_log_t *)v3[8];
  }
  sub_10029CAF8(v4, (uint64_t)[v3 getLogPrefix], *(void **)(a1 + 40));
  [*(id *)(a1 + 32) setFRegisteredDevices:*(void *)(a1 + 40)];
  [*(id *)(a1 + 32) invalidateBootstrapDevicesIfNeeded];
  [*(id *)(a1 + 32) recalculateSupportedDevices];
  [*(id *)(a1 + 32) recalculateConnectedDevices];
  [*(id *)(a1 + 32) checkForBootstrapDevices];
  [*(id *)(a1 + 32) invokeCallbackOnDevsChanged];
}

void sub_10029CAF8(os_log_t *a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1;
  if (a3)
  {
    uint64_t v4 = a3;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    id v5 = [a3 countByEnumeratingWithState:&v19 objects:v35 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v20;
      do
      {
        for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v20 != v7) {
            objc_enumerationMutation(v4);
          }
          id v9 = *v3;
          if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v10 = *(void **)(*((void *)&v19 + 1) + 8 * i);
            id v11 = objc_msgSend(objc_msgSend(v10, "uniqueIDOverride"), "UTF8String");
            id v12 = [(id)IDSCopyIDForDevice() UTF8String];
            id v13 = v3;
            long long v14 = v4;
            id v15 = objc_msgSend(objc_msgSend(v10, "name"), "UTF8String");
            id v16 = objc_msgSend(objc_msgSend(v10, "modelIdentifier"), "UTF8String");
            *(_DWORD *)std::string buf = 136316418;
            uint64_t v24 = a2;
            __int16 v25 = 2048;
            uint64_t v26 = v10;
            __int16 v27 = 2080;
            id v28 = v11;
            __int16 v29 = 2080;
            id v30 = v12;
            __int16 v31 = 2080;
            id v32 = v15;
            uint64_t v4 = v14;
            uint64_t v3 = v13;
            __int16 v33 = 2080;
            id v34 = v16;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s     (0x%lx) - %s %s %s (%s)", buf, 0x3Eu);
          }
        }
        id v6 = [v4 countByEnumeratingWithState:&v19 objects:v35 count:16];
      }
      while (v6);
    }
  }
  else
  {
    long long v17 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v24 = a2;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s     (no devices)", buf, 0xCu);
    }
  }
}

void sub_10029CE78(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 32);
  uint64_t v4 = *v3[8];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315394;
    id v6 = [v3 getLogPrefix];
    __int16 v7 = 2080;
    int v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sWatch pairing complete", (uint8_t *)&v5, 0x16u);
    uint64_t v3 = *(void ***)(a1 + 32);
  }
  [v3 recalculateSupportedDevices];
  [*(id *)(a1 + 32) recalculateConnectedDevices];
  [*(id *)(a1 + 32) checkForBootstrapDevices];
  [*(id *)(a1 + 32) invokeCallbackOnDevsChanged];
}

id sub_10029D9CC(os_log_t *a1, uint64_t a2, void *a3)
{
  id v5 = [a3 keyEnumerator];
  id result = [v5 nextObject];
  if (result)
  {
    int v8 = result;
    *(void *)&long long v7 = 136315394;
    long long v11 = v7;
    do
    {
      id v9 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        id v10 = [v8 UTF8String];
        *(_DWORD *)std::string buf = v11;
        uint64_t v13 = a2;
        __int16 v14 = 2080;
        id v15 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s          %s", buf, 0x16u);
      }
      id result = objc_msgSend(v5, "nextObject", v11);
      int v8 = result;
    }
    while (result);
  }
  return result;
}

id sub_10029DD28(id result)
{
  uint64_t v1 = *((void *)result + 4);
  int v2 = *(_DWORD *)(v1 + 60) - 1;
  *(_DWORD *)(v1 + 60) = v2;
  if (!v2)
  {
    uint64_t v3 = result;
    objc_msgSend(*((id *)result + 4), "updateWithDict:", objc_msgSend(*((id *)result + 4), "fCachedUpdate"));
    uint64_t v4 = (void *)v3[4];
    return [v4 setFCachedUpdate:0];
  }
  return result;
}

void sub_10029F048(os_log_t *a1, uint64_t a2, void *a3)
{
  if (a3)
  {
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    id v6 = [a3 countByEnumeratingWithState:&v13 objects:v21 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v14;
      do
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v14 != v8) {
            objc_enumerationMutation(a3);
          }
          id v10 = *a1;
          if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
          {
            id v11 = [*(id *)(*((void *)&v13 + 1) + 8 * i) UTF8String];
            *(_DWORD *)std::string buf = 136315394;
            uint64_t v18 = a2;
            __int16 v19 = 2080;
            id v20 = v11;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s     %s", buf, 0x16u);
          }
        }
        id v7 = [a3 countByEnumeratingWithState:&v13 objects:v21 count:16];
      }
      while (v7);
    }
  }
  else
  {
    id v12 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v18 = a2;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s     (no device uuids)", buf, 0xCu);
    }
  }
}

void sub_10029FB14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A0394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10012C330((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1002A0440(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = (os_log_t *)v3[8];
  id v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [v3 getLogPrefix];
    id v7 = [*(id *)(a1 + 40) count];
    int v8 = 136315650;
    id v9 = v6;
    __int16 v10 = 2080;
    id v11 = " ";
    __int16 v12 = 2048;
    id v13 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sSet of devices changed: %lu devices", (uint8_t *)&v8, 0x20u);
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = (os_log_t *)v3[8];
  }
  sub_10029CAF8(v4, (uint64_t)[v3 getLogPrefix], *(void **)(a1 + 40));
  [*(id *)(a1 + 32) setFRegisteredDevices:*(void *)(a1 + 40)];
  [*(id *)(a1 + 32) invalidateBootstrapDevicesIfNeeded];
  [*(id *)(a1 + 32) recalculateSupportedDevices];
  [*(id *)(a1 + 32) checkForBootstrapDevices];
  [*(id *)(a1 + 32) invokeCallbackOnDevsChanged];
}

void sub_1002A0618(uint64_t a1)
{
  [*(id *)(a1 + 32) recalculateSupportedDevices];
  objc_msgSend(*(id *)(a1 + 32), "setFConnectedDevices:", objc_msgSend(*(id *)(a1 + 32), "checkAgainstSupported:", *(void *)(a1 + 40)));
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = (os_log_t *)v3[8];
  id v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [v3 getLogPrefix];
    id v7 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "fConnectedDevices"), "count");
    int v8 = 136315650;
    id v9 = v6;
    __int16 v10 = 2080;
    id v11 = " ";
    __int16 v12 = 2048;
    id v13 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sSet of connected devices changed: %lu device(s)", (uint8_t *)&v8, 0x20u);
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = (os_log_t *)v3[8];
  }
  sub_10029CAF8(v4, (uint64_t)[v3 getLogPrefix], objc_msgSend(*(id *)(a1 + 32), "fConnectedDevices"));
  [*(id *)(a1 + 32) checkForBootstrapDevices];
  [*(id *)(a1 + 32) invokeCallbackOnDevsChanged];
}

void sub_1002A0970(uint64_t a1)
{
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  id v2 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "fSentMsgs"), "allKeys");
  id v3 = [v2 countByEnumeratingWithState:&v26 objects:v36 count:16];
  if (v3)
  {
    id v5 = v3;
    uint64_t v6 = *(void *)v27;
    *(void *)&long long v4 = 136315650;
    long long v25 = v4;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v27 != v6) {
          objc_enumerationMutation(v2);
        }
        int v8 = *(void **)(*((void *)&v26 + 1) + 8 * i);
        id v9 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "fSentMsgs", v25), "valueForKey:", v8);
        __int16 v10 = v9;
        if (!v9 || ![v9 isEqualToString:*(void *)(a1 + 40)])
        {
          uint64_t v18 = *(void ***)(a1 + 32);
          __int16 v19 = *v18[8];
          if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
            continue;
          }
          id v20 = [v18 getLogPrefix];
          id v21 = [v10 UTF8String];
          *(_DWORD *)std::string buf = v25;
          id v31 = v20;
          __int16 v32 = 2080;
          __int16 v33 = " ";
          __int16 v34 = 2080;
          id v35 = v21;
          long long v16 = v19;
          long long v17 = "#I %s%sidentifier:%s not found";
          goto LABEL_13;
        }
        objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "fSentMsgs"), "removeObjectForKey:", v8);
        id v11 = *(void ***)(a1 + 32);
        if (*(unsigned char *)(a1 + 48))
        {
          [*(id *)(a1 + 32) addBootstrappedDevice:v8];
          __int16 v12 = *(void ***)(a1 + 32);
          id v13 = *v12[8];
          if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
            continue;
          }
          id v14 = [v12 getLogPrefix];
          id v15 = [v8 UTF8String];
          *(_DWORD *)std::string buf = v25;
          id v31 = v14;
          __int16 v32 = 2080;
          __int16 v33 = " ";
          __int16 v34 = 2080;
          id v35 = v15;
          long long v16 = v13;
          long long v17 = "#I %s%suuid:%s now is synced";
LABEL_13:
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, buf, 0x20u);
          continue;
        }
        long long v22 = *v11[8];
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          id v23 = [v11 getLogPrefix];
          id v24 = [v8 UTF8String];
          *(_DWORD *)std::string buf = v25;
          id v31 = v23;
          __int16 v32 = 2080;
          __int16 v33 = " ";
          __int16 v34 = 2080;
          id v35 = v24;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%suuid:%s removed from pre-bootstrapped devices", buf, 0x20u);
          id v11 = *(void ***)(a1 + 32);
        }
        objc_msgSend(objc_msgSend(v11, "fPreBootstrappedDeviceUuids"), "removeObject:", v8);
      }
      id v5 = [v2 countByEnumeratingWithState:&v26 objects:v36 count:16];
    }
    while (v5);
  }
}

void sub_1002A1038(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002A1070(uint64_t result)
{
  if (*(void *)(result + 24))
  {
    uint64_t v1 = *(void ***)(result + 24);
    sub_1002A1120(&v1);
    operator delete();
  }
  return result;
}

uint64_t sub_1002A10DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1002A1120(void ***a1)
{
  uint64_t v1 = *a1;
  id v2 = (const void **)**a1;
  if (v2)
  {
    long long v4 = (const void **)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 3;
        sub_1000558F4(v4 - 2);
        sub_1000558F4(v6);
        long long v4 = v6;
      }
      while (v6 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ***sub_1002A11B0(void ***result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    id v2 = v1;
    sub_1002A1120(&v2);
    operator delete();
  }
  return result;
}

void sub_1002A1224()
{
}

void *sub_1002A1238(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019B3540;
  result[1] = v3;
  return result;
}

uint64_t sub_1002A1280(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019B3540;
  a2[1] = v2;
  return result;
}

void sub_1002A12AC(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = **(NSObject ***)(**(void **)(a1 + 8) + 64);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      long long v4 = a2;
    }
    else {
      long long v4 = (uint64_t *)*a2;
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_1002A1364(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019B35A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1002A13A4()
{
  return &off_1019B35A0;
}

void sub_1002A15D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A16F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A17A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A194C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A1990(uint64_t a1, Registry *this, char *a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(this);
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v7;
  id v11 = sub_10004D37C(&v6[1].__m_.__sig, &v17);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_9:
    std::mutex::unlock(v6);
    __int16 v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  __int16 v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (!v13)
  {
LABEL_11:
    if (v14) {
      return;
    }
    goto LABEL_12;
  }
LABEL_10:
  sub_100058DB0(__p, a3);
  (*(void (**)(uint64_t, uint64_t, void **, uint64_t))(*(void *)v13 + 328))(v13, a1, __p, 1);
  if ((v16 & 0x80000000) == 0) {
    goto LABEL_11;
  }
  operator delete(__p[0]);
  if (v14) {
    return;
  }
LABEL_12:
  sub_10004D2C8(v12);
}

void sub_1002A1AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A1B14(Registry *a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1);
  long long v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unsigned int v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    unsigned int v10 = 0;
  }
  std::mutex::unlock(v4);
  *a2 = v11;
  a2[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

void _DataSettingsChanged(uint64_t a1, Registry **a2, int a3, uint64_t a4)
{
  sub_1002A1990(a1, *a2, "due to _DataSettingsChanged");
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  uint64_t v9 = ServiceMap;
  unint64_t v11 = v10;
  if ((v10 & 0x8000000000000000) != 0)
  {
    unint64_t v12 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v38 = v11;
  char v15 = sub_10004D37C(&v9[1].__m_.__sig, &v38);
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_9:
    std::mutex::unlock(v9);
    char v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v17 = v15[3];
  char v16 = (std::__shared_weak_count *)v15[4];
  if (!v16) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
  if (v17) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t, void, uint64_t, void))(*(void *)v17 + 344))(v17, a1, 0, a4, 0);
LABEL_11:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  unint64_t v38 = 0;
  unsigned int v39 = 0;
  __int16 v19 = (std::mutex *)Registry::getServiceMap(*a2);
  id v20 = v19;
  if ((v21 & 0x8000000000000000) != 0)
  {
    long long v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      unint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(v19);
  unint64_t v40 = v21;
  long long v25 = sub_10004D37C(&v20[1].__m_.__sig, &v40);
  if (v25)
  {
    uint64_t v27 = v25[3];
    long long v26 = (std::__shared_weak_count *)v25[4];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v26);
      char v28 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v27 = 0;
  }
  std::mutex::unlock(v20);
  long long v26 = 0;
  char v28 = 1;
LABEL_21:
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v27 + 8))(&v38, v27, a1);
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  if (v38) {
    (*(void (**)(void))(*(void *)v38 + 384))();
  }
  if (!a3)
  {
    long long v29 = (std::mutex *)Registry::getServiceMap(*a2);
    id v30 = v29;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v31 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        unint64_t v10 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(v29);
    unint64_t v40 = v10;
    __int16 v34 = sub_10004D37C(&v30[1].__m_.__sig, &v40);
    if (v34)
    {
      uint64_t v36 = v34[3];
      id v35 = (std::__shared_weak_count *)v34[4];
      if (v35)
      {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v30);
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v35);
        char v37 = 0;
        if (!v36)
        {
LABEL_36:
          if ((v37 & 1) == 0) {
            sub_10004D2C8(v35);
          }
          goto LABEL_38;
        }
LABEL_35:
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v36 + 312))(v36, a1, 4, 1);
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v36 = 0;
    }
    std::mutex::unlock(v30);
    id v35 = 0;
    char v37 = 1;
    if (!v36) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
LABEL_38:
  if (v39) {
    sub_10004D2C8(v39);
  }
}

void sub_1002A1F30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void ResetAllPacketHandlersAPNs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1002A20DC();
  unsigned int v8 = qword_101B0CA28;
  BOOL v9 = os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    *(_DWORD *)unint64_t v10 = 136315394;
    *(void *)&void v10[4] = sub_100B15758(a2);
    *(_WORD *)&v10[12] = 1024;
    *(_DWORD *)&v10[14] = a1;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "ResetAllPacketHandlersAPNs, %s[%d]", v10, 0x12u);
  }
  *(void *)unint64_t v10 = 0;
  *(void *)&__int16 v10[8] = 0;
  sub_1003BEF68((Registry *)v9, v10);
  if (*(void *)v10) {
    (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)v10 + 640))(*(void *)v10, a1, a2, a3, a4);
  }
  if (*(void *)&v10[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v10[8]);
  }
}

void sub_1002A20BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A20DC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CA30, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CA30))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0CA28, kCtLoggingSystemName, "pkt");
    __cxa_guard_release(&qword_101B0CA30);
  }
}

void sub_1002A215C(_Unwind_Exception *a1)
{
}

void ResetAllPacketHandlersAPNs(Registry *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = 0;
  BOOL v9 = 0;
  sub_1003BEF68(a1, &v8);
  if (v8)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 776))(v8);
    ResetAllPacketHandlersAPNs(v6, (uint64_t)a1, a2, a3);
  }
  uint64_t v7 = v9;
  if (v9)
  {
    sub_10004D2C8(v7);
  }
}

void sub_1002A2228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002A2240(Registry *a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1);
  uint64_t v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    long long v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v13);
  if (v7)
  {
    BOOL v9 = (RegistrationInterface *)v7[3];
    uint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    BOOL v9 = 0;
  }
  std::mutex::unlock(v2);
  uint64_t v8 = 0;
  char v10 = 1;
LABEL_9:
  int RadioAccessTechnology = RegistrationInterface::getRadioAccessTechnology(v9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
  return (RadioAccessTechnology - 6) < 0xFFFFFFFD;
}

void sub_1002A232C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A2348(Registry *a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1);
  long long v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unsigned int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v5;
  BOOL v9 = sub_10004D37C(&v4[1].__m_.__sig, &v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    char v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    char v10 = 0;
  }
  std::mutex::unlock(v4);
  *a2 = v11;
  a2[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

uint64_t *sub_1002A2410(uint64_t a1)
{
  sub_100C62700(a1, "kPacketGetProperty", (unint64_t)sub_1002A29B4, 1u);
  sub_100C62630(a1, "kICloudAccountReset", (unint64_t)sub_1002A3A30, 3u);
  sub_100C62700(a1, "kPacketContextName", (unint64_t)sub_1002A3B58, 1u);
  sub_100C62630(a1, "kPacketSetActiveById", (unint64_t)sub_1002A3F64, 1u);
  sub_100C62700(a1, "kPacketGetActiveById", (unint64_t)sub_1002A445C, 1u);
  sub_100C62630(a1, "kPacketSetActiveByService", (unint64_t)sub_1002A46DC, 1u);
  sub_100C62700(a1, "kPacketGetActiveByService", (unint64_t)sub_1002A4BC8, 1u);
  sub_100C62700(a1, "kPacketGetDataLoadInfo", (unint64_t)sub_1002A4F90, 3u);
  sub_100C62630(a1, "kPacketSetProtocolActiveByInterface", (unint64_t)sub_1002A51AC, 1u);
  sub_100C62630(a1, "kPacketSetProtocolActiveByService", (unint64_t)sub_1002A56D4, 1u);
  sub_100C62700(a1, "kGetDataServiceAvailability", (unint64_t)sub_1002A5BB0, 1u);
  sub_100C62700(a1, "kDataServiceOverPublicInternet", (unint64_t)sub_1002A6054, 1u);
  sub_100C62700(a1, "kNATTKeepAliveOverCell", (unint64_t)sub_1002A6350, 1u);
  sub_100C62700(a1, "kPacketGetInterfaceFamilyStatus", (unint64_t)sub_1002A65D8, 1u);
  sub_100C62700(a1, "kPacketStatisticsByID", (unint64_t)sub_1002A6940, 3u);
  sub_100C62630(a1, "kPacketResetStatisticsByID", (unint64_t)sub_1002A6D10, 3u);
  sub_100C62630(a1, "kPacketResetSettingsByID", (unint64_t)sub_1002A71A4, 3u);
  sub_100C62630(a1, "kPacketSuspendSettingsByID", (unint64_t)sub_1002A74F0, 3u);
  sub_100C62630(a1, "kPacketResumeSettingsByID", (unint64_t)sub_1002A76E4, 3u);
  sub_100C62630(a1, "kPacketSetProperty", (unint64_t)sub_1002A78D8, 3u);
  sub_100C62700(a1, "kPacketSetPropertyWithReply", (unint64_t)sub_1002A7FB8, 3u);
  sub_100C62700(a1, "kQOSRequest", (unint64_t)sub_1002A8940, 1u);
  sub_100C62700(a1, "kPacketCreateTetheringAssertion", (unint64_t)sub_1002A8BD4, 3u);
  sub_100C62630(a1, "kPacketCreateDormancySuspendAssertion", (unint64_t)sub_1002A8F4C, 3u);
  sub_100C62700(a1, "kPacketCreateOTAActivationAssertion", (unint64_t)sub_1002A9338, 3u);
  sub_100C62700(a1, "kPacketCreatePDPAssertion", (unint64_t)sub_1002A964C, 1u);
  sub_100C62700(a1, "kPacketCreateDataActivationPopupAssertion", (unint64_t)sub_1002A9A98, 3u);
  sub_100C62630(a1, "kQOSRelease", (unint64_t)sub_1002AA070, 1u);
  sub_100C62630(a1, "kPacketFilter", (unint64_t)sub_1002AA244, 1u);
  sub_100C62630(a1, "kDropIPPackets", (unint64_t)sub_1002AA4C8, 1u);
  sub_100C62700(a1, "kGetDataStatus", (unint64_t)sub_1002AA6EC, 1u);
  sub_100C62700(a1, "kPacketCopyAssertion", (unint64_t)sub_1002AAAA4, 0x18u);
  sub_100C62630(a1, "kUpdateQualityOfService", (unint64_t)sub_1002AADA8, 1u);
  sub_100C62700(a1, "kPacketCreateKeepAliveAssertion", (unint64_t)sub_1002AB014, 3u);
  sub_100C62630(a1, "kSetEMBMSActive", (unint64_t)sub_1002AB2F4, 3u);
  sub_100C62700(a1, "kGetEMBMSStatus", (unint64_t)sub_1002AB7D0, 3u);
  sub_100C62700(a1, "kGetEMBMSSigInfo", (unint64_t)sub_1002AB9FC, 3u);
  sub_100C62700(a1, "kGetEMBMSSAIListInfo", (unint64_t)sub_1002ABD34, 3u);

  return sub_100C62700(a1, "kSetEMBMSSAIInterestedInfo", (unint64_t)sub_1002AC014, 3u);
}

void sub_1002A29B4(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t *a5)
{
  value = (capabilities::ct *)xpc_dictionary_get_value(*a4, "kPacketContextCount");
  if (value)
  {
    int64_t v9 = capabilities::ct::supportedPDPContextCount(value);
    sub_1002A20DC();
    char v10 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "kPacketGetProperty";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "kPacketContextCount";
      *(_WORD *)&unsigned char buf[22] = 2048;
      int64_t v93 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Getting %s of type %s with result %zu", buf, 0x20u);
    }
    xpc_object_t v90 = xpc_int64_create(v9);
    if (!v90) {
      xpc_object_t v90 = xpc_null_create();
    }
    *(void *)std::string buf = *a5;
    *(void *)&uint8_t buf[8] = "kPacketContextCount";
    sub_100035E70((uint64_t)buf, &v90, &v91);
    xpc_release(v91);
    xpc_object_t v91 = 0;
    xpc_release(v90);
    return;
  }
  if (xpc_dictionary_get_value(*a4, "kPacketDormancy"))
  {
    *(void *)std::string buf = 2048;
    if (IsTelephonyRunningExtended(buf))
    {
      sub_100068A94(buf);
      unsigned int v11 = (*(uint64_t (**)(void))(**(void **)buf + 296))(*(void *)buf);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      int64_t v12 = v11;
    }
    else
    {
      int64_t v12 = 0;
    }
    xpc_object_t v88 = xpc_int64_create(v12);
    if (!v88) {
      xpc_object_t v88 = xpc_null_create();
    }
    *(void *)std::string buf = *a5;
    *(void *)&uint8_t buf[8] = "kPacketDormancy";
    sub_100035E70((uint64_t)buf, &v88, &v89);
    xpc_release(v89);
    xpc_object_t v89 = 0;
    xpc_release(v88);
    return;
  }
  if (xpc_dictionary_get_value(*a4, "kEnableCellularData"))
  {
    sub_1002A20DC();
    unint64_t v13 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Calling _CTGetCellularDataIsEnabled()", buf, 2u);
    }
    *(void *)std::string buf = 2048;
    if (!IsTelephonyRunningExtended(buf))
    {
      unsigned int v39 = 0;
      goto LABEL_49;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    char v15 = ServiceMap;
    if (v16 < 0)
    {
      uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        uint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v16;
    id v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
    if (v20)
    {
      uint64_t v22 = v20[3];
      unint64_t v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
LABEL_46:
        if (!v22)
        {
          unsigned int v39 = 0;
          if (v23) {
            goto LABEL_49;
          }
          goto LABEL_48;
        }
        unsigned int v39 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 696))(v22);
        if ((v23 & 1) == 0) {
LABEL_48:
        }
          sub_10004D2C8(v21);
LABEL_49:
        xpc_object_t v86 = xpc_int64_create(v39);
        if (!v86) {
          xpc_object_t v86 = xpc_null_create();
        }
        *(void *)std::string buf = *a5;
        *(void *)&uint8_t buf[8] = "kEnableCellularData";
        sub_100035E70((uint64_t)buf, &v86, &v87);
        xpc_release(v87);
        xpc_object_t v87 = 0;
        xpc_release(v86);
        return;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    unint64_t v21 = 0;
    char v23 = 1;
    goto LABEL_46;
  }
  if (xpc_dictionary_get_value(*a4, "kCellularDataEnabled")
    && xpc_dictionary_get_value(*a4, "kCellularDataCapable")
    && xpc_dictionary_get_value(*a4, "kAirplaneMode"))
  {
    sub_1002A20DC();
    unsigned int v24 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Calling _CTGetCellularDataSettings()", buf, 2u);
    }
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_1002A1B14(*a1, buf);
    LOBYTE(v25) = buf[0];
    if (*(void *)buf)
    {
      char v26 = (*(uint64_t (**)(void))(**(void **)buf + 664))(*(void *)buf);
      char v27 = (*(uint64_t (**)(void))(**(void **)buf + 672))(*(void *)buf);
      uint64_t v82 = 2048;
      int v25 = IsTelephonyRunningExtended(&v82);
      if (v25) {
        LOBYTE(v25) = (*(uint64_t (**)(void))(**(void **)buf + 696))(*(void *)buf);
      }
    }
    else
    {
      char v26 = 0;
      char v27 = 0;
    }
    xpc_object_t v84 = xpc_BOOL_create(v25);
    if (!v84) {
      xpc_object_t v84 = xpc_null_create();
    }
    uint64_t v82 = *a5;
    BOOL v83 = (std::__shared_weak_count *)"kCellularDataEnabled";
    sub_100035E70((uint64_t)&v82, &v84, &v85);
    xpc_release(v85);
    xpc_object_t v85 = 0;
    xpc_release(v84);
    xpc_object_t v84 = 0;
    xpc_object_t v80 = xpc_BOOL_create(v27);
    if (!v80) {
      xpc_object_t v80 = xpc_null_create();
    }
    uint64_t v82 = *a5;
    BOOL v83 = (std::__shared_weak_count *)"kCellularDataCapable";
    sub_100035E70((uint64_t)&v82, &v80, &v81);
    xpc_release(v81);
    xpc_object_t v81 = 0;
    xpc_release(v80);
    xpc_object_t v80 = 0;
    xpc_object_t v78 = xpc_BOOL_create(v26);
    if (!v78) {
      xpc_object_t v78 = xpc_null_create();
    }
    uint64_t v82 = *a5;
    BOOL v83 = (std::__shared_weak_count *)"kAirplaneMode";
    sub_100035E70((uint64_t)&v82, &v78, &v79);
    xpc_release(v79);
    xpc_object_t v79 = 0;
    xpc_release(v78);
    xpc_object_t v78 = 0;
    goto LABEL_87;
  }
  if (!xpc_dictionary_get_value(*a4, "kEnableCellularDataEx"))
  {
    if (xpc_dictionary_get_value(*a4, "kCellularDataHideIndicator"))
    {
      sub_1002A20DC();
      unint64_t v40 = qword_101B0CA28;
      if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionHideDataIndicator()", buf, 2u);
      }
      *(void *)std::string buf = 2048;
      if (IsTelephonyRunningExtended(buf))
      {
        sub_100058DB0(&__p, "/cc/props/cellular_data_hide_indicator");
        v72[1] = _NSConcreteStackBlock;
        v72[2] = (xpc_object_t)1174405120;
        v72[3] = sub_1002AC4F8;
        v72[4] = &unk_1019B35E0;
        int64_t v41 = (std::__shared_weak_count *)a5[1];
        v72[5] = (xpc_object_t)*a5;
        long long v73 = v41;
        if (v41) {
          atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        ctu::RestModule::getPropertyOnce();
        if (v75 < 0) {
          operator delete(__p);
        }
        uint64_t v42 = v73;
        if (v73) {
          goto LABEL_88;
        }
      }
      else
      {
        xpc_object_t v71 = xpc_BOOL_create(0);
        if (!v71) {
          xpc_object_t v71 = xpc_null_create();
        }
        *(void *)std::string buf = *a5;
        *(void *)&uint8_t buf[8] = "kCellularDataHideIndicator";
        sub_100035E70((uint64_t)buf, &v71, v72);
        xpc_release(v72[0]);
        v72[0] = 0;
        xpc_release(v71);
      }
    }
    else if (xpc_dictionary_get_value(*a4, "kCellularDataHideRatIndicator"))
    {
      sub_1002A20DC();
      std::string::size_type v44 = qword_101B0CA28;
      if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionHideRatIndicator()", buf, 2u);
      }
      xpc_object_t v69 = xpc_BOOL_create(0);
      if (!v69) {
        xpc_object_t v69 = xpc_null_create();
      }
      *(void *)std::string buf = *a5;
      *(void *)&uint8_t buf[8] = "kCellularDataHideRatIndicator";
      sub_100035E70((uint64_t)buf, &v69, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v69);
    }
    else if (xpc_dictionary_get_value(*a4, "kCellularDataDisallow"))
    {
      if (byte_101B13D88 == 1 && IsTelephonyRunningExtended(&qword_101B13D90))
      {
        sub_1002A20DC();
        uint64_t v45 = qword_101B0CA28;
        if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Calling _CTGetCellularDataIsDisallowed()", buf, 2u);
        }
        uint64_t v82 = 0;
        BOOL v83 = 0;
        sub_1002A1B14(*a1, &v82);
        if (v82)
        {
          memset(buf, 0, sizeof(buf));
          int64_t v46 = (*(unsigned int (**)(uint64_t, uint8_t *))(*(void *)v82 + 520))(v82, buf);
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          int64_t v46 = 0;
        }
        if (v83) {
          sub_10004D2C8(v83);
        }
      }
      else
      {
        int64_t v46 = 0;
      }
      xpc_object_t v67 = xpc_int64_create(v46);
      if (!v67) {
        xpc_object_t v67 = xpc_null_create();
      }
      *(void *)std::string buf = *a5;
      *(void *)&uint8_t buf[8] = "kCellularDataDisallow";
      sub_100035E70((uint64_t)buf, &v67, &v68);
      xpc_release(v68);
      xpc_object_t v68 = 0;
      xpc_release(v67);
    }
    else
    {
      if (xpc_dictionary_get_value(*a4, "kTetheringEditing"))
      {
        sub_1002A20DC();
        uint64_t v47 = qword_101B0CA28;
        if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Calling server_CTIsTetheringEditingSupported()", buf, 2u);
        }
        *(void *)std::string buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        sub_1002A1B14(*a1, buf);
        uint64_t v48 = *(capabilities::ct **)buf;
        if (*(void *)buf)
        {
          uint64_t v48 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)buf + 776))(*(void *)buf);
          uint64_t v49 = (uint64_t)v48;
        }
        else
        {
          uint64_t v49 = 1;
        }
        unsigned int v56 = capabilities::ct::supportsWirelessModem(v48);
        if (v56) {
          unsigned int v56 = sub_100C9AB68(a1, v49);
        }
        xpc_object_t v65 = xpc_int64_create(v56);
        if (!v65) {
          xpc_object_t v65 = xpc_null_create();
        }
        uint64_t v82 = *a5;
        BOOL v83 = (std::__shared_weak_count *)"kTetheringEditing";
        sub_100035E70((uint64_t)&v82, &v65, &v66);
        xpc_release(v66);
        xpc_object_t v66 = 0;
        xpc_release(v65);
        xpc_object_t v65 = 0;
LABEL_87:
        uint64_t v42 = *(std::__shared_weak_count **)&buf[8];
        if (!*(void *)&buf[8]) {
          return;
        }
        goto LABEL_88;
      }
      if (xpc_dictionary_get_value(*a4, "kCellularAccountReset"))
      {
        *(void *)std::string buf = 4096;
        if (IsTelephonyRunningExtended(buf))
        {
          sub_1002A20DC();
          BOOL v50 = qword_101B0CA28;
          if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Calling server_CTGetResetCellularAccountSettingsIsAllowed()", buf, 2u);
          }
          uint64_t v82 = 0;
          BOOL v83 = 0;
          sub_1002A2348(*a1, &v82);
          uint64_t v63 = 0;
          int v64 = 0;
          sub_1002A1B14(*a1, &v63);
          if (v63)
          {
            int v51 = (*(uint64_t (**)(uint64_t))(*(void *)v63 + 280))(v63);
            sub_1002A20DC();
            uint64_t v52 = qword_101B0CA28;
            if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = "kPacketGetProperty";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v51;
              _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%s: Querying data plan expired from lastActivateError: %d", buf, 0x12u);
            }
            BOOL v53 = sub_1002A2240(*a1);
            BOOL v54 = !v53
               && ((capabilities::ct::supportsVoiceCall((capabilities::ct *)v53) | v51 ^ 1) & 1) == 0
               && (RegistrationInterface::getRegistrationStatus((RegistrationInterface *)v82) == 4
                || RegistrationInterface::getRegistrationStatus((RegistrationInterface *)v82) == 5);
            uint64_t v55 = (capabilities::ct *)sub_100A6DCC0(a1);
            if (v55 && !capabilities::ct::supportsVoiceCall(v55)) {
              BOOL v54 = 1;
            }
          }
          else
          {
            BOOL v54 = 0;
          }
          if (v64) {
            sub_10004D2C8(v64);
          }
          if (v83) {
            sub_10004D2C8(v83);
          }
        }
        else
        {
          BOOL v54 = 0;
        }
        xpc_object_t v61 = xpc_int64_create(v54);
        if (!v61) {
          xpc_object_t v61 = xpc_null_create();
        }
        *(void *)std::string buf = *a5;
        *(void *)&uint8_t buf[8] = "kCellularAccountReset";
        sub_100035E70((uint64_t)buf, &v61, &v62);
        xpc_release(v62);
        xpc_object_t v62 = 0;
        xpc_release(v61);
      }
      else if (xpc_dictionary_get_value(*a4, "kMTU"))
      {
        *(void *)std::string buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        sub_1002A1B14(*a1, buf);
        if (*(void *)buf)
        {
          (*(void (**)(uint64_t *__return_ptr))(**(void **)buf + 920))(&v82);
          uint64_t v57 = v82;
          uint64_t v36 = v83;
        }
        else
        {
          uint64_t v57 = 0;
          uint64_t v36 = 0;
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v57) {
          unsigned int v58 = (*(uint64_t (**)(uint64_t))(*(void *)v57 + 32))(v57);
        }
        else {
          unsigned int v58 = 0;
        }
        xpc_object_t v59 = xpc_int64_create(v58);
        if (!v59) {
          xpc_object_t v59 = xpc_null_create();
        }
        *(void *)std::string buf = *a5;
        *(void *)&uint8_t buf[8] = "kMTU";
        sub_100035E70((uint64_t)buf, &v59, &v60);
        xpc_release(v60);
        xpc_object_t v60 = 0;
        xpc_release(v59);
        xpc_object_t v59 = 0;
        if (v36) {
          goto LABEL_72;
        }
      }
    }
    return;
  }
  sub_1002A20DC();
  char v28 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Calling _CTGetCellularDataIsEnabledEx()", buf, 2u);
  }
  long long v29 = (std::mutex *)Registry::getServiceMap(*a1);
  id v30 = v29;
  if (v31 < 0)
  {
    uint64_t v32 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v33 = 5381;
    do
    {
      uint64_t v31 = v33;
      unsigned int v34 = *v32++;
      uint64_t v33 = (33 * v33) ^ v34;
    }
    while (v34);
  }
  std::mutex::lock(v29);
  *(void *)std::string buf = v31;
  id v35 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)buf);
  if (v35)
  {
    uint64_t v37 = v35[3];
    uint64_t v36 = (std::__shared_weak_count *)v35[4];
    if (v36)
    {
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v30);
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v36);
      char v38 = 0;
      goto LABEL_66;
    }
  }
  else
  {
    uint64_t v37 = 0;
  }
  std::mutex::unlock(v30);
  uint64_t v36 = 0;
  char v38 = 1;
LABEL_66:
  if (v37)
  {
    v76[0] = _NSConcreteStackBlock;
    v76[1] = 1174405120;
    v76[2] = sub_1002AC314;
    v76[3] = &unk_1019B35B0;
    char v43 = (std::__shared_weak_count *)a5[1];
    v76[4] = *a5;
    long long v77 = v43;
    if (v43) {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v37 + 16))(v37, v76);
    if (v77) {
      sub_10004D2C8(v77);
    }
  }
  if ((v38 & 1) == 0)
  {
LABEL_72:
    uint64_t v42 = v36;
LABEL_88:
    sub_10004D2C8(v42);
  }
}

void sub_1002A3888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1002A3A30(Registry **a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  char v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    long long v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v11 = v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v11);
  if (!v7)
  {
    uint64_t v9 = 0;
LABEL_9:
    std::mutex::unlock(v2);
    unsigned int v8 = 0;
    char v10 = 1;
    if (!v9) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v9 = v7[3];
  unsigned int v8 = (std::__shared_weak_count *)v7[4];
  if (!v8) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v2);
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  char v10 = 0;
  if (v9) {
LABEL_10:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 80))(v9);
LABEL_11:
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
}

void sub_1002A3B38(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A3B58(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  if (xpc_dictionary_get_value(*a4, "kPacketContextIdentifer"))
  {
    *(void *)std::string buf = a4;
    *(void *)&uint8_t buf[8] = "kPacketContextIdentifer";
    sub_100048BAC((uint64_t)buf, object);
    int v9 = xpc::dyn_cast_or_default((xpc *)object, 0, v8);
    xpc_release(object[0]);
  }
  else
  {
    int v9 = -1;
  }
  if (!xpc_dictionary_get_value(*a4, "kPacketServiceType")) {
    goto LABEL_17;
  }
  *(void *)std::string buf = a4;
  *(void *)&uint8_t buf[8] = "kPacketServiceType";
  sub_100048BAC((uint64_t)buf, object);
  uint64_t v11 = xpc::dyn_cast_or_default((xpc *)object, 0, v10);
  xpc_release(object[0]);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v13 = ServiceMap;
  if (v14 < 0)
  {
    char v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v14;
  uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
  if (!v18)
  {
    uint64_t v20 = 0;
LABEL_13:
    std::mutex::unlock(v13);
    unsigned int v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v20 = v18[3];
  unsigned int v19 = (std::__shared_weak_count *)v18[4];
  if (!v19) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  char v21 = 0;
  if (v20)
  {
LABEL_14:
    uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 776))(v20);
    int v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 256))(v20, v22, v11);
  }
LABEL_15:
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
LABEL_17:
  object[0] = 0;
  object[1] = 0;
  uint64_t v30 = 0;
  if (CSIPDPManager::getInterfaceNameById())
  {
    sub_1002A20DC();
    char v23 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v24 = object;
      if (v30 < 0) {
        unsigned int v24 = (xpc_object_t *)object[0];
      }
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = "kPacketContextName";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "kPacketContextIdentifer";
      __int16 v32 = 1024;
      int v33 = v9;
      __int16 v34 = 2080;
      id v35 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%s: %s PDP Context %d name is %s", buf, 0x26u);
    }
    if (v30 >= 0) {
      int v25 = object;
    }
    else {
      int v25 = (xpc_object_t *)object[0];
    }
    xpc_object_t v27 = xpc_string_create((const char *)v25);
    if (!v27) {
      xpc_object_t v27 = xpc_null_create();
    }
    *(void *)std::string buf = *a5;
    *(void *)&uint8_t buf[8] = "kPacketContextName";
    sub_100035E70((uint64_t)buf, &v27, &v28);
    xpc_release(v28);
    xpc_object_t v28 = 0;
    xpc_release(v27);
    xpc_object_t v27 = 0;
  }
  else
  {
    sub_1002A20DC();
    char v26 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, " Getting PDP Context %d name not possible returning name is invalid", buf, 8u);
    }
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(object[0]);
  }
}

void sub_1002A3ED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A3F64(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  sub_1002A20DC();
  unsigned int v6 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "CALL TO OBSOLETE API PacketSetActiveById, should use CoreTelephonyClient+Data.h API", buf, 2u);
  }
  if (xpc_dictionary_get_value(*a4, "kPacketContextIdentifer"))
  {
    *(void *)std::string buf = a4;
    *(void *)&uint8_t buf[8] = "kPacketContextIdentifer";
    sub_100048BAC((uint64_t)buf, &object);
    int v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
    xpc_release(object);
    if (v8)
    {
      sub_1002A20DC();
      int v9 = qword_101B0CA28;
      if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v8;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid PDP Context %d specified", buf, 8u);
      }
      return;
    }
    *(void *)std::string buf = a4;
    *(void *)&uint8_t buf[8] = "kPacketStatus";
    sub_100048BAC((uint64_t)buf, &object);
    int v11 = xpc::dyn_cast_or_default((xpc *)&object, 0, v10);
    xpc_release(object);
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    unint64_t v13 = ServiceMap;
    if (v14 < 0)
    {
      char v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        uint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v14;
    uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
    if (v18)
    {
      uint64_t v20 = v18[3];
      unsigned int v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
        if (!v20)
        {
LABEL_37:
          if ((v21 & 1) == 0) {
            sub_10004D2C8(v19);
          }
          return;
        }
LABEL_16:
        uint64_t v51 = 0;
        long long v49 = 0u;
        long long v50 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v45 = 0u;
        long long v46 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v40 = 0u;
        long long v38 = 0u;
        *(_OWORD *)unsigned int v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        *(_OWORD *)std::string buf = 0u;
        sub_10004DE24((uint64_t)buf);
        sub_10004B96C(buf, (uint64_t)"Client [", 8);
        xpc_object_t object = 0;
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        sub_100C663EC(a4, (uint64_t)&object);
        uint64_t v22 = HIBYTE(v34);
        char v23 = HIBYTE(v34);
        uint64_t v24 = v33;
        if (v34 >= 0) {
          uint64_t v25 = HIBYTE(v34);
        }
        else {
          uint64_t v25 = v33;
        }
        if (!v25)
        {
          if (SHIBYTE(v34) < 0)
          {
            uint64_t v33 = 9;
            p_xpc_object_t object = (char *)object;
          }
          else
          {
            HIBYTE(v34) = 9;
            p_xpc_object_t object = (char *)&object;
          }
          strcpy(p_object, "<unknown>");
          uint64_t v22 = HIBYTE(v34);
          uint64_t v24 = v33;
          char v23 = HIBYTE(v34);
        }
        if (v23 >= 0) {
          xpc_object_t v27 = &object;
        }
        else {
          xpc_object_t v27 = object;
        }
        if (v23 >= 0) {
          uint64_t v28 = v22;
        }
        else {
          uint64_t v28 = v24;
        }
        long long v29 = sub_10004B96C(buf, (uint64_t)v27, v28);
        sub_10004B96C(v29, (uint64_t)"] via xpc:kPacketSetActiveById", 30);
        sub_10004BC98((uint64_t)&buf[8], __p);
        (*(void (**)(uint64_t, BOOL, void **))(*(void *)v20 + 56))(v20, v11 != 0, __p);
        if (v31 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v34) < 0) {
          operator delete(object);
        }
        if (SHIBYTE(v40) < 0) {
          operator delete(v39[1]);
        }
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        std::ios::~ios();
        goto LABEL_37;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    unsigned int v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_37;
    }
    goto LABEL_16;
  }
}

void sub_1002A43B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t object, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(object);
  }
  sub_1000C937C((uint64_t)&a23);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(a1);
}

void sub_1002A445C(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  sub_1002A20DC();
  int v8 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "CALL TO OBSOLETE API kPacketGetActiveById", buf, 2u);
  }
  if (xpc_dictionary_get_value(*a4, "kPacketContextIdentifer"))
  {
    sub_1002A20DC();
    int v9 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionGetPacketContextActive()", buf, 2u);
    }
    *(void *)std::string buf = a4;
    char v26 = "kPacketContextIdentifer";
    sub_100048BAC((uint64_t)buf, &object);
    uint64_t v11 = xpc::dyn_cast_or_default((xpc *)&object, 0, v10);
    xpc_release(object);
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    unint64_t v13 = ServiceMap;
    if (v14 < 0)
    {
      char v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        uint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v14;
    uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
    if (v18)
    {
      uint64_t v20 = v18[3];
      unsigned int v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
        if (!v20)
        {
LABEL_18:
          if ((v21 & 1) == 0) {
            sub_10004D2C8(v19);
          }
          return;
        }
LABEL_15:
        unsigned int v22 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v20 + 296))(v20, v11);
        xpc_object_t v23 = xpc_int64_create(v22);
        if (!v23) {
          xpc_object_t v23 = xpc_null_create();
        }
        *(void *)std::string buf = *a5;
        char v26 = "kPacketStatus";
        sub_100035E70((uint64_t)buf, &v23, &v24);
        xpc_release(v24);
        xpc_object_t v24 = 0;
        xpc_release(v23);
        xpc_object_t v23 = 0;
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    unsigned int v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_18;
    }
    goto LABEL_15;
  }
}

void sub_1002A46A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A46DC(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  *(void *)std::string buf = a4;
  *(void *)&uint8_t buf[8] = "kPacketServiceType";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v7 = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
  xpc_release(object);
  *(void *)std::string buf = a4;
  *(void *)&uint8_t buf[8] = "kPacketStatus";
  sub_100048BAC((uint64_t)buf, &object);
  char v9 = xpc::dyn_cast_or_default((xpc *)&object, 0, v8);
  xpc_release(object);
  sub_1002A20DC();
  int v10 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionSetPacketContextActiveByServiceType() = %llu", buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  int64_t v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v13;
  unsigned int v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (v17)
  {
    uint64_t v19 = v17[3];
    uint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      if (!v19) {
        goto LABEL_33;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v18 = 0;
  char v20 = 1;
  if (!v19) {
    goto LABEL_33;
  }
LABEL_12:
  uint64_t v51 = 0;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v40 = 0u;
  long long v38 = 0u;
  *(_OWORD *)unsigned int v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  *(_OWORD *)std::string buf = 0u;
  sub_10004DE24((uint64_t)buf);
  sub_10004B96C(buf, (uint64_t)"Client [", 8);
  xpc_object_t object = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  sub_100C663EC(a4, (uint64_t)&object);
  uint64_t v21 = HIBYTE(v34);
  char v22 = HIBYTE(v34);
  uint64_t v23 = v33;
  if (v34 >= 0) {
    uint64_t v24 = HIBYTE(v34);
  }
  else {
    uint64_t v24 = v33;
  }
  if (!v24)
  {
    if (SHIBYTE(v34) < 0)
    {
      uint64_t v33 = 9;
      p_xpc_object_t object = (char *)object;
    }
    else
    {
      HIBYTE(v34) = 9;
      p_xpc_object_t object = (char *)&object;
    }
    strcpy(p_object, "<unknown>");
    uint64_t v21 = HIBYTE(v34);
    uint64_t v23 = v33;
    char v22 = HIBYTE(v34);
  }
  if (v22 >= 0) {
    char v26 = &object;
  }
  else {
    char v26 = object;
  }
  if (v22 >= 0) {
    uint64_t v27 = v21;
  }
  else {
    uint64_t v27 = v23;
  }
  uint64_t v28 = sub_10004B96C(buf, (uint64_t)v26, v27);
  sub_10004B96C(v28, (uint64_t)"] via xpc:kPacketSetActiveByService", 35);
  uint64_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 776))(v19);
  sub_10004BC98((uint64_t)&buf[8], __p);
  (*(void (**)(uint64_t, uint64_t, uint64_t, BOOL, void **, void, void))(*(void *)v19 + 80))(v19, v29, v7, v9 != 0, __p, 0, 0);
  if (v31 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v34) < 0) {
    operator delete(object);
  }
  if (SHIBYTE(v40) < 0) {
    operator delete(v39[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
LABEL_33:
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
}

void sub_1002A4B24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t object, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(object);
  }
  sub_1000C937C((uint64_t)&a23);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(a1);
}

void sub_1002A4BC8(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  *(void *)std::string buf = a4;
  long long v36 = "kPacketServiceType";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v9 = xpc::dyn_cast_or_default((xpc *)&object, 0, v8);
  xpc_release(object);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v12;
  unsigned int v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (v16)
  {
    uint64_t v18 = v16[3];
    unsigned int v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      if (!v18) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  unsigned int v17 = 0;
  char v19 = 1;
  if (!v18)
  {
LABEL_7:
    int64_t v20 = 0;
    LODWORD(v21) = -2;
    int v22 = 2;
    if (v19) {
      goto LABEL_16;
    }
LABEL_15:
    sub_10004D2C8(v17);
    goto LABEL_16;
  }
LABEL_11:
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
  xpc_object_t v24 = remote_connection;
  if (remote_connection) {
    xpc_retain(remote_connection);
  }
  else {
    xpc_object_t v24 = xpc_null_create();
  }
  uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)v18 + 776))(v18);
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18 + 232))(v18, v25, v9);
  int v22 = v26;
  xpc_release(v24);
  int64_t v20 = BYTE4(v21);
  if ((v19 & 1) == 0) {
    goto LABEL_15;
  }
LABEL_16:
  sub_1002A20DC();
  uint64_t v27 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionGetPacketContextActiveByServiceType(): context id is %d", buf, 8u);
  }
  xpc_object_t v32 = xpc_int64_create((int)v21);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  long long v36 = "kPacketContextIdentifer";
  sub_100035E70((uint64_t)buf, &v32, &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_object_t v30 = xpc_int64_create(v20);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  long long v36 = "kPacketStatus";
  sub_100035E70((uint64_t)buf, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_object_t v28 = xpc_int64_create(v22);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  long long v36 = "kPacketContextType";
  sub_100035E70((uint64_t)buf, &v28, &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v28);
}

void sub_1002A4EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A4F90(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_15;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
  if (!v14) {
    goto LABEL_15;
  }
LABEL_10:
  int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 240))(v14);
  sub_1002A20DC();
  unsigned int v17 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionGetPacketDataLoadInfo(): activateQueueSize %d", buf, 8u);
  }
  xpc_object_t v18 = xpc_int64_create(v16);
  if (!v18) {
    xpc_object_t v18 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  uint64_t v21 = "kPacketActivateQueueSize";
  sub_100035E70((uint64_t)buf, &v18, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v18);
  xpc_object_t v18 = 0;
LABEL_15:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_1002A516C(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1002A51AC(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  sub_1002A20DC();
  unint64_t v6 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "CALL TO OBSOLETE API PacketSetProtocolActiveByInterface, should use CoreTelephonyClient+Data.h API", buf, 2u);
  }
  *(void *)std::string buf = a4;
  *(void *)&uint8_t buf[8] = "kPacketContextIdentifer";
  sub_100048BAC((uint64_t)buf, &object);
  int v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
  xpc_release(object);
  if (v8)
  {
    sub_1002A20DC();
    uint64_t v9 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "server_CTSetPacketProtocolActiveByInterface: Invalid PDP Context %d specified", buf, 8u);
    }
    return;
  }
  *(void *)std::string buf = a4;
  *(void *)&uint8_t buf[8] = "kPacketStatus";
  sub_100048BAC((uint64_t)buf, &object);
  int v11 = xpc::dyn_cast_or_default((xpc *)&object, 0, v10);
  xpc_release(object);
  sub_1002A20DC();
  uint64_t v12 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionSetPacketProtocolActiveByInterface()", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v14 = ServiceMap;
  if (v15 < 0)
  {
    int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v15;
  char v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
  if (!v19)
  {
    uint64_t v21 = 0;
LABEL_16:
    std::mutex::unlock(v14);
    int64_t v20 = 0;
    char v22 = 1;
    if (!v21) {
      goto LABEL_38;
    }
LABEL_17:
    uint64_t v52 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v41 = 0u;
    long long v39 = 0u;
    *(_OWORD *)long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    *(_OWORD *)std::string buf = 0u;
    sub_10004DE24((uint64_t)buf);
    sub_10004B96C(buf, (uint64_t)"Client [", 8);
    xpc_object_t object = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    sub_100C663EC(a4, (uint64_t)&object);
    uint64_t v23 = HIBYTE(v35);
    char v24 = HIBYTE(v35);
    uint64_t v25 = v34;
    if (v35 >= 0) {
      uint64_t v26 = HIBYTE(v35);
    }
    else {
      uint64_t v26 = v34;
    }
    if (!v26)
    {
      if (SHIBYTE(v35) < 0)
      {
        uint64_t v34 = 9;
        p_xpc_object_t object = (char *)object;
      }
      else
      {
        HIBYTE(v35) = 9;
        p_xpc_object_t object = (char *)&object;
      }
      strcpy(p_object, "<unknown>");
      uint64_t v23 = HIBYTE(v35);
      uint64_t v25 = v34;
      char v24 = HIBYTE(v35);
    }
    if (v24 >= 0) {
      xpc_object_t v28 = &object;
    }
    else {
      xpc_object_t v28 = object;
    }
    if (v24 >= 0) {
      uint64_t v29 = v23;
    }
    else {
      uint64_t v29 = v25;
    }
    xpc_object_t v30 = sub_10004B96C(buf, (uint64_t)v28, v29);
    sub_10004B96C(v30, (uint64_t)"] via xpc:kPacketSetProtocolActiveByInterface", 45);
    sub_10004BC98((uint64_t)&buf[8], __p);
    (*(void (**)(uint64_t, BOOL, void **))(*(void *)v21 + 56))(v21, v11 != 0, __p);
    if (v32 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(object);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[1]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    goto LABEL_38;
  }
  uint64_t v21 = v19[3];
  int64_t v20 = (std::__shared_weak_count *)v19[4];
  if (!v20) {
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v14);
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  char v22 = 0;
  if (v21) {
    goto LABEL_17;
  }
LABEL_38:
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
}

void sub_1002A5630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t object, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(object);
  }
  sub_1000C937C((uint64_t)&a23);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(a1);
}

void sub_1002A56D4(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  *(void *)std::string buf = a4;
  *(void *)&uint8_t buf[8] = "kPacketServiceType";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v7 = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
  xpc_release(object);
  *(void *)std::string buf = a4;
  *(void *)&uint8_t buf[8] = "kPacketStatus";
  sub_100048BAC((uint64_t)buf, &object);
  char v9 = xpc::dyn_cast_or_default((xpc *)&object, 0, v8);
  xpc_release(object);
  sub_1002A20DC();
  int v10 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionSetPacketProtocolActiveByServiceType()", buf, 2u);
  }
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
  if (remote_connection)
  {
    xpc_object_t v12 = remote_connection;
    xpc_retain(remote_connection);
  }
  else
  {
    xpc_object_t v12 = xpc_null_create();
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v14 = ServiceMap;
  if (v15 < 0)
  {
    int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v15;
  char v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
  if (v19)
  {
    uint64_t v21 = v19[3];
    int64_t v20 = (std::__shared_weak_count *)v19[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v22 = 0;
      if (!v21) {
        goto LABEL_36;
      }
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v14);
  int64_t v20 = 0;
  char v22 = 1;
  if (!v21) {
    goto LABEL_36;
  }
LABEL_15:
  uint64_t v53 = 0;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  *(_OWORD *)long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  *(_OWORD *)std::string buf = 0u;
  long long v38 = 0u;
  sub_10004DE24((uint64_t)buf);
  sub_10004B96C(buf, (uint64_t)"Client [", 8);
  xpc_object_t object = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  sub_100C663EC(a4, (uint64_t)&object);
  uint64_t v23 = HIBYTE(v36);
  char v24 = HIBYTE(v36);
  uint64_t v25 = v35;
  if (v36 >= 0) {
    uint64_t v26 = HIBYTE(v36);
  }
  else {
    uint64_t v26 = v35;
  }
  if (!v26)
  {
    if (SHIBYTE(v36) < 0)
    {
      uint64_t v35 = 9;
      p_xpc_object_t object = (char *)object;
    }
    else
    {
      HIBYTE(v36) = 9;
      p_xpc_object_t object = (char *)&object;
    }
    strcpy(p_object, "<unknown>");
    uint64_t v23 = HIBYTE(v36);
    uint64_t v25 = v35;
    char v24 = HIBYTE(v36);
  }
  if (v24 >= 0) {
    xpc_object_t v28 = &object;
  }
  else {
    xpc_object_t v28 = object;
  }
  if (v24 >= 0) {
    uint64_t v29 = v23;
  }
  else {
    uint64_t v29 = v25;
  }
  xpc_object_t v30 = sub_10004B96C(buf, (uint64_t)v28, v29);
  sub_10004B96C(v30, (uint64_t)"] via xpc:kPacketSetProtocolActiveByService", 43);
  uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 776))(v21);
  sub_10004BC98((uint64_t)&buf[8], __p);
  (*(void (**)(uint64_t, uint64_t, uint64_t, BOOL, void **, void, void))(*(void *)v21 + 80))(v21, v31, v7, v9 != 0, __p, 0, 0);
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(object);
  }
  if (SHIBYTE(v42) < 0) {
    operator delete(v41[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
LABEL_36:
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  xpc_release(v12);
}

void sub_1002A5B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, xpc_object_t object, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(object);
  }
  sub_1000C937C((uint64_t)&a21);
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  xpc_release(v21);
  _Unwind_Resume(a1);
}

void sub_1002A5BB0(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void ***a5)
{
  sub_1002A20DC();
  uint64_t v7 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionGetDataServiceAvailability()", buf, 2u);
  }
  xpc_object_t v38 = 0;
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v9 = v8;
  if (v8)
  {
    xpc_object_t v38 = v8;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v38 = v9;
    if (!v9)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v9 = 0;
      goto LABEL_10;
    }
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v9);
    goto LABEL_11;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_10:
  xpc_object_t v38 = v10;
LABEL_11:
  xpc_release(v9);
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  *(_OWORD *)std::string buf = 0u;
  long long v40 = 0u;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&__p);
  if (v17)
  {
    uint64_t v19 = v17[3];
    unsigned int v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      if (!v19) {
        goto LABEL_28;
      }
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  unsigned int v18 = 0;
  char v20 = 1;
  if (!v19) {
    goto LABEL_28;
  }
LABEL_20:
  std::string __p = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 776))(v19);
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v19 + 568))(&__p, v19, v21);
  char v23 = __p;
  char v22 = v36;
  if (v36 == __p)
  {
    LODWORD(v19) = 0;
  }
  else
  {
    uint64_t v24 = 0;
    LODWORD(v19) = 0;
    unsigned int v25 = 1;
    do
    {
      if (!v23[14 * v24])
      {
        *(void *)&buf[8 * v19] = kCTDataConnectionServiceTypeFromIndex();
        LODWORD(v19) = v19 + 1;
        char v23 = __p;
        char v22 = v36;
      }
      uint64_t v24 = v25;
    }
    while (0x6DB6DB6DB6DB6DB7 * ((v22 - (unsigned char *)v23) >> 3) > (unint64_t)v25++);
  }
  p_p = &__p;
  sub_1002AC5A8(&p_p);
LABEL_28:
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  std::string __p = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  ctu::cf::assign();
  CFArrayRef v27 = CFArrayCreate(kCFAllocatorDefault, (const void **)buf, v19, &kCFTypeArrayCallBacks);
  xpc_object_t v33 = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
  if (!v33) {
    xpc_object_t v33 = xpc_null_create();
  }
  xpc_object_t v28 = (const char *)&__p;
  if (v37 < 0) {
    xpc_object_t v28 = (const char *)__p;
  }
  p_p = &v38;
  char v32 = v28;
  sub_100035E70((uint64_t)&p_p, &v33, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_object_t v29 = v38;
  if (v38) {
    xpc_retain(v38);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  p_p = *a5;
  char v32 = "kDataServiceAvailability";
  sub_10014E03C((uint64_t)&p_p, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  CFRelease(v27);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p);
  }
  xpc_release(v38);
}

void sub_1002A5FB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

const void **sub_1002A6054(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  *(void *)std::string buf = a4;
  xpc_object_t v29 = "kPacketServiceType";
  sub_100048BAC((uint64_t)buf, &object);
  int v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
  xpc_release(object);
  xpc_object_t object = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v10 = ServiceMap;
  if (v11 < 0)
  {
    xpc_object_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    unsigned int v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  unsigned int v16 = 0;
  char v18 = 1;
LABEL_9:
  (*(void (**)(xpc_object_t *__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v17 + 32))(&object, v17, kCarrierBundleId, @"AllowedServicesTypeMaskOnInternet", 0, 0);
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  uint64_t v19 = (int *)object;
  *(_DWORD *)std::string buf = 0;
  if (object)
  {
    CFTypeID v20 = CFGetTypeID(object);
    if (v20 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)buf, v19, v21);
      LODWORD(v19) = *(_DWORD *)buf;
    }
    else
    {
      LODWORD(v19) = 0;
    }
  }
  sub_1002A20DC();
  unsigned int v22 = v19 & v8;
  char v23 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v8;
    LOWORD(v29) = 1024;
    *(_DWORD *)((char *)&v29 + 2) = v22 != 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionIsServiceOverPublicInternet() for %d, with result %d", buf, 0xEu);
  }
  xpc_object_t v25 = xpc_BOOL_create(v22 != 0);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  xpc_object_t v29 = "kDataServiceOverPublicInternet";
  sub_100035E70((uint64_t)buf, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  return sub_1000577C4((const void **)&object);
}

void sub_1002A62E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1002A6350(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  int v7 = ServiceMap;
  if (v8 < 0)
  {
    xpc_object_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v8;
  xpc_object_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v14 + 32))(&cf, v14, kCarrierBundleId, @"NATTKeepAliveIntervalOverCell", 0, 0);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  unsigned int v16 = (unsigned int *)cf;
  unsigned int v17 = 110;
  *(_DWORD *)std::string buf = 110;
  if (cf)
  {
    CFTypeID v18 = CFGetTypeID(cf);
    if (v18 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)buf, v16, v19);
      unsigned int v17 = *(_DWORD *)buf;
    }
    else
    {
      unsigned int v17 = 110;
    }
  }
  sub_1002A20DC();
  CFTypeID v20 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v17;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionGetNATTKeepAliveOverCell(),  with result %d", buf, 8u);
  }
  xpc_object_t v22 = xpc_int64_create(v17);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  xpc_object_t v26 = "kNATTKeepAliveOverCell";
  sub_100035E70((uint64_t)buf, &v22, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
  return sub_1000577C4(&cf);
}

void sub_1002A658C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A65D8(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  *(void *)std::string buf = a4;
  xpc_object_t v29 = "kPacketContextIdentifer";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
  xpc_release(object);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    xpc_object_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v11;
  char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_11:
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v17 = v15[3];
  unsigned int v16 = (std::__shared_weak_count *)v15[4];
  if (!v16) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
  if (!v17)
  {
LABEL_7:
    sub_1002A20DC();
    CFNumberRef v19 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "DataService not found", buf, 2u);
    }
    unsigned int v20 = -1;
    unsigned int v21 = -1;
    goto LABEL_14;
  }
LABEL_12:
  unsigned int v20 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 200))(v17, v8);
  unsigned int v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 208))(v17, v8);
  sub_1002A20DC();
  xpc_object_t v22 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = v20;
    LOWORD(v29) = 1024;
    *(_DWORD *)((char *)&v29 + 2) = v21;
    HIWORD(v29) = 1024;
    int v30 = v8;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "kPacketGetInterfaceFamilyStatus: active 0x%x and available 0x%x for PDP %d", buf, 0x14u);
  }
LABEL_14:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  xpc_object_t v25 = xpc_int64_create(v20);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  xpc_object_t v29 = "kPacketDataFamilyActive";
  sub_100035E70((uint64_t)buf, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_object_t v23 = xpc_int64_create(v21);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  xpc_object_t v29 = "kPacketDataFamilyAvailable";
  sub_100035E70((uint64_t)buf, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
}

void sub_1002A68D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A6940(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  int64_t v32 = 0;
  int64_t value = 0;
  sub_1002A20DC();
  uint64_t v8 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionGetPacketContextStatistics()", buf, 2u);
  }
  *(void *)std::string buf = a4;
  uint64_t v35 = "kPacketContextIdentifer";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v10 = xpc::dyn_cast_or_default((xpc *)&object, 0, v9);
  xpc_release(object);
  int64_t v32 = 0;
  int64_t value = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v12 = ServiceMap;
  if (v13 < 0)
  {
    unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (v17)
  {
    uint64_t v19 = v17[3];
    char v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      if (!v19) {
        goto LABEL_9;
      }
LABEL_13:
      (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v19 + 920))(buf, v19, v10);
      uint64_t v21 = *(void *)buf;
      xpc_object_t v22 = (std::__shared_weak_count *)v35;
      if (v20) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  char v18 = 0;
  char v20 = 1;
  if (v19) {
    goto LABEL_13;
  }
LABEL_9:
  uint64_t v21 = 0;
  xpc_object_t v22 = 0;
  if ((v20 & 1) == 0) {
LABEL_14:
  }
    sub_10004D2C8(v18);
LABEL_15:
  if (v21) {
    (*(void (**)(uint64_t, char *, int64_t *, char *, int64_t *))(*(void *)v21 + 24))(v21, (char *)&value + 4, &value, (char *)&v32 + 4, &v32);
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
  xpc_object_t v29 = xpc_int64_create(HIDWORD(value));
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  uint64_t v35 = "kPacketDataUplinkPackets";
  sub_100035E70((uint64_t)buf, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_object_t v27 = xpc_int64_create(value);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  uint64_t v35 = "kPacketDataDownlinkPackets";
  sub_100035E70((uint64_t)buf, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_object_t v25 = xpc_int64_create(HIDWORD(v32));
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  uint64_t v35 = "kPacketDataUplinkBytes";
  sub_100035E70((uint64_t)buf, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_object_t v23 = xpc_int64_create(v32);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  uint64_t v35 = "kPacketDataDownlinkBytes";
  sub_100035E70((uint64_t)buf, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
}

void sub_1002A6C9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t object)
{
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A6D10(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)std::string buf = a4;
  long long v43 = "kPacketContextIdentifer";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v6 = xpc::dyn_cast_or_default((xpc *)&object, 0, v5);
  xpc_release(object);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  uint64_t v10 = v9;
  if (v9 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v10;
  unsigned int v14 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_7;
      }
LABEL_11:
      (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v16 + 920))(buf, v16, v6);
      uint64_t v16 = *(void *)buf;
      char v18 = (std::__shared_weak_count *)v43;
      if (v17) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v15 = 0;
  char v17 = 1;
  if (v16) {
    goto LABEL_11;
  }
LABEL_7:
  char v18 = 0;
  if ((v17 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v15);
LABEL_13:
  if (v16)
  {
    (*(void (**)(uint64_t))(*(void *)v16 + 16))(v16);
    uint64_t v19 = (std::mutex *)Registry::getServiceMap(*a1);
    char v20 = v19;
    if (v9 < 0)
    {
      uint64_t v21 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        uint64_t v9 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(v19);
    *(void *)std::string buf = v9;
    xpc_object_t v24 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
    if (v24)
    {
      uint64_t v26 = v24[3];
      xpc_object_t v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
        if (!v26) {
          goto LABEL_20;
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v20);
    xpc_object_t v25 = 0;
    char v27 = 1;
    if (!v26)
    {
LABEL_20:
      int v28 = 0;
      if (v27)
      {
LABEL_28:
        if (v6 != v28) {
          goto LABEL_39;
        }
        uint64_t v31 = (std::mutex *)Registry::getServiceMap(*a1);
        int64_t v32 = v31;
        if (v33 < 0)
        {
          uint64_t v34 = (unsigned __int8 *)(v33 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v35 = 5381;
          do
          {
            uint64_t v33 = v35;
            unsigned int v36 = *v34++;
            uint64_t v35 = (33 * v35) ^ v36;
          }
          while (v36);
        }
        std::mutex::lock(v31);
        *(void *)std::string buf = v33;
        uint64_t v37 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)buf);
        if (v37)
        {
          uint64_t v39 = v37[3];
          xpc_object_t v38 = (std::__shared_weak_count *)v37[4];
          if (v38)
          {
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v32);
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v38);
            char v40 = 0;
            goto LABEL_37;
          }
        }
        else
        {
          uint64_t v39 = 0;
        }
        std::mutex::unlock(v32);
        xpc_object_t v38 = 0;
        char v40 = 1;
LABEL_37:
        (*(void (**)(uint64_t))(*(void *)v39 + 40))(v39);
        if ((v40 & 1) == 0) {
          sub_10004D2C8(v38);
        }
        goto LABEL_39;
      }
LABEL_27:
      sub_10004D2C8(v25);
      goto LABEL_28;
    }
LABEL_26:
    uint64_t v30 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 776))(v26);
    int v28 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v26 + 256))(v26, v30, 1);
    if (v27) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  sub_1002A20DC();
  xpc_object_t v29 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Invalid PDP Context %d specified", buf, 8u);
  }
LABEL_39:
  if (v18) {
    sub_10004D2C8(v18);
  }
}

void sub_1002A7114(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A71A4(Registry **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v30[0] = a4;
  v30[1] = (unint64_t)"kPacketContextIdentifer";
  sub_100048BAC((uint64_t)v30, &object);
  int v6 = xpc::dyn_cast_or_default((xpc *)&object, 0, v5);
  xpc_release(object);
  if (v6 != -1) {
    goto LABEL_14;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  v30[0] = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, v30);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_10:
    std::mutex::unlock(v8);
    unsigned int v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  uint64_t v15 = v13[3];
  unsigned int v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (v15) {
LABEL_11:
  }
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v15 + 512))(v15, 3, 0);
LABEL_12:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
LABEL_14:
  sub_1002A20DC();
  char v17 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v30[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "CommCenter told to reset the settings for APN", (uint8_t *)v30, 2u);
  }
  if ((v6 + 1) <= 1)
  {
    char v18 = (std::mutex *)Registry::getServiceMap(*a1);
    uint64_t v19 = v18;
    if ((v20 & 0x8000000000000000) != 0)
    {
      uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        unint64_t v20 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(v18);
    v30[0] = v20;
    xpc_object_t v24 = sub_10004D37C(&v19[1].__m_.__sig, v30);
    if (v24)
    {
      uint64_t v26 = v24[3];
      xpc_object_t v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
        if (!v26)
        {
LABEL_27:
          if ((v27 & 1) == 0) {
            sub_10004D2C8(v25);
          }
          return;
        }
LABEL_26:
        uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 776))(v26);
        ResetAllPacketHandlersAPNs(v28, 3, 0xFFFFFFFFLL, 0);
        uint64_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 776))(v26);
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v26 + 312))(v26, v29, 12, 0);
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v19);
    xpc_object_t v25 = 0;
    char v27 = 1;
    if (!v26) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
}

void sub_1002A74A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A74F0(Registry **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v19[0] = a4;
  v19[1] = (unint64_t)"kPacketContextIdentifer";
  sub_100048BAC((uint64_t)v19, &object);
  uint64_t v6 = xpc::dyn_cast_or_default((xpc *)&object, 0, v5);
  xpc_release(object);
  sub_1002A20DC();
  int v7 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "CommCenter told to suspend the context", (uint8_t *)v19, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  v19[0] = v10;
  unsigned int v14 = sub_10004D37C(&v9[1].__m_.__sig, v19);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_11:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (v16)
  {
LABEL_12:
    uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 776))(v16);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 536))(v16, v18, v6);
  }
LABEL_13:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_1002A76B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
}

void sub_1002A76E4(Registry **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v19[0] = a4;
  v19[1] = (unint64_t)"kPacketContextIdentifer";
  sub_100048BAC((uint64_t)v19, &object);
  uint64_t v6 = xpc::dyn_cast_or_default((xpc *)&object, 0, v5);
  xpc_release(object);
  sub_1002A20DC();
  int v7 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "CommCenter told to resume the context", (uint8_t *)v19, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  v19[0] = v10;
  unsigned int v14 = sub_10004D37C(&v9[1].__m_.__sig, v19);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_11:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (v16)
  {
LABEL_12:
    uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 776))(v16);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 544))(v16, v18, v6);
  }
LABEL_13:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_1002A78AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
}

void sub_1002A78D8(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  if (xpc_dictionary_get_value(*a4, "kPacketForceDormancy"))
  {
    *(void *)&long long buf = 2048;
    if (!IsTelephonyRunningExtended(&buf)) {
      return;
    }
    sub_1002A20DC();
    uint64_t v6 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "client request to force dormancy", (uint8_t *)&buf, 2u);
    }
    sub_100068A94(&buf);
    (*(void (**)(void))(*(void *)buf + 264))(buf);
    goto LABEL_13;
  }
  if (xpc_dictionary_get_value(*a4, "kPacketDormancy"))
  {
    *(void *)&long long buf = 2048;
    if (!IsTelephonyRunningExtended(&buf)) {
      return;
    }
    *(void *)&long long buf = a4;
    *((void *)&buf + 1) = "kPacketDormancy";
    sub_100048BAC((uint64_t)&buf, &object);
    unsigned __int8 v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
    xpc_release((xpc_object_t)object);
    sub_1002A20DC();
    int v9 = v8;
    unint64_t v10 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = "TRUE";
      if (!v9) {
        uint64_t v11 = "FALSE";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "client request to enable dormancy %s", (uint8_t *)&buf, 0xCu);
    }
    sub_100068A94(&buf);
    (*(void (**)(void))(*(void *)buf + 280))();
LABEL_13:
    uint64_t v12 = (std::__shared_weak_count *)*((void *)&buf + 1);
    if (!*((void *)&buf + 1)) {
      return;
    }
    goto LABEL_14;
  }
  if (xpc_dictionary_get_value(*a4, "kCellularDataDisallow"))
  {
    if (byte_101B13D88 != 1 || !IsTelephonyRunningExtended(&qword_101B13D90))
    {
      sub_1002A20DC();
      uint64_t v26 = qword_101B0CA28;
      if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Calling _CTSetCellularDataIsDisallowed() when telephony is not running", (uint8_t *)&buf, 2u);
      }
      return;
    }
    *(void *)&long long buf = a4;
    *((void *)&buf + 1) = "kCellularDataDisallow";
    sub_100048BAC((uint64_t)&buf, &object);
    unsigned __int8 v14 = xpc::dyn_cast_or_default((xpc *)&object, 0, v13);
    xpc_release((xpc_object_t)object);
    sub_1002A20DC();
    uint64_t v15 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v14;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Calling _CTSetCellularDataIsDisallowed(): %d", (uint8_t *)&buf, 8u);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    char v17 = ServiceMap;
    if (v18 < 0)
    {
      uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v20 = 5381;
      do
      {
        uint64_t v18 = v20;
        unsigned int v21 = *v19++;
        uint64_t v20 = (33 * v20) ^ v21;
      }
      while (v21);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v18;
    uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&buf);
    if (v22)
    {
      uint64_t v24 = v22[3];
      unsigned int v23 = (std::__shared_weak_count *)v22[4];
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v17);
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v23);
        char v25 = 0;
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v24 = 0;
    }
    std::mutex::unlock(v17);
    unsigned int v23 = 0;
    char v25 = 1;
LABEL_31:
    long long buf = 0uLL;
    uint64_t v36 = 0;
    if (v24)
    {
      if ((*(unsigned int (**)(uint64_t, long long *))(*(void *)v24 + 520))(v24, &buf) == v14)
      {
        sub_1002A20DC();
        char v27 = qword_101B0CA28;
        if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
        {
          p_long long buf = &buf;
          if (v36 < 0) {
            p_long long buf = (long long *)buf;
          }
          LODWORD(object) = 136446210;
          *(void *)((char *)&object + 4) = p_buf;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Calling _CTSetCellularDataIsDisallowed() when we are already in that state - requested by %{public}s", (uint8_t *)&object, 0xCu);
        }
      }
      else
      {
        long long object = 0uLL;
        uint64_t v34 = 0;
        sub_100C663EC(a4, (uint64_t)&object);
        (*(void (**)(uint64_t, BOOL, long long *))(*(void *)v24 + 528))(v24, v14 != 0, &object);
        uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v24 + 456);
        if (v14)
        {
          v30(v24, 0, 4);
          uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 776))(v24);
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v24 + 312))(v24, v31, 4, 1);
        }
        else
        {
          v30(v24, 1, 4);
          uint64_t v32 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 776))(v24);
          sub_1002A1990(v32, *a1, "due to kCellularDataDisallow");
        }
        if (SHIBYTE(v34) < 0) {
          operator delete((void *)object);
        }
      }
    }
    else
    {
      sub_1002A20DC();
      uint64_t v29 = qword_101B0CA28;
      if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
      {
        LOWORD(object) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Calling _CTSetCellularDataIsDisallowed() when DataService is not running", (uint8_t *)&object, 2u);
      }
    }
    if (SHIBYTE(v36) < 0) {
      operator delete((void *)buf);
    }
    if ((v25 & 1) == 0)
    {
      uint64_t v12 = v23;
LABEL_14:
      sub_10004D2C8(v12);
    }
  }
}

void sub_1002A7F10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A7FB8(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  if (xpc_dictionary_get_value(*a4, "kEnableCellularDataEx"))
  {
    sub_1002A20DC();
    unsigned __int8 v8 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionSetCellularDataIsEnabledEx()", buf, 2u);
    }
    *(void *)long long buf = a4;
    *(void *)&uint8_t buf[8] = "kEnableCellularDataEx";
    sub_100048BAC((uint64_t)buf, &object);
    char v10 = xpc::dyn_cast_or_default((xpc *)&object, 0, v9);
    xpc_release(object);
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    uint64_t v12 = ServiceMap;
    if (v13 < 0)
    {
      unsigned __int8 v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v13;
    char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
    if (v17)
    {
      uint64_t v19 = v17[3];
      uint64_t v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        if (!v19) {
          goto LABEL_28;
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    uint64_t v18 = 0;
    char v20 = 1;
    if (!v19) {
      goto LABEL_28;
    }
LABEL_24:
    v89[0] = _NSConcreteStackBlock;
    v89[1] = 1174405120;
    v89[2] = sub_1002AC648;
    v89[3] = &unk_1019B3610;
    uint64_t v33 = (std::__shared_weak_count *)a5[1];
    v89[4] = *a5;
    xpc_object_t v90 = v33;
    if (v33) {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v91 = v10;
    (*(void (**)(uint64_t, BOOL, void *))(*(void *)v19 + 24))(v19, v10 != 0, v89);
    if (v90) {
      sub_10004D2C8(v90);
    }
LABEL_28:
    if (v20) {
      return;
    }
    goto LABEL_29;
  }
  if (xpc_dictionary_get_value(*a4, "kEnableCellularData"))
  {
    *(void *)long long buf = 6144;
    if (IsTelephonyRunningExtended(buf))
    {
      sub_1002A20DC();
      unsigned int v21 = qword_101B0CA28;
      if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Calling _CTSetCellularDataIsEnabled()", buf, 2u);
      }
      *(void *)long long buf = a4;
      *(void *)&uint8_t buf[8] = "kEnableCellularData";
      sub_100048BAC((uint64_t)buf, &object);
      unsigned __int8 v23 = xpc::dyn_cast_or_default((xpc *)&object, 0, v22);
      xpc_release(object);
      uint64_t v24 = (std::mutex *)Registry::getServiceMap(*a1);
      char v25 = v24;
      if (v26 < 0)
      {
        char v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v28 = 5381;
        do
        {
          uint64_t v26 = v28;
          unsigned int v29 = *v27++;
          uint64_t v28 = (33 * v28) ^ v29;
        }
        while (v29);
      }
      std::mutex::lock(v24);
      *(void *)long long buf = v26;
      uint64_t v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
      if (v30)
      {
        uint64_t v31 = v30[3];
        uint64_t v18 = (std::__shared_weak_count *)v30[4];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v25);
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v18);
          char v32 = 0;
          if (!v31) {
            goto LABEL_84;
          }
LABEL_33:
          if ((*(unsigned int (**)(uint64_t))(*(void *)v31 + 696))(v31) == v23) {
            goto LABEL_84;
          }
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)v31 + 456))(v31, 0, 3);
          uint64_t v34 = (std::__shared_weak_count *)a5[1];
          uint64_t v87 = *a5;
          xpc_object_t v88 = v34;
          if (v34) {
            atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t, BOOL, uint64_t, uint64_t *))(*(void *)v31 + 72))(v31, v23 != 0, 1, &v87);
          if (v88) {
            sub_10004D2C8(v88);
          }
          uint64_t v86 = 0;
          long long v84 = 0u;
          long long v85 = 0u;
          long long v82 = 0u;
          long long v83 = 0u;
          long long v80 = 0u;
          long long v81 = 0u;
          long long v78 = 0u;
          long long v79 = 0u;
          long long v76 = 0u;
          long long v77 = 0u;
          *(_OWORD *)long long v74 = 0u;
          long long v75 = 0u;
          long long v72 = 0u;
          long long v73 = 0u;
          *(_OWORD *)long long buf = 0u;
          long long v71 = 0u;
          sub_10004DE24((uint64_t)buf);
          sub_10004B96C(buf, (uint64_t)"Client [", 8);
          xpc_object_t object = 0;
          uint64_t v68 = 0;
          uint64_t v69 = 0;
          sub_100C663EC(a4, (uint64_t)&object);
          uint64_t v35 = HIBYTE(v69);
          char v36 = HIBYTE(v69);
          uint64_t v37 = v68;
          if (v69 >= 0) {
            uint64_t v38 = HIBYTE(v69);
          }
          else {
            uint64_t v38 = v68;
          }
          if (!v38)
          {
            if (SHIBYTE(v69) < 0)
            {
              uint64_t v68 = 9;
              p_xpc_object_t object = (char *)object;
            }
            else
            {
              HIBYTE(v69) = 9;
              p_xpc_object_t object = (char *)&object;
            }
            strcpy(p_object, "<unknown>");
            uint64_t v35 = HIBYTE(v69);
            uint64_t v37 = v68;
            char v36 = HIBYTE(v69);
          }
          if (v36 >= 0) {
            char v40 = &object;
          }
          else {
            char v40 = object;
          }
          if (v36 >= 0) {
            uint64_t v41 = v35;
          }
          else {
            uint64_t v41 = v37;
          }
          long long v42 = sub_10004B96C(buf, (uint64_t)v40, v41);
          sub_10004B96C(v42, (uint64_t)"] via xpc:kPacketSetProperty", 28);
          uint64_t v43 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 776))(v31);
          sub_10004BC98((uint64_t)&buf[8], &__p);
          _DataSettingsChanged(v43, a1, v23, (uint64_t)&__p);
          if (SHIBYTE(v66) < 0) {
            operator delete(__p);
          }
          long long v44 = (std::mutex *)Registry::getServiceMap(*a1);
          long long v45 = v44;
          if (v46 < 0)
          {
            long long v47 = (unsigned __int8 *)(v46 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v48 = 5381;
            do
            {
              uint64_t v46 = v48;
              unsigned int v49 = *v47++;
              uint64_t v48 = (33 * v48) ^ v49;
            }
            while (v49);
          }
          std::mutex::lock(v44);
          std::string __p = (void *)v46;
          long long v50 = sub_10004D37C(&v45[1].__m_.__sig, (unint64_t *)&__p);
          if (v50)
          {
            uint64_t v52 = v50[3];
            long long v51 = (std::__shared_weak_count *)v50[4];
            if (v51)
            {
              atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v45);
              atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v51);
              if (!v52)
              {
LABEL_78:
                sub_10004D2C8(v51);
                goto LABEL_79;
              }
LABEL_63:
              std::string __p = 0;
              uint64_t v65 = 0;
              uint64_t v66 = 0;
              xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
              uint64_t pid = xpc_connection_get_pid(remote_connection);
              (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v52 + 24))(&__p, v52, pid);
              uint64_t v55 = HIBYTE(v66);
              if (v66 < 0) {
                uint64_t v55 = v65;
              }
              if (!v55)
              {
                if (SHIBYTE(v66) < 0)
                {
                  uint64_t v65 = 7;
                  p_p = (char *)__p;
                }
                else
                {
                  HIBYTE(v66) = 7;
                  p_p = (char *)&__p;
                }
                strcpy(p_p, "unknown");
              }
              ct_green_tea_logger_create_static();
              CTGreenTeaOsLogHandle = getCTGreenTeaOsLogHandle();
              unsigned int v58 = CTGreenTeaOsLogHandle;
              if (CTGreenTeaOsLogHandle && os_log_type_enabled(CTGreenTeaOsLogHandle, OS_LOG_TYPE_INFO))
              {
                BOOL v59 = v23 != 0;
                int v60 = SHIBYTE(v66);
                xpc_object_t v61 = (void **)__p;
                uint64_t v62 = asStringBool(v59);
                uint64_t v63 = &__p;
                if (v60 < 0) {
                  uint64_t v63 = v61;
                }
                *(_DWORD *)unsigned int v92 = 136315394;
                int64_t v93 = v63;
                __int16 v94 = 2080;
                uint64_t v95 = v62;
                _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_INFO, "Process %s set Celluar Data %s", v92, 0x16u);
              }
              if (SHIBYTE(v66) < 0) {
                operator delete(__p);
              }
              if (!v51) {
                goto LABEL_79;
              }
              goto LABEL_78;
            }
            std::mutex::unlock(v45);
            if (v52) {
              goto LABEL_63;
            }
          }
          else
          {
            std::mutex::unlock(v45);
          }
LABEL_79:
          if (SHIBYTE(v69) < 0) {
            operator delete(object);
          }
          if (SHIBYTE(v75) < 0) {
            operator delete(v74[1]);
          }
          std::streambuf::~streambuf();
          std::ostream::~ostream();
          std::ios::~ios();
LABEL_84:
          if (v32) {
            return;
          }
LABEL_29:
          sub_10004D2C8(v18);
          return;
        }
      }
      else
      {
        uint64_t v31 = 0;
      }
      std::mutex::unlock(v25);
      uint64_t v18 = 0;
      char v32 = 1;
      if (!v31) {
        goto LABEL_84;
      }
      goto LABEL_33;
    }
  }
}

void sub_1002A8828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, xpc_object_t object, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (a20 < 0) {
    operator delete(object);
  }
  sub_1000C937C((uint64_t)&a21);
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(a1);
}

void sub_1002A8940(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  if (!xpc_dictionary_get_value(*a4, "kQOSInfo")) {
    return;
  }
  unsigned int v26 = -1;
  sub_1002A20DC();
  unsigned __int8 v8 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "server_CTRequestQos", buf, 2u);
  }
  uint64_t v24 = "kQOSInfo";
  xpc_object_t v25 = 0;
  *(void *)long long buf = a4;
  sub_100048BAC((uint64_t)buf, &v25);
  CFTypeRef cf = 0;
  *(void *)long long buf = _CFXPCCreateCFObjectFromXPCObject();
  sub_100084068(&cf, (CFTypeRef *)buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  char v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    unsigned int v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      if (!v17) {
        goto LABEL_16;
      }
LABEL_13:
      CFTypeRef v21 = cf;
      if (cf) {
        CFRetain(cf);
      }
      (*(void (**)(uint64_t, uint64_t, CFTypeRef *, unsigned int *))(*(void *)v17 + 368))(v17, 1, &v21, &v26);
      sub_100057D78(&v21);
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  unsigned int v16 = 0;
  char v18 = 1;
  if (v17) {
    goto LABEL_13;
  }
LABEL_16:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  xpc_object_t v19 = xpc_int64_create(v26);
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  *(void *)long long buf = *a5;
  uint64_t v24 = "kQOSRequest";
  sub_100035E70((uint64_t)buf, &v19, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  sub_100057D78(&cf);
  xpc_release(v25);
}

void sub_1002A8B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  sub_100057D78(&a11);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  sub_100057D78(&a12);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_1002A8BD4(capabilities::ct *a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  if (capabilities::ct::supportsWirelessModem(a1))
  {
    long long v22 = 0uLL;
    uint64_t v23 = 0;
    v20[0] = a4;
    v20[1] = "kAssertionName";
    sub_100048BAC((uint64_t)v20, &object);
    sub_100058DB0(buf, "<unknown>");
    xpc::dyn_cast_or_default();
    if (v25 < 0) {
      operator delete(*(void **)buf);
    }
    xpc_release(object);
    *(void *)long long buf = a4;
    *(void *)&uint8_t buf[8] = "kPacketServiceType";
    sub_100048BAC((uint64_t)buf, v20);
    int v8 = xpc::dyn_cast_or_default((xpc *)v20, 0, v7);
    xpc_release(v20[0]);
    sub_1002A20DC();
    int v9 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      char v10 = &v22;
      if (v23 < 0) {
        char v10 = (long long *)v22;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%s is adding a tethering assertion of type %d", buf, 0x12u);
    }
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
    xpc_object_t v12 = remote_connection;
    if (remote_connection) {
      xpc_retain(remote_connection);
    }
    else {
      xpc_object_t v12 = xpc_null_create();
    }
    sub_100058DB0(v18, "tethering");
    xpc_object_t v17 = v12;
    if (v12) {
      xpc_retain(v12);
    }
    else {
      xpc_object_t v17 = xpc_null_create();
    }
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(__p, (void *)v22, *((unint64_t *)&v22 + 1));
    }
    else
    {
      *(_OWORD *)std::string __p = v22;
      uint64_t v16 = v23;
    }
    sub_100C641C0((long long *)v18, &v17, (long long *)__p);
    if (SHIBYTE(v16) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v17);
    xpc_object_t v17 = 0;
    if (v19 < 0) {
      operator delete(v18[0]);
    }
    xpc_object_t v13 = xpc_BOOL_create(1);
    if (!v13) {
      xpc_object_t v13 = xpc_null_create();
    }
    *(void *)long long buf = *a5;
    *(void *)&uint8_t buf[8] = "kDidSucceed";
    sub_100035E70((uint64_t)buf, &v13, &v14);
    xpc_release(v14);
    xpc_object_t v14 = 0;
    xpc_release(v13);
    xpc_object_t v13 = 0;
    xpc_release(v12);
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)v22);
    }
  }
}

void sub_1002A8E54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, xpc_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,xpc_object_t a25,uint64_t a26,xpc_object_t a27)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1002A8F44()
{
}

void sub_1002A8F4C(capabilities::ct *a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  unsigned int v26 = 0;
  char v27 = 0;
  uint64_t v28 = 0;
  sub_100058DB0(&v26, "com.apple.springboard");
  __s1[0] = 0;
  __s1[1] = 0;
  uint64_t v25 = 0;
  v22[0] = a4;
  v22[1] = "kAssertionName";
  sub_100048BAC((uint64_t)v22, &object);
  sub_100058DB0(buf, "<unknown>");
  xpc::dyn_cast_or_default();
  if (v30 < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(object);
  if (dormancy::DormancyController::Rel8_FD_ScreenOn_Mode(a1))
  {
    uint64_t v6 = HIBYTE(v25);
    if (v25 >= 0) {
      int v7 = (void *)HIBYTE(v25);
    }
    else {
      int v7 = __s1[1];
    }
    int v8 = (void *)HIBYTE(v28);
    if (v28 < 0) {
      int v8 = v27;
    }
    if (v7 == v8)
    {
      if (v28 >= 0) {
        int v9 = (void **)&v26;
      }
      else {
        int v9 = v26;
      }
      if ((v25 & 0x8000000000000000) == 0)
      {
        if (HIBYTE(v25))
        {
          char v10 = __s1;
          while (*(unsigned __int8 *)v10 == *(unsigned __int8 *)v9)
          {
            char v10 = (void **)((char *)v10 + 1);
            int v9 = (void **)((char *)v9 + 1);
            if (!--v6) {
              goto LABEL_43;
            }
          }
          goto LABEL_20;
        }
LABEL_43:
        sub_1002A20DC();
        uint64_t v15 = qword_101B0CA28;
        if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = __s1;
          if (v25 < 0) {
            uint64_t v16 = (void **)__s1[0];
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "The \"%s\" fast dormancy suspend assertion is being suppressed, due to AllowScreenOnFastDormancy", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (!memcmp(__s1[0], v9, (size_t)__s1[1])) {
        goto LABEL_43;
      }
    }
  }
LABEL_20:
  sub_1002A20DC();
  uint64_t v11 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v12 = __s1;
    if (v25 < 0) {
      xpc_object_t v12 = (void **)__s1[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%s is adding a fast dormancy suspend assertion", buf, 0xCu);
  }
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
  xpc_object_t v14 = remote_connection;
  if (remote_connection) {
    xpc_retain(remote_connection);
  }
  else {
    xpc_object_t v14 = xpc_null_create();
  }
  sub_100058DB0(v20, "suspend dormancy");
  xpc_object_t v19 = v14;
  if (v14) {
    xpc_retain(v14);
  }
  else {
    xpc_object_t v19 = xpc_null_create();
  }
  if (SHIBYTE(v25) < 0)
  {
    sub_10004FC84(__p, __s1[0], (unint64_t)__s1[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__s1;
    uint64_t v18 = v25;
  }
  sub_100C641C0((long long *)v20, &v19, (long long *)__p);
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v19);
  xpc_object_t v19 = 0;
  if (v21 < 0) {
    operator delete(v20[0]);
  }
  xpc_release(v14);
LABEL_38:
  if (SHIBYTE(v25) < 0) {
    operator delete(__s1[0]);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(v26);
  }
}

void sub_1002A9250(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, xpc_object_t object, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,xpc_object_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v30 - 65) < 0) {
    operator delete(*(void **)(v30 - 88));
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A9338(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  long long v20 = 0uLL;
  uint64_t v21 = 0;
  v18[0] = a4;
  v18[1] = "kAssertionName";
  sub_100048BAC((uint64_t)v18, &object);
  sub_100058DB0(&buf, "<unknown>");
  xpc::dyn_cast_or_default();
  if (v23 < 0) {
    operator delete((void *)buf);
  }
  xpc_release(object);
  sub_1002A20DC();
  int v7 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = &v20;
    if (v21 < 0) {
      int v8 = (long long *)v20;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%s is adding an OTA activation assertion", (uint8_t *)&buf, 0xCu);
  }
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
  xpc_object_t v10 = remote_connection;
  if (remote_connection) {
    xpc_retain(remote_connection);
  }
  else {
    xpc_object_t v10 = xpc_null_create();
  }
  sub_100058DB0(v16, "ota activation");
  xpc_object_t v15 = v10;
  if (v10) {
    xpc_retain(v10);
  }
  else {
    xpc_object_t v15 = xpc_null_create();
  }
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(__p, (void *)v20, *((unint64_t *)&v20 + 1));
  }
  else
  {
    *(_OWORD *)std::string __p = v20;
    uint64_t v14 = v21;
  }
  sub_100C641C0((long long *)v16, &v15, (long long *)__p);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v15);
  xpc_object_t v15 = 0;
  if (v17 < 0) {
    operator delete(v16[0]);
  }
  xpc_object_t v11 = xpc_BOOL_create(1);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  *(void *)&long long buf = *a5;
  *((void *)&buf + 1) = "kDidSucceed";
  sub_100035E70((uint64_t)&buf, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_release(v10);
  if (SHIBYTE(v21) < 0) {
    operator delete((void *)v20);
  }
}

void sub_1002A9570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, xpc_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,xpc_object_t a27)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1002A9644()
{
}

void sub_1002A964C(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  sub_1002A20DC();
  int v7 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "CALL TO OBSOLETE API kPacketCreatePDPAssertion: should use a specific assertion type request", buf, 2u);
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v28 = 0;
  v25[0] = a4;
  v25[1] = "kAssertionName";
  sub_100048BAC((uint64_t)v25, &object);
  sub_100058DB0(v29, "<unknown>");
  xpc::dyn_cast_or_default();
  if (v30 < 0) {
    operator delete(*(void **)v29);
  }
  xpc_release(object);
  *(void *)unsigned int v29 = a4;
  *(void *)&v29[8] = "kPacketContextIdentifer";
  sub_100048BAC((uint64_t)v29, v25);
  int v9 = xpc::dyn_cast_or_default((xpc *)v25, 0, v8);
  xpc_release(v25[0]);
  sub_1002A20DC();
  xpc_object_t v10 = qword_101B0CA28;
  BOOL v11 = os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT);
  if (v11)
  {
    xpc_object_t v12 = buf;
    if (v28 < 0) {
      xpc_object_t v12 = *(uint8_t **)buf;
    }
    *(_DWORD *)unsigned int v29 = 136315394;
    *(void *)&void v29[4] = v12;
    *(_WORD *)&v29[12] = 1024;
    *(_DWORD *)&v29[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%s is adding an internet assertion for pdp %d", v29, 0x12u);
  }
  unint64_t v13 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v11);
  if (v13 >> 31) {
    __assert_rtn("kPacketCreatePDPAssertion", "PacketXPCServer.cpp", 1026, "capabilities::ct::supportedPDPContextCount() <= std::numeric_limits<int>::max()");
  }
  int v14 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v13);
  if (v9 < 0 || v9 >= v14)
  {
    sub_1002A20DC();
    char v17 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unsigned int v29 = 67109120;
      *(_DWORD *)&void v29[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Invalid PDP Context %d specified", v29, 8u);
    }
  }
  else
  {
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
    xpc_object_t v16 = remote_connection;
    if (remote_connection) {
      xpc_retain(remote_connection);
    }
    else {
      xpc_object_t v16 = xpc_null_create();
    }
    sub_100058DB0(v23, "internet");
    xpc_object_t v22 = v16;
    if (v16) {
      xpc_retain(v16);
    }
    else {
      xpc_object_t v22 = xpc_null_create();
    }
    if (SHIBYTE(v28) < 0)
    {
      sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)buf;
      uint64_t v21 = v28;
    }
    sub_100C641C0((long long *)v23, &v22, (long long *)__p);
    if (SHIBYTE(v21) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v22);
    xpc_object_t v22 = 0;
    if (v24 < 0) {
      operator delete(v23[0]);
    }
    xpc_object_t v18 = xpc_BOOL_create(1);
    if (!v18) {
      xpc_object_t v18 = xpc_null_create();
    }
    *(void *)unsigned int v29 = *a5;
    *(void *)&v29[8] = "kDidSucceed";
    sub_100035E70((uint64_t)v29, &v18, &v19);
    xpc_release(v19);
    xpc_object_t v19 = 0;
    xpc_release(v18);
    xpc_object_t v18 = 0;
    xpc_release(v16);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1002A999C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,xpc_object_t a24,uint64_t a25,xpc_object_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A9A98(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  v32[0] = 0;
  v32[1] = 0;
  uint64_t v33 = 0;
  v31.__r_.__value_.__r.__words[0] = (std::string::size_type)a4;
  v31.__r_.__value_.__l.__size_ = (std::string::size_type)"kAssertionName";
  sub_100048BAC((uint64_t)&v31, object);
  sub_100058DB0(buf, "<unknown>");
  xpc::dyn_cast_or_default();
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(object[0]);
  sub_1002A20DC();
  int v7 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = v32;
    if (v33 < 0) {
      int v8 = (void **)v32[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%s is adding an Data Activation assertion\n", buf, 0xCu);
  }
  memset(&v31, 0, sizeof(v31));
  xpc_object_t v30 = 0;
  *(void *)long long buf = a4;
  *(void *)&uint8_t buf[8] = "kPacketCreateDataActivationPopupAssertionCategories";
  sub_100048BAC((uint64_t)buf, &v30);
  if (xpc_get_type(v30) != (xpc_type_t)&_xpc_type_null)
  {
    CFArrayRef theArray = 0;
    *(void *)long long buf = _CFXPCCreateCFObjectFromXPCObject();
    sub_1002AC730(&theArray, (CFTypeRef *)buf);
    CFArrayRef v9 = theArray;
    if (theArray) {
      xpc_object_t v10 = sub_100083F10;
    }
    else {
      xpc_object_t v10 = 0;
    }
    if (v10)
    {
      for (CFIndex i = 0; i < CFArrayGetCount(v9); ++i)
      {
        if (CFArrayGetValueAtIndex(theArray, i))
        {
          std::string::size_type size = HIBYTE(v31.__r_.__value_.__r.__words[2]);
          if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type size = v31.__r_.__value_.__l.__size_;
          }
          if (size)
          {
            memset(buf, 0, sizeof(buf));
            ctu::cf::assign();
            *(_OWORD *)xpc_object_t object = *(_OWORD *)buf;
            uint64_t v35 = *(void *)&buf[16];
            if ((buf[23] & 0x80u) == 0) {
              unint64_t v13 = object;
            }
            else {
              unint64_t v13 = (xpc_object_t *)object[0];
            }
            if ((buf[23] & 0x80u) == 0) {
              std::string::size_type v14 = HIBYTE(v35);
            }
            else {
              std::string::size_type v14 = (std::string::size_type)object[1];
            }
            std::string::append(&v31, (const std::string::value_type *)v13, v14);
            if (SHIBYTE(v35) < 0) {
              operator delete(object[0]);
            }
          }
          else
          {
            memset(buf, 0, sizeof(buf));
            ctu::cf::assign();
            std::string::size_type v15 = *(void *)buf;
            object[0] = *(xpc_object_t *)&buf[8];
            *(xpc_object_t *)((char *)object + 7) = *(xpc_object_t *)&buf[15];
            uint8_t v16 = buf[23];
            if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v31.__r_.__value_.__l.__data_);
            }
            v31.__r_.__value_.__r.__words[0] = v15;
            v31.__r_.__value_.__l.__size_ = (std::string::size_type)object[0];
            *(std::string::size_type *)((char *)&v31.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)object + 7);
            *((unsigned char *)&v31.__r_.__value_.__s + 23) = v16;
          }
        }
        CFArrayRef v9 = theArray;
      }
    }
    sub_100044D00((const void **)&theArray);
  }
  sub_1002A20DC();
  char v17 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v18 = v32;
    if (v33 < 0) {
      xpc_object_t v18 = (void **)v32[0];
    }
    xpc_object_t v19 = &v31;
    if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      xpc_object_t v19 = (std::string *)v31.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v18;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%s is adding an Data Activation assertion for category %s\n", buf, 0x16u);
  }
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
  xpc_object_t v21 = remote_connection;
  if (remote_connection) {
    xpc_retain(remote_connection);
  }
  else {
    xpc_object_t v21 = xpc_null_create();
  }
  sub_100058DB0(v27, "popup-suppression");
  xpc_object_t v26 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  if (SHIBYTE(v33) < 0)
  {
    sub_10004FC84(__p, v32[0], (unint64_t)v32[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v32;
    uint64_t v25 = v33;
  }
  sub_100C641C0((long long *)v27, &v26, (long long *)__p);
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v28 < 0) {
    operator delete(v27[0]);
  }
  xpc_object_t v22 = xpc_BOOL_create(1);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  *(void *)long long buf = *a5;
  *(void *)&uint8_t buf[8] = "kDidSucceed";
  sub_100035E70((uint64_t)buf, &v22, &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_release(v30);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v31.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(v32[0]);
  }
}

void sub_1002A9F04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, xpc_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,xpc_object_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,xpc_object_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1002AA070(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  if (xpc_dictionary_get_value(*a4, "kQOSInfo"))
  {
    sub_1002A20DC();
    uint64_t v6 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v19[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "server_CTReleaseQos", (uint8_t *)v19, 2u);
    }
    v19[0] = (unint64_t)a4;
    v19[1] = (unint64_t)"kQOSInfo";
    sub_100048BAC((uint64_t)v19, &object);
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
    xpc_release(object);
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    xpc_object_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      xpc_object_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    v19[0] = v11;
    std::string::size_type v15 = sub_10004D37C(&v10[1].__m_.__sig, v19);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint8_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        if (!v17)
        {
LABEL_14:
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v16);
          }
          return;
        }
LABEL_13:
        (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 376))(v17, v8);
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint8_t v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
}

void sub_1002AA210(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AA244(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  if (!xpc_dictionary_get_value(*a4, "kPacketFilterStatus") || !xpc_dictionary_get_value(*a4, "kQOSInfo")) {
    return;
  }
  sub_1002A20DC();
  uint64_t v6 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "_CTServerConnectionSetPacketNotificationFilter()", buf, 2u);
  }
  *(void *)long long buf = a4;
  xpc_object_t v22 = "kPacketFilterStatus";
  sub_100048BAC((uint64_t)buf, &object);
  char v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
  xpc_release(object);
  xpc_object_t object = 0;
  *(void *)long long buf = a4;
  xpc_object_t v22 = "kQOSInfo";
  sub_100048BAC((uint64_t)buf, &object);
  CFTypeRef cf = 0;
  *(void *)long long buf = _CFXPCCreateCFObjectFromXPCObject();
  sub_100084068(&cf, (CFTypeRef *)buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v10 = ServiceMap;
  if (v11 < 0)
  {
    char v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v11;
  std::string::size_type v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    uint8_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      if (!v17) {
        goto LABEL_17;
      }
LABEL_14:
      CFTypeRef v19 = cf;
      if (cf) {
        CFRetain(cf);
      }
      (*(void (**)(uint64_t, uint64_t, BOOL, CFTypeRef *))(*(void *)v17 + 392))(v17, 1, v8 != 0, &v19);
      sub_100057D78(&v19);
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint8_t v16 = 0;
  char v18 = 1;
  if (v17) {
    goto LABEL_14;
  }
LABEL_17:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  sub_100057D78(&cf);
  xpc_release(object);
}

void sub_1002AA464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  sub_100057D78((const void **)&a9);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  sub_100057D78(&a10);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_1002AA4C8(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  if (!xpc_dictionary_get_value(*a4, "kQOSInfo")) {
    return;
  }
  sub_1002A20DC();
  uint64_t v6 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "_CTServerConnectionDropIPPackets()", buf, 2u);
  }
  xpc_object_t object = 0;
  *(void *)long long buf = a4;
  long long v20 = "kQOSInfo";
  sub_100048BAC((uint64_t)buf, &object);
  CFTypeRef cf = 0;
  *(void *)long long buf = _CFXPCCreateCFObjectFromXPCObject();
  sub_1002AC730(&cf, (CFTypeRef *)buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  char v8 = ServiceMap;
  if (v9 < 0)
  {
    xpc_object_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    unsigned int v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_16;
      }
LABEL_13:
      CFTypeRef v17 = cf;
      if (cf) {
        CFRetain(cf);
      }
      (*(void (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)v15 + 400))(v15, 1, &v17);
      sub_100044D00(&v17);
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  unsigned int v14 = 0;
  char v16 = 1;
  if (v15) {
    goto LABEL_13;
  }
LABEL_16:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  sub_100044D00(&cf);
  xpc_release(object);
}

void sub_1002AA6A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  sub_100044D00((const void **)&a9);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  sub_100044D00(&a10);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_1002AA6EC(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  if (!xpc_dictionary_get_value(*a4, "kPacketContextIdentifer")) {
    return;
  }
  memset(v32, 0, sizeof(v32));
  *(void *)long long buf = 4096;
  if (!IsTelephonyRunningExtended(buf))
  {
    uint64_t v21 = 0;
    goto LABEL_18;
  }
  *(void *)long long buf = a4;
  xpc_object_t v30 = "kPacketContextIdentifer";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v9 = xpc::dyn_cast_or_default((xpc *)&object, 0, v8);
  xpc_release(object);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v12;
  char v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (v16)
  {
    uint64_t v18 = v16[3];
    CFTypeRef v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      if (!v18) {
        goto LABEL_9;
      }
LABEL_16:
      uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *))(*(void *)v18 + 320))(v18, v9, v32);
      if (v19) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  CFTypeRef v17 = 0;
  char v19 = 1;
  if (v18) {
    goto LABEL_16;
  }
LABEL_9:
  sub_1002A20DC();
  long long v20 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "DataService not found", buf, 2u);
  }
  uint64_t v21 = 0;
  if (v19) {
    goto LABEL_18;
  }
LABEL_17:
  sub_10004D2C8(v17);
LABEL_18:
  xpc_object_t v22 = xpc_array_create(0, 0);
  if (v22 || (xpc_object_t v22 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v22);
      xpc_object_t v23 = v22;
    }
    else
    {
      xpc_object_t v23 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v23 = xpc_null_create();
    xpc_object_t v22 = 0;
  }
  xpc_release(v22);
  if (v21)
  {
    char v24 = (int64_t *)v32;
    do
    {
      int64_t v25 = *v24++;
      xpc_object_t v26 = xpc_int64_create(v25);
      if (!v26) {
        xpc_object_t v26 = xpc_null_create();
      }
      xpc_array_append_value(v23, v26);
      xpc_release(v26);
      --v21;
    }
    while (v21);
  }
  xpc_object_t v27 = v23;
  if (v23) {
    xpc_retain(v23);
  }
  else {
    xpc_object_t v27 = xpc_null_create();
  }
  *(void *)long long buf = *a5;
  xpc_object_t v30 = "kGetDataStatusInfo";
  sub_10017AC14((uint64_t)buf, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v23);
}

void sub_1002AAA08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AAAA4(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, xpc_object_t **a5)
{
  if (byte_101B13D88 == 1
    && IsTelephonyRunningExtended(&qword_101B13D90)
    && xpc_dictionary_get_value(*a4, "kPacketContextIdentifer"))
  {
    xpc_object_t v22 = a4;
    xpc_object_t v23 = "kPacketContextIdentifer";
    sub_100048BAC((uint64_t)&v22, &object);
    int v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
    xpc_release(object);
    unint64_t v10 = capabilities::ct::supportedPDPContextCount(v9);
    if (v10 >> 31) {
      __assert_rtn("kPacketCopyAssertion", "PacketXPCServer.cpp", 1148, "capabilities::ct::supportedPDPContextCount() <= std::numeric_limits<int>::max()");
    }
    int v11 = capabilities::ct::supportedPDPContextCount((capabilities::ct *)v10);
    if (v8 < 0 || v8 >= v11)
    {
      xpc_object_t v18 = xpc_int64_create(22);
      if (!v18) {
        xpc_object_t v18 = xpc_null_create();
      }
      xpc_object_t v22 = *a5;
      xpc_object_t v23 = "kPosixError";
      sub_100035E70((uint64_t)&v22, &v18, &v19);
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_release(v18);
    }
    else
    {
      xpc_object_t v22 = 0;
      xpc_object_t v23 = 0;
      uint64_t v24 = 0;
      InternetAssertion::getAssertions(&v22);
      xpc_object_t v12 = xpc_array_create(0, 0);
      if (v12 || (xpc_object_t v12 = xpc_null_create()) != 0)
      {
        if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_array)
        {
          xpc_retain(v12);
          xpc_object_t v13 = v12;
        }
        else
        {
          xpc_object_t v13 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v13 = xpc_null_create();
        xpc_object_t v12 = 0;
      }
      xpc_release(v12);
      uint64_t v14 = v22;
      char v15 = v23;
      while (v14 != (xpc_object_t *)v15)
      {
        char v16 = (const char *)v14;
        if (*((char *)v14 + 23) < 0) {
          char v16 = (const char *)*v14;
        }
        xpc_object_t v17 = xpc_string_create(v16);
        if (!v17) {
          xpc_object_t v17 = xpc_null_create();
        }
        xpc_array_append_value(v13, v17);
        xpc_release(v17);
        v14 += 3;
      }
      xpc_object_t object = &v22;
      sub_100047F64((void ***)&object);
      if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_object_t v20 = v13;
        if (v13) {
          xpc_retain(v13);
        }
        else {
          xpc_object_t v20 = xpc_null_create();
        }
        xpc_object_t v22 = *a5;
        xpc_object_t v23 = "kPacketCopyAssertion";
        sub_10017AC14((uint64_t)&v22, &v20, &v21);
        xpc_release(v21);
        xpc_object_t v21 = 0;
        xpc_release(v20);
        xpc_object_t v20 = 0;
      }
      xpc_release(v13);
    }
  }
}

void sub_1002AAD24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  xpc_release(v16);
  _Unwind_Resume(a1);
}

void sub_1002AADA8(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)long long buf = a4;
  xpc_object_t v23 = "kQosIndicator";
  sub_100048BAC((uint64_t)buf, &object);
  char v7 = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
  xpc_release(object);
  *(void *)long long buf = a4;
  xpc_object_t v23 = "kPacketDataFamily";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v9 = xpc::dyn_cast_or_default((xpc *)&object, 0, v8);
  xpc_release(object);
  sub_1002A20DC();
  unint64_t v10 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Calling setQuality, protocols 0x%x", buf, 8u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v13;
  xpc_object_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (!v17)
  {
    uint64_t v19 = 0;
LABEL_11:
    std::mutex::unlock(v12);
    xpc_object_t v18 = 0;
    char v20 = 1;
    if (!v19) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v19 = v17[3];
  xpc_object_t v18 = (std::__shared_weak_count *)v17[4];
  if (!v18) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
  if (v19) {
LABEL_12:
  }
    (*(void (**)(uint64_t, uint64_t, BOOL, uint64_t))(*(void *)v19 + 408))(v19, 1, v7 != 0, v9);
LABEL_13:
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
}

void sub_1002AAFB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AB014(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  v20[0] = 0;
  v20[1] = 0;
  uint64_t v21 = 0;
  *(void *)&long long buf = a4;
  *((void *)&buf + 1) = "kAssertionName";
  sub_100048BAC((uint64_t)&buf, &object);
  xpc::dyn_cast_or_default((uint64_t *)v20, (xpc *)&object, (const object *)"Unknown client", v7);
  xpc_release(object);
  sub_1002A20DC();
  uint64_t v8 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = v20;
    if (v21 < 0) {
      uint64_t v9 = (void **)v20[0];
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%s is adding a CT keep alive assertion", (uint8_t *)&buf, 0xCu);
  }
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
  xpc_object_t v11 = remote_connection;
  if (remote_connection) {
    xpc_retain(remote_connection);
  }
  else {
    xpc_object_t v11 = xpc_null_create();
  }
  sub_100058DB0(v17, "CT Keep Alive");
  xpc_object_t v16 = v11;
  if (v11) {
    xpc_retain(v11);
  }
  else {
    xpc_object_t v16 = xpc_null_create();
  }
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(__p, v20[0], (unint64_t)v20[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v20;
    uint64_t v15 = v21;
  }
  sub_100C641C0((long long *)v17, &v16, (long long *)__p);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v16);
  xpc_object_t v16 = 0;
  if (v18 < 0) {
    operator delete(v17[0]);
  }
  xpc_object_t v12 = xpc_BOOL_create(1);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  *(void *)&long long buf = *a5;
  *((void *)&buf + 1) = "kDidSucceed";
  sub_100035E70((uint64_t)&buf, &v12, &v13);
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[0]);
  }
}

void sub_1002AB230(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, xpc_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,xpc_object_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1002AB2EC()
{
}

void sub_1002AB2F4(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  int v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  xpc_object_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    xpc_object_t v13 = (void (***)(void, BOOL))v11[3];
    xpc_object_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    xpc_object_t v13 = 0;
  }
  std::mutex::unlock(v6);
  xpc_object_t v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_7:
    sub_1002A20DC();
    uint64_t v15 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "EMBMSController not found", buf, 2u);
    }
    goto LABEL_39;
  }
LABEL_11:
  *(void *)long long buf = a4;
  *(void *)&uint8_t buf[8] = "kEMBMSStatus";
  sub_100048BAC((uint64_t)buf, &object);
  char v17 = xpc::dyn_cast_or_default((xpc *)&object, 0, v16);
  xpc_release(object);
  xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
  xpc_object_t v19 = remote_connection;
  if (remote_connection) {
    xpc_retain(remote_connection);
  }
  else {
    xpc_object_t v19 = xpc_null_create();
  }
  uint64_t v51 = 0;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  *(_OWORD *)uint64_t v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v36 = 0u;
  sub_10004DE24((uint64_t)buf);
  sub_10004B96C(buf, (uint64_t)"Client [", 8);
  xpc_object_t object = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  sub_100C663EC(a4, (uint64_t)&object);
  uint64_t v20 = HIBYTE(v34);
  char v21 = HIBYTE(v34);
  uint64_t v22 = v33;
  if (v34 >= 0) {
    uint64_t v23 = HIBYTE(v34);
  }
  else {
    uint64_t v23 = v33;
  }
  if (!v23)
  {
    if (SHIBYTE(v34) < 0)
    {
      uint64_t v33 = 9;
      p_xpc_object_t object = (char *)object;
    }
    else
    {
      HIBYTE(v34) = 9;
      p_xpc_object_t object = (char *)&object;
    }
    strcpy(p_object, "<unknown>");
    uint64_t v20 = HIBYTE(v34);
    uint64_t v22 = v33;
    char v21 = HIBYTE(v34);
  }
  if (v21 >= 0) {
    int64_t v25 = &object;
  }
  else {
    int64_t v25 = object;
  }
  if (v21 >= 0) {
    uint64_t v26 = v20;
  }
  else {
    uint64_t v26 = v22;
  }
  xpc_object_t v27 = sub_10004B96C(buf, (uint64_t)v25, v26);
  sub_10004B96C(v27, (uint64_t)"] via xpc:kSetEMBMSActive", 25);
  sub_1002A20DC();
  xpc_object_t v28 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)&buf[8], __p);
    unsigned int v29 = v31 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)uint64_t v52 = 136315138;
    long long v53 = v29;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Calling _CTServerConnectionSetEMBMSActive(), reason %s", v52, 0xCu);
    if (v31 < 0) {
      operator delete(__p[0]);
    }
  }
  (**v13)(v13, v17 != 0);
  if (SHIBYTE(v34) < 0) {
    operator delete(object);
  }
  if (SHIBYTE(v40) < 0) {
    operator delete(v39[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  xpc_release(v19);
LABEL_39:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_1002AB734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1000C937C((uint64_t)&a18);
  xpc_release(v19);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(a1);
}

void sub_1002AB7D0(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  xpc_object_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_12:
    std::mutex::unlock(v7);
    xpc_object_t v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }
  uint64_t v14 = v12[3];
  xpc_object_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (!v14)
  {
LABEL_7:
    xpc_object_t v18 = xpc_BOOL_create(0);
    if (!v18) {
      xpc_object_t v18 = xpc_null_create();
    }
    *(void *)long long buf = *a5;
    char v21 = "kEMBMSStatus";
    sub_100035E70((uint64_t)buf, &v18, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v18);
    xpc_object_t v18 = 0;
    sub_1002A20DC();
    int v16 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "EMBMSController not found", buf, 2u);
    }
    goto LABEL_16;
  }
LABEL_13:
  char v17 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 8))(v14);
  xpc_object_t v22 = xpc_BOOL_create(v17);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  *(void *)long long buf = *a5;
  char v21 = "kEMBMSStatus";
  sub_100035E70((uint64_t)buf, &v22, &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
LABEL_16:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_1002AB9C4(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AB9FC(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  xpc_object_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15)
  {
LABEL_7:
    sub_1002A20DC();
    char v17 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "EMBMSController not found", buf, 2u);
    }
    goto LABEL_20;
  }
LABEL_11:
  *(void *)long long buf = a4;
  xpc_object_t v28 = "kEMBMSServiceType";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v19 = xpc::dyn_cast_or_default((xpc *)&object, 0, v18);
  xpc_release(object);
  *(void *)long long buf = a4;
  xpc_object_t v28 = "kEMBMSEarfcn";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v21 = xpc::dyn_cast_or_default((xpc *)&object, 0, v20);
  xpc_release(object);
  xpc_object_t v22 = *a4;
  xpc_object_t v26 = v22;
  if (v22)
  {
    xpc_retain(v22);
  }
  else
  {
    xpc_object_t v22 = xpc_null_create();
    xpc_object_t v26 = v22;
  }
  uint64_t v23 = *a5;
  uint64_t v24 = a5[1];
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
  }
  char v31 = 0;
  int64_t v25 = operator new(0x20uLL);
  *int64_t v25 = off_1019B3650;
  v25[1] = v22;
  if (v22) {
    xpc_retain(v22);
  }
  else {
    v25[1] = xpc_null_create();
  }
  xpc_object_t v25[2] = v23;
  v25[3] = v24;
  char v31 = v25;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v15 + 16))(v15, v19, v21, v30);
  sub_10010E020(v30);
  xpc_release(v26);
LABEL_20:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1002ABCA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, char a16)
{
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002ABD34(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  xpc_object_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15)
  {
LABEL_7:
    sub_1002A20DC();
    char v17 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "EMBMSController not found", buf, 2u);
    }
    goto LABEL_20;
  }
LABEL_11:
  *(void *)long long buf = a4;
  xpc_object_t v26 = "kEMBMSSAIType";
  sub_100048BAC((uint64_t)buf, &object);
  uint64_t v19 = xpc::dyn_cast_or_default((xpc *)&object, 0, v18);
  xpc_release(object);
  xpc_object_t v20 = *a4;
  xpc_object_t v24 = v20;
  if (v20)
  {
    xpc_retain(v20);
  }
  else
  {
    xpc_object_t v20 = xpc_null_create();
    xpc_object_t v24 = v20;
  }
  uint64_t v21 = *a5;
  uint64_t v22 = a5[1];
  if (v22) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v29 = 0;
  uint64_t v23 = operator new(0x20uLL);
  void *v23 = off_1019B36D0;
  v23[1] = v20;
  if (v20) {
    xpc_retain(v20);
  }
  else {
    v23[1] = xpc_null_create();
  }
  v23[2] = v21;
  v23[3] = v22;
  unsigned int v29 = v23;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v15 + 24))(v15, v19, v28);
  sub_10010E020(v28);
  xpc_release(v24);
LABEL_20:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1002ABFA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, char a16)
{
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AC014(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  xpc_object_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15)
  {
LABEL_7:
    sub_1002A20DC();
    char v17 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "EMBMSController not found", buf, 2u);
    }
    goto LABEL_21;
  }
LABEL_11:
  if (xpc_dictionary_get_value(*a4, "kEMBMSSAIInterestedInfo"))
  {
    int64_t value = (ctu *)xpc_dictionary_get_value(*a4, "kEMBMSSAIInterestedInfo");
    ctu::xpc_to_cf((uint64_t *)buf, value, v19);
    sub_10004EFE4(&v25, (CFTypeRef *)buf);
    xpc_object_t v20 = *a4;
    xpc_object_t object = v20;
    if (v20)
    {
      xpc_retain(v20);
    }
    else
    {
      xpc_object_t v20 = xpc_null_create();
      xpc_object_t object = v20;
    }
    uint64_t v21 = *a5;
    uint64_t v22 = a5[1];
    if (v22) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
    }
    xpc_object_t v28 = 0;
    uint64_t v23 = operator new(0x20uLL);
    void *v23 = off_1019B3750;
    v23[1] = v20;
    if (v20) {
      xpc_retain(v20);
    }
    else {
      v23[1] = xpc_null_create();
    }
    v23[2] = v21;
    v23[3] = v22;
    xpc_object_t v28 = v23;
    (*(void (**)(uint64_t, const void **, void *))(*(void *)v15 + 32))(v15, &v25, v27);
    sub_100060644(v27);
    xpc_release(object);
    sub_100057D78(&v25);
    sub_1000577C4((const void **)buf);
  }
LABEL_21:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1002AC298(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1002AC314(uint64_t a1, BOOL a2, int a3)
{
  sub_1002A20DC();
  int v6 = qword_101B0CA28;
  if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "false";
    if (a2) {
      uint64_t v7 = "true";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Calling _CTGetCellularDataIsEnabledEx() -> %s, %d", buf, 0x12u);
  }
  if (a3)
  {
    xpc_object_t v10 = xpc_int64_create(a3);
    if (!v10) {
      xpc_object_t v10 = xpc_null_create();
    }
    *(void *)long long buf = *(void *)(a1 + 32);
    *(void *)&uint8_t buf[8] = "kPosixError";
    sub_100035E70((uint64_t)buf, &v10, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v10);
  }
  else
  {
    xpc_object_t v8 = xpc_BOOL_create(a2);
    if (!v8) {
      xpc_object_t v8 = xpc_null_create();
    }
    *(void *)long long buf = *(void *)(a1 + 32);
    *(void *)&uint8_t buf[8] = "kEnableCellularDataEx";
    sub_100035E70((uint64_t)buf, &v8, &v9);
    xpc_release(v9);
    xpc_object_t v9 = 0;
    xpc_release(v8);
  }
}

void sub_1002AC48C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002AC4CC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1002AC4E8(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1002AC4F8(uint64_t a1, xpc *a2)
{
  if (xpc_get_type(*(xpc_object_t *)a2) == (xpc_type_t)&_xpc_type_null) {
    char v5 = 0;
  }
  else {
    char v5 = xpc::dyn_cast_or_default(a2, 0, v4);
  }
  xpc_object_t v7 = xpc_BOOL_create(v5);
  if (!v7) {
    xpc_object_t v7 = xpc_null_create();
  }
  v6[0] = *(void *)(a1 + 32);
  v6[1] = "kCellularDataHideIndicator";
  sub_100035E70((uint64_t)v6, &v7, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v7);
}

void sub_1002AC5A8(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1002AC5FC((uint64_t *)v2);
    char v3 = **a1;
    operator delete(v3);
  }
}

void sub_1002AC5FC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 56)
  {
    BOOL v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
  a1[1] = v2;
}

void sub_1002AC648(uint64_t a1, int a2)
{
  if (a2)
  {
    xpc_object_t object = xpc_int64_create(a2);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = "kPosixError";
    sub_100035E70((uint64_t)&v5, &object, &v8);
    xpc_release(v8);
    xpc_object_t v8 = 0;
    xpc_release(object);
  }
  else
  {
    xpc_object_t v3 = xpc_int64_create(*(unsigned __int8 *)(a1 + 48));
    if (!v3) {
      xpc_object_t v3 = xpc_null_create();
    }
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = "kEnableCellularDataEx";
    sub_100035E70((uint64_t)&v5, &v3, &v4);
    xpc_release(v4);
    xpc_object_t v4 = 0;
    xpc_release(v3);
  }
}

void *sub_1002AC730(void *a1, CFTypeRef *a2)
{
  CFTypeRef v4 = *a2;
  if (*a2 && (CFTypeID v5 = CFGetTypeID(*a2), v5 == CFArrayGetTypeID()))
  {
    *a1 = v4;
  }
  else
  {
    *a1 = 0;
    if (*a2) {
      CFRelease(*a2);
    }
  }
  return a1;
}

uint64_t sub_1002AC79C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
  return a1;
}

uint64_t sub_1002AC7DC(uint64_t a1)
{
  *(void *)a1 = off_1019B3650;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  return a1;
}

void sub_1002AC838(uint64_t a1)
{
  *(void *)a1 = off_1019B3650;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;

  operator delete();
}

xpc_object_t *sub_1002AC8B4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = (xpc_object_t *)operator new(0x20uLL);
  *uint64_t v2 = off_1019B3650;
  sub_1002ACAC0(v2 + 1, v1);
  return v2;
}

xpc_object_t *sub_1002AC908(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B3650;
  return sub_1002ACAC0((xpc_object_t *)(a2 + 8), a1 + 8);
}

void sub_1002AC934(uint64_t a1)
{
}

void sub_1002AC93C(void *a1)
{
  sub_1002ACB20((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_1002AC978(uint64_t a1, const void **a2)
{
  xpc_object_t v7 = (ctu *)*a2;
  xpc_object_t v3 = v7;
  *a2 = 0;
  if (v3) {
    CFTypeRef v4 = sub_100080778;
  }
  else {
    CFTypeRef v4 = 0;
  }
  if (v4)
  {
    ctu::cf_to_xpc((uint64_t *)&object, v3, a2);
    *(void *)long long buf = *(void *)(a1 + 16);
    xpc_object_t v9 = "kEMBMSSigInfo";
    sub_100035E70((uint64_t)buf, &object, &v11);
    xpc_release(v11);
    xpc_object_t v11 = 0;
    xpc_release(object);
  }
  else
  {
    sub_1002A20DC();
    CFTypeID v5 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "kGetEMBMSSigInfo failure", buf, 2u);
    }
  }
  return sub_100057D78((const void **)&v7);
}

void sub_1002ACA60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002ACA74(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002ACAB4()
{
}

xpc_object_t *sub_1002ACAC0(xpc_object_t *a1, uint64_t a2)
{
  xpc_object_t v4 = *(xpc_object_t *)a2;
  *a1 = *(xpc_object_t *)a2;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    *a1 = xpc_null_create();
  }
  CFTypeID v5 = *(atomic_ullong **)(a2 + 16);
  a1[1] = *(xpc_object_t *)(a2 + 8);
  a1[2] = v5;
  if (v5) {
    atomic_fetch_add_explicit(v5 + 1, 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1002ACB20(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
}

uint64_t sub_1002ACB5C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
  return a1;
}

uint64_t sub_1002ACB9C(uint64_t a1)
{
  *(void *)a1 = off_1019B36D0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  return a1;
}

void sub_1002ACBF8(uint64_t a1)
{
  *(void *)a1 = off_1019B36D0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;

  operator delete();
}

xpc_object_t *sub_1002ACC74(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = (xpc_object_t *)operator new(0x20uLL);
  *uint64_t v2 = off_1019B36D0;
  sub_1002ACE80(v2 + 1, v1);
  return v2;
}

xpc_object_t *sub_1002ACCC8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B36D0;
  return sub_1002ACE80((xpc_object_t *)(a2 + 8), a1 + 8);
}

void sub_1002ACCF4(uint64_t a1)
{
}

void sub_1002ACCFC(void *a1)
{
  sub_1002ACEE0((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_1002ACD38(uint64_t a1, const void **a2)
{
  xpc_object_t v7 = (ctu *)*a2;
  xpc_object_t v3 = v7;
  *a2 = 0;
  if (v3) {
    xpc_object_t v4 = sub_100080778;
  }
  else {
    xpc_object_t v4 = 0;
  }
  if (v4)
  {
    ctu::cf_to_xpc((uint64_t *)&object, v3, a2);
    *(void *)long long buf = *(void *)(a1 + 16);
    xpc_object_t v9 = "kEMBMSSAIListInfo";
    sub_100035E70((uint64_t)buf, &object, &v11);
    xpc_release(v11);
    xpc_object_t v11 = 0;
    xpc_release(object);
  }
  else
  {
    sub_1002A20DC();
    CFTypeID v5 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "kGetEMBMSSAIListInfo failure", buf, 2u);
    }
  }
  return sub_100057D78((const void **)&v7);
}

void sub_1002ACE20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002ACE34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002ACE74()
{
}

xpc_object_t *sub_1002ACE80(xpc_object_t *a1, uint64_t a2)
{
  xpc_object_t v4 = *(xpc_object_t *)a2;
  *a1 = *(xpc_object_t *)a2;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    *a1 = xpc_null_create();
  }
  CFTypeID v5 = *(atomic_ullong **)(a2 + 16);
  a1[1] = *(xpc_object_t *)(a2 + 8);
  a1[2] = v5;
  if (v5) {
    atomic_fetch_add_explicit(v5 + 1, 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1002ACEE0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
}

uint64_t sub_1002ACF1C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
  return a1;
}

uint64_t sub_1002ACF5C(uint64_t a1)
{
  *(void *)a1 = off_1019B3750;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  return a1;
}

void sub_1002ACFB8(uint64_t a1)
{
  *(void *)a1 = off_1019B3750;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;

  operator delete();
}

xpc_object_t *sub_1002AD034(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = (xpc_object_t *)operator new(0x20uLL);
  *uint64_t v2 = off_1019B3750;
  sub_1002AD21C(v2 + 1, v1);
  return v2;
}

xpc_object_t *sub_1002AD088(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019B3750;
  return sub_1002AD21C((xpc_object_t *)(a2 + 8), a1 + 8);
}

void sub_1002AD0B4(uint64_t a1)
{
}

void sub_1002AD0BC(void *a1)
{
  sub_1002AD27C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1002AD0F8(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    xpc_object_t v5 = xpc_BOOL_create(1);
    if (!v5) {
      xpc_object_t v5 = xpc_null_create();
    }
    v4[0] = *(void *)(a1 + 16);
    v4[1] = "kDidSucceed";
    sub_100035E70((uint64_t)v4, &v5, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v5);
  }
  else
  {
    sub_1002A20DC();
    xpc_object_t v3 = qword_101B0CA28;
    if (os_log_type_enabled((os_log_t)qword_101B0CA28, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v4[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "kSetEMBMSSAIInterestedInfo failure", (uint8_t *)v4, 2u);
    }
  }
}

uint64_t sub_1002AD1D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002AD210()
{
}

xpc_object_t *sub_1002AD21C(xpc_object_t *a1, uint64_t a2)
{
  xpc_object_t v4 = *(xpc_object_t *)a2;
  *a1 = *(xpc_object_t *)a2;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    *a1 = xpc_null_create();
  }
  xpc_object_t v5 = *(atomic_ullong **)(a2 + 16);
  a1[1] = *(xpc_object_t *)(a2 + 8);
  a1[2] = v5;
  if (v5) {
    atomic_fetch_add_explicit(v5 + 1, 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1002AD27C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
}

uint64_t sub_1002AD2B8()
{
  return sub_100C624B8((uint64_t)&unk_101B0CA22, (uint64_t)sub_1002A2410);
}

uint64_t *sub_1002AD2D4(uint64_t a1)
{
  sub_100C62700(a1, "kPhoneBookGetProperty", (unint64_t)sub_1002AD3B0, 3u);
  sub_100C62630(a1, "kPhoneBookSelect", (unint64_t)sub_1002AD5B0, 3u);
  sub_100C62630(a1, "kPhoneBookSaveContact", (unint64_t)sub_1002AD7F0, 3u);
  sub_100C62630(a1, "kPhoneBookFetch", (unint64_t)sub_1002ADB30, 3u);

  return sub_100C62700(a1, "kPhoneBookGetEntry", (unint64_t)sub_1002ADC5C, 3u);
}

void sub_1002AD3B0(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, unint64_t *a5)
{
  if (!xpc_dictionary_get_value(*a4, "kPhoneBookEntryCount")) {
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    xpc_object_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  v19[0] = v9;
  xpc_object_t v13 = sub_10004D37C(&v8[1].__m_.__sig, v19);
  if (v13)
  {
    uint64_t v14 = v13[3];
    uint64_t v15 = (std::__shared_weak_count *)v13[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v16 = 0;
      if (!v14) {
        goto LABEL_14;
      }
LABEL_11:
      unint64_t v18 = *a5;
      unint64_t v17 = a5[1];
      if (v17) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
      }
      v21[0] = off_1019B37D0;
      v21[1] = v18;
      v21[2] = v17;
      v21[3] = v21;
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v14 + 64))(v14, 1, v21);
      sub_1002AE148(v21);
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v15 = 0;
  char v16 = 1;
  if (v14) {
    goto LABEL_11;
  }
LABEL_14:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (!v14)
  {
    v19[0] = *a5;
    v19[1] = (unint64_t)"kPhoneBookEntryCount";
    sub_10021ACC8((uint64_t)v19, &object);
    xpc_release(object);
  }
}

void sub_1002AD578(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1002AD5B0(Registry **a1, uint64_t a2, uint64_t a3, void *a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  int v6 = ServiceMap;
  if (v7 < 0)
  {
    xpc_object_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&__p);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_9:
    std::mutex::unlock(v6);
    unsigned int v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_19;
    }
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  unsigned int v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (!v13) {
    goto LABEL_19;
  }
LABEL_10:
  v21[0] = 0;
  v21[1] = 0;
  uint64_t v22 = 0;
  v19[0] = a4;
  v19[1] = "kPhoneBookPassword";
  sub_100048BAC((uint64_t)v19, &object);
  std::string __p = 0;
  xpc_object_t v24 = 0;
  uint64_t v25 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v25) < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  std::string __p = a4;
  xpc_object_t v24 = "kPhoneBookName";
  sub_100048BAC((uint64_t)&__p, v19);
  unsigned int v16 = xpc::dyn_cast_or_default((xpc *)v19, 0, v15);
  xpc_release(v19[0]);
  if (v16 - 1 >= 3) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = v16;
  }
  if (v22 >= 0) {
    unint64_t v18 = v21;
  }
  else {
    unint64_t v18 = (void **)v21[0];
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, void **))(*(void *)v13 + 16))(v13, 1, v17, v18);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
LABEL_19:
    if (v14) {
      return;
    }
    goto LABEL_20;
  }
  operator delete(v21[0]);
  if (v14) {
    return;
  }
LABEL_20:
  sub_10004D2C8(v12);
}

void sub_1002AD778(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AD7F0(Registry **a1, uint64_t a2, uint64_t a3, void *a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  int v6 = ServiceMap;
  if (v7 < 0)
  {
    xpc_object_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&__p);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_9:
    std::mutex::unlock(v6);
    unsigned int v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_28;
    }
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  unsigned int v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (!v13) {
    goto LABEL_28;
  }
LABEL_10:
  v33[0] = 0;
  v33[1] = 0;
  uint64_t v34 = 0;
  xpc_object_t v30 = a4;
  char v31 = "kPhoneBookContactName";
  sub_100048BAC((uint64_t)&v30, object);
  std::string __p = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v20) < 0) {
    operator delete(__p);
  }
  xpc_release(object[0]);
  xpc_object_t v30 = 0;
  char v31 = 0;
  uint64_t v32 = 0;
  object[0] = a4;
  object[1] = "kPhoneBookContactNumber";
  sub_100048BAC((uint64_t)object, &v29);
  std::string __p = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v20) < 0) {
    operator delete(__p);
  }
  xpc_release(v29);
  std::string __p = a4;
  uint64_t v19 = "kPhoneBookEntryIndex";
  sub_100048BAC((uint64_t)&__p, object);
  uint64_t v16 = xpc::dyn_cast_or_default((xpc *)object, 0, v15);
  xpc_release(object[0]);
  CSIPhoneNumber::CSIPhoneNumber();
  if (v34 >= 0) {
    uint64_t v17 = v33;
  }
  else {
    uint64_t v17 = (void **)v33[0];
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, void **, void **))(*(void *)v13 + 32))(v13, 1, v16, &__p, v17);
  if (v27 < 0) {
    operator delete(v26);
  }
  if (v25 < 0) {
    operator delete(v24);
  }
  if (v23 < 0) {
    operator delete(v22);
  }
  if (v21 < 0) {
    operator delete(v19);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v30);
  }
  if ((SHIBYTE(v34) & 0x80000000) == 0)
  {
LABEL_28:
    if (v14) {
      return;
    }
    goto LABEL_29;
  }
  operator delete(v33[0]);
  if (v14) {
    return;
  }
LABEL_29:
  sub_10004D2C8(v12);
}

void sub_1002ADA68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,xpc_object_t object)
{
  sub_100087E24((uint64_t)&__p);
  if (*(char *)(v31 - 89) < 0) {
    operator delete(*(void **)(v31 - 112));
  }
  if (*(char *)(v31 - 65) < 0) {
    operator delete(*(void **)(v31 - 88));
  }
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  _Unwind_Resume(a1);
}

void sub_1002ADB30(Registry **a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    xpc_object_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v11 = v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v11);
  if (!v7)
  {
    uint64_t v9 = 0;
LABEL_9:
    std::mutex::unlock(v2);
    xpc_object_t v8 = 0;
    char v10 = 1;
    if (!v9) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v9 = v7[3];
  xpc_object_t v8 = (std::__shared_weak_count *)v7[4];
  if (!v8) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v2);
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  char v10 = 0;
  if (v9) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 48))(v9, 1);
LABEL_11:
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
}

void sub_1002ADC3C(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002ADC5C(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  xpc_object_t v8 = ServiceMap;
  if (v9 < 0)
  {
    char v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&v23[0] = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)v23);
  if (v13)
  {
    uint64_t v15 = v13[3];
    char v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  char v14 = 0;
  char v16 = 1;
  if (!v15) {
    goto LABEL_13;
  }
LABEL_10:
  memset(v23, 0, sizeof(v23));
  sub_1002AE1CC((uint64_t)v23);
  v21[0] = a4;
  v21[1] = "kPhoneBookEntryIndex";
  sub_100048BAC((uint64_t)v21, &object);
  uint64_t v18 = xpc::dyn_cast_or_default((xpc *)&object, 0, v17);
  xpc_release(object);
  uint64_t v20 = *a5;
  uint64_t v19 = a5[1];
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  v24[0] = off_1019B3860;
  v24[1] = v20;
  v24[2] = v19;
  v24[3] = v24;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v15 + 72))(v15, 1, v18, v24);
  sub_1002AEBA8(v24);
  sub_100039D40((uint64_t)v23);
LABEL_13:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1002ADE68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, char a13)
{
  sub_1002AEBA8((void *)(v15 - 104));
  sub_100039D40((uint64_t)&a13);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  _Unwind_Resume(a1);
}

void *sub_1002ADED0(void *a1)
{
  *a1 = off_1019B37D0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1002ADF1C(void *a1)
{
  *a1 = off_1019B37D0;
  char v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_1002ADF88(uint64_t a1)
{
  id result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019B37D0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1002ADFE4(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019B37D0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1002AE01C(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1002AE02C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_1002AE06C(uint64_t a1, unsigned char *a2, int *a3)
{
  if (*a2) {
    int64_t v4 = *a3;
  }
  else {
    int64_t v4 = 0;
  }
  xpc_object_t v6 = xpc_int64_create(v4);
  if (!v6) {
    xpc_object_t v6 = xpc_null_create();
  }
  v5[0] = *(void *)(a1 + 8);
  v5[1] = "kPhoneBookEntryCount";
  sub_100035E70((uint64_t)v5, &v6, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v6);
}

uint64_t sub_1002AE0FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002AE13C()
{
}

void *sub_1002AE148(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1002AE1CC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v2 = (unsigned char *)(a1 + 8);
  *(void *)(a1 + 24) = 0;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 32));
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 168));
  *(void *)(a1 + 368) = 0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)a1 = -1;
  if (*(char *)(a1 + 31) < 0)
  {
    *(void *)(a1 + 16) = 0;
    uint64_t v3 = *(unsigned char **)(a1 + 8);
  }
  else
  {
    *(unsigned char *)(a1 + 31) = 0;
    uint64_t v3 = v2;
  }
  int64_t v4 = (unsigned char *)(a1 + 304);
  uint64_t v5 = (unsigned char *)(a1 + 328);
  xpc_object_t v6 = (unsigned char *)(a1 + 352);
  *uint64_t v3 = 0;
  CSIPhoneNumber::CSIPhoneNumber(&v18, "");
  *(void *)(a1 + 32) = *(void *)&v18.var0;
  uint64_t v7 = (void **)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*v7);
  }
  *(_OWORD *)uint64_t v7 = *(_OWORD *)v18.var2.__r_.__value_.var0.var0.__data_;
  *(void *)(a1 + 56) = *((void *)&v18.var2.__r_.__value_.var0.var1 + 2);
  *((unsigned char *)&v18.var2.__r_.__value_.var0.var1 + 23) = 0;
  v18.var2.__r_.__value_.var0.var0.__data_[0] = 0;
  xpc_object_t v8 = (void **)(a1 + 64);
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*v8);
  }
  *(_OWORD *)xpc_object_t v8 = *(_OWORD *)&v18.var2.__r_.var0;
  *(void *)(a1 + 80) = v19;
  HIBYTE(v19) = 0;
  LOBYTE(v18.var2.__r_.var0) = 0;
  *(_DWORD *)(a1 + 88) = v20;
  *(unsigned char *)(a1 + 92) = v21;
  uint64_t v9 = (void **)(a1 + 96);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*v9);
  }
  char v10 = 0;
  *(_OWORD *)uint64_t v9 = __p;
  *(void *)(a1 + 112) = v23;
  HIBYTE(v23) = 0;
  LOBYTE(__p) = 0;
  uint64_t v11 = (void **)(a1 + 120);
  if (*(char *)(a1 + 143) < 0)
  {
    operator delete(*v11);
    char v10 = HIBYTE(v23);
  }
  *(_OWORD *)uint64_t v11 = v24;
  *(void *)(a1 + 136) = v25;
  HIBYTE(v25) = 0;
  LOBYTE(v24) = 0;
  *(_OWORD *)(a1 + 144) = v26;
  *(unsigned char *)(a1 + 160) = v27;
  if (v10 < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(*(void **)&v18.var2.__r_.var0);
  }
  if (*((char *)&v18.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(v18.var2.__r_.__value_.var0.var1.__data_);
  }
  CSIPhoneNumber::CSIPhoneNumber(&v18, "");
  *(void *)(a1 + 168) = *(void *)&v18.var0;
  unsigned int v12 = (void **)(a1 + 176);
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*v12);
  }
  *(_OWORD *)unsigned int v12 = *(_OWORD *)v18.var2.__r_.__value_.var0.var0.__data_;
  *(void *)(a1 + 192) = *((void *)&v18.var2.__r_.__value_.var0.var1 + 2);
  *((unsigned char *)&v18.var2.__r_.__value_.var0.var1 + 23) = 0;
  v18.var2.__r_.__value_.var0.var0.__data_[0] = 0;
  uint64_t v13 = (void **)(a1 + 200);
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*v13);
  }
  *(_OWORD *)uint64_t v13 = *(_OWORD *)&v18.var2.__r_.var0;
  *(void *)(a1 + 216) = v19;
  HIBYTE(v19) = 0;
  LOBYTE(v18.var2.__r_.var0) = 0;
  *(_DWORD *)(a1 + 224) = v20;
  *(unsigned char *)(a1 + 228) = v21;
  char v14 = (void **)(a1 + 232);
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*v14);
  }
  *(_OWORD *)char v14 = __p;
  *(void *)(a1 + 248) = v23;
  HIBYTE(v23) = 0;
  LOBYTE(__p) = 0;
  uint64_t v15 = (_OWORD *)(a1 + 256);
  if (*(char *)(a1 + 279) < 0)
  {
    operator delete(*(void **)(a1 + 256));
    int v16 = SHIBYTE(v23);
    *uint64_t v15 = v24;
    *(void *)(a1 + 272) = v25;
    HIBYTE(v25) = 0;
    LOBYTE(v24) = 0;
    *(_OWORD *)(a1 + 280) = v26;
    *(unsigned char *)(a1 + 296) = v27;
    if (v16 < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    *uint64_t v15 = v24;
    *(void *)(a1 + 272) = v25;
    HIBYTE(v25) = 0;
    LOBYTE(v24) = 0;
    *(unsigned char *)(a1 + 296) = v27;
    *(_OWORD *)(a1 + 280) = v26;
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(*(void **)&v18.var2.__r_.var0);
  }
  if (*((char *)&v18.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(v18.var2.__r_.__value_.var0.var1.__data_);
  }
  if (*(char *)(a1 + 327) < 0)
  {
    *(void *)(a1 + 312) = 0;
    int64_t v4 = *(unsigned char **)(a1 + 304);
  }
  else
  {
    *(unsigned char *)(a1 + 327) = 0;
  }
  *int64_t v4 = 0;
  if (*(char *)(a1 + 351) < 0)
  {
    *(void *)(a1 + 336) = 0;
    uint64_t v5 = *(unsigned char **)(a1 + 328);
  }
  else
  {
    *(unsigned char *)(a1 + 351) = 0;
  }
  unsigned char *v5 = 0;
  if (*(char *)(a1 + 375) < 0)
  {
    *(void *)(a1 + 360) = 0;
    xpc_object_t v6 = *(unsigned char **)(a1 + 352);
  }
  else
  {
    *(unsigned char *)(a1 + 375) = 0;
  }
  unsigned char *v6 = 0;
  *(unsigned char *)(a1 + 376) = 0;
  return a1;
}

void sub_1002AE568(_Unwind_Exception *a1)
{
  if (v1[375] < 0) {
    operator delete(*v4);
  }
  if (v1[351] < 0) {
    operator delete(*v5);
  }
  if (v1[327] < 0) {
    operator delete(*v6);
  }
  sub_100087E24(v3);
  sub_100087E24(v2);
  if (v1[31] < 0) {
    operator delete(*v7);
  }
  _Unwind_Resume(a1);
}

void *sub_1002AE5D8(void *a1)
{
  *a1 = off_1019B3860;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1002AE624(void *a1)
{
  *a1 = off_1019B3860;
  char v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_1002AE690(uint64_t a1)
{
  id result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019B3860;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1002AE6EC(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019B3860;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1002AE724(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1002AE734(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_1002AE774(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  if (*a2)
  {
    xpc_object_t v5 = xpc_int64_create(*(void *)a3);
    char v10 = v5;
    if (!v5)
    {
      xpc_object_t v5 = xpc_null_create();
      char v10 = v5;
    }
    xpc_object_t v6 = (void *)(a1 + 8);
    sub_1002AE9BC(v6, @"kCTPhoneBookSlotKey", &v10);
    xpc_release(v5);
    char v10 = 0;
    sub_1002AEAA0(v6, @"kCTPhoneBookNameKey", a3 + 8);
    CSIPhoneNumber::getFullNumber((uint64_t *)__p, (CSIPhoneNumber *)(a3 + 32));
    sub_1002AEAA0(v6, @"kCTPhoneBookNumberKey", (uint64_t)__p);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    CSIPhoneNumber::getFullNumber((uint64_t *)__p, (CSIPhoneNumber *)(a3 + 168));
    sub_1002AEAA0(v6, @"kCTPhoneBookAltNumberKey", (uint64_t)__p);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    sub_1002AEAA0(v6, @"kCTPhoneBookGroupKey", a3 + 304);
    sub_1002AEAA0(v6, @"kCTPhoneBookAltTextKey", a3 + 328);
    sub_1002AEAA0(v6, @"kCTPhoneBookEmailKey", a3 + 352);
    if (*(unsigned char *)(a3 + 376))
    {
      xpc_object_t v7 = xpc_BOOL_create(1);
      __p[0] = v7;
      if (!v7)
      {
        xpc_object_t v7 = xpc_null_create();
        __p[0] = v7;
      }
      sub_1002AE9BC(v6, @"kCTPhoneBookHiddenKey", __p);
      xpc_release(v7);
    }
  }
}

void sub_1002AE91C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  xpc_release(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_1002AE970(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1002AE9B0()
{
}

void sub_1002AE9BC(void *a1, uint64_t a2, void **a3)
{
  long long v11 = 0uLL;
  uint64_t v12 = 0;
  ctu::cf::assign();
  *(_OWORD *)long long __p = 0uLL;
  uint64_t v10 = 0;
  xpc_object_t v5 = *a3;
  xpc_object_t v7 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_object_t v6 = __p;
  if (v10 < 0) {
    xpc_object_t v6 = (void **)__p[0];
  }
  *(void *)&long long v11 = *a1;
  *((void *)&v11 + 1) = v6;
  sub_100035E70((uint64_t)&v11, &v7, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v7);
  xpc_object_t v7 = 0;
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002AEA84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AEAA0(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a3 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a3 + 8);
  }
  if (v3)
  {
    long long v12 = 0uLL;
    uint64_t v13 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __p = 0uLL;
    uint64_t v11 = 0;
    if (*(char *)(a3 + 23) >= 0) {
      xpc_object_t v6 = (const char *)a3;
    }
    else {
      xpc_object_t v6 = *(const char **)a3;
    }
    xpc_object_t v8 = xpc_string_create(v6);
    if (!v8) {
      xpc_object_t v8 = xpc_null_create();
    }
    xpc_object_t v7 = __p;
    if (v11 < 0) {
      xpc_object_t v7 = (void **)__p[0];
    }
    *(void *)&long long v12 = *a1;
    *((void *)&v12 + 1) = v7;
    sub_100035E70((uint64_t)&v12, &v8, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v8);
    xpc_object_t v8 = 0;
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1002AEB8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002AEBA8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1002AEC2C()
{
  return sub_100C624B8((uint64_t)&unk_101B0CA38, (uint64_t)sub_1002AD2D4);
}

void sub_1002AEC48(uint64_t a1@<X0>, os_log_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t **a4@<X3>, uint64_t a5@<X4>, NSObject **a6@<X5>, _OWORD *a7@<X8>)
{
  uint64_t v11 = (std::__shared_weak_count *)a3[1];
  long long v12 = (Registry **)(a1 + 8);
  uint64_t v15 = *a3;
  int v16 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *a6;
  dispatch_object_t object = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  sub_1009292C0(a2, v12, (uint64_t)&v15, a4, a5, &object, a7);
  if (object) {
    dispatch_release(object);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_1002AECF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AED14(uint64_t a1@<X0>, os_log_t *a2@<X1>, uint64_t **a3@<X2>, NSObject **a4@<X3>, uint64_t a5@<X4>, _OWORD *a6@<X8>)
{
  uint64_t v10 = (Registry **)(a1 + 8);
  uint64_t v11 = *a4;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  sub_10092A508(a2, v10, (uint64_t)&_mh_execute_header, 2, a3, &object, a5, a6);
  if (object) {
    dispatch_release(object);
  }
}

void sub_1002AED9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1002AEDB4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CA40, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CA40))
  {
    sub_100058DB0(v8, "com.apple.mobilephone");
    sub_100058DB0(v9, "com.apple.MobileAddressBook");
    sub_1000EA30C((uint64_t)v3, v8, 2);
    uint64_t v10 = "com.apple.MobileAddressBook";
    sub_1000C6BDC(v11, (uint64_t)v3);
    sub_1002AFEA0(&v5, (unint64_t *)&v10, 1);
    char v1 = v6;
    qword_101B0CA68 = (uint64_t)v5;
    qword_101B0CA70 = v6;
    qword_101B0CA78 = v7;
    if (v7)
    {
      void v6[2] = &qword_101B0CA70;
      xpc_object_t v5 = (uint64_t *)&v6;
      xpc_object_t v6 = 0;
      uint64_t v7 = 0;
      char v1 = 0;
    }
    else
    {
      qword_101B0CA68 = (uint64_t)&qword_101B0CA70;
    }
    sub_1001FEB64((uint64_t)&v5, v1);
    sub_10005CD2C((uint64_t)v11, (char *)v11[1]);
    sub_10005CD2C((uint64_t)v3, v4);
    for (uint64_t i = 0; i != -6; i -= 3)
    {
      if (SHIBYTE(v9[i + 2]) < 0) {
        operator delete(v8[i + 3]);
      }
    }
    __cxa_guard_release(&qword_101B0CA40);
  }
  return &qword_101B0CA68;
}

void sub_1002AEF38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, char *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  sub_10005CD2C(v27, *(char **)(v28 - 56));
  sub_10005CD2C((uint64_t)&a10, a11);
  uint64_t v30 = 0;
  while (1)
  {
    if (*(&a27 + v30) < 0) {
      operator delete(*(void **)((char *)&a22 + v30));
    }
    v30 -= 24;
    if (v30 == -48)
    {
      __cxa_guard_abort(&qword_101B0CA40);
      _Unwind_Resume(a1);
    }
  }
}

long long *sub_1002AEFC0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CA48, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CA48))
  {
    sub_100058DB0(&v5, "com.apple.findmy");
    sub_100058DB0(v6, "com.apple.mobileme.fmf1");
    sub_1001F69F4((uint64_t)v7, &v5, 2uLL);
    sub_1002AF170(&v2, v7, 1uLL);
    xmmword_101B0CA80 = v2;
    qword_101B0CA90 = v3;
    uint64_t v3 = 0;
    long long v2 = 0uLL;
    uint64_t v4 = (void **)&v2;
    sub_1000D9554(&v4);
    uint64_t v4 = (void **)v7;
    sub_100047F64(&v4);
    for (uint64_t i = 0; i != -6; i -= 3)
    {
      if (SHIBYTE(v6[i + 2]) < 0) {
        operator delete((void *)v6[i]);
      }
    }
    __cxa_guard_release(&qword_101B0CA48);
  }
  return &xmmword_101B0CA80;
}

void sub_1002AF0FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  sub_100047F64((void ***)&a12);
  uint64_t v25 = 0;
  while (1)
  {
    if (*(&a24 + v25) < 0) {
      operator delete(*(void **)((char *)&a19 + v25));
    }
    v25 -= 24;
    if (v25 == -48)
    {
      __cxa_guard_abort(&qword_101B0CA48);
      _Unwind_Resume(a1);
    }
  }
}

void *sub_1002AF170(void *a1, long long **a2, unint64_t a3)
{
  a1[2] = 0;
  uint64_t v4 = (uint64_t)(a1 + 2);
  *a1 = 0;
  a1[1] = 0;
  if (a3)
  {
    sub_1000D89C4(a1, a3);
    a1[1] = sub_1002AFBB8(v4, a2, &a2[3 * a3], a1[1]);
  }
  return a1;
}

void sub_1002AF1F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1000D9554(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1002AF210()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CA50, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CA50))
  {
    qword_101B0CAA0 = 0;
    unk_101B0CAA8 = 0;
    qword_101B0CA98 = 0;
    memset(v1, 0, sizeof(v1));
    long long v2 = (void **)v1;
    sub_1000D9554(&v2);
    __cxa_guard_release(&qword_101B0CA50);
  }
  return &qword_101B0CA98;
}

void sub_1002AF28C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

_OWORD *sub_1002AF298()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CA58, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CA58))
  {
    v3[0] = "com.apple.MobileSMS";
    v3[1] = "com.apple.message-payload-provider";
    sub_1002AF36C(&v1, (uint64_t)v3, 1uLL);
    xmmword_101B0CAB0 = v1;
    qword_101B0CAC0 = v2;
    __cxa_guard_release(&qword_101B0CA58);
  }
  return &xmmword_101B0CAB0;
}

void sub_1002AF354(_Unwind_Exception *a1)
{
}

void *sub_1002AF36C(void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >> 60) {
      sub_10006A748();
    }
    uint64_t v6 = 16 * a3;
    uint64_t v7 = (char *)operator new(16 * a3);
    uint64_t v8 = 0;
    *a1 = v7;
    a1[1] = v7;
    a1[2] = &v7[16 * a3];
    do
    {
      *(_OWORD *)&v7[v8] = *(_OWORD *)(a2 + v8);
      v8 += 16;
    }
    while (v6 != v8);
    a1[1] = &v7[v8];
  }
  return a1;
}

void sub_1002AF3F4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AF410()
{
}

void sub_1002AF418(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1003F3060();
}

void sub_1002AF4AC(_Unwind_Exception *exception_object)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AF4D0(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = operator new(0x360uLL);
  uint64_t v5 = 0;
  a2[2] = (uint64_t)(v4 + 108);
  *a2 = (uint64_t)v4;
  a2[1] = (uint64_t)v4;
  uint64_t v22 = v4;
  uint64_t v23 = v4;
  v20[0] = (unint64_t)(a2 + 2);
  v20[1] = (unint64_t)&v22;
  xpc_object_t v20[2] = (unint64_t)&v23;
  uint64_t v21 = 0;
  uint64_t v6 = v4;
  do
  {
    sub_100058DB0(v6, off_1019B3980[v5]);
    uint64_t v6 = v23 + 3;
    v23 += 3;
    ++v5;
  }
  while (v5 != 36);
  LOBYTE(v21) = 1;
  sub_10005E1C8((uint64_t)v20);
  a2[1] = (uint64_t)v6;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  v20[0] = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, v20);
  if (v13)
  {
    uint64_t v15 = v13[3];
    char v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  char v14 = 0;
  char v16 = 1;
LABEL_11:
  int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 72))(v15);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (v17)
  {
    unint64_t v18 = a2[1];
    if (v18 >= a2[2])
    {
      uint64_t v19 = sub_1002AFC74(a2, "com.apple.MobileSMS");
    }
    else
    {
      sub_100058DB0((void *)a2[1], "com.apple.MobileSMS");
      uint64_t v19 = v18 + 24;
      a2[1] = v18 + 24;
    }
    a2[1] = v19;
  }
}

void sub_1002AF6A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

void sub_1002AF700(capabilities::ct *a1@<X0>, uint64_t a2@<X8>)
{
  if (capabilities::ct::supportsP2PAsPhone(a1))
  {
    uint64_t v3 = preInstalledApps::kWatch;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)a2 = a2 + 8;
    if ((uint64_t *)v3 != &qword_101B141A0)
    {
      do
      {
        sub_1002B0044((uint64_t **)a2, a2 + 8, (char **)(v3 + 32));
        uint64_t v4 = *(uint64_t **)(v3 + 8);
        if (v4)
        {
          do
          {
            uint64_t v5 = v4;
            uint64_t v4 = (uint64_t *)*v4;
          }
          while (v4);
        }
        else
        {
          do
          {
            uint64_t v5 = *(uint64_t **)(v3 + 16);
            BOOL v6 = *v5 == v3;
            uint64_t v3 = (uint64_t)v5;
          }
          while (!v6);
        }
        uint64_t v3 = (uint64_t)v5;
      }
      while (v5 != &qword_101B141A0);
    }
  }
  else
  {
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)a2 = a2 + 8;
  }
}

void sub_1002AF7B8(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1002AF7D0(uint64_t a1@<X8>)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  sub_1002B0044((uint64_t **)a1, a1 + 8, off_1019B3AA0);
}

void sub_1002AF810(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1002AF828(char **a1@<X8>)
{
  sub_100058DB0(__p, "com.apple.iCloudDriveApp");
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = (char *)operator new(0x18uLL);
  *a1 = v2;
  a1[1] = v2;
  a1[2] = v2 + 24;
  a1[1] = sub_1000D8A18((uint64_t)(a1 + 2), (long long *)__p, &v5, v2);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002AF8DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v18 = v17;
  *(void *)(v16 + 8) = v18;
  sub_100047F64((void ***)&a9);
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

long long *sub_1002AF918()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0CA60, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0CA60))
  {
    long long v3 = *(_OWORD *)off_1019B3AA8;
    char v4 = "com.apple.MobileAddressBook";
    sub_1002AF9F0(&v1, &v3, 3uLL);
    xmmword_101B0CAD0 = v1;
    qword_101B0CAE0 = v2;
    __cxa_guard_release(&qword_101B0CA60);
  }
  return &xmmword_101B0CAD0;
}

void sub_1002AF9D8(_Unwind_Exception *a1)
{
}

void *sub_1002AF9F0(void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    sub_1000D8590(a1, a3);
    BOOL v6 = (char *)a1[1];
    memmove(v6, a2, 8 * a3);
    a1[1] = &v6[8 * a3];
  }
  return a1;
}

void sub_1002AFA58(_Unwind_Exception *exception_object)
{
  long long v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002AFA74@<D0>(CCPreferences *a1@<X0>, _OWORD *a2@<X8>)
{
  CCPreferences::create((uint64_t *)&v4, a1);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_1002AFAAC()
{
  CellularUsageReliableNetworkFallback::create(&v0);
}

void sub_1002AFAEC(NetworkAccessInterface *this)
{
  *(void *)this = off_1019B38F0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  NetworkAccessInterface::~NetworkAccessInterface(this);
}

void sub_1002AFB48(NetworkAccessInterface *this)
{
  *(void *)this = off_1019B38F0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  NetworkAccessInterface::~NetworkAccessInterface(this);

  operator delete();
}

uint64_t sub_1002AFBB8(uint64_t a1, long long **a2, long long **a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  _DWORD v8[2] = &v11;
  uint64_t v9 = 0;
  if (a2 != a3)
  {
    BOOL v6 = a2;
    do
    {
      *(void *)uint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
      *(void *)(v4 + 16) = 0;
      sub_1000302C0((char *)v4, *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v6[1] - (char *)*v6) >> 3));
      uint64_t v4 = v11 + 24;
      v11 += 24;
      v6 += 3;
    }
    while (v6 != a3);
  }
  LOBYTE(v9) = 1;
  sub_1000D94D0((uint64_t)v8);
  return v4;
}

void sub_1002AFC60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002AFC74(uint64_t *a1, char *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_1000D8578();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10004812C(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  char v14 = &v10[24 * v4];
  uint64_t v16 = &v10[24 * v9];
  sub_100058DB0(v14, a2);
  uint64_t v15 = v14 + 24;
  sub_100048204(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100048174((uint64_t)&v13);
  return v11;
}

void sub_1002AFD68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100048174((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_1002AFD7C@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  double result = operator new(0x30uLL);
  result[1] = 0;
  result[2] = 0;
  void *result = off_1019B3AE8;
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  result[3] = off_1019B38F0;
  result[4] = v6;
  result[5] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1002AFE04(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3AE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002AFE24(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3AE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002AFE78(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 128))();
}

uint64_t **sub_1002AFEA0(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  a1[1] = 0;
  unint64_t v4 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  if (a3)
  {
    uint64_t v5 = a2;
    uint64_t v6 = 0;
    uint64_t v7 = &a2[4 * a3];
    unint64_t v8 = a1 + 1;
    while (1)
    {
      unint64_t v9 = *v5;
      uint64_t v10 = v4;
      if (v8 == (uint64_t **)v4) {
        break;
      }
      uint64_t v11 = v6;
      unsigned int v12 = v4;
      if (v6)
      {
        do
        {
          uint64_t v10 = v11;
          uint64_t v11 = (uint64_t *)v11[1];
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v10 = (uint64_t *)v12[2];
          BOOL v13 = *v10 == (void)v12;
          unsigned int v12 = v10;
        }
        while (v13);
      }
      if (v10[4] < v9) {
        break;
      }
      uint64_t v15 = (uint64_t **)v4;
      char v14 = (uint64_t **)v4;
      if (!v6) {
        goto LABEL_25;
      }
      uint64_t v16 = v6;
      while (1)
      {
        while (1)
        {
          char v14 = (uint64_t **)v16;
          unint64_t v17 = v16[4];
          if (v17 <= v9) {
            break;
          }
          uint64_t v16 = *v14;
          uint64_t v15 = v14;
          if (!*v14) {
            goto LABEL_25;
          }
        }
        if (v17 >= v9) {
          break;
        }
        uint64_t v16 = v14[1];
        if (!v16)
        {
          uint64_t v15 = v14 + 1;
          goto LABEL_25;
        }
      }
LABEL_28:
      v5 += 4;
      if (v5 == v7) {
        return a1;
      }
      unint64_t v8 = (uint64_t **)*a1;
      uint64_t v6 = a1[1];
    }
    if (v6) {
      char v14 = (uint64_t **)v10;
    }
    else {
      char v14 = (uint64_t **)v4;
    }
    if (v6) {
      uint64_t v15 = (uint64_t **)(v10 + 1);
    }
    else {
      uint64_t v15 = (uint64_t **)v4;
    }
    if (*v15) {
      goto LABEL_28;
    }
LABEL_25:
    uint64_t v18 = (uint64_t *)operator new(0x40uLL);
    v18[4] = v9;
    sub_1000C6BDC(v18 + 5, (uint64_t)(v5 + 1));
    uint64_t *v18 = 0;
    v18[1] = 0;
    void v18[2] = (uint64_t)v14;
    *uint64_t v15 = v18;
    uint64_t v19 = (uint64_t *)**a1;
    if (v19)
    {
      *a1 = v19;
      uint64_t v18 = *v15;
    }
    sub_100046C90(a1[1], v18);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    goto LABEL_28;
  }
  return a1;
}

void sub_1002B0018(_Unwind_Exception *a1)
{
  operator delete(v2);
  sub_1001FEB64(v1, *v3);
  _Unwind_Resume(a1);
}

void sub_1002B0044(uint64_t **a1, uint64_t a2, char **a3)
{
  long long __p = 0;
  v10[0] = 0;
  v10[1] = 0;
  sub_1002B00FC((uint64_t)a1, a3, &__p);
  uint64_t v7 = 0;
  unint64_t v8 = 0;
  uint64_t v5 = sub_1000C6D50(a1, a2, &v8, &v7, (void **)__p + 4);
  if (*v5)
  {
    uint64_t v6 = (void **)__p;
    long long __p = 0;
    if (v6) {
      sub_1000C6EE8((uint64_t)v10, v6);
    }
  }
  else
  {
    sub_100046C38(a1, (uint64_t)v8, (uint64_t **)v5, (uint64_t *)__p);
  }
}

void sub_1002B00D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p) {
    sub_1000C6EE8((uint64_t)&a13, __p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002B00FC@<X0>(uint64_t a1@<X0>, char **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  uint64_t v6 = a3 + 1;
  uint64_t v7 = operator new(0x38uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  double result = sub_100058DB0(v7 + 4, *a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1002B0170(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v2, v3);
  _Unwind_Resume(a1);
}

void *sub_1002B018C(void *a1, void *a2, long long *a3)
{
  uint64_t v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1 + 2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(v5, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v6 = *a3;
    a1[4] = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_1002B01F0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B0210(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  uint64_t v6 = a1 + 16;
  if (*(unsigned char *)a3)
  {
    sub_1002B2188((uint64_t)v18, v6);
    char v19 = 1;
    sub_1001F7214((uint64_t)v14, a3);
    (*(void (**)(uint64_t, uint64_t, unsigned char *, unsigned char *))(*(void *)v4 + 184))(v4, v5, v18, v14);
    if (v17)
    {
      if (v16 < 0) {
        operator delete(__p);
      }
    }
    if (v19)
    {
      uint64_t v7 = v18;
LABEL_12:
      sub_1002B26E8((uint64_t)v7);
    }
  }
  else
  {
    sub_1002B2188((uint64_t)v12, v6);
    char v13 = 1;
    sub_1001F7214((uint64_t)v8, a3);
    (*(void (**)(uint64_t, uint64_t, unsigned char *, unsigned char *))(*(void *)v4 + 184))(v4, v5, v12, v8);
    if (v11 && v10 < 0) {
      operator delete(v9);
    }
    if (v13)
    {
      uint64_t v7 = v12;
      goto LABEL_12;
    }
  }
}

void sub_1002B0344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, __int16 a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60)
{
  if (a18 && a16 < 0) {
    operator delete(__p);
  }
  if (a60) {
    sub_1002B26E8((uint64_t)&a20);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002B03B4()
{
  return 0;
}

void *sub_1002B03BC(void *a1)
{
  *a1 = off_1019B3B68;
  sub_1002B26E8((uint64_t)(a1 + 2));
  return a1;
}

void sub_1002B0400(void *a1)
{
  *a1 = off_1019B3B68;
  sub_1002B26E8((uint64_t)(a1 + 2));

  operator delete();
}

void sub_1002B0464(uint64_t a1, long long *a2, long long *a3)
{
  if ((*((char *)a2 + 23) & 0x80000000) == 0)
  {
    *(_OWORD *)uint64_t v6 = *a2;
    uint64_t v7 = *((void *)a2 + 2);
LABEL_4:
    long long v8 = *a2;
    uint64_t v9 = *((void *)a2 + 2);
    goto LABEL_5;
  }
  sub_10004FC84(v6, *(void **)a2, *((void *)a2 + 1));
  if ((*((char *)a2 + 23) & 0x80000000) == 0) {
    goto LABEL_4;
  }
  sub_10004FC84(&v8, *(void **)a2, *((void *)a2 + 1));
LABEL_5:
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __p = *a3;
    uint64_t v11 = *((void *)a3 + 2);
  }
  sub_1002B05A8(a1 + 112, (long long *)v6);
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)v8);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[0]);
  }
}

void sub_1002B0564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B05A8(uint64_t a1, long long *a2)
{
  if (*(unsigned char *)(a1 + 72))
  {
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    long long v4 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v4;
    *((unsigned char *)a2 + 23) = 0;
    *(unsigned char *)a2 = 0;
    uint64_t v5 = (void **)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v5);
    }
    long long v6 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(_OWORD *)uint64_t v5 = v6;
    *((unsigned char *)a2 + 47) = 0;
    *((unsigned char *)a2 + 24) = 0;
    uint64_t v7 = (void **)(a1 + 48);
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*v7);
    }
    long long v8 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(_OWORD *)uint64_t v7 = v8;
    *((unsigned char *)a2 + 71) = 0;
    *((unsigned char *)a2 + 48) = 0;
  }
  else
  {
    long long v9 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v9;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v10 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v10;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    long long v11 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(_OWORD *)(a1 + 48) = v11;
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 6) = 0;
    *(unsigned char *)(a1 + 72) = 1;
  }
  return a1;
}

int64x2_t *sub_1002B06B8(int64x2_t *a1, long long **a2)
{
  a1->i64[0] = 0;
  a1->i64[1] = 0;
  a1[1].i64[0] = 0;
  sub_1000302C0(a1->i8, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
  a1[1].i64[1] = 0;
  a1[2].i64[0] = 0;
  a1[2].i64[1] = 0;
  sub_1002B2788(&a1[1].i64[1], a2[3], a2[4], ((char *)a2[4] - (char *)a2[3]) >> 5);
  a1[3].i64[0] = 0;
  a1[3].i64[1] = 0;
  uint64_t v28 = a1 + 3;
  a1[4].i64[0] = 0;
  long long v4 = a2[3];
  for (uint64_t i = a2[4]; v4 != i; v4 += 2)
  {
    if (*((char *)v4 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)v4, *((void *)v4 + 1));
    }
    else
    {
      long long v6 = *v4;
      uint64_t v30 = *((void *)v4 + 2);
      *(_OWORD *)std::string __dst = v6;
    }
    int v31 = *((_DWORD *)v4 + 6);
    sub_100561B00((uint64_t)&__p);
    char v34 = 0;
    char v35 = 0;
    unint64_t v8 = a1[3].u64[1];
    unint64_t v7 = a1[4].u64[0];
    if (v8 >= v7)
    {
      uint64_t v10 = (uint64_t)(v8 - v28->i64[0]) >> 6;
      if ((unint64_t)(v10 + 1) >> 58) {
        sub_10006A748();
      }
      uint64_t v11 = v7 - v28->i64[0];
      uint64_t v12 = v11 >> 5;
      if (v11 >> 5 <= (unint64_t)(v10 + 1)) {
        uint64_t v12 = v10 + 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFC0) {
        unint64_t v13 = 0x3FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      uint64_t v39 = a1 + 4;
      if (v13) {
        char v14 = (char *)sub_1001A14BC((uint64_t)a1[4].i64, v13);
      }
      else {
        char v14 = 0;
      }
      long long v36 = v14;
      v37.i64[0] = (uint64_t)&v14[64 * v10];
      v37.i64[1] = v37.i64[0];
      long long v38 = &v14[64 * v13];
      sub_1002B299C((char *)v37.i64[0], (long long *)__dst);
      uint64_t v15 = v37.i64[0];
      uint64_t v9 = v37.i64[1] + 64;
      v37.i64[1] += 64;
      uint64_t v17 = a1[3].i64[0];
      unint64_t v16 = a1[3].u64[1];
      if (v16 == v17)
      {
        int64x2_t v25 = vdupq_n_s64(v16);
      }
      else
      {
        uint64_t v18 = 0;
        do
        {
          char v19 = (unsigned char *)(v15 + v18 - 64);
          int v20 = (void **)(v16 + v18 - 64);
          if (*(char *)(v16 + v18 - 41) < 0)
          {
            sub_10004FC84(v19, *v20, *(void *)(v16 + v18 - 56));
          }
          else
          {
            long long v21 = *(_OWORD *)v20;
            *(void *)(v15 + v18 - 48) = *(void *)(v16 + v18 - 48);
            *(_OWORD *)char v19 = v21;
          }
          *(_DWORD *)(v15 + v18 - 40) = *(_DWORD *)(v16 + v18 - 40);
          uint64_t v22 = (unsigned char *)(v15 + v18 - 32);
          uint64_t v23 = (void **)(v16 + v18 - 32);
          if (*(char *)(v16 + v18 - 9) < 0)
          {
            sub_10004FC84(v22, *v23, *(void *)(v16 + v18 - 24));
          }
          else
          {
            long long v24 = *(_OWORD *)v23;
            *(void *)(v15 + v18 - 16) = *(void *)(v16 + v18 - 16);
            *(_OWORD *)uint64_t v22 = v24;
          }
          *(void *)(v15 + v18 - 8) = *(void *)(v16 + v18 - 8);
          v18 -= 64;
        }
        while (v16 + v18 != v17);
        int64x2_t v25 = *v28;
        uint64_t v9 = v37.i64[1];
        v15 += v18;
      }
      a1[3].i64[0] = v15;
      a1[3].i64[1] = v9;
      int64x2_t v37 = v25;
      long long v26 = (char *)a1[4].i64[0];
      a1[4].i64[0] = (uint64_t)v38;
      long long v38 = v26;
      long long v36 = (char *)v25.i64[0];
      sub_1002B2A9C((uint64_t)&v36);
    }
    else
    {
      sub_1002B299C((char *)a1[3].i64[1], (long long *)__dst);
      uint64_t v9 = v8 + 64;
      a1[3].i64[1] = v8 + 64;
    }
    a1[3].i64[1] = v9;
    if (v33 < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(__dst[0]);
    }
  }
  return a1;
}

void sub_1002B0974(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
}

void **sub_1002B0A2C(void **a1)
{
  uint64_t v3 = a1 + 3;
  sub_1000D82FC(&v3);
  uint64_t v3 = a1;
  sub_100047F64(&v3);
  return a1;
}

uint64_t sub_1002B0A74(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 56);
  if (v2 != v3)
  {
    while (1)
    {
      uint64_t v5 = *(unsigned __int8 *)(v2 + 55);
      if ((v5 & 0x80u) == 0) {
        uint64_t v6 = *(unsigned __int8 *)(v2 + 55);
      }
      else {
        uint64_t v6 = *(void *)(v2 + 40);
      }
      uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
      int v8 = (char)v7;
      if ((v7 & 0x80u) != 0) {
        uint64_t v7 = *(void *)(a2 + 8);
      }
      if (v6 != v7) {
        goto LABEL_19;
      }
      uint64_t v9 = v8 >= 0 ? (unsigned __int8 *)a2 : *(unsigned __int8 **)a2;
      if ((v5 & 0x80) == 0) {
        break;
      }
      double result = memcmp(*(const void **)(v2 + 32), v9, *(void *)(v2 + 40));
      if (!result) {
        goto LABEL_18;
      }
LABEL_19:
      v2 += 64;
      if (v2 == v3) {
        return result;
      }
    }
    if (*(unsigned char *)(v2 + 55))
    {
      uint64_t v10 = 0;
      while (*(unsigned __int8 *)(v2 + v10 + 32) == v9[v10])
      {
        if (v5 == ++v10) {
          goto LABEL_18;
        }
      }
      goto LABEL_19;
    }
LABEL_18:
    *(_DWORD *)(v2 + 56) = 0;
    *(unsigned char *)(v2 + 60) = 1;
    goto LABEL_19;
  }
  return result;
}

uint64_t sub_1002B0B38(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 56);
  if (v2 != v3)
  {
    while (1)
    {
      uint64_t v5 = *(unsigned __int8 *)(v2 + 55);
      if ((v5 & 0x80u) == 0) {
        uint64_t v6 = *(unsigned __int8 *)(v2 + 55);
      }
      else {
        uint64_t v6 = *(void *)(v2 + 40);
      }
      uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
      int v8 = (char)v7;
      if ((v7 & 0x80u) != 0) {
        uint64_t v7 = *(void *)(a2 + 8);
      }
      if (v6 != v7) {
        goto LABEL_19;
      }
      uint64_t v9 = v8 >= 0 ? (unsigned __int8 *)a2 : *(unsigned __int8 **)a2;
      if ((v5 & 0x80) == 0) {
        break;
      }
      double result = memcmp(*(const void **)(v2 + 32), v9, *(void *)(v2 + 40));
      if (!result) {
        goto LABEL_18;
      }
LABEL_19:
      v2 += 64;
      if (v2 == v3) {
        return result;
      }
    }
    if (*(unsigned char *)(v2 + 55))
    {
      uint64_t v10 = 0;
      while (*(unsigned __int8 *)(v2 + v10 + 32) == v9[v10])
      {
        if (v5 == ++v10) {
          goto LABEL_18;
        }
      }
      goto LABEL_19;
    }
LABEL_18:
    *(_DWORD *)(v2 + 56) = 1;
    *(unsigned char *)(v2 + 60) = 1;
    goto LABEL_19;
  }
  return result;
}

uint64_t sub_1002B0BFC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3 != v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      if (*(unsigned char *)(v4 + 60))
      {
        int v8 = *(_DWORD *)(v4 + 56);
        if (v8 == 1) {
          uint64_t v9 = v6 + 1;
        }
        else {
          uint64_t v9 = v6;
        }
        if (v8) {
          uint64_t v6 = v9;
        }
        else {
          ++v5;
        }
      }
      else
      {
        ++v7;
      }
      v4 += 64;
    }
    while (v4 != v3);
  }
  uint64_t v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v19 = 0u;
  memset(v17, 0, sizeof(v17));
  long long v16 = 0u;
  sub_10004BD84((uint64_t)&v16);
  sub_10004B96C(v17, (uint64_t)"Total operations: [", 19);
  uint64_t v10 = (void *)std::ostream::operator<<();
  sub_10004B96C(v10, (uint64_t)"], not started [", 16);
  uint64_t v11 = (void *)std::ostream::operator<<();
  sub_10004B96C(v11, (uint64_t)"], succeeded: [", 15);
  uint64_t v12 = (void *)std::ostream::operator<<();
  sub_10004B96C(v12, (uint64_t)"], failed: [", 12);
  unint64_t v13 = (void *)std::ostream::operator<<();
  sub_10004B96C(v13, (uint64_t)"]", 1);
  sub_10004BC98((uint64_t)v17 + 8, a2);
  *(void *)((char *)&v17[-1]
  *(void *)&v17[0] = v14;
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1002B0E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002B0E7C(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  if (a1 == a2) {
    return 0;
  }
  uint64_t v4 = a1;
  char v5 = *((unsigned char *)a3 + 23);
  if (v5 >= 0) {
    uint64_t v6 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
  }
  else {
    uint64_t v6 = a3[1];
  }
  if (v5 >= 0) {
    uint64_t v7 = (unsigned __int8 *)a3;
  }
  else {
    uint64_t v7 = *a3;
  }
  while (1)
  {
    uint64_t v8 = *(unsigned __int8 *)(v4 + 55);
    if ((v8 & 0x80u) == 0) {
      uint64_t v9 = (unsigned __int8 *)*(unsigned __int8 *)(v4 + 55);
    }
    else {
      uint64_t v9 = *(unsigned __int8 **)(v4 + 40);
    }
    if (v9 != v6) {
      goto LABEL_19;
    }
    if ((v8 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v4 + 55)) {
      return 1;
    }
    uint64_t v10 = 0;
    while (*(unsigned __int8 *)(v4 + v10 + 32) == v7[v10])
    {
      if (v8 == ++v10) {
        return 1;
      }
    }
LABEL_19:
    v4 += 64;
    if (v4 == a2) {
      return 0;
    }
  }
  if (memcmp(*(const void **)(v4 + 32), v7, *(void *)(v4 + 40))) {
    goto LABEL_19;
  }
  return 1;
}

_OWORD *sub_1002B0F48(_OWORD *result, uint64_t a2, uint64_t a3)
{
  result[5] = 0u;
  result[6] = 0u;
  result[3] = 0u;
  result[4] = 0u;
  result[1] = 0u;
  result[2] = 0u;
  void *result = 0u;
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t)result;
    uint64_t v6 = (uint64_t)result + 56;
    uint64_t v7 = (uint64_t *)result + 3;
    uint64_t v8 = (uint64_t *)(result + 5);
    do
    {
      if (*(unsigned char *)(v4 + 60))
      {
        int v9 = *(_DWORD *)(v4 + 56);
        if (v9) {
          goto LABEL_11;
        }
        if (!*(unsigned char *)(v5 + 48))
        {
          long long v13 = 0u;
          long long v14 = 0u;
          long long v12 = 0u;
          sub_1002B10F0(v5, (uint64_t)&v12);
          uint64_t v15 = (void **)&v13 + 1;
          sub_1000D82FC(&v15);
          uint64_t v15 = (void **)&v12;
          sub_100047F64(&v15);
        }
        unint64_t v10 = *(void *)(v5 + 32);
        if (v10 >= *(void *)(v5 + 40))
        {
          double result = (_OWORD *)sub_1002B2C1C(v7, (long long *)v4);
        }
        else
        {
          sub_1002B2BAC(v7, (long long *)v4);
          double result = (_OWORD *)(v10 + 32);
        }
        *(void *)(v5 + 32) = result;
        int v9 = *(_DWORD *)(v4 + 56);
        if (*(unsigned char *)(v4 + 60))
        {
LABEL_11:
          if (v9 == 1)
          {
            if (!*(unsigned char *)(v5 + 104))
            {
              long long v13 = 0u;
              long long v14 = 0u;
              long long v12 = 0u;
              sub_1002B10F0(v6, (uint64_t)&v12);
              uint64_t v15 = (void **)&v13 + 1;
              sub_1000D82FC(&v15);
              uint64_t v15 = (void **)&v12;
              sub_100047F64(&v15);
            }
            unint64_t v11 = *(void *)(v5 + 88);
            if (v11 >= *(void *)(v5 + 96))
            {
              double result = (_OWORD *)sub_1002B2C1C(v8, (long long *)v4);
            }
            else
            {
              sub_1002B2BAC(v8, (long long *)v4);
              double result = (_OWORD *)(v11 + 32);
            }
            *(void *)(v5 + 88) = result;
          }
        }
      }
      v4 += 64;
    }
    while (v4 != a3);
  }
  return result;
}

void sub_1002B10D4(_Unwind_Exception *a1)
{
  sub_1002B3018(v2);
  sub_1002B3018(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002B10F0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 24);
  uint64_t v5 = (void *)(a2 + 24);
  if (*(unsigned char *)(a1 + 48))
  {
    sub_10005CBB4((uint64_t *)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    sub_1002B2B70(v4);
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    void *v5 = 0;
    v5[1] = 0;
    void v5[2] = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *uint64_t v4 = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    void *v5 = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    *(unsigned char *)(a1 + 48) = 1;
  }
  return a1;
}

uint64_t sub_1002B11BC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  memset(v15, 0, sizeof(v15));
  sub_1002B0F48(v15, *(void *)(a1 + 64), *(void *)(a1 + 72));
  uint64_t v6 = *a2;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  sub_1002B2F60((uint64_t)v14, (uint64_t)v15);
  sub_1002B2F60((uint64_t)v13, (uint64_t)&v15[3] + 8);
  sub_1001F7214((uint64_t)v9, a3);
  (*(void (**)(uint64_t, uint64_t, unsigned char *, unsigned char *, unsigned char *))(*(void *)v6 + 192))(v6, v7, v14, v13, v9);
  if (v12 && v11 < 0) {
    operator delete(__p);
  }
  sub_1002B3018((uint64_t)v13);
  sub_1002B3018((uint64_t)v14);
  sub_1002B3018((uint64_t)&v15[3] + 8);
  return sub_1002B3018((uint64_t)v15);
}

void sub_1002B12BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  if (a19)
  {
    if (a17 < 0) {
      operator delete(__p);
    }
  }
  sub_1002B3018((uint64_t)&a21);
  sub_1002B3018((uint64_t)&a30);
  sub_1002B3018(v30);
  sub_1002B3018(v31 - 160);
  _Unwind_Resume(a1);
}

uint64_t sub_1002B1318(uint64_t a1, unsigned __int8 **a2)
{
  return sub_1002B0E7C(*(void *)(a1 + 64), *(void *)(a1 + 72), a2);
}

void **sub_1002B1328(void **a1)
{
  uint64_t v2 = a1 + 2;
  uint64_t v4 = a1 + 8;
  sub_1002B2AEC(&v4);
  uint64_t v4 = a1 + 5;
  sub_1000D82FC(&v4);
  uint64_t v4 = v2;
  sub_100047F64(&v4);
  return a1;
}

void sub_1002B1388(void **a1)
{
  sub_1002B1328(a1);

  operator delete();
}

uint64_t sub_1002B13C0(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  memset(v15, 0, sizeof(v15));
  sub_1002B0F48(v15, *(void *)(a1 + 64), *(void *)(a1 + 72));
  uint64_t v6 = *a2;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  sub_1002B2F60((uint64_t)v14, (uint64_t)v15);
  sub_1002B2F60((uint64_t)v13, (uint64_t)&v15[3] + 8);
  sub_1001F7214((uint64_t)v9, a3);
  (*(void (**)(uint64_t, uint64_t, unsigned char *, unsigned char *, unsigned char *))(*(void *)v6 + 200))(v6, v7, v14, v13, v9);
  if (v12 && v11 < 0) {
    operator delete(__p);
  }
  sub_1002B3018((uint64_t)v13);
  sub_1002B3018((uint64_t)v14);
  sub_1002B3018((uint64_t)&v15[3] + 8);
  return sub_1002B3018((uint64_t)v15);
}

void sub_1002B14C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  if (a19)
  {
    if (a17 < 0) {
      operator delete(__p);
    }
  }
  sub_1002B3018((uint64_t)&a21);
  sub_1002B3018((uint64_t)&a30);
  sub_1002B3018(v30);
  sub_1002B3018(v31 - 160);
  _Unwind_Resume(a1);
}

uint64_t sub_1002B151C(uint64_t a1, unsigned __int8 **a2)
{
  return sub_1002B0E7C(*(void *)(a1 + 64), *(void *)(a1 + 72), a2);
}

void sub_1002B1530(void **a1)
{
  sub_1002B1328(a1);

  operator delete();
}

void sub_1002B1568(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(__dst, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)(a1 + 16);
    uint64_t v11 = *(void *)(a1 + 32);
  }
  char v12 = 1;
  sub_1001F7214((uint64_t)v6, a3);
  (*(void (**)(uint64_t, uint64_t, void **, unsigned char *))(*(void *)v4 + 216))(v4, v5, __dst, v6);
  if (v9 && v8 < 0) {
    operator delete(__p);
  }
  if (v12)
  {
    if (SHIBYTE(v11) < 0) {
      operator delete(__dst[0]);
    }
  }
}

void sub_1002B1644(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26)
{
  if (a19 && a17 < 0) {
    operator delete(__p);
  }
  if (a26)
  {
    if (a25 < 0) {
      operator delete(a20);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B1688(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a1 + 63);
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 63);
  }
  else {
    uint64_t v3 = *(void *)(a1 + 48);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  uint64_t v6 = (const void **)(a1 + 40);
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*v6, a2, *(void *)(a1 + 48)) == 0;
  }
  if (!*(unsigned char *)(a1 + 63)) {
    return 1;
  }
  uint64_t v7 = v2 - 1;
  do
  {
    int v9 = *(unsigned __int8 *)v6;
    uint64_t v6 = (const void **)((char *)v6 + 1);
    int v8 = v9;
    int v11 = *a2++;
    int v10 = v11;
    BOOL v13 = v7-- != 0;
    uint64_t result = v8 == v10;
  }
  while (v8 == v10 && v13);
  return result;
}

uint64_t sub_1002B172C(uint64_t a1, int a2, long long *a3)
{
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)a1 = off_1019B3BF8;
  uint64_t v4 = (_OWORD *)(a1 + 16);
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    *(void *)(a1 + 32) = *((void *)a3 + 2);
    *uint64_t v4 = v5;
  }
  unint64_t v6 = sub_100206390((uint64_t)&v8, (uint64_t)v4);
  std::to_string((std::string *)(a1 + 40), v6);
  return a1;
}

void sub_1002B17C4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B17E0(uint64_t a1)
{
  *(void *)a1 = off_1019B3BF8;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1002B1844(uint64_t a1)
{
  sub_1002B17E0(a1);

  operator delete();
}

void sub_1002B187C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  sub_1001F7214((uint64_t)v5, a3);
  (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v3 + 208))(v3, v4, v5);
  if (v8)
  {
    if (v7 < 0) {
      operator delete(__p);
    }
  }
}

void sub_1002B18FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19)
{
  if (a19)
  {
    if (a17 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B1920()
{
  return 0;
}

void *sub_1002B1928(void *a1)
{
  *a1 = off_1019B3C28;
  sub_1002B26E8((uint64_t)(a1 + 2));
  return a1;
}

void sub_1002B196C(void *a1)
{
  *a1 = off_1019B3C28;
  sub_1002B26E8((uint64_t)(a1 + 2));

  operator delete();
}

void sub_1002B19D0(uint64_t **a1, long long *a2, void *a3)
{
  sub_1002B3068(__p, a2, a3);
  sub_1002B30D4(a1, __p, (uint64_t)__p);
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002B1A2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002B1A40((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002B1A40(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1002B1A80(uint64_t a1, void **a2, uint64_t a3, os_log_t *a4)
{
  unint64_t v6 = a2;
  char v8 = (uint64_t *)sub_100046F68(a1, a2);
  if ((uint64_t *)(a1 + 8) == v8)
  {
    BOOL v13 = *a4;
    if (os_log_type_enabled(*a4, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)v6 + 23) < 0) {
        unint64_t v6 = (void **)*v6;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Operation has disappeared: [%{public}s]", buf, 0xCu);
    }
  }
  else
  {
    int v9 = v8;
    uint64_t v10 = (uint64_t)(v8 + 4);
    uint64_t v12 = v8[7];
    int v11 = (std::__shared_weak_count *)v8[8];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1000F5B04((uint64_t **)a1, v8);
    sub_1001FEC1C(v10);
    operator delete(v9);
    *(_OWORD *)uint64_t v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)long long buf = 0u;
    buf[0] = (a3 & 0xFF00000000) == 0;
    if (*((char *)v6 + 23) < 0)
    {
      sub_10004FC84(v30, *v6, (unint64_t)v6[1]);
    }
    else
    {
      *(_OWORD *)uint64_t v30 = *(_OWORD *)v6;
      *(void *)&long long v31 = v6[2];
    }
    if ((a3 & 0xFF00000000) != 0) {
      int v14 = a3;
    }
    else {
      int v14 = 0;
    }
    DWORD2(v31) = v14;
    BYTE12(v31) = (a3 & 0xFF00000000) != 0;
    uint64_t v15 = *a4;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      long long v16 = "true";
      if (!buf[0]) {
        long long v16 = "false";
      }
      if (*((char *)v6 + 23) < 0) {
        unint64_t v6 = (void **)*v6;
      }
      *(_DWORD *)long long v25 = 136315394;
      long long v26 = v16;
      __int16 v27 = 2082;
      long long v28 = v6;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Publishing operation [fDidSucceed = %s, .fOperation = %{public}s]", v25, 0x16u);
    }
    uint64_t v17 = *(std::__shared_weak_count **)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 24);
    long long v24 = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v18 = *(void *)buf;
    uint8_t v19 = buf[8];
    if (SBYTE7(v31) < 0)
    {
      sub_10004FC84(&__p, v30[0], (unint64_t)v30[1]);
    }
    else
    {
      long long __p = *(_OWORD *)v30;
      uint64_t v21 = v31;
    }
    uint64_t v22 = *((void *)&v31 + 1);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v12 + 16))(v12, &v23, &v18);
    if (SHIBYTE(v21) < 0) {
      operator delete((void *)__p);
    }
    if (v24) {
      sub_10004D2C8(v24);
    }
    if (SBYTE7(v31) < 0) {
      operator delete(v30[0]);
    }
    if (v11) {
      sub_10004D2C8(v11);
    }
  }
}

void sub_1002B1D3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a31 < 0) {
    operator delete(__p);
  }
  if (v31) {
    sub_10004D2C8(v31);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B1D90(uint64_t a1, uint64_t *a2, uint64_t a3, os_log_t *a4)
{
  unint64_t v6 = (uint64_t *)(a1 + 8);
  char v7 = *(uint64_t **)a1;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v30 = 0;
  if (v7 == (uint64_t *)(a1 + 8)) {
    goto LABEL_18;
  }
  while (((*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v7[7] + 24))(v7[7], a2) & 1) == 0)
  {
    uint64_t v10 = (uint64_t *)v7[1];
    if (v10)
    {
      do
      {
        int v11 = v10;
        uint64_t v10 = (uint64_t *)*v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        int v11 = (uint64_t *)v7[2];
        BOOL v12 = *v11 == (void)v7;
        char v7 = v11;
      }
      while (!v12);
    }
    char v7 = v11;
    if (v11 == v6) {
      goto LABEL_18;
    }
  }
  if (*((char *)v7 + 55) < 0)
  {
    sub_10004FC84(__dst, (void *)v7[4], v7[5]);
  }
  else
  {
    *(_OWORD *)std::string __dst = *((_OWORD *)v7 + 2);
    v36[0] = (void *)v7[6];
  }
  *(_OWORD *)long long __p = *(_OWORD *)__dst;
  uint64_t v30 = v36[0];
  if (v7 == v6)
  {
LABEL_18:
    uint64_t v15 = *a4;
    if (os_log_type_enabled(*a4, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v21 = a2;
      }
      else {
        uint64_t v21 = (uint64_t *)*a2;
      }
      *(_DWORD *)std::string __dst = 136446210;
      *(void *)&__dst[4] = v21;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to publish with transactionID: %{public}s", __dst, 0xCu);
    }
  }
  else
  {
    uint64_t v14 = v7[7];
    BOOL v13 = (std::__shared_weak_count *)v7[8];
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1000F5B04((uint64_t **)a1, v7);
    sub_1001FEC1C((uint64_t)(v7 + 4));
    operator delete(v7);
    *(_OWORD *)long long v36 = 0u;
    long long v37 = 0u;
    *(_OWORD *)std::string __dst = 0u;
    __dst[0] = (a3 & 0xFF00000000) == 0;
    if (SHIBYTE(v30) < 0)
    {
      sub_10004FC84(v36, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)long long v36 = *(_OWORD *)__p;
      *(void *)&long long v37 = v30;
    }
    if ((a3 & 0xFF00000000) != 0) {
      int v16 = a3;
    }
    else {
      int v16 = 0;
    }
    DWORD2(v37) = v16;
    BYTE12(v37) = (a3 & 0xFF00000000) != 0;
    uint64_t v17 = *a4;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      if (__dst[0]) {
        uint64_t v18 = "true";
      }
      else {
        uint64_t v18 = "false";
      }
      uint8_t v19 = (void **)__p[0];
      if (SHIBYTE(v30) >= 0) {
        uint8_t v19 = __p;
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v32 = v18;
      __int16 v33 = 2082;
      char v34 = v19;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Publishing operation [fDidSucceed = %s, .fOperation = %{public}s]", buf, 0x16u);
    }
    long long v20 = *(std::__shared_weak_count **)(a1 + 32);
    uint64_t v27 = *(void *)(a1 + 24);
    long long v28 = v20;
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v22 = *(void *)__dst;
    uint8_t v23 = __dst[8];
    if (SBYTE7(v37) < 0)
    {
      sub_10004FC84(&v24, v36[0], (unint64_t)v36[1]);
    }
    else
    {
      long long v24 = *(_OWORD *)v36;
      uint64_t v25 = v37;
    }
    uint64_t v26 = *((void *)&v37 + 1);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v14 + 16))(v14, &v27, &v22);
    if (SHIBYTE(v25) < 0) {
      operator delete((void *)v24);
    }
    if (v28) {
      sub_10004D2C8(v28);
    }
    if (SBYTE7(v37) < 0) {
      operator delete(v36[0]);
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002B2118(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a38 < 0) {
    operator delete(__p);
  }
  if (v38) {
    sub_10004D2C8(v38);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B2188(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1000302C0((char *)a1, *(long long **)a2, *(long long **)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_1002B2788((void *)(a1 + 24), *(long long **)(a2 + 24), *(long long **)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 5);
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 48), *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)(a1 + 48) = v4;
  }
  if (*(char *)(a2 + 95) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 72), *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = v5;
  }
  sub_1002B2370((char *)(a1 + 96), a2 + 96);
  sub_1002B250C(a1 + 176, (long long *)(a2 + 176));
  sub_1002B2560((char *)(a1 + 208), a2 + 208);
  unint64_t v6 = (unsigned char *)(a1 + 288);
  if (*(char *)(a2 + 311) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 288), *(void *)(a2 + 296));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 288);
    *(void *)(a1 + 304) = *(void *)(a2 + 304);
    *(_OWORD *)unint64_t v6 = v7;
  }
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a2 + 312);
  return a1;
}

void sub_1002B22D8(_Unwind_Exception *a1)
{
  sub_1002B268C(v6);
  if (*(unsigned char *)(v1 + 200) && *(char *)(v1 + 199) < 0) {
    operator delete(*v5);
  }
  sub_1002B24B0(v4);
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v2);
  }
  sub_1002B0A2C((void **)v1);
  _Unwind_Resume(a1);
}

void sub_1002B235C(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100047F64((void ***)va);
  JUMPOUT(0x1002B2354);
}

char *sub_1002B2370(char *__dst, uint64_t a2)
{
  *std::string __dst = 0;
  __dst[72] = 0;
  if (*(unsigned char *)(a2 + 72))
  {
    sub_1002B23C8(__dst, (long long *)a2);
    __dst[72] = 1;
  }
  return __dst;
}

void sub_1002B23B4(_Unwind_Exception *a1)
{
  sub_1002B24B0(v1);
  _Unwind_Resume(a1);
}

char *sub_1002B23C8(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  uint64_t v6 = __dst + 48;
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(v6, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v7 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *(_OWORD *)uint64_t v6 = v7;
  }
  return __dst;
}

void sub_1002B247C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B24B0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_1002B250C(uint64_t a1, long long *a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  sub_100059450((_OWORD *)a1, a2);
  return a1;
}

void sub_1002B253C(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
  }
  _Unwind_Resume(exception_object);
}

char *sub_1002B2560(char *__dst, uint64_t a2)
{
  *std::string __dst = 0;
  __dst[72] = 0;
  if (*(unsigned char *)(a2 + 72))
  {
    sub_1002B25B8(__dst, (long long *)a2);
    __dst[72] = 1;
  }
  return __dst;
}

void sub_1002B25A4(_Unwind_Exception *a1)
{
  sub_1002B268C(v1);
  _Unwind_Resume(a1);
}

char *sub_1002B25B8(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  *((void *)__dst + 3) = 0;
  *((void *)__dst + 4) = 0;
  *((void *)__dst + 5) = 0;
  sub_10005C928((void *)__dst + 3, *((const void **)a2 + 3), *((void *)a2 + 4), *((void *)a2 + 4) - *((void *)a2 + 3));
  long long v5 = __dst + 48;
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *(_OWORD *)long long v5 = v6;
  }
  return __dst;
}

void sub_1002B2658(_Unwind_Exception *exception_object)
{
  long long v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B268C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    uint64_t v2 = *(void **)(a1 + 24);
    if (v2)
    {
      *(void *)(a1 + 32) = v2;
      operator delete(v2);
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_1002B26E8(uint64_t a1)
{
  if (*(char *)(a1 + 311) < 0) {
    operator delete(*(void **)(a1 + 288));
  }
  sub_1002B268C(a1 + 208);
  if (*(unsigned char *)(a1 + 200) && *(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  sub_1002B24B0(a1 + 96);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v3 = (void **)(a1 + 24);
  sub_1000D82FC(&v3);
  uint64_t v3 = (void **)a1;
  sub_100047F64(&v3);
  return a1;
}

void *sub_1002B2788(void *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_1002B2810(result, a4);
    uint64_t result = sub_1002B2854((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1002B27F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1000D82FC(&a9);
  _Unwind_Resume(a1);
}

char *sub_1002B2810(void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_1000F5A68((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void *sub_1002B2854(uint64_t a1, long long *a2, long long *a3, void *__dst)
{
  uint64_t v4 = __dst;
  BOOL v12 = __dst;
  BOOL v13 = __dst;
  v10[0] = a1;
  v10[1] = &v12;
  void v10[2] = &v13;
  uint64_t v11 = 0;
  if (a2 != a3)
  {
    long long v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_10004FC84(v4, *(void **)v6, *((void *)v6 + 1));
        char v8 = v13;
      }
      else
      {
        long long v7 = *v6;
        void v4[2] = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v4 = v7;
        char v8 = v4;
      }
      *((_DWORD *)v4 + 6) = *((_DWORD *)v6 + 6);
      v6 += 2;
      uint64_t v4 = v8 + 4;
      BOOL v13 = v8 + 4;
    }
    while (v6 != a3);
  }
  LOBYTE(v11) = 1;
  sub_1002B291C((uint64_t)v10);
  return v4;
}

void sub_1002B2908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002B291C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1002B2954(a1);
  }
  return a1;
}

void sub_1002B2954(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 9) < 0) {
      operator delete(*(void **)(v1 - 32));
    }
    v1 -= 32;
  }
}

char *sub_1002B299C(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  *((_DWORD *)__dst + 6) = *((_DWORD *)a2 + 6);
  long long v5 = __dst + 32;
  if (*((char *)a2 + 55) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 4), *((void *)a2 + 5));
  }
  else
  {
    long long v6 = a2[2];
    *((void *)__dst + 6) = *((void *)a2 + 6);
    *(_OWORD *)long long v5 = v6;
  }
  *((void *)__dst + 7) = *((void *)a2 + 7);
  return __dst;
}

void sub_1002B2A28(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B2A44(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t sub_1002B2A9C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 64;
    sub_1002B2A44(i - 64);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1002B2AEC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 64;
        sub_1002B2A44(v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1002B2B70(uint64_t *a1)
{
  if (*a1)
  {
    sub_1000D8350(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void *sub_1002B2BAC(void *result, long long *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t result = sub_10004FC84((unsigned char *)result[1], *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *(void *)(v4 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v4 = v5;
  }
  *(_DWORD *)(v4 + 24) = *((_DWORD *)a2 + 6);
  v3[1] = v4 + 32;
  return result;
}

void sub_1002B2C14(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1002B2C1C(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v18 = a1 + 2;
  if (v9) {
    uint64_t v10 = sub_1000F5A68(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = (char *)&v10[8 * v4];
  v15[0] = v10;
  v15[1] = v11;
  int v16 = v11;
  uint64_t v17 = (char *)&v10[8 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(v11, *(void **)a2, *((void *)a2 + 1));
    uint64_t v11 = v16;
  }
  else
  {
    long long v12 = *a2;
    *((void *)v11 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }
  v10[8 * v4 + 6] = *((_DWORD *)a2 + 6);
  int v16 = v11 + 32;
  sub_1002B2D2C(a1, v15);
  uint64_t v13 = a1[1];
  sub_1002B2ED0((uint64_t)v15);
  return v13;
}

void sub_1002B2D18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002B2ED0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1002B2D2C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002B2DA4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002B2DA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v12[0] = a1;
  v12[1] = &v13;
  void v12[2] = &v14;
  void v12[3] = 1;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = a7;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 32);
      *(void *)(v8 - 16) = *(void *)(a3 - 16);
      *(_OWORD *)(v8 - 32) = v9;
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 32) = 0;
      *(_DWORD *)(v8 - 8) = *(_DWORD *)(a3 - 8);
      v8 -= 32;
      v7 -= 32;
      a3 -= 32;
    }
    while (a3 != a5);
    *((void *)&v14 + 1) = v8;
    uint64_t v10 = v14;
  }
  sub_1002B2E50((uint64_t)v12);
  return v10;
}

uint64_t sub_1002B2E50(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1002B2E88(a1);
  }
  return a1;
}

void sub_1002B2E88(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 32;
  }
}

uint64_t sub_1002B2ED0(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1002B2F08(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 4;
      *(void *)(a1 + 16) = v2 - 4;
      if (*((char *)v2 - 9) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

uint64_t sub_1002B2F60(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 48) = 0;
  if (*(unsigned char *)(a2 + 48))
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_1000302C0((char *)a1, *(long long **)a2, *(long long **)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    sub_1002B2788((void *)(a1 + 24), *(long long **)(a2 + 24), *(long long **)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 5);
    *(unsigned char *)(a1 + 48) = 1;
  }
  return a1;
}

void sub_1002B2FF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100047F64((void ***)va);
  sub_1002B3018(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1002B3018(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v3 = (void **)(a1 + 24);
    sub_1000D82FC(&v3);
    uint64_t v3 = (void **)a1;
    sub_100047F64(&v3);
  }
  return a1;
}

void *sub_1002B3068(void *__dst, long long *a2, void *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  uint64_t v6 = a3[1];
  __dst[3] = *a3;
  __dst[4] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return __dst;
}

_OWORD *sub_1002B30D4(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v10 = 0;
  long long v5 = (void **)sub_100046ED4((uint64_t)a1, &v10, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    v9[2] = 1;
    uint64_t v6 = operator new(0x48uLL);
    v9[1] = a1 + 1;
    void v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(_OWORD *)((char *)v6 + 56) = *(_OWORD *)(a3 + 24);
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    sub_100046C38(a1, v10, v7, (uint64_t *)v6);
    v9[0] = 0;
    sub_1002B31A0((uint64_t)v9, 0);
  }
  return v6;
}

void sub_1002B31A0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1001FEC1C((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void *sub_1002B31F8()
{
  long long v0 = (void *)CUTWeakLinkSymbol();
  if (v0) {
    long long v0 = (void *)*v0;
  }

  return v0;
}

void sub_1002B3228(PowerSourceFactoryInterface *a1)
{
  *(void *)a1 = off_1019B3D30;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)a1 + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  PowerSourceFactoryInterface::~PowerSourceFactoryInterface(a1);
}

void sub_1002B3288(PowerSourceFactoryInterface *a1)
{
  sub_1002B3228(a1);

  operator delete();
}

void sub_1002B32C0(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_1010414E0(&v2);
}

void sub_1002B3330(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B3348(void *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = (std::__shared_weak_count *)operator new(0x60uLL);
  uint64_t v7 = v6;
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3D70;
  uint64_t v8 = &v6[1].__vftable;
  uint64_t v9 = *a2;
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v12[0] = v9;
  v12[1] = v10;
  sub_1002B3484((uint64_t)&v6[1], a1, v12);
  if (v10)
  {
    sub_10004D2C8(v10);
    sub_10004D2C8(v10);
  }
  shared_owners = (std::__shared_weak_count *)v7[1].__shared_owners_;
  if (!shared_owners)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v7[1].__vftable = (std::__shared_weak_count_vtbl *)&v7[1];
    v7[1].__shared_owners_ = (uint64_t)v7;
    goto LABEL_9;
  }
  if (shared_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v7[1].__vftable = (std::__shared_weak_count_vtbl *)&v7[1];
    v7[1].__shared_owners_ = (uint64_t)v7;
    std::__shared_weak_count::__release_weak(shared_owners);
LABEL_9:
    sub_10004D2C8(v7);
  }
  *a3 = v8;
  a3[1] = v7;
}

void sub_1002B3458(_Unwind_Exception *a1)
{
  if (v2)
  {
    sub_10004D2C8(v2);
    sub_10004D2C8(v2);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  _Unwind_Resume(a1);
}

uint64_t sub_1002B3484(uint64_t a1, void *a2, void *a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "ent.pnr");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v10, &v9);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 16), (const ctu::OsLogLogger *)v10);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *(void *)(a1 + 24) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 32) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 40) = *a3;
  uint64_t v7 = a3[1];
  *(void *)(a1 + 48) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  Registry::getNotificationSenderFactory((uint64_t *)&v9, *(Registry **)(a1 + 24));
  (*(void (**)(char *))(*(void *)v9.var0 + 120))(v9.var0);
  if (v9.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v9.var1.fRef);
  }
  return a1;
}

void sub_1002B3590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, std::__shared_weak_count *a11, char a12)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  uint64_t v15 = (std::__shared_weak_count *)v12[6];
  if (v15) {
    sub_10004D2C8(v15);
  }
  int v16 = (std::__shared_weak_count *)v12[4];
  if (v16) {
    sub_10004D2C8(v16);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  uint64_t v17 = (std::__shared_weak_count *)v12[1];
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  _Unwind_Resume(a1);
}

void sub_1002B3604(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  xpc_object_t v40 = 0;
  if (v4)
  {
    xpc_object_t v40 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v40 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v40 = v6;
LABEL_9:
  xpc_release(v5);
  uint64_t v7 = *(unsigned __int8 *)(a2 + 47);
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *(void *)(a2 + 32);
  }
  if (!v7)
  {
    long long v12 = *(NSObject **)(a1 + 16);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    uint64_t v13 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 40));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    long long v14 = "#E %s%sPNR response with empty signature";
    goto LABEL_24;
  }
  uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a2 + 8);
  }
  if (v8)
  {
    long long v48 = 0uLL;
    uint64_t v49 = 0;
    ctu::base64::decode();
    OsLogContext v9 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 40));
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&uint8_t buf[24] = asString();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sAdding HTTP header for PNR signature version %s", buf, 0x20u);
    }
    uint64_t v11 = *(void *)(a1 + 48);
    v46[0] = *(void *)(a1 + 40);
    v46[1] = v11;
    xpc_object_t v47 = 0;
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
    sub_1012D9898(a1 + 24, (uint64_t)v46, *(unsigned __int8 *)(a2 + 48));
  }
  long long v12 = *(NSObject **)(a1 + 16);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 40));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    long long v14 = "#E %s%sPNR response with empty phone number";
LABEL_24:
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v14, buf, 0x16u);
  }
LABEL_25:
  memset(buf, 0, 24);
  ctu::cf::assign();
  long long v48 = *(_OWORD *)buf;
  uint64_t v49 = *(void *)&buf[16];
  if ((buf[23] & 0x80u) == 0) {
    int v16 = (const char *)&v48;
  }
  else {
    int v16 = (const char *)v48;
  }
  xpc_object_t v47 = xpc_string_create(v16);
  if (!v47) {
    xpc_object_t v47 = xpc_null_create();
  }
  memset(buf, 0, 24);
  ctu::cf::assign();
  long long v44 = *(_OWORD *)buf;
  uint64_t v45 = *(void *)&buf[16];
  uint64_t v17 = *(long long **)buf;
  if ((buf[23] & 0x80u) == 0) {
    uint64_t v17 = &v44;
  }
  __p[0] = &v40;
  __p[1] = v17;
  sub_100035E70((uint64_t)__p, &v47, v42);
  xpc_release(v42[0]);
  v42[0] = 0;
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)v44);
  }
  xpc_release(v47);
  xpc_object_t v47 = 0;
  if (SHIBYTE(v49) < 0) {
    operator delete((void *)v48);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  uint8_t v19 = ServiceMap;
  if (v20 < 0)
  {
    uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v20;
  long long v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
  if (!v24)
  {
    std::mutex::unlock(v19);
    goto LABEL_68;
  }
  uint64_t v26 = v24[3];
  uint64_t v25 = (std::__shared_weak_count *)v24[4];
  if (v25)
  {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v19);
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v25);
    if (!v26)
    {
LABEL_67:
      sub_10004D2C8(v25);
      goto LABEL_68;
    }
  }
  else
  {
    std::mutex::unlock(v19);
    if (!v26) {
      goto LABEL_68;
    }
  }
  uint64_t v55 = 0;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  memset(buf, 0, sizeof(buf));
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v26 + 176))(buf, v26, **(void **)(a1 + 40) + 24);
  uint64_t v27 = BYTE7(v53);
  if (SBYTE7(v53) < 0) {
    uint64_t v27 = *((void *)&v52 + 1);
  }
  if (v27)
  {
    if ((SBYTE7(v53) & 0x80u) == 0) {
      long long v28 = (const char *)&v52;
    }
    else {
      long long v28 = (const char *)v52;
    }
    xpc_object_t v41 = xpc_string_create(v28);
    if (!v41) {
      xpc_object_t v41 = xpc_null_create();
    }
    long long v48 = 0uLL;
    uint64_t v49 = 0;
    ctu::cf::assign();
    long long v44 = v48;
    uint64_t v45 = v49;
    long long v29 = &v44;
    if (v49 < 0) {
      long long v29 = (long long *)v44;
    }
    __p[0] = &v40;
    __p[1] = v29;
    sub_100035E70((uint64_t)__p, &v41, (xpc_object_t *)&v48);
    xpc_release((xpc_object_t)v48);
    *(void *)&long long v48 = 0;
    if (SHIBYTE(v45) < 0) {
      operator delete((void *)v44);
    }
    xpc_release(v41);
    xpc_object_t v41 = 0;
  }
  if (SHIBYTE(v55) < 0) {
    operator delete((void *)v54);
  }
  if (SBYTE7(v53) < 0) {
    operator delete((void *)v52);
  }
  if (SHIBYTE(v51) < 0) {
    operator delete(*(void **)&buf[24]);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  if (v25) {
    goto LABEL_67;
  }
LABEL_68:
  if (xpc_get_type(v40) == (xpc_type_t)&_xpc_type_dictionary)
  {
    if (*(_DWORD *)(**(void **)(a1 + 40) + 52) == 1)
    {
      xpc_object_t v33 = v40;
      *(void *)long long buf = v40;
      if (v40)
      {
        xpc_retain(v40);
      }
      else
      {
        xpc_object_t v33 = xpc_null_create();
        *(void *)long long buf = v33;
      }
      xpc_object_t v34 = xpc_null_create();
      *(void *)&long long v48 = v34;
      sub_1000452AC(96, (xpc_object_t *)buf, (xpc_object_t *)&v48);
      xpc_release(v34);
      xpc_release(v33);
    }
    uint64_t v35 = *(void *)(a1 + 56);
    uint64_t v30 = *(NSObject **)(a1 + 16);
    BOOL v36 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
    if (!v35)
    {
      if (!v36) {
        goto LABEL_83;
      }
      uint64_t v39 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 40));
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v39;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      uint64_t v32 = "#W %s%sFailed to get PNR Notification interface.";
      goto LABEL_71;
    }
    long long v37 = *(PersonalityInfo ***)(a1 + 40);
    if (v36)
    {
      uint64_t v38 = PersonalityInfo::logPrefix(*v37);
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v38;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s%sIssuing PNR Response received", buf, 0x16u);
      uint64_t v35 = *(void *)(a1 + 56);
      long long v37 = *(PersonalityInfo ***)(a1 + 40);
    }
    (*(void (**)(uint64_t, void, xpc_object_t *))(*(void *)v35 + 8))(v35, *((unsigned int *)*v37 + 13), &v40);
  }
  else
  {
    uint64_t v30 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v31 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 40));
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v31;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      uint64_t v32 = "#W %s%sFailed to create PNR notification dictionary";
LABEL_71:
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v32, buf, 0x16u);
    }
  }
LABEL_83:
  xpc_release(v40);
}

void sub_1002B40EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t a19, uint64_t a20,xpc_object_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,xpc_object_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,xpc_object_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
}

void sub_1002B43B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3D70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002B43D4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3D70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1002B4428(void *a1)
{
  long long v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  xpc_object_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  xpc_object_t v5 = (std::__shared_weak_count *)a1[4];
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_1002B449C(void *a1, void *a2, const char *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v9, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 1), (const ctu::OsLogLogger *)v9);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  *a1 = off_1019B3DC0;
  a1[2] = *a2;
  uint64_t v5 = a2[1];
  a1[3] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  xpc_object_t v6 = (char *)operator new(8uLL);
  __p.var0 = v6;
  *(void *)xpc_object_t v6 = @"Stewie";
  __p.var1.fRef = (os_log_s *)(v6 + 8);
  uint64_t v8 = v6 + 8;
  sub_10026EFA4(a1 + 4);
}

void sub_1002B459C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(v12 + 24);
  if (v15) {
    sub_10004D2C8(v15);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  _Unwind_Resume(a1);
}

BOOL sub_1002B45F4(uint64_t a1)
{
  void (***v10)(unsigned char **__return_ptr, void);
  char v11;
  BOOL v12;
  std::mutex *v13;
  std::mutex *v14;
  unint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  unsigned int v18;
  void *v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  char v22;
  int v23;
  unsigned char *v25;
  std::__shared_weak_count *v26;
  unint64_t v27;

  uint64_t v25 = 0;
  uint64_t v26 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
  uint64_t v3 = ServiceMap;
  xpc_object_t v4 = "20ProfileManagedConfig";
  if (((unint64_t)"20ProfileManagedConfig" & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)((unint64_t)"20ProfileManagedConfig" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      xpc_object_t v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v27 = (unint64_t)v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v27);
  if (v8)
  {
    uint64_t v10 = (void (***)(unsigned char **__return_ptr, void))v8[3];
    OsLogContext v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      uint64_t v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  OsLogContext v9 = 0;
  uint64_t v11 = 1;
LABEL_9:
  (**v10)(&v25, v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (v25 && v25[1] && *v25)
  {
    uint64_t v12 = 1;
    goto LABEL_28;
  }
  uint64_t v13 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
  long long v14 = v13;
  if ((v15 & 0x8000000000000000) != 0)
  {
    int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      uint64_t v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(v13);
  uint64_t v27 = v15;
  uint8_t v19 = sub_10004D37C(&v14[1].__m_.__sig, &v27);
  if (!v19)
  {
    uint64_t v21 = 0;
    goto LABEL_22;
  }
  uint64_t v21 = v19[3];
  uint64_t v20 = (std::__shared_weak_count *)v19[4];
  if (!v20)
  {
LABEL_22:
    std::mutex::unlock(v14);
    uint64_t v20 = 0;
    uint64_t v22 = 1;
    goto LABEL_23;
  }
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v14);
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  uint64_t v22 = 0;
LABEL_23:
  unsigned int v23 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 16))(v21);
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  if (v23) {
    uint64_t v12 = sub_10025B63C(a1 + 32, 0) == 1;
  }
  else {
    uint64_t v12 = 0;
  }
LABEL_28:
  if (v26) {
    sub_10004D2C8(v26);
  }
  return v12;
}

void sub_1002B481C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002B4864()
{
  return 1;
}

void sub_1002B486C(uint64_t a1)
{
  long long v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v3 = sub_1002B45F4(a1);
    xpc_object_t v4 = "false";
    if (v3) {
      xpc_object_t v4 = "true";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Mock Mode: %s", (uint8_t *)&v5, 0xCu);
  }
}

void *sub_1002B4928(void *a1)
{
  *a1 = off_1019B3DC0;
  uint64_t v4 = a1[5];
  long long v2 = a1 + 5;
  uint64_t v3 = v4;
  *long long v2 = 0;
  if (v4) {
    sub_10026CD9C((uint64_t)v2, v3);
  }
  int v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_1002B4994(uint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, const void *a4@<X3>, _OWORD *a5@<X8>)
{
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v12 = a2;
  uint64_t v11 = a3;
  CFTypeRef v10 = a4;
  sub_100F8F6AC(&v12, &v7, &v11, &v10, &v9);
  *a5 = v9;
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_1002B4A10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B4A28(NSObject **a1@<X1>, std::__shared_weak_count **a2@<X8>)
{
  uint64_t v4 = (std::__shared_weak_count *)operator new(0x68uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3E80;
  int v5 = v4 + 1;
  sub_10015DC48((uint64_t)&v4[1], a1);
  shared_weak_owners = (std::__shared_weak_count *)v4[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v4[1].__shared_owners_ = (uint64_t)v5;
    v4[1].__shared_weak_owners_ = (uint64_t)v4;
    goto LABEL_5;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v4[1].__shared_owners_ = (uint64_t)v5;
    v4[1].__shared_weak_owners_ = (uint64_t)v4;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_5:
    sub_10004D2C8(v4);
  }
  *a2 = v5;
  a2[1] = v4;
}

void sub_1002B4AE8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1002B4B00(Peer2PeerFactoryInterface *this)
{
  *(void *)this = off_1019B3E38;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  Peer2PeerFactoryInterface::~Peer2PeerFactoryInterface(this);
}

void sub_1002B4B5C(Peer2PeerFactoryInterface *this)
{
  *(void *)this = off_1019B3E38;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  Peer2PeerFactoryInterface::~Peer2PeerFactoryInterface(this);

  operator delete();
}

void sub_1002B4BCC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3E80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002B4BEC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019B3E80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1002B4C40(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t *sub_1002B4C68(uint64_t a1)
{
  sub_100C62630(a1, "kRegistrationUpdateRegisteredLocationStatus", (unint64_t)sub_1002B505C, 3u);
  sub_100C62700(a1, "kRegistrationGetSignalStrengthDisplayValue", (unint64_t)sub_1002B55FC, 3u);
  sub_100C62700(a1, "kRegistrationGetProperty", (unint64_t)sub_100051118, 3u);
  sub_100C62700(a1, "kRegistrationGetPublicSignalStrength", (unint64_t)sub_1002B586C, 8u);
  sub_100C62700(a1, "kRegistrationProviderName", (unint64_t)sub_1002B5ADC, 1u);
  sub_100C62700(a1, "kRegistrationIsoCountryCode", (unint64_t)sub_1002B5DF0, 1u);
  sub_100C62630(a1, "kRegistrationSetProperty", (unint64_t)sub_1002B6254, 3u);
  sub_100C62700(a1, "kRegistrationSetPropertySync", (unint64_t)sub_1002B6CE8, 3u);
  sub_100C62700(a1, "kFetchTimeFromNetwork", (unint64_t)sub_1002B8068, 3u);
  sub_100C62630(a1, "kSetTimeCacheValidityPeriod", (unint64_t)sub_1002B8284, 3u);
  sub_100C62630(a1, "kRegistrationFetchNetworkList", (unint64_t)sub_1002B83FC, 3u);
  sub_100C62700(a1, "kRegistrationAddNotificationAssertion", (unint64_t)sub_1002B8504, 3u);
  sub_100C62700(a1, "kRegistrationCopyInfo", (unint64_t)sub_1002B882C, 3u);
  sub_100C62700(a1, "kRegistrationCopyBandInfo", (unint64_t)sub_1002B9218, 3u);
  sub_100C62630(a1, "kRegistrationSetBandInfo", (unint64_t)sub_1002B93DC, 3u);
  sub_100C62700(a1, "kGetLTEWithCDRXState", (unint64_t)sub_1002B9658, 3u);
  sub_100C62630(a1, "kSetCivicInfoBasedOnCurrentLocation", (unint64_t)sub_1002B9814, 3u);
  sub_100C62630(a1, "kSetLocalRoutableAddress", (unint64_t)sub_1002B9EE4, 3u);
  sub_100C62700(a1, "kGetE911State", (unint64_t)sub_1002BA0F4, 3u);
  sub_100C62700(a1, "kGetWifiE911State", (unint64_t)sub_1002BA1F4, 3u);
  sub_100C62700(a1, "kPhoneServicesGetDeviceList", (unint64_t)sub_1002BA5B4, 3u);
  sub_100C62700(a1, "kPhoneServicesGetDeviceInfo", (unint64_t)sub_1002BA88C, 3u);
  sub_100C62630(a1, "kPhoneServicesAddDevice", (unint64_t)sub_1002BAB64, 3u);
  sub_100C62630(a1, "kPhoneServicesRemoveDevice", (unint64_t)sub_1002BAE48, 3u);
  sub_100C62630(a1, "kPhoneServicesEnableDevice", (unint64_t)nullsub_473, 3u);
  sub_100C62630(a1, "kPhoneServicesDisableDevice", (unint64_t)nullsub_474, 3u);

  return sub_100C62700(a1, "kGetIdentityProtectionSupport", (unint64_t)sub_1002BB134, 3u);
}

void sub_1002B505C(capabilities::ct *a1, uint64_t a2, uint64_t a3, void **a4)
{
  void (***v15)(void ***__return_ptr, void, void **);
  std::__shared_weak_count *v16;
  std::mutex *ServiceMap;
  std::mutex *v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  void **v26;
  const object *v27;
  uint64_t (*v28)(uint64_t);
  CFIndex Count;
  uint64_t v30;
  int v31;
  const void *v32;
  const void *v33;
  void *v34;
  CFTypeID v35;
  CFBooleanRef v36;
  int v37;
  void **values;
  void **v39;
  uint64_t v40;
  void **keys;
  void **v42;
  uint64_t v43;
  xpc_object_t object;
  CFDictionaryRef theDict;
  void *v46[2];
  uint64_t v47;
  void *__p[2];
  uint64_t v49;

  int v6 = capabilities::ct::supportsThumperService(a1);
  uint64_t v7 = *(Registry **)a1;
  if (!v6)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7);
    uint64_t v18 = ServiceMap;
    if (v19 < 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint8_t v19 = v21;
        uint64_t v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v19;
    unsigned int v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)__p);
    if (v23)
    {
      long long v24 = v23[3];
      int v16 = (std::__shared_weak_count *)v23[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
LABEL_20:
        (*(void (**)(void ***__return_ptr, uint64_t, uint64_t))(*(void *)v24 + 8))(&keys, v24, 1);
        goto LABEL_23;
      }
    }
    else
    {
      long long v24 = 0;
    }
    std::mutex::unlock(v18);
    int v16 = 0;
    goto LABEL_20;
  }
  uint64_t v8 = (std::mutex *)Registry::getServiceMap(v7);
  long long v9 = v8;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(v8);
  __p[0] = (void *)v10;
  long long v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)__p);
  if (!v14)
  {
    uint64_t v15 = 0;
    goto LABEL_15;
  }
  uint64_t v15 = (void (***)(void ***__return_ptr, void, void **))v14[3];
  int v16 = (std::__shared_weak_count *)v14[4];
  if (!v16)
  {
LABEL_15:
    std::mutex::unlock(v9);
    int v16 = 0;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
LABEL_16:
  sub_100058DB0(v46, "thumper");
  if (SHIBYTE(v47) < 0)
  {
    sub_10004FC84(__p, v46[0], (unint64_t)v46[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)v46;
    uint64_t v49 = v47;
  }
  (**v15)(&keys, v15, __p);
LABEL_23:
  uint64_t v26 = keys;
  uint64_t v25 = (std::__shared_weak_count *)v42;
  keys = 0;
  long long v42 = 0;
  if (v6)
  {
    if (SHIBYTE(v49) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v47) < 0) {
      operator delete(v46[0]);
    }
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v26)
  {
    CFDictionaryRef theDict = 0;
    keys = a4;
    long long v42 = (void **)"kTelephonyCapabilityInformation";
    sub_100048BAC((uint64_t)&keys, &object);
    xpc::bridge((uint64_t *)&values, (xpc *)&object, v27);
    sub_10004EFE4(&theDict, (CFTypeRef *)&values);
    sub_1000577C4((const void **)&values);
    xpc_release(object);
    if (theDict) {
      long long v28 = sub_100080778;
    }
    else {
      long long v28 = 0;
    }
    if (!v28) {
      goto LABEL_54;
    }
    CFIndex Count = CFDictionaryGetCount(theDict);
    if (!Count) {
      goto LABEL_54;
    }
    keys = 0;
    long long v42 = 0;
    long long v43 = 0;
    sub_10019E8F0(&keys, Count);
    values = 0;
    uint64_t v39 = 0;
    xpc_object_t v40 = 0;
    sub_10004EE3C(&values, Count);
    CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
    if (Count >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      uint64_t v32 = (const void *)kCTCapabilityAgent2;
      xpc_object_t v33 = (const void *)kCTCapabilityPhoneServices;
      while (1)
      {
        xpc_object_t v34 = values[v30];
        LOBYTE(object) = 0;
        if (v34)
        {
          uint64_t v35 = CFGetTypeID(v34);
          if (v35 == CFBooleanGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&object, (BOOL *)v34, v36);
          }
        }
        long long v37 = object;
        if (CFEqual(keys[v30], v32)) {
          break;
        }
        if (CFEqual(keys[v30], v33))
        {
          (*((void (**)(void **, uint64_t, BOOL))*v26 + 10))(v26, 1, v37 != 0);
          goto LABEL_45;
        }
LABEL_46:
        if (Count == ++v30) {
          goto LABEL_49;
        }
      }
      (*((void (**)(void **, void, BOOL))*v26 + 10))(v26, 0, v37 != 0);
LABEL_45:
      ++v31;
      goto LABEL_46;
    }
    uint64_t v31 = 0;
LABEL_49:
    if (values)
    {
      uint64_t v39 = values;
      operator delete(values);
    }
    if (keys)
    {
      long long v42 = keys;
      operator delete(keys);
    }
    if (!v31)
    {
LABEL_54:
      (*((void (**)(void **, void, uint64_t))*v26 + 10))(v26, 0, 1);
      (*((void (**)(void **, uint64_t, uint64_t))*v26 + 10))(v26, 1, 1);
    }
    sub_100057D78((const void **)&theDict);
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_1002B54FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, xpc_object_t object, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (v29) {
    sub_10004D2C8(v29);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B55FC(Registry **a1, uint64_t a2, NSObject **a3, uint64_t a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  v22[0] = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, v22);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    long long v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_15;
    }
LABEL_10:
    uint64_t v20 = 0;
    uint64_t v17 = *a3;
    if (v17) {
      dispatch_retain(v17);
    }
    unint64_t v19 = *a5;
    unint64_t v18 = a5[1];
    if (v18) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
    }
    dispatch_object_t object = v17;
    v22[0] = (unint64_t)off_1019B3ED0;
    v22[1] = v19;
    void v22[2] = v18;
    _DWORD v22[3] = (unint64_t)v22;
    sub_1002BB4E4();
  }
  uint64_t v15 = v13[3];
  long long v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (v15) {
    goto LABEL_10;
  }
LABEL_15:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1002B580C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t *a10, dispatch_object_t object, char a12)
{
  sub_1002BB62C((uint64_t **)&a9, 0);
  sub_1002BB62C(&a10, 0);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(a1);
}

void sub_1002B586C(Registry **a1, uint64_t a2, NSObject **a3, uint64_t a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  v22[0] = v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, v22);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    long long v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_15;
    }
LABEL_10:
    uint64_t v20 = 0;
    uint64_t v17 = *a3;
    if (v17) {
      dispatch_retain(v17);
    }
    unint64_t v19 = *a5;
    unint64_t v18 = a5[1];
    if (v18) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
    }
    dispatch_object_t object = v17;
    v22[0] = (unint64_t)off_1019B4250;
    v22[1] = v19;
    void v22[2] = v18;
    _DWORD v22[3] = (unint64_t)v22;
    sub_1002BB4E4();
  }
  uint64_t v15 = v13[3];
  long long v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (v15) {
    goto LABEL_10;
  }
LABEL_15:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1002B5A7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t *a10, dispatch_object_t object, char a12)
{
  sub_1002BB62C((uint64_t **)&a9, 0);
  sub_1002BB62C(&a10, 0);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(a1);
}

const void **sub_1002B5ADC(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  *(void *)std::string string = 4096;
  uint64_t result = (const void **)IsTelephonyRunningExtended(string);
  if (!result) {
    return result;
  }
  *(void *)std::string string = a4;
  uint64_t v25 = "kRegistrationUseCarrierBundle";
  sub_100048BAC((uint64_t)string, object);
  int v10 = xpc::dyn_cast_or_default((xpc *)object, 0, v9);
  xpc_release(object[0]);
  CFStringRef v11 = 0;
  CFStringRef v32 = 0;
  if (v10)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    char v13 = ServiceMap;
    if (v14 < 0)
    {
      uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        uint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string string = v14;
    unint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)string);
    if (v18)
    {
      uint64_t v20 = v18[3];
      unint64_t v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
LABEL_11:
        (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, void, void))(*(void *)v20 + 40))(&v31, v20, kCarrierBundleId, @"CarrierName", 0, 0);
        sub_100056248(object, &v31);
        *(void *)std::string string = v32;
        CFStringRef v32 = (const __CFString *)object[0];
        object[0] = 0;
        sub_1000558F4((const void **)string);
        sub_1000558F4((const void **)object);
        sub_1000577C4(&v31);
        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
        CFStringRef v11 = v32;
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    unint64_t v19 = 0;
    char v21 = 1;
    goto LABEL_11;
  }
LABEL_14:
  if (v11) {
    uint64_t v22 = sub_1000810B8;
  }
  else {
    uint64_t v22 = 0;
  }
  if (v22 && CFStringGetLength(v11))
  {
    xpc_object_t v29 = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
    if (!v29) {
      xpc_object_t v29 = xpc_null_create();
    }
    *(void *)std::string string = *a5;
    uint64_t v25 = "kRegistrationProviderName";
    sub_100035E70((uint64_t)string, &v29, &v30);
    xpc_release(v30);
    xpc_object_t v30 = 0;
    xpc_release(v29);
    xpc_object_t v29 = 0;
  }
  else
  {
    *(void *)std::string string = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    xpc_object_t v27 = xpc_string_create(string);
    if (!v27) {
      xpc_object_t v27 = xpc_null_create();
    }
    object[0] = *(xpc_object_t *)a5;
    object[1] = "kRegistrationProviderName";
    sub_100035E70((uint64_t)object, &v27, &v28);
    xpc_release(v28);
    xpc_object_t v28 = 0;
    xpc_release(v27);
    xpc_object_t v27 = 0;
    if (SHIBYTE(v26) < 0) {
      operator delete(*(void **)string);
    }
  }
  return sub_1000558F4((const void **)&v32);
}

void sub_1002B5D8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  sub_1000577C4((const void **)(v12 - 64));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  sub_1000558F4((const void **)(v12 - 56));
  _Unwind_Resume(a1);
}

void sub_1002B5DF0(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void **a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)xpc_object_t v41 = v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)v41);
  if (v13)
  {
    uint64_t v15 = (SubscriberUtilityInterface *)v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_7;
      }
LABEL_15:
      *(void *)xpc_object_t v41 = 0;
      long long v42 = 0;
      uint64_t v43 = 0;
      SubscriberUtilityInterface::getSubscriberMcc((uint64_t *)v41, v15);
      if (v43 >= 0) {
        unint64_t v18 = v41;
      }
      else {
        unint64_t v18 = *(uint8_t **)v41;
      }
      xpc_object_t v39 = xpc_string_create((const char *)v18);
      if (!v39) {
        xpc_object_t v39 = xpc_null_create();
      }
      __p[0] = *a5;
      __p[1] = "kRegistrationMCC";
      sub_100035E70((uint64_t)__p, &v39, &v40);
      xpc_release(v40);
      xpc_object_t v40 = 0;
      xpc_release(v39);
      xpc_object_t v39 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v38 = 0;
      unint64_t v19 = (std::mutex *)Registry::getServiceMap(*a1);
      uint64_t v20 = v19;
      if (v21 < 0)
      {
        uint64_t v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v23 = 5381;
        do
        {
          uint64_t v21 = v23;
          unsigned int v24 = *v22++;
          uint64_t v23 = (33 * v23) ^ v24;
        }
        while (v24);
      }
      std::mutex::lock(v19);
      *(void *)long long buf = v21;
      uint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
      if (v25)
      {
        uint64_t v27 = v25[3];
        uint64_t v26 = (std::__shared_weak_count *)v25[4];
        if (v26)
        {
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v20);
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v26);
          char v28 = 0;
          if (!v27) {
            goto LABEL_26;
          }
          goto LABEL_30;
        }
      }
      else
      {
        uint64_t v27 = 0;
      }
      std::mutex::unlock(v20);
      uint64_t v26 = 0;
      char v28 = 1;
      if (!v27)
      {
LABEL_26:
        sub_1002BBBAC();
        xpc_object_t v29 = qword_101B0CAF0;
        if (os_log_type_enabled((os_log_t)qword_101B0CAF0, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Missing IsoMccCacheInterface", buf, 2u);
        }
        goto LABEL_33;
      }
LABEL_30:
      (*(void (**)(uint8_t *__return_ptr, uint64_t, uint8_t *))(*(void *)v27 + 24))(buf, v27, v41);
      if (SHIBYTE(v38) < 0) {
        operator delete(__p[0]);
      }
      *(_OWORD *)OsLogContext __p = *(_OWORD *)buf;
      uint64_t v38 = v36;
LABEL_33:
      if ((v28 & 1) == 0) {
        sub_10004D2C8(v26);
      }
      if (v38 >= 0) {
        xpc_object_t v30 = __p;
      }
      else {
        xpc_object_t v30 = (void **)__p[0];
      }
      xpc_object_t v33 = xpc_string_create((const char *)v30);
      if (!v33) {
        xpc_object_t v33 = xpc_null_create();
      }
      *(void *)long long buf = *a5;
      *(void *)&uint8_t buf[8] = "kRegistrationIsoCountryCode";
      sub_100035E70((uint64_t)buf, &v33, &v34);
      xpc_release(v34);
      xpc_object_t v34 = 0;
      xpc_release(v33);
      xpc_object_t v33 = 0;
      if (SHIBYTE(v38) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v43) < 0)
      {
        operator delete(*(void **)v41);
        if (v16) {
          return;
        }
      }
      else if (v16)
      {
        return;
      }
      goto LABEL_44;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (v15) {
    goto LABEL_15;
  }
LABEL_7:
  sub_1002BBBAC();
  unsigned int v17 = qword_101B0CAF0;
  if (os_log_type_enabled((os_log_t)qword_101B0CAF0, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)xpc_object_t v41 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Missing SubscriberUtilityInterface", v41, 2u);
  }
  xpc_object_t v31 = xpc_int64_create(45);
  if (!v31) {
    xpc_object_t v31 = xpc_null_create();
  }
  *(void *)xpc_object_t v41 = *a5;
  long long v42 = "kPosixError";
  sub_100035E70((uint64_t)v41, &v31, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v31);
  xpc_object_t v31 = 0;
  if ((v16 & 1) == 0) {
LABEL_44:
  }
    sub_10004D2C8(v14);
}

void sub_1002B61C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  if (a22 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v26 - 73) < 0) {
    operator delete(*(void **)(v26 - 96));
  }
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B6254(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  *(void *)&long long __p = 4096;
  if (IsTelephonyRunningExtended(&__p))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    uint64_t v7 = ServiceMap;
    if (v8 < 0)
    {
      uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        uint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long __p = v8;
    unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&__p);
    if (v12)
    {
      char v13 = (RegistrationInterface *)v12[3];
      uint64_t v14 = (std::__shared_weak_count *)v12[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v15 = 0;
        if (!v13)
        {
LABEL_70:
          if ((v15 & 1) == 0) {
            sub_10004D2C8(v14);
          }
          return;
        }
LABEL_11:
        if (!xpc_dictionary_get_value(*a4, "kRegistrationRAT"))
        {
LABEL_50:
          if (xpc_dictionary_get_value(*a4, "kRegistrationCurrentNetworkSelection"))
          {
            xpc_object_t object = 0;
            uint64_t v55 = 0;
            uint64_t v56 = 0;
            xpc_object_t v51 = a4;
            long long v52 = (std::__shared_weak_count *)"kRegistrationCurrentNetworkSelection";
            sub_100048BAC((uint64_t)&v51, &v53);
            long long __p = 0uLL;
            unsigned int v58 = 0;
            xpc::dyn_cast_or_default();
            if (SHIBYTE(v58) < 0) {
              operator delete((void *)__p);
            }
            xpc_release(v53);
            RegistrationInterface::selectNetwork();
            if (SHIBYTE(v56) < 0) {
              operator delete(object);
            }
          }
          if (xpc_dictionary_get_value(*a4, "kRegistrationAutomaticNetworkSelection")) {
            RegistrationInterface::automaticallySelectNetwork(v13);
          }
          if (xpc_dictionary_get_value(*a4, "kRegistrationBrickMode"))
          {
            *(void *)&long long __p = a4;
            *((void *)&__p + 1) = "kRegistrationBrickMode";
            sub_100048BAC((uint64_t)&__p, &object);
            uint64_t v42 = xpc::dyn_cast_or_default((xpc *)&object, 0, v41);
            xpc_release(object);
            long long __p = 0uLL;
            sub_100068A94(&__p);
            if ((void)__p) {
              (*(void (**)(void, uint64_t))(*(void *)__p + 40))(__p, v42);
            }
            if (*((void *)&__p + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&__p + 1));
            }
          }
          if (xpc_dictionary_get_value(*a4, "kRegistrationEmergencyCallBackMode"))
          {
            *(void *)&long long __p = a4;
            *((void *)&__p + 1) = "kRegistrationEmergencyCallBackMode";
            sub_100048BAC((uint64_t)&__p, &object);
            uint64_t v44 = xpc::dyn_cast_or_default((xpc *)&object, 0, v43);
            xpc_release(object);
            (*(void (**)(RegistrationInterface *, uint64_t))(*(void *)v13 + 272))(v13, v44);
          }
          if (xpc_dictionary_get_value(*a4, "kRegistrationOnlyHomeNetwork"))
          {
            *(void *)&long long __p = a4;
            *((void *)&__p + 1) = "kRegistrationOnlyHomeNetwork";
            sub_100048BAC((uint64_t)&__p, &object);
            uint64_t v46 = xpc::dyn_cast_or_default((xpc *)&object, 0, v45);
            xpc_release(object);
            sub_1002BBBAC();
            xpc_object_t v47 = qword_101B0CAF0;
            if (os_log_type_enabled((os_log_t)qword_101B0CAF0, OS_LOG_TYPE_DEFAULT))
            {
              long long v48 = "false";
              if (v46) {
                long long v48 = "true";
              }
              LODWORD(__p) = 136315138;
              *(void *)((char *)&__p + 4) = v48;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Setting enable only home network: %s", (uint8_t *)&__p, 0xCu);
            }
            (*(void (**)(RegistrationInterface *, uint64_t))(*(void *)v13 + 288))(v13, v46);
          }
          goto LABEL_70;
        }
        *(void *)&long long __p = a4;
        *((void *)&__p + 1) = "kRegistrationRAT";
        sub_100048BAC((uint64_t)&__p, &object);
        unsigned __int8 v17 = xpc::dyn_cast_or_default((xpc *)&object, 0, v16);
        xpc_release(object);
        *(void *)&long long __p = a4;
        *((void *)&__p + 1) = "kRegistrationPreferredRAT";
        sub_100048BAC((uint64_t)&__p, &object);
        unsigned __int8 v19 = xpc::dyn_cast_or_default((xpc *)&object, 0, v18);
        xpc_release(object);
        if (v17 == 255)
        {
LABEL_44:
          if (v17 <= 0x20u)
          {
            if (((1 << v17) & 0x100011115) != 0)
            {
LABEL_46:
              unsigned __int8 v19 = v17;
LABEL_47:
              *(void *)&long long __p = _NSConcreteStackBlock;
              *((void *)&__p + 1) = 0x40000000;
              unsigned int v58 = sub_10017DD78;
              p_p = (long long *)&unk_1019A6310;
              int v60 = v17;
              sub_10017DB90((wis::MetricFactory *)0x8001D);
              uint64_t v50 = 0;
              RatSelectionType::RatSelectionType((RatSelectionType *)&v50);
              RatSelectionType::setSelection((RatSelectionType *)&v50, v17);
              RatSelectionType::setPreferredSelection((RatSelectionType *)&v50, v19);
              xpc_object_t v51 = 0;
              sub_10014E9E0((RatSelectionType *)&v50, &v51);
              sub_100058DB0(&object, "/cc/requests/rat_selection");
              xpc_object_t v53 = v51;
              xpc_object_t v51 = xpc_null_create();
              *(void *)&long long __p = off_1019B42D0;
              BYTE8(__p) = 0;
              p_p = &__p;
              ctu::RestModule::sendRequest();
              sub_10003F600(&__p);
              xpc_release(v53);
              xpc_object_t v53 = 0;
              if (SHIBYTE(v56) < 0) {
                operator delete(object);
              }
              xpc_release(v51);
              goto LABEL_50;
            }
            if (v17 == 1)
            {
              unsigned __int8 v19 = 2;
              goto LABEL_47;
            }
            if (v17 == 3)
            {
              if (v19 != 1) {
                unsigned __int8 v19 = 2;
              }
              goto LABEL_47;
            }
          }
          if (v17 != 255) {
            goto LABEL_47;
          }
          goto LABEL_46;
        }
        uint64_t v49 = v14;
        uint64_t v20 = (std::mutex *)Registry::getServiceMap(*a1);
        uint64_t v21 = v20;
        if (v22 < 0)
        {
          uint64_t v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v24 = 5381;
          do
          {
            uint64_t v22 = v24;
            unsigned int v25 = *v23++;
            uint64_t v24 = (33 * v24) ^ v25;
          }
          while (v25);
        }
        std::mutex::lock(v20);
        *(void *)&long long __p = v22;
        uint64_t v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)&__p);
        if (v26)
        {
          uint64_t v28 = v26[3];
          uint64_t v27 = (std::__shared_weak_count *)v26[4];
          if (v27)
          {
            atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v21);
            atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v27);
            goto LABEL_21;
          }
        }
        else
        {
          uint64_t v28 = 0;
        }
        std::mutex::unlock(v21);
        uint64_t v27 = 0;
LABEL_21:
        int v29 = (*(uint64_t (**)(uint64_t))(*(void *)v28 + 16))(v28);
        char v30 = v29;
        uint64_t v14 = v49;
        if (v27)
        {
          sub_10004D2C8(v27);
          if ((v30 & 1) == 0) {
            goto LABEL_44;
          }
        }
        else if (!v29)
        {
          goto LABEL_44;
        }
        xpc_object_t v31 = (std::mutex *)Registry::getServiceMap(*a1);
        CFStringRef v32 = v31;
        if (v33 < 0)
        {
          xpc_object_t v34 = (unsigned __int8 *)(v33 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v35 = 5381;
          do
          {
            uint64_t v33 = v35;
            unsigned int v36 = *v34++;
            uint64_t v35 = (33 * v35) ^ v36;
          }
          while (v36);
        }
        std::mutex::lock(v31);
        *(void *)&long long __p = v33;
        long long v37 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)&__p);
        if (v37)
        {
          uint64_t v39 = v37[3];
          uint64_t v38 = (std::__shared_weak_count *)v37[4];
          if (v38)
          {
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v32);
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v38);
            char v40 = 0;
            goto LABEL_33;
          }
        }
        else
        {
          uint64_t v39 = 0;
        }
        std::mutex::unlock(v32);
        uint64_t v38 = 0;
        char v40 = 1;
LABEL_33:
        if (v39
          && (*(unsigned int (**)(uint64_t))(*(void *)v39 + 16))(v39)
          && ((*(uint64_t (**)(uint64_t))(*(void *)v39 + 32))(v39) & 1) == 0)
        {
          long long __p = 0uLL;
          unsigned int v58 = 0;
          sub_100058DB0(&__p, "CDMA Intl Roaming is OFF");
          xpc_object_t object = 0;
          uint64_t v55 = 0;
          uint64_t v56 = 0;
          sub_100058DB0(&object, "RAT Selection is not supported when CDMA Intl Roaming switch is OFF. Please reset it to Automatic");
          sub_1002BD030(*a1, &v51);
          (*(void (**)(xpc_object_t, long long *, xpc_object_t *))(*(void *)v51 + 24))(v51, &__p, &object);
          if (v52) {
            sub_10004D2C8(v52);
          }
          if (SHIBYTE(v56) < 0) {
            operator delete(object);
          }
          if (SHIBYTE(v58) < 0) {
            operator delete((void *)__p);
          }
        }
        uint64_t v14 = v49;
        if ((v40 & 1) == 0) {
          sub_10004D2C8(v38);
        }
        goto LABEL_44;
      }
    }
    else
    {
      char v13 = 0;
    }
    std::mutex::unlock(v7);
    uint64_t v14 = 0;
    char v15 = 1;
    if (!v13) {
      goto LABEL_70;
    }
    goto LABEL_11;
  }
}

void sub_1002B6A98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, int a13, char a14, uint64_t a15, xpc_object_t a16, std::__shared_weak_count *a17, xpc_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  if ((a14 & 1) == 0) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B6CE8(capabilities::ct *a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  void (***v16)(unsigned char *__return_ptr, void, long long *);
  std::__shared_weak_count *v17;
  std::mutex *ServiceMap;
  std::mutex *v19;
  uint64_t v20;
  unsigned __int8 *v21;
  uint64_t v22;
  unsigned int v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  const object *v28;
  uint64_t (*v29)(uint64_t);
  const object *v30;
  BOOL v32;
  uint64_t v33;
  NSObject *v34;
  const char *v35;
  const object *v36;
  BOOL v37;
  uint64_t v38;
  const object *v39;
  uint64_t (*v40)(uint64_t);
  BOOL v41;
  uint64_t v42;
  NSObject *v43;
  const char *v44;
  BOOL v45;
  uint64_t v46;
  std::mutex *v47;
  std::mutex *v48;
  uint64_t v49;
  unsigned __int8 *v50;
  uint64_t v51;
  unsigned int v52;
  void *v53;
  std::__shared_weak_count *v54;
  uint64_t v55;
  char v56;
  int v57;
  NSObject *v58;
  const char *v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  std::mutex *v63;
  std::mutex *v64;
  uint64_t v65;
  unsigned __int8 *v66;
  uint64_t v67;
  unsigned int v68;
  void *v69;
  std::__shared_weak_count *v70;
  uint64_t v71;
  char v72;
  std::mutex *v73;
  std::mutex *v74;
  uint64_t v75;
  unsigned __int8 *v76;
  uint64_t v77;
  unsigned int v78;
  void *v79;
  std::__shared_weak_count *v80;
  uint64_t v81;
  char v82;
  unint64_t v83;
  uint64_t v84;
  unsigned int v85;
  uint64_t v86;
  unsigned int v87;
  uint64_t v88;
  void (*v89)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v90;
  std::mutex *v91;
  std::mutex *v92;
  uint64_t v93;
  unsigned __int8 *v94;
  uint64_t v95;
  unsigned int v96;
  void *v97;
  std::__shared_weak_count *v98;
  uint64_t v99;
  char v100;
  unint64_t v101;
  uint64_t v102;
  void (*v103)(uint64_t, uint64_t, uint64_t);
  uint64_t v104;
  std::mutex *v105;
  std::mutex *v106;
  uint64_t v107;
  unsigned __int8 *v108;
  uint64_t v109;
  unsigned int v110;
  void *v111;
  std::__shared_weak_count *v112;
  uint64_t v113;
  char v114;
  BOOL v115;
  uint64_t v116;
  std::__shared_weak_count *v117;
  xpc_object_t v119;
  xpc_object_t v120;
  xpc_object_t v121;
  xpc_object_t v122;
  xpc_object_t v123;
  xpc_object_t v124;
  xpc_object_t v125;
  xpc_object_t v126;
  xpc_object_t v127;
  xpc_object_t v128;
  CFTypeRef v129;
  const void *v130;
  CFTypeRef v131;
  CFTypeRef v132;
  xpc_object_t v133;
  xpc_object_t object;
  CFTypeRef cf;
  CFTypeRef cf1;
  void *__p[2];
  uint64_t v138;
  long long __dst;
  uint64_t v140;
  unsigned char buf[22];

  int v7 = capabilities::ct::supportsThumperService(a1);
  uint64_t v8 = *(Registry **)a1;
  if (!v7)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8);
    unsigned __int8 v19 = ServiceMap;
    if (v20 < 0)
    {
      uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        uint64_t v20 = v22;
        uint64_t v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&std::string __dst = v20;
    uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)&__dst);
    if (v24)
    {
      unsigned int v25 = v24[3];
      unsigned __int8 v17 = (std::__shared_weak_count *)v24[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
LABEL_20:
        (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t))(*(void *)v25 + 8))(buf, v25, 1);
        goto LABEL_23;
      }
    }
    else
    {
      unsigned int v25 = 0;
    }
    std::mutex::unlock(v19);
    unsigned __int8 v17 = 0;
    goto LABEL_20;
  }
  uint64_t v9 = (std::mutex *)Registry::getServiceMap(v8);
  uint64_t v10 = v9;
  if (v11 < 0)
  {
    unsigned int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(v9);
  *(void *)&std::string __dst = v11;
  char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&__dst);
  if (!v15)
  {
    uint64_t v16 = 0;
    goto LABEL_15;
  }
  uint64_t v16 = (void (***)(unsigned char *__return_ptr, void, long long *))v15[3];
  unsigned __int8 v17 = (std::__shared_weak_count *)v15[4];
  if (!v17)
  {
LABEL_15:
    std::mutex::unlock(v10);
    unsigned __int8 v17 = 0;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
LABEL_16:
  sub_100058DB0(__p, "thumper");
  if (SHIBYTE(v138) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    std::string __dst = *(_OWORD *)__p;
    __int16 v140 = v138;
  }
  (**v16)(buf, v16, &__dst);
LABEL_23:
  uint64_t v26 = *(void *)buf;
  uint64_t v27 = *(std::__shared_weak_count **)&buf[8];
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  if (v7)
  {
    if (SHIBYTE(v140) < 0) {
      operator delete((void *)__dst);
    }
    if (SHIBYTE(v138) < 0) {
      operator delete(__p[0]);
    }
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (xpc_dictionary_get_value(*a4, "kTelephonyCapability")
    && xpc_dictionary_get_value(*a4, "kTelephonyCapabilityStatus"))
  {
    cf1 = 0;
    *(void *)long long buf = a4;
    *(void *)&uint8_t buf[8] = "kTelephonyCapability";
    sub_100048BAC((uint64_t)buf, &object);
    xpc::bridge((uint64_t *)&cf, (xpc *)&object, v28);
    sub_100056248(&cf1, &cf);
    sub_1000577C4(&cf);
    xpc_release(object);
    if (cf1) {
      int v29 = sub_1000810B8;
    }
    else {
      int v29 = 0;
    }
    if (v29 && CFEqual(cf1, kCTCapabilityPhoneServices))
    {
      if (!v26) {
        goto LABEL_161;
      }
      CFTypeRef cf = 0;
      *(void *)long long buf = a4;
      *(void *)&uint8_t buf[8] = "kTelephonyCapabilityInformation";
      sub_100048BAC((uint64_t)buf, &v133);
      xpc::bridge((uint64_t *)&object, (xpc *)&v133, v30);
      sub_10004EFE4(&cf, (CFTypeRef *)&object);
      sub_1000577C4((const void **)&object);
      xpc_release(v133);
      if (sub_10121F67C())
      {
        if (cf ? sub_100080778 : 0)
        {
          std::string v132 = cf;
          if (cf) {
            CFRetain(cf);
          }
          (*(void (**)(uint64_t, CFTypeRef *))(*(void *)v26 + 192))(v26, &v132);
          sub_100057D78(&v132);
        }
      }
      *(void *)long long buf = a4;
      *(void *)&uint8_t buf[8] = "kTelephonyCapabilityStatus";
      sub_100048BAC((uint64_t)buf, &object);
      uint64_t v33 = xpc::dyn_cast_or_default((xpc *)&object, 0, v32);
      xpc_release(object);
      sub_1002BBBAC();
      xpc_object_t v34 = qword_101B0CAF0;
      if (os_log_type_enabled((os_log_t)qword_101B0CAF0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v35 = "OFF";
        if (v33) {
          uint64_t v35 = "ON";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v35;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = cf;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I PhoneServices Set %s, %@", buf, 0x16u);
      }
      std::string v131 = cf;
      if (cf) {
        CFRetain(cf);
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(*(void *)v26 + 32))(v26, 1, v33, &v131);
      sub_100057D78(&v131);
      sub_100057D78(&cf);
    }
    sub_1000558F4(&cf1);
  }
  *(void *)long long buf = 4096;
  if (!IsTelephonyRunningExtended(buf)) {
    goto LABEL_157;
  }
  __int16 v117 = v27;
  if (!xpc_dictionary_get_value(*a4, "kTelephonyCapability")
    || !xpc_dictionary_get_value(*a4, "kTelephonyCapabilityStatus"))
  {
LABEL_73:
    if (!xpc_dictionary_get_value(*a4, "kRegistrationCDMAInternationalRoaming")) {
      goto LABEL_95;
    }
    *(void *)long long buf = a4;
    *(void *)&uint8_t buf[8] = "kRegistrationCDMAInternationalRoaming";
    sub_100048BAC((uint64_t)buf, &cf1);
    uint64_t v46 = xpc::dyn_cast_or_default((xpc *)&cf1, 0, v45);
    xpc_release((xpc_object_t)cf1);
    xpc_object_t v47 = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
    long long v48 = v47;
    if (v49 < 0)
    {
      uint64_t v50 = (unsigned __int8 *)(v49 & 0x7FFFFFFFFFFFFFFFLL);
      xpc_object_t v51 = 5381;
      do
      {
        uint64_t v49 = v51;
        long long v52 = *v50++;
        xpc_object_t v51 = (33 * v51) ^ v52;
      }
      while (v52);
    }
    std::mutex::lock(v47);
    *(void *)long long buf = v49;
    xpc_object_t v53 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)buf);
    if (v53)
    {
      uint64_t v55 = v53[3];
      long long v54 = (std::__shared_weak_count *)v53[4];
      if (v54)
      {
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v48);
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v54);
        uint64_t v56 = 0;
        if (!v55) {
          goto LABEL_80;
        }
        goto LABEL_84;
      }
    }
    else
    {
      uint64_t v55 = 0;
    }
    std::mutex::unlock(v48);
    long long v54 = 0;
    uint64_t v56 = 1;
    if (!v55)
    {
LABEL_80:
      uint64_t v57 = 0;
      if (v56) {
        goto LABEL_86;
      }
      goto LABEL_85;
    }
LABEL_84:
    uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v55 + 40))(v55, v46);
    if (v56)
    {
LABEL_86:
      sub_1002BBBAC();
      unsigned int v58 = qword_101B0CAF0;
      if (os_log_type_enabled((os_log_t)qword_101B0CAF0, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v59 = "Not Allow";
        if (v46) {
          BOOL v59 = "Allow";
        }
        int v60 = "Succeeded";
        if (!v57) {
          int v60 = "Failed";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v59;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v60;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I Setting CDMA International Roaming to '%s' %s", buf, 0x16u);
      }
      std::string::size_type v127 = xpc_BOOL_create(v57);
      uint64_t v27 = v117;
      if (!v127) {
        std::string::size_type v127 = xpc_null_create();
      }
      *(void *)long long buf = *a5;
      *(void *)&uint8_t buf[8] = "kRegistrationCDMAInternationalRoaming";
      sub_100035E70((uint64_t)buf, &v127, &v128);
      xpc_release(v128);
      CFArrayRef v128 = 0;
      xpc_release(v127);
      std::string::size_type v127 = 0;
LABEL_95:
      if (!xpc_dictionary_get_value(*a4, "kRegistrationVictimFreq")) {
        goto LABEL_142;
      }
      *(void *)long long buf = a4;
      *(void *)&uint8_t buf[8] = "kRegistrationDesenseClient";
      sub_100048BAC((uint64_t)buf, &cf1);
      uint64_t v62 = xpc::dyn_cast_or_default((xpc *)&cf1, 0, v61);
      xpc_release((xpc_object_t)cf1);
      if (!xpc_dictionary_get_value(*a4, "kRegistrationClear")) {
        goto LABEL_108;
      }
      uint64_t v63 = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
      int v64 = v63;
      if (v65 < 0)
      {
        uint64_t v66 = (unsigned __int8 *)(v65 & 0x7FFFFFFFFFFFFFFFLL);
        xpc_object_t v67 = 5381;
        do
        {
          uint64_t v65 = v67;
          uint64_t v68 = *v66++;
          xpc_object_t v67 = (33 * v67) ^ v68;
        }
        while (v68);
      }
      std::mutex::lock(v63);
      *(void *)long long buf = v65;
      uint64_t v69 = sub_10004D37C(&v64[1].__m_.__sig, (unint64_t *)buf);
      if (v69)
      {
        long long v71 = v69[3];
        long long v70 = (std::__shared_weak_count *)v69[4];
        if (v70)
        {
          atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v64);
          atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v70);
          long long v72 = 0;
LABEL_105:
          uint64_t v27 = v117;
          if (v71)
          {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v71 + 16))(v71, v62);
            if (v72) {
              goto LABEL_108;
            }
            goto LABEL_107;
          }
          std::string v125 = xpc_int64_create(45);
          if (!v125) {
            std::string v125 = xpc_null_create();
          }
          *(void *)long long buf = *a5;
          *(void *)&uint8_t buf[8] = "kPosixError";
          sub_100035E70((uint64_t)buf, &v125, &v126);
          xpc_release(v126);
          v126 = 0;
          xpc_release(v125);
          std::string v125 = 0;
          if ((v72 & 1) == 0) {
LABEL_107:
          }
            sub_10004D2C8(v70);
LABEL_108:
          if (!xpc_dictionary_get_value(*a4, "kRegistrationAdd")) {
            goto LABEL_127;
          }
          long long v73 = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
          long long v74 = v73;
          if (v75 < 0)
          {
            long long v76 = (unsigned __int8 *)(v75 & 0x7FFFFFFFFFFFFFFFLL);
            long long v77 = 5381;
            do
            {
              long long v75 = v77;
              long long v78 = *v76++;
              long long v77 = (33 * v77) ^ v78;
            }
            while (v78);
          }
          std::mutex::lock(v73);
          *(void *)long long buf = v75;
          long long v79 = sub_10004D37C(&v74[1].__m_.__sig, (unint64_t *)buf);
          if (v79)
          {
            long long v81 = v79[3];
            long long v80 = (std::__shared_weak_count *)v79[4];
            if (v80)
            {
              atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v74);
              atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v80);
              long long v82 = 0;
              if (!v81)
              {
LABEL_115:
                uint64_t v123 = xpc_int64_create(45);
                uint64_t v27 = v117;
                if (!v123) {
                  uint64_t v123 = xpc_null_create();
                }
                *(void *)long long buf = *a5;
                *(void *)&uint8_t buf[8] = "kPosixError";
                sub_100035E70((uint64_t)buf, &v123, &v124);
                xpc_release(v124);
                std::string v124 = 0;
                xpc_release(v123);
                uint64_t v123 = 0;
                goto LABEL_125;
              }
LABEL_124:
              *(void *)long long buf = a4;
              *(void *)&uint8_t buf[8] = "kRegistrationVictimFreq";
              sub_100048BAC((uint64_t)buf, &cf1);
              long long v84 = xpc::dyn_cast_or_default((xpc *)&cf1, 0, v83);
              xpc_release((xpc_object_t)cf1);
              *(void *)long long buf = a4;
              *(void *)&uint8_t buf[8] = "kRegistrationBandwidth";
              sub_100048BAC((uint64_t)buf, &cf1);
              uint64_t v86 = xpc::dyn_cast_or_default((xpc *)&cf1, 0, v85);
              xpc_release((xpc_object_t)cf1);
              *(void *)long long buf = a4;
              *(void *)&uint8_t buf[8] = "kRegistrationPriority";
              sub_100048BAC((uint64_t)buf, &cf1);
              xpc_object_t v88 = xpc::dyn_cast_or_default((xpc *)&cf1, 0, v87);
              xpc_release((xpc_object_t)cf1);
              xpc_object_t v89 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v81 + 32);
              xpc_object_t v90 = v81;
              uint64_t v27 = v117;
              v89(v90, v62, v84, v86, v88);
LABEL_125:
              if ((v82 & 1) == 0) {
                sub_10004D2C8(v80);
              }
LABEL_127:
              if (!xpc_dictionary_get_value(*a4, "kRegistrationRemove")) {
                goto LABEL_142;
              }
              char v91 = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
              unsigned int v92 = v91;
              if (v93 < 0)
              {
                __int16 v94 = (unsigned __int8 *)(v93 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v95 = 5381;
                do
                {
                  int64_t v93 = v95;
                  std::string v96 = *v94++;
                  uint64_t v95 = (33 * v95) ^ v96;
                }
                while (v96);
              }
              std::mutex::lock(v91);
              *(void *)long long buf = v93;
              unsigned int v97 = sub_10004D37C(&v92[1].__m_.__sig, (unint64_t *)buf);
              if (v97)
              {
                uint64_t v99 = v97[3];
                std::string v98 = (std::__shared_weak_count *)v97[4];
                if (v98)
                {
                  atomic_fetch_add_explicit(&v98->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v92);
                  atomic_fetch_add_explicit(&v98->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v98);
                  CFTypeRef v100 = 0;
                  if (!v99)
                  {
LABEL_134:
                    uint64_t v121 = xpc_int64_create(45);
                    uint64_t v27 = v117;
                    if (!v121) {
                      uint64_t v121 = xpc_null_create();
                    }
                    *(void *)long long buf = *a5;
                    *(void *)&uint8_t buf[8] = "kPosixError";
                    sub_100035E70((uint64_t)buf, &v121, &v122);
                    xpc_release(v122);
                    uint64_t v122 = 0;
                    xpc_release(v121);
                    uint64_t v121 = 0;
                    goto LABEL_140;
                  }
LABEL_139:
                  *(void *)long long buf = a4;
                  *(void *)&uint8_t buf[8] = "kRegistrationVictimFreq";
                  sub_100048BAC((uint64_t)buf, &cf1);
                  CFTypeID v102 = xpc::dyn_cast_or_default((xpc *)&cf1, 0, v101);
                  xpc_release((xpc_object_t)cf1);
                  long long v103 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v99 + 40);
                  long long v104 = v99;
                  uint64_t v27 = v117;
                  v103(v104, v62, v102);
LABEL_140:
                  if ((v100 & 1) == 0) {
                    sub_10004D2C8(v98);
                  }
LABEL_142:
                  if (!xpc_dictionary_get_value(*a4, "kRegistrationBlockBBFreqReport")) {
                    goto LABEL_157;
                  }
                  long long v105 = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
                  uint64_t v106 = v105;
                  if (v107 < 0)
                  {
                    CFTypeID v108 = (unsigned __int8 *)(v107 & 0x7FFFFFFFFFFFFFFFLL);
                    CFDictionaryRef v109 = 5381;
                    do
                    {
                      uint64_t v107 = v109;
                      int v110 = *v108++;
                      CFDictionaryRef v109 = (33 * v109) ^ v110;
                    }
                    while (v110);
                  }
                  std::mutex::lock(v105);
                  *(void *)long long buf = v107;
                  uint64_t v111 = sub_10004D37C(&v106[1].__m_.__sig, (unint64_t *)buf);
                  if (v111)
                  {
                    int v113 = v111[3];
                    unsigned int v112 = (std::__shared_weak_count *)v111[4];
                    if (v112)
                    {
                      atomic_fetch_add_explicit(&v112->__shared_owners_, 1uLL, memory_order_relaxed);
                      std::mutex::unlock(v106);
                      atomic_fetch_add_explicit(&v112->__shared_owners_, 1uLL, memory_order_relaxed);
                      sub_10004D2C8(v112);
                      CFTypeRef v114 = 0;
                      if (!v113)
                      {
LABEL_149:
                        uint64_t v119 = xpc_int64_create(45);
                        if (!v119) {
                          uint64_t v119 = xpc_null_create();
                        }
                        *(void *)long long buf = *a5;
                        *(void *)&uint8_t buf[8] = "kPosixError";
                        sub_100035E70((uint64_t)buf, &v119, &v120);
                        xpc_release(v120);
                        uint64_t v120 = 0;
                        xpc_release(v119);
                        uint64_t v119 = 0;
                        goto LABEL_155;
                      }
LABEL_154:
                      *(void *)long long buf = a4;
                      *(void *)&uint8_t buf[8] = "kRegistrationBlockBBFreqReport";
                      sub_100048BAC((uint64_t)buf, &cf1);
                      CFIndex v116 = xpc::dyn_cast_or_default((xpc *)&cf1, 0, v115);
                      xpc_release((xpc_object_t)cf1);
                      (*(void (**)(uint64_t, uint64_t))(*(void *)v113 + 64))(v113, v116);
LABEL_155:
                      if ((v114 & 1) == 0) {
                        sub_10004D2C8(v112);
                      }
LABEL_157:
                      if (!v27) {
                        return;
                      }
                      goto LABEL_158;
                    }
                  }
                  else
                  {
                    int v113 = 0;
                  }
                  std::mutex::unlock(v106);
                  unsigned int v112 = 0;
                  CFTypeRef v114 = 1;
                  if (!v113) {
                    goto LABEL_149;
                  }
                  goto LABEL_154;
                }
              }
              else
              {
                uint64_t v99 = 0;
              }
              std::mutex::unlock(v92);
              std::string v98 = 0;
              CFTypeRef v100 = 1;
              if (!v99) {
                goto LABEL_134;
              }
              goto LABEL_139;
            }
          }
          else
          {
            long long v81 = 0;
          }
          std::mutex::unlock(v74);
          long long v80 = 0;
          long long v82 = 1;
          if (!v81) {
            goto LABEL_115;
          }
          goto LABEL_124;
        }
      }
      else
      {
        long long v71 = 0;
      }
      std::mutex::unlock(v64);
      long long v70 = 0;
      long long v72 = 1;
      goto LABEL_105;
    }
LABEL_85:
    sub_10004D2C8(v54);
    goto LABEL_86;
  }
  cf1 = 0;
  *(void *)long long buf = a4;
  *(void *)&uint8_t buf[8] = "kTelephonyCapability";
  sub_100048BAC((uint64_t)buf, &object);
  xpc::bridge((uint64_t *)&cf, (xpc *)&object, v36);
  sub_100056248(&cf1, &cf);
  sub_1000577C4(&cf);
  xpc_release(object);
  *(void *)long long buf = a4;
  *(void *)&uint8_t buf[8] = "kTelephonyCapabilityStatus";
  sub_100048BAC((uint64_t)buf, &cf);
  uint64_t v38 = xpc::dyn_cast_or_default((xpc *)&cf, 0, v37);
  xpc_release((xpc_object_t)cf);
  CFTypeRef cf = 0;
  *(void *)long long buf = a4;
  *(void *)&uint8_t buf[8] = "kTelephonyCapabilityInformation";
  sub_100048BAC((uint64_t)buf, &v133);
  xpc::bridge((uint64_t *)&object, (xpc *)&v133, v39);
  sub_10004EFE4(&cf, (CFTypeRef *)&object);
  sub_1000577C4((const void **)&object);
  xpc_release(v133);
  if (cf1) {
    char v40 = sub_1000810B8;
  }
  else {
    char v40 = 0;
  }
  if (!v40) {
    goto LABEL_72;
  }
  if (CFEqual(cf1, kCTCapabilityAgent))
  {
    uint64_t v130 = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t, const void **))(*(void *)v26 + 32))(v26, 2, v38, &v130);
    sub_100057D78(&v130);
  }
  if (!CFEqual(cf1, kCTCapabilityAgent2))
  {
LABEL_72:
    sub_100057D78(&cf);
    sub_1000558F4(&cf1);
    goto LABEL_73;
  }
  if (v26)
  {
    *(void *)long long buf = a4;
    *(void *)&uint8_t buf[8] = "kTelephonyCapabilityStatus";
    sub_100048BAC((uint64_t)buf, &object);
    uint64_t v42 = xpc::dyn_cast_or_default((xpc *)&object, 0, v41);
    xpc_release(object);
    sub_1002BBBAC();
    BOOL v43 = qword_101B0CAF0;
    if (os_log_type_enabled((os_log_t)qword_101B0CAF0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v44 = "OFF";
      if (v42) {
        uint64_t v44 = "ON";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v44;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I WiFiCalling Set %s", buf, 0xCu);
    }
    CFArrayRef v129 = cf;
    if (cf) {
      CFRetain(cf);
    }
    (*(void (**)(uint64_t, void, uint64_t, CFTypeRef *))(*(void *)v26 + 32))(v26, 0, v42, &v129);
    sub_100057D78(&v129);
    goto LABEL_72;
  }
  sub_100057D78(&cf);
LABEL_161:
  sub_1000558F4(&cf1);
  if (!v27) {
    return;
  }
LABEL_158:
  sub_10004D2C8(v27);
}

void sub_1002B7C94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,xpc_object_t a35,xpc_object_t object,xpc_object_t a37,xpc_object_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B805C()
{
}

void sub_1002B8068(Registry **a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v24 = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v24);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_11:
    std::mutex::unlock(v8);
    unsigned int v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v15 = v13[3];
  unsigned int v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15)
  {
LABEL_7:
    xpc_object_t v20 = xpc_int64_create(45);
    if (!v20) {
      xpc_object_t v20 = xpc_null_create();
    }
    unint64_t v24 = *a5;
    unsigned int v25 = "kPosixError";
    sub_100035E70((uint64_t)&v24, &v20, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v20);
    xpc_object_t v20 = 0;
    goto LABEL_16;
  }
LABEL_12:
  unint64_t v24 = a4;
  unsigned int v25 = "kNetworkTimeFetchRequestType";
  sub_100048BAC((uint64_t)&v24, &v26);
  uint64_t v18 = xpc::dyn_cast_or_default((xpc *)&v26, 0, v17);
  xpc_release(v26);
  unsigned __int8 v19 = (std::__shared_weak_count *)a5[1];
  unint64_t v22 = *a5;
  uint64_t v23 = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, unint64_t *))(*(void *)v15 + 64))(v15, v18, &v22);
  if (v23) {
    sub_10004D2C8(v23);
  }
LABEL_16:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1002B823C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B8284(Registry **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  int v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  v17[0] = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, v17);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_9:
    std::mutex::unlock(v6);
    unsigned int v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  unsigned int v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (v13)
  {
LABEL_10:
    v17[0] = a4;
    v17[1] = (unint64_t)"kValidityPeriod";
    sub_100048BAC((uint64_t)v17, &object);
    uint64_t v16 = xpc::dyn_cast_or_default((xpc *)&object, 0, v15);
    xpc_release(object);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 72))(v13, v16);
  }
LABEL_11:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_1002B83C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B83FC(Registry **a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  long long v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v11 = v3;
  unint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v11);
  if (!v7)
  {
    uint64_t v9 = 0;
LABEL_9:
    std::mutex::unlock(v2);
    uint64_t v8 = 0;
    char v10 = 1;
    if (!v9) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v9 = (RegistrationInterface *)v7[3];
  uint64_t v8 = (std::__shared_weak_count *)v7[4];
  if (!v8) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v2);
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  char v10 = 0;
  if (v9) {
LABEL_10:
  }
    RegistrationInterface::fetchNetworkList(v9);
LABEL_11:
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
}

void sub_1002B84E4(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B8504(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  *(void *)&long long v20 = 4096;
  if (IsTelephonyRunningExtended(&v20))
  {
    xpc_connection_t remote_connection = xpc_dictionary_get_remote_connection(*a4);
    xpc_object_t v8 = remote_connection;
    if (remote_connection) {
      xpc_retain(remote_connection);
    }
    else {
      xpc_object_t v8 = xpc_null_create();
    }
    long long v20 = 0uLL;
    uint64_t v21 = 0;
    v18[0] = a4;
    v18[1] = "kRegistrationAssertionName";
    sub_100048BAC((uint64_t)v18, &object);
    sub_100058DB0(&buf, "<no name>");
    xpc::dyn_cast_or_default();
    if (v23 < 0) {
      operator delete((void *)buf);
    }
    xpc_release(object);
    sub_1002BBBAC();
    uint64_t v9 = qword_101B0CAF0;
    if (os_log_type_enabled((os_log_t)qword_101B0CAF0, OS_LOG_TYPE_DEFAULT))
    {
      char v10 = &v20;
      if (v21 < 0) {
        char v10 = (long long *)v20;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s is adding a registration notifications to be turned on during low power mode", (uint8_t *)&buf, 0xCu);
    }
    sub_100058DB0(v16, "reg");
    xpc_object_t v15 = v8;
    if (v8) {
      xpc_retain(v8);
    }
    else {
      xpc_object_t v15 = xpc_null_create();
    }
    if (SHIBYTE(v21) < 0)
    {
      sub_10004FC84(__p, (void *)v20, *((unint64_t *)&v20 + 1));
    }
    else
    {
      *(_OWORD *)long long __p = v20;
      uint64_t v14 = v21;
    }
    sub_100C641C0((long long *)v16, &v15, (long long *)__p);
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v15);
    xpc_object_t v15 = 0;
    if (v17 < 0) {
      operator delete(v16[0]);
    }
    xpc_object_t v11 = xpc_BOOL_create(1);
    if (!v11) {
      xpc_object_t v11 = xpc_null_create();
    }
    *(void *)&long long buf = *a5;
    *((void *)&buf + 1) = "kRegistrationAddNotificationAssertion";
    sub_100035E70((uint64_t)&buf, &v11, &v12);
    xpc_release(v12);
    xpc_object_t v12 = 0;
    xpc_release(v11);
    xpc_object_t v11 = 0;
    if (SHIBYTE(v21) < 0) {
      operator delete((void *)v20);
    }
    xpc_release(v8);
  }
}

void sub_1002B8750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, xpc_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,xpc_object_t a27)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1002B882C(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    xpc_object_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  CFMutableArrayRef v91 = (CFMutableArrayRef)v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v91);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_9:
    std::mutex::unlock(v9);
    xpc_object_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_38;
    }
    goto LABEL_10;
  }
  uint64_t v16 = (RegistrationInterface *)v14[3];
  xpc_object_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (!v16) {
    goto LABEL_38;
  }
LABEL_10:
  if (xpc_dictionary_get_value(*a4, "kRegistrationStatus"))
  {
    int RegistrationStatus = RegistrationInterface::getRegistrationStatus(v16);
    xpc_object_t v93 = xpc_int64_create(RegistrationStatus);
    if (!v93) {
      xpc_object_t v93 = xpc_null_create();
    }
    CFMutableArrayRef v91 = *(CFMutableArrayRef *)a5;
    unsigned int v92 = (std::__shared_weak_count *)"kRegistrationStatus";
    sub_100035E70((uint64_t)&v91, &v93, &v94);
    xpc_release(v94);
    xpc_object_t v94 = 0;
    xpc_release(v93);
    xpc_object_t v93 = 0;
  }
  if (xpc_dictionary_get_value(*a4, "kRegistrationDisplayStatus"))
  {
    int RegistrationDisplayStatus = RegistrationInterface::getRegistrationDisplayStatus(v16);
    xpc_object_t object = xpc_int64_create(RegistrationDisplayStatus);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    CFMutableArrayRef v91 = *(CFMutableArrayRef *)a5;
    unsigned int v92 = (std::__shared_weak_count *)"kRegistrationDisplayStatus";
    sub_100035E70((uint64_t)&v91, &object, &v90);
    xpc_release(v90);
    xpc_object_t v90 = 0;
    xpc_release(object);
    xpc_object_t object = 0;
  }
  if (xpc_dictionary_get_value(*a4, "kRegistrationIsForcedRegisteredHome"))
  {
    char v20 = (*(uint64_t (**)(RegistrationInterface *))(*(void *)v16 + 240))(v16);
    xpc_object_t v87 = xpc_BOOL_create(v20);
    if (!v87) {
      xpc_object_t v87 = xpc_null_create();
    }
    CFMutableArrayRef v91 = *(CFMutableArrayRef *)a5;
    unsigned int v92 = (std::__shared_weak_count *)"kRegistrationIsForcedRegisteredHome";
    sub_100035E70((uint64_t)&v91, &v87, &v88);
    xpc_release(v88);
    xpc_object_t v88 = 0;
    xpc_release(v87);
    xpc_object_t v87 = 0;
  }
  if (xpc_dictionary_get_value(*a4, "kRegistrationIsInHomeCountry"))
  {
    uint64_t v21 = (std::mutex *)Registry::getServiceMap(*a1);
    unint64_t v22 = v21;
    if (v23 < 0)
    {
      unint64_t v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        uint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(v21);
    CFMutableArrayRef v91 = (CFMutableArrayRef)v23;
    uint64_t v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)&v91);
    if (v27)
    {
      uint64_t v29 = v27[3];
      uint64_t v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
        if (!v29)
        {
LABEL_36:
          if ((v30 & 1) == 0) {
            sub_10004D2C8(v28);
          }
          goto LABEL_38;
        }
LABEL_32:
        char v31 = *(std::__shared_weak_count **)(a5 + 8);
        v85[1] = *(xpc_object_t *)a5;
        uint64_t v86 = v31;
        if (v31) {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        RoamingInterface::isInHomeCountry();
        if (v86) {
          sub_10004D2C8(v86);
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    uint64_t v28 = 0;
    char v30 = 1;
    if (!v29) {
      goto LABEL_36;
    }
    goto LABEL_32;
  }
LABEL_38:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  CFMutableArrayRef v91 = 0;
  unsigned int v92 = 0;
  sub_100068A94(&v91);
  if (v91)
  {
    if (xpc_dictionary_get_value(*a4, "kRegistrationCampOnly"))
    {
      char v32 = (*(uint64_t (**)(CFMutableArrayRef, uint64_t))(*(void *)v91 + 384))(v91, 6);
      xpc_object_t v84 = xpc_BOOL_create(v32);
      if (!v84) {
        xpc_object_t v84 = xpc_null_create();
      }
      theArray[0] = *(CFMutableArrayRef *)a5;
      theArray[1] = (CFMutableArrayRef)"kRegistrationCampOnly";
      sub_100035E70((uint64_t)theArray, &v84, v85);
      xpc_release(v85[0]);
      v85[0] = 0;
      xpc_release(v84);
      xpc_object_t v84 = 0;
    }
  }
  else
  {
    sub_1002BBBAC();
    uint64_t v33 = qword_101B0CAF0;
    if (os_log_type_enabled((os_log_t)qword_101B0CAF0, OS_LOG_TYPE_ERROR))
    {
      LOWORD(theArray[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Could not get RadioModule", (uint8_t *)theArray, 2u);
    }
  }
  if (v92) {
    sub_10004D2C8(v92);
  }
  if (xpc_dictionary_get_value(*a4, "kRegistrationAgentStatus"))
  {
    char v82 = 0;
    unsigned int v81 = 0;
    char v80 = 0;
    int v79 = 2;
    xpc_object_t v34 = (std::mutex *)Registry::getServiceMap(*a1);
    uint64_t v35 = v34;
    if (v36 < 0)
    {
      long long v37 = (unsigned __int8 *)(v36 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v38 = 5381;
      do
      {
        uint64_t v36 = v38;
        unsigned int v39 = *v37++;
        uint64_t v38 = (33 * v38) ^ v39;
      }
      while (v39);
    }
    std::mutex::lock(v34);
    CFMutableArrayRef v91 = (CFMutableArrayRef)v36;
    char v40 = sub_10004D37C(&v35[1].__m_.__sig, (unint64_t *)&v91);
    if (v40)
    {
      uint64_t v42 = v40[3];
      BOOL v41 = (std::__shared_weak_count *)v40[4];
      if (v41)
      {
        atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v35);
        atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v41);
        char v43 = 0;
        if (!v42)
        {
LABEL_60:
          if ((v43 & 1) == 0) {
            sub_10004D2C8(v41);
          }
          if (v82)
          {
            int v44 = v81 & 1;
            int v45 = (v81 >> 1) & 1;
LABEL_77:
            theArray[0] = 0;
            CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            theArray[0] = Mutable;
            if (Mutable) {
              unsigned int v58 = sub_100289354;
            }
            else {
              unsigned int v58 = 0;
            }
            if (v58)
            {
              if (v44)
              {
                CFArrayAppendValue(Mutable, kCTRegistrationIStatus2);
                CFArrayRef Mutable = theArray[0];
              }
              if (v45)
              {
                CFArrayAppendValue(Mutable, kCTRegistrationIStatus1);
                CFArrayRef Mutable = theArray[0];
              }
              ctu::cf_to_xpc((uint64_t *)&v77, Mutable, v57);
              CFMutableArrayRef v91 = *(CFMutableArrayRef *)a5;
              unsigned int v92 = (std::__shared_weak_count *)"kRegistrationAgentStatus";
              sub_100035E70((uint64_t)&v91, &v77, &v78);
              xpc_release(v78);
              xpc_object_t v78 = 0;
              xpc_release(v77);
              xpc_object_t v77 = 0;
            }
            sub_1000440D4((const void **)theArray);
            goto LABEL_87;
          }
          uint64_t v46 = (std::mutex *)Registry::getServiceMap(*a1);
          xpc_object_t v47 = v46;
          if (v48 < 0)
          {
            uint64_t v49 = (unsigned __int8 *)(v48 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v50 = 5381;
            do
            {
              uint64_t v48 = v50;
              unsigned int v51 = *v49++;
              uint64_t v50 = (33 * v50) ^ v51;
            }
            while (v51);
          }
          std::mutex::lock(v46);
          CFMutableArrayRef v91 = (CFMutableArrayRef)v48;
          long long v52 = sub_10004D37C(&v47[1].__m_.__sig, (unint64_t *)&v91);
          if (v52)
          {
            uint64_t v54 = v52[3];
            xpc_object_t v53 = (std::__shared_weak_count *)v52[4];
            if (v53)
            {
              atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v47);
              atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v53);
              char v55 = 0;
              if (!v54) {
                goto LABEL_70;
              }
              goto LABEL_74;
            }
          }
          else
          {
            uint64_t v54 = 0;
          }
          std::mutex::unlock(v47);
          xpc_object_t v53 = 0;
          char v55 = 1;
          if (!v54)
          {
LABEL_70:
            int v45 = 0;
            if (v55) {
              goto LABEL_76;
            }
            goto LABEL_75;
          }
LABEL_74:
          int v45 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v54 + 232))(v54, 1);
          if (v55)
          {
LABEL_76:
            int v44 = 0;
            goto LABEL_77;
          }
LABEL_75:
          sub_10004D2C8(v53);
          goto LABEL_76;
        }
LABEL_59:
        (*(void (**)(uint64_t, char *, unsigned int *, char *, int *, uint64_t))(*(void *)v42 + 248))(v42, &v82, &v81, &v80, &v79, 1);
        goto LABEL_60;
      }
    }
    else
    {
      uint64_t v42 = 0;
    }
    std::mutex::unlock(v35);
    BOOL v41 = 0;
    char v43 = 1;
    if (!v42) {
      goto LABEL_60;
    }
    goto LABEL_59;
  }
LABEL_87:
  if (!xpc_dictionary_get_value(*a4, "kRegistrationIMSContext")) {
    return;
  }
  LOBYTE(v79) = 0;
  LODWORD(theArray[0]) = 0;
  char v82 = 0;
  unsigned int v81 = 2;
  BOOL v59 = (std::mutex *)Registry::getServiceMap(*a1);
  int v60 = v59;
  if (v61 < 0)
  {
    uint64_t v62 = (unsigned __int8 *)(v61 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v63 = 5381;
    do
    {
      uint64_t v61 = v63;
      unsigned int v64 = *v62++;
      uint64_t v63 = (33 * v63) ^ v64;
    }
    while (v64);
  }
  std::mutex::lock(v59);
  CFMutableArrayRef v91 = (CFMutableArrayRef)v61;
  uint64_t v65 = sub_10004D37C(&v60[1].__m_.__sig, (unint64_t *)&v91);
  if (v65)
  {
    uint64_t v67 = v65[3];
    uint64_t v66 = (std::__shared_weak_count *)v65[4];
    if (v66)
    {
      atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v60);
      atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v66);
      char v69 = 0;
      if (!v67) {
        goto LABEL_98;
      }
      goto LABEL_97;
    }
  }
  else
  {
    uint64_t v67 = 0;
  }
  std::mutex::unlock(v60);
  uint64_t v66 = 0;
  char v69 = 1;
  if (v67) {
LABEL_97:
  }
    (*(void (**)(uint64_t, int *, CFMutableArrayRef *, char *, unsigned int *, uint64_t))(*(void *)v67 + 248))(v67, &v79, theArray, &v82, &v81, 1);
LABEL_98:
  if ((v69 & 1) == 0) {
    sub_10004D2C8(v66);
  }
  if ((_BYTE)v79)
  {
    if (v82) {
      long long v70 = (ctu **)&kCTRegistrationIMSContextWiFi;
    }
    else {
      long long v70 = (ctu **)&kCTRegistrationIMSContextCellular;
    }
    long long v71 = (ctu **)&kCTRegistrationIMSTransportTypeWiFi;
    if (v81 != 1) {
      long long v71 = (ctu **)&kCTRegistrationIMSTransportTypeCellular;
    }
    ctu::cf_to_xpc((uint64_t *)&v75, *v71, v68);
    CFMutableArrayRef v91 = *(CFMutableArrayRef *)a5;
    unsigned int v92 = (std::__shared_weak_count *)"kRegistrationIMSTransportType";
    sub_100035E70((uint64_t)&v91, &v75, &v76);
    xpc_release(v76);
    xpc_object_t v76 = 0;
    xpc_release(v75);
    long long v72 = *v70;
    xpc_object_t v75 = 0;
  }
  else
  {
    long long v72 = (ctu *)@"None";
  }
  ctu::cf_to_xpc((uint64_t *)&v73, v72, v68);
  CFMutableArrayRef v91 = *(CFMutableArrayRef *)a5;
  unsigned int v92 = (std::__shared_weak_count *)"kRegistrationIMSContext";
  sub_100035E70((uint64_t)&v91, &v73, &v74);
  xpc_release(v74);
  xpc_object_t v74 = 0;
  xpc_release(v73);
}