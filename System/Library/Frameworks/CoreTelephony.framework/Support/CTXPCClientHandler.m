@interface CTXPCClientHandler
- (BOOL)_hasPublicCellularPlanEntitlement:(id)a3;
- (BOOL)hasEntitlement:(int)a3;
- (BOOL)isLinkedOnOrAfterVersion:(id)a3;
- (BOOL)restrictedPublicCarrierInfoKeys;
- (CTXPCClientHandler)initWithRegistry:(const void *)a3 queue:(queue)a4 connection:(id)a5;
- (CTXPCClientHandlerDelegate)delegate;
- (CTXPCDataProviderInterface)dataProviderDelegate;
- (NSString)sdkVersion;
- (NSXPCConnection)connection;
- (id).cxx_construct;
- (id)validateParametersWithContext:(id)a3 keys:(id)a4 bundleType:(id)a5 personalityInfo:(void *)a6 slot:(int *)a7;
- (optional<PhoneServicesType>)serviceFromCFName:(id)a3;
- (shared_ptr<const)registry;
- (void)SIMUnlockProcedureDidComplete;
- (void)_isAutofilleSIMIdAllowedForDomain:(id)a3 applicationIdentifier:(id)a4 completion:(id)a5;
- (void)acknowledgeIncomingMessages:(id)a3 withMessageIDList:(id)a4 completion:(id)a5;
- (void)activateProximityTransfer:(unint64_t)a3 completion:(id)a4;
- (void)activateStewieEmergencyTryOutWithCompletion:(id)a3;
- (void)activateTurboMode:(id)a3;
- (void)addDedicatedBearer:(id)a3 completion:(id)a4;
- (void)addLowLatencyFilter:(id)a3 pdp:(int)a4 queueSetId:(unint64_t)a5 uplink:(BOOL)a6 completion:(id)a7;
- (void)addParticipants:(id)a3 toGroupChat:(id)a4 withParticipantsToAdd:(id)a5 withOperationID:(id)a6 completion:(id)a7;
- (void)addPlanWith:(id)a3 appName:(id)a4 appType:(unint64_t)a5 completionHandler:(id)a6;
- (void)addPlanWith:(id)a3 completionHandler:(id)a4;
- (void)addQRCodePlanWith:(id)a3 appName:(id)a4 appType:(unint64_t)a5 completionHandler:(id)a6;
- (void)authenticate:(id)a3 request:(id)a4 completion:(id)a5;
- (void)automaticallySelectNetwork:(id)a3 completion:(id)a4;
- (void)billingCycleEndDatesForLastPeriods:(unint64_t)a3 completion:(id)a4;
- (void)bootstrapPlanTransferForEndpoint:(unint64_t)a3 usingMessageSession:(id)a4 completion:(id)a5;
- (void)canRunActivationCodeProvisioningWithCompletion:(id)a3;
- (void)cancelCellularPlanTransfer:(id)a3 fromDevice:(id)a4 keepCache:(BOOL)a5 completionHandler:(id)a6;
- (void)cancelSIMToolkitUSSDSessionForContext:(id)a3 completion:(id)a4;
- (void)changeIcon:(id)a3 forGroupChat:(id)a4 withNewIcon:(id)a5 withOperationID:(id)a6 completion:(id)a7;
- (void)changePIN:(id)a3 oldPin:(id)a4 newPin:(id)a5 completion:(id)a6;
- (void)changeSubject:(id)a3 forGroupChat:(id)a4 withNewSubject:(id)a5 withOperationID:(id)a6 completion:(id)a7;
- (void)checkCellularDiagnosticsStatus:(id)a3;
- (void)checkEmbeddedSimHealthWithCompletion:(id)a3;
- (void)checkForUpdatedBundlesWithAutoInstall:(BOOL)a3 completion:(id)a4;
- (void)checkPreFlightEligibility:(id)a3 mccs:(id)a4 mncs:(id)a5 gid1s:(id)a6 gid2s:(id)a7 smdpUrl:(id)a8 iccidPrefix:(id)a9 completion:(id)a10;
- (void)checkProfileEligibility:(id)a3 metadata:(id)a4 completion:(id)a5;
- (void)checkRadioBootHealth:(id)a3;
- (void)clearUserEnteredBillingEndDayOfMonth:(id)a3 completion:(id)a4;
- (void)clearUserEnteredMonthlyBudget:(id)a3 completion:(id)a4;
- (void)clearUserEnteredMonthlyRoamingBudget:(id)a3 completion:(id)a4;
- (void)compressWithStewieCodec:(id)a3 completion:(id)a4;
- (void)context:(id)a3 addPhoneServicesDevice:(id)a4 withCompletion:(id)a5;
- (void)context:(id)a3 canSetCapability:(id)a4 completion:(id)a5;
- (void)context:(id)a3 getAttachApnSettingsWithCompletion:(id)a4;
- (void)context:(id)a3 getCapability:(id)a4 completion:(id)a5;
- (void)context:(id)a3 getPhoneNumberSignatureWithCompletion:(id)a4;
- (void)context:(id)a3 getPseudoIdentityFor:(id)a4 completion:(id)a5;
- (void)context:(id)a3 getSystemCapabilities:(id)a4;
- (void)context:(id)a3 isMandatoryDisabledVoLTE:(id)a4;
- (void)context:(id)a3 isProtectedIdentitySupported:(id)a4 completion:(id)a5;
- (void)context:(id)a3 mandatoryDisableVoLTE:(BOOL)a4 withCompletion:(id)a5;
- (void)context:(id)a3 modifyAttachApnSettings:(id)a4 completion:(id)a5;
- (void)context:(id)a3 recheckPhoneServicesAccountStatus:(id)a4 completion:(id)a5;
- (void)context:(id)a3 removePhoneServicesDevice:(id)a4 withCompletion:(id)a5;
- (void)context:(id)a3 resetPhoneNumber:(id)a4;
- (void)context:(id)a3 setCapability:(id)a4 enabled:(BOOL)a5 info:(id)a6 completion:(id)a7;
- (void)context:(id)a3 supportedIdentityProtectionFor:(id)a4 completion:(id)a5;
- (void)convertPhysicalToeSIMWithCompletionHandler:(id)a3;
- (void)copyAbbreviatedOperatorName:(id)a3 completion:(id)a4;
- (void)copyBandInfo:(id)a3 completion:(id)a4;
- (void)copyBundleIdentifier:(id)a3 bundleType:(id)a4 completion:(id)a5;
- (void)copyBundleLocation:(id)a3 bundleType:(id)a4 completion:(id)a5;
- (void)copyBundleVersion:(id)a3 bundleType:(id)a4 completion:(id)a5;
- (void)copyCarrierBookmarks:(id)a3 completion:(id)a4;
- (void)copyCarrierBundleLocation:(id)a3 completion:(id)a4;
- (void)copyCarrierBundleValue:(id)a3 key:(id)a4 bundleType:(id)a5 completion:(id)a6;
- (void)copyCarrierBundleValue:(id)a3 keyHierarchy:(id)a4 bundleType:(id)a5 completion:(id)a6;
- (void)copyCarrierBundleValueWithCountryBundleLookup:(id)a3 keyHierarchy:(id)a4 matchingInfo:(id)a5 completion:(id)a6;
- (void)copyCarrierBundleValueWithDefault:(id)a3 key:(id)a4 bundleType:(id)a5 completion:(id)a6;
- (void)copyCarrierBundleValueWithDefault:(id)a3 keyHierarchy:(id)a4 bundleType:(id)a5 completion:(id)a6;
- (void)copyCarrierBundleValues:(id)a3 keyHierarchies:(id)a4 defaultValues:(id)a5 bundleType:(id)a6 withFallbackBundleCheck:(BOOL)a7 completion:(id)a8;
- (void)copyCarrierBundleValues:(id)a3 keys:(id)a4 defaultValues:(id)a5 bundleType:(id)a6 withFallbackBundleCheck:(BOOL)a7 completion:(id)a8;
- (void)copyCarrierBundleVersion:(id)a3 completion:(id)a4;
- (void)copyCellId:(id)a3 completion:(id)a4;
- (void)copyCellInfo:(id)a3 completion:(id)a4;
- (void)copyEmergencyMode:(id)a3;
- (void)copyFirmwareUpdateInfo:(id)a3;
- (void)copyGid1:(id)a3 completion:(id)a4;
- (void)copyGid2:(id)a3 completion:(id)a4;
- (void)copyIsDataAttached:(id)a3 completion:(id)a4;
- (void)copyIsInHomeCountry:(id)a3 completion:(id)a4;
- (void)copyLabel:(id)a3 completion:(id)a4;
- (void)copyLastKnownMobileCountryCode:(id)a3 completion:(id)a4;
- (void)copyLastKnownMobileSubscriberCountryCode:(id)a3 completion:(id)a4;
- (void)copyLocalizedOperatorName:(id)a3 completion:(id)a4;
- (void)copyLocationAreaCode:(id)a3 completion:(id)a4;
- (void)copyMccOrPlmnsListForIso3CountryCode:(id)a3 completion:(id)a4;
- (void)copyMobileCountryCode:(id)a3 completion:(id)a4;
- (void)copyMobileEquipmentInfo:(id)a3;
- (void)copyMobileNetworkCode:(id)a3 completion:(id)a4;
- (void)copyMobileSubscriberCountryCode:(id)a3 completion:(id)a4;
- (void)copyMobileSubscriberIdentity:(id)a3 completion:(id)a4;
- (void)copyMobileSubscriberIso3CountryCode:(id)a3 MNC:(id)a4 completion:(id)a5;
- (void)copyMobileSubscriberIsoCountryCode:(id)a3 completion:(id)a4;
- (void)copyMobileSubscriberIsoSubregionCode:(id)a3 MNC:(id)a4 completion:(id)a5;
- (void)copyMobileSubscriberNetworkCode:(id)a3 completion:(id)a4;
- (void)copyNetworkList:(id)a3 completion:(id)a4;
- (void)copyNetworkSelection:(id)a3 completion:(id)a4;
- (void)copyNetworkSelectionInfo:(id)a3 completion:(id)a4;
- (void)copyNetworkSelectionMode:(id)a3 completion:(id)a4;
- (void)copyOperatorName:(id)a3 completion:(id)a4;
- (void)copyPriVersion:(id)a3 completion:(id)a4;
- (void)copyPublicCellId:(id)a3 completion:(id)a4;
- (void)copyRadioAccessTechnology:(id)a3 completion:(id)a4;
- (void)copyRegistrationDisplayStatus:(id)a3 completion:(id)a4;
- (void)copyRegistrationIMSTransportInfo:(id)a3 completion:(id)a4;
- (void)copyRegistrationStatus:(id)a3 completion:(id)a4;
- (void)copyRejectCauseCode:(id)a3 completion:(id)a4;
- (void)copySIMIdentity:(id)a3 completion:(id)a4;
- (void)copyServingPlmn:(id)a3 completion:(id)a4;
- (void)copyWirelessTechnology:(id)a3 completion:(id)a4;
- (void)create:(id)a3 groupChat:(id)a4 withOperationID:(id)a5 completion:(id)a6;
- (void)createEncryptedIdentity:(id)a3 identity:(id)a4 completion:(id)a5;
- (void)dataUsageForLastPeriods:(unint64_t)a3 completion:(id)a4;
- (void)dataUsageForLastPeriodsOnActivePairedDevice:(unint64_t)a3 completion:(id)a4;
- (void)decodeSuggestionsBase64:(id)a3 withBase64String:(id)a4 completion:(id)a5;
- (void)deleteChat:(id)a3 chat:(id)a4 completion:(id)a5;
- (void)deleteHiddenSims:(id)a3;
- (void)deleteLowLatencyFilter:(id)a3 pdp:(int)a4 queueSetId:(unint64_t)a5 uplink:(BOOL)a6 completion:(id)a7;
- (void)deletePersonalWallet:(id)a3 completion:(id)a4;
- (void)deleteTransferPlansForImei:(id)a3 completion:(id)a4;
- (void)deleteZone:(id)a3 completion:(id)a4;
- (void)disableBusinessMessaging:(id)a3 completion:(id)a4;
- (void)disableLazuli:(id)a3 completion:(id)a4;
- (void)discoverCapabilities:(id)a3 forDestination:(id)a4 completion:(id)a5;
- (void)discoverRemoteCapabilities:(id)a3 forDestination:(id)a4 withOperationID:(id)a5 completion:(id)a6;
- (void)enableBusinessMessaging:(id)a3 completion:(id)a4;
- (void)enableLazuli:(id)a3 completion:(id)a4;
- (void)encryptDataWithCarrierIdentifiers:(id)a3 mnc:(id)a4 gid1:(id)a5 gid2:(id)a6 data:(id)a7 completion:(id)a8;
- (void)endPlanTransferForEndPoint:(unint64_t)a3 completion:(id)a4;
- (void)enterLoopBackMode:(id)a3;
- (void)evaluateMobileSubscriberIdentity:(id)a3 identity:(id)a4 completion:(id)a5;
- (void)exit:(id)a3 groupChat:(id)a4 withOperationID:(id)a5 completion:(id)a6;
- (void)exitStewieWithContext:(id)a3 completion:(id)a4;
- (void)fetchBasebandTicket:(BOOL)a3 withCompletion:(id)a4;
- (void)fetchCallBarringValue:(id)a3 facility:(int)a4 callClass:(int)a5 password:(id)a6 completion:(id)a7;
- (void)fetchCallForwardingValue:(id)a3 reason:(int)a4 callClass:(int)a5 completion:(id)a6;
- (void)fetchCallWaitingValue:(id)a3 callClass:(int)a4 completion:(id)a5;
- (void)fetchCallingLineIdRestrictionValue:(id)a3 completion:(id)a4;
- (void)fetchCallingLinePresentationValue:(id)a3 completion:(id)a4;
- (void)fetchChatBotRenderInformation:(id)a3 forDestination:(id)a4 completion:(id)a5;
- (void)fetchConnectedLineIdRestrictionValue:(id)a3 completion:(id)a4;
- (void)fetchConnectedLinePresentationValue:(id)a3 completion:(id)a4;
- (void)fetchNetworkList:(id)a3 completion:(id)a4;
- (void)fetchPhonebook:(id)a3 completion:(id)a4;
- (void)fetchRemoteCapabilities:(id)a3 forDestination:(id)a4 withOptions:(id)a5 withOperationID:(id)a6 completion:(id)a7;
- (void)fetchRenderInformation:(id)a3 forChatBot:(id)a4 withOperationID:(id)a5 completion:(id)a6;
- (void)fetchRoadsideProvidersWithContext:(id)a3 completion:(id)a4;
- (void)fetchSIMLockValue:(id)a3 completion:(id)a4;
- (void)forceRollAllTransportKeys:(id)a3;
- (void)generateAuthenticationInfoUsingSim:(id)a3 authParams:(id)a4 completion:(id)a5;
- (void)get2GSwitchEnabled:(id)a3;
- (void)get2GUserPreference:(id)a3;
- (void)getActivationPolicyState:(id)a3;
- (void)getActiveConnections:(id)a3 completion:(id)a4;
- (void)getActiveContexts:(id)a3;
- (void)getAllEmergencyNumbers:(id)a3;
- (void)getAnbrActivationState:(id)a3 completion:(id)a4;
- (void)getBandInfo:(id)a3 completion:(id)a4;
- (void)getBasebandRadioFrequencyFrontEndScanData:(id)a3;
- (void)getBootstrapState:(id)a3;
- (void)getCallCapabilities:(id)a3 completion:(id)a4;
- (void)getCameraScanInfoForCardData:(id)a3 completionHandler:(id)a4;
- (void)getCarrierSetupWithCompletion:(id)a3;
- (void)getCellularUsageWorkspaceInfo:(id)a3;
- (void)getConfiguredApns:(id)a3 completion:(id)a4;
- (void)getConnectionAssistantConfig:(id)a3;
- (void)getConnectionAssistantServicePlot:(id)a3;
- (void)getConnectionAssistantState:(id)a3;
- (void)getConnectionAvailability:(id)a3 connectionType:(int)a4 completion:(id)a5;
- (void)getConnectionState:(id)a3 connectionType:(int)a4 completion:(id)a5;
- (void)getCountryBundleIdentifierForCountryCode:(id)a3 completion:(id)a4;
- (void)getCountryBundleLocationForBundleIdentifier:(id)a3 completion:(id)a4;
- (void)getCountryBundleLocationForMatchingInfo:(id)a3 completion:(id)a4;
- (void)getCurrentDataServiceDescriptor:(id)a3;
- (void)getCurrentDataSubscriptionContext:(id)a3;
- (void)getCurrentRat:(id)a3 completion:(id)a4;
- (void)getDataStatus:(id)a3 completion:(id)a4;
- (void)getDescriptorsForDomain:(int64_t)a3 completion:(id)a4;
- (void)getDeviceInfo:(id)a3;
- (void)getDualSimCapability:(id)a3;
- (void)getEOSFirmwareUpdateInfo:(id)a3;
- (void)getEmergencyTextNumbers:(id)a3 completion:(id)a4;
- (void)getEncryptionStatus:(id)a3 completion:(id)a4;
- (void)getEnglishCarrierNameFor:(id)a3 completion:(id)a4;
- (void)getEnhancedVoiceLinkQualityMetric:(id)a3 completion:(id)a4;
- (void)getEosStatus:(id)a3;
- (void)getEuiccData:(id)a3;
- (void)getEvolvedSubscriptionLabelID:(id)a3 withCallback:(id)a4;
- (void)getGSMAUIControlSetting:(id)a3 completion:(id)a4;
- (void)getIMSRegistrationStatus:(id)a3 completion:(id)a4;
- (void)getInternationalDataAccess:(id)a3 completion:(id)a4;
- (void)getLastKnownSimDeactivationInfoFor:(id)a3 completion:(id)a4;
- (void)getListOfPresentDedicatedBearers:(id)a3;
- (void)getLocalDeviceIdentifier:(unint64_t)a3 clientBundleIdentifier:(id)a4 completion:(id)a5;
- (void)getLocalPolicies:(id)a3 completion:(id)a4;
- (void)getLowLatencyFilters:(int)a3 queueSetId:(unint64_t)a4 completion:(id)a5;
- (void)getMaxDataRate:(id)a3 completion:(id)a4;
- (void)getMobileSubscriberHomeCountryList:(id)a3 completion:(id)a4;
- (void)getNATTKeepAliveOverCell:(id)a3 completion:(id)a4;
- (void)getNRStatus:(id)a3 completion:(id)a4;
- (void)getOperatorMultiPartyCallCountMaximum:(id)a3 completion:(id)a4;
- (void)getPNRContext:(id)a3 completion:(id)a4;
- (void)getPacketContextCount:(id)a3;
- (void)getPhoneNumberWithCompletion:(id)a3 completion:(id)a4;
- (void)getPhoneServicesDeviceInfo:(id)a3;
- (void)getPhoneServicesDeviceList:(id)a3;
- (void)getPhonebookEntryCountWithCompletion:(id)a3 completion:(id)a4;
- (void)getPhonebookEntryWithCompletion:(id)a3 atIndex:(int)a4 completion:(id)a5;
- (void)getPlanTransferCredentials:(id)a3 completion:(id)a4;
- (void)getPrefForKey:(id)a3 heirarchy:(id)a4 storage:(id)a5 completion:(id)a6;
- (void)getPreferredDataServiceDescriptor:(id)a3;
- (void)getPreferredDataSubscriptionContext:(id)a3;
- (void)getPrivateNetworkCapabilitiesForContext:(id)a3 completion:(id)a4;
- (void)getPrivateNetworkSimInfoForContext:(id)a3 completion:(id)a4;
- (void)getProvisioningServerURL:(id)a3 completion:(id)a4;
- (void)getProximityTransportSession:(unint64_t)a3 remoteDeviceInfo:(id)a4 completion:(id)a5;
- (void)getPublicDataBearer:(id)a3;
- (void)getPublicNrFrequencyRange:(id)a3;
- (void)getPublicSignalStrength:(id)a3 completion:(id)a4;
- (void)getQoSLinkCharacteristics:(id)a3;
- (void)getRadioPersonality:(id)a3 completion:(id)a4;
- (void)getRatSelection:(id)a3 completion:(id)a4;
- (void)getRatSelectionMask:(id)a3 completion:(id)a4;
- (void)getRemainingPINAttemptCount:(id)a3 completion:(id)a4;
- (void)getRemainingPUKAttemptCount:(id)a3 completion:(id)a4;
- (void)getRemoteDeviceForTransferWithEID:(id)a3 completion:(id)a4;
- (void)getRemoteDevices:(id)a3;
- (void)getRemoteDevicesForTransferWithCompletion:(id)a3;
- (void)getRemotePlanManageAccountInfoFor:(id)a3 completion:(id)a4;
- (void)getRemotePolicies:(id)a3 completion:(id)a4;
- (void)getResumableRoadsideProvider:(id)a3;
- (void)getRoamingStatus:(id)a3 completion:(id)a4;
- (void)getSIMStatus:(id)a3 completion:(id)a4;
- (void)getSIMToolkitListItemsForContext:(id)a3 completion:(id)a4;
- (void)getSIMToolkitMenuForContext:(id)a3 completion:(id)a4;
- (void)getSIMToolkitUSSDStringForContext:(id)a3 completion:(id)a4;
- (void)getSIMTrayStatus:(id)a3;
- (void)getSatelliteMsgCfgToUpdate:(id)a3;
- (void)getShortLabel:(id)a3 completion:(id)a4;
- (void)getSignalStrengthInfo:(id)a3 completion:(id)a4;
- (void)getSignalStrengthMeasurements:(id)a3 completion:(id)a4;
- (void)getSignalStrengthMeasurementsAsync:(id)a3 completion:(id)a4;
- (void)getSimHardwareInfo:(id)a3 completion:(id)a4;
- (void)getSimLabel:(id)a3 completion:(id)a4;
- (void)getSliceTrafficDescriptors:(id)a3;
- (void)getSliceTrafficDescriptorsInfo:(id)a3 connectionType:(int)a4 completion:(id)a5;
- (void)getSmsReadyState:(id)a3 completion:(id)a4;
- (void)getSmscAddress:(id)a3 completion:(id)a4;
- (void)getStewieSupport:(id)a3;
- (void)getSubscriptionInfo:(id)a3;
- (void)getSubscriptionUserFacingName:(id)a3 completion:(id)a4;
- (void)getSupportDynamicDataSimSwitch:(id)a3;
- (void)getSupportedDataRates:(id)a3 completion:(id)a4;
- (void)getSupports5G:(id)a3 completion:(id)a4;
- (void)getSupports5GStandalone:(id)a3 completion:(id)a4;
- (void)getSweetgumApps:(id)a3 completion:(id)a4;
- (void)getSweetgumCapabilities:(id)a3 completion:(id)a4;
- (void)getSweetgumDataPlanMetrics:(id)a3 completion:(id)a4;
- (void)getSweetgumPlans:(id)a3 completion:(id)a4;
- (void)getSweetgumUsage:(id)a3 completion:(id)a4;
- (void)getSweetgumUserConsentInfo:(id)a3 completion:(id)a4;
- (void)getSystemConfiguration:(id)a3 completion:(id)a4;
- (void)getTetheringStatus:(id)a3 connectionType:(int)a4;
- (void)getTransferPlansWithCompletion:(id)a3;
- (void)getTransferType:(id)a3 remoteEid:(id)a4 completion:(id)a5;
- (void)getTransportKeysToUpdate:(id)a3;
- (void)getTypeAllocationCode:(id)a3 completion:(id)a4;
- (void)getUIConfiguredApns:(id)a3 completion:(id)a4;
- (void)getUserAuthToken:(id)a3 completion:(id)a4;
- (void)getUserDefaultVoiceSubscriptionContext:(id)a3;
- (void)getVoiceLinkQualityMetric:(id)a3 completion:(id)a4;
- (void)getVoicemailCallInDetails:(id)a3 completion:(id)a4;
- (void)getVoicemailInfo:(id)a3 completion:(id)a4;
- (void)getWiFiCallingSettingPreferences:(id)a3 key:(id)a4 completion:(id)a5;
- (void)handleTermsAndConditionsCompleted:(id)a3 consented:(BOOL)a4 completion:(id)a5;
- (void)handleUserEnteredOtp:(id)a3 otp:(id)a4 completion:(id)a5;
- (void)handoffTokenWithController:(shared_ptr<CellularPlanController>)a3 completion:(function<void (NSDictionary<NSString *);
- (void)hasDedicatedBearerSupport:(id)a3;
- (void)hiddenTransferPlans:(id)a3;
- (void)hideTransferCellularPlan:(id)a3 fromDevice:(id)a4 completion:(id)a5;
- (void)hideTransferPlan:(id)a3 fromDevice:(id)a4 completion:(id)a5;
- (void)installPendingPlan:(id)a3 completion:(id)a4;
- (void)installPendingPlanList:(id)a3 completion:(id)a4;
- (void)installPrivateNetworkProfile:(id)a3 completion:(id)a4;
- (void)interfaceCostExpensive:(id)a3 completion:(id)a4;
- (void)invalidateCrossPlatformPlanTransfer:(id)a3;
- (void)invalidateProximityTransfer:(unint64_t)a3 force:(BOOL)a4 completion:(id)a5;
- (void)isAnyPlanOfTransferCapability:(unint64_t)a3 availableForThisDeviceWithCompletion:(id)a4;
- (void)isAnyPlanTransferableFromThisDeviceWithCompletion:(id)a3;
- (void)isAnySimReadyWithCompletion:(id)a3;
- (void)isAttachApnSettingAllowed:(id)a3 completion:(id)a4;
- (void)isAutofilleSIMIdAllowedForDomain:(id)a3 bundleIdentifier:(id)a4 completion:(id)a5;
- (void)isAutofilleSIMIdAllowedForDomain:(id)a3 clientBundleIdentifier:(id)a4 completion:(id)a5;
- (void)isDedicatedBearerPresent:(id)a3 completion:(id)a4;
- (void)isEmbeddedSIMOnlyConfig:(id)a3;
- (void)isEmergencyNumber:(id)a3 number:(id)a4 completion:(id)a5;
- (void)isEmergencyNumberWithWhitelistIncluded:(id)a3 number:(id)a4 completion:(id)a5;
- (void)isFactoryDebugEnabled:(id)a3;
- (void)isHighDataModeSupported:(id)a3 completion:(id)a4;
- (void)isNetworkReselectionNeeded:(id)a3 completion:(id)a4;
- (void)isNetworkSelectionMenuAvailable:(id)a3 completion:(id)a4;
- (void)isPNRSupported:(id)a3 completion:(id)a4;
- (void)isPhoneNumberCredentialValid:(id)a3 completion:(id)a4;
- (void)isPrivateNetworkContext:(id)a3 completion:(id)a4;
- (void)isPrivateNetworkEvaluationNeeded:(id)a3;
- (void)isPrivateNetworkPreferredOverWifi:(id)a3 completion:(id)a4;
- (void)isPrivateNetworkSIM:(id)a3 completion:(id)a4;
- (void)isSimMatching:(id)a3 carrierDescriptors:(id)a4 completion:(id)a5;
- (void)isSmartDataModeSupportedWithCompletion:(id)a3;
- (void)isTetheringEditingSupported:(id)a3 completion:(id)a4;
- (void)isUnconditionalCallForwardingActive:(id)a3 completion:(id)a4;
- (void)isVinylTapeSupportedWithCompletion:(id)a3;
- (void)isVinylTestModeEnabledWithCompletion:(id)a3;
- (void)issuePNRRequest:(id)a3 pnrReqType:(id)a4 completion:(id)a5;
- (void)listPersonalWallets:(id)a3;
- (void)loadGSMASettings:(id)a3 state:(BOOL)a4 completion:(id)a5;
- (void)lowDataMode:(id)a3 completion:(id)a4;
- (void)needToLaunchSetUpeSIMWithCompletion:(id)a3;
- (void)overriddenInterfaceCostInexpensiveWithCompletion:(id)a3;
- (void)overridePlanSelection:(id)a3 completion:(id)a4;
- (void)performNetworkAccessFlowIfAllowed:(id)a3 ignoreForeground:(BOOL)a4 completion:(id)a5;
- (void)ping:(id)a3;
- (void)plansPendingCrossPlatformTransferWithCompletion:(id)a3;
- (void)plansPendingInstallWithCompletion:(id)a3;
- (void)prepareCrossPlatformCellularPlanLabel:(id)a3 completion:(id)a4;
- (void)prepareCrossPlatformPlanTransfer:(id)a3 completion:(id)a4;
- (void)privacyProxy:(id)a3 completion:(id)a4;
- (void)promptForSIMUnlock:(id)a3 completion:(id)a4;
- (void)purchaseSweetgumPlan:(id)a3 completion:(id)a4;
- (void)queryAnbrBitrate:(id)a3 bitrate:(id)a4 direction:(int)a5 completion:(id)a6;
- (void)readCachedCapabilities:(id)a3 forDestination:(id)a4 completion:(id)a5;
- (void)readCachedChatBotRenderInformation:(id)a3 forChatBot:(id)a4 completion:(id)a5;
- (void)refreshCellMonitor:(id)a3 completion:(id)a4;
- (void)refreshSweetgumAll:(id)a3 completion:(id)a4;
- (void)refreshSweetgumApps:(id)a3 completion:(id)a4;
- (void)refreshSweetgumPlans:(id)a3 completion:(id)a4;
- (void)refreshSweetgumUsage:(id)a3 completion:(id)a4;
- (void)refreshUserAuthToken:(id)a3 completion:(id)a4;
- (void)registerForNotifications:(id)a3 completion:(id)a4;
- (void)registerSetUpeSIMLaunchedEvent:(id)a3;
- (void)releaseBootstrapService:(id)a3;
- (void)reliableNetworkFallback:(id)a3 completion:(id)a4;
- (void)remotePlanSignupInfoFor:(id)a3 userConsent:(int64_t)a4 completion:(id)a5;
- (void)removeAllDedicatedBearers:(id)a3;
- (void)removeDedicatedBearer:(id)a3 completion:(id)a4;
- (void)removeGeofenceProfile:(id)a3;
- (void)removeParticipants:(id)a3 fromGroupChat:(id)a4 withParticipantsToRemove:(id)a5 withOperationID:(id)a6 completion:(id)a7;
- (void)removePoliciesFromLocalDevice:(id)a3 completion:(id)a4;
- (void)removePrivateNetworkProfile:(id)a3 completion:(id)a4;
- (void)renamePersonalWallet:(id)a3 to:(id)a4 completion:(id)a5;
- (void)renewOneTimePassword:(id)a3 completion:(id)a4;
- (void)reportChatbotSpam:(id)a3 forChatbot:(id)a4 withSpamReportInfo:(id)a5 andOperationID:(id)a6 completion:(id)a7;
- (void)reportLazuliSpamWithContext:(id)a3 destination:(id)a4 spamReportInfo:(id)a5 operationID:(id)a6 completion:(id)a7;
- (void)reportStewieConnectionAssistantEvent:(id)a3 completion:(id)a4;
- (void)reportStewieDeviceOrientation:(id)a3 completion:(id)a4;
- (void)reprovisionSatelliteMsg:(BOOL)a3 completion:(id)a4;
- (void)requestBootstrapService:(id)a3;
- (void)requestQoSLinkCharacteristics:(id)a3;
- (void)requestSliceByUUID:(id)a3 completion:(id)a4;
- (void)requestSliceDeactivation:(id)a3 completion:(id)a4;
- (void)requestStewieWithContext:(id)a3 completion:(id)a4;
- (void)resetAPNSettings:(id)a3;
- (void)resetProximityTransportExtension:(id)a3;
- (void)resetUIConfiguredApns:(id)a3 completion:(id)a4;
- (void)restoreToSystemBundles:(id)a3;
- (void)retrieveAllIncomingMessageIDs:(id)a3 completion:(id)a4;
- (void)retrieveMessage:(id)a3 withMessageID:(id)a4 completion:(id)a5;
- (void)revokeMessage:(id)a3 withRevokeData:(id)a4 withMessageID:(id)a5 completion:(id)a6;
- (void)saveCallBarringValue:(id)a3 facility:(int)a4 callClass:(int)a5 enabled:(BOOL)a6 password:(id)a7 completion:(id)a8;
- (void)saveCallForwardingValue:(id)a3 value:(id)a4 completion:(id)a5;
- (void)saveCallWaitingValue:(id)a3 callClass:(int)a4 enabled:(BOOL)a5 completion:(id)a6;
- (void)saveCallingLineIdRestrictionValue:(id)a3 restrictionValue:(int)a4 completion:(id)a5;
- (void)savePhonebookEntry:(id)a3 atIndex:(int)a4 withContactName:(id)a5 contactNumber:(id)a6 completion:(id)a7;
- (void)saveSIMLockValue:(id)a3 enabled:(BOOL)a4 pin:(id)a5 completion:(id)a6;
- (void)selectNetwork:(id)a3 network:(id)a4 completion:(id)a5;
- (void)selectPhonebook:(id)a3 forPhonebookName:(int)a4 withPassword:(id)a5 completion:(id)a6;
- (void)selectRoadsideProviderWithContext:(id)a3 completion:(id)a4;
- (void)selectSIMToolkitListItemForContext:(id)a3 session:(id)a4 response:(id)a5 index:(id)a6 completion:(id)a7;
- (void)selectSIMToolkitMenuItemForContext:(id)a3 index:(id)a4 completion:(id)a5;
- (void)sendComposingIndicator:(id)a3 to:(id)a4 withMessageID:(id)a5 withIndication:(id)a6 withError:(id *)a7;
- (void)sendDeadPeerDetection:(id)a3;
- (void)sendDeviceAction:(id)a3 to:(id)a4 withMessageID:(id)a5 withAction:(id)a6 completion:(id)a7;
- (void)sendDeviceSettings:(id)a3 to:(id)a4 withMessageID:(id)a5 withSetting:(id)a6 completion:(id)a7;
- (void)sendDispositionNotificationMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withDisposition:(int64_t)a6 forMessageID:(id)a7 completion:(id)a8;
- (void)sendFileTransferMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withFileInformation:(id)a6 completion:(id)a7;
- (void)sendFileTransferMessage:(id)a3 toGroupDestination:(id)a4 withMessageID:(id)a5 withFileInformation:(id)a6 completion:(id)a7;
- (void)sendGeolocationMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withGeoPush:(id)a6 completion:(id)a7;
- (void)sendGeolocationMessage:(id)a3 toGroupDestination:(id)a4 withMessageID:(id)a5 withGeoPush:(id)a6 completion:(id)a7;
- (void)sendGroupComposingIndicator:(id)a3 toGroup:(id)a4 withMessageID:(id)a5 withIndication:(id)a6 completion:(id)a7;
- (void)sendGroupComposingIndicator:(id)a3 toGroupDestination:(id)a4 withMessageID:(id)a5 withIndication:(id)a6 completion:(id)a7;
- (void)sendGroupDispositionNotificationMessage:(id)a3 toGroup:(id)a4 to:(id)a5 withMessageID:(id)a6 withDisposition:(int64_t)a7 forMessageID:(id)a8 completion:(id)a9;
- (void)sendOneToManyFileTransferMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withDescriptor:(id)a6 completion:(id)a7;
- (void)sendOneToManyGeolocationMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withGeoPush:(id)a6 completion:(id)a7;
- (void)sendOneToManyTextMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withMessage:(id)a6 completion:(id)a7;
- (void)sendRequest:(id)a3 completionHandler:(id)a4;
- (void)sendResponseForSuggestedAction:(id)a3 to:(id)a4 withMessageID:(id)a5 response:(id)a6 completion:(id)a7;
- (void)sendResponseForSuggestedReply:(id)a3 to:(id)a4 withMessageID:(id)a5 response:(id)a6 completion:(id)a7;
- (void)sendSIMToolkitBooleanResponseForContext:(id)a3 session:(id)a4 response:(id)a5 yesNo:(BOOL)a6 completion:(id)a7;
- (void)sendSIMToolkitDisplayReadyForContext:(id)a3 completion:(id)a4;
- (void)sendSIMToolkitResponseForContext:(id)a3 session:(id)a4 response:(id)a5 completion:(id)a6;
- (void)sendSIMToolkitStringResponseForContext:(id)a3 session:(id)a4 response:(id)a5 string:(id)a6 completion:(id)a7;
- (void)sendSIMToolkitUSSDResponseForContext:(id)a3 response:(id)a4 completion:(id)a5;
- (void)sendSIMToolkitUserActivityForContext:(id)a3 completion:(id)a4;
- (void)sendTaggedInfo:(id)a3 type:(unint64_t)a4 payload:(id)a5 completion:(id)a6;
- (void)sendTextMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withMessage:(id)a6 completion:(id)a7;
- (void)sendTextMessage:(id)a3 toGroupDestination:(id)a4 withMessageID:(id)a5 withMessage:(id)a6 completion:(id)a7;
- (void)sendTravelBuddyCAEventWithCompletion:(id)a3 carrierName:(id)a4 completion:(id)a5;
- (void)set2GUserPreference:(BOOL)a3 completion:(id)a4;
- (void)setActiveBandInfo:(id)a3 bands:(id)a4 completion:(id)a5;
- (void)setActiveUserDataSelection:(id)a3 completion:(id)a4;
- (void)setApplicationCategory:(id)a3 completion:(id)a4;
- (void)setAssertionForConnectionType:(int)a3 enable:(BOOL)a4 completion:(id)a5;
- (void)setBandInfo:(id)a3 bands:(id)a4 completion:(id)a5;
- (void)setCoalescing:(BOOL)a3 udp:(BOOL)a4 completion:(id)a5;
- (void)setConnection:(id)a3;
- (void)setDataProviderDelegate:(id)a3;
- (void)setDefaultVoice:(id)a3 completion:(id)a4;
- (void)setDelegate:(id)a3;
- (void)setEosStatus:(id)a3 assertionState:(id)a4 completion:(id)a5;
- (void)setInterfaceCost:(id)a3 expensive:(BOOL)a4 completion:(id)a5;
- (void)setInternationalDataAccess:(id)a3 status:(BOOL)a4 completion:(id)a5;
- (void)setLabel:(id)a3 label:(id)a4 completion:(id)a5;
- (void)setLocalPolicies:(id)a3 completion:(id)a4;
- (void)setLowDataMode:(id)a3 enable:(BOOL)a4 completion:(id)a5;
- (void)setMaxDataRate:(id)a3 rate:(int64_t)a4 completion:(id)a5;
- (void)setOverriddenInterfaceCostInexpensive:(BOOL)a3 completion:(id)a4;
- (void)setPacketContextActiveByServiceType:(id)a3 connectionType:(int)a4 active:(BOOL)a5 completion:(id)a6;
- (void)setPrefForKey:(id)a3 heirarchy:(id)a4 value:(id)a5 storage:(id)a6 completion:(id)a7;
- (void)setPrivacyProxy:(id)a3 enabled:(BOOL)a4 completion:(id)a5;
- (void)setProvisioningServerURL:(id)a3 url:(id)a4 completion:(id)a5;
- (void)setRatSelection:(id)a3 selection:(id)a4 preferred:(id)a5 completion:(id)a6;
- (void)setRatSelectionMask:(id)a3 selection:(unsigned __int8)a4 preferred:(unsigned __int8)a5 completion:(id)a6;
- (void)setRegistry:(shared_ptr<const Registry>)a3;
- (void)setReliableNetworkFallback:(id)a3 enable:(BOOL)a4 completion:(id)a5;
- (void)setRemotePolicies:(id)a3 completion:(id)a4;
- (void)setSatelliteMsgCfgUpdated:(id)a3 completion:(id)a4;
- (void)setSdkVersion:(id)a3;
- (void)setShouldShowBrandedCallingInfo:(BOOL)a3 completion:(id)a4;
- (void)setSmartDataMode:(id)a3 enable:(BOOL)a4 completion:(id)a5;
- (void)setStewieBlocked:(BOOL)a3 completion:(id)a4;
- (void)setSupportDynamicDataSimSwitch:(BOOL)a3 completion:(id)a4;
- (void)setSupportDynamicDataSimSwitch:(BOOL)a3 forIccid:(id)a4 completion:(id)a5;
- (void)setSupports5GStandalone:(id)a3 enabled:(BOOL)a4 completion:(id)a5;
- (void)setSweetgumUserConsent:(id)a3 userConsent:(BOOL)a4 completion:(id)a5;
- (void)setTransportKeysUpdated:(BOOL)a3 with:(id)a4 completion:(id)a5;
- (void)setUIConfiguredApns:(id)a3 apns:(id)a4 completion:(id)a5;
- (void)setUpeSIMLaunched:(id)a3;
- (void)setUsageCollectionEnabled:(BOOL)a3 completion:(id)a4;
- (void)setUserEntered:(id)a3 monthlyBudget:(id)a4 completion:(id)a5;
- (void)setUserEntered:(id)a3 monthlyRoamingBudget:(id)a4 completion:(id)a5;
- (void)setUserEnteredBillingEnd:(id)a3 dayOfMonth:(id)a4 completion:(id)a5;
- (void)setVinylTestMode:(BOOL)a3 completion:(id)a4;
- (void)setVirtualSimMode:(BOOL)a3 withDualSim:(BOOL)a4 completion:(id)a5;
- (void)setVisualVoicemailState:(id)a3 subscribed:(BOOL)a4 completion:(id)a5;
- (void)setVoLTEAudioCodec:(id)a3 codecInfo:(id)a4 completion:(id)a5;
- (void)setWiFiCallingSettingPreferences:(id)a3 key:(id)a4 value:(id)a5 completion:(id)a6;
- (void)shouldAllowSimLockFor:(id)a3 completion:(id)a4;
- (void)shouldShowBrandedCallingInfo:(id)a3;
- (void)shouldShowUserWarningWhenDialingCallOnContext:(id)a3 completion:(id)a4;
- (void)shouldShoweSIMTravelTipWithCompletion:(id)a3;
- (void)simulateDataStall:(BOOL)a3 pdp:(int)a4 completion:(id)a5;
- (void)smartDataMode:(id)a3 completion:(id)a4;
- (void)startPendingPlanInstallationForPlan:(id)a3 carrierName:(id)a4 completionHandler:(id)a5;
- (void)submitPlanSetupDetails:(id)a3 completion:(id)a4;
- (void)submitSimSetupUsage:(id)a3 completion:(id)a4;
- (void)supportsEmbeddedSIMWithCompletion:(id)a3;
- (void)supportsHydraWithCompletion:(id)a3;
- (void)supportsPlanProvisioning:(id)a3 carrierDescriptors:(id)a4 smdpUrl:(id)a5 iccidPrefix:(id)a6 completionHandler:(id)a7;
- (void)terminateProcess:(id)a3;
- (void)testStewieCommand:(id)a3 completion:(id)a4;
- (void)transferCellularPlan:(id)a3 fromDevice:(id)a4 completionHandler:(id)a5;
- (void)transferCellularPlans:(id)a3 fromDevice:(id)a4 completionHandler:(id)a5;
- (void)transferPersonalWallet:(id)a3 to:(id)a4 completion:(id)a5;
- (void)transferPlan:(id)a3 fromDevice:(id)a4 completionHandler:(id)a5;
- (void)transferPlans:(id)a3 fromDevice:(id)a4 completionHandler:(id)a5;
- (void)transferRemotePlan:(id)a3 completion:(id)a4;
- (void)transferRemotePlan:(id)a3 fromDevice:(id)a4 completion:(id)a5;
- (void)triggerKeepAliveWakeupEvent:(int)a3 completion:(id)a4;
- (void)unhideTransferPlan:(id)a3 completion:(id)a4;
- (void)universalGetCarrierBundleValue:(id)a3 keyHierarchy:(id)a4 bundleType:(id)a5 withDefault:(BOOL)a6 completion:(id)a7;
- (void)unlockPIN:(id)a3 pin:(id)a4 completion:(id)a5;
- (void)unlockPUK:(id)a3 puk:(id)a4 newPin:(id)a5 completion:(id)a6;
- (void)updateGeofenceProfile:(id)a3 completion:(id)a4;
- (void)updatePrivateNetworkProfile:(id)a3 setProfileAside:(BOOL)a4 completion:(id)a5;
- (void)updateSecureIntentData:(id)a3 completion:(id)a4;
- (void)usageCollectionEnabled:(id)a3;
- (void)userDidExitWebsheetFlowForPlan:(id)a3 completion:(id)a4;
- (void)userEnteredBillingEndDayOfMont:(id)a3 completion:(id)a4;
- (void)userEnteredMonthlyBudget:(id)a3 completion:(id)a4;
- (void)userEnteredMonthlyRoamingBudget:(id)a3 completion:(id)a4;
- (void)usingBootstrapDataServiceWithCompletion:(id)a3;
- (void)validateProximityTransfer:(unint64_t)a3 pin:(id)a4 completion:(id)a5;
- (void)websheetInfoForPlan:(id)a3 completion:(id)a4;
- (void)wifiCallingCTFollowUpComplete:(id)a3 withCompletion:(id)a4;
@end

@implementation CTXPCClientHandler

- (void).cxx_destruct
{
  cntrl = self->_registry.__cntrl_;
  if (cntrl) {
    sub_10004D2C8((std::__shared_weak_count *)cntrl);
  }
  objc_storeStrong((id *)&self->_sdkVersion, 0);
  objc_destroyWeak((id *)&self->_delegate);
  objc_destroyWeak((id *)&self->_dataProviderDelegate);

  objc_destroyWeak((id *)&self->_connection);
}

- (void)getStewieSupport:(id)a3
{
  v4 = (std::__shared_weak_count *)a3;
  if (v4)
  {
    v5 = v4;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v19 = v8;
    v12 = sub_10004D37C(&v7[1].__m_.__sig, &v19);
    if (v12)
    {
      uint64_t v14 = v12[3];
      v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_13:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v14)
        {
          *(void *)buf = off_1019A9A98;
          v21 = v5;
          v22 = buf;
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v14 + 40))(v14, buf);
          sub_1000605C0(buf);
          v5 = 0;
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          v17 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Service is not available", buf, 2u);
          }
          v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (*)(std::__shared_weak_count *, void, void *))v5->__shared_weak_owners_)(v5, 0, v18);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    v13 = 0;
    char v15 = 1;
    goto LABEL_13;
  }
  [(CTXPCClientHandler *)self getLogContext];
  v16 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for getStewieSupport", buf, 2u);
  }
  v5 = 0;
LABEL_22:
}

- (void)getDualSimCapability:(id)a3
{
  v4 = (void (**)(id, uint64_t, void))a3;
  if ((capabilities::ct::supportsGemini((capabilities::ct *)v4) & 1) == 0)
  {
    v4[2](v4, 3, 0);
    goto LABEL_18;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v17);
  v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    unint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v7;
  unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, &v19);
  if (!v11)
  {
    uint64_t v13 = 0;
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  v12 = (std::__shared_weak_count *)v11[4];
  if (!v12)
  {
LABEL_10:
    std::mutex::unlock(v6);
    v12 = 0;
    char v14 = 1;
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
LABEL_11:
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v13)
  {
    char v15 = objc_retainBlock(v4);
    v20[0] = off_101A0BF18;
    v20[1] = v15;
    v20[3] = v20;
    (*(void (**)(uint64_t, void *))(*(void *)v13 + 144))(v13, v20);
    sub_100008E40(v20);
  }
  else
  {
    v16 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, uint64_t, void *))v4)[2](v4, 4, v16);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
LABEL_18:
}

- (void)getUserDefaultVoiceSubscriptionContext:(id)a3
{
  v4 = (void (**)(id, id, void))a3;
  if (v4)
  {
    if (qword_101B14190)
    {
      v5 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
      if (v5 && DataPlanManagerBootstrap::sInstance)
      {
        int v6 = (*(uint64_t (**)(uint64_t))(*(void *)DataPlanManagerBootstrap::sInstance + 32))(DataPlanManagerBootstrap::sInstance);
        if (v6)
        {
          id v7 = objc_alloc((Class)CTXPCServiceSubscriptionContext);
          if (v6 == 1) {
            uint64_t v8 = 1;
          }
          else {
            uint64_t v8 = 2 * (v6 == 2);
          }
          id v9 = [v7 initWithSlot:v8];
          if (v9)
          {
            v4[2](v4, v9, 0);
          }
          else
          {
            id v13 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:12 userInfo:0];
            ((void (**)(id, id, id))v4)[2](v4, 0, v13);

            id v9 = 0;
          }
        }
        else
        {
          id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
          ((void (**)(id, id, id))v4)[2](v4, 0, v9);
        }

LABEL_21:
        sub_10004D2C8(v5);
        goto LABEL_22;
      }
    }
    else
    {
      v5 = 0;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v11 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v14);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      __int16 v14 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "CommCenter uninitialized", (uint8_t *)&v14, 2u);
    }
    id v12 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id, id))v4)[2](v4, 0, v12);

    if (v5) {
      goto LABEL_21;
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v10 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v14);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      __int16 v14 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid completion handler for getUserDefaultVoiceSubscriptionContext", (uint8_t *)&v14, 2u);
    }
  }
LABEL_22:
}

- (void)getPreferredDataSubscriptionContext:(id)a3
{
  v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    *(void *)buf = 0;
    v34 = buf;
    uint64_t v35 = 0x3032000000;
    v36 = sub_100521B9C;
    v37 = sub_100521BAC;
    id v38 = 0;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)v27);
    int v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v39 = v7;
    unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, &v39);
    if (v11)
    {
      uint64_t v13 = v11[3];
      id v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    id v12 = 0;
    char v14 = 1;
LABEL_12:
    if (v28) {
      sub_10004D2C8(v28);
    }
    if (v13)
    {
      if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 768))(v13) & 1) == 0)
      {
        id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v4[2](v4, 0, v22);

        if (v14)
        {
LABEL_33:
          _Block_object_dispose(buf, 8);

          goto LABEL_34;
        }
LABEL_24:
        sub_10004D2C8(v12);
        goto LABEL_33;
      }
      int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 760))(v13);
      *(void *)v27 = 0;
      v28 = (std::__shared_weak_count *)v27;
      uint64_t v29 = 0x3032000000;
      v30 = sub_100521B9C;
      v31 = sub_100521BAC;
      id v32 = 0;
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472;
      v25[2] = sub_100015874;
      v25[3] = &unk_1019DE500;
      int v26 = v16;
      v25[4] = v27;
      v25[5] = buf;
      [(CTXPCClientHandler *)self getSubscriptionInfo:v25];
      uint64_t shared_weak_owners = v28[1].__shared_weak_owners_;
      if (shared_weak_owners
        || ((id v18 = objc_alloc((Class)CTXPCServiceSubscriptionContext), v16 == 1)
          ? (uint64_t v19 = 1)
          : (uint64_t v19 = 2 * (v16 == 2)),
            id v20 = [v18 initWithSlot:v19],
            v21 = (void *)v28[1].__shared_weak_owners_,
            v28[1].__shared_weak_owners_ = (uint64_t)v20,
            v21,
            (uint64_t shared_weak_owners = v28[1].__shared_weak_owners_) != 0))
      {
        v4[2](v4, shared_weak_owners, 0);
        _Block_object_dispose(v27, 8);

        if (v14) {
          goto LABEL_33;
        }
        goto LABEL_24;
      }
      _Block_object_dispose(v27, 8);
    }
    if ((v14 & 1) == 0) {
      sub_10004D2C8(v12);
    }
    [(CTXPCClientHandler *)self getLogContext];
    v23 = v28;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v27);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v27 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "CommCenter uninitialized", v27, 2u);
    }
    id v24 = *((id *)v34 + 5);
    if (!v24) {
      id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    }
    v4[2](v4, 0, v24);

    goto LABEL_33;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v15 = v34;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getPreferredDataSubscriptionContext", buf, 2u);
  }
LABEL_34:
}

- (void)getConnectionState:(id)a3 connectionType:(int)a4 completion:(id)a5
{
  uint64_t v6 = *(void *)&a4;
  id v8 = a3;
  uint64_t v9 = (void (**)(id, void, id))a5;
  if (v9)
  {
    if (v6 >= 0x24)
    {
      [(CTXPCClientHandler *)self getLogContext];
      unsigned int v10 = v30;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Wrong connection type", buf, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v9[2](v9, 0, v11);

      goto LABEL_31;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    char v14 = ServiceMap;
    if ((v15 & 0x8000000000000000) != 0)
    {
      int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        unint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v31 = v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, &v31);
    if (v19)
    {
      uint64_t v21 = v19[3];
      id v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
LABEL_16:
        if (v30) {
          sub_10004D2C8((std::__shared_weak_count *)v30);
        }
        if (v21)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v21 + 768))(v21))
          {
            v28[0] = v21;
            v28[1] = v20;
            if ((v22 & 1) == 0) {
              atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v23 = sub_100045208(v28, v8);
            if ((v22 & 1) == 0) {
              sub_10004D2C8(v20);
            }
            id v24 = objc_retainBlock(v9);
            v32[0] = off_1019DEBA8;
            v32[1] = v24;
            v32[3] = v32;
            (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v21 + 600))(v21, v23, v6, v32);
            sub_1000606C8(v32);
          }
          else
          {
            id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            v9[2](v9, 0, v27);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          v25 = v30;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "DataService uninitialized", buf, 2u);
          }
          id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v9[2](v9, 0, v26);
        }
        if ((v22 & 1) == 0) {
          sub_10004D2C8(v20);
        }
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    id v20 = 0;
    char v22 = 1;
    goto LABEL_16;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v12 = v30;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid completion handler for getConnectionState", buf, 2u);
  }
LABEL_31:
}

- (void)getCurrentDataSubscriptionContext:(id)a3
{
  v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    *(void *)buf = 0;
    v34 = buf;
    uint64_t v35 = 0x3032000000;
    v36 = sub_100521B9C;
    v37 = sub_100521BAC;
    id v38 = 0;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)v27);
    uint64_t v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v39 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, &v39);
    if (v11)
    {
      uint64_t v13 = v11[3];
      id v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    id v12 = 0;
    char v14 = 1;
LABEL_12:
    if (v28) {
      sub_10004D2C8(v28);
    }
    if (v13)
    {
      if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 768))(v13) & 1) == 0)
      {
        id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v4[2](v4, 0, v22);

        if (v14)
        {
LABEL_33:
          _Block_object_dispose(buf, 8);

          goto LABEL_34;
        }
LABEL_24:
        sub_10004D2C8(v12);
        goto LABEL_33;
      }
      int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 776))(v13);
      *(void *)id v27 = 0;
      v28 = (std::__shared_weak_count *)v27;
      uint64_t v29 = 0x3032000000;
      v30 = sub_100521B9C;
      unint64_t v31 = sub_100521BAC;
      id v32 = 0;
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472;
      v25[2] = sub_10001C3C0;
      v25[3] = &unk_1019DE500;
      int v26 = v16;
      v25[4] = v27;
      v25[5] = buf;
      [(CTXPCClientHandler *)self getSubscriptionInfo:v25];
      uint64_t shared_weak_owners = v28[1].__shared_weak_owners_;
      if (shared_weak_owners
        || ((id v18 = objc_alloc((Class)CTXPCServiceSubscriptionContext), v16 == 1)
          ? (uint64_t v19 = 1)
          : (uint64_t v19 = 2 * (v16 == 2)),
            id v20 = [v18 initWithSlot:v19],
            uint64_t v21 = (void *)v28[1].__shared_weak_owners_,
            v28[1].__shared_weak_owners_ = (uint64_t)v20,
            v21,
            (uint64_t shared_weak_owners = v28[1].__shared_weak_owners_) != 0))
      {
        v4[2](v4, shared_weak_owners, 0);
        _Block_object_dispose(v27, 8);

        if (v14) {
          goto LABEL_33;
        }
        goto LABEL_24;
      }
      _Block_object_dispose(v27, 8);
    }
    if ((v14 & 1) == 0) {
      sub_10004D2C8(v12);
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v23 = v28;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v27);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v27 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "CommCenter uninitialized", v27, 2u);
    }
    id v24 = *((id *)v34 + 5);
    if (!v24) {
      id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    }
    v4[2](v4, 0, v24);

    goto LABEL_33;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v15 = v34;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getCurrentDataSubscriptionContext", buf, 2u);
  }
LABEL_34:
}

- (void)refreshCellMonitor:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v18 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for cell monitor refresh", (uint8_t *)&v24, 2u);
    }
    goto LABEL_23;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v26);
  if (!v14)
  {
    uint64_t v16 = 0;
    goto LABEL_11;
  }
  uint64_t v16 = v14[3];
  unint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
LABEL_11:
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
LABEL_12:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (v16)
  {
    if (v6)
    {
      id v19 = [v6 slotID];
      if (v19 == (id)2) {
        uint64_t v20 = 2;
      }
      else {
        uint64_t v20 = v19 == (id)1;
      }
    }
    else
    {
      uint64_t v20 = 3;
    }
    id v23 = objc_retainBlock(v7);
    v27[0] = off_101A8E648;
    v27[1] = v23;
    v27[3] = v27;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 24))(v16, v20, v27);
    sub_10001C9D4(v27);
    if (v17) {
      goto LABEL_23;
    }
LABEL_22:
    sub_10004D2C8(v15);
    goto LABEL_23;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v21 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v24) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find CellMonitorInterface for cell monitor refresh", (uint8_t *)&v24, 2u);
  }
  id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
  (*((void (**)(id, id))v7 + 2))(v7, v22);

  if ((v17 & 1) == 0) {
    goto LABEL_22;
  }
LABEL_23:
}

- (void)copyOperatorName:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          id v22 = objc_retainBlock(v7);
          v28[0] = off_101AA5E80;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 112))(v16, v21, v28);
          sub_10001E914(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting operator name", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for operator name query", (uint8_t *)&v25, 2u);
  }
LABEL_26:
}

- (void)getSubscriptionInfo:(id)a3
{
  id v6 = (void (**)(id, void *, void))a3;
  v4 = [(CTXPCClientHandler *)self dataProviderDelegate];
  v5 = [v4 subscriptionInfo];

  v6[2](v6, v5, 0);
}

- (void)getActiveContexts:(id)a3
{
  id v6 = (void (**)(id, void *, void))a3;
  v4 = [(CTXPCClientHandler *)self dataProviderDelegate];
  v5 = [v4 activeSubscriptions];

  v6[2](v6, v5, 0);
}

- (CTXPCDataProviderInterface)dataProviderDelegate
{
  id WeakRetained = objc_loadWeakRetained((id *)&self->_dataProviderDelegate);

  return (CTXPCDataProviderInterface *)WeakRetained;
}

- (void)sendSIMToolkitDisplayReadyForContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void))a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v20);
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v22);
  if (v14)
  {
    uint64_t v16 = v14[3];
    unint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  unint64_t v15 = 0;
  char v17 = 1;
LABEL_9:
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v16)
  {
    (*(void (**)(uint64_t))(*(void *)v16 + 144))(v16);
    if (v7) {
      v7[2](v7, 0);
    }
    if ((v17 & 1) == 0) {
LABEL_15:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find STK Controller", (uint8_t *)&v20, 2u);
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    if (v7) {
      ((void (**)(id, id))v7)[2](v7, v19);
    }

    if ((v17 & 1) == 0) {
      goto LABEL_15;
    }
  }
}

- (void)copyRegistrationStatus:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          unint64_t v22 = objc_retainBlock(v7);
          v28[0] = off_101AA59B0;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 16))(v16, v21, v28);
          sub_10002FB34(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting registration status", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for registration status query", (uint8_t *)&v25, 2u);
  }
LABEL_26:
}

- (void)getDataStatus:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v16 + 768))(v16))
          {
            v24[0] = v16;
            v24[1] = v15;
            if ((v17 & 1) == 0) {
              atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v19 = sub_100045208(v24, v6);
            if ((v17 & 1) == 0) {
              sub_10004D2C8(v15);
            }
            id v20 = objc_retainBlock(v7);
            v28[0] = off_1019DED58;
            v28[1] = v20;
            v28[3] = v28;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 616))(v16, v19, v28);
            sub_100030784(v28);
          }
          else
          {
            id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            (*((void (**)(id, void, id))v7 + 2))(v7, 0, v23);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v21 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "DataService uninitialized", buf, 2u);
          }
          id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, id))v7 + 2))(v7, 0, v22);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getDataStatus", buf, 2u);
  }
LABEL_27:
}

- (void)getPhoneNumberWithCompletion:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v26);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v28);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v16)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          id v22 = self;
          id v23 = objc_retainBlock(v7);
          v29[0] = off_101A3D750;
          v29[1] = v22;
          v29[2] = v23;
          v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 264))(v16, v21, v29);
          sub_10003A3A8(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find PhonebookInterface for copying own phone number", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for copying own phone number", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)setDelegate:(id)a3
{
}

- (void)setDataProviderDelegate:(id)a3
{
}

- (CTXPCClientHandler)initWithRegistry:(const void *)a3 queue:(queue)a4 connection:(id)a5
{
  id v8 = a5;
  dispatch_object_t object = *(dispatch_object_t *)a4.fObj.fObj;
  *(void *)a4.fObj.fObj = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v15, kCtLoggingSystemName, "xpc.handler");
  v14.receiver = self;
  v14.super_class = (Class)CTXPCClientHandler;
  uint64_t v9 = [(CTXPCClientHandler *)&v14 initWithQueue:&object logContext:v15];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v15);
  if (object) {
    dispatch_release(object);
  }
  if (v9)
  {
    id v11 = *(Registry **)a3;
    uint64_t v10 = *((void *)a3 + 1);
    if (v10) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    }
    cntrl = (std::__shared_weak_count *)v9->_registry.__cntrl_;
    v9->_registry.__ptr_ = v11;
    v9->_registry.__cntrl_ = (__shared_weak_count *)v10;
    if (cntrl) {
      sub_10004D2C8(cntrl);
    }
    objc_storeWeak((id *)&v9->_connection, v8);
  }

  return v9;
}

- (void)getSignalStrengthMeasurements:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_27;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v26 = v10;
    objc_super v14 = sub_10004D37C(&v9[1].__m_.__sig, &v26);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v25) {
          sub_10004D2C8(v25);
        }
        if (v16)
        {
          id v24 = 0;
          id v25 = 0;
          uint64_t v20 = sub_10003E318(v6);
          (*(void (**)(Registry **__return_ptr, uint64_t, uint64_t))(*(void *)v16 + 56))(&v24, v16, v20);
          if (v24)
          {
            uint64_t v21 = sub_10132AEE0(v24);
            ((void (**)(id, void *, void *))v7)[2](v7, v21, 0);
          }
          else
          {
            v7[2](v7, 0, 0);
          }
          if (v25) {
            sub_10004D2C8(v25);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v22 = v25;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v24) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find SignalStrengthInterface for getting signal strength measurements", (uint8_t *)&v24, 2u);
          }
          id v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v23);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v24) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting signal strength measurements", (uint8_t *)&v24, 2u);
  }
LABEL_27:
}

- (void)copyMobileNetworkCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    objc_super v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          id v22 = objc_retainBlock(v7);
          v28[0] = off_101AA5C50;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 224))(v16, v21, v28);
          sub_10003D49C(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting MNC", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for MNC query", (uint8_t *)&v25, 2u);
  }
LABEL_26:
}

- (void)copyMobileCountryCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    objc_super v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          id v22 = objc_retainBlock(v7);
          v28[0] = off_101AA5B50;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 208))(v16, v21, v28);
          sub_10003DF80(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting MCC", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for MCC query", (uint8_t *)&v25, 2u);
  }
LABEL_26:
}

- (shared_ptr<const)registry
{
  cntrl = self->_registry.__cntrl_;
  *v2 = self->_registry.__ptr_;
  v2[1] = (Registry *)cntrl;
  if (cntrl) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)cntrl + 1, 1uLL, memory_order_relaxed);
  }
  result.__cntrl_ = (__shared_weak_count *)a2;
  result.__ptr_ = (Registry *)self;
  return result;
}

- (void)sendRequest:(id)a3 completionHandler:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  id v8 = [v6 requiredEntitlement];
  if ([(CTXPCClientHandler *)self hasEntitlement:v8])
  {
    uint64_t v9 = [[CTXPCRequestHandler alloc] initWithClientHandler:self];
    [v6 performRequestWithHandler:v9 completionHandler:v7];
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v10 = *(NSObject **)&v18[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = (objc_class *)objc_opt_class();
      uint64_t v13 = NSStringFromClass(v12);
      objc_super v14 = (void *)v13;
      uint64_t v15 = 0;
      uint64_t v16 = "???";
      while (dword_101AAF500[v15] != v8)
      {
        v15 += 4;
        if (v15 == 124) {
          goto LABEL_11;
        }
      }
      uint64_t v16 = *(const char **)&dword_101AAF500[v15 + 2];
LABEL_11:
      int v17 = 138412546;
      *(void *)id v18 = v13;
      *(_WORD *)&v18[8] = 2080;
      *(void *)&v18[10] = v16;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Client is not entitled for request %@ (requires '%s')", (uint8_t *)&v17, 0x16u);
    }
    id v11 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:1 userInfo:0];
    v7[2](v7, 0, v11);
  }
}

- (void)registerForNotifications:(id)a3 completion:(id)a4
{
  id v10 = a3;
  id v6 = (void (**)(id, void))a4;
  id v7 = [(CTXPCClientHandler *)self connection];
  if (v7)
  {
    id v8 = [(CTXPCClientHandler *)self delegate];
    [v8 receivedSelectors:v10 forConnection:v7];

    v6[2](v6, 0);
  }
  else
  {
    uint64_t v9 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(id, void *))v6)[2](v6, v9);
  }
}

- (BOOL)hasEntitlement:(int)a3
{
  uint64_t v3 = *(void *)&a3;
  v5 = [(CTXPCClientHandler *)self delegate];
  LOBYTE(v3) = [v5 clientHandler:self hasEntitlement:v3];

  return v3;
}

- (CTXPCClientHandlerDelegate)delegate
{
  id WeakRetained = objc_loadWeakRetained((id *)&self->_delegate);

  return (CTXPCClientHandlerDelegate *)WeakRetained;
}

- (NSXPCConnection)connection
{
  id WeakRetained = objc_loadWeakRetained((id *)&self->_connection);

  return (NSXPCConnection *)WeakRetained;
}

- (id).cxx_construct
{
  *((void *)self + 5) = 0;
  *((void *)self + 6) = 0;
  return self;
}

- (void)getLocalPolicies:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  [(CTXPCClientHandler *)self registry];
  [(CTXPCClientHandler *)self getLogContext];
  sub_1001527F0(&v9, v8[1], (unint64_t)sub_100152C74, 0, v6, v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
  if (v10) {
    sub_10004D2C8(v10);
  }
}

- (void)getRemotePolicies:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  [(CTXPCClientHandler *)self registry];
  [(CTXPCClientHandler *)self getLogContext];
  sub_1001527F0(&v9, v8[1], (unint64_t)sub_100152D74, 0, v6, v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
  if (v10) {
    sub_10004D2C8(v10);
  }
}

- (void)setLocalPolicies:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  [(CTXPCClientHandler *)self registry];
  [(CTXPCClientHandler *)self getLogContext];
  sub_100152E5C(&v9, v8[1], v6, v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
  if (v10) {
    sub_10004D2C8(v10);
  }
}

- (void)setRemotePolicies:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  [(CTXPCClientHandler *)self registry];
  [(CTXPCClientHandler *)self getLogContext];
  sub_100152E5C(&v9, v8[1], v6, v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
  if (v10) {
    sub_10004D2C8(v10);
  }
}

- (void)removePoliciesFromLocalDevice:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, id))a4;
  if (v7)
  {
    *(void *)buf = 0;
    unint64_t v28 = 0;
    uint64_t v29 = 0;
    sub_1004952CC(v6, (uint64_t)buf);
    if (!v29)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v19 = v26;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v25);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v25 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Bundle Id list empty.", v25, 2u);
      }
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_25;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)v25);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v30 = v10;
    objc_super v14 = sub_10004D37C(&v9[1].__m_.__sig, &v30);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_16:
        if (v26) {
          sub_10004D2C8((std::__shared_weak_count *)v26);
        }
        if (v16)
        {
          sub_1000C6BDC(v24, (uint64_t)buf);
          uint64_t v21 = objc_retainBlock(v7);
          v31[0] = off_1019A47F0;
          v31[1] = v21;
          v31[3] = v31;
          (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 80))(v16, v24, v31);
          sub_100060644(v31);
          sub_10005CD2C((uint64_t)v24, (char *)v24[1]);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v22 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v25);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)id v25 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find policy controller for removing policies.", v25, 2u);
          }
          id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v23);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
LABEL_25:
        sub_10005CD2C((uint64_t)buf, v28);
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_16;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for data usage policy query", buf, 2u);
  }
LABEL_26:
}

- (void)performNetworkAccessFlowIfAllowed:(id)a3 ignoreForeground:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = a5;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  id v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v27);
  if (v16)
  {
    uint64_t v18 = v16[3];
    char v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  char v17 = 0;
  char v19 = 1;
LABEL_9:
  if (v26) {
    sub_10004D2C8(v26);
  }
  if (v18)
  {
    sub_100058DB0(__p, (char *)[v8 UTF8String]);
    id v20 = objc_retainBlock(v9);
    v28[0] = off_1019A4870;
    v28[1] = v20;
    v28[3] = v28;
    (*(void (**)(uint64_t, void **, BOOL, void *))(*(void *)v18 + 88))(v18, __p, v6, v28);
    sub_1000D91CC(v28);
    if (v24 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find policy controller for displaying network access flow.", buf, 2u);
    }
    id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*((void (**)(id, void, id))v9 + 2))(v9, 0, v22);
  }
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

- (void)requestStewieWithContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138412290;
        *(void *)&buf[4] = v6;
        _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Received requestStewieWithContext: %@", buf, 0xCu);
      }
      int v9 = 0;
      int v10 = 1;
      switch((unint64_t)[v6 reason])
      {
        case 1uLL:
          goto LABEL_18;
        case 2uLL:
        case 5uLL:
          int v9 = 0;
          int v10 = 2;
          goto LABEL_18;
        case 3uLL:
          int v9 = 0;
          int v10 = 3;
          goto LABEL_18;
        case 4uLL:
          int v9 = 0;
          int v10 = 4;
          goto LABEL_18;
        case 6uLL:
          int v9 = 0;
          int v10 = 6;
          goto LABEL_18;
        case 7uLL:
          int v10 = 7;
          int v9 = 1;
          goto LABEL_18;
        case 8uLL:
          int v9 = 0;
          int v10 = 8;
          goto LABEL_18;
        case 9uLL:
          int v9 = 0;
          int v10 = 9;
          goto LABEL_18;
        case 0xAuLL:
          int v9 = 0;
          int v10 = 10;
LABEL_18:
          __int16 v56 = 0;
          *(_OWORD *)__p = 0u;
          long long v55 = 0u;
          __int16 v53 = 0;
          uint64_t v16 = [v6 metadata];
          BOOL v17 = v16 == 0;

          if (v17)
          {
            uint8_t v50 = 0;
            unint64_t v51 = 0;
            BOOL v23 = 0;
            unsigned __int8 v52 = 0;
            LOBYTE(v20) = 0;
          }
          else
          {
            uint64_t v18 = [v6 metadata];
            char v19 = [v18 objectForKeyedSubscript:kCTStewieRequestSourceKey];
            unsigned int v20 = [v19 isEqualToString:kCTStewieRequestSourceConnectionAssistant];

            if (v20)
            {
              uint64_t v21 = [v6 metadata];
              id v22 = [v21 objectForKeyedSubscript:kCTStewieForceTransitionKey];

              if (v22) {
                unsigned __int8 v52 = [v22 BOOLValue];
              }
              else {
                unsigned __int8 v52 = 0;
              }
            }
            else
            {
              unsigned __int8 v52 = 0;
            }
            if (v9)
            {
              char v24 = [v6 metadata];
              *(void *)buf = 0;
              BOOL v25 = sub_100215464(v24, kCTStewieProviderIdKey, buf);
              BOOL v23 = v25;
              if (v25) {
                uint8_t v26 = buf[0];
              }
              else {
                uint8_t v26 = 0;
              }
              if (v25) {
                unint64_t v27 = *(void *)buf & 0xFFFFFFFFFFFFFF00;
              }
              else {
                unint64_t v27 = 0;
              }
              uint8_t v50 = v26;
              unint64_t v51 = v27;
            }
            else
            {
              uint8_t v50 = 0;
              unint64_t v51 = 0;
              BOOL v23 = 0;
            }
            unint64_t v28 = [v6 metadata];
            sub_100215578(v28, kCTStewieRequestWaitForOffGridModeMessage, (unsigned char *)&v56 + 1);

            uint64_t v29 = [v6 metadata];
            sub_100215578(v29, kCTStewieOffer, &v56);

            unint64_t v30 = [v6 metadata];
            unint64_t v31 = (void *)kCTStewieOfferReason;
            id v32 = v30;
            id v33 = v31;
            memset(buf, 0, sizeof(buf));
            *(void *)&long long v59 = 0;
            if (sub_1002155D4(v32, (uint64_t)v33, (std::string *)buf))
            {
              sub_100093B44((std::string *)__p, (const std::string *)buf);
            }
            else if (BYTE8(v55))
            {
              if (SBYTE7(v55) < 0) {
                operator delete(__p[0]);
              }
              BYTE8(v55) = 0;
            }
            if (SBYTE7(v59) < 0) {
              operator delete(*(void **)buf);
            }

            v34 = [v6 metadata];
            sub_100215578(v34, kCTStewieLaunchDemo, (unsigned char *)&v53 + 1);

            uint64_t v35 = [v6 metadata];
            sub_100215578(v35, kCTStewieAreAllPrimaryContactsReachableViaIML, &v53);
          }
          if ([v6 reason] == (id)5) {
            HIBYTE(v53) = 1;
          }
          int v49 = v10;
          [(CTXPCClientHandler *)self registry];
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
          v37 = ServiceMap;
          if ((v38 & 0x8000000000000000) != 0)
          {
            unint64_t v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v40 = 5381;
            do
            {
              unint64_t v38 = v40;
              unsigned int v41 = *v39++;
              uint64_t v40 = (33 * v40) ^ v41;
            }
            while (v41);
          }
          std::mutex::lock(ServiceMap);
          v57[0] = v38;
          v42 = sub_10004D37C(&v37[1].__m_.__sig, v57);
          if (v42)
          {
            uint64_t v44 = v42[3];
            v43 = (std::__shared_weak_count *)v42[4];
            if (v43)
            {
              atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v37);
              atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v43);
              char v45 = 0;
              goto LABEL_54;
            }
          }
          else
          {
            uint64_t v44 = 0;
          }
          std::mutex::unlock(v37);
          v43 = 0;
          char v45 = 1;
LABEL_54:
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          if (v44)
          {
            int v64 = 0;
            long long v62 = 0u;
            long long v63 = 0u;
            long long v61 = 0u;
            long long v59 = 0u;
            long long v60 = 0u;
            *(_OWORD *)buf = 0u;
            int v65 = v49;
            buf[0] = v56;
            sub_100179AF8((std::string *)&buf[8], (const std::string *)__p);
            BYTE8(v60) = HIBYTE(v53);
            *(void *)&long long v61 = v51 & 0xFFFFFFFFFFFFFF00 | v50;
            BYTE8(v61) = v23;
            BYTE9(v60) = v52;
            BYTE10(v60) = v20;
            LOBYTE(v64) = HIBYTE(v56);
            BYTE1(v64) = v53;
            id v46 = objc_retainBlock(v7);
            v57[0] = (unint64_t)off_1019A9B18;
            v57[1] = (unint64_t)v46;
            v57[3] = (unint64_t)v57;
            (*(void (**)(uint64_t, uint8_t *, unint64_t *))(*(void *)v44 + 48))(v44, buf, v57);
            sub_1001E7E54(v57);
            if (*((void *)&v63 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v63 + 1));
            }
            if (*((void *)&v62 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v62 + 1));
            }
            if ((_BYTE)v60 && SHIBYTE(v59) < 0) {
              operator delete(*(void **)&buf[8]);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            v47 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for requestStewieWithContext", buf, 2u);
            }
            v48 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void *))v7 + 2))(v7, v48);
          }
          if ((v45 & 1) == 0) {
            sub_10004D2C8(v43);
          }
          if (BYTE8(v55) && SBYTE7(v55) < 0) {
            operator delete(__p[0]);
          }
          break;
        default:
          NSErrorUserInfoKey v66 = NSLocalizedDescriptionKey;
          CFStringRef v67 = @"Valid reason required";
          uint64_t v14 = +[NSDictionary dictionaryWithObjects:&v67 forKeys:&v66 count:1];
          unsigned int v15 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v14];

          (*((void (**)(id, void *))v7 + 2))(v7, v15);
          break;
      }
    }
    else
    {
      NSErrorUserInfoKey v68 = NSLocalizedDescriptionKey;
      CFStringRef v69 = @"Context required";
      unint64_t v12 = +[NSDictionary dictionaryWithObjects:&v69 forKeys:&v68 count:1];
      unsigned int v13 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v12];

      (*((void (**)(id, void *))v7 + 2))(v7, v13);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v11 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid completion handler for requestStewieWithContext:completion: query", buf, 2u);
    }
  }
}

- (void)exitStewieWithContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      NSErrorUserInfoKey v35 = NSLocalizedDescriptionKey;
      CFStringRef v36 = @"Context required";
      id v22 = +[NSDictionary dictionaryWithObjects:&v36 forKeys:&v35 count:1];
      BOOL v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v22];

      v7[2](v7, v23);
      goto LABEL_30;
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v8 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v6;
      _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Received exitStewieWithContext: %@", (uint8_t *)&buf, 0xCu);
    }
    int v9 = (char *)[v6 reason];
    BOOL v10 = (unint64_t)(v9 - 1) < 4;
    if ((unint64_t)(v9 - 1) >= 4)
    {
      NSErrorUserInfoKey v33 = NSLocalizedDescriptionKey;
      CFStringRef v34 = @"Valid reason required";
      char v24 = +[NSDictionary dictionaryWithObjects:&v34 forKeys:&v33 count:1];
      BOOL v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v24];

      v7[2](v7, v25);
      goto LABEL_30;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    unint64_t v12 = ServiceMap;
    if ((v13 & 0x8000000000000000) != 0)
    {
      uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        unint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v32 = v13;
    BOOL v17 = sub_10004D37C(&v12[1].__m_.__sig, &v32);
    if (v17)
    {
      uint64_t v19 = v17[3];
      uint64_t v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
LABEL_18:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v19)
        {
          unint64_t v26 = (unint64_t)[v6 reason];
          if (v26 >= 5)
          {
            LOBYTE(v27) = 0;
            LOBYTE(v28) = 0;
            BOOL v29 = 0;
          }
          else
          {
            unint64_t v27 = 0x101010000uLL >> (8 * v26);
            unint64_t v28 = 0x3002040000uLL >> (8 * v26);
            BOOL v29 = (v26 & 0x1F) == 3;
          }
          LODWORD(buf) = v10;
          WORD2(buf) = v28;
          BYTE6(buf) = v27;
          BYTE8(buf) = v29;
          (*(void (**)(uint64_t, long long *))(*(void *)v19 + 56))(v19, &buf);
          v7[2](v7, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v30 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for exitStewieWithContext", (uint8_t *)&buf, 2u);
          }
          unint64_t v31 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v31);
        }
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_30;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    uint64_t v18 = 0;
    char v20 = 1;
    goto LABEL_18;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v21 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for exitStewieWithContext:completion: query", (uint8_t *)&buf, 2u);
  }
LABEL_30:
}

- (void)getConnectionAssistantConfig:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v19 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, &v19);
    if (v11)
    {
      uint64_t v13 = v11[3];
      unint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v13)
        {
          unsigned int v16 = (std::__shared_weak_count *)objc_retainBlock(v4);
          *(void *)long long buf = off_1019A9BA8;
          uint64_t v21 = v16;
          id v22 = buf;
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v13 + 64))(v13, buf);
          sub_1001E8174(buf);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          BOOL v17 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for getConnectionAssistantConfig", buf, 2u);
          }
          uint64_t v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v18);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    unint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getConnectionAssistantConfig: query", buf, 2u);
  }
LABEL_21:
}

- (void)getConnectionAssistantState:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v19 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, &v19);
    if (v11)
    {
      uint64_t v13 = v11[3];
      unint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v13)
        {
          unsigned int v16 = (std::__shared_weak_count *)objc_retainBlock(v4);
          *(void *)long long buf = off_1019A9C38;
          uint64_t v21 = v16;
          id v22 = buf;
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v13 + 72))(v13, buf);
          sub_1001E8464(buf);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          BOOL v17 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for getConnectionAssistantState", buf, 2u);
          }
          uint64_t v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v18);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    unint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getConnectionAssistantState: query", buf, 2u);
  }
LABEL_21:
}

- (void)getConnectionAssistantServicePlot:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v19 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, &v19);
    if (v11)
    {
      uint64_t v13 = v11[3];
      unint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v13)
        {
          unsigned int v16 = (std::__shared_weak_count *)objc_retainBlock(v4);
          *(void *)long long buf = off_1019A9CC8;
          uint64_t v21 = v16;
          id v22 = buf;
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v13 + 80))(v13, buf);
          sub_1001E8754(buf);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          BOOL v17 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for getConnectionAssistantServicePlot", buf, 2u);
          }
          uint64_t v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v18);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    unint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getConnectionAssistantServicePlot: query", buf, 2u);
  }
LABEL_21:
}

- (void)setStewieBlocked:(BOOL)a3 completion:(id)a4
{
  BOOL v4 = a3;
  id v6 = a4;
  if (v6)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v8 = ServiceMap;
    if ((v9 & 0x8000000000000000) != 0)
    {
      unsigned int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        unint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v21 = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v21);
    if (v13)
    {
      uint64_t v15 = v13[3];
      char v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_12:
        if (v23) {
          sub_10004D2C8(v23);
        }
        if (v15)
        {
          uint64_t v18 = (std::__shared_weak_count *)objc_retainBlock(v6);
          *(void *)long long buf = off_1019A9D58;
          BOOL v23 = v18;
          char v24 = buf;
          (*(void (**)(uint64_t, BOOL, uint8_t *))(*(void *)v15 + 88))(v15, v4, buf);
          sub_1001E7E54(buf);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v19 = v23;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for setStewieBlocked:completion", buf, 2u);
          }
          char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void *))v6 + 2))(v6, v20);
        }
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    char v14 = 0;
    char v16 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  BOOL v17 = v23;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler for setStewieBlocked:completion query", buf, 2u);
  }
LABEL_21:
}

- (void)reportStewieDeviceOrientation:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void *))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for reportStewieDeviceOrientation:completion: query", (uint8_t *)&v24, 2u);
    }
    goto LABEL_18;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
  unint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v26);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_12:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (!v16)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v21 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for reportStewieDeviceOrientation:completion:", (uint8_t *)&v24, 2u);
    }
    id v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v7[2](v7, v22);
LABEL_25:

    if (v17) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (!v6)
  {
    [(CTXPCClientHandler *)self getLogContext];
    BOOL v23 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Data cannot be nil for reportStewieDeviceOrientation:completion:", (uint8_t *)&v24, 2u);
    }
    id v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, v22);
    goto LABEL_25;
  }
  BOOL v25 = 0;
  unint64_t v19 = [v6 timestamp];
  [v19 timeIntervalSince1970];
  char v24 = (Registry *)v20;

  LOBYTE(v25) = [v6 targetLocked];
  BYTE1(v25) = [v6 isDeviceStationary];
  HIDWORD(v25) = [v6 x];
  (*(void (**)(uint64_t, Registry **))(*(void *)v16 + 96))(v16, &v24);
  v7[2](v7, 0);
  if ((v17 & 1) == 0) {
LABEL_17:
  }
    sub_10004D2C8(v15);
LABEL_18:
}

- (void)compressWithStewieCodec:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unint64_t v9 = ServiceMap;
    if (v10 < 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    __p = (void *)v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&__p);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
LABEL_12:
    if (v38) {
      sub_10004D2C8(v38);
    }
    if (!v16)
    {
      [(CTXPCClientHandler *)self getLogContext];
      BOOL v29 = v38;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for compressWithStewieCodec:completion:", buf, 2u);
      }
      unint64_t v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v7[2](v7, 0, v30);

      goto LABEL_29;
    }
    if (v6)
    {
      unint64_t v19 = [v6 data];
      if (v19)
      {
        double v20 = [v6 data];
        BOOL v21 = [v20 length] == 0;

        if (!v21)
        {
          __p = 0;
          NSErrorUserInfoKey v35 = 0;
          uint64_t v36 = 0;
          id v22 = [v6 data];
          id v23 = [v22 bytes];
          id v24 = [v6 data];
          id v25 = [v24 bytes];
          unint64_t v26 = [v6 data];
          unint64_t v27 = (char *)[v26 length];
          __p = 0;
          NSErrorUserInfoKey v35 = 0;
          uint64_t v36 = 0;
          sub_1001E7940(&__p, v23, (uint64_t)&v27[(void)v25], &v27[(void)v25] - (char *)v23);

          unint64_t v28 = objc_retainBlock(v7);
          *(void *)long long buf = off_1019A9DD8;
          unint64_t v38 = v28;
          unint64_t v39 = buf;
          (*(void (**)(uint64_t, uint64_t, void **, uint8_t *))(*(void *)v16 + 104))(v16, 1, &__p, buf);
          sub_1001E8DA8(buf);
          if (__p)
          {
            NSErrorUserInfoKey v35 = __p;
            operator delete(__p);
          }
          goto LABEL_29;
        }
      }
      [(CTXPCClientHandler *)self getLogContext];
      unint64_t v31 = v38;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Data in request cannot be empty for compressWithStewieCodec:completion:", buf, 2u);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      unint64_t v32 = v38;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Request cannot be nil for compressWithStewieCodec:completion:", buf, 2u);
      }
    }
    NSErrorUserInfoKey v33 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, 0, v33);

LABEL_29:
    if ((v17 & 1) == 0) {
      sub_10004D2C8(v15);
    }
    goto LABEL_31;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v18 = v38;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for compressWithStewieCodec:completion: query", buf, 2u);
  }
LABEL_31:
}

- (void)activateStewieEmergencyTryOutWithCompletion:(id)a3
{
  BOOL v4 = (void (**)(id, void *))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    v5 = v9;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "activateStewieEmergencyTryOutWithCompletion is deprecated.", v8, 2u);
    }
    id v6 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v4[2](v4, v6);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v7 = v9;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid completion handler for activateStewieEmergencyTryOutWithCompletion:completion:", v8, 2u);
    }
  }
}

- (void)reportStewieConnectionAssistantEvent:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void))a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
    unint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v26 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v26);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
LABEL_12:
    if (v25) {
      sub_10004D2C8(v25);
    }
    if (v16)
    {
      if (v6)
      {
        unint64_t v19 = (char *)[v6 eventType];
        if ((unint64_t)(v19 - 1) > 7) {
          uint64_t v20 = 0;
        }
        else {
          uint64_t v20 = dword_10146E110[(void)(v19 - 1)];
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 112))(v16, v20);
        v7[2](v7, 0);
        goto LABEL_27;
      }
      [(CTXPCClientHandler *)self getLogContext];
      id v23 = v25;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v24) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Event cannot be nil for reportStewieConnectionAssistantEvent:completion:", (uint8_t *)&v24, 2u);
      }
      id v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      ((void (**)(id, void *))v7)[2](v7, v22);
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      BOOL v21 = v25;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v24) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for reportStewieConnectionAssistantEvent:completion:", (uint8_t *)&v24, 2u);
      }
      id v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      ((void (**)(id, void *))v7)[2](v7, v22);
    }

LABEL_27:
    if ((v17 & 1) == 0) {
      sub_10004D2C8(v15);
    }
    goto LABEL_29;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v18 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v24) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Completion handler for reportStewieConnectionAssistantEvent:completion: query is required", (uint8_t *)&v24, 2u);
  }
LABEL_29:
}

- (void)testStewieCommand:(id)a3 completion:(id)a4
{
  id v6 = (ctu *)a3;
  unint64_t v7 = (void (**)(id, void *, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = *((void *)&object + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&object);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(object) = 138412290;
        *(void *)((char *)&object + 4) = v6;
        _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Received testStewieCommand: %@", (uint8_t *)&object, 0xCu);
      }
      ctu::cf_to_xpc((uint64_t *)&object, v6, v9);
      unint64_t v10 = (void *)object;
      xpc_object_t v49 = (xpc_object_t)object;
      if ((void)object && xpc_get_type((xpc_object_t)object) == (xpc_type_t)&_xpc_type_dictionary) {
        xpc_retain(v10);
      }
      else {
        xpc_object_t v49 = xpc_null_create();
      }
      xpc_release((xpc_object_t)object);
      xpc_object_t v48 = 0;
      *(void *)&long long object = &v49;
      *((void *)&object + 1) = "force-allow-satellite-systems";
      sub_100048BAC((uint64_t)&object, &v48);
      if (xpc_get_type(v48) != (xpc_type_t)&_xpc_type_null)
      {
        [(CTXPCClientHandler *)self getLogContext];
        char v14 = *((void *)&object + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&object);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          char v45 = xpc_copy_description(v48);
          long long object = 0uLL;
          uint64_t v51 = 0;
          sub_100058DB0(&object, v45);
          free(v45);
          id v46 = v51 >= 0 ? &object : (long long *)object;
          *(_DWORD *)long long buf = 136315138;
          *(void *)&buf[4] = v46;
          _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "force-allow-satellite-systems - %s", buf, 0xCu);
          if (SHIBYTE(v51) < 0) {
            operator delete((void *)object);
          }
        }
        if (xpc_get_type(v48) != (xpc_type_t)&_xpc_type_BOOL)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v15 = *((void *)&object + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&object);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            LOWORD(object) = 0;
            _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "force-allow-satellite-systems - invalid format", (uint8_t *)&object, 2u);
          }
          NSErrorUserInfoKey v53 = NSLocalizedDescriptionKey;
          CFStringRef v54 = @"force-allow-satellite-systems: invalid format";
          uint64_t v16 = +[NSDictionary dictionaryWithObjects:&v54 forKeys:&v53 count:1];
          char v17 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v16];

          v7[2](v7, v17, 0);
LABEL_59:
          xpc_release(v48);
          goto LABEL_60;
        }
        *(void *)&long long object = v48;
        if (v48) {
          xpc_retain(v48);
        }
        else {
          *(void *)&long long object = xpc_null_create();
        }
        uint64_t v31 = xpc::dyn_cast_or_default((xpc *)&object, 0, v28);
        xpc_release((xpc_object_t)object);
        [(CTXPCClientHandler *)self registry];
        ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)object);
        NSErrorUserInfoKey v33 = ServiceMap;
        if (v34 < 0)
        {
          NSErrorUserInfoKey v35 = (unsigned __int8 *)(v34 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v36 = 5381;
          do
          {
            uint64_t v34 = v36;
            unsigned int v37 = *v35++;
            uint64_t v36 = (33 * v36) ^ v37;
          }
          while (v37);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long buf = v34;
        unint64_t v38 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)buf);
        if (v38)
        {
          uint64_t v40 = (void (***)(void, uint64_t))v38[3];
          unint64_t v39 = (std::__shared_weak_count *)v38[4];
          if (v39)
          {
            atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v33);
            atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v39);
            char v41 = 0;
LABEL_50:
            if (*((void *)&object + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&object + 1));
            }
            if (v40)
            {
              (**v40)(v40, v31);
              v7[2](v7, 0, 0);
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              v43 = *((void *)&object + 1);
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&object);
              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
              {
                LOWORD(object) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Could not find SatelliteSystemInterface for testStewieCommand", (uint8_t *)&object, 2u);
              }
              uint64_t v44 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
              v7[2](v7, v44, 0);
            }
            if ((v41 & 1) == 0) {
              sub_10004D2C8(v39);
            }
            goto LABEL_59;
          }
        }
        else
        {
          uint64_t v40 = 0;
        }
        std::mutex::unlock(v33);
        unint64_t v39 = 0;
        char v41 = 1;
        goto LABEL_50;
      }
      xpc_release(v48);
      [(CTXPCClientHandler *)self registry];
      uint64_t v18 = (std::mutex *)Registry::getServiceMap((Registry *)object);
      unint64_t v19 = v18;
      if (v20 < 0)
      {
        BOOL v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v22 = 5381;
        do
        {
          uint64_t v20 = v22;
          unsigned int v23 = *v21++;
          uint64_t v22 = (33 * v22) ^ v23;
        }
        while (v23);
      }
      std::mutex::lock(v18);
      *(void *)long long buf = v20;
      id v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
      if (v24)
      {
        uint64_t v26 = v24[3];
        id v25 = (std::__shared_weak_count *)v24[4];
        if (v25)
        {
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v19);
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v25);
          char v27 = 0;
LABEL_29:
          if (*((void *)&object + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&object + 1));
          }
          if (v26)
          {
            xpc_object_t v47 = v49;
            if (v49) {
              xpc_retain(v49);
            }
            else {
              xpc_object_t v47 = xpc_null_create();
            }
            v42 = objc_retainBlock(v7);
            *(void *)&long long object = off_1019A9E68;
            *((void *)&object + 1) = v42;
            p_long long object = &object;
            (*(void (**)(uint64_t, xpc_object_t *, long long *))(*(void *)v26 + 144))(v26, &v47, &object);
            sub_1001E917C(&object);
            xpc_release(v47);
            xpc_object_t v47 = 0;
            if (v27) {
              goto LABEL_60;
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            BOOL v29 = *((void *)&object + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&object);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              LOWORD(object) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for testStewieCommand", (uint8_t *)&object, 2u);
            }
            unint64_t v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            v7[2](v7, v30, 0);

            if (v27) {
              goto LABEL_60;
            }
          }
          sub_10004D2C8(v25);
LABEL_60:
          xpc_release(v49);
          goto LABEL_61;
        }
      }
      else
      {
        uint64_t v26 = 0;
      }
      std::mutex::unlock(v19);
      id v25 = 0;
      char v27 = 1;
      goto LABEL_29;
    }
    NSErrorUserInfoKey v56 = NSLocalizedDescriptionKey;
    CFStringRef v57 = @"Command required";
    uint64_t v12 = +[NSDictionary dictionaryWithObjects:&v57 forKeys:&v56 count:1];
    unsigned int v13 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v12];

    v7[2](v7, v13, 0);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v11 = *((void *)&object + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&object);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(object) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid completion handler for testStewieCommand:completion: query", (uint8_t *)&object, 2u);
    }
  }
LABEL_61:
}

- (void)fetchRoadsideProvidersWithContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  [(CTXPCClientHandler *)self getLogContext];
  id v8 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Received fetchRoadsideProvidersWithContext: %@", (uint8_t *)&buf, 0xCu);
    if (v7)
    {
LABEL_3:
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
      unint64_t v10 = ServiceMap;
      if ((v11 & 0x8000000000000000) != 0)
      {
        uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v13 = 5381;
        do
        {
          unint64_t v11 = v13;
          unsigned int v14 = *v12++;
          uint64_t v13 = (33 * v13) ^ v14;
        }
        while (v14);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v23 = v11;
      uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v23);
      if (v15)
      {
        uint64_t v17 = v15[3];
        uint64_t v16 = (std::__shared_weak_count *)v15[4];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v10);
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          char v18 = 0;
LABEL_11:
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          if (v17)
          {
            id v19 = objc_retainBlock(v7);
            *(void *)&long long buf = off_1019A9EF8;
            *((void *)&buf + 1) = v19;
            p_long long buf = &buf;
            (*(void (**)(uint64_t, long long *))(*(void *)v17 + 120))(v17, &buf);
            sub_1001E971C(&buf);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v20 = *((void *)&buf + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for fetchRoadsideProvidersWithContext", (uint8_t *)&buf, 2u);
            }
            BOOL v21 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v21);
          }
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v16);
          }
          goto LABEL_23;
        }
      }
      else
      {
        uint64_t v17 = 0;
      }
      std::mutex::unlock(v10);
      uint64_t v16 = 0;
      char v18 = 1;
      goto LABEL_11;
    }
  }
  else if (v7)
  {
    goto LABEL_3;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v22 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetchRoadsideProvidersWithContext: query", (uint8_t *)&buf, 2u);
  }
LABEL_23:
}

- (void)selectRoadsideProviderWithContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  [(CTXPCClientHandler *)self getLogContext];
  id v8 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Received selectRoadsideProviderWithContext: %@", (uint8_t *)&buf, 0xCu);
    if (v7) {
      goto LABEL_3;
    }
LABEL_26:
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v26 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Invalid completion handler for selectRoadsideProviderWithContext", (uint8_t *)&buf, 2u);
    }
    goto LABEL_28;
  }
  if (!v7) {
    goto LABEL_26;
  }
LABEL_3:
  if (v6)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    char v27 = (std::__shared_weak_count *)v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v27);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_15:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v17)
        {
          BOOL v21 = (std::__shared_weak_count_vtbl *)[v6 providerId];
          uint64_t v22 = (std::__shared_weak_count *)operator new(0x28uLL);
          v22->__shared_owners_ = 0;
          v22->__shared_weak_owners_ = 0;
          v22->__vftable = (std::__shared_weak_count_vtbl *)off_1019A9F88;
          v22[1].__vftable = v21;
          LOBYTE(v22[1].__shared_owners_) = 1;
          char v27 = v22 + 1;
          BOOL v28 = v22;
          id v23 = objc_retainBlock(v7);
          *(void *)&long long buf = off_1019A9FD8;
          *((void *)&buf + 1) = v23;
          p_long long buf = &buf;
          (*(void (**)(uint64_t, std::__shared_weak_count **, long long *))(*(void *)v17 + 128))(v17, &v27, &buf);
          sub_1001E9A74(&buf);
          if (v28) {
            sub_10004D2C8(v28);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for selectRoadsideProviderWithContext", (uint8_t *)&buf, 2u);
          }
          id v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_15;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Context is required for selectRoadsideProviderWithContext", (uint8_t *)&buf, 2u);
  }
  uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v20);

LABEL_28:
}

- (void)getResumableRoadsideProvider:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v19 = v7;
    unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v19);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v13)
        {
          uint64_t v16 = (std::__shared_weak_count *)objc_retainBlock(v4);
          *(void *)long long buf = off_1019AA068;
          BOOL v21 = v16;
          uint64_t v22 = buf;
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v13 + 136))(v13, buf);
          sub_1001E9D80(buf);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v17 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find StewieInterface for getResumableRoadsideProvider", buf, 2u);
          }
          char v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v18);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getResumableRoadsideProvider: query", buf, 2u);
  }
LABEL_21:
}

- (void)getSmsReadyState:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          uint64_t v22 = objc_retainBlock(v7);
          v28[0] = off_1019ACA80;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 336))(v16, v21, v28);
          sub_100217B34(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SMS for getting ReadyState", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSmsReadyState", (uint8_t *)&v25, 2u);
  }
LABEL_26:
}

- (void)getSmscAddress:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          uint64_t v22 = objc_retainBlock(v7);
          v28[0] = off_1019ACB10;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 344))(v16, v21, v28);
          sub_100217EB0(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SMS for getting ReadyState", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSmscAddress", (uint8_t *)&v25, 2u);
  }
LABEL_26:
}

- (void)getEmergencyTextNumbers:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          uint64_t v22 = objc_retainBlock(v7);
          v28[0] = off_1019ACBA0;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 368))(v16, v21, v28);
          sub_100218320(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SMS for getting ReadyState", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getEmergencyTextNumbers", (uint8_t *)&v25, 2u);
  }
LABEL_26:
}

- (void)setUIConfiguredApns:(id)a3 apns:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (v10)
  {
    if (v8)
    {
      if (v9)
      {
        [(CTXPCClientHandler *)self registry];
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
        uint64_t v12 = ServiceMap;
        if (v13 < 0)
        {
          char v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v15 = 5381;
          do
          {
            uint64_t v13 = v15;
            unsigned int v16 = *v14++;
            uint64_t v15 = (33 * v15) ^ v16;
          }
          while (v16);
        }
        std::mutex::lock(ServiceMap);
        *(void *)&long long v40 = v13;
        char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&v40);
        if (v17)
        {
          uint64_t v19 = v17[3];
          char v18 = (std::__shared_weak_count *)v17[4];
          if (v18)
          {
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v12);
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v18);
            char v20 = 0;
LABEL_20:
            if (v37) {
              sub_10004D2C8(v37);
            }
            if (v19)
            {
              id v25 = [v8 slotID];
              if (v25 == (id)2) {
                int v26 = 2;
              }
              else {
                int v26 = v25 == (id)1;
              }
              *(void *)long long buf = 0;
              unsigned int v37 = 0;
              sub_10022EDC4(v19, buf);
              unint64_t v27 = *(Registry **)buf;
              if (*(void *)buf)
              {
                [(CTXPCClientHandler *)self registry];
                id v28 = objc_retainBlock(v10);
                unint64_t v39 = 0;
                BOOL v29 = (char *)operator new(0x28uLL);
                *(void *)BOOL v29 = off_1019AD248;
                *(_OWORD *)(v29 + 8) = v35;
                *((_DWORD *)v29 + 6) = v26;
                *((void *)v29 + 4) = v28;
                unint64_t v39 = v29;
                (*(void (**)(Registry *, id, void *))(*(void *)v27 + 104))(v27, v9, v38);
                sub_100060644(v38);
              }
              else
              {
                [(CTXPCClientHandler *)self getLogContext];
                unint64_t v32 = *((void *)&v40 + 1);
                ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v40);
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v34 = subscriber::asString();
                  LODWORD(v40) = 136315138;
                  *(void *)((char *)&v40 + 4) = v34;
                  _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not find UI_APN_Storage %s for setting UI apns", (uint8_t *)&v40, 0xCu);
                }
                id v33 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
                (*((void (**)(id, id))v10 + 2))(v10, v33);
              }
              if (v37) {
                sub_10004D2C8(v37);
              }
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              unint64_t v30 = v37;
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Could not find APN_StorageMgrInterface for setting UI apns", buf, 2u);
              }
              id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:6 userInfo:0];
              (*((void (**)(id, id))v10 + 2))(v10, v31);
            }
            if ((v20 & 1) == 0) {
              sub_10004D2C8(v18);
            }
            goto LABEL_38;
          }
        }
        else
        {
          uint64_t v19 = 0;
        }
        std::mutex::unlock(v12);
        char v18 = 0;
        char v20 = 1;
        goto LABEL_20;
      }
      [(CTXPCClientHandler *)self getLogContext];
      id v24 = v37;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid apns for setting UI apns", buf, 2u);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v22 = v37;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid context for setting UI apns", buf, 2u);
      }
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, id))v10 + 2))(v10, v23);

    goto LABEL_38;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v21 = v37;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting UI apns", buf, 2u);
  }
LABEL_38:
}

- (void)getUIConfiguredApns:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v28);
      id v9 = ServiceMap;
      if (v10 < 0)
      {
        unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          uint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&long long buf = v10;
      char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&buf);
      if (v14)
      {
        uint64_t v16 = v14[3];
        uint64_t v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (v29) {
            sub_10004D2C8(v29);
          }
          if (v16)
          {
            [v6 slotID];
            id v28 = 0;
            BOOL v29 = 0;
            sub_10022EDC4(v16, &v28);
            uint64_t v21 = v28;
            if (v28)
            {
              id v22 = objc_retainBlock(v7);
              v30[0] = off_1019AD2C8;
              v30[1] = v22;
              v30[3] = v30;
              (*(void (**)(Registry *, void *))(*(void *)v21 + 120))(v21, v30);
              sub_10010E020(v30);
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              id v25 = *((void *)&buf + 1);
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              {
                uint64_t v27 = subscriber::asString();
                LODWORD(buf) = 136315138;
                *(void *)((char *)&buf + 4) = v27;
                _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find UI_APN_Storage %s for getting UI apns", (uint8_t *)&buf, 0xCu);
              }
              id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
              (*((void (**)(id, void, id))v7 + 2))(v7, 0, v26);
            }
            if (v29) {
              sub_10004D2C8(v29);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v23 = v29;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v28) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find APN_StorageMgrInterface for getting UI apns", (uint8_t *)&v28, 2u);
            }
            id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:6 userInfo:0];
            (*((void (**)(id, void, id))v7 + 2))(v7, 0, v24);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_31;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      uint64_t v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v28) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid context for getting UI apns", (uint8_t *)&v28, 2u);
    }
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, id))v7 + 2))(v7, 0, v20);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v28) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting UI apns", (uint8_t *)&v28, 2u);
    }
  }
LABEL_31:
}

- (void)resetUIConfiguredApns:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      id v9 = ServiceMap;
      if (v10 < 0)
      {
        unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          uint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&long long v36 = v10;
      char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v36);
      if (v14)
      {
        uint64_t v16 = v14[3];
        uint64_t v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (v33) {
            sub_10004D2C8(v33);
          }
          if (v16)
          {
            id v21 = [v6 slotID];
            if (v21 == (id)2) {
              int v22 = 2;
            }
            else {
              int v22 = v21 == (id)1;
            }
            *(void *)long long buf = 0;
            id v33 = 0;
            sub_10022EDC4(v16, buf);
            id v23 = *(Registry **)buf;
            if (*(void *)buf)
            {
              [(CTXPCClientHandler *)self registry];
              id v24 = objc_retainBlock(v7);
              long long v35 = 0;
              id v25 = (char *)operator new(0x28uLL);
              *(void *)id v25 = off_1019AD358;
              *(_OWORD *)(v25 + 8) = v31;
              *((_DWORD *)v25 + 6) = v22;
              *((void *)v25 + 4) = v24;
              long long v35 = v25;
              (*(void (**)(Registry *, void, void *))(*(void *)v23 + 96))(v23, 0, v34);
              sub_10003B34C(v34);
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              id v28 = *((void *)&v36 + 1);
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v36);
              if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
              {
                uint64_t v30 = subscriber::asString();
                LODWORD(v36) = 136315138;
                *(void *)((char *)&v36 + 4) = v30;
                _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Could not find UI_APN_Storage %s for resetting UI apns", (uint8_t *)&v36, 0xCu);
              }
              id v29 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
              (*((void (**)(id, id))v7 + 2))(v7, v29);
            }
            if (v33) {
              sub_10004D2C8(v33);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v26 = v33;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find APN_StorageMgrInterface for resetting UI apns", buf, 2u);
            }
            id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:6 userInfo:0];
            (*((void (**)(id, id))v7 + 2))(v7, v27);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_34;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      uint64_t v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v33;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid context for resetting UI apns", buf, 2u);
    }
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, id))v7 + 2))(v7, v20);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = v33;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for resetting UI apns", buf, 2u);
    }
  }
LABEL_34:
}

- (void)getConfiguredApns:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
    id v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v26 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v26);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (v25) {
          sub_10004D2C8(v25);
        }
        if (v16)
        {
          id v19 = [v6 slotID];
          if (v19 == (id)2) {
            uint64_t v20 = 2;
          }
          else {
            uint64_t v20 = v19 == (id)1;
          }
          id v21 = objc_retainBlock(v7);
          v27[0] = off_1019AD3D8;
          v27[1] = v21;
          v27[3] = v27;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 104))(v16, v20, v27);
          sub_10023197C(v27);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          int v22 = v25;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v24) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find PDPConfigInterface for retrieving configured apns", (uint8_t *)&v24, 2u);
          }
          id v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:6 userInfo:0];
          (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v23);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v18 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v24) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "getConfiguredApns, no completion", (uint8_t *)&v24, 2u);
  }
LABEL_24:
}

- (void)getGSMAUIControlSetting:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, uint64_t, void *))a4;
  if (v7)
  {
    id v8 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:6 userInfo:0];
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v26 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v26);
    if (v15)
    {
      char v17 = (uint64_t (***)(void, uint64_t))v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v25) {
          sub_10004D2C8(v25);
        }
        if (v17)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          int v22 = (**v17)(v17, v21);
          if (v22 == 2) {
            uint64_t v23 = 2;
          }
          else {
            uint64_t v23 = v22 == 1;
          }

          id v8 = 0;
        }
        else
        {
          uint64_t v23 = 2;
        }
        v7[2](v7, v23, v8);
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }

        goto LABEL_26;
      }
    }
    else
    {
      char v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v24) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "getGSMAUIControlSetting, no completion", (uint8_t *)&v24, 2u);
  }
LABEL_26:
}

- (void)loadGSMASettings:(id)a3 state:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = (void (**)(id, void *))a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v20 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "loadGSMASettings, no completion", (uint8_t *)&v24, 2u);
    }
    goto LABEL_21;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
  unint64_t v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v26);
  if (!v16)
  {
    uint64_t v18 = 0;
    goto LABEL_11;
  }
  uint64_t v18 = v16[3];
  char v17 = (std::__shared_weak_count *)v16[4];
  if (!v17)
  {
LABEL_11:
    std::mutex::unlock(v11);
    char v17 = 0;
    char v19 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
LABEL_12:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (!v18
    || ((v21 = [v8 slotID], v21 != (id)2) ? (uint64_t v22 = v21 == (id)1) : (uint64_t v22 = 2),
        !(*(unsigned int (**)(uint64_t, uint64_t, BOOL))(*(void *)v18 + 8))(v18, v22, v6)))
  {
    uint64_t v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:6 userInfo:0];
    v9[2](v9, v23);

    if (v19) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  v9[2](v9, 0);
  if ((v19 & 1) == 0) {
LABEL_20:
  }
    sub_10004D2C8(v17);
LABEL_21:
}

- (void)deletePersonalWallet:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v34);
      id v9 = ServiceMap;
      if (v10 < 0)
      {
        unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          uint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v10;
      uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
      if (v14)
      {
        uint64_t v16 = v14[3];
        unsigned int v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      unsigned int v15 = 0;
      char v17 = 1;
LABEL_19:
      sub_100058DB0(__p, (char *)[v6 UTF8String]);
      if (SHIBYTE(v31) < 0)
      {
        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)__p;
        uint64_t v33 = v31;
      }
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v16 + 112))(v16, buf);
      if (SHIBYTE(v33) < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v31) < 0)
      {
        operator delete(__p[0]);
        if (v17)
        {
LABEL_27:
          id v29 = v35;
          if (!v35)
          {
LABEL_29:
            v7[2](v7, 0);
            goto LABEL_30;
          }
LABEL_28:
          sub_10004D2C8(v29);
          goto LABEL_29;
        }
      }
      else if (v17)
      {
        goto LABEL_27;
      }
      sub_10004D2C8(v15);
      goto LABEL_27;
    }
    [(CTXPCClientHandler *)self registry];
    char v19 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v20 = v19;
    if (v21 < 0)
    {
      uint64_t v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v23 = 5381;
      do
      {
        uint64_t v21 = v23;
        unsigned int v24 = *v22++;
        uint64_t v23 = (33 * v23) ^ v24;
      }
      while (v24);
    }
    std::mutex::lock(v19);
    __p[0] = (void *)v21;
    id v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)__p);
    if (v25)
    {
      uint64_t v26 = v25[3];
      id v27 = (std::__shared_weak_count *)v25[4];
      if (v27)
      {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v27);
        char v28 = 0;
        goto LABEL_35;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v20);
    id v27 = 0;
    char v28 = 1;
LABEL_35:
    (*(void (**)(uint64_t))(*(void *)v26 + 120))(v26);
    if ((v28 & 1) == 0) {
      sub_10004D2C8(v27);
    }
    id v29 = *(std::__shared_weak_count **)&buf[8];
    if (!*(void *)&buf[8]) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v18 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "deletePersonalWallet, no completion", buf, 2u);
  }
LABEL_30:
}

- (void)renamePersonalWallet:(id)a3 to:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void))a5;
  if (v10)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v30);
    uint64_t v12 = ServiceMap;
    if (v13 < 0)
    {
      uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v13;
    char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
    if (v17)
    {
      uint64_t v19 = v17[3];
      uint64_t v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    uint64_t v18 = 0;
    char v20 = 1;
LABEL_12:
    sub_100058DB0(v26, (char *)[v8 UTF8String]);
    if (SHIBYTE(v27) < 0)
    {
      sub_10004FC84(buf, v26[0], (unint64_t)v26[1]);
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)v26;
      uint64_t v29 = v27;
    }
    sub_100058DB0(v22, (char *)[v9 UTF8String]);
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(__p, v22[0], (unint64_t)v22[1]);
    }
    else
    {
      *(_OWORD *)__p = *(_OWORD *)v22;
      uint64_t v25 = v23;
    }
    (*(void (**)(uint64_t, uint8_t *, void **))(*(void *)v19 + 96))(v19, buf, __p);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(v22[0]);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(v27) < 0)
    {
      operator delete(v26[0]);
      if (v20) {
        goto LABEL_27;
      }
    }
    else if (v20)
    {
LABEL_27:
      if (v31) {
        sub_10004D2C8(v31);
      }
      v10[2](v10, 0);
      goto LABEL_30;
    }
    sub_10004D2C8(v18);
    goto LABEL_27;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v21 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "renamePersonalWallet, no completion", buf, 2u);
  }
LABEL_30:
}

- (void)listPersonalWallets:(id)a3
{
  id v4 = (void (**)(id, id, void))a3;
  if (v4)
  {
    *(void *)long long buf = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v22);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v7;
    unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v27);
    if (v11)
    {
      uint64_t v12 = v11[3];
      uint64_t v13 = (std::__shared_weak_count *)v11[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v14 = 0;
LABEL_12:
        (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v12 + 80))(buf, v12, 0);
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        if (v23) {
          sub_10004D2C8(v23);
        }
        id v16 = objc_alloc((Class)NSMutableArray);
        id v17 = [v16 initWithCapacity:0xAAAAAAAAAAAAAAABLL * (((uint64_t)v25 - *(void *)buf) >> 3)];
        uint64_t v18 = *(NSObject **)buf;
        for (i = v25; v18 != i; v18 += 3)
        {
          isa = (uint64_t *)v18;
          if (SHIBYTE(v18[2].isa) < 0) {
            isa = (uint64_t *)v18->isa;
          }
          uint64_t v21 = +[NSString stringWithUTF8String:isa];
          [v17 addObject:v21];
        }
        v4[2](v4, v17, 0);

        uint64_t v22 = (Registry *)buf;
        sub_100047F64((void ***)&v22);
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v13 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "listPersonalWallets, no completion", buf, 2u);
  }
LABEL_21:
}

- (void)transferPersonalWallet:(id)a3 to:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unsigned int v10 = (void (**)(id, void))a5;
  if (v10)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v27);
    uint64_t v12 = ServiceMap;
    if (v13 < 0)
    {
      char v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v13;
    id v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
    if (v17)
    {
      uint64_t v19 = v17[3];
      uint64_t v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    uint64_t v18 = 0;
    char v20 = 1;
LABEL_12:
    sub_100058DB0(buf, (char *)[v8 UTF8String]);
    sub_100058DB0(__p, (char *)[v9 UTF8String]);
    (*(void (**)(uint64_t, uint8_t *, void **))(*(void *)v19 + 272))(v19, buf, __p);
    if (v23 < 0) {
      operator delete(__p[0]);
    }
    if (v26 < 0)
    {
      operator delete(*(void **)buf);
      if (v20) {
        goto LABEL_17;
      }
    }
    else if (v20)
    {
LABEL_17:
      if (v28) {
        sub_10004D2C8(v28);
      }
      v10[2](v10, 0);
      goto LABEL_20;
    }
    sub_10004D2C8(v18);
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v21 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "transferPersonalWallet, no completion", buf, 2u);
  }
LABEL_20:
}

- (id)validateParametersWithContext:(id)a3 keys:(id)a4 bundleType:(id)a5 personalityInfo:(void *)a6 slot:(int *)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = v12;
  unsigned int v16 = [(CTXPCClientHandler *)self dataProviderDelegate];
  id v17 = [v16 resolveContext:v15];

  if (!v15)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v30 = v46;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v31 = "Invalid Subscription Context";
LABEL_16:
    _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, v31, buf, 2u);
    goto LABEL_17;
  }
  if (!v13)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v30 = v46;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v31 = "Invalid key(s) or key hierarchy/(ies)";
    goto LABEL_16;
  }
  if (!v14)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v30 = v46;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v31 = "Invalid bundle type";
      goto LABEL_16;
    }
LABEL_17:
    unint64_t v32 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    goto LABEL_18;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  uint64_t v19 = ServiceMap;
  if (v20 < 0)
  {
    uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      uint64_t v20 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(ServiceMap);
  *(void *)v43 = v20;
  unsigned int v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)v43);
  v42 = a6;
  if (!v24)
  {
    uint64_t v27 = 0;
LABEL_23:
    std::mutex::unlock(v19);
    char v28 = 0;
    char v29 = 1;
    goto LABEL_24;
  }
  uint64_t v25 = v17;
  uint64_t v27 = v24[3];
  char v26 = (std::__shared_weak_count *)v24[4];
  if (!v26)
  {
    id v17 = v25;
    goto LABEL_23;
  }
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v19);
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  char v28 = v26;
  sub_10004D2C8(v26);
  id v17 = v25;
  char v29 = 0;
LABEL_24:
  if (v46) {
    sub_10004D2C8((std::__shared_weak_count *)v46);
  }
  if (v27)
  {
    *(void *)long long buf = 0;
    id v46 = 0;
    uint64_t v34 = [v15 uuid];
    sub_1005B09D4(v34, (CFUUIDRef *)v43);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v27 + 16))(buf, v27, *(void *)v43);
    sub_10012577C((const void **)v43);

    long long v35 = *(Registry **)buf;
    if (*(void *)buf)
    {
      long long v36 = (std::__shared_weak_count *)v46;
      if (v46) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)&v46[1], 1uLL, memory_order_relaxed);
      }
      unsigned int v37 = (std::__shared_weak_count *)v42[1];
      void *v42 = v35;
      v42[1] = v36;
      if (v37) {
        sub_10004D2C8(v37);
      }
      id v38 = [v17 slotID];
      unint64_t v32 = 0;
      int v39 = v38 == (id)1;
      if (v38 == (id)2) {
        int v39 = 2;
      }
      *a7 = v39;
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v41 = v44;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v43);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v43 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "Subscription Context does not have corresponding personality", v43, 2u);
      }
      unint64_t v32 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    }
    if (v46) {
      sub_10004D2C8((std::__shared_weak_count *)v46);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    long long v40 = v46;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
    }
    unint64_t v32 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
  }
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v28);
  }
LABEL_18:

  return v32;
}

- (void)copyCarrierBundleValue:(id)a3 key:(id)a4 bundleType:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(id, void, void *))a6;
  if (v13)
  {
    if (v11)
    {
      id v20 = v11;
      id v14 = +[NSArray arrayWithObjects:&v20 count:1];
      [(CTXPCClientHandler *)self universalGetCarrierBundleValue:v10 keyHierarchy:v14 bundleType:v12 withDefault:0 completion:v13];
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      unsigned int v16 = v19;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v18 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid key", v18, 2u);
      }
      id v17 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v13[2](v13, 0, v17);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v15 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v18 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler", v18, 2u);
    }
  }
}

- (void)copyCarrierBundleValue:(id)a3 keyHierarchy:(id)a4 bundleType:(id)a5 completion:(id)a6
{
}

- (void)copyCarrierBundleValues:(id)a3 keys:(id)a4 defaultValues:(id)a5 bundleType:(id)a6 withFallbackBundleCheck:(BOOL)a7 completion:(id)a8
{
  void (**v47)(CFTypeRef *__return_ptr, void *, uint64_t, void, id, id, void);
  NSObject *v48;
  id v49;
  void *v50;
  void *v51;
  id v52;
  void *v53;
  id v54;
  CFTypeRef cf;
  void *v56;
  uint8_t v57[8];
  NSObject *v58;
  unsigned int v59;
  uint8_t buf[8];
  std::__shared_weak_count *v61;
  CFTypeRef v62;

  BOOL v9 = a7;
  id v14 = a3;
  id v15 = a4;
  CFStringRef v54 = a5;
  id v16 = a6;
  id v17 = (void (**)(id, void, void *))a8;
  if (v17)
  {
    long long v59 = 0;
    *(void *)long long buf = 0;
    long long v61 = 0;
    unsigned __int8 v52 = v14;
    NSErrorUserInfoKey v53 = v16;
    uint64_t v18 = [(CTXPCClientHandler *)self validateParametersWithContext:v14 keys:v15 bundleType:v16 personalityInfo:buf slot:&v59];
    if (v18)
    {
      v17[2](v17, 0, v18);
LABEL_30:

      if (v61) {
        sub_10004D2C8(v61);
      }
      id v14 = v52;
      id v16 = v53;
      goto LABEL_33;
    }
    if (!v54)
    {
      id v20 = [v15 count];
      if (v20 != [0 count])
      {
        [(CTXPCClientHandler *)self getLogContext];
        v42 = v58;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v57);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)CFStringRef v57 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Arrays of keys and defaults must be the same length.", v57, 2u);
        }
        v43 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        v17[2](v17, 0, v43);

        uint64_t v18 = 0;
        goto LABEL_30;
      }
    }
    NSErrorUserInfoKey v56 = 0;
    int v21 = *(unsigned __int8 *)(*(void *)buf + 49);
    if (v21 == 2)
    {
      [(CTXPCClientHandler *)self getLogContext];
      unint64_t v32 = v58;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v57);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        goto LABEL_20;
      }
      *(_WORD *)CFStringRef v57 = 0;
      uint64_t v33 = "Managed Personality multi-key fetch not supported yet";
    }
    else
    {
      if (v21 != 1)
      {
        if (!*(unsigned char *)(*(void *)buf + 49))
        {
          [(CTXPCClientHandler *)self registry];
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)v57);
          unsigned int v23 = ServiceMap;
          if (v24 < 0)
          {
            uint64_t v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v26 = 5381;
            do
            {
              uint64_t v24 = v26;
              unsigned int v27 = *v25++;
              uint64_t v26 = (33 * v26) ^ v27;
            }
            while (v27);
          }
          std::mutex::lock(ServiceMap);
          long long v62 = (CFTypeRef)v24;
          char v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)&v62);
          if (v28)
          {
            uint64_t v30 = (void *)v28[3];
            char v29 = (std::__shared_weak_count *)v28[4];
            if (v29)
            {
              atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v23);
              atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v29);
              char v31 = 0;
              goto LABEL_39;
            }
          }
          else
          {
            uint64_t v30 = 0;
          }
          std::mutex::unlock(v23);
          char v29 = 0;
          char v31 = 1;
LABEL_39:
          if (v58) {
            sub_10004D2C8((std::__shared_weak_count *)v58);
          }
          if (v30)
          {
            uint64_t v44 = v59;
            if (v9)
            {
              id v45 = [v53 type];
              if ((unint64_t)v45 >= 7) {
                unsigned __int8 v46 = 0;
              }
              else {
                unsigned __int8 v46 = v45;
              }
              xpc_object_t v47 = (void (**)(CFTypeRef *__return_ptr, void *, uint64_t, void, id, id, void))(*v30 + 168);
            }
            else
            {
              xpc_object_t v49 = [v53 type];
              if ((unint64_t)v49 >= 7) {
                unsigned __int8 v46 = 0;
              }
              else {
                unsigned __int8 v46 = v49;
              }
              xpc_object_t v47 = (void (**)(CFTypeRef *__return_ptr, void *, uint64_t, void, id, id, void))(*v30 + 160);
            }
            (*v47)(&cf, v30, v44, v46, v15, v54, 0);
            long long v62 = cf;
            if (cf)
            {
              CFRetain(cf);
              uint8_t v50 = (void *)v62;
            }
            else
            {
              uint8_t v50 = 0;
            }
            uint64_t v51 = v56;
            NSErrorUserInfoKey v56 = v50;
            *(void *)CFStringRef v57 = v51;
            long long v62 = 0;
            sub_1000577C4((const void **)v57);
            sub_1000577C4(&v62);
            sub_100044D00(&cf);
            uint64_t v18 = 0;
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            xpc_object_t v48 = v58;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v57);
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)CFStringRef v57 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Could not find CarrierSettingsInterface to copy carrier bundle key value", v57, 2u);
            }
            uint64_t v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          }
          if ((v31 & 1) == 0) {
            sub_10004D2C8(v29);
          }
          uint64_t v34 = v56;
          if (v18) {
            goto LABEL_29;
          }
          goto LABEL_21;
        }
LABEL_20:
        uint64_t v34 = v56;
LABEL_21:
        if ([(CTXPCClientHandler *)self restrictedPublicCarrierInfoKeys])
        {
          long long v35 = (char *)[v15 count];
          if (v35)
          {
            for (i = 0; i != v35; ++i)
            {
              unsigned int v37 = [v15 objectAtIndexedSubscript:i];
              unsigned __int8 v38 = [v37 isEqualToString:@"CarrierName"];

              CFStringRef v39 = @"--";
              if ((v38 & 1) == 0)
              {
                long long v40 = [v15 objectAtIndexedSubscript:i];
                unsigned int v41 = [v40 isEqualToString:@"AllowVOIP"];

                CFStringRef v39 = (const __CFString *)&__kCFBooleanTrue;
                if (!v41) {
                  continue;
                }
              }
              [v34 setObject:v39 atIndexedSubscript:i];
            }
          }
        }
        uint64_t v18 = 0;
LABEL_29:
        ((void (**)(id, void *, void *))v17)[2](v17, v34, v18);

        sub_1000577C4((const void **)&v56);
        goto LABEL_30;
      }
      [(CTXPCClientHandler *)self getLogContext];
      unint64_t v32 = v58;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v57);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
        goto LABEL_20;
      }
      *(_WORD *)CFStringRef v57 = 0;
      uint64_t v33 = "Cloud multi-key fetch not supported yet";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, v33, v57, 2u);
    goto LABEL_20;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v61;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
  }
LABEL_33:
}

- (void)copyCarrierBundleValues:(id)a3 keyHierarchies:(id)a4 defaultValues:(id)a5 bundleType:(id)a6 withFallbackBundleCheck:(BOOL)a7 completion:(id)a8
{
  BOOL v9 = a7;
  id v14 = a3;
  id v15 = a4;
  id v16 = a5;
  id v17 = a6;
  uint64_t v18 = (void (**)(id, void, void *))a8;
  if (v18)
  {
    unsigned __int8 v52 = v17;
    unsigned int v57 = 0;
    *(void *)long long buf = 0;
    long long v59 = 0;
    id v51 = v14;
    uint64_t v19 = [(CTXPCClientHandler *)self validateParametersWithContext:v14 keys:v15 bundleType:v17 personalityInfo:buf slot:&v57];
    if (v19)
    {
      v18[2](v18, 0, v19);
LABEL_30:

      if (v59) {
        sub_10004D2C8(v59);
      }
      id v14 = v51;
      id v17 = v52;
      goto LABEL_33;
    }
    if (!v16)
    {
      id v21 = [v15 count];
      if (v21 != [0 count])
      {
        [(CTXPCClientHandler *)self getLogContext];
        v43 = v56;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v55);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long v55 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Arrays of key hierarchies and defaults must be the same length.", v55, 2u);
        }
        uint64_t v44 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        v18[2](v18, 0, v44);

        uint64_t v19 = 0;
        goto LABEL_30;
      }
    }
    CFStringRef v54 = 0;
    int v22 = *(unsigned __int8 *)(*(void *)buf + 49);
    if (v22 == 2)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v33 = v56;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v55);
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        goto LABEL_20;
      }
      *(_WORD *)long long v55 = 0;
      uint64_t v34 = "Managed Personality multi-key fetch not supported yet";
    }
    else
    {
      if (v22 != 1)
      {
        if (!*(unsigned char *)(*(void *)buf + 49))
        {
          [(CTXPCClientHandler *)self registry];
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)v55);
          uint64_t v24 = ServiceMap;
          if (v25 < 0)
          {
            uint64_t v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v27 = 5381;
            do
            {
              uint64_t v25 = v27;
              unsigned int v28 = *v26++;
              uint64_t v27 = (33 * v27) ^ v28;
            }
            while (v28);
          }
          std::mutex::lock(ServiceMap);
          CFTypeRef v60 = (CFTypeRef)v25;
          char v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)&v60);
          if (v29)
          {
            uint64_t v31 = v29[3];
            uint64_t v30 = (std::__shared_weak_count *)v29[4];
            if (v30)
            {
              atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v24);
              atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v30);
              char v32 = 0;
              goto LABEL_39;
            }
          }
          else
          {
            uint64_t v31 = 0;
          }
          std::mutex::unlock(v24);
          uint64_t v30 = 0;
          char v32 = 1;
LABEL_39:
          if (v56) {
            sub_10004D2C8((std::__shared_weak_count *)v56);
          }
          if (v31)
          {
            uint64_t v45 = v57;
            id v46 = [v52 type];
            if ((unint64_t)v46 >= 7) {
              unsigned __int8 v47 = 0;
            }
            else {
              unsigned __int8 v47 = v46;
            }
            (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, void, id, id, BOOL, void))(*(void *)v31 + 176))(&cf, v31, v45, v47, v15, v16, v9, 0);
            CFTypeRef v60 = cf;
            if (cf)
            {
              CFRetain(cf);
              xpc_object_t v48 = (void *)v60;
            }
            else
            {
              xpc_object_t v48 = 0;
            }
            uint8_t v50 = v54;
            CFStringRef v54 = v48;
            *(void *)long long v55 = v50;
            CFTypeRef v60 = 0;
            sub_1000577C4((const void **)v55);
            sub_1000577C4(&v60);
            sub_100044D00(&cf);
            uint64_t v19 = 0;
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            xpc_object_t v49 = v56;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v55);
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long v55 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "Could not find CarrierSettingsInterface to copy carrier bundle key value", v55, 2u);
            }
            uint64_t v19 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          }
          if ((v32 & 1) == 0) {
            sub_10004D2C8(v30);
          }
          long long v35 = v54;
          if (v19) {
            goto LABEL_29;
          }
          goto LABEL_21;
        }
LABEL_20:
        long long v35 = v54;
LABEL_21:
        if ([(CTXPCClientHandler *)self restrictedPublicCarrierInfoKeys])
        {
          long long v36 = (char *)[v15 count];
          if (v36)
          {
            for (i = 0; i != v36; ++i)
            {
              unsigned __int8 v38 = [v15 objectAtIndexedSubscript:i];
              unsigned __int8 v39 = [v38 containsObject:@"CarrierName"];

              CFStringRef v40 = @"--";
              if ((v39 & 1) == 0)
              {
                unsigned int v41 = [v15 objectAtIndexedSubscript:i];
                unsigned int v42 = [v41 containsObject:@"AllowVOIP"];

                CFStringRef v40 = (const __CFString *)&__kCFBooleanTrue;
                if (!v42) {
                  continue;
                }
              }
              [v35 setObject:v40 atIndexedSubscript:i];
            }
          }
        }
        uint64_t v19 = 0;
LABEL_29:
        ((void (**)(id, void *, void *))v18)[2](v18, v35, v19);

        sub_1000577C4((const void **)&v54);
        goto LABEL_30;
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v33 = v56;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v55);
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        goto LABEL_20;
      }
      *(_WORD *)long long v55 = 0;
      uint64_t v34 = "Cloud multi-key fetch not supported yet";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, v34, v55, 2u);
    goto LABEL_20;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v20 = v59;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
  }
LABEL_33:
}

- (void)copyCarrierBundleValueWithDefault:(id)a3 key:(id)a4 bundleType:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(id, void, void *))a6;
  if (v13)
  {
    if (v11)
    {
      id v20 = v11;
      id v14 = +[NSArray arrayWithObjects:&v20 count:1];
      [(CTXPCClientHandler *)self universalGetCarrierBundleValue:v10 keyHierarchy:v14 bundleType:v12 withDefault:1 completion:v13];
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v16 = v19;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v18 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid key", v18, 2u);
      }
      id v17 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v13[2](v13, 0, v17);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v15 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v18 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler", v18, 2u);
    }
  }
}

- (void)copyCarrierBundleValueWithDefault:(id)a3 keyHierarchy:(id)a4 bundleType:(id)a5 completion:(id)a6
{
}

- (void)universalGetCarrierBundleValue:(id)a3 keyHierarchy:(id)a4 bundleType:(id)a5 withDefault:(BOOL)a6 completion:(id)a7
{
  void (***v41)(uint8_t *__return_ptr, void, uint64_t);
  char v42;
  CFStringRef v43;
  uint64_t v44;
  id v45;
  unsigned __int8 v46;
  void (**v47)(long long *__return_ptr, void *, uint64_t, void, void **, void, void);
  NSObject *v48;
  NSObject *v49;
  std::__shared_weak_count *v50;
  id v51;
  const char *v52;
  uint64_t v53;
  int v54;
  CFStringRef v55;
  void *__p[2];
  uint64_t v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  unsigned int v60;
  uint8_t buf[16];
  uint64_t v62;
  CFStringRef v63;
  long long context;
  CFRange v65;

  BOOL v8 = a6;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = (void (**)(id, const __CFString *, void))a7;
  if (v15)
  {
    if ([v13 containsObject:@"CarrierName"])
    {
      if ([(CTXPCClientHandler *)self restrictedPublicCarrierInfoKeys])
      {
        CFStringRef v16 = @"--";
LABEL_10:
        v15[2](v15, v16, 0);
        goto LABEL_71;
      }
    }
    else if ([v13 containsObject:@"AllowVOIP"] {
           && [(CTXPCClientHandler *)self restrictedPublicCarrierInfoKeys])
    }
    {
      CFStringRef v16 = (const __CFString *)&__kCFBooleanTrue;
      goto LABEL_10;
    }
    CFTypeRef v60 = 0;
    v58 = 0;
    long long v59 = 0;
    uint64_t v18 = [(CTXPCClientHandler *)self validateParametersWithContext:v12 keys:v13 bundleType:v14 personalityInfo:&v58 slot:&v60];
    if (v18)
    {
      ((void (**)(id, const __CFString *, void *))v15)[2](v15, 0, v18);
LABEL_69:

      if (v59) {
        sub_10004D2C8(v59);
      }
      goto LABEL_71;
    }
    unsigned int v57 = 0;
    long long v19 = 0uLL;
    *(_OWORD *)__p = 0u;
    long long v62 = 0;
    *(_OWORD *)long long buf = 0u;
    *(void *)&context = buf;
    if (v13)
    {
      v65.length = CFArrayGetCount((CFArrayRef)v13);
      v65.location = 0;
      CFArrayApplyFunction((CFArrayRef)v13, v65, (CFArrayApplierFunction)sub_1002CED68, &context);
      long long v19 = *(_OWORD *)buf;
      uint64_t v20 = v62;
    }
    else
    {
      uint64_t v20 = 0;
    }
    int v21 = *(unsigned __int8 *)(v58 + 49);
    *(_OWORD *)__p = v19;
    unsigned int v57 = v20;
    long long v55 = 0;
    if (v21 == 2)
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v32 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Managed Personality not supported yet", buf, 2u);
      }
      uint64_t v18 = 0;
      goto LABEL_67;
    }
    if (v21 != 1)
    {
      uint64_t v18 = 0;
      if (v21) {
        goto LABEL_67;
      }
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      unsigned int v23 = ServiceMap;
      if (v24 < 0)
      {
        uint64_t v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v26 = 5381;
        do
        {
          uint64_t v24 = v26;
          unsigned int v27 = *v25++;
          uint64_t v26 = (33 * v26) ^ v27;
        }
        while (v27);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&context = v24;
      unsigned int v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)&context);
      if (v28)
      {
        uint64_t v30 = (void *)v28[3];
        char v29 = (std::__shared_weak_count *)v28[4];
        if (v29)
        {
          atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v23);
          atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v29);
          char v31 = 0;
LABEL_44:
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          if (v30)
          {
            uint64_t v44 = v60;
            if (v8)
            {
              uint64_t v45 = [v14 type];
              if ((unint64_t)v45 >= 7) {
                id v46 = 0;
              }
              else {
                id v46 = v45;
              }
              unsigned __int8 v47 = (void (**)(long long *__return_ptr, void *, uint64_t, void, void **, void, void))(*v30 + 104);
            }
            else
            {
              id v51 = [v14 type];
              if ((unint64_t)v51 >= 7) {
                id v46 = 0;
              }
              else {
                id v46 = v51;
              }
              unsigned __int8 v47 = (void (**)(long long *__return_ptr, void *, uint64_t, void, void **, void, void))(*v30 + 88);
            }
            (*v47)(&context, v30, v44, v46, __p, 0, 0);
            *(void *)long long buf = v55;
            long long v55 = (const __CFString *)context;
            *(void *)&context = 0;
            sub_1000577C4((const void **)buf);
            sub_1000577C4((const void **)&context);
            uint64_t v18 = 0;
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            xpc_object_t v48 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Could not find CarrierSettingsInterface to copy carrier bundle key value", buf, 2u);
            }
            uint64_t v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          }
          if (v31) {
            goto LABEL_67;
          }
          uint8_t v50 = v29;
          goto LABEL_66;
        }
      }
      else
      {
        uint64_t v30 = 0;
      }
      std::mutex::unlock(v23);
      char v29 = 0;
      char v31 = 1;
      goto LABEL_44;
    }
    memset(buf, 0, sizeof(buf));
    [(CTXPCClientHandler *)self registry];
    uint64_t v33 = (std::mutex *)Registry::getServiceMap((Registry *)context);
    uint64_t v34 = v33;
    if (v35 < 0)
    {
      long long v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v37 = 5381;
      do
      {
        uint64_t v35 = v37;
        unsigned int v38 = *v36++;
        uint64_t v37 = (33 * v37) ^ v38;
      }
      while (v38);
    }
    std::mutex::lock(v33);
    long long v63 = (const __CFString *)v35;
    unsigned __int8 v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)&v63);
    if (v39)
    {
      unsigned int v41 = (void (***)(uint8_t *__return_ptr, void, uint64_t))v39[3];
      CFStringRef v40 = (std::__shared_weak_count *)v39[4];
      if (v40)
      {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v34);
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v40);
        unsigned int v42 = 0;
        goto LABEL_36;
      }
    }
    else
    {
      unsigned int v41 = 0;
    }
    std::mutex::unlock(v34);
    CFStringRef v40 = 0;
    unsigned int v42 = 1;
LABEL_36:
    (**v41)(buf, v41, v58 + 24);
    if ((v42 & 1) == 0) {
      sub_10004D2C8(v40);
    }
    if (*((void *)&context + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&context + 1));
    }
    if (*(void *)buf)
    {
      (*(void (**)(const __CFString **__return_ptr))(**(void **)buf + 120))(&v63);
      v43 = v55;
      long long v55 = v63;
      long long v63 = 0;
      *(void *)&context = v43;
      sub_1000577C4((const void **)&context);
      sub_1000577C4((const void **)&v63);
      uint64_t v18 = 0;
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      xpc_object_t v49 = *((void *)&context + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&context);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        unsigned __int8 v52 = (const char *)(v58 + 24);
        NSErrorUserInfoKey v53 = *(unsigned __int8 *)(v58 + 47);
        CFStringRef v54 = (char)v53;
        if ((v53 & 0x80u) != 0) {
          NSErrorUserInfoKey v53 = *(void *)(v58 + 32);
        }
        if (v54 < 0) {
          unsigned __int8 v52 = *(const char **)(v58 + 24);
        }
        if (!v53) {
          unsigned __int8 v52 = "<invalid>";
        }
        LODWORD(context) = 136315138;
        *(void *)((char *)&context + 4) = v52;
        _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "Could not find PhoneServices for personality %s", (uint8_t *)&context, 0xCu);
      }
      uint64_t v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
    }
    uint8_t v50 = *(std::__shared_weak_count **)&buf[8];
    if (!*(void *)&buf[8]) {
      goto LABEL_67;
    }
LABEL_66:
    sub_10004D2C8(v50);
LABEL_67:
    ((void (**)(id, const __CFString *, void *))v15)[2](v15, v55, v18);
    sub_1000577C4((const void **)&v55);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    goto LABEL_69;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v17 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
  }
LABEL_71:
}

- (void)copyCarrierBundleValueWithCountryBundleLookup:(id)a3 keyHierarchy:(id)a4 matchingInfo:(id)a5 completion:(id)a6
{
  id v10 = a3;
  CFArrayRef v11 = (const __CFArray *)a4;
  id v12 = a5;
  id v13 = (void (**)(id, void, id))a6;
  if (v13)
  {
    id v14 = [(CTXPCClientHandler *)self dataProviderDelegate];
    uint64_t v15 = [v14 resolveContext:v10];

    if (v15)
    {
      if (v11)
      {
        if (v12)
        {
          uint64_t v16 = (uint64_t)[v12 imsi];
          unint64_t v17 = (unint64_t)[v12 mcc];
          if (v16 | v17)
          {
            [(CTXPCClientHandler *)self registry];
            ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
            long long v19 = ServiceMap;
            if (v20 < 0)
            {
              int v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v22 = 5381;
              do
              {
                uint64_t v20 = v22;
                unsigned int v23 = *v21++;
                uint64_t v22 = (33 * v22) ^ v23;
              }
              while (v23);
            }
            std::mutex::lock(ServiceMap);
            v50[0] = (void *)v20;
            uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)v50);
            CFTypeRef v45 = (CFTypeRef)v17;
            if (v24)
            {
              uint64_t v25 = v24[3];
              uint64_t v26 = (std::__shared_weak_count *)v24[4];
              if (v26)
              {
                atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v19);
                atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
                unsigned int v27 = v26;
                sub_10004D2C8(v26);
                char v28 = 0;
                goto LABEL_30;
              }
            }
            else
            {
              uint64_t v25 = 0;
            }
            std::mutex::unlock(v19);
            unsigned int v27 = 0;
            char v28 = 1;
LABEL_30:
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            if (!v25)
            {
              [(CTXPCClientHandler *)self getLogContext];
              unsigned int v38 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Could not find CarrierBundleHandler to do CountryBundle lookup.", buf, 2u);
              }
              id v39 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
              v13[2](v13, 0, v39);

              goto LABEL_76;
            }
            *(void *)long long v55 = 0;
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (Mutable)
            {
              uint64_t v37 = *(__CFDictionary **)v55;
              *(void *)long long v55 = Mutable;
              *(void *)long long buf = v37;
              sub_10005717C((const void **)buf);
            }
            if (v16)
            {
              sub_10010F3F0(*(__CFDictionary **)v55, (void *)qword_101B13EC0, v16);
LABEL_68:
              memset(buf, 0, sizeof(buf));
              *(void *)&long long v53 = 0;
              *(void *)&long long context = buf;
              v63.length = CFArrayGetCount(v11);
              v63.location = 0;
              CFArrayApplyFunction(v11, v63, (CFArrayApplierFunction)sub_1002CED68, &context);
              *(_OWORD *)uint8_t v50 = *(_OWORD *)buf;
              *(void *)&long long v51 = v53;
              *(void *)long long buf = 0;
              sub_10004EFE4(&v46, (CFTypeRef *)v55);
              (*(void (**)(uint8_t *__return_ptr, uint64_t, const void **, void **))(*(void *)v25 + 304))(buf, v25, &v46, v50);
              sub_100057D78(&v46);
              if (*(void *)buf) {
                v43 = sub_100080934;
              }
              else {
                v43 = 0;
              }
              if (!v43) {
                v13[2](v13, 0, 0);
              }
              ((void (*)(void (**)(id, void, id)))v13[2])(v13);
              sub_1000577C4((const void **)buf);
              if (v50[0])
              {
                v50[1] = v50[0];
                operator delete(v50[0]);
              }
              sub_10005717C((const void **)v55);
LABEL_76:
              if ((v28 & 1) == 0) {
                sub_10004D2C8(v27);
              }
              goto LABEL_26;
            }
            char v44 = v28;
            memset(v54, 0, 7);
            if (![v12 mnc])
            {
              sub_10010F3F0(*(__CFDictionary **)v55, (void *)qword_101B13EC0, (uint64_t)v45);
LABEL_67:
              char v28 = v44;
              goto LABEL_68;
            }
            *(_OWORD *)long long buf = 0u;
            long long v53 = 0u;
            v50[0] = 0;
            v50[1] = 0;
            *(void *)&long long v51 = 0;
            ctu::cf::assign();
            long long context = *(_OWORD *)v50;
            uint64_t v60 = v51;
            MCC::MCC();
            if (SHIBYTE(v60) < 0) {
              operator delete((void *)context);
            }
            *(_OWORD *)uint8_t v50 = 0u;
            long long v51 = 0u;
            long long context = 0uLL;
            uint64_t v60 = 0;
            ctu::cf::assign();
            long long __p = context;
            uint64_t v58 = v60;
            MNC::MNC();
            if (SHIBYTE(v58) < 0) {
              operator delete((void *)__p);
            }
            formPLMN((const MCC *)buf, (const MNC *)v50);
            CFStringRef v40 = (void *)context;
            v54[0] = v60;
            *(_DWORD *)((char *)v54 + 3) = *(_DWORD *)((char *)&v60 + 3);
            int v41 = SHIBYTE(v60);
            if (SHIBYTE(v60) < 0)
            {
              sub_10004FC84(__dst, (void *)context, *((unint64_t *)&context + 1));
              if (SHIBYTE(v48) < 0)
              {
                sub_10004FC84(&__p, __dst[0], (unint64_t)__dst[1]);
                goto LABEL_50;
              }
            }
            else
            {
              *(_OWORD *)__dst = context;
              LODWORD(v48) = v54[0];
              *(_DWORD *)((char *)&v48 + 3) = *(_DWORD *)((char *)v54 + 3);
              HIBYTE(v48) = HIBYTE(v60);
            }
            long long __p = *(_OWORD *)__dst;
            uint64_t v58 = v48;
LABEL_50:
            NSErrorUserInfoKey v56 = 0;
            if (SHIBYTE(v58) < 0)
            {
              sub_10004FC84(&context, (void *)__p, *((unint64_t *)&__p + 1));
            }
            else
            {
              long long context = __p;
              uint64_t v60 = v58;
            }
            long long v61 = 0;
            if (ctu::cf::convert_copy())
            {
              unsigned int v42 = v56;
              NSErrorUserInfoKey v56 = v61;
              long long v62 = v42;
              sub_1000558F4(&v62);
            }
            if (SHIBYTE(v60) < 0) {
              operator delete((void *)context);
            }
            CFTypeRef v49 = v56;
            NSErrorUserInfoKey v56 = 0;
            sub_1000558F4(&v56);
            if (SHIBYTE(v58) < 0) {
              operator delete((void *)__p);
            }
            sub_10010F3F0(*(__CFDictionary **)v55, (void *)qword_101B13EC0, (uint64_t)v49);
            sub_1000558F4(&v49);
            if (SHIBYTE(v48) < 0) {
              operator delete(__dst[0]);
            }
            if (SHIBYTE(v51) < 0) {
              operator delete(v50[1]);
            }
            if (SHIBYTE(v53) < 0) {
              operator delete(*(void **)&buf[8]);
            }
            if (v41 < 0) {
              operator delete(v40);
            }
            goto LABEL_67;
          }
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v34 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Invalid MCC / IMSI info", buf, 2u);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v33 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Invalid matching info", buf, 2u);
          }
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        char v32 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Invalid key hierarchy", buf, 2u);
        }
      }
      uint64_t v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v13[2](v13, 0, v35);

LABEL_26:
      id v10 = (id)v15;
      goto LABEL_27;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v30 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Invalid Subscription Context", buf, 2u);
    }
    char v31 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v13[2](v13, 0, v31);

    id v10 = 0;
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v29 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
    }
  }
LABEL_27:
}

- (void)copyCarrierBundleLocation:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v26);
      BOOL v9 = ServiceMap;
      if ((v10 & 0x8000000000000000) != 0)
      {
        CFArrayRef v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          unint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v28 = v10;
      id v14 = sub_10004D37C(&v9[1].__m_.__sig, &v28);
      if (v14)
      {
        uint64_t v16 = v14[3];
        uint64_t v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (v27) {
            sub_10004D2C8(v27);
          }
          if (v16)
          {
            id v21 = [v6 slotID];
            if (v21 == (id)2) {
              uint64_t v22 = 2;
            }
            else {
              uint64_t v22 = v21 == (id)1;
            }
            id v23 = objc_retainBlock(v7);
            v29[0] = off_1019B4D98;
            v29[1] = v23;
            v29[3] = v29;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 136))(v16, v22, v29);
            sub_10001E914(v29);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v24 = v27;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v26) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CarrierBundleInterface to copy carrier bundle location", (uint8_t *)&v26, 2u);
            }
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, id))v7 + 2))(v7, 0, v25);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      uint64_t v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid Subscription Context", (uint8_t *)&v26, 2u);
    }
    (*((void (**)(id, void, id))v7 + 2))(v7, 0, v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for copy carrier bundle location spi", (uint8_t *)&v26, 2u);
    }
  }
LABEL_28:
}

- (void)copyCarrierBookmarks:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v26);
      BOOL v9 = ServiceMap;
      if ((v10 & 0x8000000000000000) != 0)
      {
        CFArrayRef v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          unint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v28 = v10;
      id v14 = sub_10004D37C(&v9[1].__m_.__sig, &v28);
      if (v14)
      {
        uint64_t v16 = v14[3];
        uint64_t v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (v27) {
            sub_10004D2C8(v27);
          }
          if (v16)
          {
            id v21 = [v6 slotID];
            if (v21 == (id)2) {
              uint64_t v22 = 2;
            }
            else {
              uint64_t v22 = v21 == (id)1;
            }
            id v23 = objc_retainBlock(v7);
            v29[0] = off_1019B4E18;
            v29[1] = v23;
            v29[3] = v29;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 264))(v16, v22, v29);
            sub_10010E020(v29);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v24 = v27;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v26) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CarrierBundleInterface to copy carrier bundle location", (uint8_t *)&v26, 2u);
            }
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, id))v7 + 2))(v7, 0, v25);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      uint64_t v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid Subscription Context", (uint8_t *)&v26, 2u);
    }
    (*((void (**)(id, void, id))v7 + 2))(v7, 0, v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for copy carrier bundle location spi", (uint8_t *)&v26, 2u);
    }
  }
LABEL_28:
}

- (void)copyCarrierBundleVersion:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v26);
      BOOL v9 = ServiceMap;
      if ((v10 & 0x8000000000000000) != 0)
      {
        CFArrayRef v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          unint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v28 = v10;
      id v14 = sub_10004D37C(&v9[1].__m_.__sig, &v28);
      if (v14)
      {
        uint64_t v16 = v14[3];
        uint64_t v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (v27) {
            sub_10004D2C8(v27);
          }
          if (v16)
          {
            id v21 = [v6 slotID];
            if (v21 == (id)2) {
              uint64_t v22 = 2;
            }
            else {
              uint64_t v22 = v21 == (id)1;
            }
            id v23 = objc_retainBlock(v7);
            v29[0] = off_1019B4E98;
            v29[1] = v23;
            v29[3] = v29;
            (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v16 + 272))(v16, v22, 1, v29);
            sub_10001E914(v29);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v24 = v27;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v26) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CarrierBundleInterface to copy carrier bundle version", (uint8_t *)&v26, 2u);
            }
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, id))v7 + 2))(v7, 0, v25);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      uint64_t v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid Subscription Context", (uint8_t *)&v26, 2u);
    }
    (*((void (**)(id, void, id))v7 + 2))(v7, 0, v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for copy carrier bundle version spi", (uint8_t *)&v26, 2u);
    }
  }
LABEL_28:
}

- (void)isAttachApnSettingAllowed:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v26);
      BOOL v9 = ServiceMap;
      if ((v10 & 0x8000000000000000) != 0)
      {
        CFArrayRef v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          unint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v28 = v10;
      id v14 = sub_10004D37C(&v9[1].__m_.__sig, &v28);
      if (v14)
      {
        uint64_t v16 = v14[3];
        uint64_t v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (v27) {
            sub_10004D2C8(v27);
          }
          if (v16)
          {
            id v21 = [v6 slotID];
            if (v21 == (id)2) {
              uint64_t v22 = 2;
            }
            else {
              uint64_t v22 = v21 == (id)1;
            }
            id v23 = objc_retainBlock(v7);
            v29[0] = off_1019B4F18;
            v29[1] = v23;
            v29[3] = v29;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 120))(v16, v22, v29);
            sub_100060644(v29);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v24 = v27;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v26) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find BasebandSettingsInterface for checking Attach Apn settings allow", (uint8_t *)&v26, 2u);
            }
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, id))v7 + 2))(v7, 0, v25);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      uint64_t v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid context for checking Attach Apn settings allow", (uint8_t *)&v26, 2u);
    }
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, id))v7 + 2))(v7, 0, v20);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for checking Attach Apn settings allow", (uint8_t *)&v26, 2u);
    }
  }
LABEL_28:
}

- (void)context:(id)a3 modifyAttachApnSettings:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (v10)
  {
    if (v8)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v28);
      uint64_t v12 = ServiceMap;
      if ((v13 & 0x8000000000000000) != 0)
      {
        id v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v15 = 5381;
        do
        {
          unint64_t v13 = v15;
          unsigned int v16 = *v14++;
          uint64_t v15 = (33 * v15) ^ v16;
        }
        while (v16);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v30 = v13;
      char v17 = sub_10004D37C(&v12[1].__m_.__sig, &v30);
      if (v17)
      {
        uint64_t v19 = v17[3];
        uint64_t v18 = (std::__shared_weak_count *)v17[4];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v12);
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v18);
          char v20 = 0;
LABEL_16:
          if (v29) {
            sub_10004D2C8(v29);
          }
          if (v19)
          {
            unint64_t v28 = 0;
            char v29 = 0;
            [v8 slotID];
            sub_10022EDC4(v19, &v28);
            uint64_t v24 = v28;
            if (v28)
            {
              id v25 = objc_retainBlock(v10);
              v31[0] = off_1019B4F98;
              v31[1] = v25;
              v31[3] = v31;
              (*(void (**)(Registry *, id, void *))(*(void *)v24 + 112))(v24, v9, v31);
              sub_100060644(v31);
            }
            else
            {
              unsigned int v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
              (*((void (**)(id, void *))v10 + 2))(v10, v27);
            }
            if (v29) {
              sub_10004D2C8(v29);
            }
          }
          else
          {
            uint64_t v26 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void *))v10 + 2))(v10, v26);
          }
          if ((v20 & 1) == 0) {
            sub_10004D2C8(v18);
          }
          goto LABEL_27;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v12);
      uint64_t v18 = 0;
      char v20 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v28) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "modifyAttachApnSettings, no context", (uint8_t *)&v28, 2u);
    }
    id v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void *))v10 + 2))(v10, v23);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v21 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v28) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "modifyAttachApnSettings, no completion", (uint8_t *)&v28, 2u);
    }
  }
LABEL_27:
}

- (void)context:(id)a3 getAttachApnSettingsWithCompletion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      id v9 = ServiceMap;
      if ((v10 & 0x8000000000000000) != 0)
      {
        CFArrayRef v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          unint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v28 = v10;
      id v14 = sub_10004D37C(&v9[1].__m_.__sig, &v28);
      if (v14)
      {
        uint64_t v16 = v14[3];
        uint64_t v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (v27) {
            sub_10004D2C8(v27);
          }
          if (v16)
          {
            *(void *)long long buf = 0;
            unsigned int v27 = 0;
            [v6 slotID];
            sub_10022EDC4(v16, buf);
            id v21 = *(Registry **)buf;
            if (*(void *)buf)
            {
              v24[0] = _NSConcreteStackBlock;
              v24[1] = 3221225472;
              void v24[2] = sub_1002CB918;
              uint64_t v24[3] = &unk_1019B4D68;
              id v25 = v7;
              unint64_t v30 = 0;
              v29[0] = off_1019B5018;
              v29[1] = objc_retainBlock(v24);
              unint64_t v30 = v29;
              (*(void (**)(Registry *, void *))(*(void *)v21 + 128))(v21, v29);
              sub_10010E020(v29);
              uint64_t v22 = v25;
            }
            else
            {
              uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
              (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v22);
            }

            if (v27) {
              sub_10004D2C8(v27);
            }
          }
          else
          {
            id v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v23);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_27;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      uint64_t v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "getAttachApnSettings, no context", buf, 2u);
    }
    char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v20);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "getAttachApnSettings, no completion", buf, 2u);
    }
  }
LABEL_27:
}

- (void)setWiFiCallingSettingPreferences:(id)a3 key:(id)a4 value:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  unsigned int v13 = (void (**)(id, id))a6;
  if (v13)
  {
    if (!v10 || !v11 || (sub_1002CBCF0(v11) & 1) == 0)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v25 = v29;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v28) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Invalid context or key or unsupported key for set WiFiCalling setting preferences", (uint8_t *)&v28, 2u);
      }
      id v14 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v13[2](v13, v14);
      goto LABEL_16;
    }
    id v14 = +[NSMutableString string];
    [v14 setString:v11];
    if ([v10 slotID] == (id)2) {
      [v14 appendString:@"2"];
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v28);
    uint64_t v16 = ServiceMap;
    if ((v17 & 0x8000000000000000) != 0)
    {
      uint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        unint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v30 = v17;
    id v21 = sub_10004D37C(&v16[1].__m_.__sig, &v30);
    if (v21)
    {
      uint64_t v23 = v21[3];
      uint64_t v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v24 = 0;
LABEL_22:
        if (v29) {
          sub_10004D2C8((std::__shared_weak_count *)v29);
        }
        unsigned int v27 = *(void (**)(uint64_t, id, id, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v23 + 16);
        if (v12) {
          v27(v23, v14, v12, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        }
        else {
          v27(v23, v14, 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        }
        (*(void (**)(uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v23 + 48))(v23, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        v13[2](v13, 0);
        if ((v24 & 1) == 0) {
          sub_10004D2C8(v22);
        }
LABEL_16:

        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    uint64_t v22 = 0;
    char v24 = 1;
    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v26 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v28) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Invalid completion handler for set WiFiCalling setting preferences", (uint8_t *)&v28, 2u);
  }
LABEL_19:
}

- (void)getWiFiCallingSettingPreferences:(id)a3 key:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, void, id))a5;
  if (v10)
  {
    if (!v8 || !v9 || (sub_1002CBCF0(v9) & 1) == 0)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v22 = v48;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid context or key or unsupported key for get WiFiCalling setting preferences", buf, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, 0, v11);
      goto LABEL_16;
    }
    id v11 = +[NSMutableString string];
    [v11 setString:v9];
    if ([v8 slotID] == (id)2) {
      [v11 appendString:@"2"];
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unsigned int v13 = ServiceMap;
    if (v14 < 0)
    {
      uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        uint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    v43 = (Registry *)v14;
    uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&v43);
    if (v18)
    {
      uint64_t v20 = v18[3];
      uint64_t v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    uint64_t v19 = 0;
    char v21 = 1;
LABEL_22:
    if (v48) {
      sub_10004D2C8((std::__shared_weak_count *)v48);
    }
    CFTypeRef cf = 0;
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, id, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v20 + 40))(&cf, v20, v11, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    if (cf) {
      char v24 = sub_100080934;
    }
    else {
      char v24 = 0;
    }
    if (v24)
    {
      CFTypeID v25 = CFGetTypeID(cf);
      if (v25 != CFNullGetTypeID()) {
        goto LABEL_60;
      }
    }
    if (![v9 isEqualToString:@"WiFiCallingInCallHandover"])
    {
      CFTypeRef v38 = 0;
      goto LABEL_61;
    }
    id v26 = [v8 slotID];
    CFDictionaryRef theDict = 0;
    if (v26 == (id)2) {
      uint64_t v27 = 2;
    }
    else {
      uint64_t v27 = v26 == (id)1;
    }
    *(void *)long long buf = 0;
    uint64_t v48 = 0;
    [(CTXPCClientHandler *)self registry];
    unint64_t v28 = (std::mutex *)Registry::getServiceMap(v43);
    char v29 = v28;
    if (v30 < 0)
    {
      char v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        uint64_t v30 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(v28);
    CFDictionaryRef v49 = (const __CFDictionary *)v30;
    uint64_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)&v49);
    if (v34)
    {
      uint64_t v36 = v34[3];
      uint64_t v35 = (std::__shared_weak_count *)v34[4];
      if (v35)
      {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v29);
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v27 = v27;
        sub_10004D2C8(v35);
        char v37 = 0;
LABEL_42:
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v36 + 32))(buf, v36, v27);
        if ((v37 & 1) == 0) {
          sub_10004D2C8(v35);
        }
        if (v44) {
          sub_10004D2C8(v44);
        }
        if (*(void *)buf)
        {
          (*(void (**)(const __CFDictionary **__return_ptr))(**(void **)buf + 40))(&v49);
          v43 = (Registry *)theDict;
          CFDictionaryRef theDict = v49;
          CFDictionaryRef v49 = 0;
          sub_100057D78((const void **)&v43);
          sub_100057D78((const void **)&v49);
        }
        if (v48) {
          sub_10004D2C8((std::__shared_weak_count *)v48);
        }
        if (theDict) {
          id v39 = sub_100080778;
        }
        else {
          id v39 = 0;
        }
        if (v39)
        {
          Value = CFDictionaryGetValue(theDict, @"SupportCallHandover");
          int v41 = Value;
          if (Value && (CFTypeID v42 = CFGetTypeID(Value), v42 == CFBooleanGetTypeID()))
          {
            *(void *)long long buf = v41;
            sub_1002CC4B4(&cf, (CFTypeRef *)buf);
          }
          else
          {
            *(void *)long long buf = kCFBooleanTrue;
            sub_1002CC4B4(&cf, (CFTypeRef *)buf);
          }
        }
        else
        {
          *(void *)long long buf = kCFBooleanFalse;
          sub_1002CC4B4(&cf, (CFTypeRef *)buf);
        }
        sub_100057D78((const void **)&theDict);
LABEL_60:
        CFTypeRef v38 = cf;
LABEL_61:
        ((void (**)(id, CFTypeRef, id))v10)[2](v10, v38, 0);
        sub_1000577C4(&cf);
        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
LABEL_16:

        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v36 = 0;
    }
    std::mutex::unlock(v29);
    uint64_t v35 = 0;
    char v37 = 1;
    goto LABEL_42;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v23 = v48;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid completion handler for get WiFiCalling setting preferences", buf, 2u);
  }
LABEL_19:
}

- (void)copyBundleVersion:(id)a3 bundleType:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (v10)
  {
    if (v8)
    {
      if (v9)
      {
        [(CTXPCClientHandler *)self registry];
        ServiceMap = (std::mutex *)Registry::getServiceMap(v31);
        id v12 = ServiceMap;
        if ((v13 & 0x8000000000000000) != 0)
        {
          uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v15 = 5381;
          do
          {
            unint64_t v13 = v15;
            unsigned int v16 = *v14++;
            uint64_t v15 = (33 * v15) ^ v16;
          }
          while (v16);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v33 = v13;
        unsigned int v17 = sub_10004D37C(&v12[1].__m_.__sig, &v33);
        if (v17)
        {
          uint64_t v19 = v17[3];
          uint64_t v18 = (std::__shared_weak_count *)v17[4];
          if (v18)
          {
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v12);
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v18);
            char v20 = 0;
LABEL_20:
            if (v32) {
              sub_10004D2C8(v32);
            }
            if (v19)
            {
              uint64_t v25 = 1;
              uint64_t v26 = 4;
              switch((unint64_t)[v9 type])
              {
                case 1uLL:
                  uint64_t v26 = 1;
                  goto LABEL_35;
                case 2uLL:
                  uint64_t v26 = 2;
                  goto LABEL_35;
                case 3uLL:
                  uint64_t v26 = 3;
                  goto LABEL_35;
                case 4uLL:
                  goto LABEL_38;
                case 5uLL:
                  uint64_t v26 = 5;
                  goto LABEL_35;
                case 6uLL:
                  uint64_t v26 = 6;
                  goto LABEL_35;
                default:
                  uint64_t v26 = 0;
LABEL_35:
                  id v29 = [v8 slotID];
                  if (v29 == (id)2) {
                    uint64_t v25 = 2;
                  }
                  else {
                    uint64_t v25 = v29 == (id)1;
                  }
LABEL_38:
                  id v30 = objc_retainBlock(v10);
                  v34[0] = off_1019B5098;
                  v34[1] = v30;
                  void v34[3] = v34;
                  (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v19 + 272))(v19, v25, v26, v34);
                  sub_10001E914(v34);
                  if (v20) {
                    goto LABEL_29;
                  }
                  goto LABEL_28;
              }
            }
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v27 = v32;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v31);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v31) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Could not find CarrierBundleInterface to copy carrier bundle version", (uint8_t *)&v31, 2u);
            }
            id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, id))v10 + 2))(v10, 0, v28);

            if ((v20 & 1) == 0) {
LABEL_28:
            }
              sub_10004D2C8(v18);
            goto LABEL_29;
          }
        }
        else
        {
          uint64_t v19 = 0;
        }
        std::mutex::unlock(v12);
        uint64_t v18 = 0;
        char v20 = 1;
        goto LABEL_20;
      }
      [(CTXPCClientHandler *)self getLogContext];
      char v24 = v32;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v31);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v31) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid bundle type", (uint8_t *)&v31, 2u);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v22 = v32;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v31);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v31) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid Subscription Context", (uint8_t *)&v31, 2u);
      }
    }
    uint64_t v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, void *))v10 + 2))(v10, 0, v23);

    goto LABEL_29;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v21 = v32;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v31);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v31) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for copy bundle version spi", (uint8_t *)&v31, 2u);
  }
LABEL_29:
}

- (void)copyBundleIdentifier:(id)a3 bundleType:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (v10)
  {
    if (v8)
    {
      if (v9)
      {
        [(CTXPCClientHandler *)self registry];
        ServiceMap = (std::mutex *)Registry::getServiceMap(v32);
        id v12 = ServiceMap;
        if ((v13 & 0x8000000000000000) != 0)
        {
          uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v15 = 5381;
          do
          {
            unint64_t v13 = v15;
            unsigned int v16 = *v14++;
            uint64_t v15 = (33 * v15) ^ v16;
          }
          while (v16);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v34 = v13;
        unsigned int v17 = sub_10004D37C(&v12[1].__m_.__sig, &v34);
        if (v17)
        {
          uint64_t v19 = v17[3];
          uint64_t v18 = (std::__shared_weak_count *)v17[4];
          if (v18)
          {
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v12);
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v18);
            char v20 = 0;
LABEL_20:
            if (v33) {
              sub_10004D2C8(v33);
            }
            if (v19)
            {
              id v25 = [v9 type];
              id v26 = [v8 slotID];
              if ((unint64_t)v25 >= 7) {
                unsigned __int8 v27 = 0;
              }
              else {
                unsigned __int8 v27 = v25;
              }
              if (v26 == (id)2) {
                uint64_t v28 = 2;
              }
              else {
                uint64_t v28 = v26 == (id)1;
              }
              id v29 = objc_retainBlock(v10);
              v35[0] = off_1019B5118;
              v35[1] = v29;
              v35[3] = v35;
              (*(void (**)(uint64_t, uint64_t, void, void *))(*(void *)v19 + 280))(v19, v28, v27, v35);
              sub_10001E914(v35);
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              id v30 = v33;
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v32);
              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
              {
                LOWORD(v32) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Could not find CarrierBundleInterface to copy bundle identifier.", (uint8_t *)&v32, 2u);
              }
              id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
              (*((void (**)(id, void, id))v10 + 2))(v10, 0, v31);
            }
            if ((v20 & 1) == 0) {
              sub_10004D2C8(v18);
            }
            goto LABEL_35;
          }
        }
        else
        {
          uint64_t v19 = 0;
        }
        std::mutex::unlock(v12);
        uint64_t v18 = 0;
        char v20 = 1;
        goto LABEL_20;
      }
      [(CTXPCClientHandler *)self getLogContext];
      char v24 = v33;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v32);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v32) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid bundle type", (uint8_t *)&v32, 2u);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v22 = v33;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v32);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v32) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid Subscription Context", (uint8_t *)&v32, 2u);
      }
    }
    uint64_t v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, void *))v10 + 2))(v10, 0, v23);

    goto LABEL_35;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v21 = v33;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v32);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v32) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for copy bundle version spi", (uint8_t *)&v32, 2u);
  }
LABEL_35:
}

- (void)restoreToSystemBundles:(id)a3
{
  id v4 = (void (**)(id, uint64_t, void))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v15 = v20;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for restoreToSystemBundles SPI", (uint8_t *)&v19, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v19);
  id v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v7;
  id v11 = sub_10004D37C(&v6[1].__m_.__sig, &v21);
  if (v11)
  {
    uint64_t v13 = v11[3];
    id v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  id v12 = 0;
  char v14 = 1;
LABEL_12:
  if (v20) {
    sub_10004D2C8((std::__shared_weak_count *)v20);
  }
  if (v13)
  {
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 240))(v13);
    v4[2](v4, v16, 0);
    if ((v14 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v12);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v17 = v20;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find CarrierBundleInterface for restoreToSystemBundles SPI.", (uint8_t *)&v19, 2u);
    }
    id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, uint64_t, id))v4)[2](v4, 0, v18);

    if ((v14 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)getCountryBundleLocationForBundleIdentifier:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(void))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v18 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getCountryBundleLocationForBundleIdentifier", buf, 2u);
    }
    goto LABEL_31;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)id v30 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)v30);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_12:
  if (v29) {
    sub_10004D2C8((std::__shared_weak_count *)v29);
  }
  if (v16)
  {
    *(void *)id v30 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      char v20 = *(__CFDictionary **)v30;
      *(void *)id v30 = Mutable;
      *(void *)long long buf = v20;
      sub_10005717C((const void **)buf);
    }
    sub_10010F3F0(*(__CFDictionary **)v30, @"HomeBundleIdentifier", (uint64_t)v6);
    unsigned __int8 v27 = 0;
    sub_10004EFE4(&v26, (CFTypeRef *)v30);
    (*(void (**)(const void **__return_ptr, uint64_t, const void **))(*(void *)v16 + 312))(&v27, v16, &v26);
    sub_100057D78(&v26);
    if (v27) {
      unint64_t v21 = sub_1000810B8;
    }
    else {
      unint64_t v21 = 0;
    }
    if (v21)
    {
      v7[2](v7);
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v24 = v29;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Unable to get the path associated with country bundle identifier lookup", buf, 2u);
      }
      id v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      ((void (*)(void (**)(void), void, void *))v7[2])(v7, 0, v25);
    }
    sub_1000558F4(&v27);
    sub_10005717C((const void **)v30);
    if ((v17 & 1) == 0) {
LABEL_30:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Unable to get the CarrierBundleInterface in the getCountryBundleLocationForBundleIdentifier SPI.", buf, 2u);
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (*)(void (**)(void), void, id))v7[2])(v7, 0, v23);

    if ((v17 & 1) == 0) {
      goto LABEL_30;
    }
  }
LABEL_31:
}

- (void)getCountryBundleIdentifierForCountryCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(void))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v18 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getCountryBundleIdentifierForCountryCode", buf, 2u);
    }
    goto LABEL_31;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v28 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v28);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_12:
  if (v27) {
    sub_10004D2C8((std::__shared_weak_count *)v27);
  }
  if (v16)
  {
    uint64_t v28 = (uint64_t)v6;
    char v24 = v6;
    id v25 = 0;
    if (v6) {
      CFRetain(v6);
    }
    (*(void (**)(const void **__return_ptr, uint64_t, const void **))(*(void *)v16 + 320))(&v25, v16, &v24);
    sub_1000558F4(&v24);
    if (v25) {
      uint64_t v19 = sub_1000810B8;
    }
    else {
      uint64_t v19 = 0;
    }
    if (v19)
    {
      v7[2](v7);
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v22 = v27;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Alpha3 does not have an associated country bundle identifier lookup", buf, 2u);
      }
      id v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      ((void (*)(void (**)(void), void, void *))v7[2])(v7, 0, v23);
    }
    sub_1000558F4(&v25);
    sub_1000558F4((const void **)&v28);
    if ((v17 & 1) == 0) {
LABEL_30:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v20 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Unable to get the CarrierBundleInterface in the getCountryBundleIdentifierForCountryCode SPI.", buf, 2u);
    }
    id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (*)(void (**)(void), void, id))v7[2])(v7, 0, v21);

    if ((v17 & 1) == 0) {
      goto LABEL_30;
    }
  }
LABEL_31:
}

- (void)getEnglishCarrierNameFor:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void *, void))a4;
  if (v7)
  {
    if (v6)
    {
      id v8 = [&off_101AE7FC0 objectForKeyedSubscript:v6];
      if (v8)
      {
        uint64_t v9 = [&off_101AE7FC0 objectForKeyedSubscript:v6];
      }
      else
      {
        uint64_t v9 = v6;
      }
      v7[2](v7, v9, 0);
      if (v8) {
    }
      }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v11 = v13;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        __int16 v12 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid locale carrier name provided for getEnglishCarrierNameFor:LocaleCarrierName", (uint8_t *)&v12, 2u);
      }
      id v8 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      ((void (**)(id, void *, void *))v7)[2](v7, 0, v8);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v10 = v13;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      __int16 v12 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid completion handler for getEnglishCarrierNameFor:LocaleCarrierName", (uint8_t *)&v12, 2u);
    }
  }
}

- (void)copyBundleLocation:(id)a3 bundleType:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void, id))a5;
  if (v10)
  {
    if (v8)
    {
      if (v9)
      {
        [(CTXPCClientHandler *)self registry];
        ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p);
        __int16 v12 = ServiceMap;
        if ((v13 & 0x8000000000000000) != 0)
        {
          char v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v15 = 5381;
          do
          {
            unint64_t v13 = v15;
            unsigned int v16 = *v14++;
            uint64_t v15 = (33 * v15) ^ v16;
          }
          while (v16);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v36 = v13;
        char v17 = sub_10004D37C(&v12[1].__m_.__sig, &v36);
        if (v17)
        {
          uint64_t v19 = v17[3];
          id v18 = (std::__shared_weak_count *)v17[4];
          if (v18)
          {
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v12);
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v18);
            char v20 = 0;
            goto LABEL_20;
          }
        }
        else
        {
          uint64_t v19 = 0;
        }
        std::mutex::unlock(v12);
        id v18 = 0;
        char v20 = 1;
LABEL_20:
        if (v34) {
          sub_10004D2C8(v34);
        }
        if (!v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v30 = v34;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Could not find CarrierBundleInterface to copy bundle location.", (uint8_t *)&__p, 2u);
          }
          id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v10[2](v10, 0, v31);

          goto LABEL_41;
        }
        id v25 = [v9 type];
        id v26 = [v8 slotID];
        if ((unint64_t)v25 >= 7) {
          unsigned __int8 v27 = 0;
        }
        else {
          unsigned __int8 v27 = v25;
        }
        if (v26 == (id)2) {
          uint64_t v28 = 2;
        }
        else {
          uint64_t v28 = v26 == (id)1;
        }
        long long __p = 0;
        unint64_t v34 = 0;
        uint64_t v35 = 0;
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, void))(*(void *)v19 + 360))(&__p, v19, v28, v27);
        if (SHIBYTE(v35) < 0)
        {
          if (v34)
          {
            p_p = __p;
            goto LABEL_37;
          }
        }
        else if (HIBYTE(v35))
        {
          p_p = &__p;
LABEL_37:
          uint64_t v32 = +[NSString stringWithUTF8String:p_p];
          ((void (**)(id, void *, id))v10)[2](v10, v32, 0);
          goto LABEL_39;
        }
        uint64_t v32 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        v10[2](v10, 0, v32);
LABEL_39:

        if (SHIBYTE(v35) < 0) {
          operator delete(__p);
        }
LABEL_41:
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_43;
      }
      [(CTXPCClientHandler *)self getLogContext];
      id v23 = v34;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid bundle type", (uint8_t *)&__p, 2u);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v22 = v34;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid Subscription Context", (uint8_t *)&__p, 2u);
      }
    }
    char v24 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v10[2](v10, 0, v24);

    goto LABEL_43;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v21 = v34;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for copy bundle location spi", (uint8_t *)&__p, 2u);
  }
LABEL_43:
}

- (void)checkForUpdatedBundlesWithAutoInstall:(BOOL)a3 completion:(id)a4
{
  BOOL v4 = a3;
  id v6 = (void (**)(id, void))a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v20);
  id v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v9;
  unint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v22);
  if (v13)
  {
    uint64_t v15 = v13[3];
    char v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  char v14 = 0;
  char v16 = 1;
LABEL_9:
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v15)
  {
    if (v4) {
      uint64_t v17 = 7;
    }
    else {
      uint64_t v17 = 5;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 96))(v15, v17);
    v6[2](v6, 0);
    if ((v16 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v14);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Unable to get the CarrierBundleInterface in the checkForUpdatedBundlesWithAutoInstall SPI.", (uint8_t *)&v20, 2u);
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v6)[2](v6, v19);

    if ((v16 & 1) == 0) {
      goto LABEL_16;
    }
  }
}

- (void)getCountryBundleLocationForMatchingInfo:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(void))a4;
  if (v7)
  {
    if (v6)
    {
      uint64_t v8 = (uint64_t)[v6 imsi];
      uint64_t v9 = (uint64_t)[v6 mcc];
      if (v8 | v9)
      {
        *(void *)v43 = 0;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          uint64_t v11 = *(__CFDictionary **)v43;
          *(void *)v43 = Mutable;
          *(void *)long long buf = v11;
          sub_10005717C((const void **)buf);
        }
        if (v8)
        {
          sub_10010F3F0(*(__CFDictionary **)v43, (void *)qword_101B13EC0, v8);
          goto LABEL_8;
        }
        memset(v42, 0, 7);
        if (![v6 mnc])
        {
          sub_10010F3F0(*(__CFDictionary **)v43, (void *)qword_101B13EC0, v9);
          goto LABEL_8;
        }
        *(_OWORD *)long long buf = 0u;
        long long v41 = 0u;
        v38[1] = 0;
        ctu::cf::assign();
        long long v47 = 0u;
        uint64_t v48 = 0;
        MCC::MCC();
        if (SHIBYTE(v48) < 0) {
          operator delete((void *)v47);
        }
        *(_OWORD *)CFTypeRef v38 = 0u;
        long long v39 = 0u;
        long long v47 = 0uLL;
        uint64_t v48 = 0;
        ctu::cf::assign();
        long long __p = v47;
        uint64_t v46 = v48;
        MNC::MNC();
        if (SHIBYTE(v46) < 0) {
          operator delete((void *)__p);
        }
        formPLMN((const MCC *)buf, (const MNC *)v38);
        id v26 = (void *)v47;
        v42[0] = v48;
        *(_DWORD *)((char *)v42 + 3) = *(_DWORD *)((char *)&v48 + 3);
        int v27 = SHIBYTE(v48);
        if (SHIBYTE(v48) < 0)
        {
          sub_10004FC84(__dst, (void *)v47, *((unint64_t *)&v47 + 1));
          if (SHIBYTE(v36) < 0)
          {
            sub_10004FC84(&__p, __dst[0], (unint64_t)__dst[1]);
            goto LABEL_53;
          }
        }
        else
        {
          *(_OWORD *)__dst = v47;
          LODWORD(v36) = v42[0];
          *(_DWORD *)((char *)&v36 + 3) = *(_DWORD *)((char *)v42 + 3);
          HIBYTE(v36) = HIBYTE(v48);
        }
        long long __p = *(_OWORD *)__dst;
        uint64_t v46 = v36;
LABEL_53:
        char v44 = 0;
        if (SHIBYTE(v46) < 0)
        {
          sub_10004FC84(&v47, (void *)__p, *((unint64_t *)&__p + 1));
        }
        else
        {
          long long v47 = __p;
          uint64_t v48 = v46;
        }
        CFDictionaryRef v49 = 0;
        if (ctu::cf::convert_copy())
        {
          unint64_t v33 = v44;
          char v44 = v49;
          uint8_t v50 = v33;
          sub_1000558F4(&v50);
        }
        if (SHIBYTE(v48) < 0) {
          operator delete((void *)v47);
        }
        CFTypeRef v37 = v44;
        char v44 = 0;
        sub_1000558F4(&v44);
        if (SHIBYTE(v46) < 0) {
          operator delete((void *)__p);
        }
        sub_10010F3F0(*(__CFDictionary **)v43, (void *)qword_101B13EC0, (uint64_t)v37);
        sub_1000558F4(&v37);
        if (SHIBYTE(v36) < 0) {
          operator delete(__dst[0]);
        }
        if (SHIBYTE(v39) < 0) {
          operator delete(v38[1]);
        }
        if (SHIBYTE(v41) < 0) {
          operator delete(*(void **)&buf[8]);
        }
        if (v27 < 0) {
          operator delete(v26);
        }
LABEL_8:
        [(CTXPCClientHandler *)self registry];
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
        unint64_t v13 = ServiceMap;
        if (v14 < 0)
        {
          uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v16 = 5381;
          do
          {
            uint64_t v14 = v16;
            unsigned int v17 = *v15++;
            uint64_t v16 = (33 * v16) ^ v17;
          }
          while (v17);
        }
        std::mutex::lock(ServiceMap);
        v38[0] = (void *)v14;
        id v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v38);
        if (v18)
        {
          uint64_t v20 = v18[3];
          id v19 = (std::__shared_weak_count *)v18[4];
          if (v19)
          {
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v13);
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v19);
            char v21 = 0;
            goto LABEL_31;
          }
        }
        else
        {
          uint64_t v20 = 0;
        }
        std::mutex::unlock(v13);
        id v19 = 0;
        char v21 = 1;
LABEL_31:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v20)
        {
          v38[0] = 0;
          sub_10004EFE4(&v34, (CFTypeRef *)v43);
          (*(void (**)(void **__return_ptr, uint64_t, const void **))(*(void *)v20 + 312))(v38, v20, &v34);
          sub_100057D78(&v34);
          if (v38[0]) {
            uint64_t v28 = sub_1000810B8;
          }
          else {
            uint64_t v28 = 0;
          }
          if (v28)
          {
            v7[2](v7);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v31 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Unable to get the path associated with country bundle identifier lookup", buf, 2u);
            }
            uint64_t v32 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            ((void (*)(void (**)(void), void, void *))v7[2])(v7, 0, v32);
          }
          sub_1000558F4((const void **)v38);
          if (v21) {
            goto LABEL_48;
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v29 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Unable to get the CarrierBundleInterface in the getCountryBundleLocationForMatchingInfo SPI.", buf, 2u);
          }
          id v30 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (*)(void (**)(void), void, id))v7[2])(v7, 0, v30);

          if (v21) {
            goto LABEL_48;
          }
        }
        sub_10004D2C8(v19);
LABEL_48:
        sub_10005717C((const void **)v43);
        goto LABEL_49;
      }
      [(CTXPCClientHandler *)self getLogContext];
      char v24 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid MCC / IMSI info", buf, 2u);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v23 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid matching info", buf, 2u);
      }
    }
    id v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (*)(void (**)(void), void, void *))v7[2])(v7, 0, v25);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for country bundle location for matching info spi", buf, 2u);
    }
  }
LABEL_49:
}

- (BOOL)restrictedPublicCarrierInfoKeys
{
  if ([(CTXPCClientHandler *)self hasEntitlement:3])
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v3 = v9;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_INFO);
    if (v4)
    {
      *(_WORD *)uint64_t v8 = 0;
      v5 = "Allow all bundle info (Entitlement)";
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, v5, v8, 2u);
      LOBYTE(v4) = 0;
    }
  }
  else if ([(CTXPCClientHandler *)self isLinkedOnOrAfterVersion:@"16.4"])
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v6 = v9;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Restricting carrier info", v8, 2u);
    }
    LOBYTE(v4) = 1;
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v3 = v9;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_INFO);
    if (v4)
    {
      *(_WORD *)uint64_t v8 = 0;
      v5 = "Allow all bundle info (SDK version)";
      goto LABEL_10;
    }
  }
  return v4;
}

- (void)isVinylTapeSupportedWithCompletion:(id)a3
{
  BOOL v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    id v11 = 0;
    [(CTXPCClientHandler *)self registry];
    sub_100363518(&v12, &v11, &v9);
    id v5 = v11;
    if (v13) {
      sub_10004D2C8(v13);
    }
    id v6 = (capabilities::ct *)v10;
    if (v10) {
      sub_10004D2C8(v10);
    }
    if (v5)
    {
      v4[2](v4, 0, v5);
    }
    else
    {
      uint64_t v8 = capabilities::ct::defaultVinylCardTypeToGSMA(v6);
      v4[2](v4, v8, 0);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v7 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
    }
  }
}

- (void)isVinylTestModeEnabledWithCompletion:(id)a3
{
  BOOL v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    *(void *)long long buf = 0;
    unint64_t v13 = 0;
    id v11 = 0;
    [(CTXPCClientHandler *)self registry];
    sub_100363518(buf, &v11, &v9);
    id v5 = v11;
    if (v10) {
      sub_10004D2C8(v10);
    }
    if (v5)
    {
      v4[2](v4, 0, v5);
    }
    else
    {
      uint64_t v7 = *(void *)buf;
      uint64_t v8 = objc_retainBlock(v4);
      v14[0] = off_1019BD2A8;
      v14[1] = v8;
      v14[3] = v14;
      (*(void (**)(uint64_t, void *))(*(void *)v7 + 168))(v7, v14);
      sub_1000F25E0(v14);
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v6 = v13;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
    }
  }
}

- (void)setVinylTestMode:(BOOL)a3 completion:(id)a4
{
  BOOL v4 = a3;
  id v6 = (void (**)(id, void, id))a4;
  if (v6)
  {
    *(void *)long long buf = 0;
    uint64_t v15 = 0;
    id v13 = 0;
    [(CTXPCClientHandler *)self registry];
    sub_100363518(buf, &v13, &v11);
    id v7 = v13;
    if (v12) {
      sub_10004D2C8(v12);
    }
    if (v7)
    {
      v6[2](v6, 0, v7);
    }
    else
    {
      uint64_t v9 = *(void *)buf;
      uint64_t v10 = objc_retainBlock(v6);
      v16[0] = off_1019BD328;
      v16[1] = v10;
      v16[3] = v16;
      (*(void (**)(uint64_t, BOOL, void *))(*(void *)v9 + 176))(v9, v4, v16);
      sub_100060644(v16);
    }
    if (v15) {
      sub_10004D2C8(v15);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v8 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
    }
  }
}

- (void)setVirtualSimMode:(BOOL)a3 withDualSim:(BOOL)a4 completion:(id)a5
{
  BOOL v5 = a4;
  BOOL v6 = a3;
  id v8 = a5;
  if (v8)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v22);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v24 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v24);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v23) {
          sub_10004D2C8(v23);
        }
        if (v17)
        {
          id v20 = objc_retainBlock(v8);
          v25[0] = off_1019BD3A8;
          v25[1] = v20;
          v25[3] = v25;
          (*(void (**)(uint64_t, BOOL, BOOL, void *))(*(void *)v17 + 160))(v17, v6, v5, v25);
          sub_1000C752C(v25);
        }
        else
        {
          id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, id))v8 + 2))(v8, 0, v21);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = v23;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v22) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&v22, 2u);
  }
LABEL_19:
}

- (void)getEuiccData:(id)a3
{
  BOOL v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    BOOL v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v37 = v7;
    unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v37);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
LABEL_12:
    if (v36) {
      sub_10004D2C8(v36);
    }
    if (!v13)
    {
      id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v4[2](v4, 0, v26);

LABEL_36:
      if ((v14 & 1) == 0) {
        sub_10004D2C8(v12);
      }
      goto LABEL_38;
    }
    [(CTXPCClientHandler *)self registry];
    uint64_t v16 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v17 = v16;
    if ((v18 & 0x8000000000000000) != 0)
    {
      id v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v20 = 5381;
      do
      {
        unint64_t v18 = v20;
        unsigned int v21 = *v19++;
        uint64_t v20 = (33 * v20) ^ v21;
      }
      while (v21);
    }
    std::mutex::lock(v16);
    unint64_t v37 = v18;
    unint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, &v37);
    if (v22)
    {
      uint64_t v24 = v22[3];
      id v23 = (std::__shared_weak_count *)v22[4];
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v17);
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v23);
        char v25 = 0;
LABEL_24:
        int v27 = (capabilities::ct *)v36;
        if (v36) {
          sub_10004D2C8(v36);
        }
        if (v24)
        {
          uint64_t v28 = (capabilities::euicc *)capabilities::ct::supportsVinylFirmwareUpdate(v27);
          if (v28) {
            int v29 = capabilities::euicc::supportsEOS(v28) ^ 1;
          }
          else {
            int v29 = 0;
          }
          v32[0] = _NSConcreteStackBlock;
          v32[1] = 3221225472;
          v32[2] = sub_1003642B4;
          v32[3] = &unk_1019BD278;
          char v34 = v29;
          void v32[4] = self;
          unint64_t v33 = v4;
          (*(void (**)(uint64_t, uint64_t, void *, void))(*(void *)v24 + 136))(v24, 1, v32, v29 ^ 1u);
          id v31 = v33;
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v30 = v36;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Could not find VinylController for getEuiccData", buf, 2u);
          }
          id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v4[2](v4, 0, v31);
        }

        if ((v25 & 1) == 0) {
          sub_10004D2C8(v23);
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v24 = 0;
    }
    std::mutex::unlock(v17);
    id v23 = 0;
    char v25 = 1;
    goto LABEL_24;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v36;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getEuiccData", buf, 2u);
  }
LABEL_38:
}

- (void)getVoicemailInfo:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      (*((void (**)(id, void, void, void, id))v7 + 2))(v7, 0, 0, 0, v19);

      goto LABEL_46;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v41 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v41);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
LABEL_14:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    [(CTXPCClientHandler *)self registry];
    uint64_t v20 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unsigned int v21 = v20;
    if ((v22 & 0x8000000000000000) != 0)
    {
      id v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v24 = 5381;
      do
      {
        unint64_t v22 = v24;
        unsigned int v25 = *v23++;
        uint64_t v24 = (33 * v24) ^ v25;
      }
      while (v25);
    }
    std::mutex::lock(v20);
    unint64_t v41 = v22;
    id v26 = sub_10004D37C(&v21[1].__m_.__sig, &v41);
    if (v26)
    {
      uint64_t v28 = v26[3];
      int v27 = (std::__shared_weak_count *)v26[4];
      if (v27)
      {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v21);
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v27);
        char v29 = 0;
LABEL_24:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v16 && v28)
        {
          id v30 = [v6 slotID];
          if (v30 == (id)2) {
            uint64_t v31 = 2;
          }
          else {
            uint64_t v31 = v30 == (id)1;
          }
          memset(buf, 0, sizeof(buf));
          (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v28 + 32))(buf, v28, v31);
          uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v28 + 40))(v28, v31);
          if (v32 && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v28 + 48))(v28, v31)) {
            uint64_t v33 = (*(int (**)(uint64_t, uint64_t))(*(void *)v28 + 56))(v28, v31);
          }
          else {
            uint64_t v33 = 0;
          }
          uint64_t v36 = +[NSNumber numberWithUnsignedInteger:v33];
          if ((buf[23] & 0x80u) == 0) {
            unint64_t v37 = buf;
          }
          else {
            unint64_t v37 = *(uint8_t **)buf;
          }
          CFTypeRef v38 = +[NSString stringWithUTF8String:v37];
          (*((void (**)(id, uint64_t, void *, void *, void))v7 + 2))(v7, v32, v36, v38, 0);

          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v34 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            long long v39 = "False";
            if (v16) {
              CFStringRef v40 = "True";
            }
            else {
              CFStringRef v40 = "False";
            }
            if (v28) {
              long long v39 = "True";
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&buf[4] = v40;
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = v39;
            _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Error in fetching VoicemailInfo SMS available %s. VMC available %s.", buf, 0x16u);
          }
          id v35 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void, void, id))v7 + 2))(v7, 0, 0, 0, v35);
        }
        if ((v29 & 1) == 0) {
          sub_10004D2C8(v27);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_46;
      }
    }
    else
    {
      uint64_t v28 = 0;
    }
    std::mutex::unlock(v21);
    int v27 = 0;
    char v29 = 1;
    goto LABEL_24;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v18 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting voicemail info", buf, 2u);
  }
LABEL_46:
}

- (void)setVisualVoicemailState:(id)a3 subscribed:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  uint64_t v9 = (void (**)(id, void *))a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for settings visual voicemail state", (uint8_t *)&v26, 2u);
    }
    goto LABEL_24;
  }
  if (!v8)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v21 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "No context given", (uint8_t *)&v26, 2u);
    }
    unint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v9[2](v9, v22);

    goto LABEL_24;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v26);
  unint64_t v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v28 = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v28);
  if (!v16)
  {
    uint64_t v18 = 0;
    goto LABEL_15;
  }
  uint64_t v18 = v16[3];
  char v17 = (std::__shared_weak_count *)v16[4];
  if (!v17)
  {
LABEL_15:
    std::mutex::unlock(v11);
    char v17 = 0;
    char v19 = 1;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
LABEL_16:
  if (v27) {
    sub_10004D2C8((std::__shared_weak_count *)v27);
  }
  if (!v18)
  {
    unsigned int v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v9[2](v9, v25);

    if (v19) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  id v23 = [v8 slotID];
  if (v23 == (id)2) {
    uint64_t v24 = 2;
  }
  else {
    uint64_t v24 = v23 == (id)1;
  }
  (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v18 + 72))(v18, v24, v6);
  v9[2](v9, 0);
  if ((v19 & 1) == 0) {
LABEL_23:
  }
    sub_10004D2C8(v17);
LABEL_24:
}

- (void)getVoicemailCallInDetails:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v19 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_29;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v37 = v10;
    uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v37);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unsigned int v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v16)
        {
          unint64_t v37 = 0;
          CFTypeRef v38 = 0;
          uint64_t v20 = [v6 uuid];
          sub_1005B09D4(v20, (CFUUIDRef *)buf);
          (*(void (**)(unint64_t *__return_ptr, uint64_t, void))(*(void *)v16 + 16))(&v37, v16, *(void *)buf);
          sub_10012577C((const void **)buf);

          if (v37 && !*(unsigned char *)(v37 + 49))
          {
            if (*(unsigned char *)(v37 + 48))
            {
              uint64_t v35 = 0;
              uint64_t v36 = 0;
              [(CTXPCClientHandler *)self registry];
              sub_100224000(*(Registry **)buf, &v35);
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
              if (v35)
              {
                *(_OWORD *)long long buf = 0u;
                long long v42 = 0u;
                CallController::getVoicemailNumber(v35, *(unsigned int *)(v37 + 52), (uint64_t)buf);
                if (DWORD2(v42) == -1)
                {
                  unint64_t v28 = 0;
                }
                else
                {
                  v39[0] = kCTVVMNumberTypeKey;
                  unsigned int v25 = sub_1003ABAEC((id)DWORD2(v42));
                  v40[0] = v25;
                  v39[1] = kCTVVMNumberKey;
                  if ((SBYTE7(v42) & 0x80u) == 0) {
                    id v26 = buf;
                  }
                  else {
                    id v26 = *(uint8_t **)buf;
                  }
                  int v27 = +[NSString stringWithUTF8String:v26];
                  v40[1] = v27;
                  unint64_t v28 = +[NSDictionary dictionaryWithObjects:v40 forKeys:v39 count:2];
                }
                ((void (**)(id, void *, void *))v7)[2](v7, v28, 0);
                if (SBYTE7(v42) < 0) {
                  operator delete(*(void **)buf);
                }
              }
              else
              {
                [(CTXPCClientHandler *)self getLogContext];
                uint64_t v31 = *(NSObject **)&buf[8];
                ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "getVoicemailCallInDetails, ... CallController is missing", buf, 2u);
                }
                unint64_t v28 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
                v7[2](v7, 0, v28);
              }

              if (v36) {
                sub_10004D2C8(v36);
              }
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              char v29 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
              {
                uint64_t v32 = (const char *)(v37 + 24);
                uint64_t v33 = *(unsigned __int8 *)(v37 + 47);
                int v34 = (char)v33;
                if ((v33 & 0x80u) != 0) {
                  uint64_t v33 = *(void *)(v37 + 32);
                }
                if (v34 < 0) {
                  uint64_t v32 = *(const char **)(v37 + 24);
                }
                if (!v33) {
                  uint64_t v32 = "<invalid>";
                }
                *(_DWORD *)long long buf = 136315138;
                *(void *)&buf[4] = v32;
                _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "SIM configuration '%s' is not active yet", buf, 0xCu);
              }
              id v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
              v7[2](v7, 0, v30);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            unsigned int v21 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Subscription Context does not have corresponding personality", buf, 2u);
            }
            unint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v22);
          }
          if (v38) {
            sub_10004D2C8(v38);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
          }
          uint64_t v24 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unsigned int v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v18 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getVoicemailCallInDetails", buf, 2u);
  }
LABEL_29:
}

- (void)isPNRSupported:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    id v8 = [(CTXPCClientHandler *)self dataProviderDelegate];
    uint64_t v9 = [v8 resolveContext:v6];

    if (v9)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v44);
      unint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&long long buf = v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&buf);
      if (v16)
      {
        uint64_t v18 = v16[3];
        char v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      char v17 = 0;
      char v19 = 1;
LABEL_16:
      if (v45) {
        sub_10004D2C8(v45);
      }
      if (!v18)
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v26 = v45;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v44);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v44) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", (uint8_t *)&v44, 2u);
        }
        int v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v7[2](v7, 0, v27);

        goto LABEL_29;
      }
      char v44 = 0;
      CFTypeRef v45 = 0;
      id v23 = [v9 uuid];
      sub_1005B09D4(v23, (CFUUIDRef *)&buf);
      (*(void (**)(Registry **__return_ptr, uint64_t, void))(*(void *)v18 + 16))(&v44, v18, buf);
      sub_10012577C((const void **)&buf);

      if (!v44 || *((unsigned char *)v44 + 49))
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v24 = *((void *)&buf + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Subscription Context does not have corresponding personality", (uint8_t *)&buf, 2u);
        }
        unsigned int v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        v7[2](v7, 0, v25);

LABEL_24:
        if (v45) {
          sub_10004D2C8(v45);
        }
LABEL_29:
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        id v6 = v9;
        goto LABEL_32;
      }
      if (!*((unsigned char *)v44 + 48))
      {
        [(CTXPCClientHandler *)self getLogContext];
        unint64_t v28 = *((void *)&buf + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          char v29 = (char *)v44 + 24;
          uint64_t v30 = *((unsigned __int8 *)v44 + 47);
          int v31 = (char)v30;
          if ((v30 & 0x80u) != 0) {
            uint64_t v30 = *((void *)v44 + 4);
          }
          if (v31 < 0) {
            char v29 = (const char *)*((void *)v44 + 3);
          }
          if (!v30) {
            char v29 = "<invalid>";
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, "SIM configuration '%s' is not active yet. But let it happen", (uint8_t *)&buf, 0xCu);
        }
      }
      [(CTXPCClientHandler *)self registry];
      uint64_t v32 = (std::mutex *)Registry::getServiceMap((Registry *)buf);
      uint64_t v33 = v32;
      if ((v34 & 0x8000000000000000) != 0)
      {
        uint64_t v35 = (unsigned __int8 *)(v34 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v36 = 5381;
        do
        {
          unint64_t v34 = v36;
          unsigned int v37 = *v35++;
          uint64_t v36 = (33 * v36) ^ v37;
        }
        while (v37);
      }
      std::mutex::lock(v32);
      unint64_t v46 = v34;
      CFTypeRef v38 = sub_10004D37C(&v33[1].__m_.__sig, &v46);
      if (v38)
      {
        uint64_t v40 = v38[3];
        long long v39 = (std::__shared_weak_count *)v38[4];
        if (v39)
        {
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v33);
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v39);
          char v41 = 0;
LABEL_50:
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          if (v40)
          {
            uint64_t v42 = (*(uint64_t (**)(uint64_t, void))(*(void *)v40 + 40))(v40, *((unsigned int *)v44 + 13));
            v7[2](v7, v42, 0);
          }
          else
          {
            v43 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v43);
          }
          if ((v41 & 1) == 0) {
            sub_10004D2C8(v39);
          }
          goto LABEL_24;
        }
      }
      else
      {
        uint64_t v40 = 0;
      }
      std::mutex::unlock(v33);
      long long v39 = 0;
      char v41 = 1;
      goto LABEL_50;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v21 = v45;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v44);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v44) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "no valid context found", (uint8_t *)&v44, 2u);
    }
    unint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, 0, v22);

    id v6 = 0;
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v45;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v44);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v44) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for isPNRSupported", (uint8_t *)&v44, 2u);
    }
  }
LABEL_32:
}

- (void)issuePNRRequest:(id)a3 pnrReqType:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (v10)
  {
    unint64_t v11 = [(CTXPCClientHandler *)self dataProviderDelegate];
    uint64_t v12 = [v11 resolveContext:v8];

    if (v12)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      uint64_t v14 = ServiceMap;
      if (v15 < 0)
      {
        uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v17 = 5381;
        do
        {
          uint64_t v15 = v17;
          unsigned int v18 = *v16++;
          uint64_t v17 = (33 * v17) ^ v18;
        }
        while (v18);
      }
      std::mutex::lock(ServiceMap);
      __p[0] = (void *)v15;
      char v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)__p);
      if (v19)
      {
        uint64_t v21 = v19[3];
        uint64_t v20 = (std::__shared_weak_count *)v19[4];
        if (v20)
        {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v14);
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v20);
          char v22 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        uint64_t v21 = 0;
      }
      std::mutex::unlock(v14);
      uint64_t v20 = 0;
      char v22 = 1;
LABEL_16:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (!v21)
      {
        [(CTXPCClientHandler *)self getLogContext];
        char v29 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
        }
        uint64_t v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        (*((void (**)(id, void, void, void *))v10 + 2))(v10, 0, 0, v30);

        goto LABEL_29;
      }
      uint64_t v107 = 0;
      v108 = 0;
      id v26 = [v12 uuid];
      sub_1005B09D4(v26, (CFUUIDRef *)buf);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, void))(*(void *)v21 + 16))(&v107, v21, *(void *)buf);
      sub_10012577C((const void **)buf);

      if (!v107 || *(unsigned char *)(v107 + 49))
      {
        [(CTXPCClientHandler *)self getLogContext];
        int v27 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Subscription Context does not have corresponding personality", buf, 2u);
        }
        unint64_t v28 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        (*((void (**)(id, void, void, void *))v10 + 2))(v10, 0, 0, v28);

LABEL_24:
        if (v108) {
          sub_10004D2C8(v108);
        }
LABEL_29:
        if ((v22 & 1) == 0) {
          sub_10004D2C8(v20);
        }
        id v8 = v12;
        goto LABEL_32;
      }
      if (!*(unsigned char *)(v107 + 48))
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v40 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          long long v55 = (const char *)(v107 + 24);
          uint64_t v56 = *(unsigned __int8 *)(v107 + 47);
          int v57 = (char)v56;
          if ((v56 & 0x80u) != 0) {
            uint64_t v56 = *(void *)(v107 + 32);
          }
          if (v57 < 0) {
            long long v55 = *(const char **)(v107 + 24);
          }
          if (!v56) {
            long long v55 = "<invalid>";
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&buf[4] = v55;
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "SIM configuration '%s' is not active yet", buf, 0xCu);
        }
        char v41 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        (*((void (**)(id, void, void, void *))v10 + 2))(v10, 0, 0, v41);

        goto LABEL_24;
      }
      [(CTXPCClientHandler *)self registry];
      int v31 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      uint64_t v32 = v31;
      if (v33 < 0)
      {
        unint64_t v34 = (unsigned __int8 *)(v33 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v35 = 5381;
        do
        {
          uint64_t v33 = v35;
          unsigned int v36 = *v34++;
          uint64_t v35 = (33 * v35) ^ v36;
        }
        while (v36);
      }
      std::mutex::lock(v31);
      __p[0] = (void *)v33;
      unsigned int v37 = sub_10004D37C(&v32[1].__m_.__sig, (unint64_t *)__p);
      if (v37)
      {
        uint64_t v38 = v37[3];
        long long v39 = (std::__shared_weak_count *)v37[4];
        if (v39)
        {
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v32);
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
          v78 = v39;
          sub_10004D2C8(v39);
          char v79 = 0;
          goto LABEL_44;
        }
      }
      else
      {
        uint64_t v38 = 0;
      }
      std::mutex::unlock(v32);
      v78 = 0;
      char v79 = 1;
LABEL_44:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v38)
      {
        uint64_t v77 = v38;
        if (v9)
        {
          uint64_t v42 = [v9 pushToken];
          if (v42)
          {
            v43 = [v9 pushToken];
            BOOL v44 = [v43 length] == 0;

            if (!v44)
            {
              CFTypeRef v45 = [v9 pushToken];

              CFDataRef theData = 0;
              sub_1000C163C(&theData, v45);
              if (theData) {
                unint64_t v46 = sub_10008324C;
              }
              else {
                unint64_t v46 = 0;
              }
              if (!v46)
              {
                [(CTXPCClientHandler *)self getLogContext];
                unsigned __int8 v52 = *(NSObject **)&buf[8];
                ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "Invalid token key for issuePNRRequest", buf, 2u);
                }
                long long v53 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 22, 0, v77, v78);
                (*((void (**)(id, void, void, void *))v10 + 2))(v10, 0, 0, v53);

LABEL_134:
                sub_100030068((const void **)&theData);
LABEL_135:
                if ((v79 & 1) == 0) {
                  sub_10004D2C8(v78);
                }
                goto LABEL_24;
              }
              CFStringRef v105 = 0;
              CFStringRef v47 = sub_1003F2B2C(kCFAllocatorDefault, theData);
              xpc_object_t v104 = 0;
              CFStringRef v105 = v47;
              xpc_object_t v48 = xpc_dictionary_create(0, 0, 0);
              xpc_object_t v49 = v48;
              if (v48)
              {
                xpc_object_t v104 = v48;
              }
              else
              {
                xpc_object_t v49 = xpc_null_create();
                xpc_object_t v104 = v49;
                if (!v49)
                {
                  xpc_object_t v54 = xpc_null_create();
                  xpc_object_t v49 = 0;
                  goto LABEL_75;
                }
              }
              if (xpc_get_type(v49) == (xpc_type_t)&_xpc_type_dictionary)
              {
                xpc_retain(v49);
LABEL_76:
                xpc_release(v49);
                xpc_object_t v102 = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
                if (!v102) {
                  xpc_object_t v102 = xpc_null_create();
                }
                *(void *)long long buf = &v104;
                *(void *)&uint8_t buf[8] = "kSmsToken";
                sub_100035E70((uint64_t)buf, &v102, &object);
                xpc_release(object);
                xpc_object_t object = 0;
                xpc_release(v102);
                xpc_object_t v102 = 0;
                uint64_t v58 = [v9 attemptCount];
                long long v59 = v58;
                if (v58)
                {
                  CFTypeID v60 = CFGetTypeID(v58);
                  if (v60 == CFNumberGetTypeID()) {
                    long long v61 = v59;
                  }
                  else {
                    long long v61 = 0;
                  }
                }
                else
                {
                  long long v61 = 0;
                }

                ctu::cf_to_xpc((uint64_t *)&v100, v61, v62);
                *(void *)long long buf = &v104;
                *(void *)&uint8_t buf[8] = "kSmsPhoneNumberRegistrationAttemptCount";
                sub_100035E70((uint64_t)buf, &v100, &v101);
                xpc_release(v101);
                xpc_object_t v101 = 0;
                xpc_release(v100);
                xpc_object_t v100 = 0;
                xpc_object_t v63 = xpc_array_create(0, 0);
                if (v63 || (xpc_object_t v63 = xpc_null_create()) != 0)
                {
                  if (xpc_get_type(v63) == (xpc_type_t)&_xpc_type_array)
                  {
                    xpc_retain(v63);
                    xpc_object_t xarray = v63;
                  }
                  else
                  {
                    xpc_object_t xarray = xpc_null_create();
                  }
                }
                else
                {
                  xpc_object_t xarray = xpc_null_create();
                  xpc_object_t v63 = 0;
                }
                xpc_release(v63);
                long long v98 = 0u;
                long long v99 = 0u;
                long long v96 = 0u;
                long long v97 = 0u;
                id obj = [v9 pnrReqList];
                id v64 = [obj countByEnumeratingWithState:&v96 objects:v109 count:16];
                if (v64)
                {
                  uint64_t v81 = *(void *)v97;
LABEL_91:
                  uint64_t v65 = 0;
                  while (1)
                  {
                    if (*(void *)v97 != v81) {
                      objc_enumerationMutation(obj);
                    }
                    NSErrorUserInfoKey v66 = *(void **)(*((void *)&v96 + 1) + 8 * v65);
                    xpc_object_t value = 0;
                    xpc_object_t v67 = xpc_dictionary_create(0, 0, 0);
                    xpc_object_t v68 = v67;
                    if (v67)
                    {
                      xpc_object_t value = v67;
                    }
                    else
                    {
                      xpc_object_t v68 = xpc_null_create();
                      xpc_object_t value = v68;
                      if (!v68)
                      {
                        xpc_object_t v69 = xpc_null_create();
                        xpc_object_t v68 = 0;
                        goto LABEL_101;
                      }
                    }
                    if (xpc_get_type(v68) != (xpc_type_t)&_xpc_type_dictionary)
                    {
                      xpc_object_t v69 = xpc_null_create();
LABEL_101:
                      xpc_object_t value = v69;
                      goto LABEL_102;
                    }
                    xpc_retain(v68);
LABEL_102:
                    xpc_release(v68);
                    if ([v66 pnrMechanism] == (id)2)
                    {
                      xpc_object_t v93 = xpc_int64_create(2);
                      if (!v93) {
                        xpc_object_t v93 = xpc_null_create();
                      }
                      *(void *)long long buf = &value;
                      *(void *)&uint8_t buf[8] = "kPhoneNumberRegistrationMechanismType";
                      sub_100035E70((uint64_t)buf, &v93, &v94);
                      xpc_release(v94);
                      xpc_object_t v94 = 0;
                      xpc_release(v93);
                      xpc_object_t v93 = 0;
                    }
                    else
                    {
                      if ([v66 pnrMechanism] != (id)1)
                      {
                        [(CTXPCClientHandler *)self getLogContext];
                        v75 = *(NSObject **)&buf[8];
                        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                        if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_error_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "Invalid pnrMechanism Type for Phone number Registration.", buf, 2u);
                        }
                        v76 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 22, 0, v77, v78);
                        (*((void (**)(id, void, void, void *))v10 + 2))(v10, 0, 0, v76);

                        xpc_release(value);
                        goto LABEL_133;
                      }
                      xpc_object_t v91 = xpc_int64_create(1);
                      if (!v91) {
                        xpc_object_t v91 = xpc_null_create();
                      }
                      *(void *)long long buf = &value;
                      *(void *)&uint8_t buf[8] = "kPhoneNumberRegistrationMechanismType";
                      sub_100035E70((uint64_t)buf, &v91, &v92);
                      xpc_release(v92);
                      xpc_object_t v92 = 0;
                      xpc_release(v91);
                      xpc_object_t v91 = 0;
                      v70 = [v66 svcCenterAddr];
                      memset(buf, 0, sizeof(buf));
                      uint64_t v111 = 0;
                      ctu::cf::assign();
                      *(_OWORD *)long long __p = *(_OWORD *)buf;
                      uint64_t v88 = v111;
                      if (v111 >= 0) {
                        v71 = __p;
                      }
                      else {
                        v71 = (void **)__p[0];
                      }
                      xpc_object_t v89 = xpc_string_create((const char *)v71);
                      if (!v89) {
                        xpc_object_t v89 = xpc_null_create();
                      }
                      *(void *)long long buf = &value;
                      *(void *)&uint8_t buf[8] = "kPhoneNumberRegistrationServiceCenterAddress";
                      sub_100035E70((uint64_t)buf, &v89, &v90);
                      xpc_release(v90);
                      xpc_object_t v90 = 0;
                      xpc_release(v89);
                      xpc_object_t v89 = 0;
                      if (SHIBYTE(v88) < 0) {
                        operator delete(__p[0]);
                      }

                      v72 = [v66 destAddr];
                      memset(buf, 0, sizeof(buf));
                      uint64_t v111 = 0;
                      ctu::cf::assign();
                      *(_OWORD *)long long __p = *(_OWORD *)buf;
                      uint64_t v88 = v111;
                      if (v111 >= 0) {
                        v73 = __p;
                      }
                      else {
                        v73 = (void **)__p[0];
                      }
                      xpc_object_t v85 = xpc_string_create((const char *)v73);
                      if (!v85) {
                        xpc_object_t v85 = xpc_null_create();
                      }
                      *(void *)long long buf = &value;
                      *(void *)&uint8_t buf[8] = "kPhoneNumberRegistrationDestinationAddress";
                      sub_100035E70((uint64_t)buf, &v85, &v86);
                      xpc_release(v86);
                      xpc_object_t v86 = 0;
                      xpc_release(v85);
                      xpc_object_t v85 = 0;
                      if (SHIBYTE(v88) < 0) {
                        operator delete(__p[0]);
                      }
                    }
                    xpc_array_append_value(xarray, value);
                    xpc_release(value);
                    if (v64 == (id)++v65)
                    {
                      id v64 = [obj countByEnumeratingWithState:&v96 objects:v109 count:16];
                      if (v64) {
                        goto LABEL_91;
                      }
                      break;
                    }
                  }
                }

                if (xpc_get_type(xarray) == (xpc_type_t)&_xpc_type_array && xpc_array_get_count(xarray))
                {
                  sub_1003BC2B8(&v83, xarray);
                  *(void *)long long buf = &v104;
                  *(void *)&uint8_t buf[8] = "kPhoneNumberRegistrationMechanisms";
                  sub_10017AC14((uint64_t)buf, &v83, &v84);
                  xpc_release(v84);
                  xpc_object_t v84 = 0;
                  xpc_release(v83);
                  xpc_object_t v83 = 0;
                }
                unsigned __int16 v74 = (*(uint64_t (**)(uint64_t, void, xpc_object_t *))(*(void *)v77 + 32))(v77, *(unsigned int *)(v107 + 52), &v104);
                (*((void (**)(id, BOOL, BOOL, void))v10 + 2))(v10, v74 != 0, v74 > 0xFFu, 0);
LABEL_133:
                xpc_release(xarray);
                xpc_release(v104);
                sub_1000558F4((const void **)&v105);
                goto LABEL_134;
              }
              xpc_object_t v54 = xpc_null_create();
LABEL_75:
              xpc_object_t v104 = v54;
              goto LABEL_76;
            }
          }
        }
        [(CTXPCClientHandler *)self getLogContext];
        uint8_t v50 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "Invalid pnrReqType argument", buf, 2u);
        }
      }
      long long v51 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      (*((void (**)(id, void, void, void *))v10 + 2))(v10, 0, 0, v51);

      goto LABEL_135;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v24 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "no valid context found", buf, 2u);
    }
    unsigned int v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, void, void *))v10 + 2))(v10, 0, 0, v25);

    id v8 = 0;
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v23 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid completion handler for issuePNRRequest", buf, 2u);
    }
  }
LABEL_32:
}

- (void)getPNRContext:(id)a3 completion:(id)a4
{
  void (***v48)(uint8_t *__return_ptr, void, uint64_t);
  char v49;
  NSObject *v50;
  void *v51;
  uint64_t v52;
  void (**v53)(id, void, void *);
  NSObject *v54;
  void *v55;
  NSObject *v56;
  void *v57;
  const char *v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  char v63;
  uint8_t buf[8];
  std::__shared_weak_count *v65;
  unint64_t v66;
  void v67[4];
  long long v68;
  uint8_t v69[24];

  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    id v8 = [(CTXPCClientHandler *)self dataProviderDelegate];
    id v9 = [v8 resolveContext:v6];

    if (v9)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      unint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      *(void *)xpc_object_t v69 = v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)v69);
      if (v16)
      {
        uint64_t v18 = v16[3];
        uint64_t v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      uint64_t v17 = 0;
      char v19 = 1;
LABEL_16:
      if (v65) {
        sub_10004D2C8(v65);
      }
      if (!v18)
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v26 = v65;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
        }
        int v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v7[2](v7, 0, v27);

        goto LABEL_29;
      }
      *(void *)long long buf = 0;
      uint64_t v65 = 0;
      id v23 = [v9 uuid];
      sub_1005B09D4(v23, (CFUUIDRef *)v69);
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v18 + 16))(buf, v18, *(void *)v69);
      sub_10012577C((const void **)v69);

      if (!*(void *)buf || *(unsigned char *)(*(void *)buf + 49))
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v24 = *(NSObject **)&v69[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v69);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)xpc_object_t v69 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Subscription Context does not have corresponding personality", v69, 2u);
        }
        unsigned int v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        v7[2](v7, 0, v25);

LABEL_24:
        if (v65) {
          sub_10004D2C8(v65);
        }
LABEL_29:
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        id v6 = v9;
        goto LABEL_32;
      }
      if (!*(unsigned char *)(*(void *)buf + 48))
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v38 = *(NSObject **)&v69[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v69);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          uint64_t v58 = (const char *)(*(void *)buf + 24);
          long long v59 = *(unsigned __int8 *)(*(void *)buf + 47);
          CFTypeID v60 = (char)v59;
          if ((v59 & 0x80u) != 0) {
            long long v59 = *(void *)(*(void *)buf + 32);
          }
          if (v60 < 0) {
            uint64_t v58 = *(const char **)(*(void *)buf + 24);
          }
          if (!v59) {
            uint64_t v58 = "<invalid>";
          }
          *(_DWORD *)xpc_object_t v69 = 136315138;
          *(void *)&v69[4] = v58;
          _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "SIM configuration '%s' is not active yet", v69, 0xCu);
        }
        long long v39 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v7[2](v7, 0, v39);

        goto LABEL_24;
      }
      [(CTXPCClientHandler *)self registry];
      unint64_t v28 = (std::mutex *)Registry::getServiceMap(*(Registry **)v69);
      char v29 = v28;
      if (v30 < 0)
      {
        int v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v32 = 5381;
        do
        {
          uint64_t v30 = v32;
          unsigned int v33 = *v31++;
          uint64_t v32 = (33 * v32) ^ v33;
        }
        while (v33);
      }
      std::mutex::lock(v28);
      *(void *)&xpc_object_t v68 = v30;
      unint64_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)&v68);
      if (v34)
      {
        uint64_t v36 = v34[3];
        uint64_t v35 = (std::__shared_weak_count *)v34[4];
        if (v35)
        {
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v29);
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v35);
          char v37 = 0;
          goto LABEL_44;
        }
      }
      else
      {
        uint64_t v36 = 0;
      }
      std::mutex::unlock(v29);
      uint64_t v35 = 0;
      char v37 = 1;
LABEL_44:
      if (*(void *)&v69[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v69[8]);
      }
      if (!v36)
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint8_t v50 = *(NSObject **)&v69[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v69);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)xpc_object_t v69 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "PNR Manager not available", v69, 2u);
        }
        long long v51 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        v7[2](v7, 0, v51);

        goto LABEL_73;
      }
      xpc_object_t v63 = v19;
      [v9 slotID];
      *(_OWORD *)xpc_object_t v69 = 0uLL;
      [(CTXPCClientHandler *)self registry];
      uint64_t v40 = (std::mutex *)Registry::getServiceMap((Registry *)v68);
      char v41 = v40;
      if ((v42 & 0x8000000000000000) != 0)
      {
        v43 = (unsigned __int8 *)(v42 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v44 = 5381;
        do
        {
          unint64_t v42 = v44;
          unsigned int v45 = *v43++;
          uint64_t v44 = (33 * v44) ^ v45;
        }
        while (v45);
      }
      std::mutex::lock(v40);
      NSErrorUserInfoKey v66 = v42;
      unint64_t v46 = sub_10004D37C(&v41[1].__m_.__sig, &v66);
      if (v46)
      {
        xpc_object_t v48 = (void (***)(uint8_t *__return_ptr, void, uint64_t))v46[3];
        CFStringRef v47 = (std::__shared_weak_count *)v46[4];
        if (v47)
        {
          long long v62 = v36;
          atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v41);
          atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v47);
          xpc_object_t v49 = 0;
LABEL_58:
          (**v48)(v69, v48, *(void *)buf + 24);
          char v19 = v63;
          if ((v49 & 1) == 0) {
            sub_10004D2C8(v47);
          }
          if (*((void *)&v68 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v68 + 1));
          }
          if (*(void *)v69)
          {
            if ((*(uint64_t (**)(void))(**(void **)v69 + 80))(*(void *)v69))
            {
              unsigned __int8 v52 = *(unsigned int *)(*(void *)buf + 52);
              long long v53 = objc_retainBlock(v7);
              v67[0] = off_1019C4940;
              v67[1] = v53;
              v67[3] = v67;
              (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v36 + 24))(v36, v52, v67);
              sub_1003BEA1C(v67);
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              uint64_t v56 = *((void *)&v68 + 1);
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v68);
              if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
              {
                LOWORD(v68) = 0;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_INFO, "get phone number marked as not allowed by carrier", (uint8_t *)&v68, 2u);
              }
              int v57 = objc_opt_new();
              [v57 setIsReady:0];
              [v57 setImsi:&stru_101AC1B28];
              [v57 setPlmn:&stru_101AC1B28];
              [v57 setPhoneNumber:&stru_101AC1B28];
              [v57 setPhoneNumberOnSIM:&stru_101AC1B28];
              ((void (**)(id, void *, void *))v7)[2](v7, v57, 0);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            xpc_object_t v54 = *((void *)&v68 + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v68);
            if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
            {
              long long v61 = subscriber::asString();
              LODWORD(v68) = 136315138;
              *(void *)((char *)&v68 + 4) = v61;
              _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "Carrier Entitlement Controller not available for slot %s", (uint8_t *)&v68, 0xCu);
            }
            long long v55 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", NSPOSIXErrorDomain, 22, 0, v62);
            v7[2](v7, 0, v55);
          }
          if (*(void *)&v69[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v69[8]);
          }
LABEL_73:
          if ((v37 & 1) == 0) {
            sub_10004D2C8(v35);
          }
          goto LABEL_24;
        }
      }
      else
      {
        xpc_object_t v48 = 0;
      }
      std::mutex::unlock(v41);
      CFStringRef v47 = 0;
      xpc_object_t v49 = 1;
      goto LABEL_58;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = v65;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "no valid context found", buf, 2u);
    }
    char v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, 0, v22);

    id v6 = 0;
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v65;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for getPNRContext", buf, 2u);
    }
  }
LABEL_32:
}

- (void)isPhoneNumberCredentialValid:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    id v8 = [(CTXPCClientHandler *)self dataProviderDelegate];
    id v9 = [v8 resolveContext:v6];

    if (v9)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v48);
      unint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&long long buf = v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&buf);
      if (v16)
      {
        uint64_t v18 = v16[3];
        uint64_t v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      uint64_t v17 = 0;
      char v19 = 1;
LABEL_16:
      if (v49) {
        sub_10004D2C8(v49);
      }
      if (!v18)
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v26 = v49;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v48);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v48) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", (uint8_t *)&v48, 2u);
        }
        int v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v7[2](v7, 0, v27);

        goto LABEL_29;
      }
      xpc_object_t v48 = 0;
      xpc_object_t v49 = 0;
      id v23 = [v9 uuid];
      sub_1005B09D4(v23, (CFUUIDRef *)&buf);
      (*(void (**)(Registry **__return_ptr, uint64_t, void))(*(void *)v18 + 16))(&v48, v18, buf);
      sub_10012577C((const void **)&buf);

      if (!v48 || *((unsigned char *)v48 + 49))
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v24 = *((void *)&buf + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Subscription Context does not have corresponding personality", (uint8_t *)&buf, 2u);
        }
        unsigned int v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        v7[2](v7, 0, v25);

LABEL_24:
        if (v49) {
          sub_10004D2C8(v49);
        }
LABEL_29:
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        id v6 = v9;
        goto LABEL_32;
      }
      if (!*((unsigned char *)v48 + 48))
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v38 = *((void *)&buf + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          unsigned int v45 = (char *)v48 + 24;
          uint64_t v46 = *((unsigned __int8 *)v48 + 47);
          int v47 = (char)v46;
          if ((v46 & 0x80u) != 0) {
            uint64_t v46 = *((void *)v48 + 4);
          }
          if (v47 < 0) {
            unsigned int v45 = (const char *)*((void *)v48 + 3);
          }
          if (!v46) {
            unsigned int v45 = "<invalid>";
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v45;
          _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "SIM configuration '%s' is not active yet", (uint8_t *)&buf, 0xCu);
        }
        long long v39 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v7[2](v7, 0, v39);

        goto LABEL_24;
      }
      [(CTXPCClientHandler *)self registry];
      unint64_t v28 = (std::mutex *)Registry::getServiceMap((Registry *)buf);
      char v29 = v28;
      if ((v30 & 0x8000000000000000) != 0)
      {
        int v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v32 = 5381;
        do
        {
          unint64_t v30 = v32;
          unsigned int v33 = *v31++;
          uint64_t v32 = (33 * v32) ^ v33;
        }
        while (v33);
      }
      std::mutex::lock(v28);
      unint64_t v50 = v30;
      unint64_t v34 = sub_10004D37C(&v29[1].__m_.__sig, &v50);
      if (v34)
      {
        uint64_t v36 = v34[3];
        uint64_t v35 = (std::__shared_weak_count *)v34[4];
        if (v35)
        {
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v29);
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v35);
          char v37 = 0;
LABEL_44:
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          if (v36)
          {
            uint64_t v40 = (*(uint64_t (**)(uint64_t, void))(*(void *)v36 + 40))(v36, *((unsigned int *)v48 + 13));
            [(CTXPCClientHandler *)self getLogContext];
            char v41 = *((void *)&buf + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
            {
              unint64_t v42 = "false";
              if (v40) {
                unint64_t v42 = "true";
              }
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v42;
              _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_INFO, "Phone Number Credential valid:%s", (uint8_t *)&buf, 0xCu);
            }
            v7[2](v7, v40, 0);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            v43 = *((void *)&buf + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "PNR Manager not available", (uint8_t *)&buf, 2u);
            }
            uint64_t v44 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v44);
          }
          if ((v37 & 1) == 0) {
            sub_10004D2C8(v35);
          }
          goto LABEL_24;
        }
      }
      else
      {
        uint64_t v36 = 0;
      }
      std::mutex::unlock(v29);
      uint64_t v35 = 0;
      char v37 = 1;
      goto LABEL_44;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = v49;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v48);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v48) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "no valid context found", (uint8_t *)&v48, 2u);
    }
    char v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, 0, v22);

    id v6 = 0;
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v49;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v48);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v48) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for isPhoneNumberCredentialValid", (uint8_t *)&v48, 2u);
    }
  }
LABEL_32:
}

- (void)context:(id)a3 getPhoneNumberSignatureWithCompletion:(id)a4
{
  void (***v32)(const void **__return_ptr, void, uint64_t);
  char v33;
  NSObject *v34;
  void *v35;
  NSObject *v36;
  void *v37;
  uint64_t (*v38)(uint64_t);
  NSObject *v39;
  void *v40;
  NSObject *v41;
  const char *v42;
  uint64_t v43;
  int v44;
  void *v45;
  const char *v46;
  uint64_t v47;
  int v48;
  const void *v49;
  NSObject *v50;
  uint8_t buf[8];
  std::__shared_weak_count *v52;
  uint64_t v53;
  long long v54;

  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    id v8 = [(CTXPCClientHandler *)self dataProviderDelegate];
    id v9 = [v8 resolveContext:v6];

    if (v9)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      unint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      xpc_object_t v49 = (const void *)v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v49);
      if (v16)
      {
        uint64_t v18 = v16[3];
        uint64_t v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      uint64_t v17 = 0;
      char v19 = 1;
LABEL_16:
      if (v52) {
        sub_10004D2C8(v52);
      }
      if (!v18)
      {
        [(CTXPCClientHandler *)self getLogContext];
        unint64_t v34 = v52;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
        }
        uint64_t v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v7[2](v7, 0, v35);

        goto LABEL_60;
      }
      *(void *)long long buf = 0;
      unsigned __int8 v52 = 0;
      id v23 = [v9 uuid];
      sub_1005B09D4(v23, (CFUUIDRef *)&v49);
      (*(void (**)(uint8_t *__return_ptr, uint64_t, const void *))(*(void *)v18 + 16))(buf, v18, v49);
      sub_10012577C(&v49);

      if (!*(void *)buf)
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v36 = v50;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v49);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v49) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Subscription Context does not have corresponding personality", (uint8_t *)&v49, 2u);
        }
        char v37 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        v7[2](v7, 0, v37);

        goto LABEL_58;
      }
      xpc_object_t v49 = 0;
      unint64_t v50 = 0;
      [(CTXPCClientHandler *)self registry];
      uint64_t v24 = (std::mutex *)Registry::getServiceMap((Registry *)v54);
      unsigned int v25 = v24;
      if (v26 < 0)
      {
        int v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v28 = 5381;
        do
        {
          uint64_t v26 = v28;
          unsigned int v29 = *v27++;
          uint64_t v28 = (33 * v28) ^ v29;
        }
        while (v29);
      }
      std::mutex::lock(v24);
      long long v53 = v26;
      unint64_t v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)&v53);
      if (v30)
      {
        uint64_t v32 = (void (***)(const void **__return_ptr, void, uint64_t))v30[3];
        int v31 = (std::__shared_weak_count *)v30[4];
        if (v31)
        {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v25);
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v31);
          unsigned int v33 = 0;
LABEL_34:
          (**v32)(&v49, v32, *(void *)buf + 24);
          if ((v33 & 1) == 0) {
            sub_10004D2C8(v31);
          }
          if (*((void *)&v54 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v54 + 1));
          }
          if (v49)
          {
            long long v53 = 0;
            (*(void (**)(uint64_t *__return_ptr))(*(void *)v49 + 344))(&v53);
            if (v53) {
              uint64_t v38 = sub_100080778;
            }
            else {
              uint64_t v38 = 0;
            }
            if (v38)
            {
              ((void (*)(void (**)(id, void, void *)))v7[2])(v7);
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              char v41 = *((void *)&v54 + 1);
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v54);
              if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
              {
                unint64_t v42 = (const char *)(*(void *)buf + 24);
                v43 = *(unsigned __int8 *)(*(void *)buf + 47);
                uint64_t v44 = (char)v43;
                if ((v43 & 0x80u) != 0) {
                  v43 = *(void *)(*(void *)buf + 32);
                }
                if (v44 < 0) {
                  unint64_t v42 = *(const char **)(*(void *)buf + 24);
                }
                if (!v43) {
                  unint64_t v42 = "<invalid>";
                }
                LODWORD(v54) = 136315138;
                *(void *)((char *)&v54 + 4) = v42;
                _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "No signature dictionary found for %s", (uint8_t *)&v54, 0xCu);
              }
              unsigned int v45 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
              v7[2](v7, 0, v45);
            }
            sub_100057D78((const void **)&v53);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            long long v39 = *((void *)&v54 + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v54);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
            {
              uint64_t v46 = (const char *)(*(void *)buf + 24);
              int v47 = *(unsigned __int8 *)(*(void *)buf + 47);
              xpc_object_t v48 = (char)v47;
              if ((v47 & 0x80u) != 0) {
                int v47 = *(void *)(*(void *)buf + 32);
              }
              if (v48 < 0) {
                uint64_t v46 = *(const char **)(*(void *)buf + 24);
              }
              if (!v47) {
                uint64_t v46 = "<invalid>";
              }
              LODWORD(v54) = 136315138;
              *(void *)((char *)&v54 + 4) = v46;
              _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "No CarrierEntitlements controller found for personality %s", (uint8_t *)&v54, 0xCu);
            }
            uint64_t v40 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v40);
          }
          if (v50) {
            sub_10004D2C8((std::__shared_weak_count *)v50);
          }
LABEL_58:
          if (v52) {
            sub_10004D2C8(v52);
          }
LABEL_60:
          if ((v19 & 1) == 0) {
            sub_10004D2C8(v17);
          }
          id v6 = v9;
          goto LABEL_63;
        }
      }
      else
      {
        uint64_t v32 = 0;
      }
      std::mutex::unlock(v25);
      int v31 = 0;
      unsigned int v33 = 1;
      goto LABEL_34;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = v52;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "no valid context found", buf, 2u);
    }
    char v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, 0, v22);

    id v6 = 0;
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v52;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for getPhoneNumberSignatureWithCompletion", buf, 2u);
    }
  }
LABEL_63:
}

- (void)context:(id)a3 resetPhoneNumber:(id)a4
{
  void (***v32)(const void **__return_ptr, void, uint64_t);
  char v33;
  NSObject *v34;
  void *v35;
  NSObject *v36;
  void *v37;
  NSObject *v38;
  void *v39;
  const char *v40;
  uint64_t v41;
  int v42;
  const void *v43;
  NSObject *v44;
  uint8_t buf[8];
  std::__shared_weak_count *v46;
  unint64_t v47;
  long long v48;

  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    id v8 = [(CTXPCClientHandler *)self dataProviderDelegate];
    id v9 = [v8 resolveContext:v6];

    if (v9)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      unint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      v43 = (const void *)v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v43);
      if (v16)
      {
        uint64_t v18 = v16[3];
        uint64_t v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      uint64_t v17 = 0;
      char v19 = 1;
LABEL_16:
      if (v46) {
        sub_10004D2C8(v46);
      }
      if (!v18)
      {
        [(CTXPCClientHandler *)self getLogContext];
        unint64_t v34 = v46;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
        }
        uint64_t v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v7[2](v7, v35);

        goto LABEL_46;
      }
      *(void *)long long buf = 0;
      uint64_t v46 = 0;
      id v23 = [v9 uuid];
      sub_1005B09D4(v23, (CFUUIDRef *)&v43);
      (*(void (**)(uint8_t *__return_ptr, uint64_t, const void *))(*(void *)v18 + 16))(buf, v18, v43);
      sub_10012577C(&v43);

      if (!*(void *)buf)
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v36 = v44;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v43);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v43) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Subscription Context does not have corresponding personality", (uint8_t *)&v43, 2u);
        }
        char v37 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        v7[2](v7, v37);

        goto LABEL_44;
      }
      v43 = 0;
      uint64_t v44 = 0;
      [(CTXPCClientHandler *)self registry];
      uint64_t v24 = (std::mutex *)Registry::getServiceMap((Registry *)v48);
      unsigned int v25 = v24;
      if ((v26 & 0x8000000000000000) != 0)
      {
        int v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v28 = 5381;
        do
        {
          unint64_t v26 = v28;
          unsigned int v29 = *v27++;
          uint64_t v28 = (33 * v28) ^ v29;
        }
        while (v29);
      }
      std::mutex::lock(v24);
      int v47 = v26;
      unint64_t v30 = sub_10004D37C(&v25[1].__m_.__sig, &v47);
      if (v30)
      {
        uint64_t v32 = (void (***)(const void **__return_ptr, void, uint64_t))v30[3];
        int v31 = (std::__shared_weak_count *)v30[4];
        if (v31)
        {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v25);
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v31);
          unsigned int v33 = 0;
LABEL_34:
          (**v32)(&v43, v32, *(void *)buf + 24);
          if ((v33 & 1) == 0) {
            sub_10004D2C8(v31);
          }
          if (*((void *)&v48 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v48 + 1));
          }
          if (v43)
          {
            (*(void (**)(const void *))(*(void *)v43 + 536))(v43);
            v7[2](v7, 0);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v38 = *((void *)&v48 + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v48);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
            {
              uint64_t v40 = (const char *)(*(void *)buf + 24);
              char v41 = *(unsigned __int8 *)(*(void *)buf + 47);
              unint64_t v42 = (char)v41;
              if ((v41 & 0x80u) != 0) {
                char v41 = *(void *)(*(void *)buf + 32);
              }
              if (v42 < 0) {
                uint64_t v40 = *(const char **)(*(void *)buf + 24);
              }
              if (!v41) {
                uint64_t v40 = "<invalid>";
              }
              LODWORD(v48) = 136315138;
              *(void *)((char *)&v48 + 4) = v40;
              _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "No CarrierEntitlements controller found for personality %s", (uint8_t *)&v48, 0xCu);
            }
            long long v39 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, v39);
          }
          if (v44) {
            sub_10004D2C8((std::__shared_weak_count *)v44);
          }
LABEL_44:
          if (v46) {
            sub_10004D2C8(v46);
          }
LABEL_46:
          if ((v19 & 1) == 0) {
            sub_10004D2C8(v17);
          }
          id v6 = v9;
          goto LABEL_49;
        }
      }
      else
      {
        uint64_t v32 = 0;
      }
      std::mutex::unlock(v25);
      int v31 = 0;
      unsigned int v33 = 1;
      goto LABEL_34;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = v46;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "no valid context found", buf, 2u);
    }
    char v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, v22);

    id v6 = 0;
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v46;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for context:resetPhoneNumber:", buf, 2u);
    }
  }
LABEL_49:
}

- (void)setPrefForKey:(id)a3 heirarchy:(id)a4 value:(id)a5 storage:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  uint64_t v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v18 = ServiceMap;
    if ((v19 & 0x8000000000000000) != 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        unint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    v50[0] = v19;
    id v23 = sub_10004D37C(&v18[1].__m_.__sig, v50);
    if (v23)
    {
      uint64_t v25 = v23[3];
      uint64_t v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
LABEL_12:
        char v28 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 16))(v25);
        if ((v26 & 1) == 0) {
          sub_10004D2C8(v24);
        }
        if (v56) {
          sub_10004D2C8(v56);
        }
        if (v28)
        {
          if (v12)
          {
            *(void *)long long buf = 0;
            uint64_t v56 = 0;
            unint64_t v57 = 0;
            long long v51 = 0u;
            long long v52 = 0u;
            long long v53 = 0u;
            long long v54 = 0u;
            id v29 = v13;
            id v30 = [v29 countByEnumeratingWithState:&v51 objects:v58 count:16];
            if (v30)
            {
              uint64_t v31 = *(void *)v52;
              do
              {
                for (i = 0; i != v30; i = (char *)i + 1)
                {
                  if (*(void *)v52 != v31) {
                    objc_enumerationMutation(v29);
                  }
                  unsigned int v33 = *(std::__shared_weak_count_vtbl **)(*((void *)&v51 + 1) + 8 * i);
                  unint64_t v34 = v56;
                  if ((unint64_t)v56 >= v57)
                  {
                    uint64_t v36 = ((uint64_t)v56 - *(void *)buf) >> 3;
                    if ((unint64_t)(v36 + 1) >> 61) {
                      sub_10006A748();
                    }
                    unint64_t v37 = (uint64_t)(v57 - *(void *)buf) >> 2;
                    if (v37 <= v36 + 1) {
                      unint64_t v37 = v36 + 1;
                    }
                    if (v57 - *(void *)buf >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v38 = v37;
                    }
                    if (v38) {
                      long long v39 = (char *)sub_10004EF74((uint64_t)&v57, v38);
                    }
                    else {
                      long long v39 = 0;
                    }
                    uint64_t v40 = (std::__shared_weak_count_vtbl **)&v39[8 * v36];
                    *uint64_t v40 = v33;
                    p_shared_owners = (std::__shared_weak_count *)(v40 + 1);
                    unint64_t v42 = *(Registry **)buf;
                    char v41 = (Registry *)v56;
                    if (v56 != *(std::__shared_weak_count **)buf)
                    {
                      do
                      {
                        v43 = (std::__shared_weak_count_vtbl *)*((void *)v41 - 1);
                        char v41 = (Registry *)((char *)v41 - 8);
                        *--uint64_t v40 = v43;
                      }
                      while (v41 != v42);
                      char v41 = *(Registry **)buf;
                    }
                    *(void *)long long buf = v40;
                    uint64_t v56 = p_shared_owners;
                    unint64_t v57 = (unint64_t)&v39[8 * v38];
                    if (v41) {
                      operator delete(v41);
                    }
                  }
                  else
                  {
                    v56->__vftable = v33;
                    p_shared_owners = (std::__shared_weak_count *)&v34->__shared_owners_;
                  }
                  uint64_t v56 = p_shared_owners;
                }
                id v30 = [v29 countByEnumeratingWithState:&v51 objects:v58 count:16];
              }
              while (v30);
            }

            [v15 isEqualToString:@"nobackup"];
            v50[0] = 0;
            v50[1] = 0;
            [(CTXPCClientHandler *)self registry];
            sub_100076430(v50);
          }
          [(CTXPCClientHandler *)self getLogContext];
          int v47 = v56;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "setPrefForKey: key is nil", buf, 2u);
          }
          NSErrorUserInfoKey v59 = NSLocalizedDescriptionKey;
          CFStringRef v60 = @"key cannot be nil";
          xpc_object_t v48 = +[NSDictionary dictionaryWithObjects:&v60 forKeys:&v59 count:1];
          xpc_object_t v49 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v48];
          v16[2](v16, v49);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v44 = v56;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "setPrefForKey is only supported for Internal builds", buf, 2u);
          }
          NSErrorUserInfoKey v61 = NSLocalizedDescriptionKey;
          CFStringRef v62 = @"Not supported";
          unsigned int v45 = +[NSDictionary dictionaryWithObjects:&v62 forKeys:&v61 count:1];
          uint64_t v46 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:v45];
          v16[2](v16, v46);
        }
        goto LABEL_48;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v24 = 0;
    char v26 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  int v27 = v56;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Invalid completion handler for setPrefForKey", buf, 2u);
  }
LABEL_48:
}

- (void)getPrefForKey:(id)a3 heirarchy:(id)a4 storage:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(id, void, void *))a6;
  if (v13)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v15 = ServiceMap;
    if ((v16 & 0x8000000000000000) != 0)
    {
      uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        unint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(ServiceMap);
    v48[0] = v16;
    uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, v48);
    if (v20)
    {
      uint64_t v22 = v20[3];
      uint64_t v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
LABEL_12:
        char v25 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
        if ((v23 & 1) == 0) {
          sub_10004D2C8(v21);
        }
        if (v54) {
          sub_10004D2C8(v54);
        }
        if (v25)
        {
          if (v10)
          {
            int v47 = v12;
            *(void *)long long buf = 0;
            long long v54 = 0;
            unint64_t v55 = 0;
            long long v49 = 0u;
            long long v50 = 0u;
            long long v51 = 0u;
            long long v52 = 0u;
            id v26 = v11;
            id v27 = [v26 countByEnumeratingWithState:&v49 objects:v56 count:16];
            if (v27)
            {
              uint64_t v28 = *(void *)v50;
              do
              {
                for (i = 0; i != v27; i = (char *)i + 1)
                {
                  if (*(void *)v50 != v28) {
                    objc_enumerationMutation(v26);
                  }
                  id v30 = *(std::__shared_weak_count_vtbl **)(*((void *)&v49 + 1) + 8 * i);
                  uint64_t v31 = v54;
                  if ((unint64_t)v54 >= v55)
                  {
                    uint64_t v33 = ((uint64_t)v54 - *(void *)buf) >> 3;
                    if ((unint64_t)(v33 + 1) >> 61) {
                      sub_10006A748();
                    }
                    unint64_t v34 = (uint64_t)(v55 - *(void *)buf) >> 2;
                    if (v34 <= v33 + 1) {
                      unint64_t v34 = v33 + 1;
                    }
                    if (v55 - *(void *)buf >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v35 = v34;
                    }
                    if (v35) {
                      uint64_t v36 = (char *)sub_10004EF74((uint64_t)&v55, v35);
                    }
                    else {
                      uint64_t v36 = 0;
                    }
                    unint64_t v37 = (std::__shared_weak_count_vtbl **)&v36[8 * v33];
                    void *v37 = v30;
                    p_shared_owners = (std::__shared_weak_count *)(v37 + 1);
                    long long v39 = *(Registry **)buf;
                    unint64_t v38 = (Registry *)v54;
                    if (v54 != *(std::__shared_weak_count **)buf)
                    {
                      do
                      {
                        uint64_t v40 = (std::__shared_weak_count_vtbl *)*((void *)v38 - 1);
                        unint64_t v38 = (Registry *)((char *)v38 - 8);
                        *--unint64_t v37 = v40;
                      }
                      while (v38 != v39);
                      unint64_t v38 = *(Registry **)buf;
                    }
                    *(void *)long long buf = v37;
                    long long v54 = p_shared_owners;
                    unint64_t v55 = (unint64_t)&v36[8 * v35];
                    if (v38) {
                      operator delete(v38);
                    }
                  }
                  else
                  {
                    v54->__vftable = v30;
                    p_shared_owners = (std::__shared_weak_count *)&v31->__shared_owners_;
                  }
                  long long v54 = p_shared_owners;
                }
                id v27 = [v26 countByEnumeratingWithState:&v49 objects:v56 count:16];
              }
              while (v27);
            }

            [v47 isEqualToString:@"nobackup"];
            v48[0] = 0;
            v48[1] = 0;
            [(CTXPCClientHandler *)self registry];
            sub_100076430(v48);
          }
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v44 = v54;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "getPrefForKey: key is nil", buf, 2u);
          }
          NSErrorUserInfoKey v57 = NSLocalizedDescriptionKey;
          CFStringRef v58 = @"key cannot be nil";
          unsigned int v45 = +[NSDictionary dictionaryWithObjects:&v58 forKeys:&v57 count:1];
          uint64_t v46 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v45];
          v13[2](v13, 0, v46);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v41 = v54;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "getPrefForKey is only supported for Internal builds", buf, 2u);
          }
          NSErrorUserInfoKey v59 = NSLocalizedDescriptionKey;
          CFStringRef v60 = @"Not supported";
          unint64_t v42 = +[NSDictionary dictionaryWithObjects:&v60 forKeys:&v59 count:1];
          v43 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:v42];
          v13[2](v13, 0, v43);
        }
        goto LABEL_48;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    uint64_t v21 = 0;
    char v23 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v24 = v54;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid completion handler for getPrefForKey", buf, 2u);
  }
LABEL_48:
}

- (void)terminateProcess:(id)a3
{
  BOOL v4 = (void (**)(id, void))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v21);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, &v23);
    if (v11)
    {
      uint64_t v13 = v11[3];
      id v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        char v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v16)
        {
          v4[2](v4, 0);
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v20 = v22;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v21) = 0;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Shutting down CommCenter", (uint8_t *)&v21, 2u);
          }
          _Exit(0);
        }
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v17 = v22;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v21) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "terminateProcess is only supported for Internal builds", (uint8_t *)&v21, 2u);
        }
        NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
        CFStringRef v25 = @"Not supported";
        uint64_t v18 = +[NSDictionary dictionaryWithObjects:&v25 forKeys:&v24 count:1];
        unsigned int v19 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:v18];
        ((void (**)(id, void *))v4)[2](v4, v19);

        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    id v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v15 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v21) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for terminateProcess", (uint8_t *)&v21, 2u);
  }
LABEL_20:
}

- (void)getRadioPersonality:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void *, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v29);
      uint64_t v9 = ServiceMap;
      if ((v10 & 0x8000000000000000) != 0)
      {
        id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          unint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v31 = v10;
      char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v31);
      if (v14)
      {
        uint64_t v16 = v14[3];
        id v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          char v22 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 16))(v16);
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          if (v30) {
            sub_10004D2C8(v30);
          }
          if (v22)
          {
            unint64_t v23 = (capabilities::ct *)[v6 isEqualToString:@"Stewie"];
            if (v23)
            {
              NSErrorUserInfoKey v24 = +[NSNumber numberWithBool:capabilities::ct::supportsStewie(v23)];
              v7[2](v7, v24, 0);
            }
            else
            {
              NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
              CFStringRef v33 = @"Unrecognized identifier";
              NSErrorUserInfoKey v24 = +[NSDictionary dictionaryWithObjects:&v33 forKeys:&v32 count:1];
              uint64_t v28 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v24];
              ((void (**)(id, void *, void *))v7)[2](v7, 0, v28);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            CFStringRef v25 = v30;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v29) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "getRadioPersonality is only supported for Internal builds", (uint8_t *)&v29, 2u);
            }
            NSErrorUserInfoKey v34 = NSLocalizedDescriptionKey;
            CFStringRef v35 = @"Not supported";
            id v26 = +[NSDictionary dictionaryWithObjects:&v35 forKeys:&v34 count:1];
            id v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:v26];
            ((void (**)(id, void *, void *))v7)[2](v7, 0, v27);
          }
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      id v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v19 = v30;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v29) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "getRadioPersonality: identifier is nil", (uint8_t *)&v29, 2u);
    }
    NSErrorUserInfoKey v36 = NSLocalizedDescriptionKey;
    CFStringRef v37 = @"identifier cannot be nil";
    uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v37 forKeys:&v36 count:1];
    uint64_t v21 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:v20];
    ((void (**)(id, void *, void *))v7)[2](v7, 0, v21);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v30;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v29) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getRadioPersonality", (uint8_t *)&v29, 2u);
    }
  }
LABEL_28:
}

- (void)sendTaggedInfo:(id)a3 type:(unint64_t)a4 payload:(id)a5 completion:(id)a6
{
  unsigned __int16 v8 = a4;
  id v10 = a3;
  id v11 = a5;
  uint64_t v12 = (void (**)(id, void *))a6;
  if (v12)
  {
    if (!v10 || !v11)
    {
      NSErrorUserInfoKey v24 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v12[2](v12, v24);

      goto LABEL_27;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    char v14 = ServiceMap;
    if ((v15 & 0x8000000000000000) != 0)
    {
      uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        unint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v33 = v15;
    unsigned int v19 = sub_10004D37C(&v14[1].__m_.__sig, &v33);
    if (v19)
    {
      uint64_t v21 = v19[3];
      uint64_t v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
LABEL_15:
        if (v32) {
          sub_10004D2C8(v32);
        }
        if (v21)
        {
          id v25 = [v10 slotID];
          id v30 = v11;
          CFRetain(v11);
          if (v25 == (id)2) {
            uint64_t v26 = 2;
          }
          else {
            uint64_t v26 = v25 == (id)1;
          }
          id v27 = objc_retainBlock(v12);
          v34[0] = off_1019D4428;
          v34[1] = v27;
          void v34[3] = v34;
          (*(void (**)(uint64_t, uint64_t, void, const void **, void *))(*(void *)v21 + 48))(v21, v26, v8, &v30, v34);
          sub_100060644(v34);
          sub_100030068(&v30);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v28 = v32;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Could not find ELQM controller for sending ELQM info", buf, 2u);
          }
          id v29 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v12[2](v12, v29);
        }
        if ((v22 & 1) == 0) {
          sub_10004D2C8(v20);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    uint64_t v20 = 0;
    char v22 = 1;
    goto LABEL_15;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v23 = v32;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid completion handler for sending ELQM info", buf, 2u);
  }
LABEL_27:
}

- (void)setPacketContextActiveByServiceType:(id)a3 connectionType:(int)a4 active:(BOOL)a5 completion:(id)a6
{
  BOOL v7 = a5;
  id v9 = a3;
  id v10 = (void (**)(id, id))a6;
  if (!v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = v30;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for setPacketContextActiveByServiceType", buf, 2u);
    }
    goto LABEL_24;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  uint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    char v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v31 = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v31);
  if (v17)
  {
    uint64_t v19 = v17[3];
    unsigned int v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  unsigned int v18 = 0;
  char v20 = 1;
LABEL_12:
  if (v30) {
    sub_10004D2C8((std::__shared_weak_count *)v30);
  }
  if (!v19)
  {
    [(CTXPCClientHandler *)self getLogContext];
    NSErrorUserInfoKey v24 = v30;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "DataService uninitialized", buf, 2u);
    }
    id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v10[2](v10, v25);
LABEL_29:

    if (v20) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v19 + 768))(v19) & 1) == 0)
  {
    id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
    v10[2](v10, v25);
    goto LABEL_29;
  }
  v28[0] = v19;
  v28[1] = v18;
  if ((v20 & 1) == 0) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = sub_100045208(v28, v9);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  uint64_t v23 = ConnectionTypeToMask();
  sub_100058DB0(__p, "setPacketContextActiveByServiceType");
  (*(void (**)(uint64_t, uint64_t, uint64_t, BOOL, void **, void, void))(*(void *)v19 + 80))(v19, v22, v23, v7, __p, 0, 0);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  v10[2](v10, 0);
  if ((v20 & 1) == 0) {
LABEL_23:
  }
    sub_10004D2C8(v18);
LABEL_24:
}

- (void)requestSliceByUUID:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      long long __p = 0;
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      sub_100058DB0(&__p, (char *)[v6 UTF8String]);
      uint64_t v8 = HIBYTE(v31);
      if (v31 < 0) {
        uint64_t v8 = v30;
      }
      if (!v8)
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v22 = v35;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid sliceUUID for requestSliceByUUID", buf, 2u);
        }
        id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        (*((void (**)(id, void, void, void, id))v7 + 2))(v7, 0, 0, 0, v23);

        goto LABEL_33;
      }
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      id v10 = ServiceMap;
      if ((v11 & 0x8000000000000000) != 0)
      {
        uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v13 = 5381;
        do
        {
          unint64_t v11 = v13;
          unsigned int v14 = *v12++;
          uint64_t v13 = (33 * v13) ^ v14;
        }
        while (v14);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v32 = v11;
      uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v32);
      if (v15)
      {
        uint64_t v17 = v15[3];
        unsigned int v16 = (std::__shared_weak_count *)v15[4];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v10);
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          char v18 = 0;
LABEL_22:
          if (v35) {
            sub_10004D2C8((std::__shared_weak_count *)v35);
          }
          if (v17)
          {
            if ((*(uint64_t (**)(uint64_t))(*(void *)v17 + 768))(v17))
            {
              NSErrorUserInfoKey v24 = self;
              id v25 = objc_retainBlock(v7);
              CFStringRef v35 = v24;
              *(void *)long long buf = off_1019DE530;
              id v36 = v25;
              CFStringRef v37 = buf;
              sub_1005237A0((uint64_t)v33, (uint64_t)buf);
              (*(void (**)(uint64_t, void **, void *))(*(void *)v17 + 88))(v17, &__p, v33);
              sub_10052371C(v33);
              sub_10052371C(buf);
            }
            else
            {
              id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
              (*((void (**)(id, void, void, void, id))v7 + 2))(v7, 0, 0, 0, v28);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v26 = v35;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "DataService uninitialized", buf, 2u);
            }
            id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, void, void, id))v7 + 2))(v7, 0, 0, 0, v27);
          }
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v16);
          }
LABEL_33:
          if (SHIBYTE(v31) < 0) {
            operator delete(__p);
          }
          goto LABEL_35;
        }
      }
      else
      {
        uint64_t v17 = 0;
      }
      std::mutex::unlock(v10);
      unsigned int v16 = 0;
      char v18 = 1;
      goto LABEL_22;
    }
    [(CTXPCClientHandler *)self getLogContext];
    char v20 = v35;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid sliceUUID for requestSliceByUUID", buf, 2u);
    }
    id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, void, void, id))v7 + 2))(v7, 0, 0, 0, v21);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v35;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for requestSliceByUUID", buf, 2u);
    }
  }
LABEL_35:
}

- (void)requestSliceDeactivation:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, id))a4;
  if (v6)
  {
    long long __p = 0;
    id v28 = 0;
    uint64_t v29 = 0;
    sub_100058DB0(&__p, (char *)[v6 UTF8String]);
    uint64_t v8 = HIBYTE(v29);
    if (v29 < 0) {
      uint64_t v8 = v28;
    }
    if (!v8)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v21 = v26;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v25) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid interfaceName for requestSliceDeactivation (2)", (uint8_t *)&v25, 2u);
      }
      id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v22);

      goto LABEL_24;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v30 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v30);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
LABEL_19:
    if (v26) {
      sub_10004D2C8((std::__shared_weak_count *)v26);
    }
    if (v17)
    {
      (*(void (**)(uint64_t, void **))(*(void *)v17 + 96))(v17, &__p);
      v7[2](v7, 0);
      if (v18) {
        goto LABEL_24;
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v23 = v26;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v25) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "DataService uninitialized", (uint8_t *)&v25, 2u);
      }
      id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v7[2](v7, v24);

      if (v18) {
        goto LABEL_24;
      }
    }
    sub_10004D2C8(v16);
LABEL_24:
    if (SHIBYTE(v29) < 0) {
      operator delete(__p);
    }
    goto LABEL_26;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid interfaceName for requestSliceDeactivation (1)", (uint8_t *)&__p, 2u);
  }
  id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  v7[2](v7, v20);

LABEL_26:
}

- (void)resetAPNSettings:(id)a3
{
  BOOL v4 = (void (**)(id, void))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v15 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for resetAPNSettings", (uint8_t *)&v18, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v18);
  id v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v7;
  unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v20);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_12:
  if (v19) {
    sub_10004D2C8((std::__shared_weak_count *)v19);
  }
  if (v13)
  {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v13 + 512))(v13, 3, 0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v13 + 640))(v13, 3, 3, 0xFFFFFFFFLL, 0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v13 + 312))(v13, 3, 12, 0);
    v4[2](v4, 0);
    if ((v14 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v12);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v16 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "DataService uninitialized", (uint8_t *)&v18, 2u);
    }
    id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v4)[2](v4, v17);

    if ((v14 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)addLowLatencyFilter:(id)a3 pdp:(int)a4 queueSetId:(unint64_t)a5 uplink:(BOOL)a6 completion:(id)a7
{
  __int16 v8 = a6;
  uint64_t v10 = *(void *)&a4;
  id v12 = a3;
  uint64_t v13 = (capabilities::ct *)a7;
  char v14 = v13;
  if (!v13)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v26 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Invalid completion handler for addLowLatencyFilter", buf, 2u);
    }
    goto LABEL_52;
  }
  uint64_t v15 = (capabilities::ct *)capabilities::ct::supportsLLFilters(v13);
  if ((v15 & 1) == 0)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v27 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "LL filters not supported", buf, 2u);
    }
    id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*((void (**)(capabilities::ct *, id))v14 + 2))(v14, v28);

    goto LABEL_52;
  }
  if (!capabilities::ct::supportsDataQMIExtensions(v15))
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unint64_t v30 = ServiceMap;
    if (v31 < 0)
    {
      unint64_t v32 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v33 = 5381;
      do
      {
        uint64_t v31 = v33;
        unsigned int v34 = *v32++;
        uint64_t v33 = (33 * v33) ^ v34;
      }
      while (v34);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v44 = v31;
    CFStringRef v35 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)&v44);
    if (v35)
    {
      uint64_t v36 = v35[3];
      id v23 = (std::__shared_weak_count *)v35[4];
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v30);
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v23);
        char v37 = 0;
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v36 = 0;
    }
    std::mutex::unlock(v30);
    id v23 = 0;
    char v37 = 1;
LABEL_36:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v36)
    {
      long long v55 = 0u;
      long long v56 = 0u;
      long long v54 = 0u;
      *(_OWORD *)long long __p = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      *(_OWORD *)long long v49 = 0u;
      *(_OWORD *)long long buf = 0u;
      sub_1005AF9F0(v12, (uint64_t)buf);
      *(void *)&uint8_t buf[8] = a5;
      WORD6(v56) = v8 | 0x100;
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      uint64_t v45 = sub_100522D50(&v44, (uint64_t)buf);
      long long v39 = objc_retainBlock(v14);
      v58[0] = off_1019DE640;
      v58[1] = v39;
      v58[3] = v58;
      (*(void (**)(uint64_t, uint64_t, uint64_t *, unint64_t, void *))(*(void *)v36 + 880))(v36, v10, &v44, a5, v58);
      sub_100060644(v58);
      NSErrorUserInfoKey v57 = (void **)&v44;
      sub_100523284(&v57);
      if (BYTE8(v55) && (_BYTE)v54 && SHIBYTE(v53) < 0) {
        operator delete(__p[1]);
      }
      if (LOBYTE(__p[0]) && BYTE8(v50) && SBYTE7(v50) < 0) {
        operator delete(v49[0]);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      unint64_t v42 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "DataService not supported", buf, 2u);
      }
      id v43 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      (*((void (**)(capabilities::ct *, id))v14 + 2))(v14, v43);
    }
    if ((v37 & 1) == 0) {
      goto LABEL_51;
    }
    goto LABEL_52;
  }
  [(CTXPCClientHandler *)self registry];
  unsigned int v16 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  id v17 = v16;
  char v18 = "N8dormancy15DormancyServiceE";
  if (((unint64_t)"N8dormancy15DormancyServiceE" & 0x8000000000000000) != 0)
  {
    uint64_t v19 = (unsigned __int8 *)((unint64_t)"N8dormancy15DormancyServiceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      char v18 = (const char *)v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  uint64_t v44 = (uint64_t)v18;
  id v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&v44);
  if (v22)
  {
    uint64_t v24 = v22[3];
    id v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  id v23 = 0;
  char v25 = 1;
LABEL_23:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v24)
  {
    long long v55 = 0u;
    long long v56 = 0u;
    long long v54 = 0u;
    *(_OWORD *)long long __p = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    *(_OWORD *)long long v49 = 0u;
    *(_OWORD *)long long buf = 0u;
    sub_1005AF9F0(v12, (uint64_t)buf);
    *(void *)&uint8_t buf[8] = a5;
    unint64_t v38 = objc_retainBlock(v14);
    v59[0] = off_1019DE5C0;
    v59[1] = v38;
    v59[3] = v59;
    (*(void (**)(uint64_t, uint64_t, uint8_t *, void *))(*(void *)v24 + 56))(v24, v10, buf, v59);
    sub_100060644(v59);
    if (BYTE8(v55) && (_BYTE)v54 && SHIBYTE(v53) < 0) {
      operator delete(__p[1]);
    }
    if (LOBYTE(__p[0]) && BYTE8(v50) && SBYTE7(v50) < 0) {
      operator delete(v49[0]);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v40 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "DormancyService not supported", buf, 2u);
    }
    id v41 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*((void (**)(capabilities::ct *, id))v14 + 2))(v14, v41);
  }
  if ((v25 & 1) == 0) {
LABEL_51:
  }
    sub_10004D2C8(v23);
LABEL_52:
}

- (void)getLowLatencyFilters:(int)a3 queueSetId:(unint64_t)a4 completion:(id)a5
{
  uint64_t v6 = *(void *)&a3;
  __int16 v8 = (capabilities::ct *)a5;
  uint64_t v9 = v8;
  if (!v8)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v21 = v40;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v39);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v39) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for getLowLatencyFilters", (uint8_t *)&v39, 2u);
    }
    goto LABEL_38;
  }
  uint64_t v10 = (capabilities::ct *)capabilities::ct::supportsLLFilters(v8);
  if ((v10 & 1) == 0)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = v40;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v39);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v39) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "LL filters not supported", (uint8_t *)&v39, 2u);
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*((void (**)(capabilities::ct *, void, id))v9 + 2))(v9, 0, v23);

    goto LABEL_38;
  }
  if (!capabilities::ct::supportsDataQMIExtensions(v10))
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v39);
    char v25 = ServiceMap;
    if ((v26 & 0x8000000000000000) != 0)
    {
      id v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v28 = 5381;
      do
      {
        unint64_t v26 = v28;
        unsigned int v29 = *v27++;
        uint64_t v28 = (33 * v28) ^ v29;
      }
      while (v29);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v41 = v26;
    unint64_t v30 = sub_10004D37C(&v25[1].__m_.__sig, &v41);
    if (v30)
    {
      uint64_t v31 = v30[3];
      char v18 = (std::__shared_weak_count *)v30[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v25);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v32 = 0;
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v31 = 0;
    }
    std::mutex::unlock(v25);
    char v18 = 0;
    char v32 = 1;
LABEL_29:
    if (v40) {
      sub_10004D2C8((std::__shared_weak_count *)v40);
    }
    if (v31)
    {
      unsigned int v34 = objc_retainBlock(v9);
      v42[0] = off_1019DE750;
      v42[1] = v34;
      v42[3] = v42;
      (*(void (**)(uint64_t, uint64_t, unint64_t, void *))(*(void *)v31 + 896))(v31, v6, a4, v42);
      sub_100523F74(v42);
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v37 = v40;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v39);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v39) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "DataService not supported", (uint8_t *)&v39, 2u);
      }
      id v38 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      (*((void (**)(capabilities::ct *, void, id))v9 + 2))(v9, 0, v38);
    }
    if ((v32 & 1) == 0) {
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  [(CTXPCClientHandler *)self registry];
  unint64_t v11 = (std::mutex *)Registry::getServiceMap(v39);
  id v12 = v11;
  uint64_t v13 = "N8dormancy15DormancyServiceE";
  if (((unint64_t)"N8dormancy15DormancyServiceE" & 0x8000000000000000) != 0)
  {
    char v14 = (unsigned __int8 *)((unint64_t)"N8dormancy15DormancyServiceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = (const char *)v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(v11);
  unint64_t v41 = (unint64_t)v13;
  id v17 = sub_10004D37C(&v12[1].__m_.__sig, &v41);
  if (v17)
  {
    uint64_t v19 = v17[3];
    char v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  char v18 = 0;
  char v20 = 1;
LABEL_23:
  if (v40) {
    sub_10004D2C8((std::__shared_weak_count *)v40);
  }
  if (v19)
  {
    uint64_t v33 = objc_retainBlock(v9);
    v43[0] = off_1019DE6C0;
    v43[1] = v33;
    v43[3] = v43;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v19 + 72))(v19, v6, v43);
    sub_100523F74(v43);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    CFStringRef v35 = v40;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v39);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v39) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "DormancyService not supported", (uint8_t *)&v39, 2u);
    }
    id v36 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*((void (**)(capabilities::ct *, void, id))v9 + 2))(v9, 0, v36);
  }
  if ((v20 & 1) == 0) {
LABEL_37:
  }
    sub_10004D2C8(v18);
LABEL_38:
}

- (void)deleteLowLatencyFilter:(id)a3 pdp:(int)a4 queueSetId:(unint64_t)a5 uplink:(BOOL)a6 completion:(id)a7
{
  __int16 v8 = a6;
  uint64_t v10 = *(void *)&a4;
  id v12 = a3;
  uint64_t v13 = (capabilities::ct *)a7;
  char v14 = v13;
  if (!v13)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v26 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Invalid completion handler for deleteLowLatencyFilter", buf, 2u);
    }
    goto LABEL_40;
  }
  uint64_t v15 = (capabilities::ct *)capabilities::ct::supportsLLFilters(v13);
  if ((v15 & 1) == 0)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v27 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "LL filters not supported", buf, 2u);
    }
    id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*((void (**)(capabilities::ct *, id))v14 + 2))(v14, v28);

    goto LABEL_40;
  }
  if (!capabilities::ct::supportsDataQMIExtensions(v15))
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unint64_t v30 = ServiceMap;
    if (v31 < 0)
    {
      char v32 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v33 = 5381;
      do
      {
        uint64_t v31 = v33;
        unsigned int v34 = *v32++;
        uint64_t v33 = (33 * v33) ^ v34;
      }
      while (v34);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v45 = v31;
    CFStringRef v35 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)&v45);
    if (v35)
    {
      uint64_t v37 = v35[3];
      id v36 = (std::__shared_weak_count *)v35[4];
      if (v36)
      {
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v30);
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        id v23 = v36;
        sub_10004D2C8(v36);
        char v38 = 0;
        goto LABEL_42;
      }
    }
    else
    {
      uint64_t v37 = 0;
    }
    std::mutex::unlock(v30);
    id v23 = 0;
    char v38 = 1;
LABEL_42:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v37)
    {
      long long v56 = 0u;
      long long v57 = 0u;
      long long v55 = 0u;
      *(_OWORD *)long long __p = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      *(_OWORD *)long long v50 = 0u;
      *(_OWORD *)long long buf = 0u;
      sub_1005AF9F0(v12, (uint64_t)buf);
      *(void *)&uint8_t buf[8] = a5;
      WORD6(v57) = v8 | 0x100;
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      uint64_t v47 = 0;
      uint64_t v46 = sub_100522D50(&v45, (uint64_t)buf);
      unint64_t v42 = objc_retainBlock(v14);
      v59[0] = off_1019DE850;
      v59[1] = v42;
      v59[3] = v59;
      (*(void (**)(uint64_t, uint64_t, uint64_t *, unint64_t, void *))(*(void *)v37 + 888))(v37, v10, &v45, a5, v59);
      sub_100060644(v59);
      CFStringRef v58 = (void **)&v45;
      sub_100523284(&v58);
      if (BYTE8(v56) && (_BYTE)v55 && SHIBYTE(v54) < 0) {
        operator delete(__p[1]);
      }
      if (LOBYTE(__p[0]) && BYTE8(v51) && SBYTE7(v51) < 0) {
        operator delete(v50[0]);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v43 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "DataService not supported", buf, 2u);
      }
      id v44 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      (*((void (**)(capabilities::ct *, id))v14 + 2))(v14, v44);
    }
    if ((v38 & 1) == 0) {
      goto LABEL_39;
    }
    goto LABEL_40;
  }
  [(CTXPCClientHandler *)self registry];
  unsigned int v16 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  id v17 = v16;
  char v18 = "N8dormancy15DormancyServiceE";
  if (((unint64_t)"N8dormancy15DormancyServiceE" & 0x8000000000000000) != 0)
  {
    uint64_t v19 = (unsigned __int8 *)((unint64_t)"N8dormancy15DormancyServiceE" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      char v18 = (const char *)v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  uint64_t v45 = (uint64_t)v18;
  id v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&v45);
  if (v22)
  {
    uint64_t v24 = v22[3];
    id v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  id v23 = 0;
  char v25 = 1;
LABEL_23:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v24)
  {
    long long v56 = 0u;
    long long v57 = 0u;
    long long v55 = 0u;
    *(_OWORD *)long long __p = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    *(_OWORD *)long long v50 = 0u;
    *(_OWORD *)long long buf = 0u;
    sub_1005AF9F0(v12, (uint64_t)buf);
    long long v39 = objc_retainBlock(v14);
    v60[0] = off_1019DE7D0;
    v60[1] = v39;
    v60[3] = v60;
    (*(void (**)(uint64_t, uint64_t, uint8_t *, void *))(*(void *)v24 + 64))(v24, v10, buf, v60);
    sub_100060644(v60);
    if (BYTE8(v56) && (_BYTE)v55 && SHIBYTE(v54) < 0) {
      operator delete(__p[1]);
    }
    if (LOBYTE(__p[0]) && BYTE8(v51) && SBYTE7(v51) < 0) {
      operator delete(v50[0]);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v40 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "DormancyService not supported", buf, 2u);
    }
    id v41 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*((void (**)(capabilities::ct *, id))v14 + 2))(v14, v41);
  }
  if ((v25 & 1) == 0) {
LABEL_39:
  }
    sub_10004D2C8(v23);
LABEL_40:
}

- (void)sendDeadPeerDetection:(id)a3
{
  BOOL v4 = (void (**)(id, void))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v15 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for sendDeadPeerDetection", (uint8_t *)&v18, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v18);
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    __int16 v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v7;
  unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v20);
  if (v11)
  {
    uint64_t v13 = v11[3];
    id v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  id v12 = 0;
  char v14 = 1;
LABEL_12:
  if (v19) {
    sub_10004D2C8((std::__shared_weak_count *)v19);
  }
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 712))(v13);
    v4[2](v4, 0);
    if ((v14 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v12);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v16 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "DataService uninitialized", (uint8_t *)&v18, 2u);
    }
    id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v4)[2](v4, v17);

    if ((v14 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)setInternationalDataAccess:(id)a3 status:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = a5;
  if (v9)
  {
    if (v8)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v27);
      unint64_t v11 = ServiceMap;
      if ((v12 & 0x8000000000000000) != 0)
      {
        uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          unint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v29 = v12;
      unsigned int v16 = sub_10004D37C(&v11[1].__m_.__sig, &v29);
      if (v16)
      {
        uint64_t v18 = v16[3];
        id v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
LABEL_16:
          if (v28) {
            sub_10004D2C8(v28);
          }
          if (v18)
          {
            uint64_t v23 = sub_10003E318(v8);
            id v24 = objc_retainBlock(v9);
            v30[0] = off_1019DE8D0;
            v30[1] = v24;
            v30[3] = v30;
            (*(void (**)(uint64_t, uint64_t, BOOL, void *))(*(void *)v18 + 56))(v18, v23, v6, v30);
            sub_10001C9D4(v30);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            char v25 = v28;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v27) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find RoamingInterface for setting international data access", (uint8_t *)&v27, 2u);
            }
            id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, id))v9 + 2))(v9, v26);
          }
          if ((v19 & 1) == 0) {
            sub_10004D2C8(v17);
          }
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      id v17 = 0;
      char v19 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v21 = v28;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v27) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid descriptor for setting international data access status", (uint8_t *)&v27, 2u);
    }
    id v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void *))v9 + 2))(v9, v22);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v20 = v28;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v27) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting international data access status", (uint8_t *)&v27, 2u);
    }
  }
LABEL_25:
}

- (void)getInternationalDataAccess:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
      id v9 = ServiceMap;
      if ((v10 & 0x8000000000000000) != 0)
      {
        unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          unint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v27 = v10;
      uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
      if (v14)
      {
        uint64_t v16 = v14[3];
        unsigned int v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (v26) {
            sub_10004D2C8(v26);
          }
          if (v16)
          {
            uint64_t v21 = sub_10003E318(v6);
            id v22 = objc_retainBlock(v7);
            v28[0] = off_1019DE950;
            v28[1] = v22;
            v28[3] = v28;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 48))(v16, v21, v28);
            sub_100060644(v28);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v23 = v26;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v25) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find RoamingInterface for international data access query", (uint8_t *)&v25, 2u);
            }
            id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, id))v7 + 2))(v7, 0, v24);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      unsigned int v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    char v19 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid descriptor for international data access status query", (uint8_t *)&v25, 2u);
    }
    unint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v20);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for international data access status query", (uint8_t *)&v25, 2u);
    }
  }
LABEL_25:
}

- (void)setSupportDynamicDataSimSwitch:(BOOL)a3 completion:(id)a4
{
  BOOL v4 = a3;
  id v6 = (void (**)(id, void))a4;
  if (!v6)
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v17 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler for setSupportDynamicDataSimSwitch", (uint8_t *)&__p, 2u);
    }
    goto LABEL_19;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p);
  id v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    unint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v23 = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, &v23);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
LABEL_12:
  if (v21) {
    sub_10004D2C8((std::__shared_weak_count *)v21);
  }
  if (v15)
  {
    sub_100058DB0(&__p, "");
    (*(void (**)(uint64_t, BOOL, void **))(*(void *)v15 + 8))(v15, v4, &__p);
    if (v22 < 0) {
      operator delete(__p);
    }
    v6[2](v6, 0);
    if ((v16 & 1) == 0) {
LABEL_18:
    }
      sub_10004D2C8(v14);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find TransportMasterInterface for setSupportDynamicDataSimSwitch", (uint8_t *)&__p, 2u);
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v6)[2](v6, v19);

    if ((v16 & 1) == 0) {
      goto LABEL_18;
    }
  }
LABEL_19:
}

- (void)setSupportDynamicDataSimSwitch:(BOOL)a3 forIccid:(id)a4 completion:(id)a5
{
  BOOL v6 = a3;
  id v8 = a4;
  unint64_t v9 = (void (**)(id, void *))a5;
  if (v9)
  {
    if ([v8 length])
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p);
      uint64_t v11 = ServiceMap;
      if ((v12 & 0x8000000000000000) != 0)
      {
        unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          unint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v39 = v12;
      char v16 = sub_10004D37C(&v11[1].__m_.__sig, &v39);
      if (v16)
      {
        uint64_t v18 = v16[3];
        char v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      char v17 = 0;
      char v19 = 1;
LABEL_16:
      if (v37) {
        sub_10004D2C8(v37);
      }
      if (!v18)
      {
        [(CTXPCClientHandler *)self getLogContext];
        unsigned int v34 = v37;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Could not find TransportMasterInterface", (uint8_t *)&__p, 2u);
        }
        CFStringRef v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v9[2](v9, v35);

        goto LABEL_39;
      }
      id v23 = v8;
      sub_100058DB0(&__p, (char *)[v23 UTF8String]);
      (*(void (**)(uint64_t, BOOL, void **))(*(void *)v18 + 8))(v18, v6, &__p);
      if (v38 < 0) {
        operator delete(__p);
      }
      v9[2](v9, 0);
      [(CTXPCClientHandler *)self registry];
      id v24 = (std::mutex *)Registry::getServiceMap((Registry *)__p);
      char v25 = v24;
      if ((v26 & 0x8000000000000000) != 0)
      {
        unint64_t v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v28 = 5381;
        do
        {
          unint64_t v26 = v28;
          unsigned int v29 = *v27++;
          uint64_t v28 = (33 * v28) ^ v29;
        }
        while (v29);
      }
      std::mutex::lock(v24);
      unint64_t v39 = v26;
      unint64_t v30 = sub_10004D37C(&v25[1].__m_.__sig, &v39);
      if (v30)
      {
        uint64_t v32 = v30[3];
        uint64_t v31 = (std::__shared_weak_count *)v30[4];
        if (v31)
        {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v25);
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v31);
          char v33 = 0;
LABEL_32:
          if (v37) {
            sub_10004D2C8(v37);
          }
          if (v32)
          {
            sub_100058DB0(&__p, (char *)[v23 UTF8String]);
            (*(void (**)(uint64_t, void **, BOOL))(*(void *)v32 + 40))(v32, &__p, v6);
            if (v38 < 0) {
              operator delete(__p);
            }
          }
          if ((v33 & 1) == 0) {
            sub_10004D2C8(v31);
          }
LABEL_39:
          if ((v19 & 1) == 0) {
            sub_10004D2C8(v17);
          }
          goto LABEL_41;
        }
      }
      else
      {
        uint64_t v32 = 0;
      }
      std::mutex::unlock(v25);
      uint64_t v31 = 0;
      char v33 = 1;
      goto LABEL_32;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = v37;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "ICCID must not be empty", (uint8_t *)&__p, 2u);
    }
    char v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v9[2](v9, v22);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v20 = v37;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&__p, 2u);
    }
  }
LABEL_41:
}

- (void)getSupportDynamicDataSimSwitch:(id)a3
{
  BOOL v4 = (void (**)(id, uint64_t, void))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v15 = v20;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSupportDynamicDataSimSwitch", (uint8_t *)&v19, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v19);
  BOOL v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v21);
  if (v11)
  {
    unsigned int v13 = (uint64_t (***)(void))v11[3];
    unint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    unsigned int v13 = 0;
  }
  std::mutex::unlock(v6);
  unint64_t v12 = 0;
  char v14 = 1;
LABEL_12:
  if (v20) {
    sub_10004D2C8((std::__shared_weak_count *)v20);
  }
  if (v13)
  {
    uint64_t v16 = (**v13)(v13);
    v4[2](v4, v16, 0);
    if ((v14 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v12);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v17 = v20;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find TransportMasterInterface for getSupportDynamicDataSimSwitch", (uint8_t *)&v19, 2u);
    }
    id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, uint64_t, id))v4)[2](v4, 0, v18);

    if ((v14 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)getPacketContextCount:(id)a3
{
  BOOL v4 = (capabilities::ct *)a3;
  BOOL v5 = v4;
  if (v4)
  {
    uint64_t v6 = capabilities::ct::supportedPDPContextCount(v4);
    (*((void (**)(capabilities::ct *, uint64_t))v5 + 2))(v5, v6);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v7 = v9;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      __int16 v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid completion handler for packet context count query", (uint8_t *)&v8, 2u);
    }
  }
}

- (void)getConnectionAvailability:(id)a3 connectionType:(int)a4 completion:(id)a5
{
  uint64_t v6 = *(void *)&a4;
  id v8 = a3;
  uint64_t v9 = (void (**)(id, void, id))a5;
  if (v9)
  {
    if (v6 >= 0x24)
    {
      [(CTXPCClientHandler *)self getLogContext];
      unsigned int v10 = v30;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Wrong connection type", buf, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v9[2](v9, 0, v11);

      goto LABEL_31;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    char v14 = ServiceMap;
    if ((v15 & 0x8000000000000000) != 0)
    {
      uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        unint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v31 = v15;
    char v19 = sub_10004D37C(&v14[1].__m_.__sig, &v31);
    if (v19)
    {
      uint64_t v21 = v19[3];
      unint64_t v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
LABEL_16:
        if (v30) {
          sub_10004D2C8((std::__shared_weak_count *)v30);
        }
        if (v21)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v21 + 768))(v21))
          {
            v28[0] = v21;
            v28[1] = v20;
            if ((v22 & 1) == 0) {
              atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v23 = sub_100045208(v28, v8);
            if ((v22 & 1) == 0) {
              sub_10004D2C8(v20);
            }
            id v24 = objc_retainBlock(v9);
            v32[0] = off_1019DE9D0;
            v32[1] = v24;
            v32[3] = v32;
            (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v21 + 576))(v21, v23, v6, v32);
            sub_100524DB0(v32);
          }
          else
          {
            id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            v9[2](v9, 0, v27);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v25 = v30;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "DataService uninitialized", buf, 2u);
          }
          id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v9[2](v9, 0, v26);
        }
        if ((v22 & 1) == 0) {
          sub_10004D2C8(v20);
        }
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    unint64_t v20 = 0;
    char v22 = 1;
    goto LABEL_16;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v12 = v30;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid completion handler for getConnectionAvailability", buf, 2u);
  }
LABEL_31:
}

- (void)getTetheringStatus:(id)a3 connectionType:(int)a4
{
  uint64_t v4 = *(void *)&a4;
  id v6 = a3;
  if (v6)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v23);
    id v8 = ServiceMap;
    if ((v9 & 0x8000000000000000) != 0)
    {
      unsigned int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        unint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v25 = v9;
    unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, &v25);
    if (v13)
    {
      uint64_t v15 = v13[3];
      char v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_12:
        if (v24) {
          sub_10004D2C8(v24);
        }
        if (v15)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v15 + 768))(v15))
          {
            id v18 = objc_retainBlock(v6);
            char v19 = self;
            v26[0] = off_1019DEA60;
            v26[1] = v18;
            v26[2] = v19;
            v26[3] = v26;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v15 + 584))(v15, v4, v26);
            sub_100525538(v26);
          }
          else
          {
            id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            (*((void (**)(id, void, id))v6 + 2))(v6, 0, v22);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v20 = v24;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v23) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "DataService uninitialized", (uint8_t *)&v23, 2u);
          }
          id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, id))v6 + 2))(v6, 0, v21);
        }
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    char v14 = 0;
    char v16 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v17 = v24;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v23) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler for getTetheringStatus", (uint8_t *)&v23, 2u);
  }
LABEL_23:
}

- (void)getActiveConnections:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v16 + 768))(v16))
          {
            v24[0] = v16;
            v24[1] = v15;
            if ((v17 & 1) == 0) {
              atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v19 = sub_100045208(v24, v6);
            if ((v17 & 1) == 0) {
              sub_10004D2C8(v15);
            }
            id v20 = objc_retainBlock(v7);
            v28[0] = off_1019DEB18;
            v28[1] = v20;
            v28[3] = v28;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 592))(v16, v19, v28);
            sub_10052584C(v28);
          }
          else
          {
            id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            (*((void (**)(id, void, id))v7 + 2))(v7, 0, v23);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v21 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "DataService uninitialized", buf, 2u);
          }
          id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, id))v7 + 2))(v7, 0, v22);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getActiveConnections", buf, 2u);
  }
LABEL_27:
}

- (void)getSliceTrafficDescriptorsInfo:(id)a3 connectionType:(int)a4 completion:(id)a5
{
  uint64_t v6 = *(void *)&a4;
  id v8 = a3;
  unint64_t v9 = (void (**)(id, void, id))a5;
  if (v9)
  {
    if (v6 >= 0x24)
    {
      [(CTXPCClientHandler *)self getLogContext];
      unint64_t v10 = v31;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Wrong connection type", buf, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v9[2](v9, 0, v11);

      goto LABEL_33;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    char v14 = ServiceMap;
    if ((v15 & 0x8000000000000000) != 0)
    {
      uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        unint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v32 = v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, &v32);
    if (v19)
    {
      uint64_t v21 = v19[3];
      id v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
LABEL_16:
        if (v31) {
          sub_10004D2C8((std::__shared_weak_count *)v31);
        }
        if (v21)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v21 + 768))(v21))
          {
            v29[0] = v21;
            v29[1] = v20;
            if ((v22 & 1) == 0) {
              atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v23 = sub_100045208(v29, v8);
            if ((v22 & 1) == 0) {
              sub_10004D2C8(v20);
            }
            uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 872))(v21);
            if (v24)
            {
              unint64_t v25 = objc_retainBlock(v9);
              v33[0] = off_1019DEC38;
              v33[1] = v25;
              v33[3] = v33;
              (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v24 + 88))(v24, v23, v6, v33);
              sub_100525CFC(v33);
            }
            else
            {
              v9[2](v9, 0, 0);
            }
          }
          else
          {
            id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            v9[2](v9, 0, v28);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v26 = v31;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "DataService uninitialized", buf, 2u);
          }
          id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v9[2](v9, 0, v27);
        }
        if ((v22 & 1) == 0) {
          sub_10004D2C8(v20);
        }
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    id v20 = 0;
    char v22 = 1;
    goto LABEL_16;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v12 = v31;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSliceTrafficDescriptorsInfo", buf, 2u);
  }
LABEL_33:
}

- (void)getSliceTrafficDescriptors:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v23);
    uint64_t v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v25 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, &v25);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v24) {
          sub_10004D2C8(v24);
        }
        if (v13)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v13 + 768))(v13))
          {
            uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 872))(v13);
            if (v16)
            {
              uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 776))(v13);
              if ((*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v16 + 32))(v16, v17, 0))
              {
                id v18 = objc_retainBlock(v4);
                v26[0] = off_1019DECC8;
                v26[1] = v18;
                v26[3] = v26;
                (*(void (**)(uint64_t, void *))(*(void *)v16 + 96))(v16, v26);
                sub_100526174(v26);
              }
              else
              {
                char v22 = objc_opt_new();
                [v22 setTrafficDescriptors:0];
                (*((void (**)(id, void *, void))v4 + 2))(v4, v22, 0);
              }
            }
            else
            {
              (*((void (**)(id, void, void))v4 + 2))(v4, 0, 0);
            }
          }
          else
          {
            id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            (*((void (**)(id, void, id))v4 + 2))(v4, 0, v21);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v19 = v24;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v23) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "DataService uninitialized", (uint8_t *)&v23, 2u);
          }
          id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, id))v4 + 2))(v4, 0, v20);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v15 = v24;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v23) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSliceTrafficDescriptors", (uint8_t *)&v23, 2u);
  }
LABEL_27:
}

- (void)getPublicDataBearer:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v21);
    uint64_t v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, &v23);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v13)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v13 + 768))(v13))
          {
            uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 776))(v13);
            id v17 = objc_retainBlock(v4);
            v24[0] = off_1019DEDE8;
            v24[1] = v17;
            uint64_t v24[3] = v24;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v13 + 616))(v13, v16, v24);
            sub_100030784(v24);
          }
          else
          {
            id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            (*((void (**)(id, void, id))v4 + 2))(v4, 0, v20);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v18 = v22;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v21) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "DataService uninitialized", (uint8_t *)&v21, 2u);
          }
          id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, id))v4 + 2))(v4, 0, v19);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v15 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v21) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getPublicDataBearer", (uint8_t *)&v21, 2u);
  }
LABEL_23:
}

- (void)getPublicNrFrequencyRange:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v21);
    uint64_t v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, &v23);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v13)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v13 + 768))(v13))
          {
            uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 776))(v13);
            id v17 = objc_retainBlock(v4);
            v24[0] = off_1019DEE68;
            v24[1] = v17;
            uint64_t v24[3] = v24;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v13 + 616))(v13, v16, v24);
            sub_100030784(v24);
          }
          else
          {
            id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            (*((void (**)(id, void, id))v4 + 2))(v4, 0, v20);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v18 = v22;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v21) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "DataService uninitialized", (uint8_t *)&v21, 2u);
          }
          id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, id))v4 + 2))(v4, 0, v19);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v15 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v21) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getPublicNrFrequencyRange", (uint8_t *)&v21, 2u);
  }
LABEL_23:
}

- (void)getNATTKeepAliveOverCell:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, uint64_t, id))a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v39 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v39);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
LABEL_12:
    if (v38) {
      sub_10004D2C8(v38);
    }
    if (!v16)
    {
LABEL_37:
      if ((v17 & 1) == 0) {
        sub_10004D2C8(v15);
      }
      [(CTXPCClientHandler *)self getLogContext];
      unsigned int v34 = v38;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "CommCenter uninitialized", buf, 2u);
      }
      id v35 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v7[2](v7, 110, v35);

      goto LABEL_46;
    }
    if (((*(uint64_t (**)(uint64_t))(*(void *)v16 + 768))(v16) & 1) == 0)
    {
      id v29 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
      v7[2](v7, 0, v29);

LABEL_44:
      if ((v17 & 1) == 0) {
        sub_10004D2C8(v15);
      }
      goto LABEL_46;
    }
    [(CTXPCClientHandler *)self registry];
    id v19 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v20 = v19;
    if ((v21 & 0x8000000000000000) != 0)
    {
      char v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v23 = 5381;
      do
      {
        unint64_t v21 = v23;
        unsigned int v24 = *v22++;
        uint64_t v23 = (33 * v23) ^ v24;
      }
      while (v24);
    }
    std::mutex::lock(v19);
    unint64_t v39 = v21;
    unint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, &v39);
    if (v25)
    {
      uint64_t v27 = v25[3];
      id v26 = (std::__shared_weak_count *)v25[4];
      if (v26)
      {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v26);
        char v28 = 0;
LABEL_25:
        if (v38) {
          sub_10004D2C8(v38);
        }
        if (v27)
        {
          v36[0] = v16;
          v36[1] = v15;
          if ((v17 & 1) == 0) {
            atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v30 = sub_100045208(v36, v6);
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          *(void *)long long buf = 0;
          (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v27 + 96))(buf, v27, v30, 1, @"NATTKeepAliveIntervalOverCell", 0, 0);
          unint64_t v31 = *(Registry **)buf;
          LODWORD(v39) = 110;
          if (*(void *)buf)
          {
            CFTypeID v32 = CFGetTypeID(*(CFTypeRef *)buf);
            if (v32 == CFNumberGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v39, (unsigned int *)v31, v33);
            }
          }
          ((void (*)(void (**)(id, uint64_t, id)))v7[2])(v7);
          sub_1000577C4((const void **)buf);
          if ((v28 & 1) == 0) {
            sub_10004D2C8(v26);
          }
          goto LABEL_44;
        }
        if ((v28 & 1) == 0) {
          sub_10004D2C8(v26);
        }
        goto LABEL_37;
      }
    }
    else
    {
      uint64_t v27 = 0;
    }
    std::mutex::unlock(v20);
    id v26 = 0;
    char v28 = 1;
    goto LABEL_25;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v38;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getNATTKeepAliveOverCell", buf, 2u);
  }
LABEL_46:
}

- (void)isTetheringEditingSupported:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, BOOL, void))a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v29 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v29);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (v28) {
          sub_10004D2C8(v28);
        }
        if (v16)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v16 + 768))(v16))
          {
            uint64_t v25 = v16;
            id v26 = v15;
            if ((v17 & 1) == 0) {
              atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            id v19 = (capabilities::ct *)sub_100045208(&v25, v6);
            uint64_t v20 = (uint64_t)v19;
            if ((v17 & 1) == 0) {
              sub_10004D2C8(v15);
            }
            if (capabilities::ct::supportsWirelessModem(v19))
            {
              [(CTXPCClientHandler *)self registry];
              BOOL v21 = sub_100C9AB68((Registry **)buf, v20);
              if (v28) {
                sub_10004D2C8(v28);
              }
            }
            else
            {
              BOOL v21 = 0;
            }
            v7[2](v7, v21, 0);
          }
          else
          {
            id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            ((void (**)(id, BOOL, id))v7)[2](v7, 0, v24);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
        }
        else
        {
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          [(CTXPCClientHandler *)self getLogContext];
          char v22 = v28;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "CommCenter uninitialized", buf, 2u);
          }
          id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, BOOL, id))v7)[2](v7, 0, v23);
        }
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for isTetheringEditingSupported", buf, 2u);
  }
LABEL_33:
}

- (void)getAnbrActivationState:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (capabilities::ct *)a4;
  id v8 = v7;
  if (v7)
  {
    if ((capabilities::ct::supportsThroughputEngineering(v7) & 1) == 0)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v20 = v28;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "ANBR not supported for getAnbrActivationState", buf, 2u);
      }
      goto LABEL_13;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v29 = v11;
    unint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v29);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_16:
        if (v28) {
          sub_10004D2C8((std::__shared_weak_count *)v28);
        }
        if (v17)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v17 + 768))(v17))
          {
            v26[0] = v17;
            v26[1] = v16;
            if ((v18 & 1) == 0) {
              atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v22 = sub_100045208(v26, v6);
            if ((v18 & 1) == 0) {
              sub_10004D2C8(v16);
            }
            id v23 = objc_retainBlock(v8);
            v30[0] = off_1019DEEE8;
            v30[1] = v23;
            v30[3] = v30;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 24))(v17, v22, v30);
            sub_1000605C0(v30);
          }
          else
          {
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
            (*((void (**)(capabilities::ct *, void, id))v8 + 2))(v8, 0, v25);
          }
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v16);
          }
          goto LABEL_33;
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        [(CTXPCClientHandler *)self getLogContext];
        id v24 = v28;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "CommCenter uninitialized", buf, 2u);
        }
LABEL_13:
        id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        (*((void (**)(capabilities::ct *, void, id))v8 + 2))(v8, 0, v21);

        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_16;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getAnbrActivationState", buf, 2u);
  }
LABEL_33:
}

- (void)queryAnbrBitrate:(id)a3 bitrate:(id)a4 direction:(int)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  uint64_t v12 = (capabilities::ct *)a6;
  uint64_t v13 = v12;
  if (v12)
  {
    if ((capabilities::ct::supportsThroughputEngineering(v12) & 1) == 0)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v16 = v36;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "ANBR not supported for queryAnbrBitrate", buf, 2u);
      }
      goto LABEL_10;
    }
    if ((a5 - 1) < 2)
    {
      if (v11) {
        id v14 = [v11 unsignedLongValue];
      }
      else {
        id v14 = 0;
      }
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      id v21 = ServiceMap;
      if ((v22 & 0x8000000000000000) != 0)
      {
        id v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v24 = 5381;
        do
        {
          unint64_t v22 = v24;
          unsigned int v25 = *v23++;
          uint64_t v24 = (33 * v24) ^ v25;
        }
        while (v25);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v37 = v22;
      id v26 = sub_10004D37C(&v21[1].__m_.__sig, &v37);
      if (v26)
      {
        uint64_t v28 = v26[3];
        uint64_t v27 = (std::__shared_weak_count *)v26[4];
        if (v27)
        {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v21);
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v27);
          char v29 = 0;
LABEL_23:
          if (v36) {
            sub_10004D2C8((std::__shared_weak_count *)v36);
          }
          if (v28)
          {
            if ((*(uint64_t (**)(uint64_t))(*(void *)v28 + 768))(v28))
            {
              v34[0] = v28;
              v34[1] = v27;
              if ((v29 & 1) == 0) {
                atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v30 = sub_100045208(v34, v10);
              if ((v29 & 1) == 0) {
                sub_10004D2C8(v27);
              }
              unint64_t v31 = objc_retainBlock(v13);
              v38[0] = off_1019DEF68;
              v38[1] = v31;
              void v38[3] = v38;
              (*(void (**)(uint64_t, uint64_t, id, BOOL, void *))(*(void *)v28 + 16))(v28, v30, v14, a5 == 1, v38);
              sub_100060644(v38);
            }
            else
            {
              id v33 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
              (*((void (**)(capabilities::ct *, id))v13 + 2))(v13, v33);
            }
            if ((v29 & 1) == 0) {
              sub_10004D2C8(v27);
            }
            goto LABEL_40;
          }
          if ((v29 & 1) == 0) {
            sub_10004D2C8(v27);
          }
          [(CTXPCClientHandler *)self getLogContext];
          CFTypeID v32 = v36;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "CommCenter uninitialized", buf, 2u);
          }
LABEL_10:
          id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(capabilities::ct *, id))v13 + 2))(v13, v17);

          goto LABEL_40;
        }
      }
      else
      {
        uint64_t v28 = 0;
      }
      std::mutex::unlock(v21);
      uint64_t v27 = 0;
      char v29 = 1;
      goto LABEL_23;
    }
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = v36;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid direction parameter for queryAnbrBitrate", buf, 2u);
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(capabilities::ct *, id))v13 + 2))(v13, v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v15 = v36;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for queryAnbrBitrate", buf, 2u);
    }
  }
LABEL_40:
}

- (void)setCoalescing:(BOOL)a3 udp:(BOOL)a4 completion:(id)a5
{
  BOOL v5 = a4;
  BOOL v6 = a3;
  id v8 = (capabilities::ipc *)a5;
  uint64_t v9 = v8;
  if (!v8)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for setCoalescing", (uint8_t *)&v26, 2u);
    }
    goto LABEL_29;
  }
  if ((capabilities::ipc::supportsCoalescing(v8) & 1) == 0)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v21 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      LOWORD(v26) = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "Coalescing not supported", (uint8_t *)&v26, 2u);
    }
    goto LABEL_28;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v26);
  id v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v28 = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v28);
  if (v16)
  {
    uint64_t v18 = v16[3];
    id v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  id v17 = 0;
  char v19 = 1;
LABEL_16:
  if (v27) {
    sub_10004D2C8((std::__shared_weak_count *)v27);
  }
  if (!v18)
  {
    if ((v19 & 1) == 0) {
      sub_10004D2C8(v17);
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v23 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "CommCenter uninitialized", (uint8_t *)&v26, 2u);
    }
LABEL_28:
    id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*((void (**)(capabilities::ipc *, id))v9 + 2))(v9, v24);

    goto LABEL_29;
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)v18 + 768))(v18))
  {
    uint64_t v22 = 256;
    if (!v5) {
      uint64_t v22 = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 32))(v18, v22 | v6);
    (*((void (**)(capabilities::ipc *, void))v9 + 2))(v9, 0);
    if ((v19 & 1) == 0) {
      goto LABEL_31;
    }
  }
  else
  {
    id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
    (*((void (**)(capabilities::ipc *, id))v9 + 2))(v9, v25);

    if ((v19 & 1) == 0) {
LABEL_31:
    }
      sub_10004D2C8(v17);
  }
LABEL_29:
}

- (void)simulateDataStall:(BOOL)a3 pdp:(int)a4 completion:(id)a5
{
  uint64_t v5 = *(void *)&a4;
  BOOL v6 = a3;
  id v8 = (void (**)(id, void))a5;
  if (v8)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v22);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      unint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v24 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v24);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v23) {
          sub_10004D2C8(v23);
        }
        if (v17)
        {
          (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v17 + 48))(v17, v5, v6);
          v8[2](v8, 0);
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v16);
          }
        }
        else
        {
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v16);
          }
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v20 = v23;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v22) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "CommCenter uninitialized", (uint8_t *)&v22, 2u);
          }
          id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, id))v8)[2](v8, v21);
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v19 = v23;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v22) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for simulateDataStall", (uint8_t *)&v22, 2u);
  }
LABEL_22:
}

- (void)getCurrentDataServiceDescriptor:(id)a3
{
  id v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v23);
    BOOL v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v25 = v7;
    unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v25);
    if (v11)
    {
      uint64_t v13 = v11[3];
      unint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    unint64_t v12 = 0;
    char v14 = 1;
LABEL_12:
    if (v24) {
      sub_10004D2C8(v24);
    }
    if (v13)
    {
      if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 768))(v13) & 1) == 0)
      {
        id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v4[2](v4, 0, v19);
LABEL_24:

        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_30;
      }
      int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 776))(v13);
      if (v16 == 1) {
        uint64_t v17 = 1;
      }
      else {
        uint64_t v17 = 2 * (v16 == 2);
      }
      char v18 = +[NSNumber numberWithInteger:v17];
      id v19 = +[CTServiceDescriptor telephonyDescriptorWithInstance:v18];

      if (v19)
      {
        ((void (**)(id, id, id))v4)[2](v4, v19, 0);
        goto LABEL_24;
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v20 = v24;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
LABEL_27:
        if (v14)
        {
LABEL_29:
          id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v4[2](v4, 0, v22);

          goto LABEL_30;
        }
LABEL_28:
        sub_10004D2C8(v12);
        goto LABEL_29;
      }
      LOWORD(v23) = 0;
      id v21 = "CommCenter memory allocation problem";
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v20 = v24;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      LOWORD(v23) = 0;
      id v21 = "CommCenter uninitialized";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&v23, 2u);
    if (v14) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v15 = v24;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v23) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getCurrentDataServiceDescriptor", (uint8_t *)&v23, 2u);
  }
LABEL_30:
}

- (void)getPreferredDataServiceDescriptor:(id)a3
{
  id v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v23);
    BOOL v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v25 = v7;
    unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v25);
    if (v11)
    {
      uint64_t v13 = v11[3];
      unint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    unint64_t v12 = 0;
    char v14 = 1;
LABEL_12:
    if (v24) {
      sub_10004D2C8(v24);
    }
    if (v13)
    {
      if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 768))(v13) & 1) == 0)
      {
        id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
        v4[2](v4, 0, v19);
LABEL_24:

        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_30;
      }
      int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 760))(v13);
      if (v16 == 1) {
        uint64_t v17 = 1;
      }
      else {
        uint64_t v17 = 2 * (v16 == 2);
      }
      char v18 = +[NSNumber numberWithInteger:v17];
      id v19 = +[CTServiceDescriptor telephonyDescriptorWithInstance:v18];

      if (v19)
      {
        ((void (**)(id, id, id))v4)[2](v4, v19, 0);
        goto LABEL_24;
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v20 = v24;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
LABEL_27:
        if (v14)
        {
LABEL_29:
          id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v4[2](v4, 0, v22);

          goto LABEL_30;
        }
LABEL_28:
        sub_10004D2C8(v12);
        goto LABEL_29;
      }
      LOWORD(v23) = 0;
      id v21 = "CommCenter memory allocation problem";
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v20 = v24;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      LOWORD(v23) = 0;
      id v21 = "CommCenter uninitialized";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&v23, 2u);
    if (v14) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v15 = v24;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v23) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getPreferredDataServiceDescriptor", (uint8_t *)&v23, 2u);
  }
LABEL_30:
}

- (void)enterLoopBackMode:(id)a3
{
  id v4 = (void (**)(id, id))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v19);
    BOOL v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v21 = v7;
    unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v21);
    if (v11)
    {
      uint64_t v13 = v11[3];
      unint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v13)
        {
          [(CTXPCClientHandler *)self getLogContext];
          int v16 = v20;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v19) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Operation not allowed on non-GM builds", (uint8_t *)&v19, 2u);
          }
          id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:1 userInfo:0];
          v4[2](v4, v17);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v18 = v20;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v19) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "DataService uninitialized", (uint8_t *)&v19, 2u);
          }
          id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v4[2](v4, v17);
        }

        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    unint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v15 = v20;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v19) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for enterLoopBackMode", (uint8_t *)&v19, 2u);
  }
LABEL_23:
}

- (void)setAssertionForConnectionType:(int)a3 enable:(BOOL)a4 completion:(id)a5
{
  unint64_t v7 = (void (**)(id, id))a5;
  if (v7)
  {
    if (a3 >= 0x24)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = v26;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Wrong connection type", buf, 2u);
      }
      id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v9);

      goto LABEL_24;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unint64_t v12 = ServiceMap;
    if ((v13 & 0x8000000000000000) != 0)
    {
      char v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        unint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v13;
    id v17 = sub_10004D37C(&v12[1].__m_.__sig, &v27);
    if (v17)
    {
      uint64_t v19 = v17[3];
      char v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
LABEL_16:
        if (v26) {
          sub_10004D2C8((std::__shared_weak_count *)v26);
        }
        if (v19)
        {
          unint64_t v21 = +[NSXPCConnection currentConnection];
          sub_10095460C(v21, &v24);
        }
        [(CTXPCClientHandler *)self getLogContext];
        id v22 = v26;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "CTXPCServerInterface uninitialized", buf, 2u);
        }
        id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, v23);

        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    char v18 = 0;
    char v20 = 1;
    goto LABEL_16;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v10 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Invalid completion handler for setAssertionForConnectionType", buf, 2u);
  }
LABEL_24:
}

- (void)setApplicationCategory:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, id))a4;
  if (v7)
  {
    if (v6) {
      [v6 unsignedLongLongValue];
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unsigned int v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      unint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v25 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v25);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v24) {
          sub_10004D2C8(v24);
        }
        if (v17)
        {
          uint64_t v19 = +[NSXPCConnection currentConnection];
          sub_10095460C(v19, &v22);
        }
        [(CTXPCClientHandler *)self getLogContext];
        char v20 = v24;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "CTXPCServerInterface uninitialized", buf, 2u);
        }
        id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, v21);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v8 = v24;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for setApplicationCategory", buf, 2u);
  }
LABEL_22:
}

- (void)supportsHydraWithCompletion:(id)a3
{
  id v4 = (void (**)(id, uint64_t))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v18);
    id v6 = ServiceMap;
    unint64_t v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    char v20 = v7;
    unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v20);
    if (v11)
    {
      uint64_t v13 = v11[3];
      unint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v19) {
          sub_10004D2C8(v19);
        }
        if (v13)
        {
          uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 24))(v13);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v17 = v19;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v18) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for supportsHydraWithCompletion", (uint8_t *)&v18, 2u);
          }
          uint64_t v16 = 0;
        }
        v4[2](v4, v16);
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    unint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v19;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v18) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion", (uint8_t *)&v18, 2u);
  }
LABEL_21:
}

- (void)supportsPlanProvisioning:(id)a3 carrierDescriptors:(id)a4 smdpUrl:(id)a5 iccidPrefix:(id)a6 completionHandler:(id)a7
{
  id v69 = a3;
  id v12 = a4;
  id v70 = a5;
  id v71 = a6;
  v72 = v12;
  v73 = (void (**)(id, void))a7;
  if (!v73)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v21 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for supportsPlanProvisioning", (uint8_t *)&buf, 2u);
    }
    goto LABEL_101;
  }
  if (!v12)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Carrier Descriptiors are mandatory in info.plist", (uint8_t *)&buf, 2u);
    }
    v73[2](v73, 0);
    goto LABEL_101;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
  char v14 = ServiceMap;
  uint64_t v15 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    uint64_t v16 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = (const char *)v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v91 = v15;
  uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)&v91);
  if (!v19)
  {
    uint64_t v68 = 0;
    goto LABEL_15;
  }
  char v20 = (std::__shared_weak_count *)v19[4];
  uint64_t v68 = v19[3];
  if (!v20)
  {
LABEL_15:
    std::mutex::unlock(v14);
    NSErrorUserInfoKey v66 = 0;
    char v67 = 1;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v14);
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  NSErrorUserInfoKey v66 = v20;
  sub_10004D2C8(v20);
  char v67 = 0;
LABEL_16:
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (v68)
  {
    xpc_object_t v91 = 0;
    unint64_t v92 = 0;
    unint64_t v93 = 0;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v89 = 0u;
    long long v90 = 0u;
    id obj = v72;
    id v23 = [obj countByEnumeratingWithState:&v87 objects:v99 count:16];
    if (v23)
    {
      uint64_t v24 = 0;
      uint64_t v25 = *(void *)v88;
      uint64_t v65 = &v93;
      for (uint64_t i = *(void *)v88; ; uint64_t i = *(void *)v88)
      {
        if (i != v25) {
          objc_enumerationMutation(obj);
        }
        unint64_t v27 = *(void **)(*((void *)&v87 + 1) + 8 * v24);
        unint64_t v28 = objc_msgSend(v27, "objectForKeyedSubscript:", @"MCC", v65);
        if ((unint64_t)[v28 length] > 3) {
          goto LABEL_28;
        }
        char v29 = [v27 objectForKeyedSubscript:@"MCC"];
        if (![v29 length]) {
          goto LABEL_27;
        }
        uint64_t v30 = [v27 objectForKeyedSubscript:@"MNC"];
        if ((unint64_t)[v30 length] >= 4)
        {

LABEL_27:
LABEL_28:

LABEL_29:
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v31 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
            goto LABEL_30;
          }
          LOWORD(buf) = 0;
          uint64_t v40 = v31;
          id v41 = "MCC or MNC key in info.plist doesnt confirm to standards";
LABEL_40:
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, v41, (uint8_t *)&buf, 2u);
          goto LABEL_30;
        }
        CFTypeID v32 = [v27 objectForKeyedSubscript:@"MNC"];
        BOOL v33 = [v32 length] == 0;

        if (v33) {
          goto LABEL_29;
        }
        unsigned int v34 = [v27 objectForKeyedSubscript:@"MCC"];
        char v35 = objc_opt_respondsToSelector();

        if (v35)
        {
          id v36 = [v27 objectForKeyedSubscript:@"MNC"];
          char v37 = objc_opt_respondsToSelector();

          if (v37)
          {
            char v38 = (_OWORD *)v92;
            if (v92 >= v93)
            {
              uint64_t v44 = (uint64_t)(v92 - (void)v91) >> 7;
              unint64_t v45 = v44 + 1;
              if ((unint64_t)(v44 + 1) >> 57) {
                sub_10006A748();
              }
              uint64_t v46 = v93 - (void)v91;
              if ((uint64_t)(v93 - (void)v91) >> 6 > v45) {
                unint64_t v45 = v46 >> 6;
              }
              if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFF80) {
                unint64_t v47 = 0x1FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v47 = v45;
              }
              long long v97 = v65;
              if (v47) {
                long long v48 = (char *)sub_100043864((uint64_t)v65, v47);
              }
              else {
                long long v48 = 0;
              }
              long long v49 = &v48[128 * v44];
              *(void *)&long long buf = v48;
              *((void *)&buf + 1) = v49;
              long long v96 = &v48[128 * v47];
              *(_OWORD *)long long v49 = 0u;
              *((_OWORD *)v49 + 1) = 0u;
              *((_OWORD *)v49 + 2) = 0u;
              *((_OWORD *)v49 + 3) = 0u;
              *((_OWORD *)v49 + 4) = 0u;
              *((_OWORD *)v49 + 5) = 0u;
              *((_OWORD *)v49 + 6) = 0u;
              *((_OWORD *)v49 + 7) = 0u;
              v95 = v49 + 128;
              sub_100313094((uint64_t *)&v91, &buf);
              unint64_t v39 = v92;
              sub_1003131D8((uint64_t)&buf);
            }
            else
            {
              *(_OWORD *)(v92 + 96) = 0u;
              v38[7] = 0u;
              void v38[4] = 0u;
              v38[5] = 0u;
              v38[2] = 0u;
              void v38[3] = 0u;
              unint64_t v39 = (unint64_t)(v38 + 8);
              *char v38 = 0u;
              v38[1] = 0u;
            }
            unint64_t v92 = v39;
            id v50 = [v27 objectForKeyedSubscript:@"MCC"];
            sub_10003ED78((std::string *)(v39 - 96), (char *)[v50 UTF8String]);

            id v51 = [v27 objectForKeyedSubscript:@"MNC"];
            sub_10003ED78((std::string *)(v39 - 72), (char *)[v51 UTF8String]);

            id v52 = [v27 objectForKeyedSubscript:@"GID1"];
            if ([v52 length])
            {
              long long v53 = [v27 objectForKeyedSubscript:@"GID1"];
              if ((unint64_t)[v53 length] < 0x201)
              {
                long long v54 = [v27 objectForKeyedSubscript:@"GID1"];
                char v55 = objc_opt_respondsToSelector();

                if (v55)
                {
                  id v52 = [v27 objectForKeyedSubscript:@"GID1"];
                  sub_10003ED78((std::string *)(v39 - 48), (char *)[v52 UTF8String]);
                  goto LABEL_60;
                }
LABEL_61:
                long long v56 = [v27 objectForKeyedSubscript:@"GID2"];
                if ([v56 length])
                {
                  long long v57 = [v27 objectForKeyedSubscript:@"GID2"];
                  if ((unint64_t)[v57 length] >= 0x201)
                  {
                  }
                  else
                  {
                    CFStringRef v58 = [v27 objectForKeyedSubscript:@"GID2"];
                    char v59 = objc_opt_respondsToSelector();

                    if (v59)
                    {
                      id v60 = [v27 objectForKeyedSubscript:@"GID2"];
                      sub_10003ED78((std::string *)(v39 - 24), (char *)[v60 UTF8String]);
                    }
                  }
                }
                else
                {
                }
                goto LABEL_30;
              }
            }
LABEL_60:

            goto LABEL_61;
          }
          [(CTXPCClientHandler *)self getLogContext];
          id v43 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            uint64_t v40 = v43;
            id v41 = "MNC key not present in info.plist - skipping this item";
            goto LABEL_40;
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v42 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            uint64_t v40 = v42;
            id v41 = "MCC key not present in info.plist - skipping this item";
            goto LABEL_40;
          }
        }
LABEL_30:
        if (++v24 >= (unint64_t)v23)
        {
          id v23 = [obj countByEnumeratingWithState:&v87 objects:v99 count:16];
          if (!v23) {
            break;
          }
          uint64_t v24 = 0;
        }
      }
    }

    if (v91 == (const char *)v92)
    {
      [(CTXPCClientHandler *)self getLogContext];
      xpc_object_t v63 = *((void *)&buf + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "Missing Carrier Descriptiors", (uint8_t *)&buf, 2u);
      }
      v73[2](v73, 0);
    }
    else
    {
      long long buf = 0uLL;
      v95 = 0;
      if (v70) {
        NSErrorUserInfoKey v61 = (char *)[v70 UTF8String];
      }
      else {
        NSErrorUserInfoKey v61 = "";
      }
      sub_100058DB0(&buf, v61);
      long long v85 = 0uLL;
      uint64_t v86 = 0;
      if (v71) {
        id v64 = (char *)[v71 UTF8String];
      }
      else {
        id v64 = "";
      }
      sub_100058DB0(&v85, v64);
      sub_10030B264((uint64_t)v84, (uint64_t)v91);
      v84[128] = 1;
      v75[0] = _NSConcreteStackBlock;
      v75[1] = 3321888768;
      v75[2] = sub_10052A6CC;
      v75[3] = &unk_1019E0E28;
      uint64_t v77 = v68;
      v78 = v66;
      if ((v67 & 1) == 0) {
        atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      memset(v79, 0, sizeof(v79));
      sub_10030B4A4(v79, (uint64_t)v91, v92, (uint64_t)(v92 - (void)v91) >> 7);
      if (SHIBYTE(v95) < 0)
      {
        sub_10004FC84(&v80, (void *)buf, *((unint64_t *)&buf + 1));
      }
      else
      {
        long long v80 = buf;
        uint64_t v81 = v95;
      }
      if (SHIBYTE(v86) < 0)
      {
        sub_10004FC84(&__p, (void *)v85, *((unint64_t *)&v85 + 1));
      }
      else
      {
        long long __p = v85;
        uint64_t v83 = v86;
      }
      v75[4] = self;
      v76 = v73;
      (*(void (**)(uint64_t, unsigned char *, void *))(*(void *)v68 + 40))(v68, v84, v75);
      sub_10010B788((uint64_t)v84);

      if (SHIBYTE(v83) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v81) < 0) {
        operator delete((void *)v80);
      }
      long long v98 = (void **)v79;
      sub_10030B640(&v98);
      if (v78) {
        sub_10004D2C8(v78);
      }
      if (SHIBYTE(v86) < 0) {
        operator delete((void *)v85);
      }
      if (SHIBYTE(v95) < 0) {
        operator delete((void *)buf);
      }
    }
    *(void *)&long long buf = &v91;
    sub_10030B640((void ***)&buf);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    CFStringRef v62 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for supportsPlanProvisioning", (uint8_t *)&buf, 2u);
    }
    v73[2](v73, 0);
  }
  if ((v67 & 1) == 0) {
    sub_10004D2C8(v66);
  }
LABEL_101:
}

- (void)usingBootstrapDataServiceWithCompletion:(id)a3
{
  id v4 = (void (**)(id, uint64_t))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v18);
    id v6 = ServiceMap;
    unint64_t v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    char v20 = v7;
    unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v20);
    if (v11)
    {
      uint64_t v13 = v11[3];
      id v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v19) {
          sub_10004D2C8(v19);
        }
        if (v13)
        {
          uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 32))(v13);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v17 = v19;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v18) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for usingBootstrapDataServiceWithCompletion", (uint8_t *)&v18, 2u);
          }
          uint64_t v16 = 0;
        }
        v4[2](v4, v16);
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    id v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v19;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v18) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion", (uint8_t *)&v18, 2u);
  }
LABEL_21:
}

- (void)addPlanWith:(id)a3 appName:(id)a4 appType:(unint64_t)a5 completionHandler:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = (void (**)(id, void, id))a6;
  if (!v12)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v24 = v37;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid completion handler for addPlanWith", buf, 2u);
    }
    goto LABEL_23;
  }
  uint64_t v13 = [v10 address];

  if (!v13)
  {
    id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v12[2](v12, 0, v25);

    goto LABEL_23;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  uint64_t v15 = ServiceMap;
  uint64_t v16 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    uint64_t v17 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = (const char *)v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  char v38 = v16;
  char v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)&v38);
  if (v20)
  {
    uint64_t v22 = v20[3];
    id v21 = (std::__shared_weak_count *)v20[4];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v15);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      char v23 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  std::mutex::unlock(v15);
  id v21 = 0;
  char v23 = 1;
LABEL_14:
  if (v37) {
    sub_10004D2C8((std::__shared_weak_count *)v37);
  }
  if (v22)
  {
    v35[0] = 0;
    v35[128] = 0;
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3321888768;
    void v28[2] = sub_10052B1E0;
    v28[3] = &unk_1019E0E88;
    void v28[4] = self;
    uint64_t v32 = v22;
    BOOL v33 = v21;
    if ((v23 & 1) == 0) {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    id v29 = v10;
    id v30 = v11;
    unint64_t v34 = a5;
    unint64_t v31 = v12;
    (*(void (**)(uint64_t, unsigned char *, void *))(*(void *)v22 + 40))(v22, v35, v28);
    sub_10010B788((uint64_t)v35);

    if (v33) {
      sub_10004D2C8(v33);
    }
    if ((v23 & 1) == 0) {
LABEL_22:
    }
      sub_10004D2C8(v21);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v26 = v37;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for addPlanWith", buf, 2u);
    }
    id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v12[2](v12, 0, v27);

    if ((v23 & 1) == 0) {
      goto LABEL_22;
    }
  }
LABEL_23:
}

- (void)addPlanWith:(id)a3 completionHandler:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for addPlanWith", buf, 2u);
    }
    goto LABEL_21;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  uint64_t v9 = ServiceMap;
  id v10 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      id v10 = (char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  long long __p = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&__p);
  if (!v14)
  {
    uint64_t v16 = 0;
    goto LABEL_11;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
LABEL_11:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
LABEL_12:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v16)
  {
    uint64_t v56 = 0;
    memset(v55, 0, sizeof(v55));
    memset(v54, 0, sizeof(v54));
    memset(v53, 0, sizeof(v53));
    memset(v52, 0, sizeof(v52));
    memset(v51, 0, sizeof(v51));
    *(_OWORD *)long long buf = 0u;
    unsigned int v19 = [v6 eid];
    if (v19)
    {
      uint64_t v9 = [v6 eid];
      char v20 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      char v20 = "";
    }
    sub_10003ED78((std::string *)buf, v20);
    if (v19) {

    }
    char v23 = [v6 iccid];
    if (v23)
    {
      uint64_t v9 = [v6 iccid];
      uint64_t v24 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      uint64_t v24 = "";
    }
    sub_10003ED78((std::string *)((char *)v51 + 8), v24);
    if (v23) {

    }
    id v25 = [v6 sourceIccid];
    if (v25)
    {
      uint64_t v9 = [v6 sourceIccid];
      id v26 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      id v26 = "";
    }
    sub_10003ED78(v52, v26);
    if (v25) {

    }
    id v27 = [v6 unusableIccid];
    if (v27)
    {
      uint64_t v9 = [v6 unusableIccid];
      unint64_t v28 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      unint64_t v28 = "";
    }
    sub_10003ED78(&v52[1], v28);
    if (v27) {

    }
    id v29 = [v6 phoneNumber];
    if (v29)
    {
      uint64_t v9 = [v6 phoneNumber];
      id v30 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      id v30 = "";
    }
    sub_10003ED78(v53, v30);
    if (v29) {

    }
    unint64_t v31 = [v6 mcc];
    if (v31)
    {
      uint64_t v9 = [v6 mcc];
      uint64_t v32 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      uint64_t v32 = "";
    }
    sub_10003ED78(&v53[1], v32);
    if (v31) {

    }
    BOOL v33 = [v6 mnc];
    if (v33)
    {
      uint64_t v9 = [v6 mnc];
      unint64_t v34 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      unint64_t v34 = "";
    }
    sub_10003ED78(v54, v34);
    if (v33) {

    }
    char v35 = [v6 gid1];
    if (v35)
    {
      uint64_t v9 = [v6 gid1];
      id v36 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      id v36 = "";
    }
    sub_10003ED78(&v54[1], v36);
    if (v35) {

    }
    char v37 = [v6 gid2];
    if (v37)
    {
      uint64_t v9 = [v6 gid2];
      char v38 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      char v38 = "";
    }
    sub_10003ED78(v55, v38);
    if (v37) {

    }
    unint64_t v39 = [v6 smdpAddress];
    if (v39)
    {
      uint64_t v9 = [v6 smdpAddress];
      uint64_t v40 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      uint64_t v40 = "";
    }
    sub_10003ED78(&v55[1], v40);
    if (v39) {

    }
    LOBYTE(v56) = [v6 useDS];
    BYTE1(v56) = [v6 isESim];
    long long __p = 0;
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    id v41 = [v6 flowType];
    if (v41)
    {
      uint64_t v9 = [v6 flowType];
      unint64_t v42 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      unint64_t v42 = "";
    }
    sub_100058DB0(&__p, v42);
    if (v41) {

    }
    uint64_t v43 = HIBYTE(v49);
    if (v49 < 0) {
      uint64_t v43 = v48;
    }
    if (v43 == 4)
    {
      p_p = &__p;
      if (v49 < 0) {
        p_p = __p;
      }
      BOOL v45 = *p_p == 1094995795;
    }
    else
    {
      BOOL v45 = 0;
    }
    BYTE2(v56) = v45;
    id v46 = objc_retainBlock(v7);
    v57[0] = off_1019E10A0;
    v57[1] = v46;
    v57[3] = v57;
    (*(void (**)(uint64_t, uint8_t *, void *))(*(void *)v16 + 248))(v16, buf, v57);
    sub_100313668(v57);
    if (SHIBYTE(v49) < 0) {
      operator delete(__p);
    }
    sub_10030BF00((uint64_t)buf);
    if (v17) {
      goto LABEL_21;
    }
LABEL_20:
    sub_10004D2C8(v15);
    goto LABEL_21;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v21 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for addPlanWith", buf, 2u);
  }
  id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
  (*((void (**)(id, void, id))v7 + 2))(v7, 0, v22);

  if ((v17 & 1) == 0) {
    goto LABEL_20;
  }
LABEL_21:
}

- (void)canRunActivationCodeProvisioningWithCompletion:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    char v20 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v20);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v13)
        {
          v18[0] = _NSConcreteStackBlock;
          v18[1] = 3221225472;
          v18[2] = sub_10052C428;
          v18[3] = &unk_1019E0E60;
          v18[4] = self;
          id v19 = v4;
          id v22 = 0;
          v21[0] = off_1019E1120;
          v21[1] = objc_retainBlock(v18);
          id v22 = v21;
          (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v13 + 56))(v13, 3, 2, v21);
          sub_100313668(v21);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v16 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) canRunActivationCodeProvisioningWithCompletion:]";
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
          }
          id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, void, id))v4 + 2))(v4, 0, 0, v17);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for canRunActivationCodeProvisioningWithCompletion", (uint8_t *)&buf, 2u);
  }
LABEL_21:
}

- (void)addQRCodePlanWith:(id)a3 appName:(id)a4 appType:(unint64_t)a5 completionHandler:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a6;
  if (v12)
  {
    [(CTXPCClientHandler *)self addPlanWith:v10 appName:v11 appType:a5 completionHandler:v12];
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v13 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v14);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v14 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid completion handler for addQRCodePlanWith", v14, 2u);
    }
  }
}

- (void)getCameraScanInfoForCardData:(id)a3 completionHandler:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getCameraScanInfoForCardData", (uint8_t *)&buf, 2u);
    }
    goto LABEL_31;
  }
  if (!v6)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Empty card data passed", (uint8_t *)&buf, 2u);
    }
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, 0, v20);

    goto LABEL_31;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
  uint64_t v9 = ServiceMap;
  id v10 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      id v10 = (const char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v32 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v32);
  if (!v14)
  {
    uint64_t v16 = 0;
    goto LABEL_15;
  }
  uint64_t v16 = v14[3];
  uint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
LABEL_15:
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
LABEL_16:
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (v16)
  {
    long long buf = 0uLL;
    id v36 = 0;
    unint64_t v31 = v6;
    CFRetain(v6);
    (*(void (**)(long long *__return_ptr, uint64_t, const void **))(*(void *)v16 + 264))(&buf, v16, &v31);
    sub_1000558F4(&v31);
    *(void *)&long long v32 = 0;
    uint64_t v21 = buf;
    sub_1000558F4((const void **)&v32);
    if (v21)
    {
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3321888768;
      void v26[2] = sub_10052CF04;
      v26[3] = &unk_1019E0EC0;
      void v26[4] = self;
      unint64_t v28 = (const void *)buf;
      if ((void)buf) {
        CFRetain((CFTypeRef)buf);
      }
      id v29 = (const void *)*((void *)&buf + 1);
      if (*((void *)&buf + 1)) {
        CFRetain(*((CFTypeRef *)&buf + 1));
      }
      id v30 = v36;
      if (v36) {
        CFRetain(v36);
      }
      id v27 = v7;
      unint64_t v34 = 0;
      v33[0] = off_1019E1120;
      v33[1] = objc_retainBlock(v26);
      unint64_t v34 = v33;
      (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v16 + 56))(v16, 3, 2, v33);
      sub_100313668(v33);

      sub_1000558F4(&v30);
      sub_1000558F4(&v29);
      sub_1000558F4(&v28);
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v24 = *((void *)&v32 + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v32);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v32) = 138412290;
        *(void *)((char *)&v32 + 4) = v6;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Not eSIM QR code: %@", (uint8_t *)&v32, 0xCu);
      }
      id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v25);
    }
    sub_1000558F4(&v36);
    sub_1000558F4((const void **)&buf + 1);
    sub_1000558F4((const void **)&buf);
    if (v17) {
      goto LABEL_31;
    }
LABEL_30:
    sub_10004D2C8(v15);
    goto LABEL_31;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v22 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) getCameraScanInfoForCardData:completionHandler:]";
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
  }
  id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
  v7[2](v7, 0, v23);

  if ((v17 & 1) == 0) {
    goto LABEL_30;
  }
LABEL_31:
}

- (void)getTransferPlansWithCompletion:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    id v20 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v20);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v13)
        {
          v18[0] = _NSConcreteStackBlock;
          v18[1] = 3221225472;
          v18[2] = sub_10052D930;
          v18[3] = &unk_1019E0F88;
          v18[4] = self;
          id v19 = v4;
          (*(void (**)(uint64_t, void, void *))(*(void *)v13 + 112))(v13, 0, v18);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v16 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) getTransferPlansWithCompletion:]";
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
          }
          id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v4 + 2))(v4, 0, v17);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) getTransferPlansWithCompletion:]";
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler: %s", (uint8_t *)&buf, 0xCu);
  }
LABEL_21:
}

- (void)hiddenTransferPlans:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    id v20 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v20);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v13)
        {
          id v16 = objc_retainBlock(v4);
          id v17 = self;
          v21[0] = off_1019E11A0;
          v21[1] = v16;
          v21[2] = v17;
          void v21[3] = v21;
          (*(void (**)(uint64_t, void *))(*(void *)v13 + 120))(v13, v21);
          sub_100313790(v21);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v18 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) hiddenTransferPlans:]";
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
          }
          id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v4 + 2))(v4, 0, v19);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) hiddenTransferPlans:]";
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler: %s", (uint8_t *)&buf, 0xCu);
  }
LABEL_21:
}

- (void)hideTransferPlan:(id)a3 fromDevice:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (!v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) hideTransferPlan:fromDevice:completion:]";
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler: %s", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_23;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
  uint64_t v12 = ServiceMap;
  uint64_t v13 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    char v14 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = (const char *)v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  CFTypeRef cf = v13;
  id v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&cf);
  if (!v17)
  {
    uint64_t v19 = 0;
    goto LABEL_11;
  }
  uint64_t v19 = v17[3];
  uint64_t v18 = (std::__shared_weak_count *)v17[4];
  if (!v18)
  {
LABEL_11:
    std::mutex::unlock(v12);
    uint64_t v18 = 0;
    char v20 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
LABEL_12:
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (v19)
  {
    *(void *)&long long buf = 0;
    if (v8)
    {
      id v22 = [v8 iccid];
      CFTypeRef cf = v22;
      sub_100013168((const void **)&buf, &cf);
    }
    CFTypeRef cf = 0;
    if (v9)
    {
      id v23 = [v9 IMEI];
      CFTypeRef v32 = v23;
      sub_100013168(&cf, &v32);

      CFTypeRef v32 = 0;
      uint64_t v24 = [v9 EID];
      CFTypeRef v31 = v24;
      sub_100013168(&v32, &v31);
    }
    else
    {
      CFTypeRef v32 = 0;
    }
    id v30 = (const void *)buf;
    if ((void)buf) {
      CFRetain((CFTypeRef)buf);
    }
    CFTypeRef v29 = cf;
    if (cf) {
      CFRetain(cf);
    }
    CFTypeRef v28 = v32;
    if (v32) {
      CFRetain(v32);
    }
    id v27 = objc_retainBlock(v10);
    v34[0] = off_1019E1220;
    v34[1] = v27;
    void v34[3] = v34;
    (*(void (**)(uint64_t, const void **, CFTypeRef *, CFTypeRef *, void *))(*(void *)v19 + 128))(v19, &v30, &v29, &v28, v34);
    sub_100060644(v34);
    sub_1000558F4(&v28);
    sub_1000558F4(&v29);
    sub_1000558F4(&v30);
    sub_1000558F4(&v32);
    sub_1000558F4(&cf);
    sub_1000558F4((const void **)&buf);
    if (v20) {
      goto LABEL_23;
    }
LABEL_22:
    sub_10004D2C8(v18);
    goto LABEL_23;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v25 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) hideTransferPlan:fromDevice:completion:]";
    _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
  }
  id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
  (*((void (**)(id, void, id))v10 + 2))(v10, 0, v26);

  if ((v20 & 1) == 0) {
    goto LABEL_22;
  }
LABEL_23:
}

- (void)hideTransferCellularPlan:(id)a3 fromDevice:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, void, id))a5;
  if (v10)
  {
    if (v8 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      id v11 = v8;
      uint64_t v12 = [v11 planID];

      if (v12)
      {
        uint64_t v13 = [v11 planID];
        [(CTXPCClientHandler *)self hideTransferPlan:v13 fromDevice:v9 completion:v10];
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v17 = *(NSObject **)&v20[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid CTRemotePlanIdentifier", (uint8_t *)&v19, 2u);
        }
        id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        v10[2](v10, 0, v18);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v14 = *(NSObject **)&v20[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v19) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid CTRemotePlan", (uint8_t *)&v19, 2u);
      }
      id v15 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, 0, v15);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v16 = *(NSObject **)&v20[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      int v19 = 136315138;
      *(void *)char v20 = "-[CTXPCClientHandler(CellularPlanManager) hideTransferCellularPlan:fromDevice:completion:]";
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler: %s", (uint8_t *)&v19, 0xCu);
    }
  }
}

- (void)unhideTransferPlan:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
      id v9 = ServiceMap;
      id v10 = "22CellularPlanController";
      if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
      {
        id v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          id v10 = (const char *)v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      BOOL v33 = v10;
      char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v33);
      if (v14)
      {
        uint64_t v16 = v14[3];
        id v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          if (v16)
          {
            id v21 = v6;
            id v22 = [v21 blacklistICCID];
            id v23 = v22;
            CFTypeRef v32 = v22;
            if (v22) {
              CFRetain(v22);
            }
            uint64_t v24 = [v21 blacklistIMEI];
            id v25 = v24;
            CFTypeRef v31 = v24;
            if (v24) {
              CFRetain(v24);
            }
            id v26 = [v21 blacklistEID];
            id v27 = v26;
            id v30 = v26;
            if (v26) {
              CFRetain(v26);
            }
            id v28 = objc_retainBlock(v7);
            v34[0] = off_1019E12A0;
            v34[1] = v28;
            void v34[3] = v34;
            (*(void (**)(uint64_t, const void **, const void **, const void **, void *))(*(void *)v16 + 136))(v16, &v32, &v31, &v30, v34);
            sub_100060644(v34);
            sub_1000558F4(&v30);

            sub_1000558F4(&v31);
            sub_1000558F4(&v32);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            CFTypeRef v29 = *((void *)&buf + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) unhideTransferPlan:completion:]";
              _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
            }
            id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
            (*((void (**)(id, void, id))v7 + 2))(v7, 0, v21);
          }

          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_31;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      id v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    int v19 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid plan type", (uint8_t *)&buf, 2u);
    }
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, id))v7 + 2))(v7, 0, v20);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v18 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) unhideTransferPlan:completion:]";
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler: %s", (uint8_t *)&buf, 0xCu);
    }
  }
LABEL_31:
}

- (void)deleteTransferPlansForImei:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v18 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) deleteTransferPlansForImei:completion:]";
    int v19 = "Invalid completion handler: %s";
    id v20 = v18;
    uint32_t v21 = 12;
LABEL_13:
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v19, (uint8_t *)&buf, v21);
    goto LABEL_24;
  }
  if (![v6 length])
  {
    v7[2](v7, 0);
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    LOWORD(buf) = 0;
    int v19 = "invalid parameter for imei";
    id v20 = v22;
    uint32_t v21 = 2;
    goto LABEL_13;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
  id v9 = ServiceMap;
  id v10 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      id v10 = (const char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  id v26 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v26);
  if (!v14)
  {
    uint64_t v16 = 0;
    goto LABEL_15;
  }
  uint64_t v16 = v14[3];
  id v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
LABEL_15:
    std::mutex::unlock(v9);
    id v15 = 0;
    char v17 = 1;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
LABEL_16:
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (v16)
  {
    sub_100058DB0(__p, (char *)[v6 UTF8String]);
    id v23 = objc_retainBlock(v7);
    v27[0] = off_1019E1320;
    v27[1] = v23;
    v27[3] = v27;
    (*(void (**)(uint64_t, void **, void *))(*(void *)v16 + 144))(v16, __p, v27);
    sub_1000605C0(v27);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    v7[2](v7, 0);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
LABEL_24:
}

- (void)deleteZone:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    id v9 = ServiceMap;
    id v10 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        id v10 = (const char *)v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    id v22 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v22);
    if (v14)
    {
      uint64_t v16 = v14[3];
      id v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v16)
        {
          uint32_t v21 = v6;
          if (v6) {
            CFRetain(v6);
          }
          v19[0] = _NSConcreteStackBlock;
          v19[1] = 3221225472;
          v19[2] = sub_10052F348;
          v19[3] = &unk_1019E0EF8;
          id v20 = v7;
          (*(void (**)(uint64_t, const void **, void *))(*(void *)v16 + 152))(v16, &v21, v19);
          sub_1000558F4(&v21);
        }
        else
        {
          (*((void (**)(id, void))v7 + 2))(v7, 0);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    id v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) deleteZone:completion:]";
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler: %s", (uint8_t *)&buf, 0xCu);
  }
LABEL_21:
}

- (void)transferPlan:(id)a3 fromDevice:(id)a4 completionHandler:(id)a5
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  if (!v11)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for transferPlan", buf, 2u);
    }
    goto LABEL_49;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  unsigned int v13 = ServiceMap;
  char v14 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v15 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      char v14 = (const char *)v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  v40[0] = (void *)v14;
  id v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v40);
  if (!v18)
  {
    uint64_t v20 = 0;
    goto LABEL_11;
  }
  uint64_t v20 = v18[3];
  int v19 = (std::__shared_weak_count *)v18[4];
  if (!v19)
  {
LABEL_11:
    std::mutex::unlock(v13);
    int v19 = 0;
    char v21 = 1;
    goto LABEL_12;
  }
  p_shared_owners = &v19->__shared_owners_;
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  char v21 = 0;
LABEL_12:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v20)
  {
    v40[0] = 0;
    v40[1] = 0;
    uint64_t v41 = 0;
    id v23 = [v10 IMEI];
    if (v23)
    {
      p_shared_owners = [v10 IMEI];
      uint64_t v24 = (char *)[p_shared_owners UTF8String];
    }
    else
    {
      uint64_t v24 = "";
    }
    sub_100058DB0(v40, v24);
    if (v23) {

    }
    v38[0] = 0;
    v38[1] = 0;
    uint64_t v39 = 0;
    id v27 = [v10 EID];
    if (v27)
    {
      p_shared_owners = [v10 EID];
      id v28 = (char *)[p_shared_owners UTF8String];
    }
    else
    {
      id v28 = "";
    }
    sub_100058DB0(v38, v28);
    if (v27) {

    }
    long long v51 = 0uLL;
    if (sub_100CCD2E8())
    {
      v36[0] = 0;
      v36[1] = 0;
      uint64_t v37 = 0;
      id v29 = [v9 iccid];
      sub_100058DB0(v36, (char *)[v29 UTF8String]);

      BOOL v33 = 0;
      uint64_t v34 = 0;
      char v35 = 0;
      if (SHIBYTE(v41) < 0)
      {
        sub_10004FC84(buf, v40[0], (unint64_t)v40[1]);
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)v40;
        uint64_t v46 = v41;
      }
      long long v47 = v51;
      if (SHIBYTE(v37) < 0)
      {
        sub_10004FC84(&__p, v36[0], (unint64_t)v36[1]);
      }
      else
      {
        long long __p = *(_OWORD *)v36;
        uint64_t v49 = v37;
      }
      BOOL v33 = 0;
      uint64_t v34 = 0;
      char v35 = 0;
      unint64_t v42 = (void **)&v33;
      uint64_t v43 = 0;
      BOOL v33 = (char *)operator new(0x40uLL);
      uint64_t v34 = (uint64_t)v33;
      char v35 = v33 + 64;
      uint64_t v34 = sub_10030BA7C((uint64_t)&v35, (uint64_t)buf, (uint64_t)&v50, (uint64_t)v33);
      if (SHIBYTE(v49) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v46) < 0) {
        operator delete(*(void **)buf);
      }
      id v32 = objc_retainBlock(v11);
      v44[0] = off_1019E13A0;
      v44[1] = v32;
      v44[3] = v44;
      (*(void (**)(uint64_t, char **, void *))(*(void *)v20 + 328))(v20, &v33, v44);
      sub_1003135E4(v44);
      *(void *)long long buf = &v33;
      sub_10030A698((void ***)buf);
      if (SHIBYTE(v37) < 0) {
        operator delete(v36[0]);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v30 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&buf[4] = v10;
        _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Invalid EID: %@", buf, 0xCu);
      }
      id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      (*((void (**)(id, void, void, void, id))v11 + 2))(v11, 0, 0, 0, v31);
    }
    if (SHIBYTE(v39) < 0) {
      operator delete(v38[0]);
    }
    if (SHIBYTE(v41) < 0)
    {
      operator delete(v40[0]);
      if (v21) {
        goto LABEL_49;
      }
      goto LABEL_48;
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v25 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&buf[4] = "-[CTXPCClientHandler(CellularPlanManager) transferPlan:fromDevice:completionHandler:]";
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", buf, 0xCu);
    }
    id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    (*((void (**)(id, void, void, void, id))v11 + 2))(v11, 0, 0, 0, v26);
  }
  if ((v21 & 1) == 0) {
LABEL_48:
  }
    sub_10004D2C8(v19);
LABEL_49:
}

- (void)transferCellularPlan:(id)a3 fromDevice:(id)a4 completionHandler:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (v10)
  {
    if (v8 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      id v11 = v8;
      uint64_t v12 = [v11 planID];

      if (v12)
      {
        unsigned int v13 = [v11 planID];
        [(CTXPCClientHandler *)self transferPlan:v13 fromDevice:v9 completionHandler:v10];
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        unsigned int v17 = *(NSObject **)&v20[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid CTRemotePlanIdentifier", (uint8_t *)&v19, 2u);
        }
        id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        (*((void (**)(id, void, void, void, id))v10 + 2))(v10, 0, 0, 0, v18);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v14 = *(NSObject **)&v20[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v19) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid CTRemotePlan", (uint8_t *)&v19, 2u);
      }
      id v15 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      (*((void (**)(id, void, void, void, id))v10 + 2))(v10, 0, 0, 0, v15);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v16 = *(NSObject **)&v20[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      int v19 = 136315138;
      *(void *)uint64_t v20 = "-[CTXPCClientHandler(CellularPlanManager) transferCellularPlan:fromDevice:completionHandler:]";
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler: %s", (uint8_t *)&v19, 0xCu);
    }
  }
}

- (void)transferPlans:(id)a3 fromDevice:(id)a4 completionHandler:(id)a5
{
  id v52 = a3;
  id v54 = a4;
  id v53 = a5;
  if (v53)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v10 = ServiceMap;
    id v11 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        id v11 = (const char *)v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    char v67 = v11;
    id v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v67);
    if (v15)
    {
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      uint64_t v51 = v15[3];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v49 = v16;
        sub_10004D2C8(v16);
        char v50 = 0;
LABEL_12:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v51)
        {
          long long v65 = 0uLL;
          uint64_t v66 = 0;
          id v18 = [v54 IMEI];
          if (v18)
          {
            id v5 = [v54 IMEI];
            int v19 = (char *)[v5 UTF8String];
          }
          else
          {
            int v19 = "";
          }
          sub_100058DB0(&v65, v19);
          if (v18) {

          }
          v63[0] = 0;
          v63[1] = 0;
          uint64_t v64 = 0;
          id v22 = [v54 EID];
          if (v22)
          {
            id v5 = [v54 EID];
            id v23 = (char *)[v5 UTF8String];
          }
          else
          {
            id v23 = "";
          }
          sub_100058DB0(v63, v23);
          if (v22) {

          }
          long long v74 = 0uLL;
          if (sub_100CCD2E8())
          {
            int64x2_t v61 = 0uLL;
            CFStringRef v62 = 0;
            long long v57 = 0u;
            long long v58 = 0u;
            long long v59 = 0u;
            long long v60 = 0u;
            uint64_t v24 = [v52 planIdentifiers];
            id v25 = [v24 countByEnumeratingWithState:&v57 objects:v73 count:16];
            if (v25)
            {
              uint64_t v26 = *(void *)v58;
              do
              {
                for (uint64_t i = 0; i != v25; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v58 != v26) {
                    objc_enumerationMutation(v24);
                  }
                  id v28 = *(void **)(*((void *)&v57 + 1) + 8 * i);
                  v55[0] = 0;
                  v55[1] = 0;
                  uint64_t v56 = 0;
                  id v29 = [v28 iccid];
                  sub_100058DB0(v55, (char *)[v29 UTF8String]);

                  id v30 = (void *)HIBYTE(v56);
                  char v31 = HIBYTE(v56);
                  if (v56 < 0) {
                    id v30 = v55[1];
                  }
                  if (v30)
                  {
                    memset(buf, 0, 64);
                    if (SHIBYTE(v66) < 0)
                    {
                      sub_10004FC84(buf, (void *)v65, *((unint64_t *)&v65 + 1));
                      char v31 = HIBYTE(v56);
                    }
                    else
                    {
                      *(_OWORD *)long long buf = v65;
                      *(void *)&uint8_t buf[16] = v66;
                    }
                    *(_OWORD *)&uint8_t buf[24] = v74;
                    if (v31 < 0)
                    {
                      sub_10004FC84(&buf[40], v55[0], (unint64_t)v55[1]);
                    }
                    else
                    {
                      *(_OWORD *)&buf[40] = *(_OWORD *)v55;
                      *(void *)&buf[56] = v56;
                    }
                    uint64_t v32 = v61.i64[1];
                    if (v61.i64[1] >= (unint64_t)v62)
                    {
                      uint64_t v34 = (v61.i64[1] - v61.i64[0]) >> 6;
                      if ((unint64_t)(v34 + 1) >> 58) {
                        sub_10006A748();
                      }
                      unint64_t v35 = (uint64_t)&v62[-v61.i64[0]] >> 5;
                      if (v35 <= v34 + 1) {
                        unint64_t v35 = v34 + 1;
                      }
                      if ((unint64_t)&v62[-v61.i64[0]] >= 0x7FFFFFFFFFFFFFC0) {
                        unint64_t v36 = 0x3FFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v36 = v35;
                      }
                      id v70 = &v62;
                      if (v36) {
                        uint64_t v37 = (const char *)sub_1001A14BC((uint64_t)&v62, v36);
                      }
                      else {
                        uint64_t v37 = 0;
                      }
                      char v67 = v37;
                      v68.i64[0] = (uint64_t)&v37[64 * v34];
                      v68.i64[1] = v68.i64[0];
                      id v69 = (char *)&v37[64 * v36];
                      sub_10030CE18((char *)v68.i64[0], (long long *)buf);
                      uint64_t v38 = v61.i64[1];
                      uint64_t v39 = v61.i64[0];
                      uint64_t v40 = v68.i64[1];
                      uint64_t v41 = v68.i64[0];
                      if (v61.i64[1] == v61.i64[0])
                      {
                        int64x2_t v44 = vdupq_n_s64(v61.u64[1]);
                      }
                      else
                      {
                        do
                        {
                          long long v42 = *(_OWORD *)(v38 - 64);
                          *(void *)(v41 - 48) = *(void *)(v38 - 48);
                          *(_OWORD *)(v41 - 64) = v42;
                          *(void *)(v38 - 56) = 0;
                          *(void *)(v38 - 48) = 0;
                          *(void *)(v38 - 64) = 0;
                          *(_OWORD *)(v41 - 40) = *(_OWORD *)(v38 - 40);
                          long long v43 = *(_OWORD *)(v38 - 24);
                          *(void *)(v41 - 8) = *(void *)(v38 - 8);
                          *(_OWORD *)(v41 - 24) = v43;
                          v41 -= 64;
                          *(void *)(v38 - 16) = 0;
                          *(void *)(v38 - 8) = 0;
                          *(void *)(v38 - 24) = 0;
                          v38 -= 64;
                        }
                        while (v38 != v39);
                        int64x2_t v44 = v61;
                      }
                      uint64_t v33 = v40 + 64;
                      v61.i64[0] = v41;
                      v61.i64[1] = v40 + 64;
                      int64x2_t v68 = v44;
                      BOOL v45 = v62;
                      CFStringRef v62 = v69;
                      id v69 = v45;
                      char v67 = (const char *)v44.i64[0];
                      sub_1005409BC((uint64_t)&v67);
                    }
                    else
                    {
                      sub_10030CE18((char *)v61.i64[1], (long long *)buf);
                      uint64_t v33 = v32 + 64;
                    }
                    v61.i64[1] = v33;
                    if ((char)buf[63] < 0) {
                      operator delete(*(void **)&buf[40]);
                    }
                    if ((char)buf[23] < 0) {
                      operator delete(*(void **)buf);
                    }
                    char v31 = HIBYTE(v56);
                  }
                  if (v31 < 0) {
                    operator delete(v55[0]);
                  }
                }
                id v25 = [v24 countByEnumeratingWithState:&v57 objects:v73 count:16];
              }
              while (v25);
            }

            id v46 = objc_retainBlock(v53);
            v71[0] = off_1019E1420;
            v71[1] = v46;
            v71[3] = v71;
            (*(void (**)(uint64_t, int64x2_t *, void *))(*(void *)v51 + 328))(v51, &v61, v71);
            sub_1003135E4(v71);
            *(void *)long long buf = &v61;
            sub_10030A698((void ***)buf);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            long long v47 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              *(void *)&buf[4] = v54;
              _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Invalid EID: %@", buf, 0xCu);
            }
            id v48 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            (*((void (**)(id, void, void, void, id))v53 + 2))(v53, 0, 0, 0, v48);
          }
          if (SHIBYTE(v64) < 0) {
            operator delete(v63[0]);
          }
          if (SHIBYTE(v66) < 0) {
            operator delete((void *)v65);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136315138;
            *(void *)&buf[4] = "-[CTXPCClientHandler(CellularPlanManager) transferPlans:fromDevice:completionHandler:]";
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", buf, 0xCu);
          }
          id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, void, void, id))v53 + 2))(v53, 0, 0, 0, v21);
        }
        if ((v50 & 1) == 0) {
          sub_10004D2C8(v49);
        }
        goto LABEL_78;
      }
    }
    else
    {
      uint64_t v51 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v49 = 0;
    char v50 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v17 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler for transferPlan", buf, 2u);
  }
LABEL_78:
}

- (void)transferCellularPlans:(id)a3 fromDevice:(id)a4 completionHandler:(id)a5
{
  id v21 = a3;
  id v19 = a4;
  id v20 = a5;
  if (v20)
  {
    id v8 = objc_opt_new();
    if (v21)
    {
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      id v9 = [v21 plans];
      id v10 = [v9 countByEnumeratingWithState:&v22 objects:v26 count:16];
      if (v10)
      {
        uint64_t v11 = *(void *)v23;
        do
        {
          uint64_t v12 = 0;
          do
          {
            if (*(void *)v23 != v11) {
              objc_enumerationMutation(v9);
            }
            uint64_t v13 = *(void **)(*((void *)&v22 + 1) + 8 * (void)v12);
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              id v14 = v13;
              id v15 = [v14 planID];
              [v8 addObject:v15];
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              uint64_t v16 = *(NSObject **)&v28[4];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138412290;
                *(void *)id v28 = v13;
                _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "plan [%@] is not instance of CTRemotePlan", buf, 0xCu);
              }
            }
            uint64_t v12 = (char *)v12 + 1;
          }
          while (v10 != v12);
          id v10 = [v9 countByEnumeratingWithState:&v22 objects:v26 count:16];
        }
        while (v10);
      }
    }
    id v17 = [objc_alloc((Class)CTRemotePlanIdentifierList) initWithPlanIdentifiers:v8];
    [(CTXPCClientHandler *)self transferPlans:v17 fromDevice:v19 completionHandler:v20];
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v18 = *(NSObject **)&v28[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for transferPlan", buf, 2u);
    }
  }
}

- (void)cancelCellularPlanTransfer:(id)a3 fromDevice:(id)a4 keepCache:(BOOL)a5 completionHandler:(id)a6
{
  BOOL v8 = a5;
  id v11 = a3;
  id v12 = a4;
  uint64_t v13 = (void (**)(id, id))a6;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v37);
  id v15 = ServiceMap;
  uint64_t v16 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v17 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = (const char *)v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long __p = v16;
  id v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)&__p);
  if (v20)
  {
    uint64_t v22 = v20[3];
    id v21 = (std::__shared_weak_count *)v20[4];
    if (v21)
    {
      p_shared_owners = &v21->__shared_owners_;
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v15);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      char v23 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  std::mutex::unlock(v15);
  id v21 = 0;
  char v23 = 1;
LABEL_9:
  if (v38) {
    sub_10004D2C8(v38);
  }
  if (!v22)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v26 = v38;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v37);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v37) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)&v37, 2u);
    }
    id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v13[2](v13, v27);

    goto LABEL_37;
  }
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  long long v24 = [v12 EID];
  if (v24)
  {
    p_shared_owners = [v12 EID];
    long long v25 = (char *)[p_shared_owners UTF8String];
  }
  else
  {
    long long v25 = "";
  }
  sub_100058DB0(&v37, v25);
  if (v24) {

  }
  v43[0] = 0;
  v43[1] = 0;
  if ((sub_100CCD2E8() & 1) == 0)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v34 = *((void *)&__p + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__p) = 138412290;
      *(void *)((char *)&__p + 4) = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Invalid EID: %@", (uint8_t *)&__p, 0xCu);
    }
    goto LABEL_28;
  }
  if (!v11 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v35 = *((void *)&__p + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Invalid CTRemotePlan", (uint8_t *)&__p, 2u);
    }
LABEL_28:
    id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v13[2](v13, v28);
    goto LABEL_36;
  }
  id v28 = v11;
  id v29 = [v28 planID];
  BOOL v30 = v29 == 0;

  if (v30)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v36 = *((void *)&__p + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Invalid CTRemotePlanIdentifier", (uint8_t *)&__p, 2u);
    }
    id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v13[2](v13, v31);
  }
  else
  {
    id v31 = [v28 planID];
    long long __p = 0uLL;
    uint64_t v42 = 0;
    id v32 = [v31 iccid];
    sub_100058DB0(&__p, (char *)[v32 UTF8String]);

    uint64_t v33 = objc_retainBlock(v13);
    v40[0] = off_1019E14A0;
    v40[1] = v33;
    v40[3] = v40;
    (*(void (**)(uint64_t, void *, long long *, BOOL, void *))(*(void *)v22 + 336))(v22, v43, &__p, v8, v40);
    sub_100313668(v40);
    if (SHIBYTE(v42) < 0) {
      operator delete((void *)__p);
    }
  }

LABEL_36:
  if (SHIBYTE(v39) < 0)
  {
    operator delete(v37);
    if (v23) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
LABEL_37:
  if ((v23 & 1) == 0) {
LABEL_38:
  }
    sub_10004D2C8(v21);
LABEL_39:
}

- (void)renewOneTimePassword:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, id))a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  id v9 = ServiceMap;
  id v10 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      id v10 = (const char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  long long v25 = v10;
  id v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v25);
  if (v14)
  {
    uint64_t v16 = v14[3];
    id v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  id v15 = 0;
  char v17 = 1;
LABEL_9:
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (!v16)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v20 = v24;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v7[2](v7, v19);
LABEL_25:

    if (v17) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (!v6 || ![v6 length])
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v24;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid transfer iccid", buf, 2u);
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, v19);
    goto LABEL_25;
  }
  sub_100058DB0(__p, (char *)[v6 UTF8String]);
  (*(void (**)(uint64_t, void **))(*(void *)v16 + 344))(v16, __p);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  v7[2](v7, 0);
  if ((v17 & 1) == 0) {
LABEL_17:
  }
    sub_10004D2C8(v15);
LABEL_18:
}

- (void)handleTermsAndConditionsCompleted:(id)a3 consented:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = (void (**)(id, id))a5;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  id v11 = ServiceMap;
  uint64_t v12 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    unsigned int v13 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = (const char *)v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  id v27 = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v27);
  if (v16)
  {
    uint64_t v18 = v16[3];
    char v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  char v17 = 0;
  char v19 = 1;
LABEL_9:
  if (v26) {
    sub_10004D2C8(v26);
  }
  if (!v18)
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v22 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
    }
    id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v9[2](v9, v21);
LABEL_25:

    if (v19) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (!v8 || ![v8 length])
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v20 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid transfer iccid", buf, 2u);
    }
    id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v9[2](v9, v21);
    goto LABEL_25;
  }
  sub_100058DB0(__p, (char *)[v8 UTF8String]);
  (*(void (**)(uint64_t, void **, BOOL))(*(void *)v18 + 352))(v18, __p, v6);
  if (v24 < 0) {
    operator delete(__p[0]);
  }
  v9[2](v9, 0);
  if ((v19 & 1) == 0) {
LABEL_17:
  }
    sub_10004D2C8(v17);
LABEL_18:
}

- (void)handleUserEnteredOtp:(id)a3 otp:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, id))a5;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  uint64_t v12 = ServiceMap;
  unsigned int v13 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    uint64_t v14 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unsigned int v13 = (const char *)v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  BOOL v30 = v13;
  char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&v30);
  if (v17)
  {
    uint64_t v19 = v17[3];
    uint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v18 = 0;
  char v20 = 1;
LABEL_9:
  if (v29) {
    sub_10004D2C8(v29);
  }
  if (!v19)
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v23 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
    }
    id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v10[2](v10, v22);
LABEL_27:

    if (v20) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if (!v8 || ![v8 length])
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v21 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid transfer iccid", buf, 2u);
    }
    id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v10[2](v10, v22);
    goto LABEL_27;
  }
  sub_100058DB0(v26, (char *)[v8 UTF8String]);
  sub_100058DB0(__p, (char *)[v9 UTF8String]);
  (*(void (**)(uint64_t, void **, void **))(*(void *)v19 + 360))(v19, v26, __p);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  if (v27 < 0) {
    operator delete(v26[0]);
  }
  v10[2](v10, 0);
  if ((v20 & 1) == 0) {
LABEL_19:
  }
    sub_10004D2C8(v18);
LABEL_20:
}

- (void)convertPhysicalToeSIMWithCompletionHandler:(id)a3
{
  id v4 = a3;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v18);
  BOOL v6 = ServiceMap;
  id v7 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      id v7 = (const char *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  char v20 = v7;
  id v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v20);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v13)
  {
    id v15 = objc_retainBlock(v4);
    v21[0] = off_1019E1520;
    v21[1] = v15;
    void v21[3] = v21;
    (*(void (**)(uint64_t, void *))(*(void *)v13 + 368))(v13, v21);
    sub_100313668(v21);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v16 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)&v18, 2u);
    }
    id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    (*((void (**)(id, id))v4 + 2))(v4, v17);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

- (void)getPlanTransferCredentials:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p);
  uint64_t v9 = ServiceMap;
  unsigned int v10 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unsigned int v10 = (const char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  char v24 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v24);
  if (v14)
  {
    uint64_t v16 = v14[3];
    id v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  id v15 = 0;
  char v17 = 1;
LABEL_9:
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (v16)
  {
    sub_100058DB0(&__p, (char *)[v6 UTF8String]);
    id v18 = objc_retainBlock(v7);
    v25[0] = off_1019E15A0;
    v25[1] = v18;
    v25[3] = v25;
    (*(void (**)(uint64_t, void **, void *))(*(void *)v16 + 376))(v16, &__p, v25);
    sub_10030CEB8(v25);
    if (v23 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v22;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)&__p, 2u);
    }
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    (*((void (**)(id, void, id))v7 + 2))(v7, 0, v20);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

- (void)getTransferType:(id)a3 remoteEid:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unsigned int v10 = (void (**)(id, void))a5;
  if (v10)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf.__r_.__value_.__l.__data_);
    uint64_t v12 = ServiceMap;
    unsigned int v13 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      char v14 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        unsigned int v13 = (char *)v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    long long __p = v13;
    char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&__p);
    if (v17)
    {
      uint64_t v19 = v17[3];
      id v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v32 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    id v18 = 0;
    char v32 = 1;
LABEL_12:
    if (buf.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
    }
    if (!v19)
    {
      [(CTXPCClientHandler *)self getLogContext];
      size = buf.__r_.__value_.__l.__size_;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      if (os_log_type_enabled(size, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, size, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)&buf, 2u);
      }
      v10[2](v10, 0);
      goto LABEL_33;
    }
    memset(&buf, 0, sizeof(buf));
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v21 = v8;
      id v22 = [v21 planID];
      char v23 = [v22 iccid];
      BOOL v24 = [v23 length] == 0;

      if (v24)
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v31 = v34;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "invalid iccid", (uint8_t *)&__p, 2u);
        }
        v10[2](v10, 0);

        goto LABEL_31;
      }
      char v25 = [v21 planID];
      id v26 = [v25 iccid];
      sub_10003ED78(&buf, (char *)[v26 UTF8String]);

      if (v9 && [v9 length])
      {
        long long __p = 0;
        uint64_t v34 = 0;
        uint64_t v35 = 0;
        sub_100058DB0(&__p, (char *)[v9 UTF8String]);
        char v27 = objc_retainBlock(v10);
        v37[0] = off_1019E1630;
        v37[1] = v27;
        v37[3] = v37;
        (*(void (**)(uint64_t, std::string *, void **, void *))(*(void *)v19 + 384))(v19, &buf, &__p, v37);
        sub_10030CF3C(v37);
        if (SHIBYTE(v35) < 0) {
          operator delete(__p);
        }
        goto LABEL_31;
      }
      [(CTXPCClientHandler *)self getLogContext];
      id v29 = v34;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
LABEL_27:
        v10[2](v10, 0);
LABEL_31:
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
LABEL_33:
        if ((v32 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_35;
      }
      LOWORD(__p) = 0;
      BOOL v30 = "invalid eid";
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v29 = v34;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      LOWORD(__p) = 0;
      BOOL v30 = "invalid CTPlan type";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v30, (uint8_t *)&__p, 2u);
    goto LABEL_27;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v20 = buf.__r_.__value_.__l.__size_;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "invalid completion", (uint8_t *)&buf, 2u);
  }
LABEL_35:
}

- (void)plansPendingInstallWithCompletion:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v19 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v19);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v13)
        {
          id v16 = objc_retainBlock(v4);
          v20[0] = off_1019E16C0;
          v20[1] = v16;
          v20[3] = v20;
          (*(void (**)(uint64_t, void *))(*(void *)v13 + 104))(v13, v20);
          sub_100033230(v20);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v17 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) plansPendingInstallWithCompletion:]";
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
          }
          id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v4 + 2))(v4, 0, v18);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) plansPendingInstallWithCompletion:]";
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for %s", (uint8_t *)&buf, 0xCu);
  }
LABEL_21:
}

- (void)installPendingPlan:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, id))a4;
  if (v7)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf.__r_.__value_.__l.__data_);
      uint64_t v9 = ServiceMap;
      unsigned int v10 = "22CellularPlanController";
      if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
      {
        id v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          unsigned int v10 = (const char *)v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      __p[0] = (void *)v10;
      char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)__p);
      if (v14)
      {
        uint64_t v16 = v14[3];
        uint64_t v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (buf.__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
          }
          if (v16)
          {
            id v21 = v6;
            id v22 = [v21 smdpURL];
            BOOL v23 = v22 == 0;

            if (v23)
            {
              [(CTXPCClientHandler *)self getLogContext];
              size = buf.__r_.__value_.__l.__size_;
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
              if (os_log_type_enabled(size, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, size, OS_LOG_TYPE_ERROR, "Missing server", (uint8_t *)&buf, 2u);
              }
              id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
              v7[2](v7, v31);
            }
            else
            {
              memset(&buf, 0, sizeof(buf));
              BOOL v24 = [v21 matchingID];
              BOOL v25 = v24 == 0;

              if (!v25)
              {
                id v26 = [v21 matchingID];
                sub_10003ED78(&buf, (char *)[v26 UTF8String]);
              }
              id v27 = [v21 smdpURL];
              sub_100058DB0(__p, (char *)[v27 UTF8String]);
              id v28 = objc_retainBlock(v7);
              v34[0] = off_1019E1750;
              v34[1] = v28;
              void v34[3] = v34;
              (*(void (**)(uint64_t, void **, std::string *, void *))(*(void *)v16 + 280))(v16, __p, &buf, v34);
              sub_100313668(v34);
              if (v33 < 0) {
                operator delete(__p[0]);
              }

              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v29 = buf.__r_.__value_.__l.__size_;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"-[CTXPCClientHandler(CellularPlanManager) installPendingPlan:completion:]";
              _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface for %s", (uint8_t *)&buf, 0xCu);
            }
            id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
            v7[2](v7, v21);
          }

          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_34;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      uint64_t v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = buf.__r_.__value_.__l.__size_;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid plan ID type", (uint8_t *)&buf, 2u);
    }
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, v20);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v18 = buf.__r_.__value_.__l.__size_;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"-[CTXPCClientHandler(CellularPlanManager) installPendingPlan:completion:]";
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for %s", (uint8_t *)&buf, 0xCu);
    }
  }
LABEL_34:
}

- (void)installPendingPlanList:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v46 = v6;
  long long v47 = (void (**)(id, id))a4;
  if (!v47)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v21 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) installPendingPlanList:completion:]";
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for %s", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_80;
  }
  BOOL v45 = self;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v57 = 0u;
  long long v56 = 0u;
  id v7 = [v6 plans];
  id v8 = (char *)[v7 countByEnumeratingWithState:&v56 objects:v82 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v57;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v57 != v9) {
          objc_enumerationMutation(v7);
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v19 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid plan ID type", (uint8_t *)&buf, 2u);
          }
          id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
          v47[2](v47, v20);

          goto LABEL_80;
        }
      }
      id v8 = (char *)[v7 countByEnumeratingWithState:&v56 objects:v82 count:16];
    }
    while (v8);
  }

  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
  uint64_t v12 = ServiceMap;
  unsigned int v13 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    char v14 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unsigned int v13 = (const char *)v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  id v53 = v13;
  char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&v53);
  if (v17)
  {
    id v18 = (std::__shared_weak_count *)v17[4];
    uint64_t v44 = v17[3];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v42 = v18;
      sub_10004D2C8(v18);
      char v43 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v44 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v42 = 0;
  char v43 = 1;
LABEL_23:
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (!v44)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v39 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface", (uint8_t *)&buf, 2u);
    }
    id v40 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v47[2](v47, v40);

    goto LABEL_78;
  }
  id v53 = 0;
  id v54 = 0;
  unint64_t v55 = 0;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  id v22 = [v46 plans];
  id v23 = [v22 countByEnumeratingWithState:&v49 objects:v81 count:16];
  if (!v23)
  {

    goto LABEL_76;
  }
  BOOL v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = *(void *)v50;
  for (uint64_t j = *(void *)v50; ; uint64_t j = *(void *)v50)
  {
    if (j != v26) {
      objc_enumerationMutation(v22);
    }
    id v28 = *(id *)(*((void *)&v49 + 1) + 8 * v25);
    id v29 = [v28 smdpURL];
    BOOL v30 = v29 == 0;

    if (v30)
    {
      id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];

      BOOL v24 = v31;
    }
    memset(&__str, 0, sizeof(__str));
    char v32 = [v28 matchingID];
    BOOL v33 = v32 == 0;

    if (!v33)
    {
      id v34 = [v28 matchingID];
      sub_10003ED78(&__str, (char *)[v34 UTF8String]);
    }
    uint64_t v80 = 0;
    long long v78 = 0u;
    long long v79 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long buf = 0u;
    id v35 = [v28 smdpURL];
    sub_10003ED78((std::string *)&buf, (char *)[v35 UTF8String]);

    std::string::operator=((std::string *)((char *)&v62 + 8), &__str);
    unint64_t v36 = v54;
    if ((unint64_t)v54 >= v55)
    {
      uint64_t v37 = (char *)sub_10033D0C4((uint64_t *)&v53, &buf);
    }
    else
    {
      sub_10030C34C(v54, &buf);
      uint64_t v37 = v36 + 312;
    }
    id v54 = v37;
    if ((_BYTE)v80)
    {
      if (SHIBYTE(v79) < 0) {
        operator delete(*((void **)&v78 + 1));
      }
      if (SBYTE7(v78) < 0) {
        operator delete((void *)v77);
      }
      if (SHIBYTE(v76) < 0) {
        operator delete(*((void **)&v75 + 1));
      }
      if (SBYTE7(v75) < 0) {
        operator delete((void *)v74);
      }
      if (SBYTE7(v73) < 0) {
        operator delete((void *)v72);
      }
      if (SHIBYTE(v71) < 0) {
        operator delete(*((void **)&v70 + 1));
      }
      if (SBYTE7(v70) < 0) {
        operator delete((void *)v69);
      }
    }
    if (SBYTE7(v68) < 0) {
      operator delete((void *)v67);
    }
    if (SHIBYTE(v66) < 0) {
      operator delete(*((void **)&v65 + 1));
    }
    if (SBYTE7(v65) < 0) {
      operator delete((void *)v64);
    }
    if (SHIBYTE(v63) < 0) {
      operator delete(*((void **)&v62 + 1));
    }
    if (SBYTE7(v62) < 0) {
      operator delete((void *)buf);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }

    if (++v25 >= (unint64_t)v23) {
      break;
    }
LABEL_67:
    ;
  }
  id v23 = [v22 countByEnumeratingWithState:&v49 objects:v81 count:16];
  if (v23)
  {
    uint64_t v25 = 0;
    goto LABEL_67;
  }

  if (!v24)
  {
LABEL_76:
    uint64_t v41 = objc_retainBlock(v47);
    v60[0] = off_1019E17D0;
    v60[1] = v41;
    v60[3] = v60;
    (*(void (**)(uint64_t, const char **, uint64_t, void *))(*(void *)v44 + 288))(v44, &v53, 6, v60);
    sub_100313668(v60);
    BOOL v24 = 0;
    goto LABEL_77;
  }
  [(CTXPCClientHandler *)v45 getLogContext];
  uint64_t v38 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Missing server", (uint8_t *)&buf, 2u);
  }
  v47[2](v47, v24);
LABEL_77:

  *(void *)&long long buf = &v53;
  sub_1000C63B8((void ***)&buf);
LABEL_78:
  if ((v43 & 1) == 0) {
    sub_10004D2C8(v42);
  }
LABEL_80:
}

- (void)needToLaunchSetUpeSIMWithCompletion:(id)a3
{
  id v4 = (void (**)(id, uint64_t))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v18);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    id v20 = v7;
    id v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v20);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v19) {
          sub_10004D2C8(v19);
        }
        if (v13)
        {
          uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 784))(v13);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v17 = v19;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v18) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for needToLaunchSetUpeSIMWithCompletion", (uint8_t *)&v18, 2u);
          }
          uint64_t v16 = 0;
        }
        v4[2](v4, v16);
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v19;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v18) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion", (uint8_t *)&v18, 2u);
  }
LABEL_21:
}

- (void)registerSetUpeSIMLaunchedEvent:(id)a3
{
  id v4 = a3;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v18);
  id v6 = ServiceMap;
  id v7 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      id v7 = (const char *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  id v20 = v7;
  id v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v20);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v13)
  {
    id v15 = objc_retainBlock(v4);
    v21[0] = off_1019E1850;
    v21[1] = v15;
    void v21[3] = v21;
    (*(void (**)(uint64_t, void *))(*(void *)v13 + 800))(v13, v21);
    sub_10003B34C(v21);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v16 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface for launch setup eSIM UI", (uint8_t *)&v18, 2u);
    }
    char v17 = sub_1003DF5C4(17);
    (*((void (**)(id, void *))v4 + 2))(v4, v17);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

- (void)setUpeSIMLaunched:(id)a3
{
  id v4 = (void (**)(id, void))a3;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v17);
  id v6 = ServiceMap;
  id v7 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      id v7 = (const char *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v19 = v7;
  id v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v19);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 808))(v13);
    v4[2](v4, 0);
    if ((v14 & 1) == 0) {
LABEL_13:
    }
      sub_10004D2C8(v12);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v15 = v18;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v17) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface for launch setup eSIM UI", (uint8_t *)&v17, 2u);
    }
    uint64_t v16 = sub_1003DF5C4(17);
    ((void (**)(id, void *))v4)[2](v4, v16);

    if ((v14 & 1) == 0) {
      goto LABEL_13;
    }
  }
}

- (void)bootstrapPlanTransferForEndpoint:(unint64_t)a3 usingMessageSession:(id)a4 completion:(id)a5
{
  id v8 = a4;
  id v9 = a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v20 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for transferPlan", (uint8_t *)&buf, 2u);
    }
    goto LABEL_27;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
  id v11 = ServiceMap;
  uint64_t v12 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    uint64_t v13 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = (const char *)v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  BOOL v30 = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v30);
  if (v16)
  {
    uint64_t v18 = v16[3];
    char v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  char v17 = 0;
  char v19 = 1;
LABEL_12:
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (v18)
  {
    if (v8)
    {
      id v21 = (std::__shared_weak_count *)operator new(0x20uLL);
      v21->__shared_weak_owners_ = 0;
      v21->__shared_owners_ = 0;
      v21->__vftable = (std::__shared_weak_count_vtbl *)off_1019AF4C8;
      v21[1].__vftable = (std::__shared_weak_count_vtbl *)v8;
      if (a3 == 2) {
        uint64_t v22 = 2;
      }
      else {
        uint64_t v22 = a3 == 1;
      }
      id v28 = v21 + 1;
      id v29 = v21;
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      id v23 = objc_retainBlock(v9);
      v31[0] = off_1019E1950;
      v31[1] = v23;
      v31[3] = v31;
      (*(void (**)(uint64_t, uint64_t, std::__shared_weak_count **, uint64_t, void *))(*(void *)v18 + 472))(v18, v22, &v28, 1, v31);
      sub_100313668(v31);
      if (v29) {
        sub_10004D2C8(v29);
      }
      sub_10004D2C8(v21);
      if (v19) {
        goto LABEL_27;
      }
LABEL_26:
      sub_10004D2C8(v17);
      goto LABEL_27;
    }
    if (a3 == 2) {
      uint64_t v26 = 2;
    }
    else {
      uint64_t v26 = a3 == 1;
    }
    id v27 = objc_retainBlock(v9);
    v32[0] = off_1019E18D0;
    v32[1] = v27;
    v32[3] = v32;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v18 + 480))(v18, v26, 1, v32);
    sub_100313668(v32);
    if ((v19 & 1) == 0) {
      goto LABEL_26;
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    BOOL v24 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) bootstrapPlanTransferForEndpoint:usingMe"
                                      "ssageSession:completion:]";
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
    }
    id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    (*((void (**)(id, id))v9 + 2))(v9, v25);

    if ((v19 & 1) == 0) {
      goto LABEL_26;
    }
  }
LABEL_27:
}

- (void)isAnyPlanOfTransferCapability:(unint64_t)a3 availableForThisDeviceWithCompletion:(id)a4
{
  id v6 = a4;
  if (v6)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    id v8 = ServiceMap;
    id v9 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      unsigned int v10 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        id v9 = (const char *)v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v22 = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v22);
    if (v13)
    {
      uint64_t v15 = v13[3];
      uint64_t v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v15)
        {
          uint64_t v18 = sub_1003DF94C(a3);
          id v19 = objc_retainBlock(v6);
          v23[0] = off_1019E19D0;
          v23[1] = v19;
          v23[3] = v23;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v15 + 488))(v15, v18, v23);
          sub_10023D374(v23);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v20 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) isAnyPlanOfTransferCapability:avai"
                                            "lableForThisDeviceWithCompletion:]";
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
          }
          id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v6 + 2))(v6, 0, v21);
        }
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v17 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler for transferPlan", (uint8_t *)&buf, 2u);
  }
LABEL_21:
}

- (void)isAnyPlanTransferableFromThisDeviceWithCompletion:(id)a3
{
  id v4 = (void (**)(id, uint64_t, void))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    id v19 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v19);
    if (v11)
    {
      uint64_t v13 = v11[3];
      unsigned int v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v13)
        {
          uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 496))(v13);
          v4[2](v4, v16, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v17 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) isAnyPlanTransferableFromThisDevic"
                                            "eWithCompletion:]";
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
          }
          id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          ((void (**)(id, uint64_t, id))v4)[2](v4, 0, v18);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    unsigned int v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for transferPlan", (uint8_t *)&buf, 2u);
  }
LABEL_21:
}

- (void)endPlanTransferForEndPoint:(unint64_t)a3 completion:(id)a4
{
  id v6 = (void (**)(id, void))a4;
  if (v6)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    id v8 = ServiceMap;
    uint64_t v9 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      unsigned int v10 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = (const char *)v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    id v21 = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v21);
    if (v13)
    {
      uint64_t v15 = v13[3];
      char v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v15)
        {
          if (a3 == 2) {
            uint64_t v18 = 2;
          }
          else {
            uint64_t v18 = a3 == 1;
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 504))(v15, v18);
          v6[2](v6, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v19 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) endPlanTransferForEndPoint:completion:]";
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for %s", (uint8_t *)&buf, 0xCu);
          }
          id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          ((void (**)(id, id))v6)[2](v6, v20);
        }
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    char v14 = 0;
    char v16 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v17 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler for endPlanTransferForEndPoint", (uint8_t *)&buf, 2u);
  }
LABEL_24:
}

- (void)updateSecureIntentData:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, id))a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  uint64_t v9 = ServiceMap;
  unsigned int v10 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unsigned int v10 = (const char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  id v23 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v23);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_9:
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (v16)
  {
    id v20 = v6;
    if (v6) {
      CFRetain(v6);
    }
    (*(void (**)(uint64_t, const void **))(*(void *)v16 + 512))(v16, &v20);
    sub_100030068(&v20);
    id v18 = 0;
    if (!v7) {
      goto LABEL_20;
    }
LABEL_19:
    v7[2](v7, v18);
    goto LABEL_20;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for setting externalized context", buf, 2u);
  }
  id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
  if (v7) {
    goto LABEL_19;
  }
LABEL_20:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

- (void)getRemoteDevicesForTransferWithCompletion:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)&buf[0]);
    id v6 = ServiceMap;
    id v7 = "31CellularPlanControllerInterface";
    if (((unint64_t)"31CellularPlanControllerInterface" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"31CellularPlanControllerInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    v19[0] = (unint64_t)v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, v19);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (*((void *)&buf[0] + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf[0] + 1));
        }
        if (v13)
        {
          [(CTXPCClientHandler *)self getQueue];
          id v16 = objc_retainBlock(v4);
          v19[0] = (unint64_t)off_1019E1A50;
          v19[1] = (unint64_t)v16;
          v19[3] = (unint64_t)v19;
          operator new();
        }
        [(CTXPCClientHandler *)self getLogContext];
        char v17 = *((void *)&buf[0] + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf[0]) = 136315138;
          *(void *)((char *)buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) getRemoteDevicesForTransferWithCompletion:]";
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface for %s", (uint8_t *)buf, 0xCu);
        }
        id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
        (*((void (**)(id, void, id))v4 + 2))(v4, 0, v18);

        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = *((void *)&buf[0] + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getRemoteDevicesForTransferWithCompletion", (uint8_t *)buf, 2u);
  }
LABEL_20:
}

- (void)getRemoteDeviceForTransferWithEID:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)&buf[0]);
    uint64_t v9 = ServiceMap;
    unsigned int v10 = "31CellularPlanControllerInterface";
    if (((unint64_t)"31CellularPlanControllerInterface" & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (unsigned __int8 *)((unint64_t)"31CellularPlanControllerInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unsigned int v10 = (const char *)v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    v23[0] = (unint64_t)v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, v23);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (*((void *)&buf[0] + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf[0] + 1));
        }
        if (v16)
        {
          long long v22 = 0uLL;
          *(void *)&buf[0] = v6;
          sub_100013168((const void **)&v22 + 1, (CFTypeRef *)buf);
          [(CTXPCClientHandler *)self getQueue];
          id v19 = objc_retainBlock(v7);
          v23[0] = (unint64_t)off_1019E1AE0;
          v23[1] = (unint64_t)v19;
          v23[3] = (unint64_t)v23;
          operator new();
        }
        [(CTXPCClientHandler *)self getLogContext];
        id v20 = *((void *)&buf[0] + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf[0]) = 136315138;
          *(void *)((char *)buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) getRemoteDeviceForTransferWithEID:completion:]";
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface for %s", (uint8_t *)buf, 0xCu);
        }
        id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
        (*((void (**)(id, void, id))v7 + 2))(v7, 0, v21);

        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v18 = *((void *)&buf[0] + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for getRemoteDeviceForTransferWithEID", (uint8_t *)buf, 2u);
  }
LABEL_20:
}

- (void)transferRemotePlan:(id)a3 fromDevice:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (v10)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    uint64_t v12 = ServiceMap;
    unsigned int v13 = "31CellularPlanControllerInterface";
    if (((unint64_t)"31CellularPlanControllerInterface" & 0x8000000000000000) != 0)
    {
      char v14 = (unsigned __int8 *)((unint64_t)"31CellularPlanControllerInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        unsigned int v13 = (const char *)v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    CFTypeRef cf = v13;
    char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&cf);
    if (v17)
    {
      uint64_t v19 = v17[3];
      id v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v19)
        {
          *(void *)&long long buf = 0;
          if (v9)
          {
            long long v22 = [v9 EID];
            CFTypeRef cf = v22;
            sub_100013168((const void **)&buf, &cf);
          }
          CFTypeRef cf = 0;
          if (v8)
          {
            id v23 = [v8 iccid];
            CFTypeRef v30 = v23;
            sub_100013168(&cf, &v30);
          }
          id v29 = (const void *)buf;
          if ((void)buf) {
            CFRetain((CFTypeRef)buf);
          }
          CFTypeRef v28 = cf;
          if (cf) {
            CFRetain(cf);
          }
          v26[0] = _NSConcreteStackBlock;
          v26[1] = 3221225472;
          void v26[2] = sub_100535B38;
          v26[3] = &unk_1019E0F20;
          id v27 = v10;
          (*(void (**)(uint64_t, const void **, CFTypeRef *, void *))(*(void *)v19 + 72))(v19, &v29, &v28, v26);
          sub_1000558F4(&v28);
          sub_1000558F4(&v29);

          sub_1000558F4(&cf);
          sub_1000558F4((const void **)&buf);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          BOOL v24 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) transferRemotePlan:fromDevice:completion:]";
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface for %s", (uint8_t *)&buf, 0xCu);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v10 + 2))(v10, 0, v25);
        }
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    id v18 = 0;
    char v20 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v21 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for transferRemotePlan", (uint8_t *)&buf, 2u);
  }
LABEL_29:
}

- (void)transferRemotePlan:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v8 = v6;
      id v9 = [v8 iccid];

      if (!v9)
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v23 = *((void *)&buf + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v8;
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Missing ICCID: %@", (uint8_t *)&buf, 0xCu);
        }
        id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
        (*((void (**)(id, void, void, id))v7 + 2))(v7, 0, 0, v24);

        goto LABEL_30;
      }
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
      uint64_t v11 = ServiceMap;
      uint64_t v12 = "31CellularPlanControllerInterface";
      if (((unint64_t)"31CellularPlanControllerInterface" & 0x8000000000000000) != 0)
      {
        unsigned int v13 = (unsigned __int8 *)((unint64_t)"31CellularPlanControllerInterface" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = (const char *)v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      CFTypeRef v30 = v12;
      unsigned int v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v30);
      if (v16)
      {
        uint64_t v18 = v16[3];
        char v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
LABEL_20:
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          if (v18)
          {
            id v25 = [v8 iccid];
            sub_100058DB0(__p, (char *)[v25 UTF8String]);
            id v26 = objc_retainBlock(v7);
            v31[0] = off_1019E1B70;
            v31[1] = v26;
            v31[3] = v31;
            (*(void (**)(uint64_t, void **, void *))(*(void *)v18 + 80))(v18, __p, v31);
            sub_10030C800(v31);
            if (v29 < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v27 = *((void *)&buf + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) transferRemotePlan:completion:]";
              _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface for %s", (uint8_t *)&buf, 0xCu);
            }
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
            (*((void (**)(id, void, void, id))v7 + 2))(v7, 0, 0, v25);
          }

          if ((v19 & 1) == 0) {
            sub_10004D2C8(v17);
          }
LABEL_30:

          goto LABEL_31;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      char v17 = 0;
      char v19 = 1;
      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v21 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid plan type: %@", (uint8_t *)&buf, 0xCu);
    }
    id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, void, id))v7 + 2))(v7, 0, 0, v22);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v20 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for transferRemotePlan", (uint8_t *)&buf, 2u);
    }
  }
LABEL_31:
}

- (void)getRemotePlanManageAccountInfoFor:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6 && [v6 length])
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p);
      id v9 = ServiceMap;
      id v10 = "31CellularPlanControllerInterface";
      if (((unint64_t)"31CellularPlanControllerInterface" & 0x8000000000000000) != 0)
      {
        uint64_t v11 = (unsigned __int8 *)((unint64_t)"31CellularPlanControllerInterface" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          id v10 = (const char *)v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      id v27 = v10;
      uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v27);
      if (v14)
      {
        uint64_t v16 = v14[3];
        unsigned int v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_17:
          if (v25) {
            sub_10004D2C8(v25);
          }
          if (v16)
          {
            sub_100058DB0(&__p, (char *)[v6 UTF8String]);
            id v21 = objc_retainBlock(v7);
            v28[0] = off_1019E1C00;
            v28[1] = v21;
            v28[3] = v28;
            (*(void (**)(uint64_t, void **, void *))(*(void *)v16 + 96))(v16, &__p, v28);
            sub_100544BC4(v28);
            if (v26 < 0) {
              operator delete(__p);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v22 = v25;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            {
              LOWORD(__p) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface", (uint8_t *)&__p, 2u);
            }
            id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
            (*((void (**)(id, void, void, id))v7 + 2))(v7, 0, 0, v23);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_27;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      unsigned int v15 = 0;
      char v17 = 1;
      goto LABEL_17;
    }
    id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    [(CTXPCClientHandler *)self getLogContext];
    char v19 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "No plan iccid in manage remote plan request", (uint8_t *)&__p, 2u);
    }
    (*((void (**)(id, void, void, id))v7 + 2))(v7, 0, 0, v18);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v20 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&__p, 2u);
    }
  }
LABEL_27:
}

- (void)remotePlanSignupInfoFor:(id)a3 userConsent:(int64_t)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a5;
  if (v9)
  {
    if (!v8)
    {
      id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      (*((void (**)(id, void, void, id))v9 + 2))(v9, 0, 0, v21);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    uint64_t v11 = ServiceMap;
    uint64_t v12 = "31CellularPlanControllerInterface";
    if (((unint64_t)"31CellularPlanControllerInterface" & 0x8000000000000000) != 0)
    {
      unsigned int v13 = (unsigned __int8 *)((unint64_t)"31CellularPlanControllerInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = (const char *)v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    id v27 = v12;
    uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v27);
    if (v16)
    {
      uint64_t v18 = v16[3];
      char v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
LABEL_14:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v18)
        {
          id v22 = [v8 slotID];
          if (v22 == (id)2) {
            uint64_t v23 = 2;
          }
          else {
            uint64_t v23 = v22 == (id)1;
          }
          id v24 = objc_retainBlock(v9);
          v28[0] = off_1019E1C90;
          v28[1] = v24;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, BOOL, void *))(*(void *)v18 + 88))(v18, v23, a4 == 1, v28);
          sub_100544BC4(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v25 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[CTXPCClientHandler(CellularPlanManager) remotePlanSignupInfoFor:userConsent:completion:]";
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface for %s", (uint8_t *)&buf, 0xCu);
          }
          id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, void, id))v9 + 2))(v9, 0, 0, v26);
        }
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    char v17 = 0;
    char v19 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v20 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&buf, 2u);
  }
LABEL_26:
}

- (void)getRemoteDevices:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v19);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    id v21 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v21);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v13)
        {
          uint64_t v16 = self;
          id v17 = objc_retainBlock(v4);
          v22[0] = off_1019E1D10;
          v22[1] = v16;
          v22[2] = v17;
          v22[3] = v22;
          (*(void (**)(uint64_t, void *))(*(void *)v13 + 88))(v13, v22);
          sub_100313790(v22);
        }
        else
        {
          uint64_t v18 = sub_1003DF5C4(17);
          (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v18);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v15 = v20;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v19) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&v19, 2u);
  }
LABEL_19:
}

- (void)getDeviceInfo:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v19);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    id v21 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v21);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v13)
        {
          uint64_t v16 = self;
          id v17 = objc_retainBlock(v4);
          v22[0] = off_1019E1D90;
          v22[1] = v16;
          v22[2] = v17;
          v22[3] = v22;
          (*(void (**)(uint64_t, void *))(*(void *)v13 + 624))(v13, v22);
          sub_10030D8B4(v22);
        }
        else
        {
          uint64_t v18 = sub_1003DF5C4(17);
          (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v18);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v15 = v20;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v19) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&v19, 2u);
  }
LABEL_19:
}

- (void)submitSimSetupUsage:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v20);
  uint64_t v9 = ServiceMap;
  unsigned int v10 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unsigned int v10 = (const char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  id v24 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v24);
  if (v14)
  {
    uint64_t v16 = v14[3];
    unsigned int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  unsigned int v15 = 0;
  char v17 = 1;
LABEL_9:
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v16)
  {
    LODWORD(v20) = 0;
    LOBYTE(v20) = objc_msgSend(v6, "inBuddy", v20);
    HIDWORD(v20) = objc_msgSend(v6, "transferablePlans", v20);
    LODWORD(v21) = [v6 selectedTransferablePlans];
    HIDWORD(v21) = [v6 alsPlans];
    unsigned int v22 = [v6 selectedAlsPlans];
    unsigned int v23 = [v6 odaPlans];
    (*(void (**)(uint64_t, Registry **))(*(void *)v16 + 776))(v16, &v20);
    uint64_t v18 = sub_1003DF5C4(0);
    v7[2](v7, v18);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v19 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface for submitting simsetup usage", (uint8_t *)&v20, 2u);
    }
    uint64_t v18 = sub_1003DF5C4(17);
    v7[2](v7, v18);
  }

  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

- (void)submitPlanSetupDetails:(id)a3 completion:(id)a4
{
  id v7 = a3;
  id v8 = (void (**)(id, void *))a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p[0]);
  unsigned int v10 = ServiceMap;
  uint64_t v11 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    uint64_t v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = (const char *)v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  CFTypeRef v28 = v11;
  unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v28);
  if (v15)
  {
    uint64_t v17 = v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      p_shared_owners = &v16->__shared_owners_;
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v16 = 0;
  char v18 = 1;
LABEL_9:
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  if (v17)
  {
    long long v26 = 0u;
    long long v27 = 0u;
    *(_OWORD *)long long __p = 0u;
    LOBYTE(__p[0]) = objc_msgSend(v7, "inBuddy", 0);
    char v19 = objc_msgSend(v7, "carrierName", __p[0]);
    id v20 = [v19 length];
    if (v20)
    {
      p_shared_owners = [v7 carrierName];
      id v21 = (char *)[p_shared_owners UTF8String];
    }
    else
    {
      id v21 = "";
    }
    sub_100058DB0(&__p[1], v21);
    LODWORD(v27) = [v7 setupType];
    DWORD1(v27) = [v7 setupResult];
    DWORD2(v27) = [v7 duration];
    if (v20) {

    }
    (*(void (**)(uint64_t, void **))(*(void *)v17 + 816))(v17, __p);
    id v24 = sub_1003DF5C4(0);
    v8[2](v8, v24);

    if (SHIBYTE(v26) < 0)
    {
      operator delete(__p[1]);
      if (v18) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
    if ((v18 & 1) == 0) {
LABEL_23:
    }
      sub_10004D2C8(v16);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v22 = __p[1];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)__p);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find CellularPlanControllerInterface for submitting plan setup details", (uint8_t *)__p, 2u);
    }
    unsigned int v23 = sub_1003DF5C4(17);
    v8[2](v8, v23);

    if ((v18 & 1) == 0) {
      goto LABEL_23;
    }
  }
LABEL_24:
}

- (void)getCarrierSetupWithCompletion:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v20);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unsigned int v22 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v22);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v13)
        {
          uint64_t v16 = self;
          id v17 = objc_retainBlock(v4);
          v23[0] = off_1019E1E20;
          v23[1] = v16;
          v23[2] = v17;
          v23[3] = v23;
          (*(void (**)(uint64_t, void *))(*(void *)v13 + 200))(v13, v23);
          sub_100033230(v23);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v18 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v20) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)&v20, 2u);
          }
          id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v4 + 2))(v4, 0, v19);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v15 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v20) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&v20, 2u);
  }
LABEL_21:
}

- (void)websheetInfoForPlan:(id)a3 completion:(id)a4
{
  id v9 = a3;
  id v10 = a4;
  uint64_t v11 = (void (**)(void, void, void, void, void))v10;
  v146 = v9;
  if (v10)
  {
    v145 = (void (**)(id, void *, void *, const __CFString *, void))v10;
    if (v9)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      uint64_t v13 = ServiceMap;
      char v14 = "22CellularPlanController";
      if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
      {
        unsigned int v15 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v16 = 5381;
        do
        {
          char v14 = (const char *)v16;
          unsigned int v17 = *v15++;
          uint64_t v16 = (33 * v16) ^ v17;
        }
        while (v17);
      }
      std::mutex::lock(ServiceMap);
      v180.__r_.__value_.__r.__words[0] = (std::string::size_type)v14;
      char v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&v180);
      if (v18)
      {
        uint64_t v5 = v18[4];
        uint64_t v144 = v18[3];
        if (v5)
        {
          uint64_t p_shared_owners = 1;
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
          std::mutex::unlock(v13);
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
          v142 = (std::__shared_weak_count *)v5;
          sub_10004D2C8((std::__shared_weak_count *)v5);
          int v143 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        uint64_t v144 = 0;
      }
      std::mutex::unlock(v13);
      v142 = 0;
      int v143 = 1;
LABEL_16:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (!v144)
      {
        [(CTXPCClientHandler *)self getLogContext];
        CFTypeRef v28 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
        }
        id v29 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
        ((void (**)(void, void, void, void, id))v11)[2](v11, 0, 0, 0, v29);

        goto LABEL_201;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v22 = v146;
        v207[0] = @"handoffToken";
        unsigned int v23 = [v22 handoffToken];
        v207[1] = @"isInBuddy";
        v208[0] = v23;
        unsigned int v24 = [v22 inBuddy];
        id v25 = &__kCFBooleanFalse;
        if (v24) {
          id v25 = &__kCFBooleanTrue;
        }
        v208[1] = v25;
        long long v26 = +[NSDictionary dictionaryWithObjects:v208 forKeys:v207 count:2];

        long long v27 = [v22 setupURL];
        v145[2](v145, v27, v26, @"buddyml", 0);

LABEL_201:
        uint64_t v11 = (void (**)(void, void, void, void, void))v145;
        if ((v143 & 1) == 0) {
          sub_10004D2C8(v142);
        }
        goto LABEL_203;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v30 = v146;
        id v31 = [v30 iccid];
        sub_100058DB0(buf, (char *)[v31 UTF8String]);
        char v32 = self;
        v186 = v32;
        uint64_t v187 = v144;
        v188 = v142;
        if ((v143 & 1) == 0) {
          atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        BOOL v33 = objc_retainBlock(v145);
        id v189 = v33;
        v206 = 0;
        id v34 = operator new(0x28uLL);
        void *v34 = off_1019E1EA0;
        v34[1] = v32;
        v188 = 0;
        id v189 = 0;
        uint64_t v187 = 0;
        void v34[2] = v144;
        void v34[3] = v142;
        void v34[4] = v33;
        v206 = v34;
        (*(void (**)(void))(*(void *)v144 + 312))();
        sub_10030C800(v205);

        if (v188) {
          sub_10004D2C8(v188);
        }

        if (SBYTE7(v193) < 0) {
          operator delete(*(void **)buf);
        }

        goto LABEL_201;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v37 = v146;
          memset(&v180, 0, sizeof(v180));
          uint64_t v38 = [v37 planID];
          uint64_t v39 = [v38 carrierName];
          BOOL v40 = [v39 length] == 0;

          if (!v40)
          {
            uint64_t v41 = [v37 planID];
            id v42 = [v41 carrierName];
            sub_10003ED78(&v180, (char *)[v42 UTF8String]);
          }
          memset(v201, 0, sizeof(v201));
          memset(v200, 0, sizeof(v200));
          memset(v199, 0, sizeof(v199));
          long long v198 = 0u;
          *(_OWORD *)v196 = 0u;
          memset(__p, 0, sizeof(__p));
          memset(v195, 0, sizeof(v195));
          long long v193 = 0u;
          *(_OWORD *)v194 = 0u;
          *(_OWORD *)long long buf = 0u;
          char v43 = [v37 planID];
          uint64_t v44 = [v43 iccid];
          BOOL v45 = [v44 length] == 0;

          if (!v45)
          {
            id v46 = [v37 planID];
            id v47 = [v46 iccid];
            sub_10003ED78((std::string *)buf, (char *)[v47 UTF8String]);
          }
          id v48 = [v37 planID];
          long long v49 = [v48 mcc];
          BOOL v50 = [v49 length] == 0;

          if (!v50)
          {
            long long v51 = [v37 planID];
            id v52 = [v51 mcc];
            sub_10003ED78((std::string *)__p, (char *)[v52 UTF8String]);
          }
          id v53 = [v37 planID];
          id v54 = [v53 mnc];
          BOOL v55 = [v54 length] == 0;

          if (!v55)
          {
            long long v56 = [v37 planID];
            id v57 = [v56 mnc];
            sub_10003ED78((std::string *)&__p[24], (char *)[v57 UTF8String]);
          }
          long long v58 = [v37 planID];
          long long v59 = [v58 gid1];
          BOOL v60 = [v59 length] == 0;

          if (!v60)
          {
            int64x2_t v61 = [v37 planID];
            id v62 = [v61 gid1];
            sub_10003ED78((std::string *)v199, (char *)[v62 UTF8String]);
          }
          long long v63 = [v37 planID];
          long long v64 = [v63 gid2];
          BOOL v65 = [v64 length] == 0;

          if (!v65)
          {
            long long v66 = [v37 planID];
            id v67 = [v66 gid2];
            sub_10003ED78((std::string *)&v199[24], (char *)[v67 UTF8String]);
          }
          long long v68 = [v37 planID];
          long long v69 = [v68 phoneNumber];
          BOOL v70 = [v69 length] == 0;

          if (!v70)
          {
            long long v71 = [v37 planID];
            id v72 = [v71 phoneNumber];
            sub_10003ED78((std::string *)&v195[24], (char *)[v72 UTF8String]);
          }
          if ([v37 addOnCarrierFlowType] == (id)1)
          {
            long long v73 = [v37 signUpDetails];
            long long v74 = [v73 signUpUrl];
            BOOL v75 = [v74 length] == 0;

            if (!v75)
            {
              long long v76 = [v37 signUpDetails];
              id v77 = [v76 signUpUrl];
              *(void *)v177 = [v77 UTF8String];
              sub_1000791C0((std::string *)v200, (char **)v177);
            }
            long long v78 = [v37 signUpDetails];
            long long v79 = [v78 signUpUrlType];
            BOOL v80 = [v79 length] == 0;

            if (!v80)
            {
              uint64_t v81 = [v37 signUpDetails];
              id v82 = [v81 signUpUrlType];
              *(void *)v177 = [v82 UTF8String];
              sub_1000791C0((std::string *)v201, (char **)v177);
            }
          }
          id v83 = [v37 addOnCarrierFlowType];
          if (v83 == (id)2)
          {
            long long v99 = self;
            xpc_object_t v100 = objc_retainBlock(v145);
            sub_10053994C(v190, v99, (uint64_t)v100);
            (*(void (**)(uint64_t, uint8_t *, std::string *, void *))(*(void *)v144 + 320))(v144, buf, &v180, v190);
            sub_10030CC88(v190);
          }
          else if (v83 == (id)1)
          {
            uint64_t v155 = v144;
            v156 = v142;
            if (v143)
            {
              xpc_object_t v84 = self;
              uint64_t v150 = v144;
              v151 = v142;
            }
            else
            {
              atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
              xpc_object_t v102 = self;
              uint64_t v150 = v144;
              v151 = v142;
              atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v149 = self;
            sub_10030C884(v152, (long long *)buf);
            if (SHIBYTE(v180.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v153, v180.__r_.__value_.__l.__data_, v180.__r_.__value_.__l.__size_);
            }
            else {
              std::string v153 = v180;
            }
            v154 = objc_retainBlock(v145);
            sub_100539728((uint64_t)v191, (uint64_t)&v149);
            [(CTXPCClientHandler *)self handoffTokenWithController:&v155 completion:v191];
            sub_100545F18(v191);
            sub_1005398F4((uint64_t)&v149);
            if (v156) {
              sub_10004D2C8(v156);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            xpc_object_t v101 = v178;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v177);
            if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)v177 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_ERROR, "Unknown flow type, defaulting to basic flow", v177, 2u);
            }
          }
          sub_10030CBA4((uint64_t)buf);
          if (SHIBYTE(v180.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v180.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          xpc_object_t v94 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v146;
            _os_log_error_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "Unsupported plan: %@", buf, 0xCu);
          }
          id v95 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
          ((void (**)(void, void, void, void, id))v11)[2](v11, 0, 0, 0, v95);
        }
        goto LABEL_201;
      }
      id v141 = v146;
      if ([v141 option] == (id)2
        && ((*(uint64_t (**)(uint64_t))(*(void *)v144 + 976))(v144) & 1) == 0
        && (*(unsigned int (**)(uint64_t))(*(void *)v144 + 952))(v144))
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v35 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Plan purchase is not allowed over bootstrap!", buf, 2u);
        }
        unint64_t v36 = sub_1003DF5C4(67);
        ((void (**)(void, void, void, void, void *))v11)[2](v11, 0, 0, 0, v36);

        goto LABEL_201;
      }
      [(CTXPCClientHandler *)self registry];
      long long v85 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
      uint64_t v86 = v85;
      if ((v87 & 0x8000000000000000) != 0)
      {
        long long v88 = (unsigned __int8 *)(v87 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v89 = 5381;
        do
        {
          std::string::size_type v87 = v89;
          unsigned int v90 = *v88++;
          uint64_t v89 = (33 * v89) ^ v90;
        }
        while (v90);
      }
      std::mutex::lock(v85);
      v180.__r_.__value_.__r.__words[0] = v87;
      xpc_object_t v91 = sub_10004D37C(&v86[1].__m_.__sig, (unint64_t *)&v180);
      if (v91)
      {
        uint64_t v92 = v91[3];
        unint64_t v93 = (std::__shared_weak_count *)v91[4];
        if (v93)
        {
          uint64_t p_shared_owners = (uint64_t)&v93->__shared_owners_;
          uint64_t v5 = 1;
          atomic_fetch_add_explicit(&v93->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v86);
          atomic_fetch_add_explicit(&v93->__shared_owners_, 1uLL, memory_order_relaxed);
          v137 = v93;
          sub_10004D2C8(v93);
          char v140 = 0;
          goto LABEL_76;
        }
      }
      else
      {
        uint64_t v92 = 0;
      }
      std::mutex::unlock(v86);
      v137 = 0;
      char v140 = 1;
LABEL_76:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (!v92) {
        goto LABEL_106;
      }
      v180.__r_.__value_.__r.__words[0] = 0;
      xpc_object_t v96 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v97 = v96;
      if (v96)
      {
        v180.__r_.__value_.__r.__words[0] = (std::string::size_type)v96;
      }
      else
      {
        xpc_object_t v97 = xpc_null_create();
        v180.__r_.__value_.__r.__words[0] = (std::string::size_type)v97;
        if (!v97)
        {
          xpc_object_t v98 = xpc_null_create();
          xpc_object_t v97 = 0;
          goto LABEL_92;
        }
      }
      if (xpc_get_type(v97) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v97);
LABEL_93:
        xpc_release(v97);
        v103 = objc_msgSend(v141, "name", v137);
        if (v103)
        {
          uint64_t p_shared_owners = [v141 name];
          xpc_object_t v104 = (const char *)[(id)p_shared_owners UTF8String];
        }
        else
        {
          xpc_object_t v104 = "";
        }
        xpc_object_t v184 = xpc_string_create(v104);
        if (!v184) {
          xpc_object_t v184 = xpc_null_create();
        }
        *(void *)long long buf = &v180;
        *(void *)&uint8_t buf[8] = "carrier_name";
        sub_100035E70((uint64_t)buf, &v184, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v184);
        xpc_object_t v184 = 0;
        if (v103) {

        }
        CFStringRef v105 = [v141 type];
        if ([v105 isEqualToString:@"Lite"]) {
          v106 = "Jasmine";
        }
        else {
          v106 = "Sequoia";
        }
        xpc_object_t v182 = xpc_string_create(v106);
        if (!v182) {
          xpc_object_t v182 = xpc_null_create();
        }
        *(void *)long long buf = &v180;
        *(void *)&uint8_t buf[8] = "plan_type";
        sub_100035E70((uint64_t)buf, &v182, &v183);
        xpc_release(v183);
        xpc_object_t v183 = 0;
        xpc_release(v182);
        xpc_object_t v182 = 0;

        sub_100117418(&v181, (void **)&v180.__r_.__value_.__l.__data_);
        (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v92 + 16))(v92, "commCenterCarrierItemSelection", &v181);
        xpc_release(v181);
        xpc_object_t v181 = 0;
        xpc_release(v180.__r_.__value_.__l.__data_);
LABEL_106:
        uint64_t v107 = objc_msgSend(v141, "type", v137);
        unsigned int v108 = [v107 isEqualToString:@"Lite"];

        if (v108)
        {
          id v109 = NSURL;
          v110 = [v141 url];
          v139 = +[NSURL URLWithString:v110];

          memset(&v180, 0, sizeof(v180));
          id v111 = [v139 host];
          if (v111)
          {
            id v109 = [v139 host];
            v112 = (char *)[v109 UTF8String];
          }
          else
          {
            v112 = "";
          }
          sub_100058DB0(&v180, v112);
          if (v111) {

          }
          v178 = 0;
          *(void *)v177 = 0;
          uint64_t v179 = 0;
          [v141 identifiers];
          long long v175 = 0u;
          long long v176 = 0u;
          long long v173 = 0u;
          long long v174 = 0u;
          id obj = (id)objc_claimAutoreleasedReturnValue();
          id v118 = [obj countByEnumeratingWithState:&v173 objects:v204 count:16];
          if (v118)
          {
            id v119 = v118;
            uint64_t v148 = *(void *)v174;
            do
            {
              for (uint64_t i = 0; i != v119; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v174 != v148) {
                  objc_enumerationMutation(obj);
                }
                v121 = *(void **)(*((void *)&v173 + 1) + 8 * i);
                long long v171 = 0uLL;
                uint64_t v172 = 0;
                v122 = [v121 mcc];
                if (v122)
                {
                  uint64_t p_shared_owners = [v121 mcc];
                  v123 = (char *)[(id)p_shared_owners UTF8String];
                }
                else
                {
                  v123 = "";
                }
                sub_100058DB0(&v171, v123);
                if (v122) {

                }
                v169[1] = 0;
                v169[0] = 0;
                uint64_t v170 = 0;
                v124 = [v121 mnc];
                if (v124)
                {
                  uint64_t v5 = [v121 mnc];
                  v125 = (char *)[(id)v5 UTF8String];
                }
                else
                {
                  v125 = "";
                }
                sub_100058DB0(v169, v125);
                if (v124) {

                }
                long long v167 = 0uLL;
                uint64_t v168 = 0;
                v126 = [v121 gid1];
                if (v126)
                {
                  id v111 = [v121 gid1];
                  v127 = (char *)[v111 UTF8String];
                }
                else
                {
                  v127 = "";
                }
                sub_100058DB0(&v167, v127);
                if (v126) {

                }
                v165[1] = 0;
                v165[0] = 0;
                uint64_t v166 = 0;
                v128 = [v121 gid2];
                if (v128)
                {
                  id v109 = [v121 gid2];
                  v129 = (char *)[v109 UTF8String];
                }
                else
                {
                  v129 = "";
                }
                sub_100058DB0(v165, v129);
                if (v128) {

                }
                long long __src = 0uLL;
                uint64_t v164 = 0;
                v130 = [v121 iccid];
                if (v130)
                {
                  id v6 = [v121 iccid];
                  v131 = (char *)[v6 UTF8String];
                }
                else
                {
                  v131 = "";
                }
                sub_100058DB0(&__src, v131);
                if (v130) {

                }
                memset(__p, 0, sizeof(__p));
                *(_OWORD *)v196 = 0u;
                *(_OWORD *)v194 = 0u;
                memset(v195, 0, sizeof(v195));
                *(_OWORD *)long long buf = 0u;
                long long v193 = 0u;
                if (SHIBYTE(v164) < 0)
                {
                  sub_10004FC84(buf, (void *)__src, *((unint64_t *)&__src + 1));
                }
                else
                {
                  *(_OWORD *)long long buf = __src;
                  *(void *)&long long v193 = v164;
                }
                BYTE8(v193) = 1;
                if (SHIBYTE(v172) < 0)
                {
                  sub_10004FC84(v194, (void *)v171, *((unint64_t *)&v171 + 1));
                }
                else
                {
                  *(_OWORD *)v194 = v171;
                  *(void *)v195 = v172;
                }
                if (SHIBYTE(v170) < 0)
                {
                  sub_10004FC84(&v195[8], v169[0], (unint64_t)v169[1]);
                }
                else
                {
                  *(_OWORD *)&v195[8] = *(_OWORD *)v169;
                  *(void *)&v195[24] = v170;
                }
                if (SHIBYTE(v168) < 0)
                {
                  sub_10004FC84(v196, (void *)v167, *((unint64_t *)&v167 + 1));
                }
                else
                {
                  *(_OWORD *)v196 = v167;
                  *(void *)long long __p = v168;
                }
                if (SHIBYTE(v166) < 0)
                {
                  sub_10004FC84(&__p[8], v165[0], (unint64_t)v165[1]);
                }
                else
                {
                  *(_OWORD *)&__p[8] = *(_OWORD *)v165;
                  *(void *)&__p[24] = v166;
                }
                sub_1005395D0((uint64_t *)v177, (uint64_t)buf);
                if ((__p[31] & 0x80000000) != 0) {
                  operator delete(*(void **)&__p[8]);
                }
                if ((__p[7] & 0x80000000) != 0) {
                  operator delete(v196[0]);
                }
                if ((v195[31] & 0x80000000) != 0) {
                  operator delete(*(void **)&v195[8]);
                }
                if ((v195[7] & 0x80000000) != 0) {
                  operator delete(v194[0]);
                }
                if (BYTE8(v193) && SBYTE7(v193) < 0) {
                  operator delete(*(void **)buf);
                }
                if (SHIBYTE(v164) < 0) {
                  operator delete((void *)__src);
                }
                if (SHIBYTE(v166) < 0) {
                  operator delete(v165[0]);
                }
                if (SHIBYTE(v168) < 0) {
                  operator delete((void *)v167);
                }
                if (SHIBYTE(v170) < 0) {
                  operator delete(v169[0]);
                }
                if (SHIBYTE(v172) < 0) {
                  operator delete((void *)v171);
                }
              }
              id v119 = [obj countByEnumeratingWithState:&v173 objects:v204 count:16];
            }
            while (v119);
          }

          v132 = [v141 name];
          BOOL v133 = v132 == 0;

          if (!v133)
          {
            id v134 = [v141 name];
            sub_100058DB0(buf, (char *)[v134 UTF8String]);
            (*(void (**)(uint64_t, uint8_t *, uint8_t *, std::string *))(*(void *)v144 + 408))(v144, buf, v177, &v180);
            if (SBYTE7(v193) < 0) {
              operator delete(*(void **)buf);
            }
          }
          v135 = [v141 url];
          v136 = [v141 type];
          v145[2](v145, v135, 0, v136, 0);

          *(void *)long long buf = v177;
          sub_10030B640((void ***)buf);
          if (SHIBYTE(v180.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v180.__r_.__value_.__l.__data_);
          }

          v117 = v141;
        }
        else
        {
          uint64_t v161 = v144;
          v162 = v142;
          if (v143)
          {
            v158 = v142;
          }
          else
          {
            atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
            v158 = v142;
            atomic_fetch_add_explicit(&v142->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          id v113 = v141;
          v114 = objc_retainBlock(v145);
          v203 = 0;
          v115 = operator new(0x28uLL);
          void *v115 = off_1019E1FB0;
          v115[1] = v144;
          v116 = v158;
          uint64_t v157 = 0;
          v158 = 0;
          uint64_t v159 = 0;
          uint64_t v160 = 0;
          v115[2] = v116;
          v115[3] = v113;
          v115[4] = v114;
          v203 = v115;
          [(CTXPCClientHandler *)self handoffTokenWithController:&v161 completion:v202];
          sub_100545F18(v202);
          sub_1005396E8((uint64_t)&v157);
          v117 = v141;
          if (v162) {
            sub_10004D2C8(v162);
          }
        }
        if ((v140 & 1) == 0) {
          sub_10004D2C8(v138);
        }

        goto LABEL_201;
      }
      xpc_object_t v98 = xpc_null_create();
LABEL_92:
      v180.__r_.__value_.__r.__words[0] = (std::string::size_type)v98;
      goto LABEL_93;
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v20 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "No plan", buf, 2u);
    }
    id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void, void, void, id))v11)[2](v11, 0, 0, 0, v21);

    uint64_t v11 = (void (**)(void, void, void, void, void))v145;
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
    }
  }
LABEL_203:
}

- (void)userDidExitWebsheetFlowForPlan:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (Block_layout *)a4;
  if (v7) {
    id v8 = v7;
  }
  else {
    id v8 = &stru_1019E0F40;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    id v10 = ServiceMap;
    uint64_t v11 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = (const char *)v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    id v29 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v29);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_16:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v17)
        {
          id v21 = v6;
          id v22 = [v21 type];
          unsigned __int8 v23 = [v22 isEqualToString:@"Lite"];

          if (v23)
          {
            (*(void (**)(uint64_t))(*(void *)v17 + 416))(v17);
            v8->invoke(v8, 0);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v25 = *((void *)&buf + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              CFTypeRef v28 = [v21 type];
              LODWORD(buf) = 138412290;
              *(void *)((char *)&buf + 4) = v28;
              _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "unsupported plan type : %@", (uint8_t *)&buf, 0xCu);
            }
            id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v8->invoke(v8, v26);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unsigned int v24 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)&buf, 2u);
          }
          id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v8->invoke(v8, v21);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_16;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    uint64_t v27 = objc_opt_class();
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v27;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "unsupported plan class : %@", (uint8_t *)&buf, 0xCu);
  }
  id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  v8->invoke(v8, v20);

LABEL_29:
}

- (void)handoffTokenWithController:(shared_ptr<CellularPlanController>)a3 completion:(function<void (NSDictionary<NSString *)
{
  var1 = a3.var1;
  uint64_t v5 = *(void *)a3.var0;
  id v7 = self;
  sub_1005483CC((uint64_t)v8, (uint64_t)var1);
  id v10 = 0;
  id v6 = operator new(0x30uLL);
  void *v6 = off_1019E2250;
  v6[1] = v7;
  sub_1005488D4((uint64_t)(v6 + 2), (uint64_t)v8);
  id v10 = v6;
  (*(void (**)(uint64_t, void *))(*(void *)v5 + 608))(v5, v9);
  sub_10030D088(v9);
  sub_100545F18(v8);
}

- (void)encryptDataWithCarrierIdentifiers:(id)a3 mnc:(id)a4 gid1:(id)a5 gid2:(id)a6 data:(id)a7 completion:(id)a8
{
  id v14 = a3;
  id v15 = a4;
  id v16 = a5;
  id v17 = a6;
  id v18 = a7;
  id v19 = a8;
  if (v19)
  {
    if ([v18 length] && objc_msgSend(v14, "length") && objc_msgSend(v15, "length"))
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v57 = 0;
      sub_100058DB0(buf, (char *)[v14 UTF8String]);
      long long v54 = 0uLL;
      uint64_t v55 = 0;
      sub_100058DB0(&v54, (char *)[v15 UTF8String]);
      memset(&v53, 0, sizeof(v53));
      memset(&v52, 0, sizeof(v52));
      if ([v16 length]) {
        sub_10003ED78(&v53, (char *)[v16 UTF8String]);
      }
      if ([v17 length]) {
        sub_10003ED78(&v52, (char *)[v17 UTF8String]);
      }
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)v50);
      id v21 = ServiceMap;
      id v22 = "22CellularPlanController";
      if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
      {
        unsigned __int8 v23 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v24 = 5381;
        do
        {
          id v22 = (const char *)v24;
          unsigned int v25 = *v23++;
          uint64_t v24 = (33 * v24) ^ v25;
        }
        while (v25);
      }
      std::mutex::lock(ServiceMap);
      long long v58 = v22;
      id v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)&v58);
      if (v26)
      {
        id v27 = v16;
        id v28 = v19;
        uint64_t v29 = v26[3];
        id v30 = (std::__shared_weak_count *)v26[4];
        if (v30)
        {
          BOOL v40 = v27;
          atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v21);
          atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v41 = v30;
          sub_10004D2C8(v30);
          char v31 = 0;
          uint64_t v32 = v29;
          id v19 = v28;
          id v16 = v40;
LABEL_23:
          if (v51) {
            sub_10004D2C8(v51);
          }
          if (v32)
          {
            sub_100058DB0(v48, (char *)[v18 UTF8String]);
            if (SHIBYTE(v57) < 0)
            {
              sub_10004FC84(__dst, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              *(_OWORD *)__dst = *(_OWORD *)buf;
              uint64_t v47 = v57;
            }
            if (SHIBYTE(v55) < 0)
            {
              sub_10004FC84(v44, (void *)v54, *((unint64_t *)&v54 + 1));
            }
            else
            {
              *(_OWORD *)uint64_t v44 = v54;
              uint64_t v45 = v55;
            }
            if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v43, v53.__r_.__value_.__l.__data_, v53.__r_.__value_.__l.__size_);
            }
            else {
              std::string v43 = v53;
            }
            if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&__p, v52.__r_.__value_.__l.__data_, v52.__r_.__value_.__l.__size_);
            }
            else {
              std::string __p = v52;
            }
            uint64_t v38 = self;
            id v39 = objc_retainBlock(v19);
            v59[0] = off_1019E22E0;
            v59[1] = v38;
            v59[2] = v39;
            v59[3] = v59;
            (*(void (**)(uint64_t, void **, void **, void **, std::string *, std::string *, void *))(*(void *)v32 + 208))(v32, v48, __dst, v44, &v43, &__p, v59);
            sub_10030D938(v59);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v43.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v45) < 0) {
              operator delete(v44[0]);
            }
            if (SHIBYTE(v47) < 0) {
              operator delete(__dst[0]);
            }
            if (v49 < 0) {
              operator delete(v48[0]);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            unint64_t v36 = v51;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v50);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)BOOL v50 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", v50, 2u);
            }
            id v37 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
            (*((void (**)(id, void, id))v19 + 2))(v19, 0, v37);
          }
          if ((v31 & 1) == 0) {
            sub_10004D2C8(v41);
          }
          if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v52.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v53.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v55) < 0) {
            operator delete((void *)v54);
          }
          if (SHIBYTE(v57) < 0) {
            operator delete(*(void **)buf);
          }
          goto LABEL_61;
        }
        uint64_t v32 = v26[3];
        id v19 = v28;
        id v16 = v27;
      }
      else
      {
        uint64_t v32 = 0;
      }
      std::mutex::unlock(v21);
      uint64_t v41 = 0;
      char v31 = 1;
      goto LABEL_23;
    }
    [(CTXPCClientHandler *)self getLogContext];
    BOOL v33 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Invalid Input/MCC/MNC", buf, 2u);
    }
    id v34 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, id))v19 + 2))(v19, 0, v34);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v35 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
    }
  }
LABEL_61:
}

- (void)getProximityTransportSession:(unint64_t)a3 remoteDeviceInfo:(id)a4 completion:(id)a5
{
  id v8 = (char *)a4;
  id v9 = a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v20 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "invalid completion handler", buf, 2u);
    }
    goto LABEL_25;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  uint64_t v11 = ServiceMap;
  uint64_t v12 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    uint64_t v13 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = (const char *)v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  id v28 = v12;
  id v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v28);
  if (!v16)
  {
    uint64_t v18 = 0;
    goto LABEL_11;
  }
  uint64_t v18 = v16[3];
  id v17 = (std::__shared_weak_count *)v16[4];
  if (!v17)
  {
LABEL_11:
    std::mutex::unlock(v11);
    id v17 = 0;
    char v19 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
LABEL_12:
  if (v27) {
    sub_10004D2C8((std::__shared_weak_count *)v27);
  }
  if (v18)
  {
    *(void *)long long buf = 0;
    if (v8)
    {
      id v28 = v8;
      sub_100282490((const void **)buf, (CFTypeRef *)&v28);
      if (a3 == 2) {
        uint64_t v21 = 2;
      }
      else {
        uint64_t v21 = a3 == 1;
      }
      unsigned int v25 = *(Registry **)buf;
      if (*(void *)buf) {
        CFRetain(*(CFTypeRef *)buf);
      }
    }
    else
    {
      if (a3 == 2) {
        uint64_t v21 = 2;
      }
      else {
        uint64_t v21 = a3 == 1;
      }
      unsigned int v25 = 0;
    }
    id v24 = objc_retainBlock(v9);
    v29[0] = off_1019E2370;
    v29[1] = v24;
    void v29[3] = v29;
    (*(void (**)(uint64_t, uint64_t, Registry **, void *))(*(void *)v18 + 424))(v18, v21, &v25, v29);
    sub_10030CFC0(v29);
    sub_100057D78((const void **)&v25);
    sub_100057D78((const void **)buf);
    if (v19) {
      goto LABEL_25;
    }
LABEL_24:
    sub_10004D2C8(v17);
    goto LABEL_25;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v22 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
  }
  id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
  (*((void (**)(id, void, id))v9 + 2))(v9, 0, v23);

  if ((v19 & 1) == 0) {
    goto LABEL_24;
  }
LABEL_25:
}

- (void)activateProximityTransfer:(unint64_t)a3 completion:(id)a4
{
  id v6 = a4;
  if (v6)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v22);
    id v8 = ServiceMap;
    id v9 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v10 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        id v9 = (const char *)v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    id v24 = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v24);
    if (v13)
    {
      uint64_t v15 = v13[3];
      uint64_t v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_12:
        if (v23) {
          sub_10004D2C8(v23);
        }
        if (v15)
        {
          if (a3 == 2) {
            uint64_t v18 = 2;
          }
          else {
            uint64_t v18 = a3 == 1;
          }
          id v19 = objc_retainBlock(v6);
          v25[0] = off_1019E2400;
          v25[1] = v19;
          v25[3] = v25;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v15 + 432))(v15, v18, v25);
          sub_100313668(v25);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v20 = v23;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v22) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)&v22, 2u);
          }
          id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, id))v6 + 2))(v6, v21);
        }
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v17 = v23;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(v22) = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "invalid completion handler", (uint8_t *)&v22, 2u);
  }
LABEL_24:
}

- (void)invalidateProximityTransfer:(unint64_t)a3 force:(BOOL)a4 completion:(id)a5
{
  BOOL v5 = a4;
  id v8 = a5;
  if (v8)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
    id v10 = ServiceMap;
    uint64_t v11 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      unsigned int v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = (const char *)v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    id v26 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v26);
    if (v15)
    {
      uint64_t v17 = v15[3];
      char v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v25) {
          sub_10004D2C8(v25);
        }
        if (v17)
        {
          if (a3 == 2) {
            uint64_t v20 = 2;
          }
          else {
            uint64_t v20 = a3 == 1;
          }
          id v21 = objc_retainBlock(v8);
          v27[0] = off_1019E2480;
          v27[1] = v21;
          v27[3] = v27;
          (*(void (**)(uint64_t, uint64_t, BOOL, void *))(*(void *)v17 + 440))(v17, v20, v5, v27);
          sub_100313668(v27);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v22 = v25;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v24) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)&v24, 2u);
          }
          id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, id))v8 + 2))(v8, v23);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    char v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(v24) = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "invalid completion handler", (uint8_t *)&v24, 2u);
  }
LABEL_24:
}

- (void)validateProximityTransfer:(unint64_t)a3 pin:(id)a4 completion:(id)a5
{
  id v8 = a4;
  id v9 = a5;
  if (v9)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v11 = ServiceMap;
    unsigned int v12 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v13 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        unsigned int v12 = (const char *)v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    id v30 = v12;
    char v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v30);
    if (v16)
    {
      uint64_t v18 = v16[3];
      uint64_t v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
LABEL_12:
        if (v29) {
          sub_10004D2C8(v29);
        }
        if (v18)
        {
          if ([v8 length])
          {
            if (a3 == 2) {
              uint64_t v21 = 2;
            }
            else {
              uint64_t v21 = a3 == 1;
            }
            sub_100058DB0(__p, (char *)[v8 UTF8String]);
            id v22 = objc_retainBlock(v9);
            v31[0] = off_1019E2500;
            v31[1] = v22;
            v31[3] = v31;
            (*(void (**)(uint64_t, uint64_t, void **, void *))(*(void *)v18 + 448))(v18, v21, __p, v31);
            sub_100313668(v31);
            if (v27 < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            unsigned int v25 = sub_1003DF5C4(6);
            (*((void (**)(id, void *))v9 + 2))(v9, v25);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v29;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, id))v9 + 2))(v9, v24);
        }
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    uint64_t v17 = 0;
    char v19 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v20 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "invalid completion handler", buf, 2u);
  }
LABEL_27:
}

- (void)resetProximityTransportExtension:(id)a3
{
  id v4 = (Block_layout *)a3;
  if (v4) {
    BOOL v5 = v4;
  }
  else {
    BOOL v5 = &stru_1019E0F60;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v18);
  id v7 = ServiceMap;
  id v8 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v9 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      id v8 = (const char *)v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v20 = v8;
  unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v20);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_12:
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 464))(v14);
    v5->invoke(v5, 0);
    if ((v15 & 1) == 0) {
      sub_10004D2C8(v13);
    }
  }
  else
  {
    if ((v15 & 1) == 0) {
      sub_10004D2C8(v13);
    }
    [(CTXPCClientHandler *)self getLogContext];
    char v16 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v18) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)&v18, 2u);
    }
    id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v5->invoke(v5, v17);
  }
}

- (void)prepareCrossPlatformPlanTransfer:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v34[1];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v34);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v34[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "invalid completion handler", (uint8_t *)v34, 2u);
    }
    goto LABEL_61;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v34[0]);
  id v9 = ServiceMap;
  uint64_t v10 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    unsigned int v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = (const char *)v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  std::string v43 = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v43);
  if (!v14)
  {
    uint64_t v16 = 0;
    goto LABEL_11;
  }
  uint64_t v16 = v14[3];
  char v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
LABEL_11:
    std::mutex::unlock(v9);
    char v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
LABEL_12:
  if (v34[1]) {
    sub_10004D2C8((std::__shared_weak_count *)v34[1]);
  }
  if (v16)
  {
    *(_OWORD *)std::string __p = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    *(_OWORD *)BOOL v40 = 0u;
    *(_OWORD *)id v37 = 0u;
    *(_OWORD *)uint64_t v38 = 0u;
    *(_OWORD *)id v35 = 0u;
    long long v36 = 0u;
    *(_OWORD *)id v34 = 0u;
    char v19 = [v6 phoneNumber];
    if (v19)
    {
      id v9 = [v6 phoneNumber];
      uint64_t v20 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      uint64_t v20 = "";
    }
    sub_10003ED78((std::string *)v34, v20);
    if (v19) {

    }
    id v23 = [v6 carrierName];
    if (v23)
    {
      id v9 = [v6 carrierName];
      id v24 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      id v24 = "";
    }
    sub_10003ED78((std::string *)&v35[1], v24);
    if (v23) {

    }
    unsigned int v25 = [v6 mccMnc];
    if (v25)
    {
      id v9 = [v6 mccMnc];
      id v26 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      id v26 = "";
    }
    sub_10003ED78((std::string *)v37, v26);
    if (v25) {

    }
    char v27 = [v6 gid1];
    if (v27)
    {
      id v9 = [v6 gid1];
      id v28 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      id v28 = "";
    }
    sub_10003ED78((std::string *)&v38[1], v28);
    if (v27) {

    }
    uint64_t v29 = [v6 gid2];
    if (v29)
    {
      id v9 = [v6 gid2];
      id v30 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      id v30 = "";
    }
    sub_10003ED78((std::string *)v40, v30);
    if (v29) {

    }
    char v31 = [v6 carrierID];
    if (v31)
    {
      id v9 = [v6 carrierID];
      uint64_t v32 = (char *)[(std::mutex *)v9 UTF8String];
    }
    else
    {
      uint64_t v32 = "";
    }
    sub_10003ED78((std::string *)&__p[1], v32);
    if (v31) {

    }
    id v33 = objc_retainBlock(v7);
    v44[0] = off_1019E2580;
    v44[1] = v33;
    v44[3] = v44;
    (*(void (**)(uint64_t, uint64_t, Registry **, void *))(*(void *)v16 + 928))(v16, 1, v34, v44);
    sub_100313668(v44);
    if (SHIBYTE(v42) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(__p[0]) < 0) {
      operator delete(v40[0]);
    }
    if (SHIBYTE(v39) < 0) {
      operator delete(v38[1]);
    }
    if (SHIBYTE(v38[0]) < 0) {
      operator delete(v37[0]);
    }
    if (SHIBYTE(v36) < 0) {
      operator delete(v35[1]);
    }
    if (SHIBYTE(v35[0]) < 0)
    {
      operator delete(v34[0]);
      if (v17) {
        goto LABEL_61;
      }
      goto LABEL_60;
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = v34[1];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v34);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v34[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)v34, 2u);
    }
    id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    (*((void (**)(id, id))v7 + 2))(v7, v22);
  }
  if ((v17 & 1) == 0) {
LABEL_60:
  }
    sub_10004D2C8(v15);
LABEL_61:
}

- (void)invalidateCrossPlatformPlanTransfer:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v19[0]);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    id v28 = v7;
    unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v28);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v19[1]) {
          sub_10004D2C8((std::__shared_weak_count *)v19[1]);
        }
        if (v13)
        {
          *(_OWORD *)std::string __p = 0u;
          long long v27 = 0u;
          long long v24 = 0u;
          *(_OWORD *)unsigned int v25 = 0u;
          *(_OWORD *)id v22 = 0u;
          *(_OWORD *)id v23 = 0u;
          *(_OWORD *)uint64_t v20 = 0u;
          long long v21 = 0u;
          *(_OWORD *)char v19 = 0u;
          id v16 = objc_retainBlock(v4);
          v29[0] = off_1019E2600;
          v29[1] = v16;
          void v29[3] = v29;
          (*(void (**)(uint64_t, void, Registry **, void *))(*(void *)v13 + 928))(v13, 0, v19, v29);
          sub_100313668(v29);
          if (SHIBYTE(v27) < 0) {
            operator delete(__p[1]);
          }
          if (SHIBYTE(__p[0]) < 0) {
            operator delete(v25[0]);
          }
          if (SHIBYTE(v24) < 0) {
            operator delete(v23[1]);
          }
          if (SHIBYTE(v23[0]) < 0) {
            operator delete(v22[0]);
          }
          if (SHIBYTE(v21) < 0) {
            operator delete(v20[1]);
          }
          if (SHIBYTE(v20[0]) < 0) {
            operator delete(v19[0]);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v17 = v19[1];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v19);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v19[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", (uint8_t *)v19, 2u);
          }
          id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, id))v4 + 2))(v4, v18);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v15 = v19[1];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v19);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v19[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "invalid completion handler", (uint8_t *)v19, 2u);
  }
LABEL_32:
}

- (void)plansPendingCrossPlatformTransferWithCompletion:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    id v22 = v7;
    unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v22);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v13)
        {
          v18[0] = _NSConcreteStackBlock;
          v18[1] = 3221225472;
          v18[2] = sub_10053C484;
          v18[3] = &unk_1019E0F88;
          v18[4] = self;
          id v19 = v4;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v13 + 112))(v13, 1, v18);
          id v16 = v19;
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v17 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
          }
          id v16 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v4 + 2))(v4, 0, v16);
        }

        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v15 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "invalid completion handler", buf, 2u);
  }
LABEL_21:
}

- (void)startPendingPlanInstallationForPlan:(id)a3 carrierName:(id)a4 completionHandler:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (v10)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v11 = v8;
      id v12 = objc_alloc_init((Class)CTCellularPlanProvisioningRequest);
      uint64_t v13 = [v11 smdpURL];
      [v12 setAddress:v13];

      char v14 = [v11 matchingID];
      [v12 setMatchingID:v14];

      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_10053C858;
      v16[3] = &unk_1019E0FB0;
      id v17 = v10;
      [(CTXPCClientHandler *)self addPlanWith:v12 appName:v9 appType:2 completionHandler:v16];
    }
    else
    {
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      (*((void (**)(id, uint64_t, id))v10 + 2))(v10, 1, v11);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v15 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "invalid completion handler", buf, 2u);
    }
  }
}

- (void)checkProfileEligibility:(id)a3 metadata:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (!v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    long long v21 = v31;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "invalid completion handler", buf, 2u);
    }
    goto LABEL_29;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  id v12 = ServiceMap;
  uint64_t v13 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    char v14 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = (const char *)v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v13;
  id v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)__p);
  if (!v17)
  {
    uint64_t v19 = 0;
    goto LABEL_11;
  }
  uint64_t v19 = v17[3];
  id v18 = (std::__shared_weak_count *)v17[4];
  if (!v18)
  {
LABEL_11:
    std::mutex::unlock(v12);
    id v18 = 0;
    char v20 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
LABEL_12:
  if (v31) {
    sub_10004D2C8((std::__shared_weak_count *)v31);
  }
  if (v19)
  {
    *(void *)long long buf = 0;
    char v31 = 0;
    uint64_t v32 = 0;
    if (v8) {
      id v22 = (char *)[v8 UTF8String];
    }
    else {
      id v22 = "";
    }
    sub_100058DB0(buf, v22);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v29 = 0;
    if (v9) {
      unsigned int v25 = (char *)[v9 UTF8String];
    }
    else {
      unsigned int v25 = "";
    }
    sub_100058DB0(__p, v25);
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    void v26[2] = sub_10053CCC0;
    v26[3] = &unk_1019E0F20;
    id v27 = v10;
    id v34 = 0;
    v33[0] = off_1019E2680;
    v33[1] = objc_retainBlock(v26);
    id v34 = v33;
    (*(void (**)(uint64_t, uint8_t *, void **, void *))(*(void *)v19 + 944))(v19, buf, __p, v33);
    sub_10023D374(v33);

    if (SHIBYTE(v29) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v32) < 0)
    {
      operator delete(*(void **)buf);
      if (v20) {
        goto LABEL_29;
      }
      goto LABEL_28;
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v23 = v31;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
    }
    id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    (*((void (**)(id, void, id))v10 + 2))(v10, 0, v24);
  }
  if ((v20 & 1) == 0) {
LABEL_28:
  }
    sub_10004D2C8(v18);
LABEL_29:
}

- (void)checkPreFlightEligibility:(id)a3 mccs:(id)a4 mncs:(id)a5 gid1s:(id)a6 gid2s:(id)a7 smdpUrl:(id)a8 iccidPrefix:(id)a9 completion:(id)a10
{
  id v47 = a3;
  id v51 = a4;
  id v16 = a5;
  id v52 = a6;
  id v17 = a7;
  id v49 = a8;
  id v50 = a9;
  id v48 = (void (**)(id, void, id))a10;
  if (v48)
  {
    [(CTXPCClientHandler *)self registry];
    id v18 = v51;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    char v20 = ServiceMap;
    long long v21 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v22 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v23 = 5381;
      do
      {
        long long v21 = (const char *)v23;
        unsigned int v24 = *v22++;
        uint64_t v23 = (33 * v23) ^ v24;
      }
      while (v24);
    }
    std::mutex::lock(ServiceMap);
    BOOL v70 = v21;
    unsigned int v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)&v70);
    if (v25)
    {
      id v26 = (std::__shared_weak_count *)v25[4];
      uint64_t v46 = v25[3];
      if (v26)
      {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v20);
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        id v27 = v26;
        sub_10004D2C8(v26);
        char v45 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v46 = 0;
    }
    std::mutex::unlock(v20);
    id v27 = 0;
    char v45 = 1;
LABEL_12:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    uint64_t v44 = v27;
    if (!v46)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v32 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
      }
      id v33 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v48[2](v48, 0, v33);

      goto LABEL_87;
    }
    BOOL v70 = 0;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    if (v51)
    {
      unsigned int v30 = [v51 count];
      if (v16)
      {
LABEL_17:
        unsigned int v31 = [v16 count];
LABEL_23:
        if ((int)v31 >= (int)v30) {
          uint64_t v34 = v30;
        }
        else {
          uint64_t v34 = v31;
        }
        if ((int)v34 >= 1)
        {
          for (uint64_t i = 0; i != v34; ++i)
          {
            long long v68 = 0uLL;
            uint64_t v69 = 0;
            id v36 = [v18 objectAtIndex:i];
            sub_100058DB0(&v68, (char *)[v36 UTF8String]);

            long long v66 = 0uLL;
            uint64_t v67 = 0;
            id v37 = [v16 objectAtIndex:i];
            sub_100058DB0(&v66, (char *)[v37 UTF8String]);

            memset(&v65, 0, sizeof(v65));
            if (v52 && i < (int)[v52 count])
            {
              id v38 = [v52 objectAtIndex:i];
              sub_10003ED78(&v65, (char *)[v38 UTF8String]);
            }
            memset(&v64, 0, sizeof(v64));
            if (v17 && i < (int)[v17 count])
            {
              id v39 = [v17 objectAtIndex:i];
              sub_10003ED78(&v64, (char *)[v39 UTF8String]);
            }
            memset(v63, 0, sizeof(v63));
            memset(v62, 0, sizeof(v62));
            long long v61 = 0u;
            *(_OWORD *)long long buf = 0u;
            if (SHIBYTE(v69) < 0)
            {
              sub_10004FC84(v62, (void *)v68, *((unint64_t *)&v68 + 1));
            }
            else
            {
              v62[0] = v68;
              *(void *)&v62[1] = v69;
            }
            id v18 = v51;
            if (SHIBYTE(v67) < 0)
            {
              sub_10004FC84((unsigned char *)&v62[1] + 8, (void *)v66, *((unint64_t *)&v66 + 1));
            }
            else
            {
              *(_OWORD *)((char *)&v62[1] + 8) = v66;
              *((void *)&v62[2] + 1) = v67;
            }
            if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(v63, v65.__r_.__value_.__l.__data_, v65.__r_.__value_.__l.__size_);
            }
            else {
              v63[0] = v65;
            }
            if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v63[1], v64.__r_.__value_.__l.__data_, v64.__r_.__value_.__l.__size_);
            }
            else {
              v63[1] = v64;
            }
            sub_1005395D0((uint64_t *)&v70, (uint64_t)buf);
            if (SHIBYTE(v63[1].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v63[1].__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v63[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v63[0].__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v62[2]) < 0) {
              operator delete(*((void **)&v62[1] + 1));
            }
            if (SBYTE7(v62[1]) < 0) {
              operator delete(*(void **)&v62[0]);
            }
            if (BYTE8(v61) && SBYTE7(v61) < 0) {
              operator delete(*(void **)buf);
            }
            if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v64.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v65.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v67) < 0) {
              operator delete((void *)v66);
            }
            if (SHIBYTE(v69) < 0) {
              operator delete((void *)v68);
            }
          }
        }
        memset(buf, 0, sizeof(buf));
        *(void *)&long long v61 = 0;
        if (v49)
        {
          BOOL v40 = v50;
          uint64_t v41 = (char *)[v49 UTF8String];
        }
        else
        {
          uint64_t v41 = "";
          BOOL v40 = v50;
        }
        sub_100058DB0(buf, v41);
        long long v68 = 0uLL;
        uint64_t v69 = 0;
        if (v40) {
          long long v42 = (char *)[v40 UTF8String];
        }
        else {
          long long v42 = "";
        }
        sub_100058DB0(&v68, v42);
        memset(v59, 0, sizeof(v59));
        sub_10030B4A4(v59, (uint64_t)v70, v71, (v71 - (uint64_t)v70) >> 7);
        if (SBYTE7(v61) < 0)
        {
          std::string v43 = v48;
          sub_10004FC84(__dst, *(void **)buf, *(unint64_t *)&buf[8]);
        }
        else
        {
          *(_OWORD *)__dst = *(_OWORD *)buf;
          uint64_t v58 = v61;
          std::string v43 = v48;
        }
        if (SHIBYTE(v69) < 0)
        {
          sub_10004FC84(v55, (void *)v68, *((unint64_t *)&v68 + 1));
        }
        else
        {
          *(_OWORD *)uint64_t v55 = v68;
          uint64_t v56 = v69;
        }
        v53[0] = _NSConcreteStackBlock;
        v53[1] = 3221225472;
        std::string v53[2] = sub_10053D73C;
        v53[3] = &unk_1019E0EF8;
        id v54 = v43;
        long long v74 = 0;
        v73[0] = off_1019E2700;
        v73[1] = objc_retainBlock(v53);
        long long v74 = v73;
        (*(void (**)(uint64_t, void *, void **, void **, void *))(*(void *)v46 + 64))(v46, v59, __dst, v55, v73);
        sub_100060644(v73);
        if (SHIBYTE(v56) < 0) {
          operator delete(v55[0]);
        }
        if (SHIBYTE(v58) < 0) {
          operator delete(__dst[0]);
        }
        *(void *)&long long v66 = v59;
        sub_10030B640((void ***)&v66);

        if (SHIBYTE(v69) < 0) {
          operator delete((void *)v68);
        }
        if (SBYTE7(v61) < 0) {
          operator delete(*(void **)buf);
        }
        *(void *)long long buf = &v70;
        sub_10030B640((void ***)buf);
LABEL_87:
        id v28 = v48;
        if ((v45 & 1) == 0) {
          sub_10004D2C8(v44);
        }
        goto LABEL_89;
      }
    }
    else
    {
      unsigned int v30 = 0;
      if (v16) {
        goto LABEL_17;
      }
    }
    unsigned int v31 = 0;
    goto LABEL_23;
  }
  id v28 = 0;
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v29 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "invalid completion handler", buf, 2u);
  }
LABEL_89:
}

- (void)getLocalDeviceIdentifier:(unint64_t)a3 clientBundleIdentifier:(id)a4 completion:(id)a5
{
  id v8 = a4;
  id v9 = (void (**)(id, void, id))a5;
  if (v9)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v11 = ServiceMap;
    id v12 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v13 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        id v12 = (char *)v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    xpc_object_t v47 = v12;
    id v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v47);
    if (v16)
    {
      uint64_t v18 = v16[3];
      id v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    id v17 = 0;
    char v19 = 1;
LABEL_12:
    if (v46) {
      sub_10004D2C8(v46);
    }
    if (!v18)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v32 = v46;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
      }
      id v33 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v9[2](v9, 0, v33);

      goto LABEL_52;
    }
    long long v21 = objc_retainBlock(v9);
    v48[0] = off_1019E2770;
    v48[1] = a3;
    unint64_t v48[2] = v21;
    v48[3] = v48;
    (*(void (**)(uint64_t, void *))(*(void *)v18 + 936))(v18, v48);
    sub_10030B748(v48);
    [(CTXPCClientHandler *)self registry];
    id v22 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v23 = v22;
    if (v24 < 0)
    {
      unsigned int v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v26 = 5381;
      do
      {
        uint64_t v24 = v26;
        unsigned int v27 = *v25++;
        uint64_t v26 = (33 * v26) ^ v27;
      }
      while (v27);
    }
    std::mutex::lock(v22);
    xpc_object_t v47 = (xpc_object_t)v24;
    id v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)&v47);
    if (v28)
    {
      uint64_t v30 = v28[3];
      uint64_t v29 = (std::__shared_weak_count *)v28[4];
      if (v29)
      {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v23);
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v29);
        char v31 = 0;
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v30 = 0;
    }
    std::mutex::unlock(v23);
    uint64_t v29 = 0;
    char v31 = 1;
LABEL_26:
    if (v46) {
      sub_10004D2C8(v46);
    }
    if (!v30)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v36 = v46;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "TelephonyAnalytics service not found!", buf, 2u);
      }
      goto LABEL_50;
    }
    xpc_object_t v47 = 0;
    xpc_object_t v34 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v35 = v34;
    if (v34)
    {
      xpc_object_t v47 = v34;
    }
    else
    {
      xpc_object_t v35 = xpc_null_create();
      xpc_object_t v47 = v35;
      if (!v35)
      {
        xpc_object_t v37 = xpc_null_create();
        xpc_object_t v35 = 0;
        goto LABEL_38;
      }
    }
    if (xpc_get_type(v35) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v35);
LABEL_39:
      xpc_release(v35);
      if (v8) {
        id v38 = (const char *)[v8 UTF8String];
      }
      else {
        id v38 = "";
      }
      xpc_object_t v43 = xpc_string_create(v38);
      if (!v43) {
        xpc_object_t v43 = xpc_null_create();
      }
      *(void *)long long buf = &v47;
      uint64_t v46 = (std::__shared_weak_count *)"bundle_id";
      sub_100035E70((uint64_t)buf, &v43, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v43);
      xpc_object_t v43 = 0;
      id v39 = (const char *)CTCellularPlanDeviceIdentifierAsString();
      xpc_object_t v41 = xpc_string_create(v39);
      if (!v41) {
        xpc_object_t v41 = xpc_null_create();
      }
      *(void *)long long buf = &v47;
      uint64_t v46 = (std::__shared_weak_count *)"type";
      sub_100035E70((uint64_t)buf, &v41, &v42);
      xpc_release(v42);
      xpc_object_t v42 = 0;
      xpc_release(v41);
      xpc_object_t v40 = v47;
      xpc_object_t v41 = 0;
      if (v47) {
        xpc_retain(v47);
      }
      else {
        xpc_object_t v40 = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v30 + 16))(v30, "commCenterCarrierItemAutofill", &v40);
      xpc_release(v40);
      xpc_object_t v40 = 0;
      xpc_release(v47);
LABEL_50:
      if ((v31 & 1) == 0) {
        sub_10004D2C8(v29);
      }
LABEL_52:
      if ((v19 & 1) == 0) {
        sub_10004D2C8(v17);
      }
      goto LABEL_54;
    }
    xpc_object_t v37 = xpc_null_create();
LABEL_38:
    xpc_object_t v47 = v37;
    goto LABEL_39;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v20 = v46;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "invalid completion handler", buf, 2u);
  }
LABEL_54:
}

- (void)prepareCrossPlatformCellularPlanLabel:(id)a3 completion:(id)a4
{
  id v113 = a3;
  v114 = (void (**)(id, void, id))a4;
  if (!v114)
  {
    [(CTXPCClientHandler *)self getLogContext];
    data = buf.var2.__r_.__value_.var0.var1.__data_;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled((os_log_t)data, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.var0) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)data, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&buf, 2u);
    }
    goto LABEL_212;
  }
  if ((_os_feature_enabled_impl() & 1) == 0)
  {
    id v15 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v114[2](v114, 0, v15);

    goto LABEL_212;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)&buf.var0);
  id v7 = ServiceMap;
  if (v8 < 0)
  {
    id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&v141.var0 = v8;
  id v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v141);
  if (!v12)
  {
    uint64_t v117 = 0;
    goto LABEL_13;
  }
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  uint64_t v117 = v12[3];
  if (!v13)
  {
LABEL_13:
    std::mutex::unlock(v7);
    id v111 = 0;
    char v112 = 1;
    goto LABEL_14;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  id v111 = v13;
  sub_10004D2C8(v13);
  char v112 = 0;
LABEL_14:
  if (buf.var2.__r_.__value_.var0.var1.__data_) {
    sub_10004D2C8((std::__shared_weak_count *)buf.var2.__r_.__value_.var0.var1.__data_);
  }
  if (!v117)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v109 = buf.var2.__r_.__value_.var0.var1.__data_;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled((os_log_t)v109, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.var0) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v109, OS_LOG_TYPE_ERROR, "No PersonalityShop", (uint8_t *)&buf, 2u);
    }
    id v110 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v114[2](v114, 0, v110);

    goto LABEL_210;
  }
  long long v131 = 0uLL;
  unint64_t v132 = 0;
  (*(void (**)(long long *__return_ptr))(*(void *)v117 + 248))(&v131);
  long long v129 = 0u;
  long long v130 = 0u;
  long long v127 = 0u;
  long long v128 = 0u;
  id v16 = v113;
  id v17 = [v16 countByEnumeratingWithState:&v127 objects:v140 count:16];
  if (!v17) {
    goto LABEL_175;
  }
  uint64_t v118 = *(void *)v128;
  v115 = self;
  id v116 = v16;
  do
  {
    uint64_t v18 = 0;
    do
    {
      if (*(void *)v128 != v118) {
        objc_enumerationMutation(v16);
      }
      char v19 = *(void **)(*((void *)&v127 + 1) + 8 * (void)v18);
      char v20 = [v19 phoneNumber];
      BOOL v21 = [v20 length] == 0;

      if (v21)
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v33 = buf.var2.__r_.__value_.var0.var1.__data_;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled((os_log_t)v33, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.var0) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v33, OS_LOG_TYPE_ERROR, "Missing phone number for cross platform cellular plan label creation", (uint8_t *)&buf, 2u);
        }
        goto LABEL_155;
      }
      uint64_t v23 = (uint64_t *)*((void *)&v131 + 1);
      for (uint64_t i = (uint64_t *)v131; ; i += 17)
      {
        if (i == v23)
        {
          sub_100058DB0(&buf, "CrossPlatform_");
          id v26 = [v19 phoneNumber];
          unsigned int v27 = (const char *)[v26 UTF8String];
          size_t v28 = strlen(v27);
          uint64_t v29 = std::string::append((std::string *)&buf, v27, v28);
          uint64_t v30 = (void *)v29->__r_.__value_.__r.__words[0];
          unint64_t size = v29->__r_.__value_.__l.__size_;
          v123[0] = v29->__r_.__value_.__r.__words[2];
          *(_DWORD *)((char *)v123 + 3) = *(_DWORD *)((char *)&v29->__r_.__value_.__r.__words[2] + 3);
          int v32 = SHIBYTE(v29->__r_.__value_.__r.__words[2]);
          v29->__r_.__value_.__l.__size_ = 0;
          v29->__r_.__value_.__r.__words[2] = 0;
          v29->__r_.__value_.__r.__words[0] = 0;

          if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
            operator delete(*(void **)&buf.var0);
          }
          __dst = 0;
          unint64_t v125 = 0;
          uint64_t v126 = 0;
          if (v32 < 0)
          {
            sub_10004FC84(&__dst, v30, size);
          }
          else
          {
            __dst = v30;
            unint64_t v125 = size;
            LODWORD(v126) = v123[0];
            *(_DWORD *)((char *)&v126 + 3) = *(_DWORD *)((char *)v123 + 3);
            HIBYTE(v126) = v32;
          }
          *(void *)&long long v137 = 0;
          *(_OWORD *)v135 = 0u;
          *(_OWORD *)std::string __p = 0u;
          *(_OWORD *)id v134 = 0u;
          memset(&buf, 0, sizeof(buf));
          (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)v117 + 176))(&buf);
          uint64_t v46 = (void *)HIBYTE(v135[0]);
          if (SHIBYTE(v135[0]) < 0) {
            uint64_t v46 = v134[1];
          }
          if (v46) {
            goto LABEL_75;
          }
          (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)v117 + 208))(&v141);
          if ((SBYTE7(v143) & 0x80u) == 0) {
            uint64_t v47 = BYTE7(v143);
          }
          else {
            uint64_t v47 = *((void *)&v142 + 1);
          }
          if (SBYTE7(v145) < 0)
          {
            operator delete((void *)v144);
            if ((BYTE7(v143) & 0x80) == 0) {
              goto LABEL_91;
            }
          }
          else if ((BYTE7(v143) & 0x80) == 0)
          {
            goto LABEL_91;
          }
          operator delete((void *)v142);
LABEL_91:
          if (SHIBYTE(v141.var2.var0) < 0) {
            operator delete(*((void **)&v141.var2.__r_.__value_.var0.var1 + 2));
          }
          if (v141.var2.__r_.__value_.var0.var0.__data_[15] < 0)
          {
            operator delete(*(void **)&v141.var0);
            if (v47) {
              goto LABEL_95;
            }
          }
          else if (v47)
          {
LABEL_95:
            id v48 = [v19 phoneNumber];
            sub_100058DB0(&v141, (char *)[v48 UTF8String]);
            (*(void (**)(uint64_t, void **, CSIPhoneNumber *))(*(void *)v117 + 224))(v117, &__dst, &v141);
            if (v141.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
              operator delete(*(void **)&v141.var0);
            }

            [(CTXPCClientHandler *)self getLogContext];
            id v49 = v141.var2.__r_.__value_.var0.var1.__data_;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v141);
            if (os_log_type_enabled((os_log_t)v49, OS_LOG_TYPE_DEFAULT))
            {
              unint64_t v50 = HIBYTE(v126);
              id v51 = (void **)__dst;
              unint64_t v52 = v125;
              std::string v53 = [v19 phoneNumber];
              id v54 = v53;
              if ((v50 & 0x80u) == 0) {
                unint64_t v55 = v50;
              }
              else {
                unint64_t v55 = v52;
              }
              p_dst = &__dst;
              if ((v50 & 0x80u) != 0) {
                p_dst = v51;
              }
              BOOL v57 = v55 == 0;
              v141.var0 = 136315394;
              uint64_t v58 = "<invalid>";
              if (!v57) {
                uint64_t v58 = (const char *)p_dst;
              }
              *(void *)&v141.var1 = v58;
              WORD2(v141.var2.__r_.__value_.var0.var1.__data_) = 2112;
              *(char **)((char *)&v141.var2.__r_.__value_.var0.var1.__data_ + 6) = v53;
              _os_log_impl((void *)&_mh_execute_header, (os_log_t)v49, OS_LOG_TYPE_DEFAULT, "New persona %s phone number set to (%@)", (uint8_t *)&v141, 0x16u);

              self = v115;
              id v16 = v116;
            }
            long long v59 = [v19 labelName];
            BOOL v60 = [v59 length] == 0;

            if (!v60)
            {
              id v61 = [v19 labelName];
              sub_100058DB0(&v121, (char *)[v61 UTF8String]);
              sub_100058DB0(&v119, "");
              (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)v117 + 216))(&v141);
              std::string::operator=((std::string *)&buf, (const std::string *)&v141);
              std::string::operator=((std::string *)(&buf.var2.__r_.__value_.var0.var1 + 1), (const std::string *)(&v141.var2.__r_.__value_.var0.var1 + 1));
              std::string::operator=((std::string *)v134, (const std::string *)&v142);
              LOBYTE(v135[1]) = BYTE8(v143);
              std::string::operator=((std::string *)__p, (const std::string *)&v144);
              if (SBYTE7(v145) < 0) {
                operator delete((void *)v144);
              }
              if (SBYTE7(v143) < 0) {
                operator delete((void *)v142);
              }
              if (SHIBYTE(v141.var2.var0) < 0) {
                operator delete(*((void **)&v141.var2.__r_.__value_.var0.var1 + 2));
              }
              if (v141.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
                operator delete(*(void **)&v141.var0);
              }
              if (v120 < 0) {
                operator delete(v119);
              }
              if (v122 < 0) {
                operator delete(v121);
              }

              id v62 = (void *)HIBYTE(v135[0]);
              if (SHIBYTE(v135[0]) < 0) {
                id v62 = v134[1];
              }
              if (!v62)
              {
                [(CTXPCClientHandler *)self getLogContext];
                long long v63 = v141.var2.__r_.__value_.var0.var1.__data_;
                ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v141);
                if (os_log_type_enabled((os_log_t)v63, OS_LOG_TYPE_ERROR))
                {
                  unint64_t v88 = HIBYTE(v126);
                  unsigned int v90 = (void **)__dst;
                  unint64_t v89 = v125;
                  xpc_object_t v91 = [v19 labelName];
                  uint64_t v92 = v91;
                  if ((v88 & 0x80u) == 0) {
                    unint64_t v93 = v88;
                  }
                  else {
                    unint64_t v93 = v89;
                  }
                  xpc_object_t v94 = &__dst;
                  if ((v88 & 0x80u) != 0) {
                    xpc_object_t v94 = v90;
                  }
                  BOOL v57 = v93 == 0;
                  v141.var0 = 136315394;
                  id v95 = "<invalid>";
                  if (!v57) {
                    id v95 = (const char *)v94;
                  }
                  *(void *)&v141.var1 = v95;
                  WORD2(v141.var2.__r_.__value_.var0.var1.__data_) = 2112;
                  *(char **)((char *)&v141.var2.__r_.__value_.var0.var1.__data_ + 6) = v91;
                  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v63, OS_LOG_TYPE_ERROR, "persona %s label rename %@ failed", (uint8_t *)&v141, 0x16u);

                  self = v115;
                  id v16 = v116;
                }
              }
              [(CTXPCClientHandler *)self getLogContext];
              std::string v64 = v141.var2.__r_.__value_.var0.var1.__data_;
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v141);
              if (os_log_type_enabled((os_log_t)v64, OS_LOG_TYPE_DEFAULT))
              {
                unint64_t v65 = HIBYTE(v126);
                uint64_t v67 = (void **)__dst;
                unint64_t v66 = v125;
                long long v68 = [v19 labelName];
                uint64_t v69 = v68;
                if ((v65 & 0x80u) == 0) {
                  unint64_t v70 = v65;
                }
                else {
                  unint64_t v70 = v66;
                }
                uint64_t v71 = &__dst;
                if ((v65 & 0x80u) != 0) {
                  uint64_t v71 = v67;
                }
                BOOL v57 = v70 == 0;
                v141.var0 = 136315394;
                uint64_t v72 = "<invalid>";
                if (!v57) {
                  uint64_t v72 = (const char *)v71;
                }
                *(void *)&v141.var1 = v72;
                WORD2(v141.var2.__r_.__value_.var0.var1.__data_) = 2112;
                *(char **)((char *)&v141.var2.__r_.__value_.var0.var1.__data_ + 6) = v68;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)v64, OS_LOG_TYPE_DEFAULT, "New persona %s label set to (%@)", (uint8_t *)&v141, 0x16u);

                self = v115;
                id v16 = v116;
              }
            }
LABEL_75:
            if (SBYTE7(v137) < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v135[0]) < 0) {
              operator delete(v134[0]);
            }
            if (SHIBYTE(buf.var2.var0) < 0) {
              operator delete(*((void **)&buf.var2.__r_.__value_.var0.var1 + 2));
            }
            if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
              operator delete(*(void **)&buf.var0);
            }
            if (SHIBYTE(v126) < 0)
            {
              operator delete(__dst);
              if ((v32 & 0x80000000) == 0) {
                goto LABEL_155;
              }
            }
            else if ((v32 & 0x80000000) == 0)
            {
              goto LABEL_155;
            }
            long long v73 = v30;
            goto LABEL_154;
          }
          [(CTXPCClientHandler *)self getLogContext];
          long long v74 = v141.var2.__r_.__value_.var0.var1.__data_;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v141);
          if (os_log_type_enabled((os_log_t)v74, OS_LOG_TYPE_ERROR))
          {
            unint64_t v75 = HIBYTE(v126);
            if (v126 < 0) {
              unint64_t v75 = v125;
            }
            long long v76 = (const char *)&__dst;
            if (v126 < 0) {
              long long v76 = (const char *)__dst;
            }
            BOOL v57 = v75 == 0;
            id v77 = "<invalid>";
            if (!v57) {
              id v77 = v76;
            }
            v141.var0 = 136315138;
            *(void *)&v141.var1 = v77;
            _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v74, OS_LOG_TYPE_ERROR, "persona %s add new sim label failed", (uint8_t *)&v141, 0xCu);
          }
          goto LABEL_75;
        }
        id v24 = [v19 phoneNumber];
        sub_100058DB0(&__dst, (char *)[v24 UTF8String]);
        uint64_t v139 = 0;
        long long v137 = 0u;
        long long v138 = 0u;
        *(_OWORD *)v135 = 0u;
        *(_OWORD *)std::string __p = 0u;
        *(_OWORD *)id v134 = 0u;
        memset(&buf, 0, sizeof(buf));
        CSIPhoneNumber::CSIPhoneNumber();
        uint64_t v147 = 0;
        long long v145 = 0u;
        long long v146 = 0u;
        long long v143 = 0u;
        long long v144 = 0u;
        long long v142 = 0u;
        memset(&v141, 0, sizeof(v141));
        CSIPhoneNumber::CSIPhoneNumber();
        int isOriginalNumberSame = CSIPhoneNumber::isOriginalNumberSame(&buf, &v141);
        if (SHIBYTE(v145) < 0) {
          operator delete(*((void **)&v144 + 1));
        }
        if (SBYTE7(v144) < 0) {
          operator delete((void *)v143);
        }
        if (SBYTE7(v142) < 0) {
          operator delete(*(void **)&v141.var2.__r_.var0);
        }
        if (*((char *)&v141.var2.__r_.__value_.var0.var1 + 23) < 0) {
          operator delete(v141.var2.__r_.__value_.var0.var1.__data_);
        }
        if (SHIBYTE(v137) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(__p[0]) < 0) {
          operator delete(v135[0]);
        }
        if (SHIBYTE(v134[0]) < 0) {
          operator delete(*(void **)&buf.var2.__r_.var0);
        }
        if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
          operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
        }
        if (SHIBYTE(v126) < 0) {
          operator delete(__dst);
        }

        if (isOriginalNumberSame) {
          break;
        }
      }
      xpc_object_t v34 = [v19 labelName];
      BOOL v35 = [v34 length] == 0;

      if (!v35)
      {
        *(void *)&long long v137 = 0;
        *(_OWORD *)v135 = 0u;
        *(_OWORD *)std::string __p = 0u;
        *(_OWORD *)id v134 = 0u;
        memset(&buf, 0, sizeof(buf));
        id v36 = [v19 labelName];
        sub_100058DB0(&v141, (char *)[v36 UTF8String]);
        sub_100058DB0(&__dst, "");
        xpc_object_t v37 = (const char *)(i + 13);
        (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)v117 + 216))(&buf);
        if (SHIBYTE(v126) < 0) {
          operator delete(__dst);
        }
        if (v141.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
          operator delete(*(void **)&v141.var0);
        }

        id v38 = (void *)HIBYTE(v135[0]);
        if (SHIBYTE(v135[0]) < 0) {
          id v38 = v134[1];
        }
        if (v38)
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v39 = v141.var2.__r_.__value_.var0.var1.__data_;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v141);
          if (os_log_type_enabled((os_log_t)v39, OS_LOG_TYPE_DEFAULT))
          {
            char v40 = *((unsigned char *)i + 127);
            if (v40 >= 0) {
              uint64_t v41 = *((unsigned __int8 *)i + 127);
            }
            else {
              uint64_t v41 = i[14];
            }
            if (v40 >= 0) {
              xpc_object_t v42 = (const char *)(i + 13);
            }
            else {
              xpc_object_t v42 = (const char *)i[13];
            }
            if (*((char *)i + 23) < 0) {
              uint64_t i = (uint64_t *)*i;
            }
            uint64_t v43 = [v19 labelName];
            uint64_t v44 = (void *)v43;
            v141.var0 = 136315650;
            char v45 = "<invalid>";
            if (v41) {
              char v45 = v42;
            }
            *(void *)&v141.var1 = v45;
            WORD2(v141.var2.__r_.__value_.var0.var1.__data_) = 2080;
            *(char **)((char *)&v141.var2.__r_.__value_.var0.var1.__data_ + 6) = (char *)i;
            HIWORD(v141.var2.__r_.__value_.var0.var1.__size_) = 2112;
            *((void *)&v141.var2.__r_.__value_.var0.var1 + 2) = v43;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)v39, OS_LOG_TYPE_DEFAULT, "persona %s label rename from (%s) -> (%@)", (uint8_t *)&v141, 0x20u);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          long long v78 = v141.var2.__r_.__value_.var0.var1.__data_;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v141);
          if (os_log_type_enabled((os_log_t)v78, OS_LOG_TYPE_ERROR))
          {
            uint64_t v79 = *((unsigned __int8 *)i + 127);
            id v82 = i + 13;
            BOOL v80 = (const char *)i[13];
            uint64_t v81 = v82[1];
            id v83 = [v19 labelName];
            xpc_object_t v84 = v83;
            if ((v79 & 0x80u) == 0) {
              uint64_t v85 = v79;
            }
            else {
              uint64_t v85 = v81;
            }
            if ((v79 & 0x80u) == 0) {
              uint64_t v86 = v37;
            }
            else {
              uint64_t v86 = v80;
            }
            BOOL v57 = v85 == 0;
            v141.var0 = 136315394;
            std::string::size_type v87 = "<invalid>";
            if (!v57) {
              std::string::size_type v87 = v86;
            }
            *(void *)&v141.var1 = v87;
            WORD2(v141.var2.__r_.__value_.var0.var1.__data_) = 2112;
            *(char **)((char *)&v141.var2.__r_.__value_.var0.var1.__data_ + 6) = v83;
            _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v78, OS_LOG_TYPE_ERROR, "persona %s label rename %@ failed", (uint8_t *)&v141, 0x16u);
          }
        }
        if (SBYTE7(v137) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v135[0]) < 0) {
          operator delete(v134[0]);
        }
        if (SHIBYTE(buf.var2.var0) < 0) {
          operator delete(*((void **)&buf.var2.__r_.__value_.var0.var1 + 2));
        }
        if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0)
        {
          long long v73 = *(void **)&buf.var0;
LABEL_154:
          operator delete(v73);
        }
      }
LABEL_155:
      uint64_t v18 = (char *)v18 + 1;
    }
    while (v18 != v17);
    id v96 = [v16 countByEnumeratingWithState:&v127 objects:v140 count:16];
    id v17 = v96;
  }
  while (v96);
LABEL_175:

  (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)v117 + 248))(&buf);
  sub_100541194((void **)&v131);
  long long v131 = *(_OWORD *)&buf.var0;
  unint64_t v132 = buf.var2.__r_.__value_.var0.var1.__size_;
  memset(&buf, 0, 24);
  *(void *)&v141.var0 = &buf;
  sub_100320504((void ***)&v141);
  xpc_object_t v97 = objc_opt_new();
  xpc_object_t v98 = +[NSMutableArray array];
  uint64_t v100 = *((void *)&v131 + 1);
  uint64_t v99 = v131;
  if ((void)v131 != *((void *)&v131 + 1))
  {
    while (2)
    {
      *(void *)&long long v137 = 0;
      *(_OWORD *)v135 = 0u;
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)id v134 = 0u;
      memset(&buf, 0, sizeof(buf));
      (*(void (**)(CSIPhoneNumber *__return_ptr))(*(void *)v117 + 176))(&buf);
      xpc_object_t v101 = (void *)HIBYTE(v135[0]);
      if (SHIBYTE(v135[0]) < 0) {
        xpc_object_t v101 = v134[1];
      }
      if (!v101) {
        goto LABEL_197;
      }
      xpc_object_t v102 = objc_opt_new();
      if (SHIBYTE(v135[0]) >= 0) {
        v103 = v134;
      }
      else {
        v103 = (void **)v134[0];
      }
      xpc_object_t v104 = +[NSString stringWithUTF8String:v103];
      [v102 setLabelID:v104];

      if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0)
      {
        if (!buf.var2.__r_.__value_.var0.var1.__data_) {
          goto LABEL_187;
        }
        p_CSIPhoneNumber buf = *(__long **)&buf.var0;
      }
      else
      {
        if (buf.var2.__r_.__value_.var0.var0.__data_[15])
        {
          p_CSIPhoneNumber buf = (__long *)&buf;
          break;
        }
LABEL_187:
        if (SHIBYTE(buf.var2.var0) < 0)
        {
          if (!*(void *)&buf.var2.__r_.var0) {
            goto LABEL_193;
          }
          p_CSIPhoneNumber buf = (__long *)*((void *)&buf.var2.__r_.__value_.var0.var1 + 2);
        }
        else
        {
          p_CSIPhoneNumber buf = &buf.var2.__r_.__value_.var0.var1 + 1;
          if (!HIBYTE(buf.var2.var0))
          {
LABEL_193:
            if ((SBYTE7(v137) & 0x80u) == 0) {
              uint64_t v107 = __p;
            }
            else {
              uint64_t v107 = (void **)__p[0];
            }
            unsigned int v108 = +[NSString stringWithUTF8String:v107];
            [v102 setPhoneNumber:v108];

            [v98 addObject:v102];
LABEL_197:
            if (SBYTE7(v137) < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v135[0]) < 0) {
              operator delete(v134[0]);
            }
            if (SHIBYTE(buf.var2.var0) < 0) {
              operator delete(*((void **)&buf.var2.__r_.__value_.var0.var1 + 2));
            }
            if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
              operator delete(*(void **)&buf.var0);
            }
            v99 += 136;
            if (v99 == v100) {
              goto LABEL_206;
            }
            continue;
          }
        }
      }
      break;
    }
    v106 = +[NSString stringWithUTF8String:p_buf];
    [v102 setLabel:v106];

    goto LABEL_193;
  }
LABEL_206:
  [v97 setSubscriptions:v98];
  ((void (**)(id, void *, id))v114)[2](v114, v97, 0);

  *(void *)&buf.var0 = &v131;
  sub_100320504((void ***)&buf);
LABEL_210:
  if ((v112 & 1) == 0) {
    sub_10004D2C8(v111);
  }
LABEL_212:
}

- (void)shouldShoweSIMTravelTipWithCompletion:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v6 = ServiceMap;
    id v7 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        id v7 = (const char *)v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    id v22 = v7;
    unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v22);
    if (v11)
    {
      uint64_t v13 = v11[3];
      id v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v13)
        {
          v19[0] = 0;
          v19[128] = 0;
          v17[0] = _NSConcreteStackBlock;
          v17[1] = 3221225472;
          v17[2] = sub_10053F45C;
          v17[3] = &unk_1019E0FD8;
          v17[4] = self;
          id v18 = v4;
          (*(void (**)(uint64_t, unsigned char *, void *))(*(void *)v13 + 40))(v13, v19, v17);
          sub_10010B788((uint64_t)v19);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v16 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)CSIPhoneNumber buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController", buf, 2u);
          }
          (*((void (**)(id, void))v4 + 2))(v4, 0);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    id v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v15 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "invalid completion handler", buf, 2u);
  }
LABEL_21:
}

- (void)sendTravelBuddyCAEventWithCompletion:(id)a3 carrierName:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unsigned int v10 = (void (**)(id, void))a5;
  if (!v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    BOOL v21 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "invalid completion handler", buf, 2u);
    }
    goto LABEL_21;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  id v12 = ServiceMap;
  uint64_t v13 = "22TravelHandlerInterface";
  if (((unint64_t)"22TravelHandlerInterface" & 0x8000000000000000) != 0)
  {
    char v14 = (unsigned __int8 *)((unint64_t)"22TravelHandlerInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = (const char *)v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v13;
  id v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)__p);
  if (v17)
  {
    uint64_t v19 = v17[3];
    id v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  id v18 = 0;
  char v20 = 1;
LABEL_12:
  if (v27) {
    sub_10004D2C8((std::__shared_weak_count *)v27);
  }
  if (v19)
  {
    sub_100058DB0(buf, (char *)[v8 UTF8String]);
    sub_100058DB0(__p, (char *)[v9 UTF8String]);
    (*(void (**)(uint64_t, uint8_t *, void **))(*(void *)v19 + 16))(v19, buf, __p);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
    if (v28 < 0) {
      operator delete(*(void **)buf);
    }
    v10[2](v10, 0);
    if ((v20 & 1) == 0) {
LABEL_20:
    }
      sub_10004D2C8(v18);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Unable to get TravelHandler", buf, 2u);
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    ((void (**)(id, id))v10)[2](v10, v23);

    if ((v20 & 1) == 0) {
      goto LABEL_20;
    }
  }
LABEL_21:
}

- (void)isAutofilleSIMIdAllowedForDomain:(id)a3 bundleIdentifier:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unsigned int v10 = (void (**)(id, void, id))a5;
  if (v10)
  {
    [(CTXPCClientHandler *)self registry];
    [(CTXPCClientHandler *)self getLogContext];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (v17) {
      sub_10004D2C8(v17);
    }
    id v16 = 0;
    id v11 = [objc_alloc((Class)LSApplicationRecord) initWithBundleIdentifier:v9 allowPlaceholder:0 error:&v16];
    id v12 = v16;
    if (v12)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v13 = *(NSObject **)&v19[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CSIPhoneNumber buf = 138412290;
        *(void *)uint64_t v19 = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "load LSApplicationRecord failed : %@", buf, 0xCu);
      }
      v10[2](v10, 0, v12);
    }
    else
    {
      uint64_t v15 = [v11 applicationIdentifier];
      [(CTXPCClientHandler *)self _isAutofilleSIMIdAllowedForDomain:v8 applicationIdentifier:v15 completion:v10];
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v14 = *(NSObject **)&v19[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "invalid completion handler", buf, 2u);
    }
  }
}

- (void)isAutofilleSIMIdAllowedForDomain:(id)a3 clientBundleIdentifier:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unsigned int v10 = (void (**)(id, void, id))a5;
  if (v10)
  {
    [(CTXPCClientHandler *)self registry];
    [(CTXPCClientHandler *)self getLogContext];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (v18) {
      sub_10004D2C8(v18);
    }
    id v17 = 0;
    id v11 = [objc_alloc((Class)LSApplicationRecord) initWithBundleIdentifier:v9 allowPlaceholder:0 error:&v17];
    id v12 = v17;
    if (v12)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v13 = *(NSObject **)&v20[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CSIPhoneNumber buf = 138412290;
        *(void *)char v20 = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "load LSApplicationRecord failed : %@", buf, 0xCu);
      }
      v10[2](v10, 0, v12);
    }
    else
    {
      if ([(CTXPCClientHandler *)self _hasPublicCellularPlanEntitlement:v11])
      {
        uint64_t v15 = [v11 applicationIdentifier];
        [(CTXPCClientHandler *)self _isAutofilleSIMIdAllowedForDomain:v8 applicationIdentifier:v15 completion:v10];
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v16 = *(NSObject **)&v20[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)CSIPhoneNumber buf = 138412290;
          *(void *)char v20 = v9;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "client (%@) missing entitlement for public-cellular-plan", buf, 0xCu);
        }
        uint64_t v15 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:1 userInfo:0];
        v10[2](v10, 0, v15);
      }
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v14 = *(NSObject **)&v20[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "invalid completion handler", buf, 2u);
    }
  }
}

- (void)_isAutofilleSIMIdAllowedForDomain:(id)a3 applicationIdentifier:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v34 = a4;
  id v33 = (void (**)(id, void, id))a5;
  uint64_t v40 = 0;
  uint64_t v41 = &v40;
  uint64_t v42 = 0x2050000000;
  id v9 = (void *)qword_101B0D160;
  uint64_t v43 = qword_101B0D160;
  if (!qword_101B0D160)
  {
    *(void *)CSIPhoneNumber buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_1005411FC;
    uint64_t v46 = &unk_1019DD010;
    uint64_t v47 = &v40;
    sub_1005411FC((uint64_t)buf);
    id v9 = (void *)v41[3];
  }
  unsigned int v10 = v9;
  _Block_object_dispose(&v40, 8);
  id v32 = [[v10 alloc] initWithServiceType:0 applicationIdentifier:v34 domain:0];
  if (v32)
  {
    uint64_t v40 = 0;
    uint64_t v41 = &v40;
    uint64_t v42 = 0x2050000000;
    id v11 = (void *)qword_101B0D168;
    uint64_t v43 = qword_101B0D168;
    if (!qword_101B0D168)
    {
      *(void *)CSIPhoneNumber buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_1005414D0;
      uint64_t v46 = &unk_1019DD010;
      uint64_t v47 = &v40;
      sub_1005414D0((uint64_t)buf);
      id v11 = (void *)v41[3];
    }
    id v12 = v11;
    _Block_object_dispose(&v40, 8);
    id v39 = 0;
    uint64_t v30 = [v12 serviceDetailsWithServiceSpecifier:v32 error:&v39];
    id v31 = v39;
    if (v31)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v13 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)CSIPhoneNumber buf = 138412290;
        *(void *)&uint8_t buf[4] = v31;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "failed to create swc service details : %@", buf, 0xCu);
      }
      v33[2](v33, 0, v31);
      goto LABEL_35;
    }
    if (v30)
    {
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      id v15 = v30;
      id v16 = [v15 countByEnumeratingWithState:&v35 objects:v44 count:16];
      if (v16)
      {
        uint64_t v18 = *(void *)v36;
        *(void *)&long long v17 = 138412546;
        long long v29 = v17;
        while (2)
        {
          for (uint64_t i = 0; i != v16; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v36 != v18) {
              objc_enumerationMutation(v15);
            }
            char v20 = *(void **)(*((void *)&v35 + 1) + 8 * i);
            if (objc_msgSend(v20, "isApproved", v29))
            {
              BOOL v21 = [v20 serviceSpecifier];
              if ([v21 domainEncompassesDomain:v8])
              {
                v33[2](v33, 1, 0);

                goto LABEL_35;
              }
              [(CTXPCClientHandler *)self getLogContext];
              id v22 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)CSIPhoneNumber buf = v29;
                *(void *)&uint8_t buf[4] = v21;
                *(_WORD *)&buf[12] = 2112;
                *(void *)&buf[14] = v8;
                _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Specifier: %@ doesn't encompass Domain: %@", buf, 0x16u);
              }
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              id v23 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)CSIPhoneNumber buf = 138412290;
                *(void *)&uint8_t buf[4] = v20;
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "detail: %@ is not approved", buf, 0xCu);
              }
            }
          }
          id v16 = [v15 countByEnumeratingWithState:&v35 objects:v44 count:16];
          if (v16) {
            continue;
          }
          break;
        }
      }

      [(CTXPCClientHandler *)self getLogContext];
      id v24 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      *(_DWORD *)CSIPhoneNumber buf = 138412290;
      *(void *)&uint8_t buf[4] = v15;
      char v25 = "Autofill is not allowed for Service Details: %@";
      id v26 = v24;
      uint32_t v27 = 12;
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v28 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
LABEL_33:
        v33[2](v33, 0, 0);
LABEL_35:

        goto LABEL_36;
      }
      *(_WORD *)CSIPhoneNumber buf = 0;
      char v25 = "no service details";
      id v26 = v28;
      uint32_t v27 = 2;
    }
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v25, buf, v27);
    goto LABEL_33;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v14 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "create service specifier failed", buf, 2u);
  }
  id v31 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:1 userInfo:0];
  ((void (*)(void (**)(id, void, id), void))v33[2])(v33, 0);
LABEL_36:
}

- (BOOL)_hasPublicCellularPlanEntitlement:(id)a3
{
  uint64_t v3 = [a3 entitlements];
  id v4 = [v3 objectForKey:@"com.apple.CommCenter.fine-grained" ofClass:objc_opt_class()];

  LOBYTE(v3) = [v4 containsObject:@"public-cellular-plan"];
  return (char)v3;
}

- (void)overridePlanSelection:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p.__r_.__value_.__l.__data_);
    id v9 = ServiceMap;
    unsigned int v10 = "N8cellplan36CellularPlanControllerWatchInterfaceE";
    if (((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)((unint64_t)"N8cellplan36CellularPlanControllerWatchInterfaceE" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unsigned int v10 = (const char *)v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    id v23 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v23);
    if (v14)
    {
      uint64_t v16 = v14[3];
      id v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (__p.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
        }
        if (v16)
        {
          memset(&__p, 0, sizeof(__p));
          if (v6)
          {
            id v19 = v6;
            sub_10003ED78(&__p, (char *)objc_msgSend(v19, "UTF8String", __p.__r_.__value_.__r.__words[0], __p.__r_.__value_.__l.__size_, __p.__r_.__value_.__r.__words[2]));
          }
          id v20 = objc_retainBlock(v7);
          v24[0] = off_1019E2800;
          v24[1] = v20;
          uint64_t v24[3] = v24;
          (*(void (**)(uint64_t, std::string *, void *))(*(void *)v16 + 80))(v16, &__p, v24);
          sub_100060644(v24);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t size = __p.__r_.__value_.__l.__size_;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
          if (os_log_type_enabled(size, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p.__r_.__value_.__l.__data_) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, size, OS_LOG_TYPE_ERROR, "No controller found to support selection override", (uint8_t *)&__p, 2u);
          }
          (*((void (**)(id, void))v7 + 2))(v7, 0);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    id v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v18 = __p.__r_.__value_.__l.__size_;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "invalid completion handler", (uint8_t *)&__p, 2u);
  }
LABEL_24:
}

- (void)fetchCallWaitingValue:(id)a3 callClass:(int)a4 completion:(id)a5
{
  uint64_t v6 = *(void *)&a4;
  id v8 = a3;
  id v9 = (void (**)(id, id))a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v20 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetch call waiting query", (uint8_t *)&v26, 2u);
    }
    goto LABEL_22;
  }
  if (!v8)
  {
    id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v9[2](v9, v21);

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v26);
  id v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v28 = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v28);
  if (v16)
  {
    uint64_t v18 = v16[3];
    char v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  char v17 = 0;
  char v19 = 1;
LABEL_14:
  if (v27) {
    sub_10004D2C8((std::__shared_weak_count *)v27);
  }
  if (v18)
  {
    id v22 = [v8 slotID];
    if (v22 == (id)2) {
      uint64_t v23 = 2;
    }
    else {
      uint64_t v23 = v22 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18 + 152))(v18, v23, v6);
    v9[2](v9, 0);
    if ((v19 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v17);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v24 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for fetching call waiting value", (uint8_t *)&v26, 2u);
    }
    id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v9[2](v9, v25);

    if ((v19 & 1) == 0) {
      goto LABEL_21;
    }
  }
LABEL_22:
}

- (void)fetchCallForwardingValue:(id)a3 reason:(int)a4 callClass:(int)a5 completion:(id)a6
{
  uint64_t v7 = *(void *)&a5;
  uint64_t v8 = *(void *)&a4;
  id v10 = a3;
  id v11 = (void (**)(id, id))a6;
  if (!v11)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v28) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetch call forwarding query", (uint8_t *)&v28, 2u);
    }
    goto LABEL_22;
  }
  if (!v10)
  {
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v11[2](v11, v23);

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v28);
  unsigned int v13 = ServiceMap;
  if ((v14 & 0x8000000000000000) != 0)
  {
    unsigned int v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      unint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v30 = v14;
  uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, &v30);
  if (v18)
  {
    uint64_t v20 = v18[3];
    char v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      char v21 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  std::mutex::unlock(v13);
  char v19 = 0;
  char v21 = 1;
LABEL_14:
  if (v29) {
    sub_10004D2C8((std::__shared_weak_count *)v29);
  }
  if (v20)
  {
    id v24 = [v10 slotID];
    if (v24 == (id)2) {
      uint64_t v25 = 2;
    }
    else {
      uint64_t v25 = v24 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v20 + 80))(v20, v25, v8, v7);
    v11[2](v11, 0);
    if ((v21 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v26 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v28) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for fetching call forwarding value", (uint8_t *)&v28, 2u);
    }
    id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v11[2](v11, v27);

    if ((v21 & 1) == 0) {
      goto LABEL_21;
    }
  }
LABEL_22:
}

- (void)fetchCallBarringValue:(id)a3 facility:(int)a4 callClass:(int)a5 password:(id)a6 completion:(id)a7
{
  uint64_t v9 = *(void *)&a5;
  uint64_t v10 = *(void *)&a4;
  id v12 = a3;
  id v13 = a6;
  unint64_t v14 = (void (**)(id, id))a7;
  if (v14)
  {
    if (!v12)
    {
      id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v14[2](v14, v26);

      goto LABEL_27;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p);
    uint64_t v16 = ServiceMap;
    if ((v17 & 0x8000000000000000) != 0)
    {
      uint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        unint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v34 = v17;
    char v21 = sub_10004D37C(&v16[1].__m_.__sig, &v34);
    if (v21)
    {
      uint64_t v23 = v21[3];
      id v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v24 = 0;
LABEL_14:
        if (v32) {
          sub_10004D2C8(v32);
        }
        if (v23)
        {
          id v27 = [v12 slotID];
          if (v27 == (id)2) {
            uint64_t v28 = 2;
          }
          else {
            uint64_t v28 = v27 == (id)1;
          }
          std::string __p = 0;
          id v32 = 0;
          uint64_t v33 = 0;
          sub_100058DB0(&__p, (char *)[v13 UTF8String]);
          (*(void (**)(uint64_t, uint64_t, void **, uint64_t, uint64_t))(*(void *)v23 + 128))(v23, v28, &__p, v10, v9);
          v14[2](v14, 0);
          if (SHIBYTE(v33) < 0) {
            operator delete(__p);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          long long v29 = v32;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for fetching call barring value", (uint8_t *)&__p, 2u);
          }
          id v30 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v14[2](v14, v30);
        }
        if ((v24 & 1) == 0) {
          sub_10004D2C8(v22);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    id v22 = 0;
    char v24 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v25 = v32;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetch call barring query", (uint8_t *)&__p, 2u);
  }
LABEL_27:
}

- (void)fetchConnectedLinePresentationValue:(id)a3 completion:(id)a4
{
  id v6 = a3;
  uint64_t v7 = (void (**)(id, id))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetch connected line presentation query", (uint8_t *)&v24, 2u);
    }
    goto LABEL_22;
  }
  if (!v6)
  {
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, v19);

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v10;
  unint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v26);
  if (v14)
  {
    uint64_t v16 = v14[3];
    unsigned int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  unsigned int v15 = 0;
  char v17 = 1;
LABEL_14:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (v16)
  {
    id v20 = [v6 slotID];
    if (v20 == (id)2) {
      uint64_t v21 = 2;
    }
    else {
      uint64_t v21 = v20 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v16 + 176))(v16, v21, 0);
    v7[2](v7, 0);
    if ((v17 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for fetching connected line presentation value", (uint8_t *)&v24, 2u);
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v7[2](v7, v23);

    if ((v17 & 1) == 0) {
      goto LABEL_21;
    }
  }
LABEL_22:
}

- (void)fetchCallingLinePresentationValue:(id)a3 completion:(id)a4
{
  id v6 = a3;
  uint64_t v7 = (void (**)(id, id))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetch calling line presentation query", (uint8_t *)&v24, 2u);
    }
    goto LABEL_22;
  }
  if (!v6)
  {
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, v19);

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v10;
  unint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v26);
  if (v14)
  {
    uint64_t v16 = v14[3];
    unsigned int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  unsigned int v15 = 0;
  char v17 = 1;
LABEL_14:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (v16)
  {
    id v20 = [v6 slotID];
    if (v20 == (id)2) {
      uint64_t v21 = 2;
    }
    else {
      uint64_t v21 = v20 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 176))(v16, v21, 1);
    v7[2](v7, 0);
    if ((v17 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for fetching calling line presentation value", (uint8_t *)&v24, 2u);
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v7[2](v7, v23);

    if ((v17 & 1) == 0) {
      goto LABEL_21;
    }
  }
LABEL_22:
}

- (void)fetchConnectedLineIdRestrictionValue:(id)a3 completion:(id)a4
{
  id v6 = a3;
  uint64_t v7 = (void (**)(id, id))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetch connected line ID restriction query", (uint8_t *)&v24, 2u);
    }
    goto LABEL_22;
  }
  if (!v6)
  {
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, v19);

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v10;
  unint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v26);
  if (v14)
  {
    uint64_t v16 = v14[3];
    unsigned int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  unsigned int v15 = 0;
  char v17 = 1;
LABEL_14:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (v16)
  {
    id v20 = [v6 slotID];
    if (v20 == (id)2) {
      uint64_t v21 = 2;
    }
    else {
      uint64_t v21 = v20 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 192))(v16, v21);
    v7[2](v7, 0);
    if ((v17 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for fetching connected line ID restriction value", (uint8_t *)&v24, 2u);
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v7[2](v7, v23);

    if ((v17 & 1) == 0) {
      goto LABEL_21;
    }
  }
LABEL_22:
}

- (void)fetchCallingLineIdRestrictionValue:(id)a3 completion:(id)a4
{
  id v6 = a3;
  uint64_t v7 = (void (**)(id, id))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetch calling line ID restriction query", (uint8_t *)&v24, 2u);
    }
    goto LABEL_22;
  }
  if (!v6)
  {
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, v19);

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v10;
  unint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v26);
  if (v14)
  {
    uint64_t v16 = v14[3];
    unsigned int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  unsigned int v15 = 0;
  char v17 = 1;
LABEL_14:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (v16)
  {
    id v20 = [v6 slotID];
    if (v20 == (id)2) {
      uint64_t v21 = 2;
    }
    else {
      uint64_t v21 = v20 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 208))(v16, v21);
    v7[2](v7, 0);
    if ((v17 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for fetching calling line ID restriction value", (uint8_t *)&v24, 2u);
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v7[2](v7, v23);

    if ((v17 & 1) == 0) {
      goto LABEL_21;
    }
  }
LABEL_22:
}

- (void)saveCallWaitingValue:(id)a3 callClass:(int)a4 enabled:(BOOL)a5 completion:(id)a6
{
  BOOL v7 = a5;
  uint64_t v8 = *(void *)&a4;
  id v10 = a3;
  id v11 = (void (**)(id, id))a6;
  if (!v11)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v28) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for save call waiting request", (uint8_t *)&v28, 2u);
    }
    goto LABEL_22;
  }
  if (!v10)
  {
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v11[2](v11, v23);

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v28);
  unsigned int v13 = ServiceMap;
  if ((v14 & 0x8000000000000000) != 0)
  {
    unsigned int v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      unint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v30 = v14;
  uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, &v30);
  if (v18)
  {
    uint64_t v20 = v18[3];
    id v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      char v21 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  std::mutex::unlock(v13);
  id v19 = 0;
  char v21 = 1;
LABEL_14:
  if (v29) {
    sub_10004D2C8((std::__shared_weak_count *)v29);
  }
  if (v20)
  {
    id v24 = [v10 slotID];
    if (v24 == (id)2) {
      uint64_t v25 = 2;
    }
    else {
      uint64_t v25 = v24 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t, BOOL, uint64_t))(*(void *)v20 + 168))(v20, v25, v7, v8);
    v11[2](v11, 0);
    if ((v21 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v26 = v29;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v28) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for save call waiting value", (uint8_t *)&v28, 2u);
    }
    id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v11[2](v11, v27);

    if ((v21 & 1) == 0) {
      goto LABEL_21;
    }
  }
LABEL_22:
}

- (void)saveCallForwardingValue:(id)a3 value:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, id))a5;
  if (v10)
  {
    if (!v8)
    {
      id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, v22);

      goto LABEL_46;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v12 = ServiceMap;
    if (v13 < 0)
    {
      unint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    v47[0] = (void *)v13;
    unsigned int v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)v47);
    if (v17)
    {
      uint64_t v18 = v17[3];
      id v19 = (std::__shared_weak_count *)v17[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v20 = v19;
        sub_10004D2C8(v19);
        char v36 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v18)
        {
          long long v35 = v20;
          id v23 = [v8 slotID];
          if (v23 == (id)2) {
            uint64_t v24 = 2;
          }
          else {
            uint64_t v24 = v23 == (id)1;
          }
          uint64_t v25 = [v9 noReplyTime];
          unsigned __int8 v26 = [v25 intValue];

          unsigned __int8 v49 = v26;
          v47[0] = 0;
          v47[1] = 0;
          uint64_t v48 = 0;
          id v27 = [v9 saveNumber];
          if (v27)
          {
            uint64_t v20 = [v9 saveNumber];
            uint64_t v28 = (char *)[(std::__shared_weak_count *)v20 UTF8String];
          }
          else
          {
            uint64_t v28 = "";
          }
          sub_100058DB0(v47, v28);
          if (v27) {

          }
          uint64_t v46 = 0;
          long long v44 = 0u;
          long long v45 = 0u;
          *(_OWORD *)uint64_t v42 = 0u;
          *(_OWORD *)std::string __p = 0u;
          *(_OWORD *)uint64_t v40 = 0u;
          long long v41 = 0u;
          *(_OWORD *)CSIPhoneNumber buf = 0u;
          long long v39 = 0u;
          CSIPhoneNumber::CSIPhoneNumber();
          unsigned __int8 v37 = [v9 enabled];
          id v31 = [v9 saveNumber];
          if (v31) {
            id v32 = buf;
          }
          else {
            id v32 = 0;
          }
          uint64_t v33 = [v9 noReplyTime];
          if (v33) {
            unint64_t v34 = &v49;
          }
          else {
            unint64_t v34 = 0;
          }
          (*(void (**)(uint64_t, uint64_t, unsigned __int8 *, uint8_t *, unsigned __int8 *, id, id))(*(void *)v18 + 96))(v18, v24, &v37, v32, v34, [v9 reason], objc_msgSend(v9, "clss"));

          v10[2](v10, 0);
          uint64_t v20 = v35;
          if (SHIBYTE(v44) < 0) {
            operator delete(__p[1]);
          }
          if (SHIBYTE(__p[0]) < 0) {
            operator delete(v42[0]);
          }
          if (SBYTE7(v41) < 0) {
            operator delete(v40[0]);
          }
          if (SHIBYTE(v39) < 0) {
            operator delete(*(void **)&buf[8]);
          }
          if (SHIBYTE(v48) < 0) {
            operator delete(v47[0]);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          long long v29 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)CSIPhoneNumber buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for save call forwarding value", buf, 2u);
          }
          id v30 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v10[2](v10, v30);
        }
        if ((v36 & 1) == 0) {
          sub_10004D2C8(v20);
        }
        goto LABEL_46;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v12);
    uint64_t v20 = 0;
    char v36 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v21 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for save call forwarding request", buf, 2u);
  }
LABEL_46:
}

- (void)saveCallBarringValue:(id)a3 facility:(int)a4 callClass:(int)a5 enabled:(BOOL)a6 password:(id)a7 completion:(id)a8
{
  uint64_t v11 = *(void *)&a5;
  uint64_t v12 = *(void *)&a4;
  id v14 = a3;
  BOOL v36 = a6;
  id v15 = a7;
  unsigned int v16 = (void (**)(id, id))a8;
  if (v16)
  {
    if (!v14)
    {
      id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v16[2](v16, v28);

      goto LABEL_27;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p);
    uint64_t v18 = ServiceMap;
    if ((v19 & 0x8000000000000000) != 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        unint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v37 = v19;
    id v23 = sub_10004D37C(&v18[1].__m_.__sig, &v37);
    if (v23)
    {
      uint64_t v25 = v23[3];
      uint64_t v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
LABEL_14:
        if (v34) {
          sub_10004D2C8(v34);
        }
        if (v25)
        {
          id v29 = [v14 slotID];
          if (v29 == (id)2) {
            uint64_t v30 = 2;
          }
          else {
            uint64_t v30 = v29 == (id)1;
          }
          std::string __p = 0;
          unint64_t v34 = 0;
          uint64_t v35 = 0;
          sub_100058DB0(&__p, (char *)[v15 UTF8String]);
          (*(void (**)(uint64_t, uint64_t, BOOL *, void **, uint64_t, uint64_t))(*(void *)v25 + 144))(v25, v30, &v36, &__p, v12, v11);
          v16[2](v16, 0);
          if (SHIBYTE(v35) < 0) {
            operator delete(__p);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v31 = v34;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for save call barring value", (uint8_t *)&__p, 2u);
          }
          id v32 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v16[2](v16, v32);
        }
        if ((v26 & 1) == 0) {
          sub_10004D2C8(v24);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v24 = 0;
    char v26 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v27 = v34;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Invalid completion handler for save call barring request", (uint8_t *)&__p, 2u);
  }
LABEL_27:
}

- (void)saveCallingLineIdRestrictionValue:(id)a3 restrictionValue:(int)a4 completion:(id)a5
{
  id v8 = a3;
  int v28 = a4;
  id v9 = (void (**)(id, id))a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for save calling line ID restriction request", (uint8_t *)&v26, 2u);
    }
    goto LABEL_22;
  }
  if (!v8)
  {
    id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v9[2](v9, v21);

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v26);
  uint64_t v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v29 = v12;
  unsigned int v16 = sub_10004D37C(&v11[1].__m_.__sig, &v29);
  if (v16)
  {
    uint64_t v18 = v16[3];
    unsigned int v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  unsigned int v17 = 0;
  char v19 = 1;
LABEL_14:
  if (v27) {
    sub_10004D2C8((std::__shared_weak_count *)v27);
  }
  if (v18)
  {
    id v22 = [v8 slotID];
    if (v22 == (id)2) {
      uint64_t v23 = 2;
    }
    else {
      uint64_t v23 = v22 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t, int *))(*(void *)v18 + 224))(v18, v23, &v28);
    v9[2](v9, 0);
    if ((v19 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v17);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v24 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for save calling line ID restriction value", (uint8_t *)&v26, 2u);
    }
    id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v9[2](v9, v25);

    if ((v19 & 1) == 0) {
      goto LABEL_21;
    }
  }
LABEL_22:
}

- (void)isUnconditionalCallForwardingActive:(id)a3 completion:(id)a4
{
  id v6 = a3;
  BOOL v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
    id v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unsigned int v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          id v22 = objc_retainBlock(v7);
          v28[0] = off_1019E91C0;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 112))(v16, v21, v28);
          sub_1000F25E0(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SettingsInterface for unconditional call forwarding active query", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unsigned int v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for unconditional call forwarding active query", (uint8_t *)&v25, 2u);
  }
LABEL_26:
}

- (void)copyEmergencyMode:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v20);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v22 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v22);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v13)
        {
          uint64_t v16 = self;
          id v17 = objc_retainBlock(v4);
          v23[0] = off_1019EA178;
          v23[1] = v16;
          v23[2] = v17;
          v23[3] = v23;
          (*(void (**)(uint64_t, void *))(*(void *)v13 + 80))(v13, v23);
          sub_100471854(v23);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v18 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v20) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find EmergencyManagerInterface for getting Emergency Mode", (uint8_t *)&v20, 2u);
          }
          id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void, id))v4 + 2))(v4, 0, 0, v19);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v15 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v20) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for Emergency Mode query", (uint8_t *)&v20, 2u);
  }
LABEL_21:
}

- (void)getAllEmergencyNumbers:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v20 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v20);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v13)
        {
          uint64_t v16 = (std::__shared_weak_count *)objc_retainBlock(v4);
          *(void *)CSIPhoneNumber buf = off_1019EA208;
          unint64_t v22 = v16;
          uint64_t v23 = buf;
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v13 + 128))(v13, buf);
          sub_1005B1BA4(buf);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v17 = v22;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)CSIPhoneNumber buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "EmergencyNumbersInterface does not exist", buf, 2u);
          }
          NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
          CFStringRef v25 = @"EmergencyNumbersInterface does not exist";
          uint64_t v18 = +[NSDictionary dictionaryWithObjects:&v25 forKeys:&v24 count:1];
          id v19 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:v18];

          (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v19);
        }
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v15 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for getAllEmergencyNumbers:", buf, 2u);
  }
LABEL_21:
}

- (void)requestBootstrapService:(id)a3
{
  id v4 = (void (**)(id, void *))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v15 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&v20, 2u);
    }
    goto LABEL_19;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v20);
  id v6 = ServiceMap;
  unint64_t v7 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = (const char *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v22);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_12:
  if (v21) {
    sub_10004D2C8((std::__shared_weak_count *)v21);
  }
  if (!v13)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v16 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find controller for requestBootstrapService", (uint8_t *)&v20, 2u);
    }
    id v17 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v4[2](v4, v17);
LABEL_29:

    if (v14) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 952))(v13) & 1) == 0)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Bootstrap is not the default data for requestBootstrapService", (uint8_t *)&v20, 2u);
    }
    goto LABEL_28;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 960))(v13) & 1) == 0)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "requestBootstrapService did not assert", (uint8_t *)&v20, 2u);
    }
LABEL_28:
    id v17 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:49 userInfo:0];
    v4[2](v4, v17);
    goto LABEL_29;
  }
  v4[2](v4, 0);
  if ((v14 & 1) == 0) {
LABEL_18:
  }
    sub_10004D2C8(v12);
LABEL_19:
}

- (void)releaseBootstrapService:(id)a3
{
  id v4 = (void (**)(id, void *))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v15 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&v20, 2u);
    }
    goto LABEL_19;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v20);
  id v6 = ServiceMap;
  unint64_t v7 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v8 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = (const char *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v22);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_12:
  if (v21) {
    sub_10004D2C8((std::__shared_weak_count *)v21);
  }
  if (!v13)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v16 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find controller for releaseBootstrapService", (uint8_t *)&v20, 2u);
    }
    id v17 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v4[2](v4, v17);
LABEL_29:

    if (v14) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 952))(v13) & 1) == 0)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Bootstrap is not the default data for releaseBootstrapService", (uint8_t *)&v20, 2u);
    }
    goto LABEL_28;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 968))(v13) & 1) == 0)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "releaseBootstrapService did not deassert", (uint8_t *)&v20, 2u);
    }
LABEL_28:
    id v17 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:49 userInfo:0];
    v4[2](v4, v17);
    goto LABEL_29;
  }
  v4[2](v4, 0);
  if ((v14 & 1) == 0) {
LABEL_18:
  }
    sub_10004D2C8(v12);
LABEL_19:
}

- (void)getBootstrapState:(id)a3
{
  id v4 = (void (**)(id, id, void))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v19);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v21 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v21);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v13)
        {
          id v16 = objc_alloc_init((Class)CTBootstrapState);
          [v16 setBootstrapStatus:0];
          uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
          if ((v17 - 1) < 2) {
            [v16 setBootstrapStatus:v17];
          }
          v4[2](v4, v16, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v18 = v20;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v19) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find controller for getBootstrapState", (uint8_t *)&v19, 2u);
          }
          id v16 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, id, id))v4)[2](v4, 0, v16);
        }

        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v15 = v20;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v19) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&v19, 2u);
  }
LABEL_23:
}

- (void)isEmergencyNumber:(id)a3 number:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unsigned int v10 = (void (**)(id, uint64_t, void))a5;
  if (v10)
  {
    if (v9)
    {
      if (!v8)
      {
        [(CTXPCClientHandler *)self getLogContext];
        unint64_t v22 = *(NSObject **)&v35[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v35);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)uint64_t v35 = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "isEmergencyNumber: context is null! Check against all contexts!", v35, 2u);
        }
        uint64_t v12 = 3;
        goto LABEL_35;
      }
      uint64_t v11 = (capabilities::ct *)[v8 slotID];
      if (v11 == (capabilities::ct *)2) {
        uint64_t v12 = 2;
      }
      else {
        uint64_t v12 = v11 == (capabilities::ct *)1;
      }
      if (!capabilities::ct::supportsThumperService(v11))
      {
LABEL_35:
        [(CTXPCClientHandler *)self registry];
        uint64_t v23 = sub_100781420((uint64_t)v28, v9, v12, 0);
        if (v29) {
          sub_10004D2C8(v29);
        }
        [(CTXPCClientHandler *)self getLogContext];
        NSErrorUserInfoKey v24 = *(NSObject **)&v35[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v35);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
        {
          uint64_t v25 = subscriber::asString();
          char v26 = "FALSE";
          if (v23) {
            char v26 = "TRUE";
          }
          *(_DWORD *)uint64_t v35 = 136315394;
          *(void *)&void v35[4] = v26;
          *(_WORD *)&v35[12] = 2080;
          *(void *)&v35[14] = v25;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "isEmergencyNumber: %s on %s.", v35, 0x16u);
        }
        v10[2](v10, v23, 0);
        goto LABEL_42;
      }
      uint64_t v13 = [v8 uuid];

      if (v13)
      {
        memset(v35, 0, sizeof(v35));
        [(CTXPCClientHandler *)self registry];
        char v14 = [v8 uuid];
        sub_1005B09D4(v14, (CFUUIDRef *)&buf);
        PersonalityIdFromUuid();
        sub_10012577C((const void **)&buf);

        if (v31) {
          sub_10004D2C8(v31);
        }
        std::string __p = 0;
        id v31 = 0;
        uint64_t v32 = 0;
        [(CTXPCClientHandler *)self registry];
        PersonalityIdFromSlotIdEx();
        if (*(void *)&buf_4[4]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf_4[4]);
        }
        [(CTXPCClientHandler *)self getLogContext];
        unsigned int v15 = *(NSObject **)&buf_4[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          uint64_t v16 = v35[23];
          if ((v35[23] & 0x80u) != 0) {
            uint64_t v16 = *(void *)&v35[8];
          }
          uint64_t v17 = v35;
          if ((v35[23] & 0x80u) != 0) {
            uint64_t v17 = *(uint8_t **)v35;
          }
          if (v16) {
            uint64_t v18 = (const char *)v17;
          }
          else {
            uint64_t v18 = "<invalid>";
          }
          int buf = 136315394;
          *(void *)buf_4 = v18;
          *(_WORD *)&buf_4[8] = 2080;
          *(void *)&buf_4[10] = "<invalid>";
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "Checking to skip data sim on secondary device. contextPersona: %s, curVoicePersona: %s", (uint8_t *)&buf, 0x16u);
        }
        if (sub_10001D294(v35, (unsigned __int8 *)&__p))
        {
          if (SHIBYTE(v32) < 0) {
            operator delete(__p);
          }
          if ((char)v35[23] < 0) {
            operator delete(*(void **)v35);
          }
          goto LABEL_35;
        }
        v10[2](v10, 0, 0);
        if (SHIBYTE(v32) < 0) {
          operator delete(__p);
        }
        if ((char)v35[23] < 0) {
          operator delete(*(void **)v35);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        unint64_t v27 = *(NSObject **)&v35[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v35);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v35 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "isEmergencyNumber: uuid is NULL!", v35, 2u);
        }
        v10[2](v10, 0, 0);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      unint64_t v20 = *(NSObject **)&v35[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v35);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v35 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid number input parameter handler sent in checking emergency number", v35, 2u);
      }
      id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      ((void (**)(id, uint64_t, id))v10)[2](v10, 0, v21);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = *(NSObject **)&v35[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v35);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v35 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler sent in checking emergency number", v35, 2u);
    }
  }
LABEL_42:
}

- (void)isEmergencyNumberWithWhitelistIncluded:(id)a3 number:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unsigned int v10 = (void (**)(id, uint64_t, void))a5;
  if (v10)
  {
    if (v9)
    {
      if (!v8)
      {
        [(CTXPCClientHandler *)self getLogContext];
        unint64_t v22 = *(NSObject **)&v35[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v35);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)uint64_t v35 = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "isEmergencyNumberWithWhitelistIncluded: context is null! Check against all contexts!", v35, 2u);
        }
        uint64_t v12 = 3;
        goto LABEL_35;
      }
      uint64_t v11 = (capabilities::ct *)[v8 slotID];
      if (v11 == (capabilities::ct *)2) {
        uint64_t v12 = 2;
      }
      else {
        uint64_t v12 = v11 == (capabilities::ct *)1;
      }
      if (!capabilities::ct::supportsThumperService(v11))
      {
LABEL_35:
        [(CTXPCClientHandler *)self registry];
        uint64_t v23 = sub_100781420((uint64_t)v28, v9, v12, 1u);
        if (v29) {
          sub_10004D2C8(v29);
        }
        [(CTXPCClientHandler *)self getLogContext];
        NSErrorUserInfoKey v24 = *(NSObject **)&v35[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v35);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
        {
          uint64_t v25 = subscriber::asString();
          char v26 = "FALSE";
          if (v23) {
            char v26 = "TRUE";
          }
          *(_DWORD *)uint64_t v35 = 136315394;
          *(void *)&void v35[4] = v26;
          *(_WORD *)&v35[12] = 2080;
          *(void *)&v35[14] = v25;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "isEmergencyNumberWithWhitelistIncluded: %s on %s", v35, 0x16u);
        }
        v10[2](v10, v23, 0);
        goto LABEL_42;
      }
      uint64_t v13 = [v8 uuid];

      if (v13)
      {
        memset(v35, 0, sizeof(v35));
        [(CTXPCClientHandler *)self registry];
        char v14 = [v8 uuid];
        sub_1005B09D4(v14, (CFUUIDRef *)&buf);
        PersonalityIdFromUuid();
        sub_10012577C((const void **)&buf);

        if (v31) {
          sub_10004D2C8(v31);
        }
        std::string __p = 0;
        id v31 = 0;
        uint64_t v32 = 0;
        [(CTXPCClientHandler *)self registry];
        PersonalityIdFromSlotIdEx();
        if (*(void *)&buf_4[4]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf_4[4]);
        }
        [(CTXPCClientHandler *)self getLogContext];
        unsigned int v15 = *(NSObject **)&buf_4[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          uint64_t v16 = v35[23];
          if ((v35[23] & 0x80u) != 0) {
            uint64_t v16 = *(void *)&v35[8];
          }
          uint64_t v17 = v35;
          if ((v35[23] & 0x80u) != 0) {
            uint64_t v17 = *(uint8_t **)v35;
          }
          if (v16) {
            uint64_t v18 = (const char *)v17;
          }
          else {
            uint64_t v18 = "<invalid>";
          }
          int buf = 136315394;
          *(void *)buf_4 = v18;
          *(_WORD *)&buf_4[8] = 2080;
          *(void *)&buf_4[10] = "<invalid>";
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "Checking to skip data sim on secondary device..contextPersona: %s, curPersona: %s", (uint8_t *)&buf, 0x16u);
        }
        if (sub_10001D294(v35, (unsigned __int8 *)&__p))
        {
          if (SHIBYTE(v32) < 0) {
            operator delete(__p);
          }
          if ((char)v35[23] < 0) {
            operator delete(*(void **)v35);
          }
          goto LABEL_35;
        }
        v10[2](v10, 0, 0);
        if (SHIBYTE(v32) < 0) {
          operator delete(__p);
        }
        if ((char)v35[23] < 0) {
          operator delete(*(void **)v35);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        unint64_t v27 = *(NSObject **)&v35[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v35);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v35 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "isEmergencyNumberWithWhitelistIncluded: uuid is NULL!", v35, 2u);
        }
        v10[2](v10, 0, 0);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      unint64_t v20 = *(NSObject **)&v35[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v35);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v35 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid number input parameter handler sent in checking emergency number with allowList", v35, 2u);
      }
      id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      ((void (**)(id, uint64_t, id))v10)[2](v10, 0, v21);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = *(NSObject **)&v35[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v35);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v35 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler sent in checking emergency number with allowList", v35, 2u);
    }
  }
LABEL_42:
}

- (void)shouldShowUserWarningWhenDialingCallOnContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, uint64_t, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
      id v9 = ServiceMap;
      if ((v10 & 0x8000000000000000) != 0)
      {
        uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          unint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v28 = v10;
      char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v28);
      if (v14)
      {
        uint64_t v16 = v14[3];
        unsigned int v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
LABEL_16:
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          if (v16)
          {
            id v21 = [v6 slotID];
            if (v21 == (id)2) {
              uint64_t v22 = 2;
            }
            else {
              uint64_t v22 = v21 == (id)1;
            }
            uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v16 + 32))(v16, v22);
            [(CTXPCClientHandler *)self getLogContext];
            NSErrorUserInfoKey v24 = *((void *)&buf + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
            {
              uint64_t v25 = "No need to show";
              if (v23) {
                uint64_t v25 = "Show";
              }
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v25;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "%s warning alert to the user.", (uint8_t *)&buf, 0xCu);
            }
            v7[2](v7, v23, 0);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            char v26 = *((void *)&buf + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find CallController when checking if we should show user a warning alert when dialing on this context!", (uint8_t *)&buf, 2u);
            }
            id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            ((void (**)(id, uint64_t, id))v7)[2](v7, 0, v27);
          }
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          goto LABEL_32;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      unsigned int v15 = 0;
      char v17 = 1;
      goto LABEL_16;
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v20 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Nil context sent in checking if we should show user a warning alert when dialing on this context.", (uint8_t *)&buf, 2u);
    }
    ((void (**)(id, uint64_t, id))v7)[2](v7, 0, v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler sent in checking if we should show user a warning alert when dialing on this context.", (uint8_t *)&buf, 2u);
    }
  }
LABEL_32:
}

- (void)shouldShowBrandedCallingInfo:(id)a3
{
  id v4 = (void (**)(id, uint64_t, void))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v15 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler sent in checking if we should show user branded calling information on this context.", (uint8_t *)&buf, 2u);
    }
    goto LABEL_45;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
  id v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v26);
  if (!v11)
  {
    uint64_t v13 = 0;
    goto LABEL_11;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12)
  {
LABEL_11:
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
LABEL_12:
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (v13)
  {
    [(CTXPCClientHandler *)self registry];
    subscriber::makeSimSlotRange();
    if (v27) {
      sub_10004D2C8(v27);
    }
    uint64_t v16 = (unsigned int *)*((void *)&buf + 1);
    char v17 = (unsigned int *)buf;
    if ((void)buf == *((void *)&buf + 1)) {
      goto LABEL_34;
    }
    uint64_t v18 = v29;
    while ((v18(*v17) & 1) == 0)
    {
      if (++v17 == v16)
      {
        char v17 = v16;
        break;
      }
    }
    id v19 = (unsigned int *)*((void *)&buf + 1);
    if (v17 == *((unsigned int **)&buf + 1))
    {
LABEL_34:
      uint64_t v20 = 0;
    }
    else
    {
      LOBYTE(v20) = 0;
      do
      {
        if (v20) {
          uint64_t v20 = 1;
        }
        else {
          uint64_t v20 = (*(uint64_t (**)(uint64_t, void))(*(void *)v13 + 40))(v13, *v17);
        }
        id v21 = v17 + 1;
        char v17 = v16;
        if (v21 != v16)
        {
          char v17 = v21;
          while ((v18(*v17) & 1) == 0)
          {
            if (++v17 == v16)
            {
              char v17 = v16;
              break;
            }
          }
        }
      }
      while (v17 != v19);
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      uint64_t v23 = "No need to show";
      if (v20) {
        uint64_t v23 = "Show";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "%s branded calling information to the user.", (uint8_t *)&buf, 0xCu);
    }
    v4[2](v4, v20, 0);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    NSErrorUserInfoKey v24 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CallController when checking if we should show user branded calling information", (uint8_t *)&buf, 2u);
    }
    id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, uint64_t, id))v4)[2](v4, 0, v25);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
LABEL_45:
}

- (void)setShouldShowBrandedCallingInfo:(BOOL)a3 completion:(id)a4
{
  BOOL v4 = a3;
  id v6 = (void (**)(id, void))a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
  id v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    unsigned int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v26);
  if (v13)
  {
    uint64_t v15 = v13[3];
    char v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  char v14 = 0;
  char v16 = 1;
LABEL_9:
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (v15)
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v17 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      uint64_t v18 = "disable";
      if (v4) {
        uint64_t v18 = "Enable";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "%s showing branded calling information to the user.", (uint8_t *)&buf, 0xCu);
    }
    [(CTXPCClientHandler *)self registry];
    subscriber::makeSimSlotRange();
    if (v27) {
      sub_10004D2C8(v27);
    }
    id v19 = (unsigned int *)*((void *)&buf + 1);
    uint64_t v20 = (unsigned int *)buf;
    if ((void)buf != *((void *)&buf + 1))
    {
      id v21 = v29;
      while ((v21(*v20) & 1) == 0)
      {
        if (++v20 == v19)
        {
          uint64_t v20 = v19;
          break;
        }
      }
      uint64_t v22 = (unsigned int *)*((void *)&buf + 1);
LABEL_24:
      while (v20 != v22)
      {
        (*(void (**)(uint64_t, BOOL, void))(*(void *)v15 + 48))(v15, v4, *v20);
        uint64_t v23 = v20 + 1;
        uint64_t v20 = v19;
        if (v23 != v19)
        {
          uint64_t v20 = v23;
          while ((v21(*v20) & 1) == 0)
          {
            if (++v20 == v19)
            {
              uint64_t v20 = v19;
              goto LABEL_24;
            }
          }
        }
      }
    }
    v6[2](v6, 0);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    NSErrorUserInfoKey v24 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CallController when enabling/disabling showing user branded calling information", (uint8_t *)&buf, 2u);
    }
    id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v6)[2](v6, v25);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

- (void)getCallCapabilities:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_36;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
    unint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v33 = v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v33);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
LABEL_14:
    uint64_t v20 = (capabilities::ct *)*((void *)&buf + 1);
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    if (!v16)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v25 = *((void *)&buf + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find CallController when getting call capabilities!", (uint8_t *)&buf, 2u);
      }
      id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v7[2](v7, 0, v26);

      goto LABEL_34;
    }
    if (capabilities::ct::supportsThumperService(v20))
    {
      id v21 = [v6 uuid];
      BOOL v22 = v21 == 0;

      if (v22)
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v31 = *((void *)&buf + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "getCallCapabilities: uuid is NULL!", (uint8_t *)&buf, 2u);
        }
        v7[2](v7, 0, 0);
        goto LABEL_34;
      }
      long long buf = 0uLL;
      uint64_t v37 = 0;
      [(CTXPCClientHandler *)self registry];
      uint64_t v23 = [v6 uuid];
      sub_1005B09D4(v23, (CFUUIDRef *)&v32);
      PersonalityIdFromUuid();
      sub_10012577C(&v32);

      if (v34) {
        sub_10004D2C8(v34);
      }
      [(CTXPCClientHandler *)self registry];
      uint64_t v24 = SlotIdFromPersonalityIdEx();
      if (v34) {
        sub_10004D2C8(v34);
      }
      if (SHIBYTE(v37) < 0) {
        operator delete((void *)buf);
      }
    }
    else
    {
      id v27 = [v6 slotID];
      if (v27 == (id)2) {
        uint64_t v24 = 2;
      }
      else {
        uint64_t v24 = v27 == (id)1;
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v28 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
    {
      uint64_t v29 = subscriber::asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, "Querying call capabilities for slot %s", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v30 = objc_retainBlock(v7);
    v35[0] = off_101A055E0;
    v35[1] = v30;
    v35[3] = v35;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 16))(v16, v24, v35);
    sub_10078369C(v35);
LABEL_34:
    if ((v17 & 1) == 0) {
      sub_10004D2C8(v15);
    }
    goto LABEL_36;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v18 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler sent when getting call capabilities.", (uint8_t *)&buf, 2u);
  }
LABEL_36:
}

- (void)getOperatorMultiPartyCallCountMaximum:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void *, id))a4;
  if (v7)
  {
    id v8 = CTEnhancedLinkQualityMetric_ptr;
    unint64_t v9 = +[NSNumber numberWithInt:0];
    if (!v6)
    {
      id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v9, v23);

LABEL_47:
      goto LABEL_48;
    }
    id v10 = [v6 slotID];
    if (v10 == (id)2) {
      uint64_t v11 = 2;
    }
    else {
      uint64_t v11 = v10 == (id)1;
    }
    uint64_t v40 = 0;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unsigned int v13 = ServiceMap;
    if ((v14 & 0x8000000000000000) != 0)
    {
      uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        unint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v43 = v14;
    uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, &v43);
    if (v18)
    {
      uint64_t v20 = v18[3];
      id v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        id v8 = CTEnhancedLinkQualityMetric_ptr;
        sub_10004D2C8(v19);
        char v21 = 0;
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    id v19 = 0;
    char v21 = 1;
LABEL_17:
    (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v20 + 96))(&v39, v20, v11, 2, @"MaxMultiPartyCalls", 0, 0);
    sub_1000842D0(&v40, &v39);
    sub_1000577C4(&v39);
    if ((v21 & 1) == 0) {
      sub_10004D2C8(v19);
    }
    if (v42) {
      sub_10004D2C8(v42);
    }
    uint64_t v24 = v40;

    if (v40) {
      id v25 = sub_100081E58;
    }
    else {
      id v25 = 0;
    }
    if (v25 && [v24 intValue])
    {
      id v26 = 0;
LABEL_45:
      v7[2](v7, v24, v26);
LABEL_46:

      sub_1000570E8((const void **)&v40);
      unint64_t v9 = v24;
      goto LABEL_47;
    }
    [(CTXPCClientHandler *)self registry];
    id v27 = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    unint64_t v28 = v27;
    if ((v29 & 0x8000000000000000) != 0)
    {
      uint64_t v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v31 = 5381;
      do
      {
        unint64_t v29 = v31;
        unsigned int v32 = *v30++;
        uint64_t v31 = (33 * v31) ^ v32;
      }
      while (v32);
    }
    std::mutex::lock(v27);
    unint64_t v43 = v29;
    unint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, &v43);
    if (v33)
    {
      uint64_t v35 = v33[3];
      unint64_t v34 = (std::__shared_weak_count *)v33[4];
      if (v34)
      {
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v28);
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v34);
        char v36 = 0;
        goto LABEL_35;
      }
    }
    else
    {
      uint64_t v35 = 0;
    }
    std::mutex::unlock(v28);
    unint64_t v34 = 0;
    char v36 = 1;
LABEL_35:
    if (v42) {
      sub_10004D2C8(v42);
    }
    if (v35)
    {
      uint64_t v37 = objc_msgSend(v8[245], "numberWithInt:", (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v35 + 24))(v35, v11));

      id v26 = 0;
      uint64_t v24 = (void *)v37;
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      long long v38 = v42;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Could not find CallController when getting operatorMultiPartyCallCountMaximum!", buf, 2u);
      }
      id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v7[2](v7, v24, v26);
    }
    if ((v36 & 1) == 0) {
      sub_10004D2C8(v34);
    }
    if (!v35) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  [(CTXPCClientHandler *)self getLogContext];
  BOOL v22 = v42;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler sent when getting operatorMultiPartyCallCountMaximum.", buf, 2u);
  }
LABEL_48:
}

- (void)copyPriVersion:(id)a3 completion:(id)a4
{
  id v6 = a3;
  unint64_t v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v25);
    unint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v10;
    unint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v27);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          id v20 = [v6 slotID];
          if (v20 == (id)2) {
            uint64_t v21 = 2;
          }
          else {
            uint64_t v21 = v20 == (id)1;
          }
          BOOL v22 = objc_retainBlock(v7);
          v28[0] = off_101A08DB0;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 136))(v16, v21, v28);
          sub_1007B3488(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find ActivationInterface for getting PRI version", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for PRI version query", (uint8_t *)&v25, 2u);
  }
LABEL_26:
}

- (void)getActivationPolicyState:(id)a3
{
  BOOL v4 = (void (**)(id, void, void *))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v20);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v22 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v22);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
LABEL_12:
    if (v21) {
      sub_10004D2C8(v21);
    }
    if (!v13)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v19 = v21;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v20) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find ActivationInterface for activation policy status query", (uint8_t *)&v20, 2u);
      }
      uint64_t v16 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v4[2](v4, 0, v16);
      goto LABEL_24;
    }
    uint64_t v16 = objc_opt_new();
    [v16 setCarrierLock:0];
    int v17 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 152))(v13);
    if (v17 == 1)
    {
      uint64_t v18 = 1;
    }
    else
    {
      if (v17 != 2)
      {
LABEL_23:
        ((void (**)(id, void *, void *))v4)[2](v4, v16, 0);
LABEL_24:

        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_26;
      }
      uint64_t v18 = 2;
    }
    [v16 setCarrierLock:v18];
    goto LABEL_23;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v20) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for activation policy status query", (uint8_t *)&v20, 2u);
  }
LABEL_26:
}

- (void)isFactoryDebugEnabled:(id)a3
{
  BOOL v4 = (void (**)(id, void *, void))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v18);
    id v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v20 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v20);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        if (v19) {
          sub_10004D2C8(v19);
        }
        if (v13)
        {
          uint64_t v16 = +[NSNumber numberWithBool:(*(uint64_t (**)(uint64_t))(*(void *)v13 + 96))(v13)];
          v4[2](v4, v16, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          int v17 = v19;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v18) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not find activation handler to query the factory debug state", (uint8_t *)&v18, 2u);
          }
          uint64_t v16 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, void *, void *))v4)[2](v4, 0, v16);
        }

        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v15 = v19;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v18) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid completion handler for factory debug state query", (uint8_t *)&v18, 2u);
  }
LABEL_21:
}

- (void)fetchBasebandTicket:(BOOL)a3 withCompletion:(id)a4
{
  BOOL v4 = a3;
  id v6 = a4;
  if (v6)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v21);
    id v8 = ServiceMap;
    if ((v9 & 0x8000000000000000) != 0)
    {
      unsigned int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        unint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v23);
    if (v13)
    {
      uint64_t v15 = v13[3];
      char v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_12:
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v15)
        {
          id v18 = objc_retainBlock(v6);
          v24[0] = off_101A08E40;
          v24[1] = v18;
          uint64_t v24[3] = v24;
          (*(void (**)(uint64_t, BOOL, void *))(*(void *)v15 + 104))(v15, v4, v24);
          sub_100060644(v24);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v19 = v22;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v21) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find activation handler to fetch baseband ticket", (uint8_t *)&v21, 2u);
          }
          unint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void *))v6 + 2))(v6, 0, v20);
        }
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    char v14 = 0;
    char v16 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  int v17 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v21) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler to fetch baseband ticket", (uint8_t *)&v21, 2u);
  }
LABEL_21:
}

- (void)setVoLTEAudioCodec:(id)a3 codecInfo:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  if (v10)
  {
    if (v8)
    {
      if (v9)
      {
        [(CTXPCClientHandler *)self registry];
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
        unsigned int v12 = ServiceMap;
        if ((v13 & 0x8000000000000000) != 0)
        {
          char v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v15 = 5381;
          do
          {
            unint64_t v13 = v15;
            unsigned int v16 = *v14++;
            uint64_t v15 = (33 * v15) ^ v16;
          }
          while (v16);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v35 = v13;
        int v17 = sub_10004D37C(&v12[1].__m_.__sig, &v35);
        if (v17)
        {
          uint64_t v18 = v17[3];
          id v19 = (std::__shared_weak_count *)v17[4];
          if (v19)
          {
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v12);
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v30 = v19;
            sub_10004D2C8(v19);
            char v31 = 0;
LABEL_20:
            if (v33) {
              sub_10004D2C8(v33);
            }
            if (v18)
            {
              id v24 = [v8 slotID];
              int v25 = v24 == (id)1;
              if (v24 == (id)2) {
                int v25 = 2;
              }
              unsigned int v29 = v25;
              *(void *)long long buf = 0;
              unint64_t v33 = 0;
              uint64_t v34 = 0;
              [v9 callId];
              [v9 codec];
              [v9 amrMode];
              [v9 evsBandwidth];
              [v9 evsBitrate];
              [v9 sampleRate];
              [v9 i2SClockRate];
              AudioCodecInfo::AudioCodecInfo();
              id v26 = objc_retainBlock(v10);
              v36[0] = off_101A0A3A0;
              v36[1] = v26;
              v36[3] = v36;
              (*(void (**)(uint64_t, void, uint8_t *, void *))(*(void *)v18 + 416))(v18, v29, buf, v36);
              sub_10001C9D4(v36);
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              unint64_t v27 = v33;
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Could not find DataServiceInterface for setting VoLTE codec", buf, 2u);
              }
              id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:6 userInfo:0];
              (*((void (**)(id, id))v10 + 2))(v10, v28);
            }
            if ((v31 & 1) == 0) {
              sub_10004D2C8(v30);
            }
            goto LABEL_31;
          }
        }
        else
        {
          uint64_t v18 = 0;
        }
        std::mutex::unlock(v12);
        uint64_t v30 = 0;
        char v31 = 1;
        goto LABEL_20;
      }
      [(CTXPCClientHandler *)self getLogContext];
      unint64_t v23 = v33;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid codec info for setting VoLTE codec", buf, 2u);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v21 = v33;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid context for setting VoLTE codec", buf, 2u);
      }
    }
    id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, id))v10 + 2))(v10, v22);

    goto LABEL_31;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v20 = v33;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting VoLTE codec", buf, 2u);
  }
LABEL_31:
}

- (void)getDescriptorsForDomain:(int64_t)a3 completion:(id)a4
{
  id v9 = (void (**)(id, void *, void))a4;
  if (a3 == 1)
  {
    id v6 = [(CTXPCClientHandler *)self dataProviderDelegate];
    unint64_t v7 = [v6 subscriptionInfo];

    id v8 = sub_1005AF608(v7);
    v9[2](v9, v8, 0);
  }
  else
  {
    unint64_t v7 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(id, void *, void *))v9)[2](v9, 0, v7);
  }
}

- (void)ping:(id)a3
{
}

- (void)getEvolvedSubscriptionLabelID:(id)a3 withCallback:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v22);
  id v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v21);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_9:
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (v16)
  {
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_1007EFA04;
    v19[3] = &unk_101A0BEE8;
    id v20 = v7;
    id v24 = 0;
    id v22 = (Registry *)off_101A0BFA8;
    unint64_t v23 = objc_retainBlock(v19);
    id v24 = &v22;
    (*(void (**)(uint64_t, id, Registry **))(*(void *)v16 + 280))(v16, v6, &v22);
    sub_1007F0208(&v22);
    uint64_t v18 = v20;
  }
  else
  {
    uint64_t v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
    (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v18);
  }

  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

- (BOOL)isLinkedOnOrAfterVersion:(id)a3
{
  id v4 = a3;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  id v6 = ServiceMap;
  if (v7 < 0)
  {
    id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)__p);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (!v13)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Missing service", buf, 2u);
    }
LABEL_31:
    unsigned __int8 v28 = 1;
    if (v14) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  uint64_t v15 = [(CTXPCClientHandler *)self sdkVersion];
  BOOL v16 = v15 == 0;

  if (v16)
  {
    char v17 = [(CTXPCClientHandler *)self connection];
    uint64_t v18 = v17;
    if (v17)
    {
      [v17 auditToken];
    }
    else
    {
      *(_OWORD *)long long buf = 0u;
      long long v34 = 0u;
    }
    (*(void (**)(void **__return_ptr, uint64_t, uint8_t *))(*(void *)v13 + 120))(__p, v13, buf);
    if (v32 >= 0) {
      id v20 = __p;
    }
    else {
      id v20 = (void **)__p[0];
    }
    unint64_t v21 = +[NSString stringWithUTF8String:v20];
    [(CTXPCClientHandler *)self setSdkVersion:v21];

    if (v32 < 0) {
      operator delete(__p[0]);
    }

    [(CTXPCClientHandler *)self getLogContext];
    id v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v23 = [(CTXPCClientHandler *)self sdkVersion];
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Linked version (%{public}@)", buf, 0xCu);
    }
  }
  id v24 = [(CTXPCClientHandler *)self sdkVersion];
  BOOL v25 = [v24 length] == 0;

  if (v25)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v30 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEBUG, "No SDK version", buf, 2u);
    }
    goto LABEL_31;
  }
  id v26 = +[LSApplicationWorkspace defaultWorkspace];
  unint64_t v27 = [(CTXPCClientHandler *)self sdkVersion];
  unsigned __int8 v28 = [v26 isVersion:v27 greaterThanOrEqualToVersion:v4];

  if ((v14 & 1) == 0) {
LABEL_27:
  }
    sub_10004D2C8(v12);
LABEL_28:

  return v28;
}

- (void)setRegistry:(shared_ptr<const Registry>)a3
{
  p_registry = &self->_registry;
  BOOL v5 = *(Registry **)a3.__ptr_;
  uint64_t v4 = *((void *)a3.__ptr_ + 1);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  cntrl = self->_registry.__cntrl_;
  p_registry->__ptr_ = v5;
  p_registry->__cntrl_ = (__shared_weak_count *)v4;
  if (cntrl) {
    sub_10004D2C8((std::__shared_weak_count *)cntrl);
  }
}

- (void)setConnection:(id)a3
{
}

- (NSString)sdkVersion
{
  return (NSString *)objc_getProperty(self, a2, 32, 1);
}

- (void)setSdkVersion:(id)a3
{
}

- (void)getSIMToolkitMenuForContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  uint64_t v7 = (void (**)(id, id, void))a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
    uint64_t v9 = ServiceMap;
    if (v10 < 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v10;
    char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)__p);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v16)
        {
          id v19 = [v6 slotID];
          if (v19 == (id)2) {
            uint64_t v20 = 2;
          }
          else {
            uint64_t v20 = v19 == (id)1;
          }
          uint64_t v40 = 0;
          long long v38 = 0u;
          long long v39 = 0u;
          *(_OWORD *)long long buf = 0u;
          (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v16 + 24))(buf, v16, v20);
          if ((_BYTE)v40)
          {
            id v31 = v6;
            id v21 = objc_alloc((Class)CTSIMToolkitMenu);
            if ((SBYTE7(v38) & 0x80u) == 0) {
              id v22 = buf;
            }
            else {
              id v22 = *(uint8_t **)buf;
            }
            unint64_t v23 = +[NSString stringWithUTF8String:v22];
            [v21 setTitle:v23];

            id v24 = objc_alloc_init((Class)NSMutableArray);
            if (*((void *)&v39 + 1))
            {
              unsigned int v25 = 1;
              do
              {
                __p[0] = 0;
                __p[1] = 0;
                uint64_t v36 = 0;
                __int16 v34 = 0;
                int v32 = 0;
                int v33 = 0;
                if ((*(unsigned int (**)(uint64_t, uint64_t, void, void **, char *, int *, __int16 *, int *))(*(void *)v16 + 32))(v16, v20, v25 - 1, __p, (char *)&v34 + 1, &v33, &v34, &v32))
                {
                  if (v36 >= 0) {
                    id v26 = __p;
                  }
                  else {
                    id v26 = (void **)__p[0];
                  }
                  unint64_t v27 = +[NSString stringWithUTF8String:v26];
                  [v24 addObject:v27];
                }
                if (SHIBYTE(v36) < 0) {
                  operator delete(__p[0]);
                }
              }
              while (*((void *)&v39 + 1) > (unint64_t)v25++);
            }
            [v21 setSubTitles:v24];
            v7[2](v7, v21, 0);

            id v6 = v31;
          }
          else
          {
            v7[2](v7, 0, 0);
          }
          if ((_BYTE)v40 && SBYTE7(v38) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unsigned int v29 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not find STK Controller", buf, 2u);
          }
          id v30 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, id, id))v7)[2](v7, 0, v30);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_42;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v18 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for SIMToolkit main menu", buf, 2u);
  }
LABEL_42:
}

- (void)selectSIMToolkitMenuItemForContext:(id)a3 index:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void))a5;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v26);
  uint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    char v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v28 = v13;
  char v17 = sub_10004D37C(&v12[1].__m_.__sig, &v28);
  if (v17)
  {
    uint64_t v19 = v17[3];
    uint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v18 = 0;
  char v20 = 1;
LABEL_9:
  if (v27) {
    sub_10004D2C8(v27);
  }
  if (v19)
  {
    id v21 = [v8 slotID];
    id v22 = [v9 unsignedIntValue];
    if (v21 == (id)2) {
      uint64_t v23 = 2;
    }
    else {
      uint64_t v23 = v21 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t, id, void))(*(void *)v19 + 112))(v19, v23, v22, 0);
    if (v10) {
      v10[2](v10, 0);
    }
    if ((v20 & 1) == 0) {
LABEL_18:
    }
      sub_10004D2C8(v18);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v24 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find STK Controller", (uint8_t *)&v26, 2u);
    }
    id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    if (v10) {
      ((void (**)(id, id))v10)[2](v10, v25);
    }

    if ((v20 & 1) == 0) {
      goto LABEL_18;
    }
  }
}

- (void)getSIMToolkitListItemsForContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  uint64_t v7 = (void (**)(id, id, void))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v36;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for SIMToolkit items selection", buf, 2u);
    }
    goto LABEL_28;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  id v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v38 = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, &v38);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_12:
  if (v36) {
    sub_10004D2C8((std::__shared_weak_count *)v36);
  }
  if (v16)
  {
    id v30 = v7;
    id v31 = v6;
    id v19 = [v6 slotID];
    if (v19 == (id)2) {
      uint64_t v20 = 2;
    }
    else {
      uint64_t v20 = v19 == (id)1;
    }
    *(void *)long long buf = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    __int16 v34 = 0;
    LODWORD(v38) = 0;
    int v33 = 0;
    unsigned __int8 v32 = 0;
    id v21 = objc_alloc_init((Class)NSMutableArray);
    uint64_t v22 = 0;
    while ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint8_t *, char *, unint64_t *, __int16 *, int *, unsigned __int8 *))(*(void *)v16 + 56))(v16, v20, v22, buf, (char *)&v34 + 1, &v38, &v34, &v33, &v32))
    {
      id v23 = objc_alloc((Class)CTSIMToolkitItem);
      if (v37 >= 0) {
        id v24 = (Registry *)buf;
      }
      else {
        id v24 = *(Registry **)buf;
      }
      id v25 = +[NSString stringWithUTF8String:v24];
      id v26 = [v23 initWithText:v25 selected:v32];

      [v21 addObject:v26];
      uint64_t v22 = (v22 + 1);
    }
    id v27 = objc_alloc_init((Class)CTSIMToolkitItemList);
    uint64_t v7 = v30;
    id v6 = v31;
    [v27 setItemList:v21];
    v7[2](v7, v27, 0);

    if (SHIBYTE(v37) < 0) {
      operator delete(*(void **)buf);
    }
    if ((v17 & 1) == 0) {
LABEL_27:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v28 = v36;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Could not find STK Controller", buf, 2u);
    }
    id v29 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id, id))v7)[2](v7, 0, v29);

    if ((v17 & 1) == 0) {
      goto LABEL_27;
    }
  }
LABEL_28:
}

- (void)selectSIMToolkitListItemForContext:(id)a3 session:(id)a4 response:(id)a5 index:(id)a6 completion:(id)a7
{
  id v33 = a3;
  id v12 = a4;
  id v13 = a5;
  id v14 = a6;
  uint64_t v15 = (void (**)(id, void))a7;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  char v17 = ServiceMap;
  if ((v18 & 0x8000000000000000) != 0)
  {
    id v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      unint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v36 = v18;
  uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, &v36);
  if (v22)
  {
    uint64_t v24 = v22[3];
    id v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  id v23 = 0;
  char v25 = 1;
LABEL_9:
  if (v35) {
    sub_10004D2C8(v35);
  }
  if (v24)
  {
    id v26 = [v12 unsignedIntValue];
    uint64_t v27 = sub_10081FF48(v13);
    id v28 = [v14 unsignedIntValue];
    id v29 = [v33 slotID];
    if (v29 == (id)2) {
      uint64_t v30 = 2;
    }
    else {
      uint64_t v30 = v29 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t, id, uint64_t, id))(*(void *)v24 + 88))(v24, v30, v26, v27, v28);
    if (v15) {
      v15[2](v15, 0);
    }
    if ((v25 & 1) == 0) {
LABEL_18:
    }
      sub_10004D2C8(v23);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v31 = v35;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Could not find STK Controller", buf, 2u);
    }
    id v32 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    if (v15) {
      ((void (**)(id, id))v15)[2](v15, v32);
    }

    if ((v25 & 1) == 0) {
      goto LABEL_18;
    }
  }
}

- (void)sendSIMToolkitResponseForContext:(id)a3 session:(id)a4 response:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(id, void))a6;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v31);
  uint64_t v15 = ServiceMap;
  if ((v16 & 0x8000000000000000) != 0)
  {
    char v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      unint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v33 = v16;
  uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, &v33);
  if (v20)
  {
    uint64_t v22 = v20[3];
    unsigned int v21 = (std::__shared_weak_count *)v20[4];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v15);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      char v23 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  std::mutex::unlock(v15);
  unsigned int v21 = 0;
  char v23 = 1;
LABEL_9:
  if (v32) {
    sub_10004D2C8(v32);
  }
  if (v22)
  {
    id v24 = [v11 unsignedIntValue];
    uint64_t v25 = sub_10081FF48(v12);
    id v26 = [v10 slotID];
    if (v26 == (id)2) {
      uint64_t v27 = 2;
    }
    else {
      uint64_t v27 = v26 == (id)1;
    }
    if (v25 == 6)
    {
      uint64_t v28 = 1;
    }
    else
    {
      if (v25 != 7)
      {
        (*(void (**)(uint64_t, uint64_t, id, uint64_t))(*(void *)v22 + 72))(v22, v27, v24, v25);
LABEL_26:
        if (v13) {
          v13[2](v13, 0);
        }
        goto LABEL_28;
      }
      uint64_t v28 = 0;
    }
    (*(void (**)(uint64_t, uint64_t, id, uint64_t, uint64_t))(*(void *)v22 + 80))(v22, v27, v24, v25, v28);
    goto LABEL_26;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v29 = v32;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v31);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v31) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not find STK Controller", (uint8_t *)&v31, 2u);
  }
  id v30 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
  if (v13) {
    ((void (**)(id, id))v13)[2](v13, v30);
  }

LABEL_28:
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }
}

- (void)sendSIMToolkitStringResponseForContext:(id)a3 session:(id)a4 response:(id)a5 string:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v34 = a4;
  id v13 = a5;
  id v14 = a6;
  uint64_t v15 = (void (**)(id, id))a7;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p[0]);
  char v17 = ServiceMap;
  if ((v18 & 0x8000000000000000) != 0)
  {
    unsigned int v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      unint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v39 = v18;
  uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, &v39);
  if (v22)
  {
    uint64_t v24 = v22[3];
    char v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  char v23 = 0;
  char v25 = 1;
LABEL_9:
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  if (!v24)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v32 = __p[1];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)__p);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not find STK Controller", (uint8_t *)__p, 2u);
    }
    id v33 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    if (v15) {
      v15[2](v15, v33);
    }

    if ((v25 & 1) == 0) {
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  id v26 = [v34 unsignedIntValue];
  uint64_t v27 = sub_10081FF48(v13);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v38 = 0;
  sub_100058DB0(__p, (char *)[v14 UTF8String]);
  id v28 = v12;
  id v29 = [v12 slotID];
  if (v29 == (id)2) {
    uint64_t v30 = 2;
  }
  else {
    uint64_t v30 = v29 == (id)1;
  }
  if (v27 >= 2)
  {
    if (v27 == 6)
    {
      uint64_t v31 = 1;
      goto LABEL_28;
    }
    if (v27 == 7)
    {
      uint64_t v31 = 0;
LABEL_28:
      (*(void (**)(uint64_t, uint64_t, id, uint64_t, uint64_t))(*(void *)v24 + 80))(v24, v30, v26, v27, v31);
      goto LABEL_32;
    }
    (*(void (**)(uint64_t, uint64_t, id, uint64_t))(*(void *)v24 + 72))(v24, v30, v26, v27);
LABEL_32:
    if (!v15) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  if (SHIBYTE(v38) < 0)
  {
    sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)__p;
    uint64_t v36 = v38;
  }
  (*(void (**)(uint64_t, uint64_t, id, uint64_t, void **))(*(void *)v24 + 96))(v24, v30, v26, v27, __dst);
  if ((SHIBYTE(v36) & 0x80000000) == 0) {
    goto LABEL_32;
  }
  operator delete(__dst[0]);
  if (v15) {
LABEL_33:
  }
    v15[2](v15, 0);
LABEL_34:
  if (SHIBYTE(v38) < 0) {
    operator delete(__p[0]);
  }
  id v12 = v28;
  if ((v25 & 1) == 0) {
LABEL_37:
  }
    sub_10004D2C8(v23);
LABEL_38:
}

- (void)sendSIMToolkitBooleanResponseForContext:(id)a3 session:(id)a4 response:(id)a5 yesNo:(BOOL)a6 completion:(id)a7
{
  BOOL v8 = a6;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  uint64_t v15 = (void (**)(id, void))a7;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v33);
  char v17 = ServiceMap;
  if ((v18 & 0x8000000000000000) != 0)
  {
    unsigned int v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      unint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v35 = v18;
  uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, &v35);
  if (v22)
  {
    uint64_t v24 = v22[3];
    char v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  char v23 = 0;
  char v25 = 1;
LABEL_9:
  if (v34) {
    sub_10004D2C8(v34);
  }
  if (v24)
  {
    id v26 = [v13 unsignedIntValue];
    uint64_t v27 = sub_10081FF48(v14);
    id v28 = [v12 slotID];
    if (v28 == (id)2) {
      uint64_t v29 = 2;
    }
    else {
      uint64_t v29 = v28 == (id)1;
    }
    if (v27 < 2)
    {
      uint64_t v30 = (void (**)(uint64_t, uint64_t, id, uint64_t, BOOL))(*(void *)v24 + 104);
    }
    else if (v27 == 6)
    {
      uint64_t v30 = (void (**)(uint64_t, uint64_t, id, uint64_t, BOOL))(*(void *)v24 + 80);
      BOOL v8 = 1;
    }
    else
    {
      if (v27 != 7)
      {
        (*(void (**)(uint64_t, uint64_t, id, uint64_t))(*(void *)v24 + 72))(v24, v29, v26, v27);
LABEL_28:
        if (v15) {
          v15[2](v15, 0);
        }
        goto LABEL_30;
      }
      BOOL v8 = 0;
      uint64_t v30 = (void (**)(uint64_t, uint64_t, id, uint64_t, BOOL))(*(void *)v24 + 80);
    }
    (*v30)(v24, v29, v26, v27, v8);
    goto LABEL_28;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v31 = v34;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v33);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v33) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Could not find STK Controller", (uint8_t *)&v33, 2u);
  }
  id v32 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
  if (v15) {
    ((void (**)(id, id))v15)[2](v15, v32);
  }

LABEL_30:
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
}

- (void)sendSIMToolkitUserActivityForContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  uint64_t v7 = (void (**)(id, void))a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v20);
  id v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v10;
  id v14 = sub_10004D37C(&v9[1].__m_.__sig, &v22);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_9:
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v16)
  {
    (*(void (**)(uint64_t))(*(void *)v16 + 128))(v16);
    if (v7) {
      v7[2](v7, 0);
    }
    if ((v17 & 1) == 0) {
LABEL_15:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find STK Controller", (uint8_t *)&v20, 2u);
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    if (v7) {
      ((void (**)(id, id))v7)[2](v7, v19);
    }

    if ((v17 & 1) == 0) {
      goto LABEL_15;
    }
  }
}

- (void)getSIMToolkitUSSDStringForContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  uint64_t v7 = (void (**)(id, const __CFString *, uint64_t, void))a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p);
    id v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      id v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v10;
    id v14 = sub_10004D37C(&v9[1].__m_.__sig, &v28);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v16)
        {
          pthread_mutex_lock(&stru_101B0AC18);
          char v19 = dword_101B13E54;
          pthread_mutex_unlock(&stru_101B0AC18);
          if ((v19 & 2) != 0)
          {
            v7[2](v7, @"Please add a description for this capture:", 1, 0);
          }
          else
          {
            std::string __p = 0;
            id v26 = 0;
            uint64_t v27 = 0;
            (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v16 + 80))(&__p, v16);
            uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 88))(v16);
            if (v27 >= 0) {
              p_p = &__p;
            }
            else {
              p_p = __p;
            }
            unint64_t v22 = +[NSString stringWithUTF8String:p_p];
            v7[2](v7, v22, v20, 0);

            if (SHIBYTE(v27) < 0) {
              operator delete(__p);
            }
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find Call Controller", (uint8_t *)&__p, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, const __CFString *, uint64_t, id))v7)[2](v7, &stru_101AC1B28, 0, v24);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v18 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for SIMToolkit get USSD string", (uint8_t *)&__p, 2u);
  }
LABEL_27:
}

- (void)sendSIMToolkitUSSDResponseForContext:(id)a3 response:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unint64_t v10 = (void (**)(id, void))a5;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v44[0]);
  uint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    id v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v40 = v13;
  char v17 = sub_10004D37C(&v12[1].__m_.__sig, &v40);
  if (v17)
  {
    uint64_t v19 = v17[3];
    unint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  unint64_t v18 = 0;
  char v20 = 1;
LABEL_9:
  if (v44[1]) {
    sub_10004D2C8((std::__shared_weak_count *)v44[1]);
  }
  if (v19)
  {
    pthread_mutex_lock(&stru_101B0AC18);
    char v21 = dword_101B13E54;
    pthread_mutex_unlock(&stru_101B0AC18);
    if ((v21 & 8) != 0)
    {
      pthread_mutex_lock(&stru_101B0AC18);
      dword_101B13E54 = 0;
      pthread_mutex_unlock(&stru_101B0AC18);
      v44[0] = 0;
      v44[1] = 0;
      uint64_t v45 = 0;
      unint64_t v22 = v44;
      sub_100058DB0(v44, (char *)[v9 UTF8String]);
      char v23 = HIBYTE(v45);
      id v24 = v44[0];
      if (v45 >= 0) {
        char v25 = (Registry **)((char *)v44 + HIBYTE(v45));
      }
      else {
        char v25 = (Registry **)((char *)v44[0] + (unint64_t)v44[1]);
      }
      if (v45 < 0) {
        unint64_t v22 = (Registry **)v44[0];
      }
      if (v22 != v25)
      {
        do
        {
          *(unsigned char *)unint64_t v22 = __tolower(*(char *)v22);
          unint64_t v22 = (Registry **)((char *)v22 + 1);
        }
        while (v22 != v25);
        char v23 = HIBYTE(v45);
        id v24 = v44[0];
      }
      if (v23 >= 0) {
        id v26 = (char *)v44;
      }
      else {
        id v26 = (char *)v24;
      }
      sub_100058DB0(__p, v26);
      (*(void (**)(uint64_t, void **))(*(void *)v19 + 120))(v19, __p);
      if (v43 < 0) {
        operator delete(__p[0]);
      }
      sub_10007FBD8();
      if (SHIBYTE(v45) < 0) {
        operator delete(v44[0]);
      }
    }
  }
  v44[0] = (Registry *)6144;
  if (IsTelephonyRunningExtended(v44))
  {
    pthread_mutex_lock(&stru_101B0AC18);
    char v27 = dword_101B13E54;
    pthread_mutex_unlock(&stru_101B0AC18);
    if ((v27 & 2) == 0)
    {
      [(CTXPCClientHandler *)self registry];
      unint64_t v28 = (std::mutex *)Registry::getServiceMap(v44[0]);
      uint64_t v29 = v28;
      if ((v30 & 0x8000000000000000) != 0)
      {
        uint64_t v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v32 = 5381;
        do
        {
          unint64_t v30 = v32;
          unsigned int v33 = *v31++;
          uint64_t v32 = (33 * v32) ^ v33;
        }
        while (v33);
      }
      std::mutex::lock(v28);
      unint64_t v40 = v30;
      id v34 = sub_10004D37C(&v29[1].__m_.__sig, &v40);
      if (v34)
      {
        uint64_t v35 = v34[3];
        uint64_t v36 = (std::__shared_weak_count *)v34[4];
        if (v36)
        {
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v29);
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v36);
          char v37 = 0;
LABEL_42:
          if (v44[1]) {
            sub_10004D2C8((std::__shared_weak_count *)v44[1]);
          }
          if (v35)
          {
            v44[0] = 0;
            v44[1] = 0;
            uint64_t v45 = 0;
            sub_100058DB0(v44, (char *)[v9 UTF8String]);
            if (SHIBYTE(v45) < 0)
            {
              sub_10004FC84(v38, v44[0], (unint64_t)v44[1]);
            }
            else
            {
              *(_OWORD *)uint64_t v38 = *(_OWORD *)v44;
              uint64_t v39 = v45;
            }
            (*(void (**)(uint64_t, void **))(*(void *)v35 + 104))(v35, v38);
            if (SHIBYTE(v39) < 0) {
              operator delete(v38[0]);
            }
            if (SHIBYTE(v45) < 0) {
              operator delete(v44[0]);
            }
          }
          if ((v37 & 1) == 0) {
            sub_10004D2C8(v36);
          }
          goto LABEL_54;
        }
      }
      else
      {
        uint64_t v35 = 0;
      }
      std::mutex::unlock(v29);
      uint64_t v36 = 0;
      char v37 = 1;
      goto LABEL_42;
    }
    pthread_mutex_lock(&stru_101B0AC18);
    dword_101B13E54 = 0;
    pthread_mutex_unlock(&stru_101B0AC18);
    v44[0] = 0;
    v44[1] = 0;
    uint64_t v45 = 0;
    sub_100058DB0(v44, (char *)[v9 UTF8String]);
    sub_100068A94(&v40);
    (*(void (**)(void))(*(void *)v40 + 200))();
    if (v41) {
      sub_10004D2C8(v41);
    }
    sub_10007FBD8();
    if (SHIBYTE(v45) < 0) {
      operator delete(v44[0]);
    }
  }
LABEL_54:
  if (v10) {
    v10[2](v10, 0);
  }
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
}

- (void)cancelSIMToolkitUSSDSessionForContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  uint64_t v7 = (void (**)(id, void))a4;
  pthread_mutex_lock(&stru_101B0AC18);
  int v8 = dword_101B13E54;
  pthread_mutex_unlock(&stru_101B0AC18);
  if (v8)
  {
    pthread_mutex_lock(&stru_101B0AC18);
    dword_101B13E54 = 0;
    pthread_mutex_unlock(&stru_101B0AC18);
    sub_10007FBD8();
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v19);
  unint64_t v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v21);
  if (!v15)
  {
    uint64_t v17 = 0;
    goto LABEL_10;
  }
  uint64_t v17 = v15[3];
  unsigned int v16 = (std::__shared_weak_count *)v15[4];
  if (!v16)
  {
LABEL_10:
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
LABEL_11:
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 112))(v17);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
LABEL_17:
  if (v7) {
    v7[2](v7, 0);
  }
}

- (void)reliableNetworkFallback:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v24);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v26 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v26);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v25) {
          sub_10004D2C8(v25);
        }
        if (v17)
        {
          uint64_t v20 = sub_10003E318(v6);
          id v21 = objc_retainBlock(v7);
          v27[0] = off_101A1E8A8;
          v27[1] = v21;
          v27[3] = v27;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 112))(v17, v20, v27);
          sub_1000D9250(v27);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v22 = v25;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v24) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find cellular usage policy controller for getting current setting", (uint8_t *)&v24, 2u);
          }
          id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void, id))v7 + 2))(v7, 0, 0, v23);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v24) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for rnf query", (uint8_t *)&v24, 2u);
  }
LABEL_21:
}

- (void)setReliableNetworkFallback:(id)a3 enable:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = (void (**)(id, void))a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v21 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting rnf", (uint8_t *)&v25, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v25);
  uint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v27);
  if (v17)
  {
    uint64_t v19 = v17[3];
    char v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  char v18 = 0;
  char v20 = 1;
LABEL_12:
  if (v26) {
    sub_10004D2C8((std::__shared_weak_count *)v26);
  }
  if (v19)
  {
    uint64_t v22 = sub_10003E318(v8);
    (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v19 + 120))(v19, v22, v6);
    v9[2](v9, 0);
    if ((v20 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v18);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v23 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find cellular usage policy controller for setting current setting", (uint8_t *)&v25, 2u);
    }
    id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v9)[2](v9, v24);

    if ((v20 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)lowDataMode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v24);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v26 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v26);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v25) {
          sub_10004D2C8(v25);
        }
        if (v17)
        {
          uint64_t v20 = sub_10003E318(v6);
          id v21 = objc_retainBlock(v7);
          v27[0] = off_101A1E938;
          v27[1] = v21;
          v27[3] = v27;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 16))(v17, v20, v27);
          sub_100060644(v27);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v22 = v25;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v24) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find SaveDataMode interface for getting current setting", (uint8_t *)&v24, 2u);
          }
          id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, id))v7 + 2))(v7, 0, v23);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v24) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for low data mode query", (uint8_t *)&v24, 2u);
  }
LABEL_21:
}

- (void)setLowDataMode:(id)a3 enable:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = (void (**)(id, void))a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v21 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting low data mode", (uint8_t *)&v25, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v25);
  uint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v27);
  if (v17)
  {
    uint64_t v19 = v17[3];
    char v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  char v18 = 0;
  char v20 = 1;
LABEL_12:
  if (v26) {
    sub_10004D2C8((std::__shared_weak_count *)v26);
  }
  if (v19)
  {
    uint64_t v22 = sub_10003E318(v8);
    (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v19 + 24))(v19, v22, v6);
    v9[2](v9, 0);
    if ((v20 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v18);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v23 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SaveDataMode interface for setting current setting", (uint8_t *)&v25, 2u);
    }
    id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v9)[2](v9, v24);

    if ((v20 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)isSmartDataModeSupportedWithCompletion:(id)a3
{
  uint64_t v4 = (void (**)(id, uint64_t))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v19);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v21 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v21);
    if (v12)
    {
      uint64_t v14 = v12[3];
      unint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v14)
        {
          uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 32))(v14);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v18 = v20;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v19) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find SaveDataMode interface for getting current support", (uint8_t *)&v19, 2u);
          }
          uint64_t v17 = 0;
        }
        v4[2](v4, v17);
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    unint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v16 = v20;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v19) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for smart data mode support query", (uint8_t *)&v19, 2u);
  }
LABEL_21:
}

- (void)smartDataMode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, uint64_t, void))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for smart data mode query", (uint8_t *)&v24, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v24);
  uint64_t v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v11;
  char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v26);
  if (v15)
  {
    uint64_t v17 = v15[3];
    unsigned int v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  unsigned int v16 = 0;
  char v18 = 1;
LABEL_12:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (v17)
  {
    uint64_t v20 = sub_10003E318(v6);
    uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 40))(v17, v20);
    v7[2](v7, v21, 0);
    if ((v18 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v16);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find SaveDataMode interface for getting current setting", (uint8_t *)&v24, 2u);
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, uint64_t, id))v7)[2](v7, 0, v23);

    if ((v18 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)setSmartDataMode:(id)a3 enable:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = (void (**)(id, void))a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting smart data mode", (uint8_t *)&v25, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v25);
  uint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v27);
  if (v17)
  {
    uint64_t v19 = v17[3];
    char v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  char v18 = 0;
  char v20 = 1;
LABEL_12:
  if (v26) {
    sub_10004D2C8((std::__shared_weak_count *)v26);
  }
  if (v19)
  {
    uint64_t v22 = sub_10003E318(v8);
    (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v19 + 48))(v19, v22, v6);
    v9[2](v9, 0);
    if ((v20 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v18);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v23 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SaveDataMode interface for setting current setting", (uint8_t *)&v25, 2u);
    }
    id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v9)[2](v9, v24);

    if ((v20 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)isHighDataModeSupported:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, uint64_t))a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v23);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v25 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v25);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v24) {
          sub_10004D2C8(v24);
        }
        if (v17)
        {
          uint64_t v20 = sub_10003E318(v6);
          uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 56))(v17, v20);
          v7[2](v7, v21);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v22 = v24;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v23) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find SaveDataMode interface for getting current support", (uint8_t *)&v23, 2u);
          }
          v7[2](v7, 0);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v24;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v23) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for high data mode support query", (uint8_t *)&v23, 2u);
  }
LABEL_21:
}

- (void)interfaceCostExpensive:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, uint64_t, void))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for interface cost query", (uint8_t *)&v24, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v24);
  uint64_t v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v26);
  if (v15)
  {
    uint64_t v17 = v15[3];
    unsigned int v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  unsigned int v16 = 0;
  char v18 = 1;
LABEL_12:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (v17)
  {
    uint64_t v20 = sub_10003E318(v6);
    uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 64))(v17, v20);
    v7[2](v7, v21, 0);
    if ((v18 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v16);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find SaveDataMode interface for getting current setting", (uint8_t *)&v24, 2u);
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, uint64_t, id))v7)[2](v7, 1, v23);

    if ((v18 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)setInterfaceCost:(id)a3 expensive:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = (void (**)(id, void))a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting interface cost", (uint8_t *)&v25, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v25);
  uint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v27);
  if (v17)
  {
    uint64_t v19 = v17[3];
    char v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  char v18 = 0;
  char v20 = 1;
LABEL_12:
  if (v26) {
    sub_10004D2C8((std::__shared_weak_count *)v26);
  }
  if (v19)
  {
    uint64_t v22 = sub_10003E318(v8);
    (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v19 + 72))(v19, v22, v6);
    v9[2](v9, 0);
    if ((v20 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v18);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v23 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SaveDataMode interface for setting current setting", (uint8_t *)&v25, 2u);
    }
    id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v9)[2](v9, v24);

    if ((v20 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)overriddenInterfaceCostInexpensiveWithCompletion:(id)a3
{
  uint64_t v4 = (void (**)(id, uint64_t, void))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v16 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for overridden interface cost query", (uint8_t *)&v20, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v20);
  id v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v22);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unint64_t v13 = 0;
  char v15 = 1;
LABEL_12:
  if (v21) {
    sub_10004D2C8((std::__shared_weak_count *)v21);
  }
  if (v14)
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 80))(v14);
    v4[2](v4, v17, 0);
    if ((v15 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v13);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find SaveDataMode interface for getting current setting", (uint8_t *)&v20, 2u);
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, uint64_t, id))v4)[2](v4, 1, v19);

    if ((v15 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)setOverriddenInterfaceCostInexpensive:(BOOL)a3 completion:(id)a4
{
  BOOL v4 = a3;
  BOOL v6 = (void (**)(id, void))a4;
  if (!v6)
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = v22;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting overridden interface cost", (uint8_t *)&v21, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, v21);
  id v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v23 = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v23);
  if (v14)
  {
    uint64_t v16 = v14[3];
    char v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  char v15 = 0;
  char v17 = 1;
LABEL_12:
  if (v22) {
    sub_10004D2C8((std::__shared_weak_count *)v22);
  }
  if (v16)
  {
    (*(void (**)(uint64_t, BOOL))(*(void *)v16 + 88))(v16, v4);
    v6[2](v6, 0);
    if ((v17 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = v22;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find SaveDataMode interface for setting current setting", (uint8_t *)&v21, 2u);
    }
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v6)[2](v6, v20);

    if ((v17 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)privacyProxy:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for privacy proxy query", (uint8_t *)&v24, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v24);
  unint64_t v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v11;
  char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v26);
  if (v15)
  {
    uint64_t v17 = v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v16 = 0;
  char v18 = 1;
LABEL_12:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (v17)
  {
    uint64_t v20 = sub_10003E318(v6);
    unsigned int v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 16))(v17, v20);
    (*((void (**)(id, void, void, void))v7 + 2))(v7, v21 & 1, (v21 >> 8) & 1, 0);
    if ((v18 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v16);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v22 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find privacy proxy interface for getting current setting", (uint8_t *)&v24, 2u);
    }
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*((void (**)(id, void, void, id))v7 + 2))(v7, 0, 0, v23);

    if ((v18 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)setPrivacyProxy:(id)a3 enabled:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = (void (**)(id, void))a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v21 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting the privacy proxy.", (uint8_t *)&v25, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v25);
  uint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v27);
  if (v17)
  {
    uint64_t v19 = v17[3];
    char v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  char v18 = 0;
  char v20 = 1;
LABEL_12:
  if (v26) {
    sub_10004D2C8((std::__shared_weak_count *)v26);
  }
  if (v19)
  {
    uint64_t v22 = sub_10003E318(v8);
    (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v19 + 24))(v19, v22, v6);
    v9[2](v9, 0);
    if ((v20 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v18);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v23 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find privacy proxy interface for setting privacy proxy", (uint8_t *)&v25, 2u);
    }
    id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v9)[2](v9, v24);

    if ((v20 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)checkRadioBootHealth:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    *(void *)long long buf = 0;
    unint64_t v11 = 0;
    sub_100068A94(buf);
    if (*(void *)buf && (uint64_t v9 = 2048, IsTelephonyRunningExtended(&v9)))
    {
      uint64_t v5 = *(void *)buf;
      id v6 = objc_retainBlock(v4);
      v12[0] = off_101A32400;
      v12[1] = v6;
      v12[3] = v12;
      (*(void (**)(uint64_t, void *))(*(void *)v5 + 88))(v5, v12);
      sub_100060644(v12);
    }
    else
    {
      id v7 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v7);
    }
    if (v11) {
      sub_10004D2C8(v11);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v8 = v11;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for checking radio boot health", buf, 2u);
    }
  }
}

- (void)getBasebandRadioFrequencyFrontEndScanData:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    *(void *)long long buf = 0;
    unint64_t v11 = 0;
    sub_100068A94(buf);
    if (*(void *)buf && (uint64_t v9 = 2048, IsTelephonyRunningExtended(&v9)))
    {
      uint64_t v5 = *(void *)buf;
      object[0] = (dispatch_object_t)objc_retainBlock(v4);
      [(CTXPCClientHandler *)self getQueue];
      uint64_t v12 = off_101A32480;
      long long v13 = *(_OWORD *)object;
      unsigned int v14 = &v12;
      (*(void (**)(uint64_t, uint64_t (***)()))(*(void *)v5 + 96))(v5, &v12);
      sub_10065C870(&v12);
      id v6 = 0;
    }
    else
    {
      id v6 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v6);
    }

    if (v11) {
      sub_10004D2C8(v11);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v7 = v11;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting RFFE scan data", buf, 2u);
    }
  }
}

- (void)checkCellularDiagnosticsStatus:(id)a3
{
  id v4 = (void (**)(id, uint64_t, uint64_t))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, (Registry *)buf);
    id v7 = ServiceMap;
    id v8 = "18DiagnosticsService";
    if (((unint64_t)"18DiagnosticsService" & 0x8000000000000000) != 0)
    {
      uint64_t v9 = (unsigned __int8 *)((unint64_t)"18DiagnosticsService" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        id v8 = (const char *)v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v22 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v22);
    if (v12)
    {
      uint64_t v14 = v12[3];
      long long v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v14)
        {
          int v17 = sub_1006B5AA0(v14);
          [(CTXPCClientHandler *)self getLogContext];
          char v18 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
          {
            uint64_t v19 = cellularDiagnosticsStateAsString();
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "Cellular Diagnostics status: %s", (uint8_t *)&buf, 0xCu);
          }
          if ((v17 + 3) > 6) {
            uint64_t v20 = 4;
          }
          else {
            uint64_t v20 = qword_10152D540[v17 + 3];
          }
          uint64_t v21 = v17;
        }
        else
        {
          uint64_t v20 = 0;
          uint64_t v21 = -3;
        }
        v4[2](v4, v20, v21);
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    long long v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v16 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting diagnostics status", (uint8_t *)&buf, 2u);
  }
LABEL_24:
}

- (void)activateTurboMode:(id)a3
{
  id v4 = a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v5 = v20;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "No completion handler for activating turbo mode. Activation can still proceed but clients will not be notified of success or failure.", (uint8_t *)&v19, 2u);
    }
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, v19);
  id v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v9;
  long long v13 = sub_10004D37C(&v8[1].__m_.__sig, &v21);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
LABEL_12:
  if (v20) {
    sub_10004D2C8((std::__shared_weak_count *)v20);
  }
  if (v15)
  {
    id v17 = objc_retainBlock(v4);
    v22[0] = off_101A32510;
    v22[1] = v17;
    v22[3] = v22;
    (*(void (**)(uint64_t, void *))(*(void *)v15 + 224))(v15, v22);
    sub_100060644(v22);
    goto LABEL_19;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v18 = v20;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    if (!v4) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  LOWORD(v19) = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find BasebandSettingsInterface for activating turbo mode.", (uint8_t *)&v19, 2u);
  if (v4) {
LABEL_18:
  }
    (*((void (**)(id, void))v4 + 2))(v4, 0);
LABEL_19:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

- (void)getTransportKeysToUpdate:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    uint64_t v5 = (void (**)(void, void, void))v4;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v6, v21);
    id v8 = ServiceMap;
    if ((v9 & 0x8000000000000000) != 0)
    {
      uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        unint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v9;
    long long v13 = sub_10004D37C(&v8[1].__m_.__sig, &v23);
    if (v13)
    {
      uint64_t v15 = (void (***)(void, void *))v13[3];
      uint64_t v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_13:
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v15)
        {
          char v18 = self;
          v24[0] = off_101A32590;
          v24[1] = v18;
          void v24[2] = v5;
          uint64_t v24[3] = v24;
          (**v15)(v15, v24);
          sub_100A6AF14(v24);
          uint64_t v5 = 0;
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v19 = v22;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v21) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Stewie is not available", (uint8_t *)&v21, 2u);
          }
          uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(void, void, void *))v5)[2](v5, 0, v20);
        }
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    goto LABEL_13;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v17 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v21) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler for getTransportKeysToUpdate", (uint8_t *)&v21, 2u);
  }
  uint64_t v5 = 0;
LABEL_22:
}

- (void)setTransportKeysUpdated:(BOOL)a3 with:(id)a4 completion:(id)a5
{
  BOOL v65 = a3;
  id v7 = a4;
  unint64_t v66 = (void (**)(id, void))a5;
  if (v66)
  {
    long long v63 = self;
    id v68 = v7;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    uint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      unsigned int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    v75.i64[0] = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v75);
    if (v15)
    {
      uint64_t v16 = v15[3];
      id v17 = (std::__shared_weak_count *)v15[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        id v62 = v17;
        sub_10004D2C8(v17);
        char v64 = 0;
LABEL_12:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v16)
        {
          uint64_t v61 = v16;
          int64x2_t v75 = 0uLL;
          v76[0] = 0;
          if (v7)
          {
            uint64_t v19 = [v7 stks];
            if (v19)
            {
              uint64_t v20 = [v7 stks];
              BOOL v21 = [v20 count] == 0;

              if (!v21)
              {
                uint64_t v22 = [v7 stks];
                unint64_t v23 = (unint64_t)[v22 count];
                uint64_t v24 = v75.i64[0];
                if (0xAAAAAAAAAAAAAAABLL * ((v76[0] - v75.i64[0]) >> 3) < v23)
                {
                  if (v23 > 0xAAAAAAAAAAAAAAALL) {
                    sub_10006A748();
                  }
                  uint64_t v25 = v75.i64[1];
                  BOOL v80 = v76;
                  unint64_t v26 = (char *)sub_100601864(v23);
                  unint64_t v27 = &v26[v25 - v24];
                  *(void *)long long buf = v26;
                  *(void *)&uint8_t buf[8] = v27;
                  uint64_t v29 = &v26[24 * v28];
                  *(void *)&uint8_t buf[16] = v27;
                  uint64_t v79 = v29;
                  uint64_t v30 = v75.i64[1];
                  uint64_t v31 = v75.i64[0];
                  if (v75.i64[1] == v75.i64[0])
                  {
                    int64x2_t v34 = vdupq_n_s64(v75.u64[1]);
                    uint64_t v32 = &v26[v25 - v24];
                  }
                  else
                  {
                    uint64_t v32 = &v26[v25 - v24];
                    do
                    {
                      int v33 = *(_DWORD *)(v30 - 24);
                      v30 -= 24;
                      *((_DWORD *)v32 - 6) = v33;
                      v32 -= 24;
                      *((void *)v32 + 1) = 0;
                      *((void *)v32 + 1) = *(void *)(v30 + 8);
                      *(void *)(v30 + 8) = 0;
                      *((void *)v32 + 2) = 0;
                      *((void *)v32 + 2) = *(void *)(v30 + 16);
                      *(void *)(v30 + 16) = 0;
                    }
                    while (v30 != v31);
                    int64x2_t v34 = v75;
                    unint64_t v27 = *(char **)&buf[16];
                    uint64_t v29 = v79;
                  }
                  v75.i64[0] = (uint64_t)v32;
                  v75.i64[1] = (uint64_t)v27;
                  *(int64x2_t *)&uint8_t buf[8] = v34;
                  char v37 = (char *)v76[0];
                  v76[0] = v29;
                  uint64_t v79 = v37;
                  *(void *)long long buf = v34.i64[0];
                  sub_100A6AA58((uint64_t)buf);
                }

                long long v73 = 0u;
                long long v74 = 0u;
                long long v71 = 0u;
                long long v72 = 0u;
                id obj = [v7 stks];
                id v38 = [obj countByEnumeratingWithState:&v71 objects:v77 count:16];
                if (v38)
                {
                  uint64_t v39 = *(void *)v72;
                  do
                  {
                    for (uint64_t i = 0; i != v38; uint64_t i = (char *)i + 1)
                    {
                      if (*(void *)v72 != v39) {
                        objc_enumerationMutation(obj);
                      }
                      long long v41 = *(void **)(*((void *)&v71 + 1) + 8 * i);
                      unsigned int v69 = [v41 index];
                      uint64_t v42 = objc_msgSend(v41, "key_epki");
                      char v43 = v42;
                      *(void *)&long long v70 = v42;
                      if (v42) {
                        CFRetain(v42);
                      }
                      long long v44 = [v41 stk];
                      uint64_t v45 = v44;
                      *((void *)&v70 + 1) = v44;
                      if (v44) {
                        CFRetain(v44);
                      }
                      uint64_t v46 = v75.i64[1];
                      if (v75.i64[1] >= v76[0])
                      {
                        unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((v75.i64[1] - v75.i64[0]) >> 3);
                        unint64_t v49 = v48 + 1;
                        if (v48 + 1 > 0xAAAAAAAAAAAAAAALL) {
                          sub_10006A748();
                        }
                        if (0x5555555555555556 * ((v76[0] - v75.i64[0]) >> 3) > v49) {
                          unint64_t v49 = 0x5555555555555556 * ((v76[0] - v75.i64[0]) >> 3);
                        }
                        if (0xAAAAAAAAAAAAAAABLL * ((v76[0] - v75.i64[0]) >> 3) >= 0x555555555555555) {
                          unint64_t v50 = 0xAAAAAAAAAAAAAAALL;
                        }
                        else {
                          unint64_t v50 = v49;
                        }
                        BOOL v80 = v76;
                        id v51 = (char *)sub_100601864(v50);
                        unint64_t v52 = &v51[24 * v48];
                        *(void *)long long buf = v51;
                        *(void *)&uint8_t buf[8] = v52;
                        uint64_t v79 = &v51[24 * v53];
                        *(_DWORD *)unint64_t v52 = v69;
                        *((void *)v52 + 1) = 0;
                        *((void *)v52 + 1) = v70;
                        *(void *)&long long v70 = 0;
                        *((void *)v52 + 2) = 0;
                        *((void *)v52 + 2) = *((void *)&v70 + 1);
                        *((void *)&v70 + 1) = 0;
                        uint64_t v47 = v52 + 24;
                        *(void *)&uint8_t buf[16] = v52 + 24;
                        uint64_t v54 = v75.i64[1];
                        uint64_t v55 = v75.i64[0];
                        uint64_t v56 = *(void *)&buf[8];
                        if (v75.i64[1] == v75.i64[0])
                        {
                          int64x2_t v58 = vdupq_n_s64(v75.u64[1]);
                        }
                        else
                        {
                          do
                          {
                            int v57 = *(_DWORD *)(v54 - 24);
                            v54 -= 24;
                            *(_DWORD *)(v56 - 24) = v57;
                            v56 -= 24;
                            *(void *)(v56 + 8) = 0;
                            *(void *)(v56 + 8) = *(void *)(v54 + 8);
                            *(void *)(v54 + 8) = 0;
                            *(void *)(v56 + 16) = 0;
                            *(void *)(v56 + 16) = *(void *)(v54 + 16);
                            *(void *)(v54 + 16) = 0;
                          }
                          while (v54 != v55);
                          int64x2_t v58 = v75;
                          uint64_t v47 = *(char **)&buf[16];
                        }
                        v75.i64[0] = v56;
                        v75.i64[1] = (uint64_t)v47;
                        *(int64x2_t *)&uint8_t buf[8] = v58;
                        long long v59 = (char *)v76[0];
                        v76[0] = v79;
                        uint64_t v79 = v59;
                        *(void *)long long buf = v58.i64[0];
                        sub_100A6AA58((uint64_t)buf);
                      }
                      else
                      {
                        *(_DWORD *)v75.i64[1] = v69;
                        *(_OWORD *)(v46 + 8) = 0u;
                        *(_OWORD *)(v46 + 8) = v70;
                        long long v70 = 0u;
                        uint64_t v47 = (char *)(v46 + 24);
                      }
                      v75.i64[1] = (uint64_t)v47;
                      sub_100030068((const void **)&v70 + 1);
                      sub_100030068((const void **)&v70);

                      id v7 = v68;
                    }
                    id v38 = [obj countByEnumeratingWithState:&v71 objects:v77 count:16];
                  }
                  while (v38);
                }
              }
            }
          }
          (*(void (**)(uint64_t, BOOL, int64x2_t *, id))(*(void *)v61 + 8))(v61, v65, &v75, objc_msgSend(v7, "sps_environment"));
          [(CTXPCClientHandler *)v63 getLogContext];
          BOOL v60 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v7;
            _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "processed setTransportKeysUpdated: %@", buf, 0xCu);
          }
          v66[2](v66, 0);
          *(void *)long long buf = &v75;
          sub_100A6AABC((void ***)buf);
        }
        else
        {
          [(CTXPCClientHandler *)v63 getLogContext];
          uint64_t v35 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Stewie is not available", buf, 2u);
          }
          uint64_t v36 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, void *))v66)[2](v66, v36);
        }
        if ((v64 & 1) == 0) {
          sub_10004D2C8(v62);
        }
        goto LABEL_59;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v10);
    id v62 = 0;
    char v64 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v18 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for setTransportKeysUpdated", buf, 2u);
  }
LABEL_59:
}

- (void)forceRollAllTransportKeys:(id)a3
{
  id v4 = (void (**)(id, void))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v16 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for forceRollAllTransportKeys", (uint8_t *)&v20, 2u);
    }
    goto LABEL_19;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v20);
  id v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    unint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v8;
  unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, &v22);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_12:
  if (v21) {
    sub_10004D2C8((std::__shared_weak_count *)v21);
  }
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 16))(v14);
    [(CTXPCClientHandler *)self getLogContext];
    id v17 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "processed forceRollAllTransportKeys", (uint8_t *)&v20, 2u);
    }
    v4[2](v4, 0);
    if ((v15 & 1) == 0) {
LABEL_18:
    }
      sub_10004D2C8(v13);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Stewie is not available", (uint8_t *)&v20, 2u);
    }
    uint64_t v19 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, void *))v4)[2](v4, v19);

    if ((v15 & 1) == 0) {
      goto LABEL_18;
    }
  }
LABEL_19:
}

- (void)getSatelliteMsgCfgToUpdate:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    uint64_t v5 = (void (**)(void, void, void))v4;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v6, v21);
    unint64_t v8 = ServiceMap;
    if ((v9 & 0x8000000000000000) != 0)
    {
      uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        unint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v23);
    if (v13)
    {
      uint64_t v15 = v13[3];
      uint64_t v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_13:
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v15)
        {
          char v18 = self;
          v24[0] = off_101A32620;
          v24[1] = v18;
          void v24[2] = v5;
          uint64_t v24[3] = v24;
          (**(void (***)(uint64_t, void *))(v15 + 8))(v15 + 8, v24);
          sub_100A6B2C4(v24);
          uint64_t v5 = 0;
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v19 = v22;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v21) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Stewie is not available", (uint8_t *)&v21, 2u);
          }
          uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(void, void, void *))v5)[2](v5, 0, v20);
        }
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    goto LABEL_13;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v17 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v21) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSatelliteMsgCfgToUpdate", (uint8_t *)&v21, 2u);
  }
  uint64_t v5 = 0;
LABEL_22:
}

- (void)setSatelliteMsgCfgUpdated:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void))a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, (Registry *)buf);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      unsigned int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v25 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v25);
    if (v15)
    {
      uint64_t v17 = v15[3];
      char v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v17)
        {
          id v20 = [v6 result];
          BOOL v21 = objc_msgSend(v6, "cfg_id");
          sub_1005B09D4(v21, (CFUUIDRef *)&buf);
          (*(void (**)(uint64_t, id, void, id))(*(void *)(v17 + 8) + 8))(v17 + 8, v20, buf, objc_msgSend(v6, "sps_environment"));
          sub_10012577C((const void **)&buf);

          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v22 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v6;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "processed setSatelliteMsgCfgUpdated: %@", (uint8_t *)&buf, 0xCu);
          }
          v7[2](v7, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v23 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Stewie is not available", (uint8_t *)&buf, 2u);
          }
          uint64_t v24 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, void *))v7)[2](v7, v24);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    char v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for setSatelliteMsgCfgUpdated", (uint8_t *)&buf, 2u);
  }
LABEL_23:
}

- (void)reprovisionSatelliteMsg:(BOOL)a3 completion:(id)a4
{
  BOOL v4 = a3;
  id v6 = (void (**)(id, void))a4;
  if (v6)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, (Registry *)buf);
    unint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v10;
    unsigned int v14 = sub_10004D37C(&v9[1].__m_.__sig, &v23);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v16)
        {
          (*(void (**)(uint64_t, BOOL))(*(void *)(v16 + 8) + 16))(v16 + 8, v4);
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v19 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v20 = asStringBool(v4);
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "processed reprovisionSatelliteMsg with wipe:%s", (uint8_t *)&buf, 0xCu);
          }
          v6[2](v6, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          BOOL v21 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Stewie is not available", (uint8_t *)&buf, 2u);
          }
          unint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, void *))v6)[2](v6, v22);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v18 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for reprovisionSatelliteMsg", (uint8_t *)&buf, 2u);
  }
LABEL_23:
}

- (void)hasDedicatedBearerSupport:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)buf);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      unint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    BOOL v21 = (void (***)(void, uint8_t *))v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v21);
    if (v12)
    {
      uint64_t v14 = v12[3];
      unsigned int v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v24) {
          sub_10004D2C8(v24);
        }
        if (v14)
        {
          BOOL v21 = 0;
          unint64_t v22 = 0;
          (*(void (**)(unint64_t *__return_ptr, uint64_t))(*(void *)v14 + 32))((unint64_t *)&v21, v14);
          char v17 = v21;
          if (v21)
          {
            char v18 = (std::__shared_weak_count *)objc_retainBlock(v4);
            *(void *)long long buf = off_101A326B0;
            uint64_t v24 = v18;
            unint64_t v25 = buf;
            (**v17)(v17, buf);
            sub_100060644(buf);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v20 = v24;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Dedicated Bearer management is not available", buf, 2u);
            }
            (*((void (**)(id, void))v4 + 2))(v4, 0);
          }
          if (v22) {
            sub_10004D2C8(v22);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v19 = v24;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Carrier Entitlement service is not available", buf, 2u);
          }
          (*((void (**)(id, void))v4 + 2))(v4, 0);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    unsigned int v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v16 = v24;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for hasDedicatedBearerSupport", buf, 2u);
  }
LABEL_27:
}

- (void)addDedicatedBearer:(id)a3 completion:(id)a4
{
  id v6 = a3;
  uint64_t v55 = v6;
  id v56 = a4;
  if (v56)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)buf);
      unint64_t v9 = ServiceMap;
      if ((v10 & 0x8000000000000000) != 0)
      {
        unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          unint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      uint64_t v61 = (char *)v10;
      uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v61);
      if (v14)
      {
        uint64_t v16 = v14[3];
        char v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          unint64_t v52 = v15;
          sub_10004D2C8(v15);
          char v54 = 0;
LABEL_16:
          if (v67) {
            sub_10004D2C8(v67);
          }
          if (v16)
          {
            uint64_t v64 = 0;
            BOOL v65 = 0;
            (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v16 + 32))(&v64, v16);
            if (v64)
            {
              uint64_t v61 = 0;
              id v62 = 0;
              long long v63 = 0;
              long long v57 = 0u;
              long long v58 = 0u;
              long long v59 = 0u;
              long long v60 = 0u;
              uint64_t v20 = objc_msgSend(v55, "details", v52);
              id v21 = [v20 countByEnumeratingWithState:&v57 objects:v69 count:16];
              if (v21)
              {
                uint64_t v22 = *(void *)v58;
                do
                {
                  for (uint64_t i = 0; i != v21; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v58 != v22) {
                      objc_enumerationMutation(v20);
                    }
                    uint64_t v24 = *(void **)(*((void *)&v57 + 1) + 8 * i);
                    unint64_t v25 = (char *)operator new(0x50uLL);
                    *((void *)v25 + 1) = 0;
                    *((void *)v25 + 2) = 0;
                    *(void *)unint64_t v25 = off_101A32730;
                    *(_OWORD *)(v25 + 24) = 0u;
                    unint64_t v26 = v25 + 24;
                    *(_OWORD *)(v25 + 40) = 0u;
                    *(_OWORD *)(v25 + 56) = 0u;
                    *((void *)v25 + 9) = 0;
                    unint64_t v27 = objc_msgSend(v24, "src_ip");
                    *(void *)long long buf = v27;
                    sub_100013168((const void **)v25 + 3, (CFTypeRef *)buf);

                    uint64_t v28 = objc_msgSend(v24, "src_ports");
                    *(void *)long long buf = v28;
                    sub_1002824E4((const void **)v25 + 4, (CFTypeRef *)buf);

                    uint64_t v29 = objc_msgSend(v24, "remote_ip");
                    *(void *)long long buf = v29;
                    sub_100013168((const void **)v25 + 5, (CFTypeRef *)buf);

                    uint64_t v30 = objc_msgSend(v24, "remote_ports");
                    *(void *)long long buf = v30;
                    sub_1002824E4((const void **)v25 + 6, (CFTypeRef *)buf);

                    *((void *)v25 + 7) = objc_msgSend(v24, "ip_protocol");
                    uint64_t v31 = objc_msgSend(v24, "traffic_class");
                    *(void *)long long buf = v31;
                    sub_100013168((const void **)v25 + 8, (CFTypeRef *)buf);

                    *((void *)v25 + 9) = [v24 direction];
                    uint64_t v32 = v62;
                    if (v62 >= v63)
                    {
                      uint64_t v34 = (v62 - v61) >> 4;
                      unint64_t v35 = v34 + 1;
                      if ((unint64_t)(v34 + 1) >> 60) {
                        sub_10006A748();
                      }
                      uint64_t v36 = v63 - v61;
                      if ((v63 - v61) >> 3 > v35) {
                        unint64_t v35 = v36 >> 3;
                      }
                      if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF0) {
                        unint64_t v37 = 0xFFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v37 = v35;
                      }
                      id v38 = (char *)sub_10006A794((uint64_t)&v63, v37);
                      unint64_t v40 = &v38[16 * v34];
                      *(void *)unint64_t v40 = v26;
                      *((void *)v40 + 1) = v25;
                      atomic_fetch_add_explicit((atomic_ullong *volatile)v25 + 1, 1uLL, memory_order_relaxed);
                      int v33 = v40 + 16;
                      unint64_t v41 = (unint64_t)v61;
                      uint64_t v42 = v62;
                      if (v62 == v61)
                      {
                        uint64_t v61 = v40;
                        id v62 = v40 + 16;
                        long long v63 = &v38[16 * v39];
                      }
                      else
                      {
                        do
                        {
                          long long v43 = *((_OWORD *)v42 - 1);
                          v42 -= 16;
                          *((_OWORD *)v40 - 1) = v43;
                          v40 -= 16;
                          *(void *)uint64_t v42 = 0;
                          *((void *)v42 + 1) = 0;
                        }
                        while (v42 != (char *)v41);
                        uint64_t v42 = v61;
                        long long v44 = v62;
                        uint64_t v61 = v40;
                        id v62 = v33;
                        long long v63 = &v38[16 * v39];
                        while (v44 != v42)
                        {
                          uint64_t v45 = (std::__shared_weak_count *)*((void *)v44 - 1);
                          if (v45) {
                            sub_10004D2C8(v45);
                          }
                          v44 -= 16;
                        }
                      }
                      if (v42) {
                        operator delete(v42);
                      }
                    }
                    else
                    {
                      *(void *)id v62 = v26;
                      *((void *)v32 + 1) = v25;
                      atomic_fetch_add_explicit((atomic_ullong *volatile)v25 + 1, 1uLL, memory_order_relaxed);
                      int v33 = v32 + 16;
                    }
                    id v62 = v33;
                    sub_10004D2C8((std::__shared_weak_count *)v25);
                  }
                  id v21 = [v20 countByEnumeratingWithState:&v57 objects:v69 count:16];
                }
                while (v21);
              }

              uint64_t v46 = v64;
              uint64_t v47 = (std::__shared_weak_count *)objc_retainBlock(v56);
              *(void *)long long buf = off_101A32780;
              uint64_t v67 = v47;
              id v68 = buf;
              (*(void (**)(uint64_t, char **, uint8_t *))(*(void *)v46 + 8))(v46, &v61, buf);
              sub_100A10A28(buf);
              *(void *)long long buf = &v61;
              sub_10005CBF0((void ***)buf);
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              unint64_t v50 = v67;
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "Dedicated Bearer management is not available", buf, 2u);
              }
              id v51 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
              (*((void (**)(id, void, void *))v56 + 2))(v56, 0, v51);
            }
            if (v65) {
              sub_10004D2C8(v65);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            unint64_t v48 = v67;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Carrier Entitlement service is not available", buf, 2u);
            }
            unint64_t v49 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, void *))v56 + 2))(v56, 0, v49);
          }
          if ((v54 & 1) == 0) {
            sub_10004D2C8(v53);
          }
          goto LABEL_56;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      unint64_t v52 = 0;
      char v54 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = v67;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid arguments for hasDedicatedBearerSupport", buf, 2u);
    }
    uint64_t v19 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, void *))v56 + 2))(v56, 0, v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v17 = v67;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler for hasDedicatedBearerSupport", buf, 2u);
    }
  }
LABEL_56:
}

- (void)removeDedicatedBearer:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
      unint64_t v10 = ServiceMap;
      if ((v11 & 0x8000000000000000) != 0)
      {
        uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v13 = 5381;
        do
        {
          unint64_t v11 = v13;
          unsigned int v14 = *v12++;
          uint64_t v13 = (33 * v13) ^ v14;
        }
        while (v14);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v28 = v11;
      char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
      if (v15)
      {
        uint64_t v17 = v15[3];
        uint64_t v16 = (std::__shared_weak_count *)v15[4];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v10);
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          char v18 = 0;
LABEL_16:
          if (v31) {
            sub_10004D2C8(v31);
          }
          if (v17)
          {
            unint64_t v28 = 0;
            uint64_t v29 = 0;
            (*(void (**)(unint64_t *__return_ptr, uint64_t))(*(void *)v17 + 32))(&v28, v17);
            unint64_t v22 = v28;
            if (v28)
            {
              unint64_t v23 = (std::__shared_weak_count *)objc_retainBlock(v7);
              *(void *)long long buf = off_101A32810;
              uint64_t v31 = v23;
              uint64_t v32 = buf;
              (*(void (**)(unint64_t, id, uint8_t *))(*(void *)v22 + 16))(v22, v6, buf);
              sub_100A10AAC(buf);
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              unint64_t v26 = v31;
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Dedicated Bearer management is not available", buf, 2u);
              }
              unint64_t v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
              (*((void (**)(id, void *))v7 + 2))(v7, v27);
            }
            if (v29) {
              sub_10004D2C8(v29);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v24 = v31;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Carrier Entitlement service is not available", buf, 2u);
            }
            unint64_t v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void *))v7 + 2))(v7, v25);
          }
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v16);
          }
          goto LABEL_31;
        }
      }
      else
      {
        uint64_t v17 = 0;
      }
      std::mutex::unlock(v10);
      uint64_t v16 = 0;
      char v18 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v31;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Missing bearer_id for removeDedicatedBearer", buf, 2u);
    }
    id v21 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void *))v7 + 2))(v7, v21);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v31;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for removeDedicatedBearer", buf, 2u);
    }
  }
LABEL_31:
}

- (void)removeAllDedicatedBearers:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)buf);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      unint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v23);
    if (v12)
    {
      uint64_t v14 = v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v14)
        {
          unint64_t v23 = 0;
          uint64_t v24 = 0;
          (*(void (**)(unint64_t *__return_ptr, uint64_t))(*(void *)v14 + 32))(&v23, v14);
          unint64_t v17 = v23;
          if (v23)
          {
            char v18 = (std::__shared_weak_count *)objc_retainBlock(v4);
            *(void *)long long buf = off_101A32890;
            unint64_t v26 = v18;
            unint64_t v27 = buf;
            (*(void (**)(unint64_t, uint8_t *))(*(void *)v17 + 24))(v17, buf);
            sub_100A10AAC(buf);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v21 = v26;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Dedicated Bearer management is not available", buf, 2u);
            }
            unint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void *))v4 + 2))(v4, v22);
          }
          if (v24) {
            sub_10004D2C8(v24);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v19 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Carrier Entitlement service is not available", buf, 2u);
          }
          uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void *))v4 + 2))(v4, v20);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v16 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for removeAllDedicatedBearers", buf, 2u);
  }
LABEL_27:
}

- (void)isDedicatedBearerPresent:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
      uint64_t v10 = ServiceMap;
      if ((v11 & 0x8000000000000000) != 0)
      {
        uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v13 = 5381;
        do
        {
          unint64_t v11 = v13;
          unsigned int v14 = *v12++;
          uint64_t v13 = (33 * v13) ^ v14;
        }
        while (v14);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v28 = v11;
      char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
      if (v15)
      {
        uint64_t v17 = v15[3];
        uint64_t v16 = (std::__shared_weak_count *)v15[4];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v10);
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          char v18 = 0;
LABEL_16:
          if (v31) {
            sub_10004D2C8(v31);
          }
          if (v17)
          {
            unint64_t v28 = 0;
            uint64_t v29 = 0;
            (*(void (**)(unint64_t *__return_ptr, uint64_t))(*(void *)v17 + 32))(&v28, v17);
            unint64_t v22 = v28;
            if (v28)
            {
              unint64_t v23 = (std::__shared_weak_count *)objc_retainBlock(v7);
              *(void *)long long buf = off_101A32910;
              uint64_t v31 = v23;
              uint64_t v32 = buf;
              (*(void (**)(unint64_t, id, uint8_t *))(*(void *)v22 + 32))(v22, v6, buf);
              sub_100A10B30(buf);
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              unint64_t v26 = v31;
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Dedicated Bearer management is not available", buf, 2u);
              }
              unint64_t v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
              (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v27);
            }
            if (v29) {
              sub_10004D2C8(v29);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v24 = v31;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Carrier Entitlement service is not available", buf, 2u);
            }
            unint64_t v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v25);
          }
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v16);
          }
          goto LABEL_31;
        }
      }
      else
      {
        uint64_t v17 = 0;
      }
      std::mutex::unlock(v10);
      uint64_t v16 = 0;
      char v18 = 1;
      goto LABEL_16;
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = v31;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Missing bearer_id for isDedicatedBearerPresent", buf, 2u);
    }
    id v21 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v21);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v31;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for isDedicatedBearerPresent", buf, 2u);
    }
  }
LABEL_31:
}

- (void)getListOfPresentDedicatedBearers:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)buf);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      unint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v21 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v21);
    if (v12)
    {
      uint64_t v14 = v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v24) {
          sub_10004D2C8(v24);
        }
        if (v14)
        {
          unint64_t v21 = 0;
          unint64_t v22 = 0;
          (*(void (**)(unint64_t *__return_ptr, uint64_t))(*(void *)v14 + 32))(&v21, v14);
          unint64_t v17 = v21;
          if (v21)
          {
            char v18 = (std::__shared_weak_count *)objc_retainBlock(v4);
            *(void *)long long buf = off_101A329A0;
            uint64_t v24 = v18;
            unint64_t v25 = buf;
            (*(void (**)(unint64_t, uint8_t *))(*(void *)v17 + 40))(v17, buf);
            sub_100A10BB4(buf);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v20 = v24;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Dedicated Bearer management is not available", buf, 2u);
            }
            (*((void (**)(id, void))v4 + 2))(v4, 0);
          }
          if (v22) {
            sub_10004D2C8(v22);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v19 = v24;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Carrier Entitlement service is not available", buf, 2u);
          }
          (*((void (**)(id, void))v4 + 2))(v4, 0);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v16 = v24;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for getListOfPresentDedicatedBearers", buf, 2u);
  }
LABEL_27:
}

- (void)getQoSLinkCharacteristics:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)buf);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      unint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v23);
    if (v12)
    {
      uint64_t v14 = v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v14)
        {
          unint64_t v23 = 0;
          uint64_t v24 = 0;
          (*(void (**)(unint64_t *__return_ptr, uint64_t))(*(void *)v14 + 32))(&v23, v14);
          unint64_t v17 = v23;
          if (v23)
          {
            char v18 = (std::__shared_weak_count *)objc_retainBlock(v4);
            *(void *)long long buf = off_101A32A30;
            unint64_t v26 = v18;
            unint64_t v27 = buf;
            (*(void (**)(unint64_t, uint8_t *))(*(void *)v17 + 48))(v17, buf);
            sub_100A10C38(buf);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            unint64_t v21 = v26;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Dedicated Bearer management is not available", buf, 2u);
            }
            unint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v22);
          }
          if (v24) {
            sub_10004D2C8(v24);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v19 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Carrier Entitlement service is not available", buf, 2u);
          }
          uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v20);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v16 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for getQoSLinkCharacteristics", buf, 2u);
  }
LABEL_27:
}

- (void)requestQoSLinkCharacteristics:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)buf);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      unint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v23);
    if (v12)
    {
      uint64_t v14 = v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v14)
        {
          unint64_t v23 = 0;
          uint64_t v24 = 0;
          (*(void (**)(unint64_t *__return_ptr, uint64_t))(*(void *)v14 + 32))(&v23, v14);
          unint64_t v17 = v23;
          if (v23)
          {
            char v18 = (std::__shared_weak_count *)objc_retainBlock(v4);
            *(void *)long long buf = off_101A32AC0;
            unint64_t v26 = v18;
            unint64_t v27 = buf;
            (*(void (**)(unint64_t, uint8_t *))(*(void *)v17 + 56))(v17, buf);
            sub_100A10AAC(buf);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            unint64_t v21 = v26;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Dedicated Bearer management is not available", buf, 2u);
            }
            unint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            (*((void (**)(id, void *))v4 + 2))(v4, v22);
          }
          if (v24) {
            sub_10004D2C8(v24);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v19 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Carrier Entitlement service is not available", buf, 2u);
          }
          uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void *))v4 + 2))(v4, v20);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v16 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for CTQoSLinkCharacteristics", buf, 2u);
  }
LABEL_27:
}

- (void)selectPhonebook:(id)a3 forPhonebookName:(int)a4 withPassword:(id)a5 completion:(id)a6
{
  LODWORD(v8) = a4;
  id v10 = a3;
  id v11 = a5;
  uint64_t v12 = (void (**)(id, id))a6;
  if (v12)
  {
    if (!v10)
    {
      id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v12[2](v12, v25);

      goto LABEL_33;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v13, *(Registry **)buf);
    char v15 = ServiceMap;
    if (v16 < 0)
    {
      unint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        uint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v16;
    uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)__p);
    if (v20)
    {
      uint64_t v22 = v20[3];
      unint64_t v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v22)
        {
          id v26 = [v10 slotID];
          memset(buf, 0, sizeof(buf));
          uint64_t v35 = 0;
          ctu::cf::assign();
          if ((v8 - 1) >= 3) {
            uint64_t v8 = 0;
          }
          else {
            uint64_t v8 = v8;
          }
          if (v26 == (id)2) {
            uint64_t v27 = 2;
          }
          else {
            uint64_t v27 = v26 == (id)1;
          }
          *(_OWORD *)std::string __p = *(_OWORD *)buf;
          uint64_t v33 = v35;
          if (v35 >= 0) {
            unint64_t v28 = __p;
          }
          else {
            unint64_t v28 = *(void ***)buf;
          }
          uint64_t v29 = objc_retainBlock(v12);
          v36[0] = off_101A3D4D0;
          v36[1] = v29;
          v36[3] = v36;
          (*(void (**)(uint64_t, uint64_t, uint64_t, void **, void *))(*(void *)v22 + 24))(v22, v27, v8, v28, v36);
          sub_100060644(v36);
          if (SHIBYTE(v33) < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v30 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Could not find PhonebookInterface for selecting the phone book", buf, 2u);
          }
          id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v12[2](v12, v31);
        }
        if ((v23 & 1) == 0) {
          sub_10004D2C8(v21);
        }
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    unint64_t v21 = 0;
    char v23 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v24 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid completion handler for selecting the phone book", buf, 2u);
  }
LABEL_33:
}

- (void)savePhonebookEntry:(id)a3 atIndex:(int)a4 withContactName:(id)a5 contactNumber:(id)a6 completion:(id)a7
{
  uint64_t v10 = *(void *)&a4;
  id v12 = a3;
  id v13 = a5;
  id v14 = a6;
  char v15 = (void (**)(id, id))a7;
  if (v15)
  {
    if (!v12)
    {
      id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v15[2](v15, v28);

      goto LABEL_40;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)buf);
    uint64_t v18 = ServiceMap;
    if (v19 < 0)
    {
      uint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long v48 = v19;
    char v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&v48);
    if (v23)
    {
      uint64_t v25 = v23[3];
      uint64_t v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
LABEL_14:
        if (v40) {
          sub_10004D2C8((std::__shared_weak_count *)v40);
        }
        if (v25)
        {
          id v29 = [v12 slotID];
          if (v29 == (id)2) {
            uint64_t v30 = 2;
          }
          else {
            uint64_t v30 = v29 == (id)1;
          }
          long long v48 = 0uLL;
          uint64_t v49 = 0;
          ctu::cf::assign();
          *(_OWORD *)unint64_t v37 = v48;
          uint64_t v38 = v49;
          CSIPhoneNumber::CSIPhoneNumber();
          long long v48 = 0uLL;
          uint64_t v49 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = v48;
          uint64_t v36 = v49;
          if (v49 >= 0) {
            id v31 = __p;
          }
          else {
            id v31 = (void **)__p[0];
          }
          uint64_t v32 = objc_retainBlock(v15);
          v50[0] = off_101A3D550;
          v50[1] = v32;
          v50[3] = v50;
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *, void **, void *))(*(void *)v25 + 40))(v25, v30, v10, buf, v31, v50);
          sub_100060644(v50);
          if (SHIBYTE(v36) < 0) {
            operator delete(__p[0]);
          }
          if (v47 < 0) {
            operator delete(v46);
          }
          if (v45 < 0) {
            operator delete(v44);
          }
          if (v43 < 0) {
            operator delete(v42);
          }
          if (v41 < 0) {
            operator delete(v40);
          }
          if (SHIBYTE(v38) < 0) {
            operator delete(v37[0]);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v33 = v40;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Could not find PhonebookInterface for saving the phone book entry", buf, 2u);
          }
          id v34 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v15[2](v15, v34);
        }
        if ((v26 & 1) == 0) {
          sub_10004D2C8(v24);
        }
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v24 = 0;
    char v26 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v27 = v40;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Invalid completion handler for saving the phone book entry", buf, 2u);
  }
LABEL_40:
}

- (void)fetchPhonebook:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          char v23 = objc_retainBlock(v7);
          v29[0] = off_101A3D5D0;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 56))(v17, v22, v29);
          sub_100060644(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find PhonebookInterface for fetching the phone book", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetching the phone book", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)getPhonebookEntryCountWithCompletion:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          char v23 = objc_retainBlock(v7);
          v29[0] = off_101A3D650;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 64))(v17, v22, v29);
          sub_1002AE148(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find PhonebookInterface for counting phone book entries", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for counting phone book entries", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)getPhonebookEntryWithCompletion:(id)a3 atIndex:(int)a4 completion:(id)a5
{
  uint64_t v6 = *(void *)&a4;
  id v8 = a3;
  unint64_t v9 = (void (**)(id, void, id))a5;
  if (v9)
  {
    if (!v8)
    {
      id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v9[2](v9, 0, v22);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v28);
    id v12 = ServiceMap;
    if ((v13 & 0x8000000000000000) != 0)
    {
      unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        unint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v30 = v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v30);
    if (v17)
    {
      uint64_t v19 = v17[3];
      char v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
LABEL_14:
        if (v29) {
          sub_10004D2C8(v29);
        }
        if (v19)
        {
          id v23 = [v8 slotID];
          if (v23 == (id)2) {
            uint64_t v24 = 2;
          }
          else {
            uint64_t v24 = v23 == (id)1;
          }
          id v25 = objc_retainBlock(v9);
          v31[0] = off_101A3D6D0;
          v31[1] = v25;
          v31[3] = v31;
          (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v19 + 72))(v19, v24, v6, v31);
          sub_1002AEBA8(v31);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v26 = v29;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v28) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find PhonebookInterface for copying the phone book entry", (uint8_t *)&v28, 2u);
          }
          id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v9[2](v9, 0, v27);
        }
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    char v18 = 0;
    char v20 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v21 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v28) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for copying the phone book entry", (uint8_t *)&v28, 2u);
  }
LABEL_26:
}

- (void)getSIMStatus:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (v6)
    {
      *(void *)long long buf = 0;
      uint64_t v15 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v13) {
        sub_10004D2C8(v13);
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v10 = v13;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v12);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v12 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for getSIMStatus", v12, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v7[2](v7, 0, v11);

      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    else
    {
      id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v9);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v8 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSIMStatus", buf, 2u);
    }
  }
}

- (void)getSIMTrayStatus:(id)a3
{
  id v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    *(void *)long long buf = 0;
    id v11 = 0;
    [(CTXPCClientHandler *)self registry];
    sGetSubscriberSimInterface();
    if (v9) {
      sub_10004D2C8(v9);
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v6 = v9;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for getSIMTrayStatus", v8, 2u);
    }
    id v7 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v4[2](v4, 0, v7);

    if (v11) {
      sub_10004D2C8(v11);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v5 = v11;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSIMTrayStatus", buf, 2u);
    }
  }
}

- (void)isEmbeddedSIMOnlyConfig:(id)a3
{
  id v4 = (void (**)(id, void, id))a3;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  [(CTXPCClientHandler *)self registry];
  sGetSubscriberSimInterface();
  if (v8) {
    sub_10004D2C8(v8);
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v5 = v8;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v7);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)id v7 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface", v7, 2u);
  }
  id v6 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
  v4[2](v4, 0, v6);

  if (v10) {
    sub_10004D2C8(v10);
  }
}

- (void)copyMobileEquipmentInfo:(id)a3
{
  id v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    *(void *)long long buf = 0;
    id v11 = 0;
    [(CTXPCClientHandler *)self registry];
    sGetSubscriberSimInterface();
    if (v9) {
      sub_10004D2C8(v9);
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v6 = v9;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for copyMobileEquipmentInfo", v8, 2u);
    }
    id v7 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v4[2](v4, 0, v7);

    if (v11) {
      sub_10004D2C8(v11);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v5 = v11;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyMobileEquipmentInfo", buf, 2u);
    }
  }
}

- (void)getTypeAllocationCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (v6)
    {
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v13) {
        sub_10004D2C8(v13);
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v10 = v13;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find SubscriberController for getTypeAllocationCode", (uint8_t *)&__p, 2u);
      }
      id v11 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v7[2](v7, 0, v11);

      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    else
    {
      uint64_t v9 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v9);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v8 = v13;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for refresh user auth token", (uint8_t *)&__p, 2u);
    }
  }
}

- (void)copyFirmwareUpdateInfo:(id)a3
{
  id v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)buf);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v37 = v8;
    id v12 = sub_10004D37C(&v7[1].__m_.__sig, &v37);
    if (v12)
    {
      uint64_t v14 = v12[3];
      unint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    unint64_t v13 = 0;
    char v15 = 1;
LABEL_12:
    uint64_t v17 = (capabilities::ct *)v36;
    if (v36) {
      sub_10004D2C8(v36);
    }
    char v18 = (capabilities::euicc *)capabilities::ct::supportsVinylFirmwareUpdate(v17);
    if (!v18 || (capabilities::euicc::supportsEOS(v18) & 1) != 0)
    {
      if (v14) {
        id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      }
      else {
        id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      }
      v4[2](v4, 0, v19);

LABEL_20:
      if ((v15 & 1) == 0) {
        sub_10004D2C8(v13);
      }
      goto LABEL_22;
    }
    [(CTXPCClientHandler *)self registry];
    id v21 = (std::mutex *)Registry::getServiceMap(v20, *(Registry **)buf);
    id v22 = v21;
    if ((v23 & 0x8000000000000000) != 0)
    {
      uint64_t v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        unint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(v21);
    unint64_t v37 = v23;
    id v27 = sub_10004D37C(&v22[1].__m_.__sig, &v37);
    if (v27)
    {
      uint64_t v29 = v27[3];
      unint64_t v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
LABEL_31:
        if (v36) {
          sub_10004D2C8(v36);
        }
        if (v29)
        {
          v33[0] = _NSConcreteStackBlock;
          v33[1] = 3221225472;
          v33[2] = sub_100DA3750;
          void v33[3] = &unk_101A595D8;
          void v33[4] = self;
          id v34 = v4;
          (*(void (**)(uint64_t, uint64_t, void *, void))(*(void *)v29 + 136))(v29, 1, v33, 0);
          id v31 = v34;
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v32 = v36;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not find VinylController for copyFirmwareUpdateInfo", buf, 2u);
          }
          id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v4[2](v4, 0, v31);
        }

        if ((v30 & 1) == 0) {
          sub_10004D2C8(v28);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    unint64_t v28 = 0;
    char v30 = 1;
    goto LABEL_31;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v16 = v36;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyFirmwareUpdateInfo", buf, 2u);
  }
LABEL_22:
}

- (void)copySIMIdentity:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (v6)
    {
      *(void *)long long buf = 0;
      char v15 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v13) {
        sub_10004D2C8(v13);
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v10 = v13;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v12);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v12 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for copySIMIdentity", v12, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v7[2](v7, 0, v11);

      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    else
    {
      id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v9);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v8 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for copySIMIdentity", buf, 2u);
    }
  }
}

- (void)copyMobileSubscriberIdentity:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (v6)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v10 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for copyMobileSubscriberIdentity", buf, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v7[2](v7, 0, v11);

      if (v14) {
        sub_10004D2C8(v14);
      }
    }
    else
    {
      id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v9);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v8 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyMobileSubscriberIdentity", buf, 2u);
    }
  }
}

- (void)context:(id)a3 isProtectedIdentitySupported:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void, void *))a5;
  if (v10)
  {
    if (v8 && v9)
    {
      id v11 = [(CTXPCClientHandler *)self dataProviderDelegate];
      id v12 = [v11 resolveContext:v8];

      if (v12)
      {
        id v13 = [v12 slotID];
        if (v13 == (id)2) {
          uint64_t v14 = 2;
        }
        else {
          uint64_t v14 = v13 == (id)1;
        }
        if (!v14)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v29 = v35;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v34);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v34) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "no slot in context", (uint8_t *)&v34, 2u);
          }
          char v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
          v10[2](v10, 0, v30);

          goto LABEL_31;
        }
        [(CTXPCClientHandler *)self registry];
        ServiceMap = (std::mutex *)Registry::getServiceMap(v15, v34);
        uint64_t v17 = ServiceMap;
        if ((v18 & 0x8000000000000000) != 0)
        {
          id v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v20 = 5381;
          do
          {
            unint64_t v18 = v20;
            unsigned int v21 = *v19++;
            uint64_t v20 = (33 * v20) ^ v21;
          }
          while (v21);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v36 = v18;
        id v22 = sub_10004D37C(&v17[1].__m_.__sig, &v36);
        if (v22)
        {
          uint64_t v24 = v22[3];
          unint64_t v23 = (std::__shared_weak_count *)v22[4];
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v17);
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v23);
            char v25 = 0;
LABEL_24:
            if (v35) {
              sub_10004D2C8((std::__shared_weak_count *)v35);
            }
            if (v24)
            {
              unsigned int v31 = [v9 isEqualToString:kCTEncryptedIdentityWiFiCalling];
              uint64_t v32 = objc_retainBlock(v10);
              v37[0] = off_101A598B0;
              v37[1] = v32;
              v37[3] = v37;
              (*(void (**)(uint64_t, uint64_t, void, void *))(*(void *)v24 + 24))(v24, v14, v31 ^ 1, v37);
              sub_100DAFF9C(v37);
            }
            else
            {
              uint64_t v33 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
              v10[2](v10, 0, v33);
            }
            if ((v25 & 1) == 0) {
              sub_10004D2C8(v23);
            }
LABEL_31:
            id v8 = v12;
            goto LABEL_32;
          }
        }
        else
        {
          uint64_t v24 = 0;
        }
        std::mutex::unlock(v17);
        unint64_t v23 = 0;
        char v25 = 1;
        goto LABEL_24;
      }
      unint64_t v28 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
      v10[2](v10, 0, v28);

      id v8 = 0;
    }
    else
    {
      id v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, 0, v27);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v26 = v35;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v34);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v34) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Invalid completion handler for isEncryptedIdentitySupportedForService", (uint8_t *)&v34, 2u);
    }
  }
LABEL_32:
}

- (void)context:(id)a3 supportedIdentityProtectionFor:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void, void *))a5;
  if (v10)
  {
    if (!v8)
    {
      char v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, 0, v25);

      goto LABEL_28;
    }
    id v11 = [v8 slotID];
    if (v11 == (id)2) {
      uint64_t v12 = 2;
    }
    else {
      uint64_t v12 = v11 == (id)1;
    }
    if (v12)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v13, v31);
      char v15 = ServiceMap;
      if ((v16 & 0x8000000000000000) != 0)
      {
        uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v18 = 5381;
        do
        {
          unint64_t v16 = v18;
          unsigned int v19 = *v17++;
          uint64_t v18 = (33 * v18) ^ v19;
        }
        while (v19);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v33 = v16;
      uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, &v33);
      if (v20)
      {
        uint64_t v22 = v20[3];
        unsigned int v21 = (std::__shared_weak_count *)v20[4];
        if (v21)
        {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v15);
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v21);
          char v23 = 0;
LABEL_21:
          if (v32) {
            sub_10004D2C8(v32);
          }
          if (v22)
          {
            unsigned int v28 = [v9 isEqualToString:kCTEncryptedIdentityWiFiCalling];
            uint64_t v29 = objc_retainBlock(v10);
            v34[0] = off_101A59940;
            v34[1] = v29;
            void v34[3] = v34;
            (*(void (**)(uint64_t, uint64_t, void, void *))(*(void *)v22 + 24))(v22, v12, v28 ^ 1, v34);
            sub_100DAFF9C(v34);
          }
          else
          {
            char v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            v10[2](v10, 0, v30);
          }
          if ((v23 & 1) == 0) {
            sub_10004D2C8(v21);
          }
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v22 = 0;
      }
      std::mutex::unlock(v15);
      unsigned int v21 = 0;
      char v23 = 1;
      goto LABEL_21;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v26 = v32;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v31);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v31) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "no slot in context", (uint8_t *)&v31, 2u);
    }
    id v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
    v10[2](v10, 0, v27);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v24 = v32;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v31);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v31) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid completion handler for supportedIdentityProtection", (uint8_t *)&v31, 2u);
    }
  }
LABEL_28:
}

- (void)createEncryptedIdentity:(id)a3 identity:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void, void *))a5;
  if (v10)
  {
    if (!v8)
    {
      char v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, 0, v25);

      goto LABEL_28;
    }
    id v11 = [v8 slotID];
    if (v11 == (id)2) {
      uint64_t v12 = 2;
    }
    else {
      uint64_t v12 = v11 == (id)1;
    }
    if (v12)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v13, v30);
      char v15 = ServiceMap;
      if ((v16 & 0x8000000000000000) != 0)
      {
        uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v18 = 5381;
        do
        {
          unint64_t v16 = v18;
          unsigned int v19 = *v17++;
          uint64_t v18 = (33 * v18) ^ v19;
        }
        while (v19);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v32 = v16;
      uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, &v32);
      if (v20)
      {
        uint64_t v22 = v20[3];
        unsigned int v21 = (std::__shared_weak_count *)v20[4];
        if (v21)
        {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v15);
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v21);
          char v23 = 0;
LABEL_21:
          if (v31) {
            sub_10004D2C8(v31);
          }
          if (v22)
          {
            unsigned int v28 = objc_retainBlock(v10);
            v33[0] = off_101A599C0;
            v33[1] = v28;
            void v33[3] = v33;
            (*(void (**)(uint64_t, uint64_t, uint64_t, id, void *))(*(void *)v22 + 40))(v22, v12, 1, v9, v33);
            sub_100DB04A4(v33);
          }
          else
          {
            uint64_t v29 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            v10[2](v10, 0, v29);
          }
          if ((v23 & 1) == 0) {
            sub_10004D2C8(v21);
          }
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v22 = 0;
      }
      std::mutex::unlock(v15);
      unsigned int v21 = 0;
      char v23 = 1;
      goto LABEL_21;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v26 = v31;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v30);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v30) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "no slot in context", (uint8_t *)&v30, 2u);
    }
    id v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
    v10[2](v10, 0, v27);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v24 = v31;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v30);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v30) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid completion handler for createEncryptedIdentity", (uint8_t *)&v30, 2u);
    }
  }
LABEL_28:
}

- (void)context:(id)a3 getPseudoIdentityFor:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void, void *))a5;
  if (v10)
  {
    if (!v8)
    {
      char v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, 0, v25);

      goto LABEL_28;
    }
    id v11 = [v8 slotID];
    if (v11 == (id)2) {
      uint64_t v12 = 2;
    }
    else {
      uint64_t v12 = v11 == (id)1;
    }
    if (v12)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v13, v31);
      char v15 = ServiceMap;
      if ((v16 & 0x8000000000000000) != 0)
      {
        uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v18 = 5381;
        do
        {
          unint64_t v16 = v18;
          unsigned int v19 = *v17++;
          uint64_t v18 = (33 * v18) ^ v19;
        }
        while (v19);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v33 = v16;
      uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, &v33);
      if (v20)
      {
        uint64_t v22 = v20[3];
        unsigned int v21 = (std::__shared_weak_count *)v20[4];
        if (v21)
        {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v15);
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v21);
          char v23 = 0;
LABEL_21:
          if (v32) {
            sub_10004D2C8(v32);
          }
          if (v22)
          {
            unsigned int v28 = [v9 isEqualToString:kCTEncryptedIdentityWiFiCalling];
            uint64_t v29 = objc_retainBlock(v10);
            v34[0] = off_101A59A50;
            v34[1] = v29;
            void v34[3] = v34;
            (*(void (**)(uint64_t, uint64_t, void, void *))(*(void *)v22 + 80))(v22, v12, v28 ^ 1, v34);
            sub_1007F0208(v34);
          }
          else
          {
            char v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            v10[2](v10, 0, v30);
          }
          if ((v23 & 1) == 0) {
            sub_10004D2C8(v21);
          }
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v22 = 0;
      }
      std::mutex::unlock(v15);
      unsigned int v21 = 0;
      char v23 = 1;
      goto LABEL_21;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v26 = v32;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v31);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v31) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "no slot in context", (uint8_t *)&v31, 2u);
    }
    id v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
    v10[2](v10, 0, v27);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v24 = v32;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v31);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v31) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid completion handler for getPseudoIdentity", (uint8_t *)&v31, 2u);
    }
  }
LABEL_28:
}

- (void)evaluateMobileSubscriberIdentity:(id)a3 identity:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void *))a5;
  if (v10)
  {
    if (v8)
    {
      id v11 = [v8 slotID];
      if (v11 == (id)2) {
        uint64_t v12 = 2;
      }
      else {
        uint64_t v12 = v11 == (id)1;
      }
      if (v12)
      {
        [(CTXPCClientHandler *)self registry];
        ServiceMap = (std::mutex *)Registry::getServiceMap(v13, v28);
        char v15 = ServiceMap;
        if ((v16 & 0x8000000000000000) != 0)
        {
          uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v18 = 5381;
          do
          {
            unint64_t v16 = v18;
            unsigned int v19 = *v17++;
            uint64_t v18 = (33 * v18) ^ v19;
          }
          while (v19);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v30 = v16;
        uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, &v30);
        if (v20)
        {
          uint64_t v22 = v20[3];
          unsigned int v21 = (std::__shared_weak_count *)v20[4];
          if (v21)
          {
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v15);
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v21);
            char v23 = 0;
LABEL_22:
            if (v29) {
              sub_10004D2C8(v29);
            }
            if (v22)
            {
              id v27 = 0;
              (*(void (**)(uint64_t, uint64_t, uint64_t, id))(*(void *)v22 + 56))(v22, v12, 1, v9);
            }
            else
            {
              id v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            }
            v10[2](v10, v27);
            if ((v23 & 1) == 0) {
              sub_10004D2C8(v21);
            }

            goto LABEL_30;
          }
        }
        else
        {
          uint64_t v22 = 0;
        }
        std::mutex::unlock(v15);
        unsigned int v21 = 0;
        char v23 = 1;
        goto LABEL_22;
      }
      [(CTXPCClientHandler *)self getLogContext];
      unsigned int v26 = v29;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v28) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "no slot in context", (uint8_t *)&v28, 2u);
      }
      char v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
      v10[2](v10, v25);
    }
    else
    {
      char v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, v25);
    }

    goto LABEL_30;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v24 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v28) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid completion handler for evaluateMobileSubscriberIdentity", (uint8_t *)&v28, 2u);
  }
LABEL_30:
}

- (void)copyMobileSubscriberCountryCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v21);

      goto LABEL_31;
    }
    if (![(CTXPCClientHandler *)self hasEntitlement:3]
      && [(CTXPCClientHandler *)self isLinkedOnOrAfterVersion:@"16.4"])
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = v28;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        LOWORD(v27) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Returning default value for copyMobileSubscriberCountryCode", (uint8_t *)&v27, 2u);
      }
      ((void (**)(id, const __CFString *, id))v7)[2](v7, @"65535", 0);
      goto LABEL_31;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v27);
    uint64_t v12 = ServiceMap;
    if ((v13 & 0x8000000000000000) != 0)
    {
      uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        unint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v29 = v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v29);
    if (v17)
    {
      uint64_t v19 = v17[3];
      uint64_t v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
LABEL_19:
        if (v28) {
          sub_10004D2C8((std::__shared_weak_count *)v28);
        }
        if (v19)
        {
          id v22 = [v6 slotID];
          if (v22 == (id)2) {
            uint64_t v23 = 2;
          }
          else {
            uint64_t v23 = v22 == (id)1;
          }
          uint64_t v24 = objc_retainBlock(v7);
          v30[0] = off_101A59AD0;
          v30[1] = v24;
          v30[3] = v30;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v19 + 24))(v19, v23, v30);
          sub_10001E914(v30);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v25 = v28;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v27) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find SubscriberUtilityInterface for copyMobileSubscriberCountryCode", (uint8_t *)&v27, 2u);
          }
          id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v7[2](v7, 0, v26);
        }
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    uint64_t v18 = 0;
    char v20 = 1;
    goto LABEL_19;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v9 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v27) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyMobileSubscriberCountryCode", (uint8_t *)&v27, 2u);
  }
LABEL_31:
}

- (void)copyMobileSubscriberIsoCountryCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v21);

      goto LABEL_38;
    }
    if (![(CTXPCClientHandler *)self hasEntitlement:3]
      && [(CTXPCClientHandler *)self isLinkedOnOrAfterVersion:@"16.4"])
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Returning default value for copyMobileSubscriberIsoCountryCode", buf, 2u);
      }
      ((void (**)(id, const __CFString *, id))v7)[2](v7, @"--", 0);
      goto LABEL_38;
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v31 = 0;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)v28);
    uint64_t v12 = ServiceMap;
    if (v13 < 0)
    {
      uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)__p);
    if (v17)
    {
      uint64_t v19 = v17[3];
      uint64_t v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    uint64_t v18 = 0;
    char v20 = 1;
LABEL_19:
    if (*(void *)&v28[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v28[8]);
    }
    if (v19)
    {
      sub_100058DB0(__p, (char *)[v6 UTF8String]);
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v19 + 24))(v28, v19, __p);
      if (SHIBYTE(v31) < 0) {
        operator delete(*(void **)buf);
      }
      *(_OWORD *)long long buf = *(_OWORD *)v28;
      uint64_t v31 = v29;
      HIBYTE(v29) = 0;
      v28[0] = 0;
      if ((v27 & 0x80000000) == 0)
      {
        if (v20) {
          goto LABEL_26;
        }
LABEL_31:
        sub_10004D2C8(v18);
        if (!v19) {
          goto LABEL_36;
        }
LABEL_32:
        if (v31 >= 0) {
          uint64_t v24 = buf;
        }
        else {
          uint64_t v24 = *(uint8_t **)buf;
        }
        char v25 = +[NSString stringWithUTF8String:v24];
        ((void (**)(id, void *, id))v7)[2](v7, v25, 0);

LABEL_36:
        if (SHIBYTE(v31) < 0) {
          operator delete(*(void **)buf);
        }
        goto LABEL_38;
      }
      operator delete(__p[0]);
      if ((v20 & 1) == 0) {
        goto LABEL_31;
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v22 = *(NSObject **)&v28[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v28);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unsigned int v28 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find isoCacheInterface for copyMobileSubscriberIsoCountryCode", v28, 2u);
      }
      id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v7[2](v7, 0, v23);

      if ((v20 & 1) == 0) {
        goto LABEL_31;
      }
    }
LABEL_26:
    if (!v19) {
      goto LABEL_36;
    }
    goto LABEL_32;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v9 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyMobileSubscriberIsoCountryCode", buf, 2u);
  }
LABEL_38:
}

- (void)copyMobileSubscriberIsoSubregionCode:(id)a3 MNC:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void, id))a5;
  if (!v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = v36;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyMobileSubscriberIsoSubregionCode", buf, 2u);
    }
    goto LABEL_27;
  }
  if (!v8 || !v9)
  {
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v10[2](v10, 0, v23);

    goto LABEL_27;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)buf);
  uint64_t v13 = ServiceMap;
  if (v14 < 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  v33[0] = (void *)v14;
  uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v33);
  if (v18)
  {
    uint64_t v20 = v18[3];
    uint64_t v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      char v21 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  std::mutex::unlock(v13);
  uint64_t v19 = 0;
  char v21 = 1;
LABEL_15:
  if (v36) {
    sub_10004D2C8((std::__shared_weak_count *)v36);
  }
  if (v20)
  {
    *(void *)long long buf = 0;
    unint64_t v36 = 0;
    uint64_t v37 = 0;
    char v30 = v21;
    sub_100058DB0(v33, (char *)[v8 UTF8String]);
    sub_100058DB0(__p, (char *)[v9 UTF8String]);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void **, void **))(*(void *)v20 + 80))(buf, v20, v33, __p);
    if (v32 < 0) {
      operator delete(__p[0]);
    }
    if (v34 < 0) {
      operator delete(v33[0]);
    }
    uint64_t v24 = +[NSMutableArray arrayWithCapacity:0xAAAAAAAAAAAAAAABLL * (((uint64_t)v36 - *(void *)buf) >> 3)];
    if (v36 != *(NSObject **)buf)
    {
      uint64_t v25 = 0;
      unint64_t v26 = 0;
      do
      {
        char v27 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
        [v24 setObject:v27 atIndexedSubscript:v26];

        ++v26;
        v25 += 24;
      }
      while (v26 < 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v36 - *(void *)buf) >> 3));
    }
    ((void (**)(id, void *, id))v10)[2](v10, v24, 0);

    v33[0] = buf;
    sub_100047F64((void ***)v33);
    if ((v30 & 1) == 0) {
LABEL_26:
    }
      sub_10004D2C8(v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v28 = v36;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Could not find isoCacheInterface for copyMobileSubscriberIsoSubregionCode", buf, 2u);
    }
    id v29 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v10[2](v10, 0, v29);

    if ((v21 & 1) == 0) {
      goto LABEL_26;
    }
  }
LABEL_27:
}

- (void)getSimHardwareInfo:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_33;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v27);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v29 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v29);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v28) {
          sub_10004D2C8(v28);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          char v27 = 0;
          char v27 = (Registry *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 24))(v17, v22);
          if (subscriber::isEsimCapable())
          {
            uint64_t v23 = 3;
            uint64_t v24 = 2;
          }
          else if (HIDWORD(v27) == 1)
          {
            if (v27 == 1)
            {
              uint64_t v24 = 1;
              uint64_t v23 = 1;
            }
            else
            {
              uint64_t v23 = 2 * (v27 == 2);
              uint64_t v24 = 1;
            }
          }
          else
          {
            uint64_t v24 = 0;
            uint64_t v23 = 0;
          }
          id v26 = [objc_alloc((Class)CTSimHardwareInfo) initWithHardwareInfo:v24 simLocation:v23];
          ((void (**)(id, id, void *))v7)[2](v7, v26, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v25 = v28;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v27) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for getSimHardwareInfo", (uint8_t *)&v27, 2u);
          }
          id v26 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v7[2](v7, 0, v26);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v27) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSimType", (uint8_t *)&v27, 2u);
  }
LABEL_33:
}

- (void)getMobileSubscriberHomeCountryList:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          uint64_t v23 = objc_retainBlock(v7);
          v29[0] = off_101A59B50;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 48))(v17, v22, v29);
          sub_100033230(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find SubscriberUtilityInterface for getMobileSubscriberHomeCountryList", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getMobileSubscriberHomeCountryList", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyLastKnownMobileSubscriberCountryCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          uint64_t v23 = objc_retainBlock(v7);
          v29[0] = off_101A59BD0;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 40))(v17, v22, v29);
          sub_10001E914(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find SubscriberUtilityInterface for copyLastKnownMobileSubscriberCountryCode", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyLastKnownMobileSubscriberCountryCode", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyMobileSubscriberNetworkCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v21);

      goto LABEL_35;
    }
    if (![(CTXPCClientHandler *)self hasEntitlement:3]
      && [(CTXPCClientHandler *)self isLinkedOnOrAfterVersion:@"16.4"])
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = v29;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        LOWORD(__p) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Returning default value for copyMobileSubscriberNetworkCode", (uint8_t *)&__p, 2u);
      }
      ((void (**)(id, const __CFString *, id))v7)[2](v7, @"65535", 0);
      goto LABEL_35;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, (Registry *)__p);
    uint64_t v12 = ServiceMap;
    if ((v13 & 0x8000000000000000) != 0)
    {
      unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        unint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v31 = v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v31);
    if (v17)
    {
      uint64_t v19 = v17[3];
      char v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
LABEL_19:
        if (v29) {
          sub_10004D2C8((std::__shared_weak_count *)v29);
        }
        if (v19)
        {
          id v22 = [v6 slotID];
          if (v22 == (id)2) {
            uint64_t v23 = 2;
          }
          else {
            uint64_t v23 = v22 == (id)1;
          }
          std::string __p = 0;
          unint64_t v29 = 0;
          uint64_t v30 = 0;
          (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v19 + 32))(&__p, v19, v23);
          if (v30 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          id v25 = +[NSString stringWithUTF8String:p_p];
          ((void (**)(id, void *, id))v7)[2](v7, v25, 0);

          if (SHIBYTE(v30) < 0) {
            operator delete(__p);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v26 = v29;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find SubscriberUtilityInterface for copyMobileSubscriberNetworkCode", (uint8_t *)&__p, 2u);
          }
          id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v7[2](v7, 0, v27);
        }
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_35;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    char v18 = 0;
    char v20 = 1;
    goto LABEL_19;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v9 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyMobileSubscriberNetworkCode", (uint8_t *)&__p, 2u);
  }
LABEL_35:
}

- (void)copyGid1:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (v6)
    {
      *(void *)long long buf = 0;
      uint64_t v15 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v13) {
        sub_10004D2C8(v13);
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v10 = v13;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v12);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v12 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for copyGid1", v12, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v7[2](v7, 0, v11);

      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    else
    {
      id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v9);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v8 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyGid1", buf, 2u);
    }
  }
}

- (void)copyGid2:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (v6)
    {
      *(void *)long long buf = 0;
      uint64_t v15 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v13) {
        sub_10004D2C8(v13);
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v10 = v13;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v12);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v12 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for copyGid2", v12, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v7[2](v7, 0, v11);

      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    else
    {
      id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v9);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v8 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyGid2", buf, 2u);
    }
  }
}

- (void)copyLabel:(id)a3 completion:(id)a4
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100DA799C;
  v7[3] = &unk_101A59600;
  id v8 = a4;
  id v6 = v8;
  [(CTXPCClientHandler *)self getSimLabel:a3 completion:v7];
}

- (void)getSimLabel:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_49;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v36 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v36);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v17)
        {
          unint64_t v36 = 0;
          uint64_t v37 = 0;
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 8))(&v36, v17, v22);
          if (v36)
          {
            uint64_t v44 = 0;
            long long v42 = 0u;
            *(_OWORD *)std::string __p = 0u;
            long long v40 = 0u;
            *(_OWORD *)char v41 = 0u;
            *(_OWORD *)long long buf = 0u;
            *(_OWORD *)uint64_t v39 = 0u;
            (*(void (**)(uint8_t *__return_ptr, uint64_t, unint64_t))(*(void *)v17 + 168))(buf, v17, v36 + 24);
            uint64_t v23 = (void *)BYTE7(v42);
            if (SBYTE7(v42) < 0) {
              uint64_t v23 = v41[1];
            }
            if (v23)
            {
              id v24 = objc_alloc((Class)CTSimLabel);
              if ((SBYTE7(v42) & 0x80u) == 0) {
                id v25 = v41;
              }
              else {
                id v25 = (void **)v41[0];
              }
              id v26 = +[NSString stringWithUTF8String:v25];
              if (SHIBYTE(v39[0]) >= 0) {
                id v27 = buf;
              }
              else {
                id v27 = *(uint8_t **)buf;
              }
              unint64_t v28 = +[NSString stringWithUTF8String:v27];
              id v29 = [v24 initWithId:v26 andText:v28 andDidSetup:BYTE8(v42)];

              ((void (**)(id, id, void *))v7)[2](v7, v29, 0);
            }
            else
            {
              id v29 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
              v7[2](v7, 0, v29);
            }

            if (SHIBYTE(v44) < 0) {
              operator delete(__p[0]);
            }
            if (SBYTE7(v42) < 0) {
              operator delete(v41[0]);
            }
            if (SHIBYTE(v40) < 0) {
              operator delete(v39[1]);
            }
            if (SHIBYTE(v39[0]) < 0) {
              operator delete(*(void **)buf);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            char v32 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            {
              id v34 = [v6 slotID];
              uint64_t v35 = "True";
              if (!v34) {
                uint64_t v35 = "False";
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v35;
              _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "getSimLabel, no personality for slot %s", buf, 0xCu);
            }
            unint64_t v33 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v33);
          }
          if (v37) {
            sub_10004D2C8(v37);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v30 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Could not find PersonalityShop for getSimLabel", buf, 2u);
          }
          unint64_t v31 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v7[2](v7, 0, v31);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_49;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSimLabel", buf, 2u);
  }
LABEL_49:
}

- (void)getShortLabel:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v35[0];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v34);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v34) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getShortLabel", (uint8_t *)&v34, 2u);
    }
    goto LABEL_32;
  }
  if (!v6)
  {
    char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, 0, v20);

    goto LABEL_32;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v34);
  uint64_t v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v36 = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v36);
  if (v15)
  {
    uint64_t v17 = v15[3];
    unsigned int v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  unsigned int v16 = 0;
  char v18 = 1;
LABEL_14:
  if (v35[0]) {
    sub_10004D2C8((std::__shared_weak_count *)v35[0]);
  }
  if (v17)
  {
    id v34 = 0;
    v35[0] = 0;
    v35[1] = 0;
    (*(void (**)(Registry **__return_ptr, uint64_t))(*(void *)v17 + 312))(&v34, v17);
    id v21 = [v6 slotID];
    int v22 = v21 == (id)1;
    if (v21 == (id)2) {
      int v22 = 2;
    }
    uint64_t v23 = v35[0];
    if (!v35[0]) {
      goto LABEL_29;
    }
    id v24 = v35;
    do
    {
      id v25 = v23;
      id v26 = v24;
      int v27 = *((_DWORD *)v23 + 8);
      unint64_t v28 = (const void ***)(v23 + 1);
      if (v27 >= v22)
      {
        unint64_t v28 = (const void ***)v25;
        id v24 = (const void ***)v25;
      }
      uint64_t v23 = *v28;
    }
    while (v23);
    if (v24 != v35 && (v27 >= v22 ? (id v29 = v25) : (id v29 = v26), v22 >= v29[8]))
    {
      if (v27 >= v22) {
        unint64_t v33 = v25;
      }
      else {
        unint64_t v33 = v26;
      }
      v7[2](v7, v33[5], 0);
    }
    else
    {
LABEL_29:
      uint64_t v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
      v7[2](v7, 0, v30);
    }
    sub_100706DDC((uint64_t)&v34, v35[0]);
    if ((v18 & 1) == 0) {
LABEL_31:
    }
      sub_10004D2C8(v16);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v31 = v35[0];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v34);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v34) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Could not find PersonalityShop for getSimLabel", (uint8_t *)&v34, 2u);
    }
    char v32 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v7[2](v7, 0, v32);

    if ((v18 & 1) == 0) {
      goto LABEL_31;
    }
  }
LABEL_32:
}

- (void)getSubscriptionUserFacingName:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_38;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v30);
    uint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&buf);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v31) {
          sub_10004D2C8(v31);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          uint64_t v30 = 0;
          unint64_t v31 = 0;
          (*(void (**)(Registry **__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 8))(&v30, v17, v22);
          if (v30)
          {
            *(void *)&long long buf = 0;
            (*(void (**)(long long *__return_ptr, uint64_t, char *))(*(void *)v17 + 200))(&buf, v17, (char *)v30 + 24);
            if ((void)buf) {
              uint64_t v23 = sub_1000810B8;
            }
            else {
              uint64_t v23 = 0;
            }
            if (v23)
            {
              ((void (*)(void (**)(id, void, void *)))v7[2])(v7);
            }
            else
            {
              unint64_t v28 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
              v7[2](v7, 0, v28);
            }
            sub_1000558F4((const void **)&buf);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v26 = *((void *)&buf + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              uint64_t v29 = subscriber::asString();
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v29;
              _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "getSubscriptionUserFacingName, no personality for slot %s", (uint8_t *)&buf, 0xCu);
            }
            int v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v27);
          }
          if (v31) {
            sub_10004D2C8(v31);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v31;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v30);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v30) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find PersonalityShop for getSubscriptionUserFacingName", (uint8_t *)&v30, 2u);
          }
          id v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v31;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v30);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v30) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getSubscriptionUserFacingName", (uint8_t *)&v30, 2u);
  }
LABEL_38:
}

- (void)generateAuthenticationInfoUsingSim:(id)a3 authParams:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v50 = a4;
  id v9 = a5;
  uint64_t v10 = (void (**)(void, void, void))v9;
  long long v48 = v8;
  if (v9)
  {
    if (!v8)
    {
      uint64_t v11 = v50;
      id v39 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      ((void (**)(void, void, id))v10)[2](v10, 0, v39);

      goto LABEL_42;
    }
    uint64_t v11 = v50;
    id v47 = v9;
    if (v50)
    {
      uint64_t v12 = [v50 data];

      if (v12)
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v13 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v14 = [v50 data];
          *(_DWORD *)long long buf = 136315395;
          *(void *)&uint8_t buf[4] = "-[CTXPCClientHandler(Subscriber) generateAuthenticationInfoUsingSim:authParams:completion:]";
          *(_WORD *)&buf[12] = 2117;
          *(void *)&buf[14] = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%s: input auth params: %{sensitive}@", buf, 0x16u);

          uint64_t v10 = (void (**)(void, void, void))v47;
        }
        CFDictionaryRef v15 = (const __CFDictionary *)[v50 data];
        uint64_t v16 = kCTSimSupportUICCAuthenticationTypeKey;
        Value = (subscriber *)CFDictionaryGetValue(v15, kCTSimSupportUICCAuthenticationTypeKey);
        char v18 = Value;
        if (Value && (CFTypeID v19 = CFGetTypeID(Value), v19 == CFStringGetTypeID()))
        {
          uint64_t AuthTypeFromClientKey = subscriber::getAuthTypeFromClientKey(v18, v20);
          if ((AuthTypeFromClientKey & 0xFF00000000) != 0)
          {
            v61[0] = 0;
            v61[1] = 0;
            long long v60 = (uint64_t *)v61;
            long long v56 = 0u;
            long long v57 = 0u;
            long long v58 = 0u;
            long long v59 = 0u;
            uint64_t v22 = [v50 data];
            unsigned int v46 = AuthTypeFromClientKey;
            uint64_t v49 = self;
            id v23 = [v22 countByEnumeratingWithState:&v56 objects:v64 count:16];
            if (v23)
            {
              uint64_t v24 = *(void *)v57;
              do
              {
                for (uint64_t i = 0; i != v23; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v57 != v24) {
                    objc_enumerationMutation(v22);
                  }
                  id v26 = *(subscriber **)(*((void *)&v56 + 1) + 8 * i);
                  if (([(subscriber *)v26 isEqualToString:v16] & 1) == 0)
                  {
                    uint64_t AuthInfoTypeFromClientKey = 0;
                    uint64_t AuthInfoTypeFromClientKey = subscriber::getAuthInfoTypeFromClientKey(v26, v27);
                    if ((AuthInfoTypeFromClientKey & 0xFF00000000) != 0)
                    {
                      unint64_t v28 = [v11 data];
                      [v28 objectForKey:v26];
                      memset(buf, 0, 24);
                      ctu::cf::assign();
                      long long v51 = *(_OWORD *)buf;
                      uint64_t v29 = *(uint64_t **)&buf[16];
                      *(void *)long long buf = &AuthInfoTypeFromClientKey;
                      uint64_t v30 = sub_10008CC40(&v60, (int *)&AuthInfoTypeFromClientKey, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
                      unint64_t v31 = v30[5];
                      if (v31)
                      {
                        v30[6] = v31;
                        operator delete(v31);
                        v30[5] = 0;
                        v30[6] = 0;
                        v30[7] = 0;
                      }
                      *(_OWORD *)(v30 + 5) = v51;
                      v30[7] = v29;

                      uint64_t v11 = v50;
                    }
                    else
                    {
                      [(CTXPCClientHandler *)v49 getLogContext];
                      char v32 = *(NSObject **)&buf[8];
                      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)long long buf = 138412290;
                        *(void *)&uint8_t buf[4] = v26;
                        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Unable to convert auth info type (%@)", buf, 0xCu);
                      }
                    }
                  }
                }
                id v23 = [v22 countByEnumeratingWithState:&v56 objects:v64 count:16];
              }
              while (v23);
            }

            uint64_t AuthInfoTypeFromClientKey = 0;
            uint64_t v55 = 0;
            [(CTXPCClientHandler *)v49 registry];
            sGetSubscriberSimInterface();
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            if (AuthInfoTypeFromClientKey)
            {
              *(void *)long long buf = 0;
              *(_OWORD *)&uint8_t buf[16] = 0u;
              *(void *)&uint8_t buf[8] = &buf[16];
              id v33 = [v48 slotID];
              int v34 = v33 == (id)1;
              if (v33 == (id)2) {
                int v34 = 2;
              }
              *(void *)long long buf = __PAIR64__(v46, v34);
              sub_100C77378((uint64_t **)&buf[8], v60, (uint64_t *)v61);
              uint64_t v35 = AuthInfoTypeFromClientKey;
              uint64_t v52 = *(void *)buf;
              sub_10026E7F8(v53, (uint64_t)&buf[8]);
              unint64_t v36 = v49;
              id v37 = objc_retainBlock(v47);
              v62[0] = off_101A59D50;
              v62[1] = v36;
              v62[2] = v37;
              _OWORD v62[3] = v62;
              (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v35 + 256))(v35, &v52, v62);
              sub_100273F20(v62);
              sub_10026CF54((uint64_t)v53, (void *)v53[1]);
              sub_10026CF54((uint64_t)&buf[8], *(void **)&buf[16]);
            }
            else
            {
              [(CTXPCClientHandler *)v49 getLogContext];
              uint64_t v44 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for generateAuthenticationInfoUsingSim", buf, 2u);
              }
              id v45 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
              (*((void (**)(id, void, id))v47 + 2))(v47, 0, v45);
            }
            uint64_t v10 = (void (**)(void, void, void))v47;
            if (v55) {
              sub_10004D2C8(v55);
            }
            sub_10026CF54((uint64_t)&v60, v61[0]);
            goto LABEL_42;
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v41 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "No authentication type specified", buf, 2u);
          }
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        long long v42 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "No auth params dictionary given", buf, 2u);
        }
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      long long v40 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "No auth params given", buf, 2u);
      }
    }
    id v43 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void, id))v10)[2](v10, 0, v43);

    uint64_t v10 = (void (**)(void, void, void))v47;
    goto LABEL_42;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v38 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  uint64_t v11 = v50;
  if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyLabel", buf, 2u);
  }
LABEL_42:
}

- (void)setLabel:(id)a3 label:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void *))a5;
  if (v10)
  {
    uint64_t v11 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v10[2](v10, v11);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v12 = v14;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v13);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid completion handler for setLabel", v13, 2u);
    }
  }
}

- (void)setDefaultVoice:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    uint64_t v10 = ServiceMap;
    uint64_t v11 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = (const char *)v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    CFDictionaryRef v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          id v23 = objc_retainBlock(v7);
          v29[0] = off_101A59DD0;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 760))(v17, v22, v29);
          sub_100060644(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for setDefaultVoice", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  CFTypeID v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for setDefaultVoice", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)setActiveUserDataSelection:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    uint64_t v10 = ServiceMap;
    uint64_t v11 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = (const char *)v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    CFDictionaryRef v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          id v23 = objc_retainBlock(v7);
          v29[0] = off_101A59E50;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 768))(v17, v22, v29);
          sub_100060644(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for setActiveUserDataSelection", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  CFTypeID v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for setActiveUserDataSelection", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)shouldAllowSimLockFor:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v25);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v11;
    CFDictionaryRef v15 = sub_10004D37C(&v10[1].__m_.__sig, &v27);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          id v23 = +[NSNumber numberWithBool:(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 72))(v17, v22)];
          ((void (**)(id, id, id))v7)[2](v7, v23, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for shouldAllowSimLockFor", (uint8_t *)&v25, 2u);
          }
          id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v7[2](v7, 0, v23);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  CFTypeID v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for shouldAllowSimLockFor", (uint8_t *)&v25, 2u);
  }
LABEL_26:
}

- (void)fetchSIMLockValue:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (v6)
    {
      *(void *)long long buf = 0;
      CFDictionaryRef v15 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v13) {
        sub_10004D2C8(v13);
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v10 = v13;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v12);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v12 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for fetchSIMLockValue", v12, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v7[2](v7, 0, v11);

      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    else
    {
      id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v9);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v8 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetchSIMLockValue", buf, 2u);
    }
  }
}

- (void)saveSIMLockValue:(id)a3 enabled:(BOOL)a4 pin:(id)a5 completion:(id)a6
{
  id v9 = a3;
  id v10 = a5;
  id v11 = (void (**)(id, id))a6;
  if (v11)
  {
    if (v9)
    {
      *(void *)long long buf = 0;
      CFTypeID v19 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v17) {
        sub_10004D2C8(v17);
      }
      [(CTXPCClientHandler *)self getLogContext];
      unsigned int v14 = v17;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v16);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v16 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for saveSIMLockValue", v16, 2u);
      }
      id v15 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v11[2](v11, v15);

      if (v19) {
        sub_10004D2C8(v19);
      }
    }
    else
    {
      id v13 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v11[2](v11, v13);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v12 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid completion handler for saveSIMLockValue", buf, 2u);
    }
  }
}

- (void)unlockPIN:(id)a3 pin:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, id))a5;
  if (v10)
  {
    if (v8 && v9)
    {
      *(void *)long long buf = 0;
      char v18 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v16) {
        sub_10004D2C8(v16);
      }
      [(CTXPCClientHandler *)self getLogContext];
      id v13 = v16;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v15);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v15 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for unlockPIN", v15, 2u);
      }
      id v14 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v10[2](v10, v14);

      if (v18) {
        sub_10004D2C8(v18);
      }
    }
    else
    {
      id v12 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, v12);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v11 = v18;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid completion handler for unlockPIN", buf, 2u);
    }
  }
}

- (void)unlockPUK:(id)a3 puk:(id)a4 newPin:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(id, id))a6;
  if (v13)
  {
    if (v10 && v11 && v12)
    {
      *(void *)long long buf = 0;
      id v21 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v19) {
        sub_10004D2C8(v19);
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v16 = v19;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)char v18 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for unlockPUK", v18, 2u);
      }
      id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v13[2](v13, v17);

      if (v21) {
        sub_10004D2C8(v21);
      }
    }
    else
    {
      id v15 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v13[2](v13, v15);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v14 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid completion handler for unlockPUK", buf, 2u);
    }
  }
}

- (void)changePIN:(id)a3 oldPin:(id)a4 newPin:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(id, id))a6;
  if (v13)
  {
    if (v10 && v11 && v12)
    {
      *(void *)long long buf = 0;
      id v21 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v19) {
        sub_10004D2C8(v19);
      }
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v16 = v19;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)char v18 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for changePIN", v18, 2u);
      }
      id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v13[2](v13, v17);

      if (v21) {
        sub_10004D2C8(v21);
      }
    }
    else
    {
      id v15 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v13[2](v13, v15);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v14 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid completion handler for unlockPUK", buf, 2u);
    }
  }
}

- (void)getRemainingPINAttemptCount:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (v6)
    {
      *(void *)long long buf = 0;
      id v15 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v13) {
        sub_10004D2C8(v13);
      }
      [(CTXPCClientHandler *)self getLogContext];
      id v10 = v13;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v12);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v12 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for getRemainingPINAttemptCount", v12, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v7[2](v7, 0, v11);

      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    else
    {
      id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v9);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v8 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for getRemainingPINAttemptCount", buf, 2u);
    }
  }
}

- (void)getRemainingPUKAttemptCount:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (v6)
    {
      *(void *)long long buf = 0;
      id v15 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (v13) {
        sub_10004D2C8(v13);
      }
      [(CTXPCClientHandler *)self getLogContext];
      id v10 = v13;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v12);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v12 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find SubscriberSimInterface for getRemainingPUKAttemptCount", v12, 2u);
      }
      id v11 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v7[2](v7, 0, v11);

      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    else
    {
      id v9 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v9);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v8 = v15;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid completion handler for getRemainingPUKAttemptCount", buf, 2u);
    }
  }
}

- (void)promptForSIMUnlock:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, id))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    CFTypeID v19 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for promptForSIMUnlock", (uint8_t *)&v25, 2u);
    }
    goto LABEL_22;
  }
  if (!v6)
  {
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, v20);

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v25);
  id v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v11;
  id v15 = sub_10004D37C(&v10[1].__m_.__sig, &v27);
  if (v15)
  {
    uint64_t v17 = v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v16 = 0;
  char v18 = 1;
LABEL_14:
  if (v26) {
    sub_10004D2C8((std::__shared_weak_count *)v26);
  }
  if (v17)
  {
    id v21 = [v6 slotID];
    if (v21 == (id)2) {
      uint64_t v22 = 2;
    }
    else {
      uint64_t v22 = v21 == (id)1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 24))(v17, v22);
    v7[2](v7, 0);
    if ((v18 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v16);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v23 = v26;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v25) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SubscriberUserAlertManagerInterface for promptForSIMUnlock", (uint8_t *)&v25, 2u);
    }
    id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v7[2](v7, v24);

    if ((v18 & 1) == 0) {
      goto LABEL_21;
    }
  }
LABEL_22:
}

- (void)SIMUnlockProcedureDidComplete
{
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, v15);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    id v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v6;
  id v10 = sub_10004D37C(&v5[1].__m_.__sig, &v17);
  if (v10)
  {
    uint64_t v12 = v10[3];
    unint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  unint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 48))(v12);
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v14 = v16;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v15);
  if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
LABEL_14:
    if (v13) {
      return;
    }
    goto LABEL_15;
  }
  LOWORD(v15) = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not find SubscriberUserAlertManagerInterface for SIMUnlockProcedureDidComplete", (uint8_t *)&v15, 2u);
  if (v13) {
    return;
  }
LABEL_15:
  sub_10004D2C8(v11);
}

- (void)authenticate:(id)a3 request:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, void, id))a5;
  if (v10)
  {
    if (v8)
    {
      uint64_t v16 = 0;
      unint64_t v17 = 0;
      [(CTXPCClientHandler *)self registry];
      sGetSubscriberSimInterface();
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      [(CTXPCClientHandler *)self getLogContext];
      char v13 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find SubscriberController for SIM authentication", buf, 2u);
      }
      id v14 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v10[2](v10, 0, v14);

      if (v17) {
        sub_10004D2C8(v17);
      }
    }
    else
    {
      id v12 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, 0, v12);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v11 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid completion handler when performing SIM authentication", buf, 2u);
    }
  }
}

- (void)getUserAuthToken:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v21);

      goto LABEL_25;
    }
    uint64_t v8 = sub_10003E318(v6);
    *(void *)long long buf = 0;
    uint64_t v29 = 0;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v9, v26);
    unint64_t v11 = ServiceMap;
    if ((v12 & 0x8000000000000000) != 0)
    {
      char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        unint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v30 = v12;
    uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v30);
    if (v16)
    {
      uint64_t v18 = v16[3];
      unint64_t v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
LABEL_14:
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 8))(buf, v18, v8);
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        if (v27) {
          sub_10004D2C8(v27);
        }
        uint64_t v22 = *(void *)buf;
        if (*(void *)buf)
        {
          id v23 = objc_retainBlock(v7);
          v31[0] = off_101A5A0D0;
          v31[1] = v23;
          v31[3] = v31;
          (*(void (**)(uint64_t, void *))(*(void *)v22 + 240))(v22, v31);
          sub_1001A28F8(v31);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CarrierEntitlementsController for getting user auth token", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if (v29) {
          sub_10004D2C8(v29);
        }
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    unint64_t v17 = 0;
    char v19 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v20 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting user auth token", buf, 2u);
  }
LABEL_25:
}

- (void)refreshUserAuthToken:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v21);

      goto LABEL_25;
    }
    uint64_t v8 = sub_10003E318(v6);
    *(void *)long long buf = 0;
    uint64_t v29 = 0;
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v9, v26);
    unint64_t v11 = ServiceMap;
    if ((v12 & 0x8000000000000000) != 0)
    {
      char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        unint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v30 = v12;
    uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v30);
    if (v16)
    {
      uint64_t v18 = v16[3];
      unint64_t v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
LABEL_14:
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 8))(buf, v18, v8);
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        if (v27) {
          sub_10004D2C8(v27);
        }
        uint64_t v22 = *(void *)buf;
        if (*(void *)buf)
        {
          id v23 = objc_retainBlock(v7);
          v31[0] = off_101A5A150;
          v31[1] = v23;
          v31[3] = v31;
          (*(void (**)(uint64_t, void *))(*(void *)v22 + 248))(v22, v31);
          sub_100060644(v31);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CarrierEntitlementsController for refresh user auth token", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v25);
        }
        if (v29) {
          sub_10004D2C8(v29);
        }
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    unint64_t v17 = 0;
    char v19 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v20 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for refresh user auth token", buf, 2u);
  }
LABEL_25:
}

- (void)getLastKnownSimDeactivationInfoFor:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  id v8 = [v6 slotID];
  if (v8 == (id)2) {
    uint64_t v9 = 2;
  }
  else {
    uint64_t v9 = v8 == (id)1;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v23[0]);
  unint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v27 = v13;
  unint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v27);
  if (v17)
  {
    uint64_t v19 = v17[3];
    uint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v18 = 0;
  char v20 = 1;
LABEL_12:
  if (v23[1]) {
    sub_10004D2C8((std::__shared_weak_count *)v23[1]);
  }
  if (!v19)
  {
    id v21 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v7[2](v7, 0, v21);
  }
  uint64_t v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  *(_OWORD *)id v23 = 0u;
  (*(void (**)(Registry **__return_ptr, uint64_t, uint64_t))(*(void *)v19 + 8))(v23, v19, v9);
  if ((_BYTE)v26)
  {
    uint64_t v22 = sub_1005B0AD4((uint64_t **)v23);
    ((void (**)(id, void *, void *))v7)[2](v7, v22, 0);
  }
  else
  {
    uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:6 userInfo:0];
    v7[2](v7, 0, v22);
  }

  sub_100DAE22C((uint64_t)v23);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
}

- (void)copyMobileSubscriberIso3CountryCode:(id)a3 MNC:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, void, id))a5;
  if (!v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = v36;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyMobileSubscriberIso3CountryCode", buf, 2u);
    }
    goto LABEL_27;
  }
  if (!v8 || !v9)
  {
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v10[2](v10, 0, v23);

    goto LABEL_27;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)buf);
  unint64_t v13 = ServiceMap;
  if (v14 < 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  v33[0] = (void *)v14;
  uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)v33);
  if (v18)
  {
    uint64_t v20 = v18[3];
    uint64_t v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      char v21 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  std::mutex::unlock(v13);
  uint64_t v19 = 0;
  char v21 = 1;
LABEL_15:
  if (v36) {
    sub_10004D2C8((std::__shared_weak_count *)v36);
  }
  if (v20)
  {
    *(void *)long long buf = 0;
    unint64_t v36 = 0;
    uint64_t v37 = 0;
    char v30 = v21;
    sub_100058DB0(v33, (char *)[v8 UTF8String]);
    sub_100058DB0(__p, (char *)[v9 UTF8String]);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void **, void **))(*(void *)v20 + 88))(buf, v20, v33, __p);
    if (v32 < 0) {
      operator delete(__p[0]);
    }
    if (v34 < 0) {
      operator delete(v33[0]);
    }
    long long v24 = +[NSMutableArray arrayWithCapacity:0xAAAAAAAAAAAAAAABLL * (((uint64_t)v36 - *(void *)buf) >> 3)];
    if (v36 != *(NSObject **)buf)
    {
      uint64_t v25 = 0;
      unint64_t v26 = 0;
      do
      {
        unint64_t v27 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
        [v24 setObject:v27 atIndexedSubscript:v26];

        ++v26;
        v25 += 24;
      }
      while (v26 < 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v36 - *(void *)buf) >> 3));
    }
    ((void (**)(id, void *, id))v10)[2](v10, v24, 0);

    v33[0] = buf;
    sub_100047F64((void ***)v33);
    if ((v30 & 1) == 0) {
LABEL_26:
    }
      sub_10004D2C8(v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v28 = v36;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Could not find isoCacheInterface for copyMobileSubscriberIso3CountryCode", buf, 2u);
    }
    id v29 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v10[2](v10, 0, v29);

    if ((v21 & 1) == 0) {
      goto LABEL_26;
    }
  }
LABEL_27:
}

- (void)checkEmbeddedSimHealthWithCompletion:(id)a3
{
  id v4 = (void (**)(id, BOOL, void))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v20);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v22 = v8;
    unint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v22);
    if (v12)
    {
      uint64_t v14 = v12[3];
      unint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    unint64_t v13 = 0;
    char v15 = 1;
LABEL_12:
    if (v21) {
      sub_10004D2C8(v21);
    }
    if (v14)
    {
      unsigned __int16 v17 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 288))(v14);
      if (v17 >= 0x100u)
      {
        v4[2](v4, v17 != 0, 0);
LABEL_22:
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_24;
      }
      id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      ((void (**)(id, BOOL, id))v4)[2](v4, 0, v18);
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v19 = v21;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v20) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "SubscriberSimInterface not available", (uint8_t *)&v20, 2u);
      }
      id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      ((void (**)(id, BOOL, id))v4)[2](v4, 0, v18);
    }

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v16 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v20) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler", (uint8_t *)&v20, 2u);
  }
LABEL_24:
}

- (void)supportsEmbeddedSIMWithCompletion:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v19);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v21 = v8;
    unint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v21);
    if (v12)
    {
      uint64_t v14 = v12[3];
      unint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v14)
        {
          id v17 = objc_retainBlock(v4);
          v22[0] = off_101A5A1D0;
          v22[1] = v17;
          v22[3] = v22;
          (*(void (**)(uint64_t, void *))(*(void *)v14 + 296))(v14, v22);
          sub_100060644(v22);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v18 = v20;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v19) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "SubscriberSimInterface not available", (uint8_t *)&v19, 2u);
          }
          (*((void (**)(id, void))v4 + 2))(v4, 0);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    unint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v16 = v20;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v19) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion", (uint8_t *)&v19, 2u);
  }
LABEL_21:
}

- (void)copyMccOrPlmnsListForIso3CountryCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_32;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      unint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v29 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v29);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v33) {
          sub_10004D2C8(v33);
        }
        if (v17)
        {
          *(void *)long long buf = 0;
          id v33 = 0;
          uint64_t v34 = 0;
          sub_100058DB0(buf, (char *)[v6 UTF8String]);
          unint64_t v21 = (std::__shared_weak_count *)HIBYTE(v34);
          if (v34 < 0) {
            unint64_t v21 = v33;
          }
          if (v21)
          {
            unint64_t v29 = 0;
            uint64_t v30 = 0;
            uint64_t v31 = 0;
            (*(void (**)(unint64_t *__return_ptr, uint64_t, uint8_t *))(*(void *)v17 + 96))(&v29, v17, buf);
            unint64_t v22 = +[NSMutableArray arrayWithCapacity:0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - v29) >> 3)];
            if (v30 != v29)
            {
              uint64_t v23 = 0;
              unint64_t v24 = 0;
              do
              {
                uint64_t v25 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
                [v22 setObject:v25 atIndexedSubscript:v24];

                ++v24;
                v23 += 24;
              }
              while (v24 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - v29) >> 3));
            }
            ((void (**)(id, void *, id))v7)[2](v7, v22, 0);

            uint64_t v35 = (void **)&v29;
            sub_100047F64(&v35);
          }
          else
          {
            id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v28);
          }
          if (SHIBYTE(v34) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v26 = v33;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find isoCacheInterface for copyMobileSubscriberIso3CountryCode", buf, 2u);
          }
          id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          v7[2](v7, 0, v27);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v33;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for copyMccOrPlmnsListForIso3CountryCode", buf, 2u);
  }
LABEL_32:
}

- (void)isAnySimReadyWithCompletion:(id)a3
{
  id v4 = (void (**)(id, void, id))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v16 = v20;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion", (uint8_t *)&v19, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v19);
  id v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v8;
  unint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v21);
  if (!v12)
  {
    uint64_t v14 = 0;
    goto LABEL_11;
  }
  uint64_t v14 = v12[3];
  uint64_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13)
  {
LABEL_11:
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
LABEL_12:
  if (v20) {
    sub_10004D2C8((std::__shared_weak_count *)v20);
  }
  if (!v14)
  {
    id v18 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v4[2](v4, 0, v18);

    if (v15) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 304))(v14);
  v4[2](v4, v17, 0);
  if ((v15 & 1) == 0) {
LABEL_16:
  }
    sub_10004D2C8(v13);
LABEL_17:
}

- (void)isSimMatching:(id)a3 carrierDescriptors:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void, id))a5;
  if (!v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v24 = v41;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid completion", buf, 2u);
    }
    goto LABEL_15;
  }
  if (!v9 || ![v9 count] || (uint64_t v11 = sub_10003E318(v8), !v11))
  {
    id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v10[2](v10, 0, v23);

    goto LABEL_15;
  }
  if ([(CTXPCClientHandler *)self hasEntitlement:33])
  {
LABEL_6:
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)buf);
    uint64_t v14 = ServiceMap;
    if ((v15 & 0x8000000000000000) != 0)
    {
      uint64_t v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        unint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v42 = v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, &v42);
    if (v19)
    {
      uint64_t v21 = v19[3];
      id v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    id v20 = 0;
    char v22 = 1;
LABEL_25:
    if (v41) {
      sub_10004D2C8((std::__shared_weak_count *)v41);
    }
    if (v21)
    {
      id v39 = v9;
      CFRetain(v9);
      uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)v21 + 312))(v21, v11, &v39);
      v10[2](v10, v35, 0);
      sub_100044D00(&v39);
      if ((v22 & 1) == 0) {
        goto LABEL_49;
      }
    }
    else
    {
      id v36 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
      v10[2](v10, 0, v36);

      if ((v22 & 1) == 0) {
        goto LABEL_49;
      }
    }
    goto LABEL_15;
  }
  [(CTXPCClientHandler *)self registry];
  unint64_t v26 = (std::mutex *)Registry::getServiceMap(v25, *(Registry **)buf);
  id v27 = v26;
  if ((v28 & 0x8000000000000000) != 0)
  {
    unint64_t v29 = (unsigned __int8 *)(v28 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v30 = 5381;
    do
    {
      unint64_t v28 = v30;
      unsigned int v31 = *v29++;
      uint64_t v30 = (33 * v30) ^ v31;
    }
    while (v31);
  }
  std::mutex::lock(v26);
  unint64_t v42 = v28;
  char v32 = sub_10004D37C(&v27[1].__m_.__sig, &v42);
  if (v32)
  {
    id v33 = (GestaltUtilityInterface *)v32[3];
    id v20 = (std::__shared_weak_count *)v32[4];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v27);
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v20);
      char v34 = 0;
      goto LABEL_34;
    }
  }
  else
  {
    id v33 = 0;
  }
  std::mutex::unlock(v27);
  id v20 = 0;
  char v34 = 1;
LABEL_34:
  if (v41) {
    sub_10004D2C8((std::__shared_weak_count *)v41);
  }
  if (v33)
  {
    if (((GestaltUtilityInterface::isIPhone(v33) & 1) != 0 || GestaltUtilityInterface::isIPad(v33))
      && ![(CTXPCClientHandler *)self isLinkedOnOrAfterVersion:@"18.0"]
      && [(CTXPCClientHandler *)self hasEntitlement:16])
    {
      if ((v34 & 1) == 0) {
        sub_10004D2C8(v20);
      }
      goto LABEL_6;
    }
    id v38 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:13 userInfo:0];
    v10[2](v10, 0, v38);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v37 = v41;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Missing gestalt", buf, 2u);
    }
    id v38 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:1 userInfo:0];
    v10[2](v10, 0, v38);
  }

  if ((v34 & 1) == 0) {
LABEL_49:
  }
    sub_10004D2C8(v20);
LABEL_15:
}

- (void)dataUsageForLastPeriods:(unint64_t)a3 completion:(id)a4
{
  id v6 = (void (**)(id, void, id))a4;
  if (v6)
  {
    if (!a3)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v6[2](v6, 0, v19);

      goto LABEL_23;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, v24);
    id v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v26 = v10;
    uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v26);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v25) {
          sub_10004D2C8(v25);
        }
        if (v16)
        {
          id v20 = objc_retainBlock(v6);
          uint64_t v21 = self;
          v27[0] = off_101A5FD50;
          v27[1] = v20;
          v27[2] = v21;
          v27[3] = v27;
          (*(void (**)(uint64_t, unint64_t, void *))(*(void *)v16 + 176))(v16, a3, v27);
          sub_10071E5C0(v27);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v22 = v25;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v24) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for getting app data usage.", (uint8_t *)&v24, 2u);
          }
          id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v6[2](v6, 0, v23);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v18 = v25;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v24) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for data usage query", (uint8_t *)&v24, 2u);
  }
LABEL_23:
}

- (void)dataUsageForLastPeriodsOnActivePairedDevice:(unint64_t)a3 completion:(id)a4
{
  id v6 = (void (**)(id, void, id))a4;
  if (!v6)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v18 = v32;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for data usage query on active paired device", buf, 2u);
    }
    goto LABEL_31;
  }
  if (!a3)
  {
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v6[2](v6, 0, v19);

    goto LABEL_31;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)buf);
  id v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v29 = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v29);
  if (!v14)
  {
    uint64_t v16 = 0;
    goto LABEL_13;
  }
  uint64_t v16 = v14[3];
  unint64_t v15 = (std::__shared_weak_count *)v14[4];
  if (!v15)
  {
LABEL_13:
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
LABEL_14:
  if (v32) {
    sub_10004D2C8((std::__shared_weak_count *)v32);
  }
  if (v16)
  {
    xpc_object_t v28 = 0;
    xpc_object_t v20 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v21 = v20;
    if (v20)
    {
      xpc_object_t v28 = v20;
    }
    else
    {
      xpc_object_t v21 = xpc_null_create();
      xpc_object_t v28 = v21;
      if (!v21)
      {
        xpc_object_t v23 = xpc_null_create();
        xpc_object_t v21 = 0;
        goto LABEL_25;
      }
    }
    if (xpc_get_type(v21) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v21);
      goto LABEL_26;
    }
    xpc_object_t v23 = xpc_null_create();
LABEL_25:
    xpc_object_t v28 = v23;
LABEL_26:
    xpc_release(v21);
    xpc_object_t v26 = xpc_int64_create(a3);
    if (!v26) {
      xpc_object_t v26 = xpc_null_create();
    }
    *(void *)long long buf = &v28;
    char v32 = "kPeriods";
    sub_100035E70((uint64_t)buf, &v26, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v26);
    xpc_object_t v26 = 0;
    unint64_t v24 = self;
    uint64_t v25 = objc_retainBlock(v6);
    v30[0] = off_101A5FDD0;
    v30[1] = v24;
    int v30[2] = v25;
    v30[3] = v30;
    long long v29 = 0uLL;
    operator new();
  }
  id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
  v6[2](v6, 0, v22);

  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
LABEL_31:
}

- (void)billingCycleEndDatesForLastPeriods:(unint64_t)a3 completion:(id)a4
{
  id v6 = (void (**)(id, void, id))a4;
  if (v6)
  {
    if (!a3)
    {
      id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v6[2](v6, 0, v19);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, v23);
    id v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v25 = v10;
    uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v25);
    if (v14)
    {
      uint64_t v16 = v14[3];
      unint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_14:
        if (v24) {
          sub_10004D2C8(v24);
        }
        if (v16)
        {
          (*(void (**)(uint64_t, unint64_t))(*(void *)v16 + 184))(v16, a3);
          id v20 = (id)objc_claimAutoreleasedReturnValue();
          if (v20) {
            id v21 = 0;
          }
          else {
            id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          }
          ((void (**)(id, id, id))v6)[2](v6, v20, v21);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v22 = v24;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v23) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for billing cycle end dates query.", (uint8_t *)&v23, 2u);
          }
          id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v6[2](v6, 0, v20);
        }

        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    unint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v18 = v24;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v23) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for billing cycle end dates query", (uint8_t *)&v23, 2u);
  }
LABEL_26:
}

- (void)usageCollectionEnabled:(id)a3
{
  id v4 = (void (**)(id, id, void))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v19);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v21 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v21);
    if (v12)
    {
      uint64_t v14 = v12[3];
      unsigned int v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v14)
        {
          id v17 = +[NSNumber numberWithBool:(*(uint64_t (**)(uint64_t))(*(void *)v14 + 16))(v14)];
          v4[2](v4, v17, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unsigned int v18 = v20;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v19) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for getting if usage collection is enabled.", (uint8_t *)&v19, 2u);
          }
          id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, id, id))v4)[2](v4, 0, v17);
        }

        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    unsigned int v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v16 = v20;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v19) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for billing cycle end dates query", (uint8_t *)&v19, 2u);
  }
LABEL_21:
}

- (void)setUsageCollectionEnabled:(BOOL)a3 completion:(id)a4
{
  BOOL v4 = a3;
  id v6 = (void (**)(id, void))a4;
  if (!v6)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v18 = v22;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting usage collection", (uint8_t *)&v21, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, v21);
  id v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v23 = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v23);
  if (v14)
  {
    uint64_t v16 = v14[3];
    char v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  char v15 = 0;
  char v17 = 1;
LABEL_12:
  if (v22) {
    sub_10004D2C8((std::__shared_weak_count *)v22);
  }
  if (v16)
  {
    (*(void (**)(uint64_t, BOOL))(*(void *)v16 + 24))(v16, v4);
    v6[2](v6, 0);
    if ((v17 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = v22;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for setting usage collection.", (uint8_t *)&v21, 2u);
    }
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, id))v6)[2](v6, v20);

    if ((v17 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)userEnteredMonthlyBudget:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_33;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)__p);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v17)
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v30 = 0;
          [(CTXPCClientHandler *)self registry];
          [v6 slotID];
          PersonalityIdFromSlotId();
          if (SHIBYTE(v28) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
            if (SHIBYTE(v28) < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)__p;
            uint64_t v30 = v28;
          }
          if (v26) {
            sub_10004D2C8(v26);
          }
          uint64_t v23 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v17 + 192))(v17, buf);
          if (v24)
          {
            id v25 = +[NSNumber numberWithUnsignedLongLong:v23];
            ((void (**)(id, id, void *))v7)[2](v7, v25, 0);
          }
          else
          {
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v25);
          }

          if (SHIBYTE(v30) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v21 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for user entered monthly budget query.", buf, 2u);
          }
          id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v22);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for user entered monthly budget query", buf, 2u);
  }
LABEL_33:
}

- (void)setUserEntered:(id)a3 monthlyBudget:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unint64_t v10 = (void (**)(id, void *))a5;
  if (v10)
  {
    if (!v8)
    {
      uint64_t v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, v23);

      goto LABEL_36;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)buf);
    uint64_t v13 = ServiceMap;
    if (v14 < 0)
    {
      char v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        uint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v14;
    char v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)__p);
    if (v18)
    {
      uint64_t v20 = v18[3];
      id v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v20)
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v31 = 0;
          [(CTXPCClientHandler *)self registry];
          [v8 slotID];
          PersonalityIdFromSlotId();
          if (SHIBYTE(v29) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
            if (SHIBYTE(v29) < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)__p;
            uint64_t v31 = v29;
          }
          if (v27) {
            sub_10004D2C8(v27);
          }
          uint64_t v26 = HIBYTE(v31);
          if (v31 < 0) {
            uint64_t v26 = *(void *)&buf[8];
          }
          if (v26
            && ((*(uint64_t (**)(uint64_t, uint8_t *, id))(*(void *)v20 + 200))(v20, buf, [v9 unsignedLongLongValue]) & 1) != 0)
          {
            id v25 = 0;
          }
          else
          {
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
          }
          v10[2](v10, v25);
          if (SHIBYTE(v31) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v24 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for setting user entered monthly budget.", buf, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v10[2](v10, v25);
        }

        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    id v19 = 0;
    char v21 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v22 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting user entered monthly budget", buf, 2u);
  }
LABEL_36:
}

- (void)clearUserEnteredMonthlyBudget:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_36;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)__p);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v17)
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v28 = 0;
          [(CTXPCClientHandler *)self registry];
          [v6 slotID];
          PersonalityIdFromSlotId();
          if (SHIBYTE(v26) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
            if (SHIBYTE(v26) < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)__p;
            uint64_t v28 = v26;
          }
          if (v24) {
            sub_10004D2C8(v24);
          }
          uint64_t v23 = HIBYTE(v28);
          if (v28 < 0) {
            uint64_t v23 = *(void *)&buf[8];
          }
          if (v23 && ((*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v17 + 208))(v17, buf) & 1) != 0) {
            id v22 = 0;
          }
          else {
            id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
          }
          v7[2](v7, v22);
          if (SHIBYTE(v28) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v21 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for clearing user entered monthly budget.", buf, 2u);
          }
          id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v22);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for clearing user entered monthly budget", buf, 2u);
  }
LABEL_36:
}

- (void)userEnteredMonthlyRoamingBudget:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_33;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)__p);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v17)
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v30 = 0;
          [(CTXPCClientHandler *)self registry];
          [v6 slotID];
          PersonalityIdFromSlotId();
          if (SHIBYTE(v28) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
            if (SHIBYTE(v28) < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)__p;
            uint64_t v30 = v28;
          }
          if (v26) {
            sub_10004D2C8(v26);
          }
          uint64_t v23 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v17 + 216))(v17, buf);
          if (v24)
          {
            id v25 = +[NSNumber numberWithUnsignedLongLong:v23];
            ((void (**)(id, id, void *))v7)[2](v7, v25, 0);
          }
          else
          {
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v25);
          }

          if (SHIBYTE(v30) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v21 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for user entered monthly budget query.", buf, 2u);
          }
          id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v22);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for user entered monthly budget query", buf, 2u);
  }
LABEL_33:
}

- (void)setUserEntered:(id)a3 monthlyRoamingBudget:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unint64_t v10 = (void (**)(id, void *))a5;
  if (v10)
  {
    if (!v8)
    {
      uint64_t v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, v23);

      goto LABEL_36;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)buf);
    uint64_t v13 = ServiceMap;
    if (v14 < 0)
    {
      char v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        uint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v14;
    char v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)__p);
    if (v18)
    {
      uint64_t v20 = v18[3];
      id v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v20)
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v31 = 0;
          [(CTXPCClientHandler *)self registry];
          [v8 slotID];
          PersonalityIdFromSlotId();
          if (SHIBYTE(v29) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
            if (SHIBYTE(v29) < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)__p;
            uint64_t v31 = v29;
          }
          if (v27) {
            sub_10004D2C8(v27);
          }
          uint64_t v26 = HIBYTE(v31);
          if (v31 < 0) {
            uint64_t v26 = *(void *)&buf[8];
          }
          if (v26
            && ((*(uint64_t (**)(uint64_t, uint8_t *, id))(*(void *)v20 + 224))(v20, buf, [v9 unsignedLongLongValue]) & 1) != 0)
          {
            id v25 = 0;
          }
          else
          {
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
          }
          v10[2](v10, v25);
          if (SHIBYTE(v31) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v24 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for setting user entered monthly budget.", buf, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v10[2](v10, v25);
        }

        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    id v19 = 0;
    char v21 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v22 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting user entered monthly budget", buf, 2u);
  }
LABEL_36:
}

- (void)clearUserEnteredMonthlyRoamingBudget:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_36;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)__p);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v17)
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v28 = 0;
          [(CTXPCClientHandler *)self registry];
          [v6 slotID];
          PersonalityIdFromSlotId();
          if (SHIBYTE(v26) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
            if (SHIBYTE(v26) < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)__p;
            uint64_t v28 = v26;
          }
          if (v24) {
            sub_10004D2C8(v24);
          }
          uint64_t v23 = HIBYTE(v28);
          if (v28 < 0) {
            uint64_t v23 = *(void *)&buf[8];
          }
          if (v23 && ((*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v17 + 232))(v17, buf) & 1) != 0) {
            id v22 = 0;
          }
          else {
            id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
          }
          v7[2](v7, v22);
          if (SHIBYTE(v28) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v21 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for clearing user entered monthly budget.", buf, 2u);
          }
          id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v22);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for clearing user entered monthly budget", buf, 2u);
  }
LABEL_36:
}

- (void)userEnteredBillingEndDayOfMont:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_33;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)__p);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v17)
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v29 = 0;
          [(CTXPCClientHandler *)self registry];
          [v6 slotID];
          PersonalityIdFromSlotId();
          if (SHIBYTE(v27) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
            if (SHIBYTE(v27) < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)__p;
            uint64_t v29 = v27;
          }
          if (v25) {
            sub_10004D2C8(v25);
          }
          uint64_t v23 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v17 + 240))(v17, buf);
          if ((v23 & 0xFF00000000) != 0)
          {
            id v24 = +[NSNumber numberWithInt:v23];
            ((void (**)(id, id, void *))v7)[2](v7, v24, 0);
          }
          else
          {
            id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v24);
          }

          if (SHIBYTE(v29) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v21 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for getting user entered billing end day of the month.", buf, 2u);
          }
          id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v22);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for user entered billing end day of month query", buf, 2u);
  }
LABEL_33:
}

- (void)setUserEnteredBillingEnd:(id)a3 dayOfMonth:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unint64_t v10 = (void (**)(id, void *))a5;
  if (v10)
  {
    if (!v8)
    {
      uint64_t v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, v23);

      goto LABEL_36;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)buf);
    uint64_t v13 = ServiceMap;
    if (v14 < 0)
    {
      char v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        uint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v14;
    char v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)__p);
    if (v18)
    {
      uint64_t v20 = v18[3];
      id v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v20)
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v31 = 0;
          [(CTXPCClientHandler *)self registry];
          [v8 slotID];
          PersonalityIdFromSlotId();
          if (SHIBYTE(v29) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
            if (SHIBYTE(v29) < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)__p;
            uint64_t v31 = v29;
          }
          if (v27) {
            sub_10004D2C8(v27);
          }
          uint64_t v26 = HIBYTE(v31);
          if (v31 < 0) {
            uint64_t v26 = *(void *)&buf[8];
          }
          if (v26
            && ((*(uint64_t (**)(uint64_t, uint8_t *, id))(*(void *)v20 + 248))(v20, buf, [v9 intValue]) & 1) != 0)
          {
            id v25 = 0;
          }
          else
          {
            id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
          }
          v10[2](v10, v25);
          if (SHIBYTE(v31) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for setting user entered billing end day of the month.", buf, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v10[2](v10, v25);
        }

        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    id v19 = 0;
    char v21 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v22 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting user entered billing end day of the month", buf, 2u);
  }
LABEL_36:
}

- (void)clearUserEnteredBillingEndDayOfMonth:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_36;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)__p);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v17)
        {
          memset(buf, 0, sizeof(buf));
          uint64_t v28 = 0;
          [(CTXPCClientHandler *)self registry];
          [v6 slotID];
          PersonalityIdFromSlotId();
          if (SHIBYTE(v26) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
            if (SHIBYTE(v26) < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)__p;
            uint64_t v28 = v26;
          }
          if (v24) {
            sub_10004D2C8(v24);
          }
          uint64_t v23 = HIBYTE(v28);
          if (v28 < 0) {
            uint64_t v23 = *(void *)&buf[8];
          }
          if (v23 && ((*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v17 + 256))(v17, buf) & 1) != 0) {
            id v22 = 0;
          }
          else {
            id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
          }
          v7[2](v7, v22);
          if (SHIBYTE(v28) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v21 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find DataUsageController for clearing user entered billing end day of the month.", buf, 2u);
          }
          id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v22);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for clearing user entered billing end day of the month", buf, 2u);
  }
LABEL_36:
}

- (void)getCellularUsageWorkspaceInfo:(id)a3
{
  BOOL v4 = (void (**)(id, id, void))a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)buf);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v36 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v36);
    if (v12)
    {
      uint64_t v13 = v12[3];
      unsigned int v14 = (std::__shared_weak_count *)v12[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v15 = 0;
LABEL_12:
        if (v35) {
          sub_10004D2C8(v35);
        }
        if (v13)
        {
          (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v13 + 8))(buf, v13);
          id v17 = *(id *)buf;
          sub_100057D78((const void **)buf);
          id v18 = objc_alloc((Class)CTCellularUsageWorkspaceInfo);
          uint64_t v19 = [v17 objectForKey:@"kCTCellularUsageSubscriberTag"];
          uint64_t v20 = [v17 objectForKey:@"kCTCellularUsageMetaDataForHomeCountry"];
          [v17 objectForKey:@"kCTCellularUsageMetaDataForRoaming"];
          char v30 = v15;
          char v32 = (void *)v20;
          uint64_t v31 = v33 = (void *)v19;
          uint64_t v29 = [v17 objectForKey:@"kCTCellularUsageBillingCycleEndDate"];
          uint64_t v28 = [v17 objectForKey:@"kCTCellularUsagePreviousBillingCycleDate"];
          uint64_t v27 = [v17 objectForKey:@"kCTCellularUsageBillingCycleSupported"];
          char v21 = [v17 objectForKey:@"kCTCellularUsageCarrierSpaceSupported"];
          id v22 = [v17 objectForKey:@"kCTCellularUsageWorkspaceName"];
          uint64_t v23 = [v17 objectForKey:@"kCTCellularUsageWorkspacePath"];
          id v24 = [v18 initWithSubscriberTag:v33 metaDataForHomeCountry:v32 metaDataForRoaming:v31 billingCycleEndDate:v29 previousBillingCycleDate:v28 billingCycleSupported:v27 carrierSpaceSupported:v21 workspaceName:v22 workspacePath:v23];

          v4[2](v4, v24, 0);
          char v15 = v30;
          id v25 = v17;
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v26 = v35;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find data usage controller", buf, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          ((void (**)(id, id, id))v4)[2](v4, 0, v25);
        }

        if ((v15 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v7);
    unsigned int v14 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v16 = v35;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Missing completion handler", buf, 2u);
  }
LABEL_21:
}

- (void)isPrivateNetworkContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v28);
    uint64_t v10 = ServiceMap;
    unsigned int v11 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unsigned int v11 = (const char *)v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    char v30 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v30);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v29) {
          sub_10004D2C8(v29);
        }
        if (v17)
        {
          if (v6
            && ((id v20 = [v6 slotID], v20 != (id)2) ? (v21 = v20 == (id)1) : (v21 = 2), v21))
          {
            id v22 = self;
            id v23 = objc_retainBlock(v7);
            v31[0] = off_101A63880;
            v31[1] = v22;
            v31[2] = v23;
            v31[3] = v31;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 824))(v17, v21, v31);
            sub_1000F25E0(v31);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v24 = v29;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v28) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "No slot in context", (uint8_t *)&v28, 2u);
            }
            id v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v25);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v26 = v29;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v28) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for isPrivateNetworkContext", (uint8_t *)&v28, 2u);
          }
          id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v7 + 2))(v7, 0, v27);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v28) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for isPrivateNetworkContext", (uint8_t *)&v28, 2u);
  }
LABEL_29:
}

- (void)getPrivateNetworkCapabilitiesForContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v28);
    uint64_t v10 = ServiceMap;
    unsigned int v11 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unsigned int v11 = (const char *)v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    char v30 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v30);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v29) {
          sub_10004D2C8(v29);
        }
        if (v17)
        {
          if (v6
            && ((id v20 = [v6 slotID], v20 != (id)2) ? (v21 = v20 == (id)1) : (v21 = 2), v21))
          {
            id v22 = self;
            id v23 = objc_retainBlock(v7);
            v31[0] = off_101A63900;
            v31[1] = v22;
            v31[2] = v23;
            v31[3] = v31;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 832))(v17, v21, v31);
            sub_10030D458(v31);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v24 = v29;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v28) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "No slot in context", (uint8_t *)&v28, 2u);
            }
            id v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v25);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v26 = v29;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v28) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for getPrivateNetworkCapabilitiesForContext", (uint8_t *)&v28, 2u);
          }
          id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v7 + 2))(v7, 0, v27);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v28) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getPrivateNetworkCapabilitiesForContext", (uint8_t *)&v28, 2u);
  }
LABEL_29:
}

- (void)isPrivateNetworkSIM:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v27);
    uint64_t v10 = ServiceMap;
    unsigned int v11 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unsigned int v11 = (const char *)v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v29 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v29);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v28) {
          sub_10004D2C8(v28);
        }
        if (v17)
        {
          if (v6
            && ((id v20 = [v6 slotID], v20 != (id)2) ? (v21 = v20 == (id)1) : (v21 = 2), v21))
          {
            id v22 = objc_retainBlock(v7);
            v30[0] = off_101A63990;
            v30[1] = v22;
            v30[3] = v30;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 856))(v17, v21, v30);
            sub_100060644(v30);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v23 = v28;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v27) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "No slot in context", (uint8_t *)&v27, 2u);
            }
            id v24 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
            (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v24);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v25 = v28;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v27) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for isPrivateNetworkSIM", (uint8_t *)&v27, 2u);
          }
          id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v7 + 2))(v7, 0, v26);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v27) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for isPrivateNetworkSIM", (uint8_t *)&v27, 2u);
  }
LABEL_29:
}

- (void)isPrivateNetworkEvaluationNeeded:(id)a3
{
  BOOL v4 = (void (**)(id, uint64_t, void))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v16 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for isPrivateNetworkEvaluationNeeded", (uint8_t *)&v20, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v20);
  id v7 = ServiceMap;
  unint64_t v8 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    id v9 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = (const char *)v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  id v22 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v22);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_12:
  if (v21) {
    sub_10004D2C8((std::__shared_weak_count *)v21);
  }
  if (v14)
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 864))(v14);
    v4[2](v4, v17, 0);
    if ((v15 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v13);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for isPrivateNetworkEvaluationNeeded", (uint8_t *)&v20, 2u);
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    ((void (**)(id, uint64_t, id))v4)[2](v4, 0, v19);

    if ((v15 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)isPrivateNetworkPreferredOverWifi:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v27);
    uint64_t v10 = ServiceMap;
    unsigned int v11 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unsigned int v11 = (const char *)v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v29 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v29);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v28) {
          sub_10004D2C8(v28);
        }
        if (v17)
        {
          if (v6
            && ((id v20 = [v6 slotID], v20 != (id)2) ? (v21 = v20 == (id)1) : (v21 = 2), v21))
          {
            id v22 = objc_retainBlock(v7);
            v30[0] = off_101A63A10;
            v30[1] = v22;
            v30[3] = v30;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 848))(v17, v21, v30);
            sub_100060644(v30);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v23 = v28;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v27) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "No slot in context", (uint8_t *)&v27, 2u);
            }
            id v24 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
            (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v24);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v25 = v28;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v27) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for isPrivateNetworkPreferredOverWifi", (uint8_t *)&v27, 2u);
          }
          id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v7 + 2))(v7, 0, v26);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v19 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v27) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for isPrivateNetworkPreferredOverWifi", (uint8_t *)&v27, 2u);
  }
LABEL_29:
}

- (void)updateGeofenceProfile:(id)a3 completion:(id)a4
{
  id v44 = a3;
  id v6 = a4;
  if (v6)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, (Registry *)buf);
    id v9 = ServiceMap;
    uint64_t v10 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      unsigned int v11 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = (const char *)v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long v55 = v10;
    unsigned int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v55);
    if (v14)
    {
      char v15 = (std::__shared_weak_count *)v14[4];
      uint64_t v43 = v14[3];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v16 = v15;
        sub_10004D2C8(v15);
        char v42 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v43 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v16 = 0;
    char v42 = 1;
LABEL_12:
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    char v41 = v16;
    if (v43)
    {
      if (v44)
      {
        char v18 = [v44 geofenceList];
        if (v18)
        {
          id v19 = [v44 dataSetName];
          BOOL v20 = v19 == 0;

          if (!v20)
          {
            uint64_t v72 = 0;
            long long v70 = 0u;
            long long v71 = 0u;
            long long v68 = 0u;
            long long v69 = 0u;
            long long v66 = 0u;
            long long v67 = 0u;
            long long buf = 0u;
            long long v65 = 0u;
            sub_100058DB0((void *)&v67 + 1, "");
            sub_100058DB0(&v69, "");
            WORD4(v70) = 0;
            HIDWORD(v70) = 0;
            *((void *)&v71 + 1) = 0;
            uint64_t v72 = 0;
            *(void *)&long long v71 = (char *)&v71 + 8;
            LODWORD(buf) = 1;
            uint64_t v21 = [v44 dataSetName];
            if (v21)
            {
              id v9 = [v44 dataSetName];
              id v22 = (char *)[(std::mutex *)v9 UTF8String];
            }
            else
            {
              id v22 = "";
            }
            sub_10003ED78((std::string *)((char *)&buf + 8), v22);
            if (v21) {

            }
            id v24 = [v44 versionNumber];
            if (v24)
            {
              id v9 = [v44 versionNumber];
              id v25 = (char *)[(std::mutex *)v9 UTF8String];
            }
            else
            {
              id v25 = "";
            }
            sub_10003ED78((std::string *)&v66, v25);
            if (v24) {

            }
            BYTE9(v70) = [v44 cellularDataPreferred];
            unint64_t v26 = (unint64_t)[v44 NRStandaloneMode];
            if (v26 < 3) {
              HIDWORD(v70) = dword_1015812F4[v26];
            }
            long long v62 = 0u;
            long long v63 = 0u;
            long long v60 = 0u;
            long long v61 = 0u;
            id v27 = [v44 geofenceList];
            id v28 = [v27 countByEnumeratingWithState:&v60 objects:v74 count:16];
            if (v28)
            {
              uint64_t v29 = 0;
              uint64_t v30 = *(void *)v61;
              for (uint64_t i = *(void *)v61; ; uint64_t i = *(void *)v61)
              {
                if (i != v30) {
                  objc_enumerationMutation(v27);
                }
                char v32 = *(void **)(*((void *)&v60 + 1) + 8 * v29);
                uint64_t v59 = 0;
                long long v57 = 0u;
                long long __p = 0u;
                long long v55 = 0u;
                long long v56 = 0u;
                id v33 = [v32 radius];
                [v33 doubleValue];
                *(void *)&long long v55 = v34;

                uint64_t v35 = [v32 longitude];
                [v35 doubleValue];
                *((void *)&v55 + 1) = v36;

                uint64_t v37 = [v32 latitude];
                [v37 doubleValue];
                *(void *)&long long v56 = v38;

                id v39 = [v32 geofenceId];
                sub_10003ED78((std::string *)((char *)&v56 + 8), (char *)[v39 UTF8String]);

                sub_100606AD8((uint64_t **)&v71, (void **)&v56 + 1, (long long *)((char *)&v56 + 8), &v55);
                if (SHIBYTE(v59) < 0) {
                  operator delete((void *)__p);
                }
                if (SHIBYTE(v57) < 0) {
                  operator delete(*((void **)&v56 + 1));
                }
                if (++v29 >= (unint64_t)v28)
                {
                  id v28 = [v27 countByEnumeratingWithState:&v60 objects:v74 count:16];
                  if (!v28) {
                    break;
                  }
                  uint64_t v29 = 0;
                }
              }
            }

            sub_10006891C((uint64_t)v45, (uint64_t)&buf);
            id v40 = objc_retainBlock(v6);
            v73[0] = off_101A63A90;
            v73[1] = v40;
            void v73[3] = v73;
            (*(void (**)(uint64_t, unsigned char *, void *))(*(void *)v43 + 872))(v43, v45, v73);
            sub_100060644(v73);
            sub_10005CD90((uint64_t)v54, v54[1]);
            if (v53 < 0) {
              operator delete(v52);
            }
            if (v51 < 0) {
              operator delete(v50);
            }
            if (v49 < 0) {
              operator delete(v48);
            }
            if (v47 < 0) {
              operator delete(v46);
            }
            sub_10005CD90((uint64_t)&v71, *((void **)&v71 + 1));
            if (SBYTE7(v70) < 0) {
              operator delete((void *)v69);
            }
            if (SHIBYTE(v68) < 0) {
              operator delete(*((void **)&v67 + 1));
            }
            if (SBYTE7(v67) < 0) {
              operator delete((void *)v66);
            }
            if (SHIBYTE(v65) < 0) {
              operator delete(*((void **)&buf + 1));
            }
            goto LABEL_23;
          }
        }
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v23 = *((void *)&buf + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for updateGeofenceProfile", (uint8_t *)&buf, 2u);
      }
    }
    (*((void (**)(id, void))v6 + 2))(v6, 0);
LABEL_23:
    if ((v42 & 1) == 0) {
      sub_10004D2C8(v41);
    }
    goto LABEL_25;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v17 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid completion handler for updateGeofenceProfile", (uint8_t *)&buf, 2u);
  }
LABEL_25:
}

- (void)removeGeofenceProfile:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, (Registry *)buf);
    id v7 = ServiceMap;
    unint64_t v8 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      id v9 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = (const char *)v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v38 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v38);
    if (v12)
    {
      uint64_t v14 = v12[3];
      unsigned int v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v14)
        {
          uint64_t v37 = 0;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v33 = 0u;
          long long v34 = 0u;
          long long v31 = 0u;
          long long v32 = 0u;
          long long buf = 0u;
          long long v30 = 0u;
          sub_100058DB0((void *)&v32 + 1, "");
          sub_100058DB0(&v34, "");
          WORD4(v35) = 0;
          HIDWORD(v35) = 0;
          *((void *)&v36 + 1) = 0;
          uint64_t v37 = 0;
          *(void *)&long long v36 = (char *)&v36 + 8;
          LODWORD(buf) = 1;
          sub_10006891C((uint64_t)v19, (uint64_t)&buf);
          id v17 = objc_retainBlock(v4);
          v39[0] = off_101A63B10;
          v39[1] = v17;
          v39[3] = v39;
          (*(void (**)(uint64_t, unsigned char *, void *))(*(void *)v14 + 872))(v14, v19, v39);
          sub_100060644(v39);
          sub_10005CD90((uint64_t)v28, v28[1]);
          if (v27 < 0) {
            operator delete(__p);
          }
          if (v25 < 0) {
            operator delete(v24);
          }
          if (v23 < 0) {
            operator delete(v22);
          }
          if (v21 < 0) {
            operator delete(v20);
          }
          sub_10005CD90((uint64_t)&v36, *((void **)&v36 + 1));
          if (SBYTE7(v35) < 0) {
            operator delete((void *)v34);
          }
          if (SHIBYTE(v33) < 0) {
            operator delete(*((void **)&v32 + 1));
          }
          if (SBYTE7(v32) < 0) {
            operator delete((void *)v31);
          }
          if (SHIBYTE(v30) < 0) {
            operator delete(*((void **)&buf + 1));
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v18 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for removeGeofenceProfile", (uint8_t *)&buf, 2u);
          }
          (*((void (**)(id, void))v4 + 2))(v4, 0);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    unsigned int v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v16 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for removeGeofenceProfile", (uint8_t *)&buf, 2u);
  }
LABEL_36:
}

- (void)deleteHiddenSims:(id)a3
{
  id v4 = (Block_layout *)a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v5 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Invalid completion handler for deleteHiddenSims", (uint8_t *)&v20, 2u);
    }
    id v4 = &stru_101A63850;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, v20);
  unint64_t v8 = ServiceMap;
  id v9 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      id v9 = (const char *)v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  id v22 = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v22);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
LABEL_13:
  if (v21) {
    sub_10004D2C8((std::__shared_weak_count *)v21);
  }
  if (v15)
  {
    id v17 = objc_retainBlock(v4);
    v23[0] = off_101A63B90;
    v23[1] = v17;
    v23[3] = v23;
    (*(void (**)(uint64_t, void *))(*(void *)v15 + 888))(v15, v23);
    sub_100313668(v23);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for deleteHiddenSims", (uint8_t *)&v20, 2u);
    }
    id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
    v4->invoke(v4, v19);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

- (void)installPrivateNetworkProfile:(id)a3 completion:(id)a4
{
  id v7 = a3;
  id v8 = a4;
  char v51 = v7;
  if (!v8)
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for installPrivateNetworkProfile", (uint8_t *)&buf, 2u);
    }
    goto LABEL_74;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, (Registry *)buf);
  uint64_t v11 = ServiceMap;
  unsigned int v12 = "22CellularPlanController";
  if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
  {
    unsigned int v13 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unsigned int v12 = (const char *)v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v62 = v12;
  char v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v62);
  if (!v16)
  {
    uint64_t v50 = 0;
    goto LABEL_11;
  }
  id v17 = (std::__shared_weak_count *)v16[4];
  uint64_t v50 = v16[3];
  if (!v17)
  {
LABEL_11:
    std::mutex::unlock(v11);
    long long v48 = 0;
    char v49 = 1;
    goto LABEL_12;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  long long v48 = v17;
  sub_10004D2C8(v17);
  char v49 = 0;
LABEL_12:
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (v50)
  {
    if (v7
      && ([v7 versionNumber], (id v19 = objc_claimAutoreleasedReturnValue()) != 0)
      && ([v7 dataSetName],
          BOOL v20 = objc_claimAutoreleasedReturnValue(),
          BOOL v21 = v20 == 0,
          v20,
          v19,
          !v21))
    {
      uint64_t v79 = 0;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v73 = 0u;
      long long v74 = 0u;
      long long buf = 0u;
      long long v72 = 0u;
      sub_100058DB0((void *)&v74 + 1, "");
      sub_100058DB0(&v76, "");
      WORD4(v77) = 0;
      HIDWORD(v77) = 0;
      *((void *)&v78 + 1) = 0;
      uint64_t v79 = 0;
      *(void *)&long long v78 = (char *)&v78 + 8;
      LODWORD(buf) = 1;
      id v22 = [v7 dataSetName];
      if (v22)
      {
        id v4 = [v51 dataSetName];
        char v23 = (char *)[v4 UTF8String];
      }
      else
      {
        char v23 = "";
      }
      sub_10003ED78((std::string *)((char *)&buf + 8), v23);
      if (v22) {

      }
      char v27 = [v51 versionNumber];
      if (v27)
      {
        id v4 = [v51 versionNumber];
        id v28 = (char *)[v4 UTF8String];
      }
      else
      {
        id v28 = "";
      }
      sub_10003ED78((std::string *)&v73, v28);
      if (v27) {

      }
      id v29 = [v51 csgNetworkIdentifier];
      if (v29)
      {
        id v4 = [v51 csgNetworkIdentifier];
        long long v30 = (char *)[v4 UTF8String];
      }
      else
      {
        long long v30 = "";
      }
      sub_10003ED78((std::string *)((char *)&v74 + 8), v30);
      if (v29) {

      }
      long long v31 = [v51 networkIdentifier];
      if (v31)
      {
        id v29 = [v51 networkIdentifier];
        long long v32 = (char *)[v29 UTF8String];
      }
      else
      {
        long long v32 = "";
      }
      sub_10003ED78((std::string *)&v76, v32);
      if (v31) {

      }
      BYTE9(v77) = [v51 cellularDataPreferred];
      unint64_t v33 = (unint64_t)[v51 NRStandaloneMode];
      if (v33 < 3) {
        HIDWORD(v77) = dword_1015812F4[v33];
      }
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v34 = [v51 geofenceList];
      id v35 = [v34 countByEnumeratingWithState:&v67 objects:v81 count:16];
      if (v35)
      {
        uint64_t v36 = 0;
        uint64_t v37 = *(void *)v68;
        for (uint64_t i = *(void *)v68; ; uint64_t i = *(void *)v68)
        {
          if (i != v37) {
            objc_enumerationMutation(v34);
          }
          id v39 = *(void **)(*((void *)&v67 + 1) + 8 * v36);
          uint64_t v66 = 0;
          long long v64 = 0u;
          long long __p = 0u;
          long long v62 = 0u;
          long long v63 = 0u;
          id v40 = [v39 radius];
          [v40 doubleValue];
          *(void *)&long long v62 = v41;

          char v42 = [v39 longitude];
          [v42 doubleValue];
          *((void *)&v62 + 1) = v43;

          id v44 = [v39 latitude];
          [v44 doubleValue];
          *(void *)&long long v63 = v45;

          id v46 = [v39 geofenceId];
          sub_10003ED78((std::string *)((char *)&v63 + 8), (char *)[v46 UTF8String]);

          sub_100606AD8((uint64_t **)&v78, (void **)&v63 + 1, (long long *)((char *)&v63 + 8), &v62);
          if (SHIBYTE(v66) < 0) {
            operator delete((void *)__p);
          }
          if (SHIBYTE(v64) < 0) {
            operator delete(*((void **)&v63 + 1));
          }
          if (++v36 >= (unint64_t)v35)
          {
            id v35 = [v34 countByEnumeratingWithState:&v67 objects:v81 count:16];
            if (!v35) {
              break;
            }
            uint64_t v36 = 0;
          }
        }
      }

      sub_10006891C((uint64_t)v52, (uint64_t)&buf);
      id v47 = objc_retainBlock(v8);
      v80[0] = off_101A63C10;
      v80[1] = v47;
      v80[3] = v80;
      (*(void (**)(uint64_t, unsigned char *, uint64_t, void *))(*(void *)v50 + 896))(v50, v52, 1, v80);
      sub_10030D830(v80);
      sub_10005CD90((uint64_t)v61, v61[1]);
      if (v60 < 0) {
        operator delete(v59);
      }
      if (v58 < 0) {
        operator delete(v57);
      }
      if (v56 < 0) {
        operator delete(v55);
      }
      if (v54 < 0) {
        operator delete(v53);
      }
      sub_10005CD90((uint64_t)&v78, *((void **)&v78 + 1));
      if (SBYTE7(v77) < 0) {
        operator delete((void *)v76);
      }
      if (SHIBYTE(v75) < 0) {
        operator delete(*((void **)&v74 + 1));
      }
      if (SBYTE7(v74) < 0) {
        operator delete((void *)v73);
      }
      if (SHIBYTE(v72) < 0) {
        operator delete(*((void **)&buf + 1));
      }
    }
    else
    {
      unint64_t v26 = +[NSError errorWithDomain:&stru_101AC1B28 code:4 userInfo:0];
      (*((void (**)(id, void *))v8 + 2))(v8, v26);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v24 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for installPrivateNetworkProfile", (uint8_t *)&buf, 2u);
    }
    char v25 = +[NSError errorWithDomain:&stru_101AC1B28 code:0 userInfo:0];
    (*((void (**)(id, void *))v8 + 2))(v8, v25);
  }
  if ((v49 & 1) == 0) {
    sub_10004D2C8(v48);
  }
LABEL_74:
}

- (void)removePrivateNetworkProfile:(id)a3 completion:(id)a4
{
  id v7 = a3;
  id v8 = a4;
  if (v8)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v9, (Registry *)buf);
    uint64_t v11 = ServiceMap;
    unsigned int v12 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      unsigned int v13 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        unsigned int v12 = (const char *)v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v52 = v12;
    char v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v52);
    if (v16)
    {
      uint64_t v18 = v16[3];
      id v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        uint64_t v4 = 1;
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
LABEL_12:
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        if (v18)
        {
          if (v7)
          {
            uint64_t v51 = 0;
            long long v49 = 0u;
            long long v50 = 0u;
            long long v47 = 0u;
            long long v48 = 0u;
            long long v45 = 0u;
            long long v46 = 0u;
            long long buf = 0u;
            long long v44 = 0u;
            sub_100058DB0((void *)&v46 + 1, "");
            sub_100058DB0(&v48, "");
            WORD4(v49) = 0;
            HIDWORD(v49) = 0;
            *((void *)&v50 + 1) = 0;
            uint64_t v51 = 0;
            *(void *)&long long v50 = (char *)&v50 + 8;
            BOOL v21 = [v7 dataSetName];
            if (v21)
            {
              uint64_t v4 = [v7 dataSetName];
              id v22 = (char *)[(id)v4 UTF8String];
            }
            else
            {
              id v22 = "";
            }
            sub_10003ED78((std::string *)((char *)&buf + 8), v22);
            if (v21) {

            }
            unint64_t v26 = [v7 versionNumber];
            if (v26)
            {
              uint64_t v4 = [v7 versionNumber];
              char v27 = (char *)[(id)v4 UTF8String];
            }
            else
            {
              char v27 = "";
            }
            sub_10003ED78((std::string *)&v45, v27);
            if (v26) {

            }
            id v28 = [v7 csgNetworkIdentifier];
            if (v28)
            {
              uint64_t v4 = [v7 csgNetworkIdentifier];
              id v29 = (char *)[(id)v4 UTF8String];
            }
            else
            {
              id v29 = "";
            }
            sub_10003ED78((std::string *)((char *)&v46 + 8), v29);
            if (v28) {

            }
            long long v30 = [v7 networkIdentifier];
            if (v30)
            {
              id v28 = [v7 networkIdentifier];
              long long v31 = (char *)[v28 UTF8String];
            }
            else
            {
              long long v31 = "";
            }
            sub_10003ED78((std::string *)&v48, v31);
            if (v30) {

            }
            sub_10006891C((uint64_t)v33, (uint64_t)&buf);
            id v32 = objc_retainBlock(v8);
            v53[0] = off_101A63C90;
            v53[1] = v32;
            uint64_t v53[3] = v53;
            (*(void (**)(uint64_t, unsigned char *, void, void *))(*(void *)v18 + 896))(v18, v33, 0, v53);
            sub_10030D830(v53);
            sub_10005CD90((uint64_t)v42, v42[1]);
            if (v41 < 0) {
              operator delete(__p);
            }
            if (v39 < 0) {
              operator delete(v38);
            }
            if (v37 < 0) {
              operator delete(v36);
            }
            if (v35 < 0) {
              operator delete(v34);
            }
            sub_10005CD90((uint64_t)&v50, *((void **)&v50 + 1));
            if (SBYTE7(v49) < 0) {
              operator delete((void *)v48);
            }
            if (SHIBYTE(v47) < 0) {
              operator delete(*((void **)&v46 + 1));
            }
            if (SBYTE7(v46) < 0) {
              operator delete((void *)v45);
            }
            if (SHIBYTE(v44) < 0) {
              operator delete(*((void **)&buf + 1));
            }
          }
          else
          {
            char v25 = +[NSError errorWithDomain:&stru_101AC1B28 code:4 userInfo:0];
            (*((void (**)(id, void *))v8 + 2))(v8, v25);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v23 = *((void *)&buf + 1);
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for installPrivateNetworkProfile", (uint8_t *)&buf, 2u);
          }
          id v24 = +[NSError errorWithDomain:&stru_101AC1B28 code:0 userInfo:0];
          (*((void (**)(id, void *))v8 + 2))(v8, v24);
        }
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        goto LABEL_58;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    id v17 = 0;
    char v19 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  BOOL v20 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler for installPrivateNetworkProfile", (uint8_t *)&buf, 2u);
  }
LABEL_58:
}

- (void)updatePrivateNetworkProfile:(id)a3 setProfileAside:(BOOL)a4 completion:(id)a5
{
  BOOL v7 = a4;
  id v9 = a3;
  id v10 = a5;
  if (v10)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, (Registry *)buf);
    unsigned int v13 = ServiceMap;
    uint64_t v14 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      unsigned int v15 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        uint64_t v14 = (const char *)v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    long long v55 = v14;
    uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&v55);
    if (v18)
    {
      uint64_t v20 = v18[3];
      char v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        uint64_t v5 = 1;
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v35 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    char v19 = 0;
    char v35 = 1;
LABEL_12:
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    if (v20)
    {
      if (v9)
      {
        uint64_t v54 = 0;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        long long buf = 0u;
        long long v47 = 0u;
        sub_100058DB0((void *)&v49 + 1, "");
        sub_100058DB0(&v51, "");
        WORD4(v52) = 0;
        HIDWORD(v52) = 0;
        *((void *)&v53 + 1) = 0;
        uint64_t v54 = 0;
        *(void *)&long long v53 = (char *)&v53 + 8;
        id v22 = [v9 dataSetName];
        if (v22)
        {
          uint64_t v5 = [v9 dataSetName];
          char v23 = (char *)[(id)v5 UTF8String];
        }
        else
        {
          char v23 = "";
        }
        sub_10003ED78((std::string *)((char *)&buf + 8), v23);
        if (v22) {

        }
        id v28 = [v9 versionNumber];
        if (v28)
        {
          uint64_t v5 = [v9 versionNumber];
          id v29 = (char *)[(id)v5 UTF8String];
        }
        else
        {
          id v29 = "";
        }
        sub_10003ED78((std::string *)&v48, v29);
        if (v28) {

        }
        id v30 = [v9 csgNetworkIdentifier];
        if (v30)
        {
          uint64_t v5 = [v9 csgNetworkIdentifier];
          long long v31 = (char *)[(id)v5 UTF8String];
        }
        else
        {
          long long v31 = "";
        }
        sub_10003ED78((std::string *)((char *)&v49 + 8), v31);
        if (v30) {

        }
        id v32 = [v9 networkIdentifier];
        if (v32)
        {
          id v30 = [v9 networkIdentifier];
          unint64_t v33 = (char *)[v30 UTF8String];
        }
        else
        {
          unint64_t v33 = "";
        }
        sub_10003ED78((std::string *)&v51, v33);
        if (v32) {

        }
        sub_10006891C((uint64_t)v36, (uint64_t)&buf);
        id v34 = objc_retainBlock(v10);
        v56[0] = off_101A63D10;
        v56[1] = v34;
        v56[3] = v56;
        (*(void (**)(uint64_t, unsigned char *, BOOL, void *))(*(void *)v20 + 904))(v20, v36, v7, v56);
        sub_10030D830(v56);
        sub_10005CD90((uint64_t)v45, v45[1]);
        if (v44 < 0) {
          operator delete(__p);
        }
        if (v42 < 0) {
          operator delete(v41);
        }
        if (v40 < 0) {
          operator delete(v39);
        }
        if (v38 < 0) {
          operator delete(v37);
        }
        sub_10005CD90((uint64_t)&v53, *((void **)&v53 + 1));
        if (SBYTE7(v52) < 0) {
          operator delete((void *)v51);
        }
        char v27 = v35;
        if (SHIBYTE(v50) < 0) {
          operator delete(*((void **)&v49 + 1));
        }
        if (SBYTE7(v49) < 0) {
          operator delete((void *)v48);
        }
        if (SHIBYTE(v47) < 0) {
          operator delete(*((void **)&buf + 1));
        }
        goto LABEL_57;
      }
      unint64_t v26 = +[NSError errorWithDomain:&stru_101AC1B28 code:4 userInfo:0];
      (*((void (**)(id, void *))v10 + 2))(v10, v26);
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v24 = *((void *)&buf + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for installPrivateNetworkProfile", (uint8_t *)&buf, 2u);
      }
      char v25 = +[NSError errorWithDomain:&stru_101AC1B28 code:0 userInfo:0];
      (*((void (**)(id, void *))v10 + 2))(v10, v25);
    }
    char v27 = v35;
LABEL_57:
    if ((v27 & 1) == 0) {
      sub_10004D2C8(v19);
    }
    goto LABEL_59;
  }
  [(CTXPCClientHandler *)self getLogContext];
  BOOL v21 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for installPrivateNetworkProfile", (uint8_t *)&buf, 2u);
  }
LABEL_59:
}

- (void)getPrivateNetworkSimInfoForContext:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v28);
    id v10 = ServiceMap;
    uint64_t v11 = "22CellularPlanController";
    if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
    {
      unsigned int v12 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = (const char *)v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    id v30 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v30);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_12:
        if (v29) {
          sub_10004D2C8(v29);
        }
        if (v17)
        {
          if (v6
            && ((id v20 = [v6 slotID], v20 != (id)2) ? (v21 = v20 == (id)1) : (v21 = 2), v21))
          {
            id v22 = self;
            id v23 = objc_retainBlock(v7);
            v31[0] = off_101A63D90;
            v31[1] = v22;
            v31[2] = v23;
            v31[3] = v31;
            (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 840))(v17, v21, v31);
            sub_10030D4DC(v31);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v24 = v29;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v28) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "No slot in context", (uint8_t *)&v28, 2u);
            }
            char v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            (*((void (**)(id, void, void *))v7 + 2))(v7, 0, v25);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v26 = v29;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v28) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find CellularPlanController for getPrivateNetworkSimInfoForContext", (uint8_t *)&v28, 2u);
          }
          id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:19 userInfo:0];
          (*((void (**)(id, void, id))v7 + 2))(v7, 0, v27);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v19 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v28) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getPrivateNetworkSimInfoForContext", (uint8_t *)&v28, 2u);
  }
LABEL_29:
}

- (void)getEosStatus:(id)a3
{
  uint64_t v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    *(void *)long long buf = 0;
    unsigned int v14 = 0;
    id v12 = 0;
    [(CTXPCClientHandler *)self registry];
    sub_100F35B30(buf, &v12, &v10, v5);
    id v6 = v12;
    if (v11) {
      sub_10004D2C8(v11);
    }
    if (v6)
    {
      v4[2](v4, 0, v6);
    }
    else
    {
      uint64_t v8 = *(void *)buf;
      id v9 = objc_retainBlock(v4);
      v15[0] = off_101A70C90;
      v15[1] = v9;
      v15[3] = v15;
      (*(void (**)(uint64_t, void *))(*(void *)v8 + 56))(v8, v15);
      sub_100433030(v15);
    }
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v7 = v14;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
    }
  }
}

- (void)setEosStatus:(id)a3 assertionState:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, void, id))a5;
  if (v10)
  {
    *(void *)long long buf = 0;
    id v24 = 0;
    id v22 = 0;
    [(CTXPCClientHandler *)self registry];
    sub_100F35B30(buf, &v22, &v20, v11);
    id v12 = v22;
    if (v21) {
      sub_10004D2C8(v21);
    }
    if (v12)
    {
      v10[2](v10, 0, v12);
    }
    else
    {
      uint64_t v14 = *(void *)buf;
      sub_100058DB0(v18, (char *)[v8 UTF8String]);
      sub_100058DB0(__p, (char *)[v9 UTF8String]);
      unsigned int v15 = objc_retainBlock(v10);
      v25[0] = off_101A70D20;
      v25[1] = v15;
      v25[3] = v25;
      (*(void (**)(uint64_t, void **, void **, void *))(*(void *)v14 + 64))(v14, v18, __p, v25);
      sub_100433188(v25);
      if (v17 < 0) {
        operator delete(__p[0]);
      }
      if (v19 < 0) {
        operator delete(v18[0]);
      }
    }
    if (v24) {
      sub_10004D2C8(v24);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v13 = v24;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid completion handler", buf, 2u);
    }
  }
}

- (void)getEOSFirmwareUpdateInfo:(id)a3
{
  uint64_t v4 = (void (**)(id, void, id))a3;
  if (v4)
  {
    *(void *)long long buf = 0;
    id v28 = 0;
    id v26 = 0;
    [(CTXPCClientHandler *)self registry];
    sub_100F35B30(buf, &v26, &v24, v5);
    id v6 = v26;
    if (v25) {
      sub_10004D2C8(v25);
    }
    if (v6)
    {
      v4[2](v4, 0, v6);
LABEL_23:
      if (v28) {
        sub_10004D2C8(v28);
      }

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v22);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v29 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v29);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_16:
        if (v23) {
          sub_10004D2C8(v23);
        }
        if (v17)
        {
          v20[0] = _NSConcreteStackBlock;
          v20[1] = 3221225472;
          v20[2] = sub_100F363B4;
          v20[3] = &unk_101A595D8;
          void v20[4] = self;
          uint64_t v21 = v4;
          (*(void (**)(uint64_t, void, void *, uint64_t))(*(void *)v17 + 136))(v17, 0, v20, 1);
          id v19 = v21;
        }
        else
        {
          id v19 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v4[2](v4, 0, v19);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_16;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v7 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid completion handler for getEOSFirmwareUpdateInfo", buf, 2u);
  }
LABEL_26:
}

- (optional<PhoneServicesType>)serviceFromCFName:(id)a3
{
  uint64_t v3 = (__CFString *)a3;
  if (CFStringCompare(v3, kCTCapabilityAgent, 0))
  {
    if (CFStringCompare(v3, kCTCapabilityAgent2, 0))
    {
      if (CFStringCompare(v3, kCTCapabilityPhoneServices, 0))
      {
        if (CFStringCompare(v3, kCTCapabilityAgent3, 0))
        {
          if (CFStringCompare(v3, kCTCapabilityNetworkSlicing, 0))
          {
            CFComparisonResult v4 = CFStringCompare(v3, kCTCapabilitySatellite, 0);
            unint64_t v5 = (unint64_t)(v4 == kCFCompareEqualTo) << 32;
            if (v4) {
              uint64_t v6 = 0;
            }
            else {
              uint64_t v6 = 5;
            }
          }
          else
          {
            unint64_t v5 = (unint64_t)&_mh_execute_header;
            uint64_t v6 = 4;
          }
        }
        else
        {
          unint64_t v5 = (unint64_t)&_mh_execute_header;
          uint64_t v6 = 3;
        }
      }
      else
      {
        unint64_t v5 = (unint64_t)&_mh_execute_header;
        uint64_t v6 = 1;
      }
    }
    else
    {
      uint64_t v6 = 0;
      unint64_t v5 = (unint64_t)&_mh_execute_header;
    }
  }
  else
  {
    unint64_t v5 = (unint64_t)&_mh_execute_header;
    uint64_t v6 = 2;
  }

  return (optional<PhoneServicesType>)(v6 | v5);
}

- (void)context:(id)a3 canSetCapability:(id)a4 completion:(id)a5
{
  void (***v25)(Registry **__return_ptr, void, void **);
  char v26;
  NSObject *v27;
  void *v28;
  NSObject *v29;
  void *v30;
  NSObject *v31;
  void *v32;
  int v33;
  int v34;
  void *v35;
  NSObject *v36;
  void *v37;
  uint64_t *v38;
  std::mutex *v39;
  std::mutex *v40;
  uint64_t v41;
  unsigned __int8 *v42;
  uint64_t v43;
  unsigned int v44;
  void *v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  char v48;
  id v49;
  uint64_t v50;
  uint64_t *v51;
  id v52;
  uint64_t v53;
  uint64_t v54;
  NSObject *v55;
  NSObject *v56;
  std::__shared_weak_count *v57;
  void *v58;
  id v59;
  id v60;
  NSObject *v61;
  NSObject *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const char *p_p;
  const char *v67;
  Registry *v68;
  std::__shared_weak_count *v69;
  const void *v70;
  void *__p;
  uint64_t v72;
  uint64_t v73;
  const void *v74;
  unsigned char buf[22];
  __int16 v76;
  const void *v77;

  id v8 = a3;
  id v9 = (__CFString *)a4;
  id v10 = a5;
  unint64_t v11 = (void (**)(void, void, void, void))v10;
  if (!v8 || !v9 || !v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v27 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "not enough arguments", buf, 2u);
      if (!v11) {
        goto LABEL_19;
      }
    }
    else if (!v11)
    {
LABEL_19:
      uint64_t v13 = v8;
      goto LABEL_44;
    }
    id v28 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void, void, void *))v11)[2](v11, 0, 0, v28);

    goto LABEL_19;
  }
  id v12 = [(CTXPCClientHandler *)self dataProviderDelegate];
  uint64_t v13 = [v12 resolveContext:v8];

  if (v13)
  {
    long long __p = 0;
    long long v72 = 0;
    long long v73 = 0;
    [(CTXPCClientHandler *)self registry];
    unsigned int v14 = [v13 uuid];
    sub_1005B09D4(v14, (CFUUIDRef *)&v68);
    PersonalityIdFromUuid();
    sub_10012577C((const void **)&v68);

    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    uint64_t v15 = HIBYTE(v73);
    if (v73 < 0) {
      uint64_t v15 = v72;
    }
    if (!v15)
    {
      [(CTXPCClientHandler *)self getLogContext];
      long long v31 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        char v58 = [v13 uuid];
        uint64_t v59 = [v58 UUIDString];
        char v60 = [v59 UTF8String];
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v60;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "no personality for UUID '%s'", buf, 0xCu);
      }
      id v32 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
      ((void (**)(void, void, void, void *))v11)[2](v11, 0, 0, v32);

      goto LABEL_42;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)buf);
    char v18 = ServiceMap;
    if (v19 < 0)
    {
      id v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    long long v68 = (Registry *)v19;
    id v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&v68);
    if (v23)
    {
      char v25 = (void (***)(Registry **__return_ptr, void, void **))v23[3];
      id v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        id v26 = 0;
        goto LABEL_28;
      }
    }
    else
    {
      char v25 = 0;
    }
    std::mutex::unlock(v18);
    id v24 = 0;
    id v26 = 1;
LABEL_28:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (!v25)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v36 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "CT is not ready to process the request", buf, 2u);
      }
      char v37 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
      ((void (**)(void, void, void, void *))v11)[2](v11, 0, 0, v37);

      if (v26) {
        goto LABEL_42;
      }
LABEL_41:
      sub_10004D2C8(v24);
LABEL_42:
      if (SHIBYTE(v73) < 0) {
        operator delete(__p);
      }
      goto LABEL_44;
    }
    long long v70 = 0;
    if (CFStringCompare(v9, kCTCapabilityBrandedCallingInfo, 0))
    {
      if (CFStringCompare(v9, kCTCapabilityTurnOffCellular, 0))
      {
        if (((unint64_t)[(CTXPCClientHandler *)self serviceFromCFName:v9] & 0xFF00000000) != 0)
        {
          (**v25)(&v68, v25, &__p);
          (*(void (**)(unsigned char *__return_ptr))(*(void *)v68 + 48))(buf);
          unint64_t v33 = buf[0];
          long long v74 = v70;
          long long v70 = *(const void **)&buf[8];
          *(void *)&uint8_t buf[8] = 0;
          sub_100057D78(&v74);
          id v34 = buf[16];
          sub_100057D78((const void **)&buf[8]);
          if (v69) {
            sub_10004D2C8(v69);
          }
          if (v34)
          {
            char v35 = 0;
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            long long v55 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
            {
              long long v64 = asString();
              long long v65 = HIBYTE(v73);
              if (v73 < 0) {
                long long v65 = v72;
              }
              p_p = (const char *)&__p;
              if (v73 < 0) {
                p_p = (const char *)__p;
              }
              if (v65) {
                long long v67 = p_p;
              }
              else {
                long long v67 = "<invalid>";
              }
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = v64;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v67;
              _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "%s CanSet IS NOT READY for '%s'", buf, 0x16u);
            }
            char v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
          }
          goto LABEL_87;
        }
LABEL_77:
        char v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        unint64_t v33 = 0;
        goto LABEL_87;
      }
      long long v49 = [v13 slotID];
      if (v49 == (id)2) {
        long long v50 = 2;
      }
      else {
        long long v50 = v49 == (id)1;
      }
      if (!v50)
      {
        [(CTXPCClientHandler *)self getLogContext];
        char v56 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Shouldn't call kCTCapabilityTurnOffCellular for non-slot context", buf, 2u);
        }
        goto LABEL_77;
      }
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      [(CTXPCClientHandler *)self registry];
      sub_101095458(v68, buf, v51);
      if (v69) {
        sub_10004D2C8(v69);
      }
      if (*(void *)buf)
      {
        unint64_t v33 = (*(uint64_t (**)(void, uint64_t))(**(void **)buf + 208))(*(void *)buf, v50);
        char v35 = 0;
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        long long v61 = v69;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v68);
        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v68) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "Could not find BasebandSettingsInterface for CanSet kCTCapabilityTurnOffCellular", (uint8_t *)&v68, 2u);
        }
        char v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        unint64_t v33 = 0;
      }
      long long v57 = *(std::__shared_weak_count **)&buf[8];
      if (!*(void *)&buf[8])
      {
LABEL_87:
        [(CTXPCClientHandler *)self getLogContext];
        long long v62 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
        {
          long long v63 = asStringBool(v33 != 0);
          *(_DWORD *)long long buf = 138412802;
          *(void *)&uint8_t buf[4] = v9;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = v63;
          long long v76 = 2112;
          long long v77 = v70;
          _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_INFO, "%@ CanSet = %s with [%@]", buf, 0x20u);
        }
        ((void (**)(void, BOOL, const void *, void *))v11)[2](v11, v33 != 0, v70, v35);

        sub_100057D78(&v70);
        if (v26) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }
LABEL_86:
      sub_10004D2C8(v57);
      goto LABEL_87;
    }
    [(CTXPCClientHandler *)self registry];
    char v39 = (std::mutex *)Registry::getServiceMap(v38, *(Registry **)buf);
    char v40 = v39;
    if (v41 < 0)
    {
      char v42 = (unsigned __int8 *)(v41 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v43 = 5381;
      do
      {
        char v41 = v43;
        char v44 = *v42++;
        uint64_t v43 = (33 * v43) ^ v44;
      }
      while (v44);
    }
    std::mutex::lock(v39);
    long long v68 = (Registry *)v41;
    long long v45 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)&v68);
    if (v45)
    {
      long long v46 = v45[3];
      long long v47 = (std::__shared_weak_count *)v45[4];
      if (v47)
      {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v40);
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v47);
        long long v48 = 0;
        goto LABEL_64;
      }
    }
    else
    {
      long long v46 = 0;
    }
    std::mutex::unlock(v40);
    long long v47 = 0;
    long long v48 = 1;
LABEL_64:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v46)
    {
      if ([v13 slotID])
      {
        long long v52 = [v13 slotID];
        if (v52 == (id)2) {
          long long v53 = 2;
        }
        else {
          long long v53 = v52 == (id)1;
        }
        unint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v46 + 56))(v46, v53);
        char v35 = 0;
        goto LABEL_80;
      }
      uint64_t v54 = 2;
    }
    else
    {
      uint64_t v54 = 35;
    }
    char v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:v54 userInfo:0];
    unint64_t v33 = 0;
LABEL_80:
    if (v48) {
      goto LABEL_87;
    }
    long long v57 = v47;
    goto LABEL_86;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v29 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "no valid context found", buf, 2u);
  }
  id v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  ((void (**)(void, void, void, void *))v11)[2](v11, 0, 0, v30);

  uint64_t v13 = 0;
LABEL_44:
}

- (void)context:(id)a3 getCapability:(id)a4 completion:(id)a5
{
  void (***v25)(Registry **__return_ptr, void, void **);
  char v26;
  NSObject *v27;
  void *v28;
  NSObject *v29;
  void *v30;
  NSObject *v31;
  void *v32;
  int v33;
  int v34;
  void *v35;
  NSObject *v36;
  void *v37;
  uint64_t *v38;
  std::mutex *v39;
  std::mutex *v40;
  uint64_t v41;
  unsigned __int8 *v42;
  uint64_t v43;
  unsigned int v44;
  void *v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  char v48;
  id v49;
  uint64_t v50;
  uint64_t *v51;
  id v52;
  uint64_t v53;
  uint64_t v54;
  NSObject *v55;
  NSObject *v56;
  std::__shared_weak_count *v57;
  void *v58;
  id v59;
  id v60;
  NSObject *v61;
  NSObject *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const char *p_p;
  const char *v67;
  Registry *v68;
  std::__shared_weak_count *v69;
  const void *v70;
  void *__p;
  uint64_t v72;
  uint64_t v73;
  const void *v74;
  unsigned char buf[22];
  __int16 v76;
  const void *v77;

  id v8 = a3;
  id v9 = (__CFString *)a4;
  id v10 = a5;
  unint64_t v11 = (void (**)(void, void, void, void))v10;
  if (!v8 || !v9 || !v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v27 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "not enough arguments", buf, 2u);
      if (!v11) {
        goto LABEL_19;
      }
    }
    else if (!v11)
    {
LABEL_19:
      uint64_t v13 = v8;
      goto LABEL_44;
    }
    id v28 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void, void, void *))v11)[2](v11, 0, 0, v28);

    goto LABEL_19;
  }
  id v12 = [(CTXPCClientHandler *)self dataProviderDelegate];
  uint64_t v13 = [v12 resolveContext:v8];

  if (v13)
  {
    long long __p = 0;
    long long v72 = 0;
    long long v73 = 0;
    [(CTXPCClientHandler *)self registry];
    unsigned int v14 = [v13 uuid];
    sub_1005B09D4(v14, (CFUUIDRef *)&v68);
    PersonalityIdFromUuid();
    sub_10012577C((const void **)&v68);

    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    uint64_t v15 = HIBYTE(v73);
    if (v73 < 0) {
      uint64_t v15 = v72;
    }
    if (!v15)
    {
      [(CTXPCClientHandler *)self getLogContext];
      long long v31 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        char v58 = [v13 uuid];
        uint64_t v59 = [v58 UUIDString];
        char v60 = [v59 UTF8String];
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v60;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "no personality for UUID '%s'", buf, 0xCu);
      }
      id v32 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
      ((void (**)(void, void, void, void *))v11)[2](v11, 0, 0, v32);

      goto LABEL_42;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)buf);
    char v18 = ServiceMap;
    if (v19 < 0)
    {
      id v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    long long v68 = (Registry *)v19;
    id v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)&v68);
    if (v23)
    {
      char v25 = (void (***)(Registry **__return_ptr, void, void **))v23[3];
      id v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        id v26 = 0;
        goto LABEL_28;
      }
    }
    else
    {
      char v25 = 0;
    }
    std::mutex::unlock(v18);
    id v24 = 0;
    id v26 = 1;
LABEL_28:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (!v25)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v36 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "CT is not ready to process the request", buf, 2u);
      }
      char v37 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
      ((void (**)(void, void, void, void *))v11)[2](v11, 0, 0, v37);

      if (v26) {
        goto LABEL_42;
      }
LABEL_41:
      sub_10004D2C8(v24);
LABEL_42:
      if (SHIBYTE(v73) < 0) {
        operator delete(__p);
      }
      goto LABEL_44;
    }
    long long v70 = 0;
    if (CFStringCompare(v9, kCTCapabilityBrandedCallingInfo, 0))
    {
      if (CFStringCompare(v9, kCTCapabilityTurnOffCellular, 0))
      {
        if (((unint64_t)[(CTXPCClientHandler *)self serviceFromCFName:v9] & 0xFF00000000) != 0)
        {
          (**v25)(&v68, v25, &__p);
          (*(void (**)(unsigned char *__return_ptr))(*(void *)v68 + 40))(buf);
          unint64_t v33 = buf[0];
          long long v74 = v70;
          long long v70 = *(const void **)&buf[8];
          *(void *)&uint8_t buf[8] = 0;
          sub_100057D78(&v74);
          id v34 = buf[16];
          sub_100057D78((const void **)&buf[8]);
          if (v69) {
            sub_10004D2C8(v69);
          }
          if (v34)
          {
            char v35 = 0;
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            long long v55 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
            {
              long long v64 = asString();
              long long v65 = HIBYTE(v73);
              if (v73 < 0) {
                long long v65 = v72;
              }
              p_p = (const char *)&__p;
              if (v73 < 0) {
                p_p = (const char *)__p;
              }
              if (v65) {
                long long v67 = p_p;
              }
              else {
                long long v67 = "<invalid>";
              }
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = v64;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v67;
              _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "%s Get IS NOT READY for '%s'", buf, 0x16u);
            }
            char v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
          }
          goto LABEL_87;
        }
LABEL_77:
        char v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        unint64_t v33 = 0;
        goto LABEL_87;
      }
      long long v49 = [v13 slotID];
      if (v49 == (id)2) {
        long long v50 = 2;
      }
      else {
        long long v50 = v49 == (id)1;
      }
      if (!v50)
      {
        [(CTXPCClientHandler *)self getLogContext];
        char v56 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Shouldn't call kCTCapabilityTurnOffCellular for non-slot context", buf, 2u);
        }
        goto LABEL_77;
      }
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      [(CTXPCClientHandler *)self registry];
      sub_101095458(v68, buf, v51);
      if (v69) {
        sub_10004D2C8(v69);
      }
      if (*(void *)buf)
      {
        unint64_t v33 = (*(uint64_t (**)(void, uint64_t))(**(void **)buf + 200))(*(void *)buf, v50);
        char v35 = 0;
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        long long v61 = v69;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v68);
        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v68) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "Could not find BasebandSettingsInterface for Get kCTCapabilityTurnOffCellular", (uint8_t *)&v68, 2u);
        }
        char v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        unint64_t v33 = 0;
      }
      long long v57 = *(std::__shared_weak_count **)&buf[8];
      if (!*(void *)&buf[8])
      {
LABEL_87:
        [(CTXPCClientHandler *)self getLogContext];
        long long v62 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
        {
          long long v63 = asStringBool(v33 != 0);
          *(_DWORD *)long long buf = 138412802;
          *(void *)&uint8_t buf[4] = v9;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = v63;
          long long v76 = 2112;
          long long v77 = v70;
          _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_INFO, "%@ Get = %s with [%@]", buf, 0x20u);
        }
        ((void (**)(void, BOOL, const void *, void *))v11)[2](v11, v33 != 0, v70, v35);

        sub_100057D78(&v70);
        if (v26) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }
LABEL_86:
      sub_10004D2C8(v57);
      goto LABEL_87;
    }
    [(CTXPCClientHandler *)self registry];
    char v39 = (std::mutex *)Registry::getServiceMap(v38, *(Registry **)buf);
    char v40 = v39;
    if (v41 < 0)
    {
      char v42 = (unsigned __int8 *)(v41 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v43 = 5381;
      do
      {
        char v41 = v43;
        char v44 = *v42++;
        uint64_t v43 = (33 * v43) ^ v44;
      }
      while (v44);
    }
    std::mutex::lock(v39);
    long long v68 = (Registry *)v41;
    long long v45 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)&v68);
    if (v45)
    {
      long long v46 = v45[3];
      long long v47 = (std::__shared_weak_count *)v45[4];
      if (v47)
      {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v40);
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v47);
        long long v48 = 0;
        goto LABEL_64;
      }
    }
    else
    {
      long long v46 = 0;
    }
    std::mutex::unlock(v40);
    long long v47 = 0;
    long long v48 = 1;
LABEL_64:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v46)
    {
      if ([v13 slotID])
      {
        long long v52 = [v13 slotID];
        if (v52 == (id)2) {
          long long v53 = 2;
        }
        else {
          long long v53 = v52 == (id)1;
        }
        unint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v46 + 40))(v46, v53);
        char v35 = 0;
        goto LABEL_80;
      }
      uint64_t v54 = 2;
    }
    else
    {
      uint64_t v54 = 35;
    }
    char v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:v54 userInfo:0];
    unint64_t v33 = 0;
LABEL_80:
    if (v48) {
      goto LABEL_87;
    }
    long long v57 = v47;
    goto LABEL_86;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v29 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "no valid context found", buf, 2u);
  }
  id v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  ((void (**)(void, void, void, void *))v11)[2](v11, 0, 0, v30);

  uint64_t v13 = 0;
LABEL_44:
}

- (void)context:(id)a3 setCapability:(id)a4 enabled:(BOOL)a5 info:(id)a6 completion:(id)a7
{
  void (***v30)(unsigned char *__return_ptr, void, void **);
  char v31;
  NSObject *v32;
  void *v33;
  NSObject *v34;
  void *v35;
  NSObject *v36;
  void *v37;
  optional<PhoneServicesType> v38;
  optional<PhoneServicesType> v39;
  int v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  NSObject *v45;
  uint64_t *v46;
  std::mutex *v47;
  std::mutex *v48;
  uint64_t v49;
  unsigned __int8 *v50;
  uint64_t v51;
  unsigned int v52;
  void *v53;
  std::__shared_weak_count *v54;
  uint64_t v55;
  char v56;
  id v57;
  uint64_t v58;
  uint64_t *v59;
  id v60;
  uint64_t v61;
  uint64_t v62;
  NSObject *v63;
  NSObject *v64;
  uint64_t v65;
  void *v66;
  id v67;
  id v68;
  NSObject *v69;
  char v70;
  BOOL v71;
  const void *v72;
  const void *v73;
  uint8_t v74[8];
  std::__shared_weak_count *v75;
  void *__p;
  uint64_t v77;
  uint64_t v78;
  unsigned char buf[22];
  __int16 v80;
  id v81;

  BOOL v9 = a5;
  id v12 = a3;
  uint64_t v13 = (__CFString *)a4;
  id v14 = a6;
  id v15 = a7;
  uint64_t v16 = (void (**)(void, void))v15;
  if (!v12 || !v13 || !v15)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v32 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "not enough arguments", buf, 2u);
      if (!v16) {
        goto LABEL_19;
      }
    }
    else if (!v16)
    {
LABEL_19:
      char v18 = v12;
      goto LABEL_90;
    }
    unint64_t v33 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void *))v16)[2](v16, v33);

    goto LABEL_19;
  }
  uint64_t v17 = [(CTXPCClientHandler *)self dataProviderDelegate];
  char v18 = [v17 resolveContext:v12];

  if (v18)
  {
    long long __p = 0;
    long long v77 = 0;
    long long v78 = 0;
    [(CTXPCClientHandler *)self registry];
    uint64_t v19 = [v18 uuid];
    sub_1005B09D4(v19, (CFUUIDRef *)v74);
    PersonalityIdFromUuid();
    sub_10012577C((const void **)v74);

    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    uint64_t v20 = HIBYTE(v78);
    if (v78 < 0) {
      uint64_t v20 = v77;
    }
    if (!v20)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v36 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        uint64_t v66 = [v18 uuid];
        long long v67 = [v66 UUIDString];
        long long v68 = [v67 UTF8String];
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v68;
        _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "no personality for UUID '%s'", buf, 0xCu);
      }
      char v37 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
      ((void (**)(void, void *))v16)[2](v16, v37);

      goto LABEL_88;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v21, *(Registry **)buf);
    id v23 = ServiceMap;
    if (v24 < 0)
    {
      char v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v26 = 5381;
      do
      {
        uint64_t v24 = v26;
        unsigned int v27 = *v25++;
        uint64_t v26 = (33 * v26) ^ v27;
      }
      while (v27);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long v74 = v24;
    id v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)v74);
    long long v71 = v9;
    if (v28)
    {
      id v30 = (void (***)(unsigned char *__return_ptr, void, void **))v28[3];
      unint64_t v29 = (std::__shared_weak_count *)v28[4];
      if (v29)
      {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v23);
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v29);
        long long v31 = 0;
        goto LABEL_28;
      }
    }
    else
    {
      id v30 = 0;
    }
    std::mutex::unlock(v23);
    unint64_t v29 = 0;
    long long v31 = 1;
LABEL_28:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (!v30)
    {
      [(CTXPCClientHandler *)self getLogContext];
      long long v45 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "CT is not ready to process the request", buf, 2u);
      }
      char v44 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
      ((void (**)(void, void *))v16)[2](v16, v44);
      goto LABEL_86;
    }
    if (CFStringCompare(v13, kCTCapabilityBrandedCallingInfo, 0))
    {
      if (CFStringCompare(v13, kCTCapabilityTurnOffCellular, 0))
      {
        char v38 = [(CTXPCClientHandler *)self serviceFromCFName:v13];
        char v39 = v38;
        if ((*(void *)&v38 & 0xFF00000000) != 0)
        {
          if (v38.var0.var1 == 1)
          {
            char v40 = sub_10121F67C();
            if (v14)
            {
              if (v40)
              {
                char v41 = v31;
                (**v30)(buf, v30, &__p);
                char v42 = *(void *)buf;
                long long v73 = v14;
                CFRetain(v14);
                (*(void (**)(uint64_t, const void **))(*(void *)v42 + 192))(v42, &v73);
                sub_100057D78(&v73);
                long long v31 = v41;
                if (*(void *)&buf[8]) {
                  sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
                }
              }
            }
          }
          (**v30)(buf, v30, &__p);
          uint64_t v43 = *(void *)buf;
          long long v72 = v14;
          if (v14) {
            CFRetain(v14);
          }
          (*(void (**)(uint64_t, optional<PhoneServicesType>, BOOL, const void **))(*(void *)v43 + 32))(v43, v39, v71, &v72);
          sub_100057D78(&v72);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          char v44 = 0;
          goto LABEL_83;
        }
      }
      else
      {
        long long v57 = [v18 slotID];
        if (v57 == (id)2) {
          char v58 = 2;
        }
        else {
          char v58 = v57 == (id)1;
        }
        if (v58)
        {
          *(void *)long long buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          [(CTXPCClientHandler *)self registry];
          sub_101095458(*(Registry **)v74, buf, v59);
          if (v75) {
            sub_10004D2C8(v75);
          }
          if (*(void *)buf)
          {
            (*(void (**)(void, uint64_t, BOOL))(**(void **)buf + 192))(*(void *)buf, v58, v9);
            char v44 = 0;
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            long long v69 = v75;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v74);
            if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long v74 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "Could not find BasebandSettingsInterface for Set kCTCapabilityTurnOffCellular", v74, 2u);
            }
            char v44 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          goto LABEL_83;
        }
        [(CTXPCClientHandler *)self getLogContext];
        long long v63 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "Shouldn't call kCTCapabilityTurnOffCellular for non-slot context", buf, 2u);
        }
      }
      char v44 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
LABEL_83:
      [(CTXPCClientHandler *)self getLogContext];
      long long v64 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
      {
        long long v65 = asStringBool(v71);
        *(_DWORD *)long long buf = 138412802;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v65;
        BOOL v80 = 2112;
        uint64_t v81 = v14;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_INFO, "%@ Set = %s with [%@]", buf, 0x20u);
      }
      ((void (**)(void, void *))v16)[2](v16, v44);
LABEL_86:

      if ((v31 & 1) == 0) {
        sub_10004D2C8(v29);
      }
LABEL_88:
      if (SHIBYTE(v78) < 0) {
        operator delete(__p);
      }
      goto LABEL_90;
    }
    long long v70 = v31;
    [(CTXPCClientHandler *)self registry];
    long long v47 = (std::mutex *)Registry::getServiceMap(v46, *(Registry **)buf);
    long long v48 = v47;
    if (v49 < 0)
    {
      long long v50 = (unsigned __int8 *)(v49 & 0x7FFFFFFFFFFFFFFFLL);
      long long v51 = 5381;
      do
      {
        long long v49 = v51;
        long long v52 = *v50++;
        long long v51 = (33 * v51) ^ v52;
      }
      while (v52);
    }
    std::mutex::lock(v47);
    *(void *)long long v74 = v49;
    long long v53 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)v74);
    if (v53)
    {
      long long v55 = v53[3];
      uint64_t v54 = (std::__shared_weak_count *)v53[4];
      if (v54)
      {
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v48);
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v54);
        char v56 = 0;
        goto LABEL_66;
      }
    }
    else
    {
      long long v55 = 0;
    }
    std::mutex::unlock(v48);
    uint64_t v54 = 0;
    char v56 = 1;
LABEL_66:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v55)
    {
      if ([v18 slotID])
      {
        char v60 = [v18 slotID];
        if (v60 == (id)2) {
          long long v61 = 2;
        }
        else {
          long long v61 = v60 == (id)1;
        }
        (*(void (**)(uint64_t, BOOL, uint64_t))(*(void *)v55 + 48))(v55, v9, v61);
        char v44 = 0;
        goto LABEL_80;
      }
      long long v62 = 2;
    }
    else
    {
      long long v62 = 35;
    }
    char v44 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:v62 userInfo:0];
LABEL_80:
    if ((v56 & 1) == 0) {
      sub_10004D2C8(v54);
    }
    long long v31 = v70;
    goto LABEL_83;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v34 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "no valid context found", buf, 2u);
  }
  char v35 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  ((void (**)(void, void *))v16)[2](v16, v35);

  char v18 = 0;
LABEL_90:
}

- (void)context:(id)a3 getSystemCapabilities:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  id v8 = (void (**)(void, void, void))v7;
  if (!v6 || !v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v24 = v33;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v32);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v32) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "not enough arguments", (uint8_t *)&v32, 2u);
      if (!v8) {
        goto LABEL_33;
      }
    }
    else if (!v8)
    {
      goto LABEL_33;
    }
    char v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void, void *))v8)[2](v8, 0, v25);

    goto LABEL_33;
  }
  BOOL v9 = [(CTXPCClientHandler *)self dataProviderDelegate];
  id v10 = [v9 resolveContext:v6];

  if (v10)
  {
    id v11 = [v10 slotID];
    if (v11 == (id)2) {
      uint64_t v12 = 2;
    }
    else {
      uint64_t v12 = v11 == (id)1;
    }
    if (!v12)
    {
      id v28 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
      ((void (**)(void, void, void *))v8)[2](v8, 0, v28);

LABEL_32:
      id v6 = v10;
      goto LABEL_33;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v13, v32);
    id v15 = ServiceMap;
    if ((v16 & 0x8000000000000000) != 0)
    {
      uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        unint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v34 = v16;
    uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, &v34);
    if (v20)
    {
      uint64_t v22 = v20[3];
      uint64_t v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
LABEL_23:
        if (v33) {
          sub_10004D2C8((std::__shared_weak_count *)v33);
        }
        if (v22)
        {
          id v29 = objc_retainBlock(v8);
          v35[0] = off_101A86088;
          v35[1] = v29;
          v35[3] = v35;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v22 + 56))(v22, v12, v35);
          sub_100E1A4F0(v35);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v30 = v33;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v32);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v32) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "CT is not ready to process the request", (uint8_t *)&v32, 2u);
          }
          long long v31 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
          ((void (**)(void, void, void *))v8)[2](v8, 0, v31);
        }
        if ((v23 & 1) == 0) {
          sub_10004D2C8(v21);
        }
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    uint64_t v21 = 0;
    char v23 = 1;
    goto LABEL_23;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v26 = v33;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v32);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v32) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "no valid context found", (uint8_t *)&v32, 2u);
  }
  unsigned int v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  ((void (**)(void, void, void *))v8)[2](v8, 0, v27);

  id v6 = 0;
LABEL_33:
}

- (void)getSupports5G:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_32;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v27);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v29 = v11;
    id v15 = sub_10004D37C(&v10[1].__m_.__sig, &v29);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v28) {
          sub_10004D2C8(v28);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          [(CTXPCClientHandler *)self registry];
          char isValidSimSlot = subscriber::isValidSimSlot();
          if (v28) {
            sub_10004D2C8(v28);
          }
          if (isValidSimSlot)
          {
            id v24 = +[NSNumber numberWithBool:(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 24))(v17, v22)];
            ((void (**)(id, id, id))v7)[2](v7, v24, 0);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v26 = v28;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v27) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Invalid slot passed when getting supports 5G", (uint8_t *)&v27, 2u);
            }
            id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v7[2](v7, 0, v24);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v25 = v28;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v27) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find CapabilitiesHandler for getting 5G support", (uint8_t *)&v27, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v19 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v27) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting 5G support query", (uint8_t *)&v27, 2u);
  }
LABEL_32:
}

- (void)context:(id)a3 recheckPhoneServicesAccountStatus:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  unint64_t v11 = (void (**)(void, void))v10;
  if (!v8 || !v9 || !v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v15 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "not enough arguments", (uint8_t *)&__p, 2u);
      if (!v11) {
        goto LABEL_11;
      }
    }
    else if (!v11)
    {
LABEL_11:
      uint64_t v13 = v8;
      goto LABEL_22;
    }
    unint64_t v16 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void *))v11)[2](v11, v16);

    goto LABEL_11;
  }
  uint64_t v12 = [(CTXPCClientHandler *)self dataProviderDelegate];
  uint64_t v13 = [v12 resolveContext:v8];

  if (v13)
  {
    long long __p = 0;
    char v25 = 0;
    uint64_t v26 = 0;
    [(CTXPCClientHandler *)self registry];
    unsigned int v14 = [v13 uuid];
    sub_1005B09D4(v14, (CFUUIDRef *)&v27);
    PersonalityIdFromUuid();
    sub_10012577C(&v27);

    if (*(void *)&buf_4[4]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf_4[4]);
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v19 = *(NSObject **)&buf_4[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      id v21 = [v13 uuid];
      id v22 = [v21 UUIDString];
      id v23 = [v22 UTF8String];
      int buf = 136315138;
      *(void *)buf_4 = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "no personality for UUID '%s'", (uint8_t *)&buf, 0xCu);
    }
    id v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
    ((void (**)(void, void *))v11)[2](v11, v20);

    if (SHIBYTE(v26) < 0) {
      operator delete(__p);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v17 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "no valid context found", (uint8_t *)&__p, 2u);
    }
    char v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void *))v11)[2](v11, v18);

    uint64_t v13 = 0;
  }
LABEL_22:
}

- (void)getPhoneServicesDeviceList:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v21);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v23);
    if (v12)
    {
      uint64_t v14 = v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v14)
        {
          uint64_t v17 = self;
          id v18 = objc_retainBlock(v4);
          v24[0] = off_101A86118;
          v24[1] = v17;
          void v24[2] = v18;
          uint64_t v24[3] = v24;
          (*(void (**)(uint64_t, void *))(*(void *)v14 + 72))(v14, v24);
          sub_1002BD56C(v24);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unsigned int v19 = v22;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v21) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "CT is not ready to process the request", (uint8_t *)&v21, 2u);
          }
          id v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
          (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v20);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v16 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v21) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "not enough arguments", (uint8_t *)&v21, 2u);
  }
LABEL_21:
}

- (void)getPhoneServicesDeviceInfo:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v21);
    id v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v23 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v23);
    if (v12)
    {
      uint64_t v14 = v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v22) {
          sub_10004D2C8(v22);
        }
        if (v14)
        {
          uint64_t v17 = self;
          id v18 = objc_retainBlock(v4);
          v24[0] = off_101A86198;
          v24[1] = v17;
          void v24[2] = v18;
          uint64_t v24[3] = v24;
          (*(void (**)(uint64_t, void *))(*(void *)v14 + 64))(v14, v24);
          sub_1002BD56C(v24);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unsigned int v19 = v22;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v21) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "CT is not ready to process the request", (uint8_t *)&v21, 2u);
          }
          id v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
          (*((void (**)(id, void, void *))v4 + 2))(v4, 0, v20);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unint64_t v16 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v21) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "not enough arguments", (uint8_t *)&v21, 2u);
  }
LABEL_21:
}

- (void)context:(id)a3 addPhoneServicesDevice:(id)a4 withCompletion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  unsigned int v11 = (void (**)(void, void))v10;
  if (!v8 || !v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v15 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "not enough arguments", (uint8_t *)&__p, 2u);
      if (!v11) {
        goto LABEL_10;
      }
    }
    else if (!v11)
    {
LABEL_10:
      uint64_t v13 = v8;
      goto LABEL_18;
    }
    unint64_t v16 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void *))v11)[2](v11, v16);

    goto LABEL_10;
  }
  uint64_t v12 = [(CTXPCClientHandler *)self dataProviderDelegate];
  uint64_t v13 = [v12 resolveContext:v8];

  if (v13)
  {
    long long __p = 0;
    char v25 = 0;
    uint64_t v26 = 0;
    [(CTXPCClientHandler *)self registry];
    uint64_t v14 = [v13 uuid];
    sub_1005B09D4(v14, (CFUUIDRef *)&v27);
    PersonalityIdFromUuid();
    sub_10012577C(&v27);

    if (*(void *)&buf_4[4]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf_4[4]);
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v19 = *(NSObject **)&buf_4[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      id v21 = [v13 uuid];
      id v22 = [v21 UUIDString];
      id v23 = [v22 UTF8String];
      int buf = 136315138;
      *(void *)buf_4 = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "no personality for UUID '%s'", (uint8_t *)&buf, 0xCu);
    }
    id v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
    ((void (**)(void, void *))v11)[2](v11, v20);

    if (SHIBYTE(v26) < 0) {
      operator delete(__p);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v17 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "no valid context found", (uint8_t *)&__p, 2u);
    }
    id v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void *))v11)[2](v11, v18);

    uint64_t v13 = 0;
  }
LABEL_18:
}

- (void)context:(id)a3 removePhoneServicesDevice:(id)a4 withCompletion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = a5;
  unsigned int v11 = (void (**)(void, void))v10;
  if (!v8 || !v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v15 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "not enough arguments", (uint8_t *)&__p, 2u);
      if (!v11) {
        goto LABEL_10;
      }
    }
    else if (!v11)
    {
LABEL_10:
      uint64_t v13 = v8;
      goto LABEL_18;
    }
    unint64_t v16 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void *))v11)[2](v11, v16);

    goto LABEL_10;
  }
  uint64_t v12 = [(CTXPCClientHandler *)self dataProviderDelegate];
  uint64_t v13 = [v12 resolveContext:v8];

  if (v13)
  {
    long long __p = 0;
    char v25 = 0;
    uint64_t v26 = 0;
    [(CTXPCClientHandler *)self registry];
    uint64_t v14 = [v13 uuid];
    sub_1005B09D4(v14, (CFUUIDRef *)&v27);
    PersonalityIdFromUuid();
    sub_10012577C(&v27);

    if (*(void *)&buf_4[4]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf_4[4]);
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v19 = *(NSObject **)&buf_4[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      id v21 = [v13 uuid];
      id v22 = [v21 UUIDString];
      id v23 = [v22 UTF8String];
      int buf = 136315138;
      *(void *)buf_4 = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "no personality for UUID '%s'", (uint8_t *)&buf, 0xCu);
    }
    id v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
    ((void (**)(void, void *))v11)[2](v11, v20);

    if (SHIBYTE(v26) < 0) {
      operator delete(__p);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v17 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "no valid context found", (uint8_t *)&__p, 2u);
    }
    id v18 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void *))v11)[2](v11, v18);

    uint64_t v13 = 0;
  }
LABEL_18:
}

- (void)wifiCallingCTFollowUpComplete:(id)a3 withCompletion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    id v8 = [v6 objectForKey:@"SlotID"];
    if (!v8)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v21 = v28;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v27) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "FollowUp do not specify target slot", (uint8_t *)&v27, 2u);
      }
      id v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v22);

      goto LABEL_31;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v9, v27);
    unsigned int v11 = ServiceMap;
    if (v12 < 0)
    {
      uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long buf = v12;
    unint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&buf);
    if (v16)
    {
      uint64_t v18 = v16[3];
      uint64_t v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
LABEL_16:
        if (v28) {
          sub_10004D2C8((std::__shared_weak_count *)v28);
        }
        if (v18)
        {
          unsigned int v27 = 0;
          id v28 = 0;
          (*(void (**)(Registry **__return_ptr, uint64_t, id))(*(void *)v18 + 8))(&v27, v18, [v8 intValue]);
          if (v27)
          {
            (*(void (**)(Registry *, id))(*(void *)v27 + 88))(v27, v6);
            v7[2](v7, 0);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            char v25 = *((void *)&buf + 1);
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf) = 138412290;
              *(void *)((char *)&buf + 4) = v8;
              _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "No PhoneServices instance for target %@", (uint8_t *)&buf, 0xCu);
            }
            uint64_t v26 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
            v7[2](v7, v26);
          }
          if (v28) {
            sub_10004D2C8((std::__shared_weak_count *)v28);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v28;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v27) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "CT is not ready to process the request", (uint8_t *)&v27, 2u);
          }
          id v24 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
          v7[2](v7, v24);
        }
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
LABEL_31:

        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    uint64_t v17 = 0;
    char v19 = 1;
    goto LABEL_16;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v20 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v27) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "no completion provided", (uint8_t *)&v27, 2u);
  }
LABEL_32:
}

- (void)context:(id)a3 mandatoryDisableVoLTE:(BOOL)a4 withCompletion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = a5;
  id v10 = (void (**)(void, void))v9;
  if (!v8 || !v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v15 = v20;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "not enough arguments", (uint8_t *)&v19, 2u);
      if (!v10) {
        goto LABEL_21;
      }
    }
    else if (!v10)
    {
      goto LABEL_21;
    }
    unint64_t v16 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void *))v10)[2](v10, v16);
LABEL_20:

    goto LABEL_21;
  }
  unsigned int v11 = [(CTXPCClientHandler *)self dataProviderDelegate];
  uint64_t v12 = [v11 resolveContext:v8];

  if (!v12)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v17 = v20;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "no valid context found", (uint8_t *)&v19, 2u);
    }
    unint64_t v16 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void *))v10)[2](v10, v16);
    id v8 = 0;
    goto LABEL_20;
  }
  id v13 = [v12 slotID];
  if (v13 == (id)2) {
    uint64_t v14 = 2;
  }
  else {
    uint64_t v14 = v13 == (id)1;
  }
  if (!v14)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = v20;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "no slot in context", (uint8_t *)&v19, 2u);
    }
    unint64_t v16 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
    ((void (**)(void, void *))v10)[2](v10, v16);
    id v8 = v12;
    goto LABEL_20;
  }
  [(CTXPCClientHandler *)self registry];
  mandatoryDisableVoLTE(&v19, v14, v6);
  if (v20) {
    sub_10004D2C8((std::__shared_weak_count *)v20);
  }
  v10[2](v10, 0);
  id v8 = v12;
LABEL_21:
}

- (void)context:(id)a3 isMandatoryDisabledVoLTE:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  id v8 = (void (**)(void, void, void))v7;
  if (!v6 || !v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v14 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v18 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "not enough arguments", v18, 2u);
      if (!v8) {
        goto LABEL_19;
      }
    }
    else if (!v8)
    {
      goto LABEL_19;
    }
    unsigned int v15 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void, void *))v8)[2](v8, 0, v15);
LABEL_18:

    goto LABEL_19;
  }
  id v9 = [(CTXPCClientHandler *)self dataProviderDelegate];
  id v10 = [v9 resolveContext:v6];

  if (!v10)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v16 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v18 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "no valid context found", v18, 2u);
    }
    unsigned int v15 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    ((void (**)(void, void, void *))v8)[2](v8, 0, v15);
    id v6 = 0;
    goto LABEL_18;
  }
  id v11 = [v10 slotID];
  if (v11 == (id)2) {
    int v12 = 2;
  }
  else {
    int v12 = v11 == (id)1;
  }
  if (!v12)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v17 = v19;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v18);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v18 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "no slot in context", v18, 2u);
    }
    unsigned int v15 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:2 userInfo:0];
    ((void (**)(void, void, void *))v8)[2](v8, 0, v15);
    id v6 = v10;
    goto LABEL_18;
  }
  BOOL v13 = isMandatoryDisabledVoLTE(v12);
  v8[2](v8, v13, 0);
  id v6 = v10;
LABEL_19:
}

- (void)copyCellInfo:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          id v23 = objc_retainBlock(v7);
          v29[0] = off_101A8E6C8;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 48))(v17, v22, v29);
          sub_100033230(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CellMonitorInterface for getting cell info", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for cell info query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyCellId:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          id v23 = objc_retainBlock(v7);
          v29[0] = off_101A8E748;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 64))(v17, v22, v29);
          sub_1003A1438(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CellMonitorInterface for getting cell ID", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for cell ID query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyPublicCellId:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_23;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v25);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v27);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          uint64_t v21 = sub_10003E318(v6);
          uint64_t v22 = objc_retainBlock(v7);
          v28[0] = off_101A8E7D8;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 96))(v17, v21, v28);
          sub_1003A14BC(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find CellMonitorInterface for getting public cell ID", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for public cell ID query", (uint8_t *)&v25, 2u);
  }
LABEL_23:
}

- (void)copyLocationAreaCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          id v23 = objc_retainBlock(v7);
          v29[0] = off_101A8E868;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 56))(v17, v22, v29);
          sub_1003A1438(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find CellMonitorInterface for getting location area code", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for location area code query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)getSweetgumCapabilities:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if (v11 < 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    dispatch_object_t object = (dispatch_object_t)v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&object);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          [(CTXPCClientHandler *)self getQueue];
          id v21 = objc_retainBlock(v7);
          dispatch_object_t object = v23;
          *(void *)long long buf = off_101A9F120;
          uint64_t v26 = v21;
          unint64_t v27 = buf;
          sub_10007CF50();
        }
        uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, 0, v22);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for Sweetgum capabilities query", buf, 2u);
  }
LABEL_20:
}

- (void)getSweetgumUserConsentInfo:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if (v11 < 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    dispatch_object_t object = (dispatch_object_t)v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&object);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          [(CTXPCClientHandler *)self getQueue];
          id v21 = objc_retainBlock(v7);
          dispatch_object_t object = v23;
          *(void *)long long buf = off_101A9F1A0;
          uint64_t v26 = v21;
          unint64_t v27 = buf;
          sub_10007D41C();
        }
        uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, 0, v22);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for Sweetgum user consent query", buf, 2u);
  }
LABEL_20:
}

- (void)setSweetgumUserConsent:(id)a3 userConsent:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = (void (**)(id, void *))a5;
  if (!v9)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v21 = v25;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v24);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v24) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler when setting Sweetgum user consent", (uint8_t *)&v24, 2u);
    }
    goto LABEL_19;
  }
  if (!v8)
  {
    uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v9[2](v9, v22);

    goto LABEL_19;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v24);
  int v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v26);
  if (!v17)
  {
    uint64_t v19 = 0;
    goto LABEL_13;
  }
  uint64_t v19 = v17[3];
  char v18 = (std::__shared_weak_count *)v17[4];
  if (!v18)
  {
LABEL_13:
    std::mutex::unlock(v12);
    char v18 = 0;
    char v20 = 1;
    goto LABEL_14;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
LABEL_14:
  if (v25) {
    sub_10004D2C8((std::__shared_weak_count *)v25);
  }
  if (!v19)
  {
    id v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v9[2](v9, v23);

    if (v20) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  (*(void (**)(uint64_t, BOOL))(*(void *)v19 + 32))(v19, v6);
  v9[2](v9, 0);
  if ((v20 & 1) == 0) {
LABEL_18:
  }
    sub_10004D2C8(v18);
LABEL_19:
}

- (void)getSweetgumUsage:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    v24[0] = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, v24);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          v24[0] = 0;
          v24[1] = 0;
          [(CTXPCClientHandler *)self getQueue];
          id v21 = objc_retainBlock(v7);
          void v24[2] = (unint64_t)v23;
          *(void *)long long buf = off_101A9F220;
          unint64_t v26 = v21;
          unint64_t v27 = buf;
          sub_10007D8E8();
        }
        uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, 0, v22);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for Sweetgum usage query", buf, 2u);
  }
LABEL_20:
}

- (void)refreshSweetgumUsage:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if (v11 < 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    dispatch_object_t object = (dispatch_object_t)v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&object);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          [(CTXPCClientHandler *)self getQueue];
          id v21 = objc_retainBlock(v7);
          dispatch_object_t object = v23;
          *(void *)long long buf = off_101A9F2A0;
          unint64_t v26 = v21;
          unint64_t v27 = buf;
          sub_10007E74C();
        }
        uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, v22);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for refresh Sweetgum usage", buf, 2u);
  }
LABEL_20:
}

- (void)getSweetgumPlans:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    v24[0] = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, v24);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          v24[0] = 0;
          v24[1] = 0;
          [(CTXPCClientHandler *)self getQueue];
          id v21 = objc_retainBlock(v7);
          void v24[2] = (unint64_t)v23;
          *(void *)long long buf = off_101A9F320;
          unint64_t v26 = v21;
          unint64_t v27 = buf;
          sub_10007DDB4();
        }
        uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, 0, v22);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for Sweetgum plans query", buf, 2u);
  }
LABEL_20:
}

- (void)refreshSweetgumPlans:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if (v11 < 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    dispatch_object_t object = (dispatch_object_t)v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&object);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          [(CTXPCClientHandler *)self getQueue];
          id v21 = objc_retainBlock(v7);
          dispatch_object_t object = v23;
          *(void *)long long buf = off_101A9F3A0;
          unint64_t v26 = v21;
          unint64_t v27 = buf;
          sub_10007E74C();
        }
        uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, v22);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for refresh Sweetgum plans", buf, 2u);
  }
LABEL_20:
}

- (void)getSweetgumApps:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    v24[0] = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, v24);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          v24[0] = 0;
          v24[1] = 0;
          [(CTXPCClientHandler *)self getQueue];
          id v21 = objc_retainBlock(v7);
          void v24[2] = (unint64_t)v23;
          *(void *)long long buf = off_101A9F420;
          unint64_t v26 = v21;
          unint64_t v27 = buf;
          sub_10007E280();
        }
        uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, 0, v22);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for Sweetgum apps query", buf, 2u);
  }
LABEL_20:
}

- (void)refreshSweetgumApps:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if (v11 < 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    dispatch_object_t object = (dispatch_object_t)v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&object);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          [(CTXPCClientHandler *)self getQueue];
          id v21 = objc_retainBlock(v7);
          dispatch_object_t object = v23;
          *(void *)long long buf = off_101A9F4A0;
          unint64_t v26 = v21;
          unint64_t v27 = buf;
          sub_10007E74C();
        }
        uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, v22);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for refresh Sweetgum apps", buf, 2u);
  }
LABEL_20:
}

- (void)refreshSweetgumAll:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if (v11 < 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    dispatch_object_t object = (dispatch_object_t)v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&object);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          [(CTXPCClientHandler *)self getQueue];
          id v21 = objc_retainBlock(v7);
          dispatch_object_t object = v23;
          *(void *)long long buf = off_101A9F520;
          unint64_t v26 = v21;
          unint64_t v27 = buf;
          sub_10007E74C();
        }
        uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, v22);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for refresh all Sweetgum info", buf, 2u);
  }
LABEL_20:
}

- (void)getSweetgumDataPlanMetrics:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_20;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if (v11 < 0)
    {
      int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    dispatch_object_t object = (dispatch_object_t)v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&object);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          [(CTXPCClientHandler *)self getQueue];
          id v21 = objc_retainBlock(v7);
          dispatch_object_t object = v23;
          *(void *)long long buf = off_101A9F5A0;
          unint64_t v26 = v21;
          unint64_t v27 = buf;
          sub_10007EF14();
        }
        uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, 0, v22);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for Sweetgum data plan metrics query", buf, 2u);
  }
LABEL_20:
}

- (void)purchaseSweetgumPlan:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    id v8 = [v6 planId];

    if (!v8)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_25;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)buf);
    uint64_t v11 = ServiceMap;
    if (v12 < 0)
    {
      uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    v46[0] = (char *)v12;
    unsigned int v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)v46);
    if (v16)
    {
      uint64_t v17 = v16[3];
      char v18 = (std::__shared_weak_count *)v16[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        long long v31 = v18;
        sub_10004D2C8(v18);
        char v32 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v17)
        {
          uint64_t v44 = 0;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v40 = 0u;
          long long v41 = 0u;
          *(_OWORD *)char v38 = 0u;
          long long v39 = 0u;
          *(_OWORD *)uint64_t v36 = 0u;
          long long v37 = 0u;
          *(_OWORD *)long long buf = 0u;
          *(_OWORD *)char v35 = 0u;
          objc_msgSend(v6, "planId", v31);
          id v21 = objc_claimAutoreleasedReturnValue();
          sub_10003ED78((std::string *)v35, (char *)[v21 UTF8String]);

          uint64_t v22 = [v6 planLabel];
          BOOL v23 = v22 == 0;

          if (!v23)
          {
            id v24 = [v6 planLabel];
            sub_10003ED78((std::string *)&v36[1], (char *)[v24 UTF8String]);
          }
          id v25 = [v6 planTermsURL];
          if (v25)
          {
            unint64_t v26 = [v6 planTermsURL];
            BOOL v27 = [v26 length] == 0;

            if (!v27)
            {
              id v28 = [v6 planTermsURL];
              v46[0] = (char *)[v28 UTF8String];
              sub_1000791C0((std::string *)v38, v46);
            }
          }
          [(CTXPCClientHandler *)self getQueue];
          unint64_t v29 = objc_retainBlock(v7);
          dispatch_object_t v45 = object;
          v46[0] = (char *)off_101A9F620;
          v46[1] = v29;
          v46[3] = (char *)v46;
          sub_10007E74C();
        }
        id v30 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, v30);

        if ((v32 & 1) == 0) {
          sub_10004D2C8(v31);
        }
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v11);
    long long v31 = 0;
    char v32 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for purchase Sweetgum plan", buf, 2u);
  }
LABEL_25:
}

- (void)copyRegistrationDisplayStatus:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          BOOL v23 = objc_retainBlock(v7);
          v29[0] = off_101AA5A40;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 32))(v17, v22, v29);
          sub_100ED7940(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting registration display status", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for registration display status query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyServingPlmn:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          BOOL v23 = objc_retainBlock(v7);
          v29[0] = off_101AA5AD0;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 200))(v17, v22, v29);
          sub_10001E914(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting serving PLMN", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for serving PLMN query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyLastKnownMobileCountryCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          BOOL v23 = objc_retainBlock(v7);
          v29[0] = off_101AA5BD0;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 248))(v17, v22, v29);
          sub_10003DF80(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting last known MCC", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for last known MCC query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyIsInHomeCountry:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          BOOL v23 = objc_retainBlock(v7);
          v29[0] = off_101AA5CE0;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 296))(v17, v22, v29);
          sub_10041A868(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find SystemDeterminationManager service while getting is in home country status", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for in home country query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)getRoamingStatus:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          BOOL v23 = objc_retainBlock(v7);
          v29[0] = off_101AA5D70;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 304))(v17, v22, v29);
          sub_10041A8EC(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find SystemDeterminationManager service while getting getRoamingStatus", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getRoamingStatus", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyIsDataAttached:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_42;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v39);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v41 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v41);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
LABEL_14:
    if (v40) {
      sub_10004D2C8(v40);
    }
    if (!v17)
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v32 = v40;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v39);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v39) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not find RoamingInterface for getting is data attached status", (uint8_t *)&v39, 2u);
      }
      id v33 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v7[2](v7, 0, v33);

      goto LABEL_40;
    }
    [(CTXPCClientHandler *)self registry];
    uint64_t v22 = (std::mutex *)Registry::getServiceMap(v21, v39);
    BOOL v23 = v22;
    if ((v24 & 0x8000000000000000) != 0)
    {
      id v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v26 = 5381;
      do
      {
        unint64_t v24 = v26;
        unsigned int v27 = *v25++;
        uint64_t v26 = (33 * v26) ^ v27;
      }
      while (v27);
    }
    std::mutex::lock(v22);
    unint64_t v41 = v24;
    unint64_t v28 = sub_10004D37C(&v23[1].__m_.__sig, &v41);
    if (v28)
    {
      uint64_t v30 = v28[3];
      unint64_t v29 = (std::__shared_weak_count *)v28[4];
      if (v29)
      {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v23);
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v29);
        char v31 = 0;
LABEL_28:
        if (v40) {
          sub_10004D2C8(v40);
        }
        if (v30)
        {
          id v34 = [v6 slotID];
          if (v34 == (id)2) {
            uint64_t v35 = 2;
          }
          else {
            uint64_t v35 = v34 == (id)1;
          }
          uint64_t v36 = objc_retainBlock(v7);
          v42[0] = off_101AA5E00;
          v42[1] = v36;
          v42[3] = v42;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v30 + 48))(v30, v35, v42);
          sub_100060644(v42);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          long long v37 = v40;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v39);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v39) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting is data attached", (uint8_t *)&v39, 2u);
          }
          id v38 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v38);
        }
        if ((v31 & 1) == 0) {
          sub_10004D2C8(v29);
        }
LABEL_40:
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_42;
      }
    }
    else
    {
      uint64_t v30 = 0;
    }
    std::mutex::unlock(v23);
    unint64_t v29 = 0;
    char v31 = 1;
    goto LABEL_28;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v40;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v39);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v39) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for in data attached query", (uint8_t *)&v39, 2u);
  }
LABEL_42:
}

- (void)copyLocalizedOperatorName:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_56;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)__p);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
LABEL_14:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (!v17)
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v32 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting localized operator name", buf, 2u);
      }
      id v33 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v7[2](v7, 0, v33);

      goto LABEL_54;
    }
    [(CTXPCClientHandler *)self registry];
    uint64_t v22 = (std::mutex *)Registry::getServiceMap(v21, *(Registry **)buf);
    BOOL v23 = v22;
    if (v24 < 0)
    {
      id v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v26 = 5381;
      do
      {
        uint64_t v24 = v26;
        unsigned int v27 = *v25++;
        uint64_t v26 = (33 * v26) ^ v27;
      }
      while (v27);
    }
    std::mutex::lock(v22);
    __p[0] = (void *)v24;
    unint64_t v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)__p);
    if (v28)
    {
      uint64_t v30 = v28[3];
      unint64_t v29 = (std::__shared_weak_count *)v28[4];
      if (v29)
      {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v23);
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v29);
        char v31 = 0;
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v30 = 0;
    }
    std::mutex::unlock(v23);
    unint64_t v29 = 0;
    char v31 = 1;
LABEL_28:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v30)
    {
      id v34 = [v6 slotID];
      if (v34 == (id)2) {
        uint64_t v35 = 2;
      }
      else {
        uint64_t v35 = v34 == (id)1;
      }
      long long v42 = 0;
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 104))(v40, v17, v35);
      if (SHIBYTE(v41) < 0)
      {
        sub_10004FC84(__p, v40[0], (unint64_t)v40[1]);
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)v40;
        uint64_t v45 = v41;
      }
      long long v43 = 0;
      if (SHIBYTE(v45) < 0)
      {
        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)__p;
        uint64_t v47 = v45;
      }
      long long v48 = 0;
      if (ctu::cf::convert_copy())
      {
        id v38 = v43;
        long long v43 = v48;
        long long v49 = v38;
        sub_1000558F4(&v49);
      }
      if (SHIBYTE(v47) < 0) {
        operator delete(*(void **)buf);
      }
      long long v39 = v43;
      long long v42 = v43;
      long long v43 = 0;
      sub_1000558F4(&v43);
      if (SHIBYTE(v45) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v41) < 0) {
        operator delete(v40[0]);
      }
      *(void *)long long buf = 0;
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void, const void *, uint64_t))(*(void *)v30 + 16))(buf, v30, kCarriersLocalizationTable, v39, 1);
      v7[2](v7, *(void *)buf, 0);
      sub_1000558F4((const void **)buf);
      sub_1000558F4(&v42);
      if (v31) {
        goto LABEL_54;
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v36 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Could not find LocalizationInterface for getting localized operator name", buf, 2u);
      }
      id v37 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v7[2](v7, 0, v37);

      if (v31) {
        goto LABEL_54;
      }
    }
    sub_10004D2C8(v29);
LABEL_54:
    if ((v18 & 1) == 0) {
      sub_10004D2C8(v16);
    }
    goto LABEL_56;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for localized operator name query", buf, 2u);
  }
LABEL_56:
}

- (void)copyRadioAccessTechnology:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          BOOL v23 = objc_retainBlock(v7);
          v29[0] = off_101AA5F00;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 80))(v17, v22, v29);
          sub_100ED79C4(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting RAT", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for RAT query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyWirelessTechnology:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          BOOL v23 = objc_retainBlock(v7);
          v29[0] = off_101AA5F90;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 80))(v17, v22, v29);
          sub_100ED79C4(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting Wireless Technology", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for wireless technology query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyAbbreviatedOperatorName:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          BOOL v23 = objc_retainBlock(v7);
          v29[0] = off_101AA6010;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 120))(v17, v22, v29);
          sub_10001E914(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting operator name", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for abbreviated operator name query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)getRatSelection:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      (*((void (**)(id, void, void, id))v7 + 2))(v7, 0, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          id v23 = objc_retainBlock(v7);
          v29[0] = off_101AA6090;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 96))(v17, v22, v29);
          sub_100ED7DE4(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting RAT selection", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, void, void, id))v7 + 2))(v7, 0, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for RAT selection query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)getRatSelectionMask:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_23;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v25);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v11;
    unsigned int v15 = sub_10004D37C(&v10[1].__m_.__sig, &v27);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          uint64_t v21 = sub_10003E318(v6);
          uint64_t v22 = objc_retainBlock(v7);
          v28[0] = off_101AA6110;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 96))(v17, v21, v28);
          sub_100ED7DE4(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting RAT selection", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for RAT selection query", (uint8_t *)&v25, 2u);
  }
LABEL_23:
}

- (void)setRatSelection:(id)a3 selection:(id)a4 preferred:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  uint64_t v13 = (void (**)(id, id))a6;
  if (v13)
  {
    if (!v10)
    {
      id v26 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v13[2](v13, v26);

      goto LABEL_30;
    }
    if (v11)
    {
      [(CTXPCClientHandler *)self registry];
      ServiceMap = (std::mutex *)Registry::getServiceMap(v14, v36);
      unsigned int v16 = ServiceMap;
      if ((v17 & 0x8000000000000000) != 0)
      {
        char v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v19 = 5381;
        do
        {
          unint64_t v17 = v19;
          unsigned int v20 = *v18++;
          uint64_t v19 = (33 * v19) ^ v20;
        }
        while (v20);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v38 = v17;
      uint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, &v38);
      if (v21)
      {
        uint64_t v23 = v21[3];
        uint64_t v22 = (std::__shared_weak_count *)v21[4];
        if (v22)
        {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v16);
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v22);
          char v24 = 0;
LABEL_18:
          if (v37) {
            sub_10004D2C8(v37);
          }
          if (!v23)
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v34 = v37;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v36);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v36) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for setting RAT selection", (uint8_t *)&v36, 2u);
            }
            id v35 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
            v13[2](v13, v35);

            goto LABEL_28;
          }
          if (CFEqual(v11, kCTRegistrationRATSelection1)) {
            goto LABEL_23;
          }
          unint64_t v29 = (const void *)kCTRegistrationRATSelection0;
          if (CFEqual(v11, kCTRegistrationRATSelection0)) {
            goto LABEL_23;
          }
          if (!CFEqual(v11, kCTRegistrationRATSelection2))
          {
            unsigned __int8 v30 = 0;
            goto LABEL_24;
          }
          if (!v12 || !CFEqual(v12, v29)) {
LABEL_23:
          }
            unsigned __int8 v30 = 2;
          else {
            unsigned __int8 v30 = 1;
          }
LABEL_24:
          uint64_t v36 = 0;
          RatSelectionType::RatSelectionType((RatSelectionType *)&v36);
          unsigned __int8 v31 = sub_100DC2F68(v11);
          RatSelectionType::setSelection((RatSelectionType *)&v36, v31);
          RatSelectionType::setPreferredSelection((RatSelectionType *)&v36, v30);
          [v10 slotID];
          RatSelectionType::setSimSlot();
          char v32 = v36;
          id v33 = objc_retainBlock(v13);
          v39[0] = off_101AA6190;
          v39[1] = v33;
          v39[3] = v39;
          (*(void (**)(uint64_t, Registry *, void *))(*(void *)v23 + 88))(v23, v32, v39);
          sub_10001C9D4(v39);
LABEL_28:
          if ((v24 & 1) == 0) {
            sub_10004D2C8(v22);
          }
          goto LABEL_30;
        }
      }
      else
      {
        uint64_t v23 = 0;
      }
      std::mutex::unlock(v16);
      uint64_t v22 = 0;
      char v24 = 1;
      goto LABEL_18;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unint64_t v27 = v37;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v36);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v36) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Invalid RAT selection string", (uint8_t *)&v36, 2u);
    }
    id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v13[2](v13, v28);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v25 = v37;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v36);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v36) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting RAT selection", (uint8_t *)&v36, 2u);
    }
  }
LABEL_30:
}

- (void)setRatSelectionMask:(id)a3 selection:(unsigned __int8)a4 preferred:(unsigned __int8)a5 completion:(id)a6
{
  int v7 = a5;
  int v8 = a4;
  id v10 = a3;
  id v11 = (void (**)(id, id))a6;
  if (!v11)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v23 = v31;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v30);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v30) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting RAT selection", (uint8_t *)&v30, 2u);
    }
    goto LABEL_23;
  }
  if (!v10)
  {
    id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v11[2](v11, v24);

    goto LABEL_23;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v12, v30);
  unsigned int v14 = ServiceMap;
  if ((v15 & 0x8000000000000000) != 0)
  {
    unsigned int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      unint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v32 = v15;
  uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, &v32);
  if (!v19)
  {
    uint64_t v21 = 0;
    goto LABEL_13;
  }
  uint64_t v21 = v19[3];
  unsigned int v20 = (std::__shared_weak_count *)v19[4];
  if (!v20)
  {
LABEL_13:
    std::mutex::unlock(v14);
    unsigned int v20 = 0;
    char v22 = 1;
    goto LABEL_14;
  }
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v14);
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  char v22 = 0;
LABEL_14:
  if (v31) {
    sub_10004D2C8((std::__shared_weak_count *)v31);
  }
  if (v21)
  {
    if ((v8 - 1) >= 2u)
    {
      if (v8 == 3)
      {
        if (v7 == 1) {
          unsigned __int8 v25 = 1;
        }
        else {
          unsigned __int8 v25 = 2;
        }
      }
      else
      {
        unsigned __int8 v25 = 0;
      }
    }
    else
    {
      unsigned __int8 v25 = 2;
    }
    unsigned __int8 v30 = 0;
    RatSelectionType::RatSelectionType((RatSelectionType *)&v30);
    sub_10003E318(v10);
    RatSelectionType::setSimSlot();
    RatSelectionType::setSelection((RatSelectionType *)&v30, v8);
    RatSelectionType::setPreferredSelection((RatSelectionType *)&v30, v25);
    id v28 = v30;
    unint64_t v29 = objc_retainBlock(v11);
    v33[0] = off_101AA6210;
    v33[1] = v29;
    void v33[3] = v33;
    (*(void (**)(uint64_t, Registry *, void *))(*(void *)v21 + 88))(v21, v28, v33);
    sub_10001C9D4(v33);
    if (v22) {
      goto LABEL_23;
    }
LABEL_22:
    sub_10004D2C8(v20);
    goto LABEL_23;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v26 = v31;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v30);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v30) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for setting RAT selection", (uint8_t *)&v30, 2u);
  }
  id v27 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
  v11[2](v11, v27);

  if ((v22 & 1) == 0) {
    goto LABEL_22;
  }
LABEL_23:
}

- (void)copyBandInfo:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          uint64_t v23 = objc_retainBlock(v7);
          v29[0] = off_101AA6290;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 128))(v17, v22, v29);
          sub_10010E020(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find BasebandSettingsInterface for setting RAT selection", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for copying band info", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)setBandInfo:(id)a3 bands:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, id))a5;
  if (v10)
  {
    if (!v8)
    {
      id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, v23);

      goto LABEL_28;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)buf);
    uint64_t v13 = ServiceMap;
    if ((v14 & 0x8000000000000000) != 0)
    {
      unint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        unint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v32 = v14;
    char v18 = sub_10004D37C(&v13[1].__m_.__sig, &v32);
    if (v18)
    {
      uint64_t v20 = v18[3];
      uint64_t v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
LABEL_14:
        if (v31) {
          sub_10004D2C8(v31);
        }
        if (v20)
        {
          id v24 = [v8 slotID];
          if (v24 == (id)2) {
            uint64_t v25 = 2;
          }
          else {
            uint64_t v25 = v24 == (id)1;
          }
          unint64_t v29 = v9;
          if (v9) {
            CFRetain(v9);
          }
          id v26 = objc_retainBlock(v10);
          v33[0] = off_101AA6310;
          v33[1] = v26;
          void v33[3] = v33;
          (*(void (**)(uint64_t, uint64_t, const void **, void *))(*(void *)v20 + 144))(v20, v25, &v29, v33);
          sub_10001C9D4(v33);
          sub_100057D78(&v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v27 = v31;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Could not find BasebandSettingsInterface for setting RAT selection", buf, 2u);
          }
          id v28 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v10[2](v10, v28);
        }
        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    uint64_t v19 = 0;
    char v21 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v22 = v31;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting supported band info", buf, 2u);
  }
LABEL_28:
}

- (void)getBandInfo:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          id v23 = objc_retainBlock(v7);
          v29[0] = off_101AA6390;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 136))(v17, v22, v29);
          sub_10010E020(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find BasebandSettingsInterface for getting the band info", (uint8_t *)&v26, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting the band info", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)setActiveBandInfo:(id)a3 bands:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, id))a5;
  if (v10)
  {
    if (!v8)
    {
      id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, v23);

      goto LABEL_32;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)buf);
    uint64_t v13 = ServiceMap;
    if ((v14 & 0x8000000000000000) != 0)
    {
      unint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        unint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v35 = v14;
    char v18 = sub_10004D37C(&v13[1].__m_.__sig, &v35);
    if (v18)
    {
      uint64_t v20 = v18[3];
      uint64_t v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
LABEL_14:
        if (v34) {
          sub_10004D2C8(v34);
        }
        if (v20)
        {
          id v24 = [v9 activeBands];
          +[NSDictionary dictionaryWithObjectsAndKeys:](NSDictionary, "dictionaryWithObjectsAndKeys:", v24, kCTRegistrationBandActive, 0);
          id v25 = (id)objc_claimAutoreleasedReturnValue();

          if ([v25 count])
          {
            id v26 = [v8 slotID];
            if (v26 == (id)2) {
              uint64_t v27 = 2;
            }
            else {
              uint64_t v27 = v26 == (id)1;
            }
            unint64_t v32 = v25;
            if (v25) {
              CFRetain(v25);
            }
            unint64_t v28 = objc_retainBlock(v10);
            v36[0] = off_101AA6410;
            v36[1] = v28;
            v36[3] = v36;
            (*(void (**)(uint64_t, uint64_t, const void **, void *))(*(void *)v20 + 152))(v20, v27, &v32, v36);
            sub_10001C9D4(v36);
            sub_100057D78(&v32);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            unsigned __int8 v30 = v34;
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "The band dictionary is empty when trying to set the active bands", buf, 2u);
            }
            id v31 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
            v10[2](v10, v31);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v29 = v34;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not find BasebandSettingsInterface for setting active band info", buf, 2u);
          }
          id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v10[2](v10, v25);
        }

        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    uint64_t v19 = 0;
    char v21 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v22 = v34;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting active band info", buf, 2u);
  }
LABEL_32:
}

- (void)getSignalStrengthInfo:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_27;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if (v11 < 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    dispatch_object_t object = (dispatch_object_t)v11;
    unint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&object);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v29) {
          sub_10004D2C8(v29);
        }
        if (v17)
        {
          if ((char *)[v6 slotID] - 3 > (char *)0xFFFFFFFFFFFFFFFDLL)
          {
            [(CTXPCClientHandler *)self getQueue];
            id v25 = objc_retainBlock(v7);
            dispatch_object_t object = v26;
            *(void *)long long buf = off_101AA6490;
            unint64_t v29 = v25;
            unsigned __int8 v30 = buf;
            sub_1002BB4E4();
          }
          [(CTXPCClientHandler *)self getLogContext];
          char v21 = v29;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid SIM slot", buf, 2u);
          }
          uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
          v7[2](v7, 0, v22);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v29;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SignalStrengthInterface for getting signal strength", buf, 2u);
          }
          id v24 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting signal strength", buf, 2u);
  }
LABEL_27:
}

- (void)getVoiceLinkQualityMetric:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          object[0] = (dispatch_object_t)objc_retainBlock(v7);
          [(CTXPCClientHandler *)self getQueue];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          unint64_t v29 = off_101AA6510;
          long long v30 = *(_OWORD *)object;
          id v31 = &v29;
          (*(void (**)(uint64_t, uint64_t, uint64_t (***)()))(*(void *)v17 + 40))(v17, v22, &v29);
          sub_10022BA88(&v29);
          id v23 = 0;
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find SignalStrengthInterface for getting voice link quality metric", buf, 2u);
          }
          id v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v23);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting voice link quality metric", buf, 2u);
  }
LABEL_26:
}

- (void)getEnhancedVoiceLinkQualityMetric:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          object[0] = (dispatch_object_t)objc_retainBlock(v7);
          [(CTXPCClientHandler *)self getQueue];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          unint64_t v29 = off_101AA6590;
          long long v30 = *(_OWORD *)object;
          id v31 = &v29;
          (*(void (**)(uint64_t, uint64_t, uint64_t (***)()))(*(void *)v17 + 48))(v17, v22, &v29);
          sub_10022BD94(&v29);
          id v23 = 0;
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find SignalStrengthInterface for getting enhanced voice link quality metric", buf, 2u);
          }
          id v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v23);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting enhanced voice link quality metric", buf, 2u);
  }
LABEL_26:
}

- (void)copyRejectCauseCode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    unint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          object[0] = (dispatch_object_t)objc_retainBlock(v7);
          [(CTXPCClientHandler *)self getQueue];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          unint64_t v29 = off_101AA6610;
          long long v30 = *(_OWORD *)object;
          id v31 = &v29;
          (*(void (**)(uint64_t, uint64_t, uint64_t (***)()))(*(void *)v17 + 40))(v17, v22, &v29);
          sub_1000F8E94(&v29);
          id v23 = 0;
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting reject cause code", buf, 2u);
          }
          id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v23);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting reject cause code", buf, 2u);
  }
LABEL_26:
}

- (void)getIMSRegistrationStatus:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v25 = v11;
    unint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v25);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v28) {
          sub_10004D2C8(v28);
        }
        if (v17)
        {
          [v6 slotID];
          [(CTXPCClientHandler *)self registry];
          PersonalityIdFromSlotId();
          id v21 = self;
          uint64_t v22 = objc_retainBlock(v7);
          v30[0] = off_101AA6690;
          v30[1] = v21;
          int v30[2] = v22;
          v30[3] = v30;
          (*(void (**)(uint64_t, uint8_t *, void *))(*(void *)v17 + 256))(v17, buf, v30);
          sub_10128F158(v30);
          if (v29 < 0) {
            operator delete(*(void **)buf);
          }
          if (v26) {
            sub_10004D2C8(v26);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v28;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SystemDeterminationManagerInterface for getting agent status", buf, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for registration status query", buf, 2u);
  }
LABEL_26:
}

- (void)copyRegistrationIMSTransportInfo:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v25 = v11;
    unint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v25);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v28) {
          sub_10004D2C8(v28);
        }
        if (v17)
        {
          [v6 slotID];
          [(CTXPCClientHandler *)self registry];
          PersonalityIdFromSlotId();
          id v21 = self;
          uint64_t v22 = objc_retainBlock(v7);
          v30[0] = off_101AA6720;
          v30[1] = v21;
          int v30[2] = v22;
          v30[3] = v30;
          (*(void (**)(uint64_t, uint8_t *, void *))(*(void *)v17 + 264))(v17, buf, v30);
          sub_10128F564(v30);
          if (v29 < 0) {
            operator delete(*(void **)buf);
          }
          if (v26) {
            sub_10004D2C8(v26);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v23 = v28;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SystemDeterminationManagerInterface for getting agent status", buf, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for registration status query", buf, 2u);
  }
LABEL_26:
}

- (void)setMaxDataRate:(id)a3 rate:(int64_t)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = (void (**)(id, void *))a5;
  if (v9)
  {
    if (!v8)
    {
      uint64_t v22 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v9[2](v9, v22);

      goto LABEL_29;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v28);
    id v12 = ServiceMap;
    if ((v13 & 0x8000000000000000) != 0)
    {
      unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        unint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v30 = v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v30);
    if (v17)
    {
      uint64_t v19 = v17[3];
      char v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
LABEL_14:
        if (v29) {
          sub_10004D2C8(v29);
        }
        if (v19)
        {
          id v23 = [v8 slotID];
          if (v23 == (id)2) {
            uint64_t v24 = 2;
          }
          else {
            uint64_t v24 = v23 == (id)1;
          }
          if ((unint64_t)(a4 - 1) < 8) {
            a4 = a4;
          }
          else {
            a4 = 0;
          }
          unint64_t v25 = objc_retainBlock(v9);
          v31[0] = off_101AA67B0;
          v31[1] = v25;
          v31[3] = v31;
          (*(void (**)(uint64_t, uint64_t, int64_t, void *))(*(void *)v19 + 24))(v19, v24, a4, v31);
          sub_100449214(v31);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v26 = v29;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v28) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find MaxDataRateInterface for setting max data rate", (uint8_t *)&v28, 2u);
          }
          uint64_t v27 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v9[2](v9, v27);
        }
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    char v18 = 0;
    char v20 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v21 = v29;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v28) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting max data rate", (uint8_t *)&v28, 2u);
  }
LABEL_29:
}

- (void)getMaxDataRate:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          id v23 = objc_retainBlock(v7);
          v29[0] = off_101AA6830;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 32))(v17, v22, v29);
          sub_1004C6D38(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find MaxDataRateInterface for getting max data rate", (uint8_t *)&v26, 2u);
          }
          unint64_t v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting max data rate", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)getSupportedDataRates:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    id v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      id v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          id v23 = objc_retainBlock(v7);
          v29[0] = off_101AA68B0;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 16))(v17, v22, v29);
          sub_1002BCD40(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find MaxDataRateInterface for getting supported data rates", (uint8_t *)&v26, 2u);
          }
          unint64_t v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting supported data rates", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)get2GSwitchEnabled:(id)a3
{
  id v4 = (void (**)(id, uint64_t, void))a3;
  if (!v4)
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v16 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting 2G switch support", (uint8_t *)&v20, 2u);
    }
    goto LABEL_17;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v20);
  int v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v8;
  id v12 = sub_10004D37C(&v7[1].__m_.__sig, &v22);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_12:
  if (v21) {
    sub_10004D2C8((std::__shared_weak_count *)v21);
  }
  if (v14)
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 48))(v14);
    v4[2](v4, v17, 0);
    if ((v15 & 1) == 0) {
LABEL_16:
    }
      sub_10004D2C8(v13);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v18 = v21;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v20) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find MaxDataRateInterface for getting 2G switch support", (uint8_t *)&v20, 2u);
    }
    uint64_t v19 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    ((void (**)(id, uint64_t, void *))v4)[2](v4, 0, v19);

    if ((v15 & 1) == 0) {
      goto LABEL_16;
    }
  }
LABEL_17:
}

- (void)get2GUserPreference:(id)a3
{
  id v4 = a3;
  if (v4)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v20);
    int v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v22 = v8;
    id v12 = sub_10004D37C(&v7[1].__m_.__sig, &v22);
    if (v12)
    {
      uint64_t v14 = v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_12:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v14)
        {
          id v17 = objc_retainBlock(v4);
          v23[0] = off_101AA6930;
          v23[1] = v17;
          v23[3] = v23;
          (*(void (**)(uint64_t, void *))(*(void *)v14 + 80))(v14, v23);
          sub_1004CACEC(v23);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          char v18 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v20) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find MaxDataRateInterface for getting 2G user preference", (uint8_t *)&v20, 2u);
          }
          uint64_t v19 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, uint64_t, void *))v4 + 2))(v4, 1, v19);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  unsigned int v16 = v21;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v20) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting 2G user preference", (uint8_t *)&v20, 2u);
  }
LABEL_21:
}

- (void)set2GUserPreference:(BOOL)a3 completion:(id)a4
{
  BOOL v4 = a3;
  id v6 = a4;
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, v21);
  id v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v23 = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v23);
  if (v14)
  {
    uint64_t v16 = v14[3];
    char v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  char v15 = 0;
  char v17 = 1;
LABEL_9:
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (v16)
  {
    id v18 = objc_retainBlock(v6);
    v24[0] = off_101AA69B0;
    v24[1] = v18;
    unint64_t v24[3] = v24;
    (*(void (**)(uint64_t, BOOL, void *))(*(void *)v16 + 88))(v16, v4, v24);
    sub_100449214(v24);
    goto LABEL_16;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v22;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    if (!v6) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  LOWORD(v21) = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find MaxDataRateInterface for getting 2G switch support", (uint8_t *)&v21, 2u);
  if (v6)
  {
LABEL_15:
    char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*((void (**)(id, void *))v6 + 2))(v6, v20);
  }
LABEL_16:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

- (void)fetchNetworkList:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          unint64_t v23 = objc_retainBlock(v7);
          v29[0] = off_101AA6A30;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 128))(v17, v22, v29);
          sub_10001C9D4(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find Registration for fetching network list", (uint8_t *)&v26, 2u);
          }
          unint64_t v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for fetching network list", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyNetworkList:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v32 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v32);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v31) {
          sub_10004D2C8(v31);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          LODWORD(v27) = v22;
          [(CTXPCClientHandler *)self registry];
          unint64_t v23 = objc_retainBlock(v7);
          id v34 = 0;
          uint64_t v24 = operator new(0x28uLL);
          *(void *)uint64_t v24 = off_101AA6AB0;
          void v24[2] = v28;
          *((_OWORD *)v24 + 1) = v29;
          *((void *)v24 + 4) = v23;
          id v34 = v24;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 144))(v17, v22, v33);
          sub_100ED7B50(v33);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          unint64_t v25 = v31;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find Registration for copying network list", buf, 2u);
          }
          id v26 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v26);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v31;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for copying network list", buf, 2u);
  }
LABEL_26:
}

- (void)automaticallySelectNetwork:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      char v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          unint64_t v23 = objc_retainBlock(v7);
          v29[0] = off_101AA6B40;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 160))(v17, v22, v29);
          sub_10001C9D4(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find Registration for automatically selecting network", (uint8_t *)&v26, 2u);
          }
          unint64_t v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for automatically selecting network", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)selectNetwork:(id)a3 network:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  unint64_t v10 = (void (**)(id, void *))a5;
  if (v10)
  {
    if (!v8)
    {
      unint64_t v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v10[2](v10, v23);

      goto LABEL_32;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)buf);
    uint64_t v13 = ServiceMap;
    if ((v14 & 0x8000000000000000) != 0)
    {
      char v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        unint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v32 = v14;
    char v18 = sub_10004D37C(&v13[1].__m_.__sig, &v32);
    if (v18)
    {
      uint64_t v20 = v18[3];
      uint64_t v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v13);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
LABEL_14:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if (v20)
        {
          id v24 = [v8 slotID];
          if (v24 == (id)2) {
            uint64_t v25 = 2;
          }
          else {
            uint64_t v25 = v24 == (id)1;
          }
          memset(buf, 0, sizeof(buf));
          uint64_t v35 = 0;
          id v26 = [v9 plmn];
          sub_100058DB0(buf, (char *)[v26 UTF8String]);

          if (SHIBYTE(v35) < 0)
          {
            sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)buf;
            uint64_t v31 = v35;
          }
          long long v29 = objc_retainBlock(v10);
          v33[0] = off_101AA6BC0;
          v33[1] = v29;
          void v33[3] = v33;
          (*(void (**)(uint64_t, uint64_t, void **, void *))(*(void *)v20 + 152))(v20, v25, __p, v33);
          sub_10001C9D4(v33);
          if (SHIBYTE(v31) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v35) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v27 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v9;
            _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Could not find Registration for selecting %@ network", buf, 0xCu);
          }
          unint64_t v28 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v10[2](v10, v28);
        }
        if ((v21 & 1) == 0) {
          sub_10004D2C8(v19);
        }
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v13);
    uint64_t v19 = 0;
    char v21 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v22 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler for selecting %@ network", buf, 0xCu);
  }
LABEL_32:
}

- (void)copyNetworkSelection:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v32 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v32);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v31) {
          sub_10004D2C8(v31);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          LODWORD(v27) = v22;
          [(CTXPCClientHandler *)self registry];
          unint64_t v23 = objc_retainBlock(v7);
          id v34 = 0;
          id v24 = operator new(0x28uLL);
          *(void *)id v24 = off_101AA6C40;
          void v24[2] = v28;
          *((_OWORD *)v24 + 1) = v29;
          *((void *)v24 + 4) = v23;
          id v34 = v24;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 136))(v17, v22, v33);
          sub_100ED7ACC(v33);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v25 = v31;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for selected network query", buf, 2u);
          }
          id v26 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v26);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v31;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for selected network query", buf, 2u);
  }
LABEL_26:
}

- (void)isNetworkSelectionMenuAvailable:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (!v7)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v19 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for is network selection menu available query", (uint8_t *)&v26, 2u);
    }
    goto LABEL_22;
  }
  if (!v6)
  {
    uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    v7[2](v7, 0, v20);

    goto LABEL_22;
  }
  [(CTXPCClientHandler *)self registry];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
  unint64_t v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v28 = v11;
  char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
  if (v15)
  {
    uint64_t v17 = v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v16 = 0;
  char v18 = 1;
LABEL_14:
  if (v27) {
    sub_10004D2C8((std::__shared_weak_count *)v27);
  }
  if (v17)
  {
    id v21 = [v6 slotID];
    if (v21 == (id)2) {
      uint64_t v22 = 2;
    }
    else {
      uint64_t v22 = v21 == (id)1;
    }
    uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 312))(v17, v22);
    v7[2](v7, v23, 0);
    if ((v18 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v16);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v24 = v27;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v26) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find Registration for is network selection menu available query", (uint8_t *)&v26, 2u);
    }
    uint64_t v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    v7[2](v7, 0, v25);

    if ((v18 & 1) == 0) {
      goto LABEL_21;
    }
  }
LABEL_22:
}

- (void)copyNetworkSelectionMode:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          uint64_t v23 = objc_retainBlock(v7);
          v29[0] = off_101AA6CD0;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 168))(v17, v22, v29);
          sub_100ED7BD4(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find Registration for network selection mode query", (uint8_t *)&v26, 2u);
          }
          uint64_t v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for network selection mode query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)copyNetworkSelectionInfo:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v32 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v32);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v31) {
          sub_10004D2C8(v31);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          LODWORD(v27) = v22;
          [(CTXPCClientHandler *)self registry];
          uint64_t v23 = objc_retainBlock(v7);
          id v34 = 0;
          id v24 = operator new(0x28uLL);
          *(void *)id v24 = off_101AA6D60;
          void v24[2] = v28;
          *((_OWORD *)v24 + 1) = v29;
          *((void *)v24 + 4) = v23;
          id v34 = v24;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 184))(v17, v22, v33);
          sub_100ED7CDC(v33);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v25 = v31;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not find Registration for network selection info query", buf, 2u);
          }
          id v26 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v26);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v31;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for network selection info query", buf, 2u);
  }
LABEL_26:
}

- (void)isNetworkReselectionNeeded:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_26;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v28 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v28);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          id v21 = [v6 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          uint64_t v23 = objc_retainBlock(v7);
          v29[0] = off_101AA6DF0;
          v29[1] = v23;
          void v29[3] = v29;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 192))(v17, v22, v29);
          sub_100060644(v29);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find Registration for network needs reselection query", (uint8_t *)&v26, 2u);
          }
          uint64_t v25 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v25);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for network needs reselection query", (uint8_t *)&v26, 2u);
  }
LABEL_26:
}

- (void)getEncryptionStatus:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_23;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v25);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v27);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          uint64_t v21 = sub_10003E318(v6);
          uint64_t v22 = objc_retainBlock(v7);
          v28[0] = off_101AA6E70;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 472))(v17, v21, v28);
          sub_100ED7D60(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find Registration for encryption status query", (uint8_t *)&v25, 2u);
          }
          id v24 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for encryption status query", (uint8_t *)&v25, 2u);
  }
LABEL_23:
}

- (void)getPublicSignalStrength:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_22;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
    unint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    dispatch_object_t object = (dispatch_object_t)v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&object);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          [(CTXPCClientHandler *)self getQueue];
          uint64_t v21 = objc_retainBlock(v7);
          dispatch_object_t object = v24;
          *(void *)long long buf = off_101AA6F00;
          unint64_t v27 = v21;
          unint64_t v28 = buf;
          sub_1002BB4E4();
        }
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v22 = v27;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find SignalStrengthInterface for getting public signal strength", buf, 2u);
        }
        uint64_t v23 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        v7[2](v7, 0, v23);

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting public signal strength", buf, 2u);
  }
LABEL_22:
}

- (void)getSignalStrengthMeasurementsAsync:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, void *))a4;
  if (v7)
  {
    if (!v6)
    {
      uint64_t v20 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_23;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v25);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v27);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          uint64_t v21 = sub_10003E318(v6);
          uint64_t v22 = objc_retainBlock(v7);
          v28[0] = off_101AA6F80;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 64))(v17, v21, v28);
          sub_100AC2334(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find SignalStrengthInterface for getting signal strength measurements", (uint8_t *)&v25, 2u);
          }
          id v24 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting signal strength measurements", (uint8_t *)&v25, 2u);
  }
LABEL_23:
}

- (void)getNRStatus:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void *, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      uint64_t v21 = +[CTNRStatus default];
      v7[2](v7, v21, v20);

      goto LABEL_23;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v26);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v29 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v29);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v27) {
          sub_10004D2C8(v27);
        }
        if (v17)
        {
          uint64_t v22 = sub_10003E318(v6);
          id v26 = 0;
          unint64_t v27 = 0;
          int v28 = 0;
          (*(void (**)(Registry **__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 480))(&v26, v17, v22);
          sub_10132B15C((unsigned __int8 *)&v26);
          id v23 = (id)objc_claimAutoreleasedReturnValue();
          v7[2](v7, v23, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v27;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v26) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting NR status", (uint8_t *)&v26, 2u);
          }
          id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          uint64_t v25 = +[CTNRStatus default];
          v7[2](v7, v25, v23);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v27;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v26);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v26) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting NR status query", (uint8_t *)&v26, 2u);
  }
LABEL_23:
}

- (void)getSupports5GStandalone:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_27;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v25);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, &v27);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          uint64_t v21 = sub_10003E318(v6);
          LOBYTE(v25) = 0;
          uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, Registry **))(*(void *)v17 + 488))(v17, v21, &v25);
          if (v22 == 2)
          {
            id v23 = [objc_alloc((Class)NSError) initWithDomain:NSMachErrorDomain code:v22 >> 32 userInfo:0];
            v7[2](v7, 0, v23);
          }
          else if (v22 == 1)
          {
            id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:v22 >> 32 userInfo:0];
            v7[2](v7, 0, v23);
          }
          else
          {
            id v23 = +[NSNumber numberWithBool:v25];
            ((void (**)(id, id, id))v7)[2](v7, v23, 0);
          }
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v24 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting 5G Standalone support", (uint8_t *)&v25, 2u);
          }
          id v23 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v23);
        }

        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for getting 5G Standalone support query", (uint8_t *)&v25, 2u);
  }
LABEL_27:
}

- (void)setSupports5GStandalone:(id)a3 enabled:(BOOL)a4 completion:(id)a5
{
  BOOL v6 = a4;
  id v8 = a3;
  id v9 = (void (**)(id, id))a5;
  if (v9)
  {
    if (!v8)
    {
      id v22 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v9[2](v9, v22);

      goto LABEL_28;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, v27);
    uint64_t v12 = ServiceMap;
    if ((v13 & 0x8000000000000000) != 0)
    {
      unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        unint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v29 = v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, &v29);
    if (v17)
    {
      uint64_t v19 = v17[3];
      char v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    char v18 = 0;
    char v20 = 1;
LABEL_14:
    if (v28) {
      sub_10004D2C8(v28);
    }
    if (v19)
    {
      uint64_t v23 = sub_10003E318(v8);
      uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(void *)v19 + 496))(v19, v23, v6);
      if (v24 == 2)
      {
        id v25 = [objc_alloc((Class)NSError) initWithDomain:NSMachErrorDomain code:v24 >> 32 userInfo:0];
        v9[2](v9, v25);
      }
      else
      {
        if (v24 != 1)
        {
          v9[2](v9, 0);
LABEL_26:
          if ((v20 & 1) == 0) {
            sub_10004D2C8(v18);
          }
          goto LABEL_28;
        }
        id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:v24 >> 32 userInfo:0];
        v9[2](v9, v25);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v26 = v28;
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v27) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for setting 5G Standalone support", (uint8_t *)&v27, 2u);
      }
      id v25 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
      v9[2](v9, v25);
    }

    goto LABEL_26;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v21 = v28;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v27) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion handler for setting 5G Standalone support", (uint8_t *)&v27, 2u);
  }
LABEL_28:
}

- (void)getCurrentRat:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void, id))a4;
  if (v7)
  {
    if (!v6)
    {
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      v7[2](v7, 0, v20);

      goto LABEL_23;
    }
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v25);
    unint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v27 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v27);
    if (v15)
    {
      uint64_t v17 = v15[3];
      unsigned int v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_14:
        if (v26) {
          sub_10004D2C8(v26);
        }
        if (v17)
        {
          uint64_t v21 = sub_10003E318(v6);
          id v22 = objc_retainBlock(v7);
          v28[0] = off_101AA7010;
          v28[1] = v22;
          v28[3] = v28;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 64))(v17, v21, v28);
          sub_100ED7A48(v28);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v23 = v26;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v25) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find RegistrationInterface for getting data mode", (uint8_t *)&v25, 2u);
          }
          id v24 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          v7[2](v7, 0, v24);
        }
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    unsigned int v16 = 0;
    char v18 = 1;
    goto LABEL_14;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v19 = v26;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v25) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion handler for public data mode query", (uint8_t *)&v25, 2u);
  }
LABEL_23:
}

- (void)triggerKeepAliveWakeupEvent:(int)a3 completion:(id)a4
{
  uint64_t v4 = *(void *)&a3;
  id v6 = a4;
  if (v6)
  {
    [(CTXPCClientHandler *)self registry];
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, v22);
    id v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v24 = v10;
    unsigned int v14 = sub_10004D37C(&v9[1].__m_.__sig, &v24);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        if (v23) {
          sub_10004D2C8(v23);
        }
        if (v16)
        {
          id v19 = objc_retainBlock(v6);
          v25[0] = off_101AA70A0;
          v25[1] = v19;
          v25[3] = v25;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v16 + 312))(v16, v4, v25);
          sub_10001C9D4(v25);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v20 = v23;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v22) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Could not find SystemDeterminationManager service while handleing keepalive wakeup ping", (uint8_t *)&v22, 2u);
          }
          id v21 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
          (*((void (**)(id, id))v6 + 2))(v6, v21);
        }
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v18 = v23;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v22) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion handler for public data mode query", (uint8_t *)&v22, 2u);
  }
LABEL_21:
}

- (void)disableLazuli:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        [v6 slotID];
        uint64_t v9 = CTSubscriptionSlotAsString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] disableLazuli: %s", buf, 0xCu);
      }
      *(_OWORD *)long long buf = 0uLL;
      sub_1013FFB6C(buf, self);
      uint64_t v10 = *(void *)buf;
      if (*(void *)buf)
      {
        id v11 = [v6 slotID];
        if (v11 == (id)2) {
          uint64_t v12 = 2;
        }
        else {
          uint64_t v12 = v11 == (id)1;
        }
        if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 32))(v10, v12))
        {
          v7[2](v7, 0);
          goto LABEL_22;
        }
        [(CTXPCClientHandler *)self getLogContext];
        char v17 = v21;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to set Lazuli switch to false", (uint8_t *)&v19, 2u);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v16 = v21;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while disabling lazuli", (uint8_t *)&v19, 2u);
        }
      }
      int v19 = 5;
      char v20 = 1;
      char v18 = sub_1005628AC(&v19);
      ((void (**)(id, void *))v7)[2](v7, v18);

LABEL_22:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      goto LABEL_24;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v14 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    uint64_t v15 = sub_1005628AC((int *)buf);
    ((void (**)(id, void *))v7)[2](v7, v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v13 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid completion handler for disable lazuli", buf, 2u);
    }
  }
LABEL_24:
}

- (void)disableBusinessMessaging:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        [v6 slotID];
        uint64_t v9 = CTSubscriptionSlotAsString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] disableBusinessMessaging: %s", buf, 0xCu);
      }
      *(_OWORD *)long long buf = 0uLL;
      sub_1013FFB6C(buf, self);
      uint64_t v10 = *(void *)buf;
      if (*(void *)buf)
      {
        id v11 = [v6 slotID];
        if (v11 == (id)2) {
          uint64_t v12 = 2;
        }
        else {
          uint64_t v12 = v11 == (id)1;
        }
        if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v12))
        {
          v7[2](v7, 0);
          goto LABEL_22;
        }
        [(CTXPCClientHandler *)self getLogContext];
        char v17 = v21;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to set business messaging switch to false", (uint8_t *)&v19, 2u);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v16 = v21;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while disabling business messaging", (uint8_t *)&v19, 2u);
        }
      }
      int v19 = 5;
      char v20 = 1;
      char v18 = sub_1005628AC(&v19);
      ((void (**)(id, void *))v7)[2](v7, v18);

LABEL_22:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      goto LABEL_24;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v14 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    uint64_t v15 = sub_1005628AC((int *)buf);
    ((void (**)(id, void *))v7)[2](v7, v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v13 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid completion handler for disable business messaging", buf, 2u);
    }
  }
LABEL_24:
}

- (void)enableLazuli:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        [v6 slotID];
        uint64_t v9 = CTSubscriptionSlotAsString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] enableLazuli: %s", buf, 0xCu);
      }
      *(_OWORD *)long long buf = 0uLL;
      sub_1013FFB6C(buf, self);
      uint64_t v10 = *(void *)buf;
      if (*(void *)buf)
      {
        id v11 = [v6 slotID];
        if (v11 == (id)2) {
          uint64_t v12 = 2;
        }
        else {
          uint64_t v12 = v11 == (id)1;
        }
        if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 24))(v10, v12))
        {
          v7[2](v7, 0);
          goto LABEL_22;
        }
        [(CTXPCClientHandler *)self getLogContext];
        char v17 = v21;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to set Lazuli switch to true", (uint8_t *)&v19, 2u);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v16 = v21;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", (uint8_t *)&v19, 2u);
        }
      }
      int v19 = 5;
      char v20 = 1;
      char v18 = sub_1005628AC(&v19);
      ((void (**)(id, void *))v7)[2](v7, v18);

LABEL_22:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      goto LABEL_24;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v14 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    uint64_t v15 = sub_1005628AC((int *)buf);
    ((void (**)(id, void *))v7)[2](v7, v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v13 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid completion handler for enabling lazuli", buf, 2u);
    }
  }
LABEL_24:
}

- (void)enableBusinessMessaging:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        [v6 slotID];
        uint64_t v9 = CTSubscriptionSlotAsString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] enableBusinessMessaging: %s", buf, 0xCu);
      }
      *(_OWORD *)long long buf = 0uLL;
      sub_1013FFB6C(buf, self);
      uint64_t v10 = *(void *)buf;
      if (*(void *)buf)
      {
        id v11 = [v6 slotID];
        if (v11 == (id)2) {
          uint64_t v12 = 2;
        }
        else {
          uint64_t v12 = v11 == (id)1;
        }
        if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 40))(v10, v12))
        {
          v7[2](v7, 0);
          goto LABEL_22;
        }
        [(CTXPCClientHandler *)self getLogContext];
        char v17 = v21;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to set business messaging switch to true", (uint8_t *)&v19, 2u);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v16 = v21;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v19) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling business messaging", (uint8_t *)&v19, 2u);
        }
      }
      int v19 = 5;
      char v20 = 1;
      char v18 = sub_1005628AC(&v19);
      ((void (**)(id, void *))v7)[2](v7, v18);

LABEL_22:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      goto LABEL_24;
    }
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v14 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    uint64_t v15 = sub_1005628AC((int *)buf);
    ((void (**)(id, void *))v7)[2](v7, v15);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v13 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid completion handler for enabling business messaging", buf, 2u);
    }
  }
LABEL_24:
}

- (void)fetchChatBotRenderInformation:(id)a3 forDestination:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, void *))a5;
  if (v10)
  {
    if (v9
      && ([v9 uri], id v11 = objc_claimAutoreleasedReturnValue(), v11, v8)
      && v11)
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v12 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        [v8 slotID];
        uint64_t v13 = CTSubscriptionSlotAsString();
        unsigned int v14 = [v9 uri];
        *(_DWORD *)long long buf = 136315395;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&buf[12] = 2113;
        *(void *)&buf[14] = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] fetchChatBotRenderInformation: [slot: %s, destination: %{private}@]", buf, 0x16u);
      }
      id v15 = [v8 slotID];
      if (v15 == (id)2) {
        uint64_t v16 = 2;
      }
      else {
        uint64_t v16 = v15 == (id)1;
      }
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      sub_1013FFAB8(&v30, self);
      if (v30)
      {
        v28[0] = 0;
        v28[1] = 0;
        uint64_t v29 = 0;
        sub_100561B00((uint64_t)v28);
        uint64_t v17 = v30;
        sub_1014010FC((uint64_t)buf, v9);
        if (SHIBYTE(v29) < 0)
        {
          sub_10004FC84(__p, v28[0], (unint64_t)v28[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)v28;
          uint64_t v26 = v29;
        }
        uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **))(*(void *)v17 + 96))(v17, v16, buf, __p);
        uint64_t v27 = v23;
        if (SHIBYTE(v26) < 0) {
          operator delete(__p[0]);
        }
        if (v38 < 0) {
          operator delete(v37);
        }
        if (v36[24])
        {
          __p[0] = v36;
          sub_100047F64((void ***)__p);
        }
        if (v35 < 0) {
          operator delete(v34);
        }
        if (v33 < 0) {
          operator delete(*(void **)buf);
        }
        if ((v23 & 0xFF00000000) != 0)
        {
          unint64_t v24 = sub_1005628AC((int *)&v27);
          v10[2](v10, v24);
        }
        else
        {
          v10[2](v10, 0);
        }
        if (SHIBYTE(v29) < 0) {
          operator delete(v28[0]);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v21 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        id v22 = sub_1005628AC((int *)buf);
        v10[2](v10, v22);
      }
      if (v31) {
        sub_10004D2C8(v31);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v18 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      int v19 = sub_1005628AC((int *)buf);
      v10[2](v10, v19);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v20 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "Invalid completion block while fetching chatbot render information", buf, 2u);
    }
  }
}

- (void)readCachedChatBotRenderInformation:(id)a3 forChatBot:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, id, void))a5;
  if (v10)
  {
    if (v8
      && v9
      && ([v9 uri], id v11 = objc_claimAutoreleasedReturnValue(), v11, v11))
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v12 = *(NSObject **)&v35[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        [v8 slotID];
        uint64_t v13 = CTSubscriptionSlotAsString();
        unsigned int v14 = [v9 uri];
        *(_DWORD *)long long buf = 136315395;
        *(void *)char v35 = v13;
        *(_WORD *)&v35[8] = 2113;
        *(void *)&v35[10] = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] readCachedChatBotRenderInformation [slot: %s, destination: %{private}@]", buf, 0x16u);
      }
      id v15 = [v8 slotID];
      if (v15 == (id)2) {
        uint64_t v16 = 2;
      }
      else {
        uint64_t v16 = v15 == (id)1;
      }
      uint64_t v31 = 0;
      unint64_t v32 = 0;
      sub_1013FFAB8(&v31, self);
      uint64_t v17 = v31;
      if (v31)
      {
        bzero(buf, 0x2C0uLL);
        sub_1014010FC((uint64_t)v24, v9);
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, void **))(*(void *)v17 + 104))(buf, v17, v16, v24);
        if (v30 < 0) {
          operator delete(__p);
        }
        if (v28[24])
        {
          char v33 = (void **)v28;
          sub_100047F64(&v33);
        }
        if (v27 < 0) {
          operator delete(v26);
        }
        if (v25 < 0) {
          operator delete(v24[0]);
        }
        id v18 = [objc_alloc((Class)CTLazuliChatBotRenderInformationData) initWithReflection:buf];
        v10[2](v10, v18, 0);

        sub_1001FA0E0((uint64_t)buf);
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v22 = *(NSObject **)&v35[4];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        v35[0] = 1;
        uint64_t v23 = sub_1005628AC((int *)buf);
        ((void (**)(id, id, void *))v10)[2](v10, 0, v23);
      }
      if (v32) {
        sub_10004D2C8(v32);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      int v19 = *(NSObject **)&v35[4];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      v35[0] = 1;
      char v20 = sub_1005628AC((int *)buf);
      ((void (**)(id, id, void *))v10)[2](v10, 0, v20);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v21 = *(NSObject **)&v35[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "Invalid completion block while fetching chatbot render information from cache", buf, 2u);
    }
  }
}

- (void)fetchRenderInformation:(id)a3 forChatBot:(id)a4 withOperationID:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  uint64_t v13 = (void (**)(id, void *))a6;
  if (v13)
  {
    if (v10 && v11)
    {
      unsigned int v14 = [v11 uri];
      id v15 = v14;
      if (v12 && v14)
      {
        uint64_t v16 = [v12 uuid];

        if (v16)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v17 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            [v10 slotID];
            uint64_t v18 = CTSubscriptionSlotAsString();
            int v19 = [v11 uri];
            char v20 = [v12 uuid];
            *(_DWORD *)long long buf = 136315651;
            *(void *)&uint8_t buf[4] = v18;
            *(_WORD *)&buf[12] = 2113;
            *(void *)&buf[14] = v19;
            __int16 v38 = 2113;
            long long v39 = v20;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] fetchRenderInformation [slot: %s, destination: %{private}@, operationID: %{private}@]", buf, 0x20u);
          }
          id v21 = [v10 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          uint64_t v35 = 0;
          uint64_t v36 = 0;
          sub_1013FFAB8(&v35, self);
          uint64_t v23 = v35;
          if (v35)
          {
            sub_1014010FC((uint64_t)buf, v11);
            id v24 = [v12 uuid];
            sub_100058DB0(__p, (char *)[v24 UTF8String]);
            uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **))(*(void *)v23 + 96))(v23, v22, buf, __p);
            uint64_t v34 = v25;
            if (v33 < 0) {
              operator delete(__p[0]);
            }

            if (v43 < 0) {
              operator delete(v42);
            }
            if (v41[24])
            {
              __p[0] = v41;
              sub_100047F64((void ***)__p);
            }
            if (v40 < 0) {
              operator delete(v39);
            }
            if (SHIBYTE(v38) < 0) {
              operator delete(*(void **)buf);
            }
            if ((v25 & 0xFF00000000) != 0)
            {
              uint64_t v26 = sub_1005628AC((int *)&v34);
              v13[2](v13, v26);
            }
            else
            {
              v13[2](v13, 0);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            char v30 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            uint64_t v31 = sub_1005628AC((int *)buf);
            v13[2](v13, v31);
          }
          if (v36) {
            sub_10004D2C8(v36);
          }
          goto LABEL_31;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    int v28 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    uint64_t v29 = sub_1005628AC((int *)buf);
    v13[2](v13, v29);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v27 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_INFO, "Invalid completion block while fetching chatbot render information", buf, 2u);
    }
  }
LABEL_31:
}

- (void)getSystemConfiguration:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, id, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        [v6 slotID];
        uint64_t v9 = CTSubscriptionSlotAsString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] getSystemConfiguration: [slot %s]", buf, 0xCu);
      }
      uint64_t v18 = 0;
      int v19 = 0;
      sub_1013FFB6C(&v18, self);
      uint64_t v10 = v18;
      if (v18)
      {
        id v11 = [v6 slotID];
        memset(&v29[4], 0, 32);
        if (v11 == (id)2) {
          uint64_t v12 = 2;
        }
        else {
          uint64_t v12 = v11 == (id)1;
        }
        memset(v29, 0, 64);
        memset(v28, 0, sizeof(v28));
        long long v26 = 0uLL;
        long long v27 = 0uLL;
        long long v24 = 0uLL;
        long long v25 = 0uLL;
        long long v22 = 0uLL;
        *(_OWORD *)long long __p = 0uLL;
        *(_OWORD *)long long buf = 0uLL;
        long long v21 = 0uLL;
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v10 + 56))(buf, v10, v12);
        id v13 = [objc_alloc((Class)CTLazuliSystemConfiguration) initWithReflection:buf];
        v7[2](v7, v13, 0);

        sub_10039BE98((uint64_t)v29);
        sub_10039BEEC((uint64_t)v28 + 8);
        if (BYTE8(v25) && (_BYTE)v25 && SHIBYTE(v24) < 0) {
          operator delete(__p[1]);
        }
      }
      else
      {
        uint64_t v17 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
        ((void (**)(id, id, void *))v7)[2](v7, 0, v17);
      }
      if (v19) {
        sub_10004D2C8(v19);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v15 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      uint64_t v16 = sub_1005628AC((int *)buf);
      ((void (**)(id, id, void *))v7)[2](v7, 0, v16);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    unsigned int v14 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Invalid completion block while getting system configuration information", buf, 2u);
    }
  }
}

- (void)retrieveMessage:(id)a3 withMessageID:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(id, id, void))a5;
  if (v10)
  {
    if (v8
      && v9
      && ([v9 uuid], id v11 = objc_claimAutoreleasedReturnValue(), v11, v11))
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v12 = *(NSObject **)((char *)v31 + 4);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        id v13 = [v9 uuid];
        *(_DWORD *)long long buf = 138543362;
        v31[0] = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] retrieveMessage [identifier: %{public}@]", buf, 0xCu);
      }
      id v14 = [v8 slotID];
      if (v14 == (id)2) {
        uint64_t v15 = 2;
      }
      else {
        uint64_t v15 = v14 == (id)1;
      }
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      sub_1013FFAB8(&v28, self);
      uint64_t v16 = v28;
      if (v28)
      {
        bzero(buf, 0x300uLL);
        id v17 = [v9 uuid];
        sub_100058DB0(__p, (char *)[v17 UTF8String]);
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, void **))(*(void *)v16 + 192))(buf, v16, v15, __p);
        if (v27 < 0) {
          operator delete(__p[0]);
        }

        if (v32)
        {
          id v18 = objc_alloc((Class)CTLazuliMessageEnvelope);
          if (!v32) {
            sub_10016C840();
          }
          id v19 = [v18 initWithReflection:buf];
          v10[2](v10, v19, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          long long v25 = __p[1];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)__p);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Missing or invalid message", (uint8_t *)__p, 2u);
          }
          v10[2](v10, 0, 0);
        }
        sub_100455FA0((uint64_t)buf);
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v23 = *(NSObject **)((char *)v31 + 4);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while while retrieving message", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        LOBYTE(v31[0]) = 1;
        long long v24 = sub_1005628AC((int *)buf);
        ((void (**)(id, id, void *))v10)[2](v10, 0, v24);
      }
      if (v29) {
        sub_10004D2C8(v29);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v20 = *(NSObject **)((char *)v31 + 4);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      LOBYTE(v31[0]) = 1;
      long long v21 = sub_1005628AC((int *)buf);
      ((void (**)(id, id, void *))v10)[2](v10, 0, v21);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    long long v22 = *(NSObject **)((char *)v31 + 4);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "Invalid completion block while retrieving message", buf, 2u);
    }
  }
}

- (void)retrieveAllIncomingMessageIDs:(id)a3 completion:(id)a4
{
  id v6 = a3;
  int v7 = (void (**)(id, id, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        [v6 slotID];
        uint64_t v9 = CTSubscriptionSlotAsString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] retrieveAllIncomingMessageIDs: [slot: %s]", buf, 0xCu);
      }
      [v6 slotID];
      uint64_t v17 = 0;
      id v18 = 0;
      sub_1013FFAB8(&v17, self);
      if (v17)
      {
        *(_OWORD *)long long buf = 0u;
        long long v21 = 0u;
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v17 + 200))(buf);
        if (BYTE8(v21))
        {
          id v10 = objc_alloc((Class)CTLazuliMessageIDList);
          if (!BYTE8(v21)) {
            sub_10016C840();
          }
          id v11 = [v10 initWithReflection:buf];
          v7[2](v7, v11, 0);
        }
        else
        {
          v7[2](v7, 0, 0);
        }
        if (BYTE8(v21))
        {
          id v19 = buf;
          sub_100047F64((void ***)&v19);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v15 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while retrieving all incoming messages", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        uint64_t v16 = sub_1005628AC((int *)buf);
        ((void (**)(id, id, void *))v7)[2](v7, 0, v16);
      }
      if (v18) {
        sub_10004D2C8(v18);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v13 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      id v14 = sub_1005628AC((int *)buf);
      ((void (**)(id, id, void *))v7)[2](v7, 0, v14);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v12 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid completion handler while retrieving all incomming message", buf, 2u);
    }
  }
}

- (void)acknowledgeIncomingMessages:(id)a3 withMessageIDList:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v36 = a4;
  uint64_t v35 = (void (**)(id, void *))a5;
  if (v35)
  {
    uint64_t v9 = v8;
    if (v8 && v36)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v10 = *((void *)&buf + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        [v8 slotID];
        uint64_t v11 = CTSubscriptionSlotAsString();
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] acknowledgeIncomingMessages: [slot: %s]", (uint8_t *)&buf, 0xCu);
      }
      id v12 = [v8 slotID];
      int v13 = v12 == (id)1;
      if (v12 == (id)2) {
        int v13 = 2;
      }
      unsigned int v34 = v13;
      uint64_t v46 = 0;
      uint64_t v47 = 0;
      sub_1013FFAB8(&v46, self);
      if (v46)
      {
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        unint64_t v45 = 0;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        id v14 = [v36 list];
        id v15 = [v14 countByEnumeratingWithState:&v39 objects:v48 count:16];
        if (v15)
        {
          uint64_t v16 = *(void *)v40;
          do
          {
            for (uint64_t i = 0; i != v15; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v40 != v16) {
                objc_enumerationMutation(v14);
              }
              id v18 = [*(id *)(*((void *)&v39 + 1) + 8 * i) uuid];
              sub_100058DB0(__p, (char *)[v18 UTF8String]);
              id v19 = v44;
              if ((unint64_t)v44 >= v45)
              {
                unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v44[-v43] >> 3);
                unint64_t v22 = v21 + 1;
                if (v21 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  sub_10006A748();
                }
                if (0x5555555555555556 * ((uint64_t)(v45 - v43) >> 3) > v22) {
                  unint64_t v22 = 0x5555555555555556 * ((uint64_t)(v45 - v43) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v45 - v43) >> 3) >= 0x555555555555555) {
                  unint64_t v23 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v23 = v22;
                }
                long long v52 = &v45;
                if (v23) {
                  long long v24 = (char *)sub_10004812C((uint64_t)&v45, v23);
                }
                else {
                  long long v24 = 0;
                }
                long long v25 = &v24[24 * v21];
                *(void *)&long long buf = v24;
                *((void *)&buf + 1) = v25;
                long long v51 = &v24[24 * v23];
                long long v26 = *(_OWORD *)__p;
                *((void *)v25 + 2) = v38;
                *(_OWORD *)long long v25 = v26;
                __p[1] = 0;
                uint64_t v38 = 0;
                __p[0] = 0;
                long long v50 = v25 + 24;
                sub_10113D234(&v43, &buf);
                char v27 = v44;
                sub_100048174((uint64_t)&buf);
                uint64_t v44 = v27;
                uint64_t v9 = v8;
                if (SHIBYTE(v38) < 0) {
                  operator delete(__p[0]);
                }
              }
              else
              {
                long long v20 = *(_OWORD *)__p;
                *((void *)v44 + 2) = v38;
                *id v19 = v20;
                __p[1] = 0;
                uint64_t v38 = 0;
                __p[0] = 0;
                uint64_t v44 = (char *)v19 + 24;
              }
            }
            id v15 = [v14 countByEnumeratingWithState:&v39 objects:v48 count:16];
          }
          while (v15);
        }

        *(void *)&long long buf = (*(uint64_t (**)(uint64_t, void, uint64_t *))(*(void *)v46 + 208))(v46, v34, &v43);
        if ((buf & 0xFF00000000) != 0)
        {
          uint64_t v28 = sub_1005628AC((int *)&buf);
          v35[2](v35, v28);
        }
        else
        {
          v35[2](v35, 0);
        }
        *(void *)&long long buf = &v43;
        sub_100047F64((void ***)&buf);
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        char v32 = *((void *)&buf + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while acknowledging incoming messages", (uint8_t *)&buf, 2u);
        }
        LODWORD(buf) = 5;
        BYTE4(buf) = 1;
        char v33 = sub_1005628AC((int *)&buf);
        v35[2](v35, v33);
      }
      if (v47) {
        sub_10004D2C8(v47);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v30 = *((void *)&buf + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Invalid arguments", (uint8_t *)&buf, 2u);
      }
      LODWORD(buf) = 4;
      BYTE4(buf) = 1;
      uint64_t v31 = sub_1005628AC((int *)&buf);
      v35[2](v35, v31);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v29 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    uint64_t v9 = v8;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Invalid completion block in acknowledge incoming messages", (uint8_t *)&buf, 2u);
    }
  }
}

- (void)discoverCapabilities:(id)a3 forDestination:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, void *))a5;
  if (v10)
  {
    if (v8
      && v9
      && ([v9 uri], uint64_t v11 = objc_claimAutoreleasedReturnValue(), v11, v11))
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v12 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        [v8 slotID];
        uint64_t v13 = CTSubscriptionSlotAsString();
        id v14 = [v9 uri];
        *(_DWORD *)long long buf = 136315395;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&buf[12] = 2113;
        *(void *)&buf[14] = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] discoverCapabilities [slot: %s, destination: %{private}@]", buf, 0x16u);
      }
      id v15 = [v8 slotID];
      if (v15 == (id)2) {
        uint64_t v16 = 2;
      }
      else {
        uint64_t v16 = v15 == (id)1;
      }
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      sub_1013FFAB8(&v30, self);
      if (v30)
      {
        v28[0] = 0;
        v28[1] = 0;
        uint64_t v29 = 0;
        sub_100561B00((uint64_t)v28);
        uint64_t v17 = v30;
        sub_1014010FC((uint64_t)buf, v9);
        if (SHIBYTE(v29) < 0)
        {
          sub_10004FC84(__p, v28[0], (unint64_t)v28[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)v28;
          uint64_t v26 = v29;
        }
        uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **))(*(void *)v17 + 128))(v17, v16, buf, __p);
        uint64_t v27 = v23;
        if (SHIBYTE(v26) < 0) {
          operator delete(__p[0]);
        }
        if (v38 < 0) {
          operator delete(v37);
        }
        if (v36[24])
        {
          __p[0] = v36;
          sub_100047F64((void ***)__p);
        }
        if (v35 < 0) {
          operator delete(v34);
        }
        if (v33 < 0) {
          operator delete(*(void **)buf);
        }
        if ((v23 & 0xFF00000000) != 0)
        {
          long long v24 = sub_1005628AC((int *)&v27);
          v10[2](v10, v24);
        }
        else
        {
          v10[2](v10, 0);
        }
        if (SHIBYTE(v29) < 0) {
          operator delete(v28[0]);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        unint64_t v21 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while discovering capabilites", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        unint64_t v22 = sub_1005628AC((int *)buf);
        v10[2](v10, v22);
      }
      if (v31) {
        sub_10004D2C8(v31);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v18 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      id v19 = sub_1005628AC((int *)buf);
      v10[2](v10, v19);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    long long v20 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion handler in discover capabilities", buf, 2u);
    }
  }
}

- (void)fetchRemoteCapabilities:(id)a3 forDestination:(id)a4 withOptions:(id)a5 withOperationID:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  uint64_t v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12 && v13)
    {
      uint64_t v17 = [v13 uri];
      id v18 = v17;
      if (v15 && v14 && v17)
      {
        id v19 = [v15 uuid];

        if (v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          long long v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            [v12 slotID];
            uint64_t v37 = CTSubscriptionSlotAsString();
            unint64_t v21 = [v13 uri];
            id v22 = [v14 type];
            uint64_t v23 = [v15 uuid];
            *(_DWORD *)long long buf = 136315907;
            *(void *)&uint8_t buf[4] = v37;
            *(_WORD *)&buf[12] = 2113;
            *(void *)&buf[14] = v21;
            __int16 v45 = 2048;
            uint64_t v46 = v22;
            __int16 v47 = 2113;
            long long v48 = v23;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] fetchRemoteCapabilities [slot: %s, destination: %{private}@, options: %ld, operationID: %{private}@]", buf, 0x2Au);
          }
          id v24 = [v12 slotID];
          if (v24 == (id)2) {
            uint64_t v25 = 2;
          }
          else {
            uint64_t v25 = v24 == (id)1;
          }
          uint64_t v42 = 0;
          uint64_t v43 = 0;
          sub_1013FFAB8(&v42, self);
          if (v42)
          {
            id v26 = [v14 type];
            uint64_t v27 = v42;
            sub_1014010FC((uint64_t)buf, v13);
            if ((unint64_t)v26 >= 3) {
              int v28 = -1;
            }
            else {
              int v28 = (int)v26;
            }
            int v40 = v28;
            id v29 = [v15 uuid];
            sub_100058DB0(__p, (char *)[v29 UTF8String]);
            uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, int *, void **))(*(void *)v27 + 136))(v27, v25, buf, &v40, __p);
            uint64_t v41 = v30;
            if (v39 < 0) {
              operator delete(__p[0]);
            }

            if (v52 < 0) {
              operator delete(v51);
            }
            if (v50[24])
            {
              __p[0] = v50;
              sub_100047F64((void ***)__p);
            }
            if (v49 < 0) {
              operator delete(v46);
            }
            if (SHIBYTE(v45) < 0) {
              operator delete(*(void **)buf);
            }
            if ((v30 & 0xFF00000000) != 0)
            {
              uint64_t v31 = sub_1005628AC((int *)&v41);
              v16[2](v16, v31);
            }
            else
            {
              v16[2](v16, 0);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            char v35 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while discovering capabilites", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            id v36 = sub_1005628AC((int *)buf);
            v16[2](v16, v36);
          }
          if (v43) {
            sub_10004D2C8(v43);
          }
          goto LABEL_35;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    char v33 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    unsigned int v34 = sub_1005628AC((int *)buf);
    v16[2](v16, v34);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v32 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Invalid completion handler in fetching remote capabilities", buf, 2u);
    }
  }
LABEL_35:
}

- (void)discoverRemoteCapabilities:(id)a3 forDestination:(id)a4 withOperationID:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(id, void *))a6;
  if (v13)
  {
    if (v10 && v11)
    {
      id v14 = [v11 uri];
      id v15 = v14;
      if (v12 && v14)
      {
        uint64_t v16 = [v12 uuid];

        if (v16)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v17 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            [v10 slotID];
            uint64_t v18 = CTSubscriptionSlotAsString();
            id v19 = [v11 uri];
            long long v20 = [v12 uuid];
            *(_DWORD *)long long buf = 136315651;
            *(void *)&uint8_t buf[4] = v18;
            *(_WORD *)&buf[12] = 2113;
            *(void *)&buf[14] = v19;
            __int16 v39 = 2113;
            int v40 = v20;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] discoverRemoteCapabilities [slot: %s, destination: %{private}@, operationID: %{private}@]", buf, 0x20u);
          }
          id v21 = [v10 slotID];
          if (v21 == (id)2) {
            uint64_t v22 = 2;
          }
          else {
            uint64_t v22 = v21 == (id)1;
          }
          uint64_t v35 = 0;
          id v36 = 0;
          sub_1013FFAB8(&v35, self);
          if (v35)
          {
            v33[0] = 0;
            v33[1] = 0;
            uint64_t v34 = 0;
            id v23 = [v12 uuid];
            sub_100058DB0(v33, (char *)[v23 UTF8String]);

            uint64_t v24 = v35;
            sub_1014010FC((uint64_t)buf, v11);
            uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **))(*(void *)v24 + 128))(v24, v22, buf, v33);
            uint64_t v32 = v25;
            if (v44 < 0) {
              operator delete(__p);
            }
            if (v42[24])
            {
              uint64_t v37 = (void **)v42;
              sub_100047F64(&v37);
            }
            if (v41 < 0) {
              operator delete(v40);
            }
            if (SHIBYTE(v39) < 0) {
              operator delete(*(void **)buf);
            }
            if ((v25 & 0xFF00000000) != 0)
            {
              id v26 = sub_1005628AC((int *)&v32);
              v13[2](v13, v26);
            }
            else
            {
              v13[2](v13, 0);
            }
            if (SHIBYTE(v34) < 0) {
              operator delete(v33[0]);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v30 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while discovering capabilites", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            uint64_t v31 = sub_1005628AC((int *)buf);
            v13[2](v13, v31);
          }
          if (v36) {
            sub_10004D2C8(v36);
          }
          goto LABEL_29;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    int v28 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v29 = sub_1005628AC((int *)buf);
    v13[2](v13, v29);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v27 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Invalid completion handler in discover capabilities", buf, 2u);
    }
  }
LABEL_29:
}

- (void)readCachedCapabilities:(id)a3 forDestination:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, id, void))a5;
  if (v10)
  {
    if (v8
      && v9
      && ([v9 uri], id v11 = objc_claimAutoreleasedReturnValue(), v11, v11))
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v12 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        [v8 slotID];
        uint64_t v13 = CTSubscriptionSlotAsString();
        id v14 = [v9 uri];
        *(_DWORD *)long long buf = 136315395;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&buf[12] = 2113;
        *(void *)&buf[14] = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] readCachedCapabilities [slot: %s, destination: %{private}@]", buf, 0x16u);
      }
      id v15 = [v8 slotID];
      if (v15 == (id)2) {
        uint64_t v16 = 2;
      }
      else {
        uint64_t v16 = v15 == (id)1;
      }
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      sub_1013FFAB8(&v33, self);
      uint64_t v17 = v33;
      if (v33)
      {
        uint64_t v48 = 0;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v37 = 0u;
        memset(buf, 0, sizeof(buf));
        sub_1014010FC((uint64_t)v26, v9);
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, void **))(*(void *)v17 + 144))(buf, v17, v16, v26);
        if (v32 < 0) {
          operator delete(__p);
        }
        if (v30[24])
        {
          uint64_t v35 = (void **)v30;
          sub_100047F64(&v35);
        }
        if (v29 < 0) {
          operator delete(v28);
        }
        if (v27 < 0) {
          operator delete(v26[0]);
        }
        if ((_BYTE)v48)
        {
          id v18 = objc_alloc((Class)CTLazuliCapabilitiesInformation);
          if (!(_BYTE)v48) {
            sub_10016C840();
          }
          id v19 = [v18 initWithReflection:buf];
          v10[2](v10, v19, 0);
        }
        else
        {
          v10[2](v10, 0, 0);
        }
        sub_1001794B8((uint64_t)buf);
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v24 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while discovering capabilites", buf, 2u);
        }
        *(_DWORD *)long long buf = 0;
        uint8_t buf[4] = 1;
        uint64_t v25 = sub_1005628AC((int *)buf);
        ((void (**)(id, id, void *))v10)[2](v10, 0, v25);
      }
      if (v34) {
        sub_10004D2C8(v34);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      long long v20 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      id v21 = sub_1005628AC((int *)buf);
      ((void (**)(id, id, void *))v10)[2](v10, 0, v21);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion handler in readCachedCapabilities", buf, 2u);
    }
    *(_DWORD *)long long buf = 5;
    uint8_t buf[4] = 1;
    id v23 = sub_1005628AC((int *)buf);
    MEMORY[0x10](0, 0, v23);
  }
}

- (void)sendDispositionNotificationMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withDisposition:(int64_t)a6 forMessageID:(id)a7 completion:(id)a8
{
  id v14 = a3;
  id v15 = a4;
  id v16 = a5;
  id v17 = a7;
  id v18 = (void (**)(id, void *))a8;
  if (v18)
  {
    if (v14 && v15)
    {
      uint64_t v19 = [v15 uri];
      long long v20 = (void *)v19;
      if (v16 && v19)
      {
        id v21 = [v16 uuid];
        uint64_t v22 = v21;
        if (v17 && v21)
        {
          id v23 = [v17 uuid];

          if (v23)
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v24 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              [v14 slotID];
              uint64_t v41 = CTSubscriptionSlotAsString();
              long long v42 = [v15 uri];
              uint64_t v25 = [v16 uuid];
              id v26 = [v17 uuid];
              *(_DWORD *)long long buf = 136316163;
              *(void *)&uint8_t buf[4] = v41;
              *(_WORD *)&buf[12] = 2113;
              *(void *)&buf[14] = v42;
              __int16 v52 = 2114;
              long long v53 = v25;
              __int16 v54 = 2048;
              int64_t v55 = a6;
              __int16 v56 = 2114;
              long long v57 = v26;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendDispositionNotificationMessage [slot: %s, to: %{private}@, identifier: %{public}@, type: %ld, forMessageID: %{public}@]", buf, 0x34u);
            }
            id v27 = [v14 slotID];
            if (v27 == (id)2) {
              uint64_t v28 = 2;
            }
            else {
              uint64_t v28 = v27 == (id)1;
            }
            uint64_t v49 = 0;
            long long v50 = 0;
            sub_1013FFAB8(&v49, self);
            uint64_t v29 = v49;
            if (v49)
            {
              if (a6 == 2) {
                int v30 = 2;
              }
              else {
                int v30 = -1;
              }
              if (a6) {
                int v31 = v30;
              }
              else {
                int v31 = 0;
              }
              sub_1014010FC((uint64_t)buf, v15);
              id v32 = [v16 uuid];
              sub_100058DB0(v46, (char *)[v32 UTF8String]);
              LODWORD(v43) = v31;
              id v33 = [v17 uuid];
              sub_100058DB0(&__p, (char *)[v33 UTF8String]);
              uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **, void ***))(*(void *)v29 + 224))(v29, v28, buf, v46, &v43);
              uint64_t v48 = v34;
              if (v45 < 0) {
                operator delete(__p);
              }

              if (v47 < 0) {
                operator delete(v46[0]);
              }

              if (v60 < 0) {
                operator delete(v59);
              }
              if (v58[24])
              {
                long long v43 = (void **)v58;
                sub_100047F64(&v43);
              }
              if (SBYTE3(v57) < 0) {
                operator delete(v53);
              }
              if (SHIBYTE(v52) < 0) {
                operator delete(*(void **)buf);
              }
              if ((v34 & 0xFF00000000) != 0)
              {
                uint64_t v35 = sub_1005628AC((int *)&v48);
                v18[2](v18, v35);
              }
              else
              {
                v18[2](v18, 0);
              }
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              long long v39 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending disposition message", buf, 2u);
              }
              *(_DWORD *)long long buf = 5;
              uint8_t buf[4] = 1;
              long long v40 = sub_1005628AC((int *)buf);
              v18[2](v18, v40);
            }
            if (v50) {
              sub_10004D2C8(v50);
            }
            goto LABEL_42;
          }
          goto LABEL_39;
        }
      }
    }
LABEL_39:
    [(CTXPCClientHandler *)self getLogContext];
    long long v37 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    long long v38 = sub_1005628AC((int *)buf);
    v18[2](v18, v38);

    goto LABEL_42;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v36 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Invalid completion block while sending disposition message", buf, 2u);
  }
LABEL_42:
}

- (void)sendFileTransferMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withFileInformation:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12 && v13)
    {
      id v17 = [v13 uri];
      id v18 = v17;
      if (v14 && v17)
      {
        uint64_t v19 = [v14 uuid];

        if (v15 && v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          long long v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            [v12 slotID];
            uint64_t v21 = CTSubscriptionSlotAsString();
            uint64_t v22 = [v13 uri];
            id v23 = [v14 uuid];
            *(_DWORD *)long long buf = 136315651;
            *(void *)&uint8_t buf[4] = v21;
            *(_WORD *)&buf[12] = 2113;
            *(void *)&buf[14] = v22;
            __int16 v59 = 2114;
            char v60 = v23;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendFileTransferMessage [slot: %s, to: %{private}@, identifier: %{public}@]", buf, 0x20u);
          }
          id v24 = [v12 slotID];
          if (v24 == (id)2) {
            uint64_t v25 = 2;
          }
          else {
            uint64_t v25 = v24 == (id)1;
          }
          uint64_t v56 = 0;
          long long v57 = 0;
          sub_1013FFAB8(&v56, self);
          if (v56)
          {
            uint64_t v55 = 0;
            memset(v54, 0, sizeof(v54));
            long long v52 = 0u;
            long long v53 = 0u;
            *(_OWORD *)long long v50 = 0u;
            *(_OWORD *)long long v51 = 0u;
            *(_OWORD *)uint64_t v48 = 0u;
            long long v49 = 0u;
            *(_OWORD *)char v47 = 0u;
            memset(v46, 0, sizeof(v46));
            sub_101405064((uint64_t)v46, v15);
            uint64_t v26 = v56;
            sub_1014010FC((uint64_t)v38, v13);
            id v27 = [v14 uuid];
            sub_100058DB0(__p, (char *)[v27 UTF8String]);
            sub_10045449C(buf, (uint64_t)v46);
            char v61 = 0;
            char v62 = 0;
            uint64_t v28 = [v15 metaData];
            sub_1014056B0((uint64_t)&v63, v28);
            uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t, void **, void **, unsigned char *))(*(void *)v26 + 240))(v26, v25, v38, __p, buf);
            uint64_t v45 = v29;
            sub_100454840((uint64_t)buf);

            if (v37 < 0) {
              operator delete(__p[0]);
            }

            if (v44 < 0) {
              operator delete(v43);
            }
            if (v42[24])
            {
              *(void *)long long buf = v42;
              sub_100047F64((void ***)buf);
            }
            if (v41 < 0) {
              operator delete(v40);
            }
            if (v39 < 0) {
              operator delete(v38[0]);
            }
            if ((v29 & 0xFF00000000) != 0)
            {
              int v30 = sub_1005628AC((int *)&v45);
              v16[2](v16, v30);
            }
            else
            {
              v16[2](v16, 0);
            }
            if ((_BYTE)v55)
            {
              *(void *)long long buf = (char *)v54 + 8;
              sub_100155410((void ***)buf);
            }
            if (SHIBYTE(v52) < 0) {
              operator delete(v51[1]);
            }
            if (SHIBYTE(v51[0]) < 0) {
              operator delete(v50[0]);
            }
            if (SHIBYTE(v49) < 0) {
              operator delete(v48[1]);
            }
            if (SHIBYTE(v48[0]) < 0) {
              operator delete(v47[0]);
            }
            sub_10045468C((uint64_t)v46);
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v34 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending file transfer message", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            uint64_t v35 = sub_1005628AC((int *)buf);
            v16[2](v16, v35);
          }
          if (v57) {
            sub_10004D2C8(v57);
          }
          goto LABEL_32;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v32 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v33 = sub_1005628AC((int *)buf);
    v16[2](v16, v33);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    int v31 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Invalid completion block while sending file transfer message", buf, 2u);
    }
  }
LABEL_32:
}

- (void)sendTextMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withMessage:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12 && v13)
    {
      uint64_t v17 = [v13 uri];
      id v18 = (void *)v17;
      if (v14 && v17)
      {
        uint64_t v19 = [v14 uuid];
        long long v20 = v19;
        if (v15 && v19)
        {
          uint64_t v21 = [v15 content];

          if (v21)
          {
            id v22 = [v12 slotID];
            if (v22 == (id)2) {
              int v23 = 2;
            }
            else {
              int v23 = v22 == (id)1;
            }
            uint64_t v48 = 0;
            long long v49 = 0;
            sub_1013FFAB8(&v48, self);
            if (v48)
            {
              unsigned int v40 = v23;
              [(CTXPCClientHandler *)self getLogContext];
              id v24 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
              {
                [v12 slotID];
                uint64_t v25 = CTSubscriptionSlotAsString();
                uint64_t v26 = [v13 uri];
                id v27 = [v14 uuid];
                uint64_t v28 = [v15 content];
                *(_DWORD *)long long buf = 136316163;
                *(void *)&uint8_t buf[4] = v25;
                *(_WORD *)&buf[12] = 2113;
                *(void *)&buf[14] = v26;
                __int16 v52 = 2114;
                long long v53 = v27;
                __int16 v54 = 2160;
                uint64_t v55 = 1752392040;
                __int16 v56 = 2117;
                long long v57 = v28;
                _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendTextMessage [slot: %s, to: %{private}@, identifier: %{public}@, content: %{sensitive, mask.hash}@]", buf, 0x34u);
              }
              uint64_t v29 = v48;
              sub_1014010FC((uint64_t)buf, v13);
              id v39 = [v14 uuid];
              sub_100058DB0(v46, (char *)[v39 UTF8String]);
              id v38 = [v15 content];
              sub_100058DB0(__p, (char *)[v38 UTF8String]);
              char v43 = 0;
              char v44 = 0;
              int v30 = [v15 metaData];
              sub_1014056B0((uint64_t)v45, v30);
              uint64_t v31 = (*(uint64_t (**)(uint64_t, void, unsigned char *, void **, void **))(*(void *)v29 + 176))(v29, v40, buf, v46, __p);
              if (v45[24])
              {
                long long v50 = (void **)v45;
                sub_100155410(&v50);
              }
              if (v44)
              {
                long long v50 = (void **)&v43;
                sub_100155494(&v50);
              }
              if (v42 < 0) {
                operator delete(__p[0]);
              }

              if (v47 < 0) {
                operator delete(v46[0]);
              }

              if (v60 < 0) {
                operator delete(v59);
              }
              if (v58[24])
              {
                __p[0] = v58;
                sub_100047F64((void ***)__p);
              }
              if (SBYTE3(v57) < 0) {
                operator delete(v53);
              }
              if (SHIBYTE(v52) < 0) {
                operator delete(*(void **)buf);
              }
              if ((v31 & 0xFF00000000) != 0)
              {
                *(_DWORD *)long long buf = v31;
                uint8_t buf[4] = 1;
                id v32 = sub_1005628AC((int *)buf);
                v16[2](v16, v32);
              }
              else
              {
                v16[2](v16, 0);
              }
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              id v36 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending file transfer message", buf, 2u);
              }
              *(_DWORD *)long long buf = 5;
              uint8_t buf[4] = 1;
              char v37 = sub_1005628AC((int *)buf);
              v16[2](v16, v37);
            }
            if (v49) {
              sub_10004D2C8(v49);
            }
            goto LABEL_40;
          }
          goto LABEL_37;
        }
      }
    }
LABEL_37:
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v34 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    uint64_t v35 = sub_1005628AC((int *)buf);
    v16[2](v16, v35);

    goto LABEL_40;
  }
  [(CTXPCClientHandler *)self getLogContext];
  id v33 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Invalid completion block while sending text message", buf, 2u);
  }
LABEL_40:
}

- (void)sendComposingIndicator:(id)a3 to:(id)a4 withMessageID:(id)a5 withIndication:(id)a6 withError:(id *)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  uint64_t v59 = 0;
  char v60 = 0;
  sub_1013FFAB8(&v59, self);
  if (!v59)
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending composing indicator", buf, 2u);
      if (!a7) {
        goto LABEL_24;
      }
    }
    else if (!a7)
    {
      goto LABEL_24;
    }
    *(_DWORD *)long long buf = 3;
    uint8_t buf[4] = 1;
    sub_1005628AC((int *)buf);
    id v23 = (id)objc_claimAutoreleasedReturnValue();
LABEL_23:
    *a7 = v23;
    goto LABEL_24;
  }
  if (!v12 || !v13)
  {
LABEL_20:
    [(CTXPCClientHandler *)self getLogContext];
    id v24 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    sub_1005628AC((int *)buf);
    id v23 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_23;
  }
  id v16 = [v13 uri];
  id v17 = v16;
  if (!v14 || !v16)
  {

    goto LABEL_20;
  }
  id v18 = [v14 uuid];
  if (v15) {
    BOOL v19 = v18 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  int v20 = v19;

  if (v20) {
    goto LABEL_20;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v21 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    [v12 slotID];
    uint64_t v46 = CTSubscriptionSlotAsString();
    char v47 = [v13 uri];
    uint64_t v48 = [v14 uuid];
    long long v49 = [v15 refreshTime];
    if (v49)
    {
      char v44 = [v15 refreshTime];
      uint64_t v45 = (uint64_t)[v44 longValue];
    }
    else
    {
      uint64_t v45 = -1;
    }
    unsigned int v25 = [v15 active];
    uint64_t v26 = [v15 lastActive];
    if (v26)
    {
      id v17 = [v15 lastActive];
      id v27 = (const char *)[v17 UTF8String];
    }
    else
    {
      id v27 = "";
    }
    *(_DWORD *)long long buf = 136316419;
    *(void *)&uint8_t buf[4] = v46;
    *(_WORD *)&buf[12] = 2113;
    *(void *)&buf[14] = v47;
    __int16 v62 = 2114;
    uint64_t v63 = v48;
    __int16 v64 = 2048;
    uint64_t v65 = v45;
    __int16 v66 = 1024;
    unsigned int v67 = v25;
    __int16 v68 = 2080;
    long long v69 = v27;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendComposingIndicator [slot: %s, to: %{private}@, identifier: %{public}@, ind.refreshTime: %ld, ind.active: %d, ind.lastActive: %s]", buf, 0x3Au);
    if (v26) {

    }
    if (v49) {
  }
    }
  id v28 = [v12 slotID];
  uint64_t v58 = 0;
  *(_OWORD *)__int16 v56 = 0u;
  long long v57 = 0u;
  if (v28 == (id)2) {
    uint64_t v29 = 2;
  }
  else {
    uint64_t v29 = v28 == (id)1;
  }
  *(_OWORD *)__int16 v54 = 0uLL;
  long long v55 = 0uLL;
  long long v53 = 0uLL;
  int v30 = [v15 refreshTime];
  BOOL v31 = v30 == 0;

  if (!v31)
  {
    id v32 = [v15 refreshTime];
    id v33 = [v32 longValue];
    if (!BYTE8(v53)) {
      BYTE8(v53) = 1;
    }
    *(void *)&long long v53 = v33;
  }
  LOBYTE(v54[0]) = [v15 active];
  uint64_t v34 = [v15 lastActive];
  BOOL v35 = v34 == 0;

  if (!v35)
  {
    id v36 = [v15 lastActive];
    *(void *)long long buf = [v36 UTF8String];
    sub_1000791C0((std::string *)&v54[1], (char **)buf);
  }
  char v37 = [v15 contentType];
  BOOL v38 = v37 == 0;

  if (!v38)
  {
    id v39 = [v15 contentType];
    *(void *)long long buf = [v39 UTF8String];
    sub_1000791C0((std::string *)&v56[1], (char **)buf);
  }
  uint64_t v40 = v59;
  sub_1014010FC((uint64_t)buf, v13);
  id v41 = [v14 uuid];
  sub_100058DB0(__p, (char *)[v41 UTF8String]);
  uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **, long long *))(*(void *)v40 + 216))(v40, v29, buf, __p, &v53);
  uint64_t v52 = v42;
  if (v51 < 0) {
    operator delete(__p[0]);
  }

  if (v72 < 0) {
    operator delete(v71);
  }
  if (v70)
  {
    __p[0] = (char *)&v69 + 6;
    sub_100047F64((void ***)__p);
  }
  if (SHIBYTE(v67) < 0) {
    operator delete(v63);
  }
  if (SHIBYTE(v62) < 0) {
    operator delete(*(void **)buf);
  }
  if ((v42 & 0xFF00000000) == 0) {
    goto LABEL_63;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v43 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
  {
    if (!a7) {
      goto LABEL_63;
    }
    goto LABEL_62;
  }
  *(_WORD *)long long buf = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Sending of sendComposingIndicator indicator failed...", buf, 2u);
  if (a7)
  {
LABEL_62:
    sub_1005628AC((int *)&v52);
    *a7 = (id)objc_claimAutoreleasedReturnValue();
  }
LABEL_63:
  if ((_BYTE)v58 && SHIBYTE(v57) < 0) {
    operator delete(v56[1]);
  }
  if (LOBYTE(v56[0]) && SHIBYTE(v55) < 0) {
    operator delete(v54[1]);
  }
LABEL_24:
  if (v60) {
    sub_10004D2C8(v60);
  }
}

- (void)revokeMessage:(id)a3 withRevokeData:(id)a4 withMessageID:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(id, void *))a6;
  if (v13)
  {
    if (v11)
    {
      if (v12)
      {
        id v14 = [v12 uuid];
        if (v14)
        {
          id v15 = [v11 destination];
          if (v15)
          {
            id v16 = [v11 messageID];
            if (v16)
            {
              id v17 = [v11 messageID];
              id v18 = [v17 uuid];

              if (v18)
              {
                [(CTXPCClientHandler *)self getLogContext];
                BOOL v19 = *(NSObject **)&buf[8];
                ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
                {
                  [v10 slotID];
                  uint64_t v20 = CTSubscriptionSlotAsString();
                  uint64_t v40 = [v12 uuid];
                  uint64_t v21 = [v11 destination];
                  id v22 = [v11 messageID];
                  id v23 = [v22 uuid];
                  *(_DWORD *)long long buf = 136315907;
                  *(void *)&uint8_t buf[4] = v20;
                  *(_WORD *)&buf[12] = 2114;
                  *(void *)&buf[14] = v40;
                  *(_WORD *)&unsigned char buf[22] = 2113;
                  *(void *)&uint8_t buf[24] = v21;
                  LOWORD(v46) = 2114;
                  *(void *)((char *)&v46 + 2) = v23;
                  _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] revokeMessage [slot: %s, identifier: %{public}@, revoke.dst = %{private}@, revoke.messageID: %{public}@]", buf, 0x2Au);
                }
                id v24 = [v10 slotID];
                if (v24 == (id)2) {
                  uint64_t v25 = 2;
                }
                else {
                  uint64_t v25 = v24 == (id)1;
                }
                uint64_t v43 = 0;
                char v44 = 0;
                sub_1013FFAB8(&v43, self);
                if (v43)
                {
                  uint64_t v51 = 0;
                  long long v49 = 0u;
                  long long v50 = 0u;
                  *(_OWORD *)uint64_t v48 = 0u;
                  long long v46 = 0u;
                  memset(v47, 0, sizeof(v47));
                  memset(buf, 0, sizeof(buf));
                  uint64_t v26 = [v11 destination];
                  id v27 = [v26 uri];
                  sub_100058DB0(buf, (char *)[v27 UTF8String]);
                  BYTE8(v47[0]) = 0;
                  LOBYTE(v48[0]) = 0;
                  long long v49 = 0uLL;
                  v48[1] = 0;
                  long long v46 = 0uLL;
                  *(void *)&uint8_t buf[24] = 0;
                  LOBYTE(v47[0]) = 0;
                  id v28 = [v11 messageID];
                  id v29 = [v28 uuid];
                  sub_100058DB0(&v50, (char *)[v29 UTF8String]);

                  uint64_t v30 = v43;
                  BOOL v31 = [v11 messageID];
                  id v32 = [v31 uuid];
                  sub_100058DB0(__p, (char *)[v32 UTF8String]);
                  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, uint8_t *, void **))(*(void *)v30 + 184))(v30, v25, buf, __p);
                  if (v42 < 0) {
                    operator delete(__p[0]);
                  }

                  if ((v33 & 0xFF00000000) != 0)
                  {
                    LODWORD(__p[0]) = v33;
                    BYTE4(__p[0]) = 1;
                    uint64_t v34 = sub_1005628AC((int *)__p);
                    v13[2](v13, v34);
                  }
                  else
                  {
                    v13[2](v13, 0);
                  }
                  if (SHIBYTE(v51) < 0) {
                    operator delete((void *)v50);
                  }
                  if (SHIBYTE(v49) < 0) {
                    operator delete(v48[1]);
                  }
                  if (LOBYTE(v48[0]))
                  {
                    __p[0] = (char *)v47 + 8;
                    sub_100047F64((void ***)__p);
                  }
                  if (SHIBYTE(v46) < 0) {
                    operator delete(*(void **)&buf[24]);
                  }
                  if ((char)buf[23] < 0) {
                    operator delete(*(void **)buf);
                  }
                }
                else
                {
                  [(CTXPCClientHandler *)self getLogContext];
                  BOOL v38 = *(NSObject **)&buf[8];
                  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                  if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending file transfer message", buf, 2u);
                  }
                  *(_DWORD *)long long buf = 5;
                  uint8_t buf[4] = 1;
                  id v39 = sub_1005628AC((int *)buf);
                  v13[2](v13, v39);
                }
                if (v44) {
                  sub_10004D2C8(v44);
                }
                goto LABEL_25;
              }
              goto LABEL_22;
            }
          }
        }
      }
    }
LABEL_22:
    [(CTXPCClientHandler *)self getLogContext];
    id v36 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    char v37 = sub_1005628AC((int *)buf);
    v13[2](v13, v37);

    goto LABEL_25;
  }
  [(CTXPCClientHandler *)self getLogContext];
  BOOL v35 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Invalid completion block while sending text message", buf, 2u);
  }
LABEL_25:
}

- (void)sendGeolocationMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withGeoPush:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12 && v13)
    {
      id v17 = [v13 uri];
      id v18 = v17;
      if (v14 && v17)
      {
        BOOL v19 = [v14 uuid];

        if (v15 && v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            [v12 slotID];
            uint64_t v21 = CTSubscriptionSlotAsString();
            __int16 v54 = [v13 uri];
            long long v53 = [v14 uuid];
            uint64_t v51 = v21;
            [v15 coordinates];
            v52 = id v22 = "ty_sink_tI16ims_client_stateE9bind_implIRMN9emergency9IMSClientEFvNS_3mapI13PersonalityIDbNS_4lessISB_EENS_9allocatorINS_4pairIKSB_bEEEEEEES9_EEvRNS2_10RestModuleEPT0_OT_NS_17integral_constantIbLb0EEEEUlRKN3xpc6objectEE_NSE_ISZ_EEFvSW_EEE";
            if (v52)
            {
              long long v49 = [v15 coordinates];
              long long v50 = [v49 latitude];
              [v50 doubleValue];
              uint64_t v24 = v23;
            }
            else
            {
              uint64_t v24 = 0x406FE00000000000;
            }
            id v28 = [v15 coordinates];
            if (v28)
            {
              uint64_t v48 = [v15 coordinates];
              id v22 = [v48 longitude];
              [v22 doubleValue];
            }
            else
            {
              uint64_t v29 = 0x406FE00000000000;
            }
            *(_DWORD *)long long buf = 136316163;
            *(void *)&uint8_t buf[4] = v51;
            *(_WORD *)&buf[12] = 2113;
            *(void *)&buf[14] = v54;
            *(_WORD *)&unsigned char buf[22] = 2114;
            *(void *)&uint8_t buf[24] = v53;
            *(_WORD *)&uint8_t buf[32] = 2048;
            *(void *)&buf[34] = v24;
            *(_WORD *)&buf[42] = 2048;
            *(void *)&buf[44] = v29;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendGeolocationMessage [slot: %s, to: %{private}@, messageIdentifier: %{public}@, push.latitude: %{senstive}f, push.longitude: %{senstive}f]", buf, 0x34u);
            if (v28)
            {
            }
            if (v52)
            {
            }
          }
          id v30 = [v12 slotID];
          int v31 = v30 == (id)1;
          if (v30 == (id)2) {
            int v31 = 2;
          }
          unsigned int v55 = v31;
          uint64_t v67 = 0;
          __int16 v68 = 0;
          sub_1013FFAB8(&v67, self);
          if (v67)
          {
            long long v65 = 0u;
            long long v66 = 0u;
            id v32 = [v15 additionalDescription];
            BOOL v33 = v32 == 0;

            if (!v33)
            {
              id v34 = [v15 additionalDescription];
              *(void *)long long buf = [v34 UTF8String];
              sub_1000791C0((std::string *)&v65, (char **)buf);
            }
            long long v71 = 0u;
            long long v72 = 0u;
            long long v70 = 0u;
            memset(buf, 0, sizeof(buf));
            BOOL v35 = [v15 coordinates];
            id v36 = [v35 longitude];
            [v36 doubleValue];
            *(void *)long long buf = v37;
            BOOL v38 = [v15 coordinates];
            id v39 = [v38 latitude];
            [v39 doubleValue];
            *(void *)&uint8_t buf[8] = v40;
            sub_1000593FC((uint64_t)&buf[16], &v65);
            buf[48] = 0;
            BYTE8(v70) = 0;
            id v41 = [v15 metaData];
            sub_1014056B0((uint64_t)&v71, v41);

            uint64_t v42 = v67;
            sub_1014010FC((uint64_t)v58, v13);
            id v43 = [v14 uuid];
            sub_100058DB0(__p, (char *)[v43 UTF8String]);
            uint64_t v44 = (*(uint64_t (**)(uint64_t, void, void **, void **, uint8_t *))(*(void *)v42 + 232))(v42, v55, v58, __p, buf);
            if (v57 < 0) {
              operator delete(__p[0]);
            }

            if (v64 < 0) {
              operator delete(v63);
            }
            if (v62[24])
            {
              __p[0] = v62;
              sub_100047F64((void ***)__p);
            }
            if (v61 < 0) {
              operator delete(v60);
            }
            if (v59 < 0) {
              operator delete(v58[0]);
            }
            if ((v44 & 0xFF00000000) != 0)
            {
              LODWORD(v58[0]) = v44;
              BYTE4(v58[0]) = 1;
              uint64_t v45 = sub_1005628AC((int *)v58);
              v16[2](v16, v45);
            }
            else
            {
              v16[2](v16, 0);
            }
            if (BYTE8(v72))
            {
              v58[0] = &v71;
              sub_100155410((void ***)v58);
            }
            if (BYTE8(v70))
            {
              v58[0] = &buf[48];
              sub_100155494((void ***)v58);
            }
            if (buf[40] && (char)buf[39] < 0) {
              operator delete(*(void **)&buf[16]);
            }
            if (BYTE8(v66) && SBYTE7(v66) < 0) {
              operator delete((void *)v65);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            long long v46 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending file transfer message", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            char v47 = sub_1005628AC((int *)buf);
            v16[2](v16, v47);
          }
          if (v68) {
            sub_10004D2C8(v68);
          }
          goto LABEL_17;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v26 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v27 = sub_1005628AC((int *)buf);
    v16[2](v16, v27);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v25 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Invalid completion block while sending geolocation message", buf, 2u);
    }
  }
LABEL_17:
}

- (void)sendDeviceAction:(id)a3 to:(id)a4 withMessageID:(id)a5 withAction:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v13)
    {
      id v17 = [v13 uri];
      id v18 = v17;
      if (v14 && v17)
      {
        BOOL v19 = [v14 uuid];

        if (v15 && v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            [v12 slotID];
            uint64_t v21 = CTSubscriptionSlotAsString();
            id v22 = [v13 uri];
            uint64_t v23 = [v14 uuid];
            id v24 = [v15 type];
            *(_DWORD *)long long buf = 136315906;
            *(void *)&uint8_t buf[4] = v21;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v22;
            __int16 v44 = 2114;
            uint64_t v45 = v23;
            __int16 v46 = 2048;
            id v47 = v24;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendDeviceAction [slot: %s, to: %@, messageIdentifier: %{public}@, type: %ld]", buf, 0x2Au);
          }
          id v25 = [v12 slotID];
          if (v25 == (id)2) {
            uint64_t v26 = 2;
          }
          else {
            uint64_t v26 = v25 == (id)1;
          }
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          sub_1013FFAB8(&v41, self);
          if (v41)
          {
            if ([v15 type]) {
              int v27 = -1;
            }
            else {
              int v27 = 0;
            }
            int v40 = v27;
            uint64_t v28 = v41;
            sub_1014010FC((uint64_t)buf, v13);
            id v29 = [v14 uuid];
            sub_100058DB0(__p, (char *)[v29 UTF8String]);
            uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **, int *))(*(void *)v28 + 272))(v28, v26, buf, __p, &v40);
            uint64_t v39 = v30;
            if (v38 < 0) {
              operator delete(__p[0]);
            }

            if (v51 < 0) {
              operator delete(v50);
            }
            if (v49[24])
            {
              __p[0] = v49;
              sub_100047F64((void ***)__p);
            }
            if (v48 < 0) {
              operator delete(v45);
            }
            if (SHIBYTE(v44) < 0) {
              operator delete(*(void **)buf);
            }
            if ((v30 & 0xFF00000000) != 0)
            {
              int v31 = sub_1005628AC((int *)&v39);
              v16[2](v16, v31);
            }
            else
            {
              v16[2](v16, 0);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            BOOL v35 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending device action", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            id v36 = sub_1005628AC((int *)buf);
            v16[2](v16, v36);
          }
          if (v42) {
            sub_10004D2C8(v42);
          }
          goto LABEL_34;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    BOOL v33 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v34 = sub_1005628AC((int *)buf);
    v16[2](v16, v34);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v32 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Invalid completion block while sending device action", buf, 2u);
    }
  }
LABEL_34:
}

- (void)sendDeviceSettings:(id)a3 to:(id)a4 withMessageID:(id)a5 withSetting:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v13)
    {
      id v17 = [v13 uri];
      id v18 = v17;
      if (v14 && v17)
      {
        BOOL v19 = [v14 uuid];

        if (v15 && v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            [v12 slotID];
            uint64_t v21 = CTSubscriptionSlotAsString();
            id v22 = [v13 uri];
            uint64_t v23 = [v14 uuid];
            id v24 = [v15 type];
            *(_DWORD *)long long buf = 136315906;
            *(void *)&uint8_t buf[4] = v21;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v22;
            __int16 v46 = 2112;
            id v47 = v23;
            __int16 v48 = 2048;
            id v49 = v24;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendDeviceSettings [slot: %s, to: %@, identifier: %@, type: %ld]", buf, 0x2Au);
          }
          id v25 = [v12 slotID];
          if (v25 == (id)2) {
            uint64_t v26 = 2;
          }
          else {
            uint64_t v26 = v25 == (id)1;
          }
          uint64_t v43 = 0;
          __int16 v44 = 0;
          sub_1013FFAB8(&v43, self);
          if (v43)
          {
            id v27 = [v15 type];
            if (v27) {
              int v28 = -1;
            }
            else {
              int v28 = 0;
            }
            if (v27 == (id)1) {
              int v29 = 1;
            }
            else {
              int v29 = v28;
            }
            uint64_t v30 = v43;
            sub_1014010FC((uint64_t)buf, v13);
            id v31 = [v14 uuid];
            sub_100058DB0(__p, (char *)[v31 UTF8String]);
            int v39 = v29;
            uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **, int *))(*(void *)v30 + 264))(v30, v26, buf, __p, &v39);
            uint64_t v42 = v32;
            if (v41 < 0) {
              operator delete(__p[0]);
            }

            if (v53 < 0) {
              operator delete(v52);
            }
            if (v51[24])
            {
              __p[0] = v51;
              sub_100047F64((void ***)__p);
            }
            if (v50 < 0) {
              operator delete(v47);
            }
            if (SHIBYTE(v46) < 0) {
              operator delete(*(void **)buf);
            }
            if ((v32 & 0xFF00000000) != 0)
            {
              BOOL v33 = sub_1005628AC((int *)&v42);
              v16[2](v16, v33);
            }
            else
            {
              v16[2](v16, 0);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v37 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending device settings", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            char v38 = sub_1005628AC((int *)buf);
            v16[2](v16, v38);
          }
          if (v44) {
            sub_10004D2C8(v44);
          }
          goto LABEL_37;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    BOOL v35 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v36 = sub_1005628AC((int *)buf);
    v16[2](v16, v36);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v34 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Invalid completion block while sending device settings", buf, 2u);
    }
  }
LABEL_37:
}

- (void)sendResponseForSuggestedReply:(id)a3 to:(id)a4 withMessageID:(id)a5 response:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v13)
    {
      id v17 = [v13 uri];
      id v18 = v17;
      if (v14 && v17)
      {
        BOOL v19 = [v14 uuid];

        if (v15 && v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            [v12 slotID];
            uint64_t v21 = CTSubscriptionSlotAsString();
            __int16 v46 = [v13 uri];
            __int16 v44 = [v14 uuid];
            char v41 = [v15 displayText];
            if (v41)
            {
              uint64_t v42 = [v15 displayText];
            }
            else
            {
              uint64_t v42 = &stru_101AC1B28;
            }
            int v40 = [v15 inReplyToID];
            if (v40)
            {
              int v39 = [v15 inReplyToID];
              uint64_t v25 = [v39 uuid];
              if (v25)
              {
                char v38 = (void *)v25;
                uint64_t v37 = [v15 inReplyToID];
                uint64_t v26 = [v37 uuid];
                LODWORD(v25) = 1;
              }
              else
              {
                char v38 = 0;
                uint64_t v26 = &stru_101AC1B28;
              }
            }
            else
            {
              LODWORD(v25) = 0;
              uint64_t v26 = &stru_101AC1B28;
            }
            *(_DWORD *)long long buf = 136316163;
            *(void *)&uint8_t buf[4] = v21;
            *(_WORD *)&buf[12] = 2113;
            *(void *)&buf[14] = v46;
            __int16 v59 = 2114;
            char v60 = v44;
            __int16 v61 = 2113;
            __int16 v62 = v42;
            __int16 v63 = 2114;
            char v64 = v26;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendResponseForSuggestedReply [slot: %s, to: %{private}@, identifier: %{public}@, response.displayText: %{private}@, response.inReplyToID: %{public}@]", buf, 0x34u);
            if (v25)
            {
            }
            if (v40)
            {
            }
            if (v41) {
          }
            }
          id v27 = [v12 slotID];
          if (v27 == (id)2) {
            uint64_t v28 = 2;
          }
          else {
            uint64_t v28 = v27 == (id)1;
          }
          uint64_t v56 = 0;
          char v57 = 0;
          sub_1013FFAB8(&v56, self);
          uint64_t v29 = v56;
          if (v56)
          {
            sub_1014010FC((uint64_t)buf, v13);
            id v47 = [v14 uuid];
            sub_100058DB0(v54, (char *)[v47 UTF8String]);
            id v45 = [v15 displayText];
            sub_100058DB0(v48, (char *)[v45 UTF8String]);
            uint64_t v43 = [v15 postBackData];
            id v30 = [v43 data];
            sub_100058DB0(&v50, (char *)[v30 UTF8String]);
            id v31 = [v15 inReplyToID];
            id v32 = [v31 uuid];
            sub_100058DB0(&__p, (char *)[v32 UTF8String]);
            uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **, void **))(*(void *)v29 + 248))(v29, v28, buf, v54, v48);
            if (v53 < 0) {
              operator delete(__p);
            }
            if (v51 < 0) {
              operator delete(v50);
            }
            if (v49 < 0) {
              operator delete(v48[0]);
            }

            if (v55 < 0) {
              operator delete(v54[0]);
            }

            if (v67 < 0) {
              operator delete(v66);
            }
            if (v65[24])
            {
              v48[0] = v65;
              sub_100047F64((void ***)v48);
            }
            if (SBYTE3(v64) < 0) {
              operator delete(v60);
            }
            if (SHIBYTE(v59) < 0) {
              operator delete(*(void **)buf);
            }
            if ((v33 & 0xFF00000000) != 0)
            {
              *(_DWORD *)long long buf = v33;
              uint8_t buf[4] = 1;
              id v34 = sub_1005628AC((int *)buf);
              v16[2](v16, v34);
            }
            else
            {
              v16[2](v16, 0);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            BOOL v35 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending file transfer message", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            id v36 = sub_1005628AC((int *)buf);
            v16[2](v16, v36);
          }
          if (v57) {
            sub_10004D2C8(v57);
          }
          goto LABEL_16;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v23 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v24 = sub_1005628AC((int *)buf);
    v16[2](v16, v24);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion block while sending response for suggested reply message", buf, 2u);
    }
  }
LABEL_16:
}

- (void)sendResponseForSuggestedAction:(id)a3 to:(id)a4 withMessageID:(id)a5 response:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v13)
    {
      id v17 = [v13 uri];
      id v18 = v17;
      if (v14 && v17)
      {
        BOOL v19 = [v14 uuid];

        if (v15 && v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            [v12 slotID];
            uint64_t v21 = CTSubscriptionSlotAsString();
            __int16 v46 = [v13 uri];
            __int16 v44 = [v14 uuid];
            char v41 = [v15 displayText];
            if (v41)
            {
              uint64_t v42 = [v15 displayText];
            }
            else
            {
              uint64_t v42 = &stru_101AC1B28;
            }
            int v40 = [v15 inReplyToID];
            if (v40)
            {
              int v39 = [v15 inReplyToID];
              uint64_t v25 = [v39 uuid];
              if (v25)
              {
                char v38 = (void *)v25;
                uint64_t v37 = [v15 inReplyToID];
                uint64_t v26 = [v37 uuid];
                LODWORD(v25) = 1;
              }
              else
              {
                char v38 = 0;
                uint64_t v26 = &stru_101AC1B28;
              }
            }
            else
            {
              LODWORD(v25) = 0;
              uint64_t v26 = &stru_101AC1B28;
            }
            *(_DWORD *)long long buf = 136316163;
            *(void *)&uint8_t buf[4] = v21;
            *(_WORD *)&buf[12] = 2113;
            *(void *)&buf[14] = v46;
            __int16 v59 = 2114;
            char v60 = v44;
            __int16 v61 = 2113;
            __int16 v62 = v42;
            __int16 v63 = 2114;
            char v64 = v26;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendResponseForSuggestedAction [slot: %s, to: %{private}@, identifier: %{public}@, response.displayText: %{private}@, response.inReplyToID: %{public}@]", buf, 0x34u);
            if (v25)
            {
            }
            if (v40)
            {
            }
            if (v41) {
          }
            }
          id v27 = [v12 slotID];
          if (v27 == (id)2) {
            uint64_t v28 = 2;
          }
          else {
            uint64_t v28 = v27 == (id)1;
          }
          uint64_t v56 = 0;
          char v57 = 0;
          sub_1013FFAB8(&v56, self);
          uint64_t v29 = v56;
          if (v56)
          {
            sub_1014010FC((uint64_t)buf, v13);
            id v47 = [v14 uuid];
            sub_100058DB0(v54, (char *)[v47 UTF8String]);
            id v45 = [v15 displayText];
            sub_100058DB0(v48, (char *)[v45 UTF8String]);
            uint64_t v43 = [v15 postBackData];
            id v30 = [v43 data];
            sub_100058DB0(&v50, (char *)[v30 UTF8String]);
            id v31 = [v15 inReplyToID];
            id v32 = [v31 uuid];
            sub_100058DB0(&__p, (char *)[v32 UTF8String]);
            uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **, void **))(*(void *)v29 + 256))(v29, v28, buf, v54, v48);
            if (v53 < 0) {
              operator delete(__p);
            }
            if (v51 < 0) {
              operator delete(v50);
            }
            if (v49 < 0) {
              operator delete(v48[0]);
            }

            if (v55 < 0) {
              operator delete(v54[0]);
            }

            if (v67 < 0) {
              operator delete(v66);
            }
            if (v65[24])
            {
              v48[0] = v65;
              sub_100047F64((void ***)v48);
            }
            if (SBYTE3(v64) < 0) {
              operator delete(v60);
            }
            if (SHIBYTE(v59) < 0) {
              operator delete(*(void **)buf);
            }
            if ((v33 & 0xFF00000000) != 0)
            {
              *(_DWORD *)long long buf = v33;
              uint8_t buf[4] = 1;
              id v34 = sub_1005628AC((int *)buf);
              v16[2](v16, v34);
            }
            else
            {
              v16[2](v16, 0);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            BOOL v35 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending file transfer message", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            id v36 = sub_1005628AC((int *)buf);
            v16[2](v16, v36);
          }
          if (v57) {
            sub_10004D2C8(v57);
          }
          goto LABEL_16;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v23 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v24 = sub_1005628AC((int *)buf);
    v16[2](v16, v24);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion block while sending response for suggested action message", buf, 2u);
    }
  }
LABEL_16:
}

- (void)reportChatbotSpam:(id)a3 forChatbot:(id)a4 withSpamReportInfo:(id)a5 andOperationID:(id)a6 completion:(id)a7
{
  id v69 = a3;
  id v12 = a4;
  id v72 = a5;
  id v71 = a6;
  long long v73 = (void (**)(id, void *))a7;
  long long v70 = v12;
  if (v73)
  {
    if (v12)
    {
      uint64_t v13 = [v12 uri];
      id v14 = (void *)v13;
      if (v71)
      {
        if (v72)
        {
          if (v13)
          {
            id v15 = [v71 uuid];
            if (v15)
            {
              id v16 = [v72 chatbotUri];
              if (v16)
              {
                id v17 = [v72 messageIDList];
                if (v17)
                {
                  id v18 = [v72 messageIDList];
                  BOOL v19 = [v18 list];

                  if (v19)
                  {
                    uint64_t v20 = self;
                    [(CTXPCClientHandler *)self getLogContext];
                    uint64_t v21 = *(NSObject **)&buf[8];
                    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                    {
                      [v69 slotID];
                      uint64_t v22 = CTSubscriptionSlotAsString();
                      uint64_t v23 = [v12 uri];
                      id v24 = [v72 chatbotUri];
                      uint64_t v25 = [v72 messageIDList];
                      uint64_t v26 = [v25 list];
                      id v27 = [v26 count];
                      id v28 = [v72 spamType];
                      *(_DWORD *)long long buf = 136316163;
                      *(void *)&uint8_t buf[4] = v22;
                      *(_WORD *)&buf[12] = 2113;
                      *(void *)&buf[14] = v23;
                      *(_WORD *)&unsigned char buf[22] = 2113;
                      *(void *)&uint8_t buf[24] = v24;
                      *(_WORD *)&uint8_t buf[32] = 2048;
                      *(void *)&buf[34] = v27;
                      *(_WORD *)&buf[42] = 2048;
                      *(void *)&buf[44] = v28;
                      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] reportChatbotSpam: [slot: %s, to: %{private}@ spamReportInfo.uri: %{private}@, spamReportInfo.messageIDList.length: %ld, spamReportInfo.spamType: %ld]", buf, 0x34u);

                      uint64_t v20 = self;
                    }
                    id v29 = [v69 slotID];
                    if (v29 == (id)2) {
                      int v30 = 2;
                    }
                    else {
                      int v30 = v29 == (id)1;
                    }
                    uint64_t v87 = 0;
                    unint64_t v88 = 0;
                    sub_1013FFAB8(&v87, v20);
                    if (!v87)
                    {
                      [(CTXPCClientHandler *)v20 getLogContext];
                      char v60 = *(NSObject **)&buf[8];
                      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while reporting chatbot spam", buf, 2u);
                      }
                      *(_DWORD *)long long buf = 5;
                      uint8_t buf[4] = 1;
                      __int16 v61 = sub_1005628AC((int *)buf);
                      v73[2](v73, v61);

                      goto LABEL_85;
                    }
                    unsigned int v68 = v30;
                    id v31 = [v70 uri];
                    BOOL v32 = v31 == 0;

                    if (v32)
                    {
                      [(CTXPCClientHandler *)self getLogContext];
                      __int16 v62 = *(NSObject **)&buf[8];
                      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "No chatbot URI provided to report as spam", buf, 2u);
                      }
                    }
                    else
                    {
                      uint64_t v33 = [v72 messageIDList];
                      id v34 = [v33 list];
                      BOOL v35 = [v34 count] == 0;

                      if (!v35)
                      {
                        xpc_object_t v84 = 0;
                        uint64_t v85 = 0;
                        unint64_t v86 = 0;
                        long long v80 = 0u;
                        long long v81 = 0u;
                        long long v82 = 0u;
                        long long v83 = 0u;
                        id v36 = [v72 messageIDList];
                        uint64_t v37 = [v36 list];

                        id v38 = [v37 countByEnumeratingWithState:&v80 objects:v96 count:16];
                        if (v38)
                        {
                          uint64_t v39 = *(void *)v81;
                          do
                          {
                            for (uint64_t i = 0; i != v38; uint64_t i = (char *)i + 1)
                            {
                              if (*(void *)v81 != v39) {
                                objc_enumerationMutation(v37);
                              }
                              id v41 = [*(id *)(*((void *)&v80 + 1) + 8 * i) uuid];
                              sub_100058DB0(&__p, (char *)[v41 UTF8String]);
                              uint64_t v42 = v85;
                              if ((unint64_t)v85 >= v86)
                              {
                                unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((v85 - v84) >> 3);
                                unint64_t v45 = v44 + 1;
                                if (v44 + 1 > 0xAAAAAAAAAAAAAAALL) {
                                  sub_10006A748();
                                }
                                if (0x5555555555555556 * ((uint64_t)(v86 - (void)v84) >> 3) > v45) {
                                  unint64_t v45 = 0x5555555555555556 * ((uint64_t)(v86 - (void)v84) >> 3);
                                }
                                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v86 - (void)v84) >> 3) >= 0x555555555555555) {
                                  unint64_t v46 = 0xAAAAAAAAAAAAAAALL;
                                }
                                else {
                                  unint64_t v46 = v45;
                                }
                                *(void *)&uint8_t buf[32] = &v86;
                                if (v46) {
                                  id v47 = (char *)sub_10004812C((uint64_t)&v86, v46);
                                }
                                else {
                                  id v47 = 0;
                                }
                                __int16 v48 = &v47[24 * v44];
                                *(void *)long long buf = v47;
                                *(void *)&uint8_t buf[8] = v48;
                                *(void *)&uint8_t buf[24] = &v47[24 * v46];
                                long long v49 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                                *((void *)v48 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
                                *(_OWORD *)__int16 v48 = v49;
                                memset(&__p, 0, sizeof(__p));
                                *(void *)&uint8_t buf[16] = v48 + 24;
                                sub_10113D234((uint64_t *)&v84, buf);
                                char v50 = (long long *)v85;
                                sub_100048174((uint64_t)buf);
                                uint64_t v85 = (char *)v50;
                                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                                  operator delete(__p.__r_.__value_.__l.__data_);
                                }
                              }
                              else
                              {
                                long long v43 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                                *((void *)v85 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
                                *(_OWORD *)uint64_t v42 = v43;
                                memset(&__p, 0, sizeof(__p));
                                uint64_t v85 = v42 + 24;
                              }
                            }
                            id v38 = [v37 countByEnumeratingWithState:&v80 objects:v96 count:16];
                          }
                          while (v38);
                        }

                        memset(&__p, 0, sizeof(__p));
                        sub_100058DB0(&__p, "");
                        char v51 = [v72 freeBodyText];
                        BOOL v52 = v51 == 0;

                        if (!v52)
                        {
                          id v53 = [v72 freeBodyText];
                          sub_10003ED78(&__p, (char *)[v53 UTF8String]);
                        }
                        id v54 = [v72 spamType];
                        *(_OWORD *)xpc_object_t v94 = 0u;
                        long long v95 = 0u;
                        if ((unint64_t)v54 + 1 >= 4) {
                          int v55 = 3;
                        }
                        else {
                          int v55 = (int)v54;
                        }
                        long long v92 = 0uLL;
                        long long v93 = 0uLL;
                        long long v90 = 0uLL;
                        *(_OWORD *)xpc_object_t v91 = 0uLL;
                        memset(buf, 0, sizeof(buf));
                        buf[0] = 1;
                        id v56 = [v70 uri];
                        sub_100058DB0(&buf[8], (char *)[v56 UTF8String]);
                        uint8_t buf[32] = 0;
                        buf[56] = 0;
                        v91[0] = 0;
                        long long v90 = 0uLL;
                        sub_1004540CC((char *)&v90, (long long *)v84, (long long *)v85, 0xAAAAAAAAAAAAAAABLL * ((v85 - v84) >> 3));
                        LOBYTE(v91[1]) = 0;
                        LOBYTE(v93) = 0;
                        DWORD2(v93) = v55;
                        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                        {
                          sub_10004FC84(v94, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
                        }
                        else
                        {
                          *(_OWORD *)xpc_object_t v94 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                          *(void *)&long long v95 = *((void *)&__p.__r_.__value_.__l + 2);
                        }
                        BYTE8(v95) = 1;

                        v77[0] = 0;
                        v77[1] = 0;
                        uint64_t v78 = 0;
                        id v65 = [v71 uuid];
                        sub_100058DB0(v77, (char *)[v65 UTF8String]);

                        uint64_t v76 = 0;
                        uint64_t v76 = (*(uint64_t (**)(uint64_t, void, uint8_t *, void **))(*(void *)v87 + 112))(v87, v68, buf, v77);
                        if ((v76 & 0xFF00000000) != 0)
                        {
                          [(CTXPCClientHandler *)self getLogContext];
                          long long v66 = v75;
                          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v74);
                          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
                          {
                            *(_WORD *)long long v74 = 0;
                            _os_log_error_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "Got error from LazuliManager", v74, 2u);
                          }
                          char v67 = sub_1005628AC((int *)&v76);
                          v73[2](v73, v67);
                        }
                        else
                        {
                          v73[2](v73, 0);
                        }
                        if (SHIBYTE(v78) < 0) {
                          operator delete(v77[0]);
                        }
                        if (BYTE8(v95) && SBYTE7(v95) < 0) {
                          operator delete(v94[0]);
                        }
                        if ((_BYTE)v93 && SHIBYTE(v92) < 0) {
                          operator delete(v91[1]);
                        }
                        v77[0] = &v90;
                        sub_100047F64((void ***)v77);
                        if (buf[56] && (char)buf[55] < 0) {
                          operator delete(*(void **)&buf[32]);
                        }
                        if ((char)buf[31] < 0) {
                          operator delete(*(void **)&buf[8]);
                        }
                        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__p.__r_.__value_.__l.__data_);
                        }
                        *(void *)long long buf = &v84;
                        sub_100047F64((void ***)buf);
                        goto LABEL_85;
                      }
                      [(CTXPCClientHandler *)self getLogContext];
                      char v64 = *(NSObject **)&buf[8];
                      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "No message ID provided to report as spam", buf, 2u);
                      }
                    }
                    *(_DWORD *)long long buf = -1;
                    uint8_t buf[4] = 1;
                    __int16 v63 = sub_1005628AC((int *)buf);
                    v73[2](v73, v63);

LABEL_85:
                    if (v88) {
                      sub_10004D2C8(v88);
                    }
                    goto LABEL_53;
                  }
                  goto LABEL_50;
                }
              }
            }
          }
        }
      }
    }
LABEL_50:
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v58 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    __int16 v59 = sub_1005628AC((int *)buf);
    v73[2](v73, v59);

    goto LABEL_53;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v57 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_INFO, "Invalid completion block while reporting chatbot spam", buf, 2u);
  }
LABEL_53:
}

- (void)reportLazuliSpamWithContext:(id)a3 destination:(id)a4 spamReportInfo:(id)a5 operationID:(id)a6 completion:(id)a7
{
  id v73 = a3;
  id v12 = a4;
  id v76 = a5;
  id v75 = a6;
  long long v77 = (void (**)(id, void *))a7;
  long long v74 = v12;
  if (v77)
  {
    id v72 = self;
    if (v12)
    {
      uint64_t v13 = [v12 uri];
      id v14 = (void *)v13;
      if (v75)
      {
        if (v76)
        {
          if (v13)
          {
            id v15 = [v75 uuid];
            if (v15)
            {
              id v16 = [v76 destinationUri];
              if (v16)
              {
                id v17 = [v76 messageIDList];
                if (v17)
                {
                  id v18 = [v76 messageIDList];
                  BOOL v19 = [v18 list];

                  if (v19)
                  {
                    uint64_t v20 = self;
                    [(CTXPCClientHandler *)self getLogContext];
                    uint64_t v21 = *(NSObject **)&buf[8];
                    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                    {
                      [v73 slotID];
                      uint64_t v22 = CTSubscriptionSlotAsString();
                      uint64_t v23 = [v12 uri];
                      id v24 = [v76 destinationUri];
                      uint64_t v25 = [v76 messageIDList];
                      uint64_t v26 = [v25 list];
                      id v27 = [v26 count];
                      id v28 = [v76 spamType];
                      *(_DWORD *)long long buf = 136316163;
                      *(void *)&uint8_t buf[4] = v22;
                      *(_WORD *)&buf[12] = 2113;
                      *(void *)&buf[14] = v23;
                      *(_WORD *)&unsigned char buf[22] = 2113;
                      *(void *)&uint8_t buf[24] = v24;
                      *(_WORD *)&uint8_t buf[32] = 2048;
                      *(void *)&buf[34] = v27;
                      *(_WORD *)&buf[42] = 2048;
                      *(void *)&buf[44] = v28;
                      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] reportSpam: [slot: %s, to: %{private}@ spamReportInfo.uri: %{private}@, spamReportInfo.messageIDList.length: %ld, spamReportInfo.spamType: %ld]", buf, 0x34u);

                      uint64_t v20 = self;
                    }
                    id v29 = [v73 slotID];
                    if (v29 == (id)2) {
                      int v30 = 2;
                    }
                    else {
                      int v30 = v29 == (id)1;
                    }
                    uint64_t v92 = 0;
                    long long v93 = 0;
                    sub_1013FFAB8(&v92, v20);
                    if (!v92)
                    {
                      [(CTXPCClientHandler *)v20 getLogContext];
                      __int16 v63 = *(NSObject **)&buf[8];
                      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while reporting chatbot spam", buf, 2u);
                      }
                      *(_DWORD *)long long buf = 5;
                      uint8_t buf[4] = 1;
                      char v64 = sub_1005628AC((int *)buf);
                      v77[2](v77, v64);

                      goto LABEL_92;
                    }
                    unsigned int v71 = v30;
                    id v31 = [v74 uri];
                    BOOL v32 = v31 == 0;

                    if (v32)
                    {
                      [(CTXPCClientHandler *)self getLogContext];
                      id v65 = *(NSObject **)&buf[8];
                      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "No destination URI provided to report as spam", buf, 2u);
                      }
                    }
                    else
                    {
                      uint64_t v33 = [v76 messageIDList];
                      id v34 = [v33 list];
                      BOOL v35 = [v34 count] == 0;

                      if (!v35)
                      {
                        unint64_t v89 = 0;
                        long long v90 = 0;
                        unint64_t v91 = 0;
                        long long v85 = 0u;
                        long long v86 = 0u;
                        long long v87 = 0u;
                        long long v88 = 0u;
                        id v36 = [v76 messageIDList];
                        uint64_t v37 = [v36 list];

                        id v38 = [v37 countByEnumeratingWithState:&v85 objects:v99 count:16];
                        if (v38)
                        {
                          uint64_t v39 = *(void *)v86;
                          do
                          {
                            for (uint64_t i = 0; i != v38; uint64_t i = (char *)i + 1)
                            {
                              if (*(void *)v86 != v39) {
                                objc_enumerationMutation(v37);
                              }
                              id v41 = [*(id *)(*((void *)&v85 + 1) + 8 * i) uuid];
                              sub_100058DB0(&__p, (char *)[v41 UTF8String]);
                              uint64_t v42 = v90;
                              if ((unint64_t)v90 >= v91)
                              {
                                unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((v90 - v89) >> 3);
                                unint64_t v45 = v44 + 1;
                                if (v44 + 1 > 0xAAAAAAAAAAAAAAALL) {
                                  sub_10006A748();
                                }
                                if (0x5555555555555556 * ((uint64_t)(v91 - (void)v89) >> 3) > v45) {
                                  unint64_t v45 = 0x5555555555555556 * ((uint64_t)(v91 - (void)v89) >> 3);
                                }
                                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v91 - (void)v89) >> 3) >= 0x555555555555555) {
                                  unint64_t v46 = 0xAAAAAAAAAAAAAAALL;
                                }
                                else {
                                  unint64_t v46 = v45;
                                }
                                *(void *)&uint8_t buf[32] = &v91;
                                if (v46) {
                                  id v47 = (char *)sub_10004812C((uint64_t)&v91, v46);
                                }
                                else {
                                  id v47 = 0;
                                }
                                __int16 v48 = &v47[24 * v44];
                                *(void *)long long buf = v47;
                                *(void *)&uint8_t buf[8] = v48;
                                *(void *)&uint8_t buf[24] = &v47[24 * v46];
                                long long v49 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                                *((void *)v48 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
                                *(_OWORD *)__int16 v48 = v49;
                                memset(&__p, 0, sizeof(__p));
                                *(void *)&uint8_t buf[16] = v48 + 24;
                                sub_10113D234((uint64_t *)&v89, buf);
                                char v50 = (long long *)v90;
                                sub_100048174((uint64_t)buf);
                                long long v90 = (char *)v50;
                                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                                  operator delete(__p.__r_.__value_.__l.__data_);
                                }
                              }
                              else
                              {
                                long long v43 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                                *((void *)v90 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
                                *(_OWORD *)uint64_t v42 = v43;
                                memset(&__p, 0, sizeof(__p));
                                long long v90 = v42 + 24;
                              }
                            }
                            id v38 = [v37 countByEnumeratingWithState:&v85 objects:v99 count:16];
                          }
                          while (v38);
                        }

                        memset(&__p, 0, sizeof(__p));
                        sub_100058DB0(&__p, "");
                        char v51 = [v76 content];
                        BOOL v52 = v51 == 0;

                        if (!v52)
                        {
                          id v53 = [v76 content];
                          sub_10003ED78(&__p, (char *)[v53 UTF8String]);
                        }
                        memset(&v83, 0, sizeof(v83));
                        sub_100058DB0(&v83, "");
                        id v54 = [v76 freeBodyText];
                        BOOL v55 = v54 == 0;

                        if (!v55)
                        {
                          id v56 = [v76 freeBodyText];
                          sub_10003ED78(&v83, (char *)[v56 UTF8String]);
                        }
                        id v57 = [v76 spamType];
                        *(_OWORD *)xpc_object_t v97 = 0u;
                        long long v98 = 0u;
                        if ((unint64_t)v57 + 1 >= 4) {
                          int v58 = 3;
                        }
                        else {
                          int v58 = (int)v57;
                        }
                        long long v96 = 0uLL;
                        memset(v95, 0, sizeof(v95));
                        memset(buf, 0, sizeof(buf));
                        buf[0] = [v76 isChatbot];
                        id v59 = [v74 uri];
                        sub_100058DB0(&buf[8], (char *)[v59 UTF8String]);
                        uint8_t buf[32] = 0;
                        buf[56] = 0;
                        memset(v95, 0, 24);
                        sub_1004540CC((char *)v95, (long long *)v89, (long long *)v90, 0xAAAAAAAAAAAAAAABLL * ((v90 - v89) >> 3));
                        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                          sub_10004FC84(&v95[1], __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
                        }
                        else {
                          v95[1] = __p;
                        }
                        LOBYTE(v96) = 1;
                        DWORD2(v96) = v58;
                        if (SHIBYTE(v83.__r_.__value_.__r.__words[2]) < 0)
                        {
                          sub_10004FC84(v97, v83.__r_.__value_.__l.__data_, v83.__r_.__value_.__l.__size_);
                        }
                        else
                        {
                          *(_OWORD *)xpc_object_t v97 = *(_OWORD *)&v83.__r_.__value_.__l.__data_;
                          *(void *)&long long v98 = *((void *)&v83.__r_.__value_.__l + 2);
                        }
                        BYTE8(v98) = 1;

                        v81[0] = 0;
                        v81[1] = 0;
                        uint64_t v82 = 0;
                        id v68 = [v75 uuid];
                        sub_100058DB0(v81, (char *)[v68 UTF8String]);

                        uint64_t v80 = 0;
                        uint64_t v80 = (*(uint64_t (**)(uint64_t, void, uint8_t *, void **))(*(void *)v92 + 112))(v92, v71, buf, v81);
                        if ((v80 & 0xFF00000000) != 0)
                        {
                          [(CTXPCClientHandler *)v72 getLogContext];
                          id v69 = v79;
                          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v78);
                          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                          {
                            *(_WORD *)uint64_t v78 = 0;
                            _os_log_error_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "Got error from LazuliManager", v78, 2u);
                          }
                          long long v70 = sub_1005628AC((int *)&v80);
                          v77[2](v77, v70);
                        }
                        else
                        {
                          v77[2](v77, 0);
                        }
                        if (SHIBYTE(v82) < 0) {
                          operator delete(v81[0]);
                        }
                        if (BYTE8(v98) && SBYTE7(v98) < 0) {
                          operator delete(v97[0]);
                        }
                        if ((_BYTE)v96 && SHIBYTE(v95[1].__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v95[1].__r_.__value_.__l.__data_);
                        }
                        v81[0] = v95;
                        sub_100047F64((void ***)v81);
                        if (buf[56] && (char)buf[55] < 0) {
                          operator delete(*(void **)&buf[32]);
                        }
                        if ((char)buf[31] < 0) {
                          operator delete(*(void **)&buf[8]);
                        }
                        if (SHIBYTE(v83.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v83.__r_.__value_.__l.__data_);
                        }
                        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(__p.__r_.__value_.__l.__data_);
                        }
                        *(void *)long long buf = &v89;
                        sub_100047F64((void ***)buf);
                        goto LABEL_92;
                      }
                      [(CTXPCClientHandler *)self getLogContext];
                      char v67 = *(NSObject **)&buf[8];
                      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                      if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                      {
                        *(_WORD *)long long buf = 0;
                        _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "No message ID provided to report as spam", buf, 2u);
                      }
                    }
                    *(_DWORD *)long long buf = -1;
                    uint8_t buf[4] = 1;
                    long long v66 = sub_1005628AC((int *)buf);
                    v77[2](v77, v66);

LABEL_92:
                    if (v93) {
                      sub_10004D2C8(v93);
                    }
                    goto LABEL_55;
                  }
                  goto LABEL_52;
                }
              }
            }
          }
        }
      }
    }
LABEL_52:
    [(CTXPCClientHandler *)self getLogContext];
    __int16 v61 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    __int16 v62 = sub_1005628AC((int *)buf);
    v77[2](v77, v62);

    goto LABEL_55;
  }
  [(CTXPCClientHandler *)self getLogContext];
  char v60 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_INFO, "Invalid completion block while reporting chatbot spam", buf, 2u);
  }
LABEL_55:
}

- (void)decodeSuggestionsBase64:(id)a3 withBase64String:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, void, id))a5;
  if (v10)
  {
    if (v8
      && v9
      && ([v9 base64String], id v11 = objc_claimAutoreleasedReturnValue(), v11, v11))
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v12 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        [v8 slotID];
        uint64_t v13 = CTSubscriptionSlotAsString();
        id v14 = [v9 base64String];
        *(_DWORD *)long long buf = 136315651;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        *(_WORD *)&unsigned char buf[22] = 2117;
        *(void *)&uint8_t buf[24] = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] decodeSuggestionsBase64: [slot: %s, link: %{sensitive, mask.hash}@]", buf, 0x20u);
      }
      id v15 = [v8 slotID];
      if (v15 == (id)2) {
        uint64_t v16 = 2;
      }
      else {
        uint64_t v16 = v15 == (id)1;
      }
      uint64_t v29 = 0;
      int v30 = 0;
      sub_1013FFAB8(&v29, self);
      uint64_t v17 = v29;
      if (v29)
      {
        uint64_t v32 = 0;
        memset(buf, 0, sizeof(buf));
        id v18 = [v9 base64String];
        sub_100058DB0(__p, (char *)[v18 UTF8String]);
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, void **))(*(void *)v17 + 152))(buf, v17, v16, __p);
        if (v28 < 0) {
          operator delete(__p[0]);
        }

        if ((_BYTE)v32)
        {
          id v19 = objc_alloc((Class)CTLazuliDeepLinkBase64StringDecoded);
          if (!(_BYTE)v32) {
            sub_10016C840();
          }
          id v20 = [v19 initWithReflection:buf];
          v10[2](v10, 0, v20);
        }
        else
        {
          LODWORD(__p[0]) = 6;
          BYTE4(__p[0]) = 1;
          uint64_t v26 = sub_1005628AC((int *)__p);
          ((void (**)(id, void *, id))v10)[2](v10, v26, 0);
        }
        if ((_BYTE)v32 && buf[24])
        {
          __p[0] = buf;
          sub_100155494((void ***)__p);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v24 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending file transfer message", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        uint64_t v25 = sub_1005628AC((int *)buf);
        ((void (**)(id, void *, id))v10)[2](v10, v25, 0);
      }
      if (v30) {
        sub_10004D2C8(v30);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v21 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      uint64_t v22 = sub_1005628AC((int *)buf);
      ((void (**)(id, void *, id))v10)[2](v10, v22, 0);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v23 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid completion block while decoding deep link", buf, 2u);
    }
  }
}

- (void)sendTextMessage:(id)a3 toGroupDestination:(id)a4 withMessageID:(id)a5 withMessage:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  uint64_t v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12 && v13 && v14)
    {
      uint64_t v17 = [v14 uuid];
      id v18 = v17;
      if (v15 && v17)
      {
        id v19 = [v15 content];

        if (v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            [v12 slotID];
            uint64_t v21 = CTSubscriptionSlotAsString();
            BOOL v35 = [v13 focus];
            uint64_t v37 = [v13 conversationID];
            uint64_t v22 = [v14 uuid];
            uint64_t v23 = [v15 content];
            *(_DWORD *)long long buf = 136316419;
            *(void *)&uint8_t buf[4] = v21;
            *(_WORD *)&buf[12] = 2113;
            *(void *)&buf[14] = v35;
            __int16 v51 = 2114;
            BOOL v52 = v37;
            __int16 v53 = 2114;
            id v54 = v22;
            __int16 v55 = 2160;
            uint64_t v56 = 1752392040;
            __int16 v57 = 2117;
            v58[0] = v23;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendTextMessage: [slot: %s, to.focus: %{private}@, to.conversationID: %{public}@, messageIdentifier: %{public}@, message: %{sensitive, mask.hash}@]", buf, 0x3Eu);
          }
          id v24 = [v12 slotID];
          if (v24 == (id)2) {
            uint64_t v25 = 2;
          }
          else {
            uint64_t v25 = v24 == (id)1;
          }
          uint64_t v47 = 0;
          __int16 v48 = 0;
          sub_1013FFAB8(&v47, self);
          uint64_t v26 = v47;
          if (v47)
          {
            sub_10140BA5C((uint64_t)v41, v13);
            id v38 = [v14 uuid];
            sub_100058DB0(__p, (char *)[v38 UTF8String]);
            id v36 = [v15 content];
            sub_100058DB0(buf, (char *)[v36 UTF8String]);
            LOBYTE(v52) = 0;
            BYTE4(v56) = 0;
            id v27 = [v15 metaData];
            sub_1014056B0((uint64_t)v58 + 2, v27);
            uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void **, void **, unsigned char *))(*(void *)v26 + 288))(v26, v25, v41, __p, buf);
            if (v59)
            {
              long long v49 = (void **)((char *)v58 + 2);
              sub_100155410(&v49);
            }
            if (BYTE4(v56))
            {
              long long v49 = &v52;
              sub_100155494(&v49);
            }
            if (SHIBYTE(v51) < 0) {
              operator delete(*(void **)buf);
            }

            if (v40 < 0) {
              operator delete(__p[0]);
            }

            if (v46 < 0) {
              operator delete(v45);
            }
            if (v44 < 0) {
              operator delete(v43);
            }
            if (v42 < 0) {
              operator delete(v41[0]);
            }
            if ((v28 & 0xFF00000000) != 0)
            {
              *(_DWORD *)long long buf = v28;
              uint8_t buf[4] = 1;
              uint64_t v29 = sub_1005628AC((int *)buf);
              v16[2](v16, v29);
            }
            else
            {
              v16[2](v16, 0);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v33 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while sending file transfer message", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            id v34 = sub_1005628AC((int *)buf);
            v16[2](v16, v34);
          }
          if (v48) {
            sub_10004D2C8(v48);
          }
          goto LABEL_36;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v31 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    uint64_t v32 = sub_1005628AC((int *)buf);
    v16[2](v16, v32);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    int v30 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Invalid completion block while sending text message to group chat", buf, 2u);
    }
  }
LABEL_36:
}

- (void)sendGroupComposingIndicator:(id)a3 toGroupDestination:(id)a4 withMessageID:(id)a5 withIndication:(id)a6 completion:(id)a7
{
  id v13 = a3;
  id v14 = a4;
  id v15 = a5;
  id v16 = a6;
  uint64_t v17 = (void (**)(id, void *))a7;
  if (v17)
  {
    if (v13
      && v14
      && v15
      && ([v15 uuid], id v18 = objc_claimAutoreleasedReturnValue(), v18, v16)
      && v18)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v19 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        [v13 slotID];
        uint64_t v40 = CTSubscriptionSlotAsString();
        long long v43 = [v14 focus];
        if (v43)
        {
          char v42 = [v14 focus];
        }
        else
        {
          char v42 = &stru_101AC1B28;
        }
        char v44 = [v14 conversationID];
        if (v44)
        {
          id v41 = [v14 conversationID];
        }
        else
        {
          id v41 = &stru_101AC1B28;
        }
        unint64_t v45 = [v15 uuid];
        char v46 = [v16 refreshTime];
        if (v46)
        {
          id v38 = [v16 refreshTime];
          uint64_t v39 = (uint64_t)[v38 longValue];
        }
        else
        {
          uint64_t v39 = -1;
        }
        unsigned int v23 = [v16 active];
        id v24 = [v16 lastActive];
        if (v24)
        {
          id v7 = [v16 lastActive];
          uint64_t v25 = (const char *)[v7 UTF8String];
        }
        else
        {
          uint64_t v25 = "";
        }
        *(_DWORD *)long long buf = 136316675;
        *(void *)&uint8_t buf[4] = v40;
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v42;
        *(_WORD *)&unsigned char buf[22] = 2114;
        *(void *)&uint8_t buf[24] = v41;
        *(_WORD *)char v59 = 2113;
        *(void *)&v59[2] = v45;
        *(_WORD *)&v59[10] = 2048;
        *(void *)&v59[12] = v39;
        *(_WORD *)&v59[20] = 1024;
        *(_DWORD *)&v59[22] = v23;
        *(_WORD *)&v59[26] = 2081;
        *(void *)&v59[28] = v25;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendGroupComposingIndicator: [slot: %s, to.focus: %{public}@, to.conversationID: %{public}@, messageIdentifier: %{private}@, ind.refreshTime: %ld, ind.active: %d, ind.lastActive: %{private}s]", buf, 0x44u);
        if (v24) {

        }
        if (v46) {
        if (v44)
        }

        if (v43) {
      }
        }
      uint64_t v56 = 0;
      __int16 v57 = 0;
      sub_1013FFAB8(&v56, self);
      if (v56)
      {
        id v26 = [v13 slotID];
        uint64_t v60 = 0;
        memset(&v59[16], 0, 32);
        if (v26 == (id)2) {
          uint64_t v27 = 2;
        }
        else {
          uint64_t v27 = v26 == (id)1;
        }
        *(_OWORD *)char v59 = 0uLL;
        memset(buf, 0, sizeof(buf));
        uint64_t v28 = [v16 refreshTime];
        *(void *)long long buf = [v28 longValue];
        uint8_t buf[8] = 1;
        uint8_t buf[16] = [v16 active];
        id v29 = [v16 lastActive];
        sub_100058DB0(&buf[24], (char *)[v29 UTF8String]);
        v59[16] = 1;
        id v30 = [v16 contentType];
        sub_100058DB0(&v59[24], (char *)[v30 UTF8String]);
        LOBYTE(v60) = 1;

        uint64_t v31 = v56;
        sub_10140BA5C((uint64_t)v49, v14);
        id v32 = [v15 uuid];
        sub_100058DB0(__p, (char *)[v32 UTF8String]);
        uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, uint8_t *, void **, uint8_t *))(*(void *)v31 + 280))(v31, v27, v49, __p, buf);
        if (v48 < 0) {
          operator delete(__p[0]);
        }

        if (v55 < 0) {
          operator delete(v54);
        }
        if (v53 < 0) {
          operator delete(v52);
        }
        if (v51 < 0) {
          operator delete(*(void **)v49);
        }
        if ((v33 & 0xFF00000000) != 0)
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v34 = v50;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v49);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long v49 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Sending of sendComposingIndicator indicator failed...", v49, 2u);
          }
          *(_DWORD *)long long v49 = v33;
          v49[4] = 1;
          BOOL v35 = sub_1005628AC((int *)v49);
          v17[2](v17, v35);
        }
        else
        {
          v17[2](v17, 0);
        }
        if ((_BYTE)v60 && (v59[47] & 0x80000000) != 0) {
          operator delete(*(void **)&v59[24]);
        }
        if (v59[16] && (v59[15] & 0x80000000) != 0) {
          operator delete(*(void **)&buf[24]);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v36 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        uint64_t v37 = sub_1005628AC((int *)buf);
        v17[2](v17, v37);
      }
      if (v57) {
        sub_10004D2C8(v57);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v20 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      uint64_t v21 = sub_1005628AC((int *)buf);
      v17[2](v17, v21);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion block while sending group composing indicator message", buf, 2u);
    }
  }
}

- (void)sendGroupComposingIndicator:(id)a3 toGroup:(id)a4 withMessageID:(id)a5 withIndication:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v17 = v23;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendGroupComposingIndicator", (uint8_t *)&v21, 2u);
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v18 = v23;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid API use", (uint8_t *)&v21, 2u);
    }
    int v21 = 5;
    char v22 = 1;
    id v19 = sub_1005628AC(&v21);
    v16[2](v16, v19);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v20 = v23;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid completion block while sending composing indicator to group chat", (uint8_t *)&v21, 2u);
    }
  }
}

- (void)sendGeolocationMessage:(id)a3 toGroupDestination:(id)a4 withMessageID:(id)a5 withGeoPush:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12
      && v13
      && v14
      && ([v14 uuid], uint64_t v17 = objc_claimAutoreleasedReturnValue(), v17, v15)
      && v17)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v18 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        [v12 slotID];
        uint64_t v51 = CTSubscriptionSlotAsString();
        char v55 = [v13 focus];
        if (v55)
        {
          id v54 = [v13 focus];
        }
        else
        {
          id v54 = &stru_101AC1B28;
        }
        BOOL v52 = [v13 conversationID];
        if (v52)
        {
          char v53 = [v13 conversationID];
        }
        else
        {
          char v53 = &stru_101AC1B28;
        }
        char v59 = [v14 uuid];
        [v15 coordinates];
        v57 = uint64_t v22 = 0x406FE00000000000;
        if (v57)
        {
          uint64_t v47 = [v15 coordinates];
          long long v49 = [v47 latitude];
          if (v49)
          {
            char v44 = [v15 coordinates];
            char v48 = [v44 latitude];
            [v48 doubleValue];
            uint64_t v22 = v23;
            int v50 = 1;
          }
          else
          {
            long long v49 = 0;
            int v50 = 0;
          }
        }
        else
        {
          int v50 = 0;
        }
        id v24 = [v15 coordinates];
        uint64_t v25 = 0x406FE00000000000;
        if (v24)
        {
          char v46 = [v15 coordinates];
          uint64_t v26 = [v46 longitude];
          if (v26)
          {
            unint64_t v45 = (void *)v26;
            long long v43 = [v15 coordinates];
            char v42 = [v43 longitude];
            [v42 doubleValue];
            uint64_t v25 = v27;
            LODWORD(v26) = 1;
          }
          else
          {
            unint64_t v45 = 0;
          }
        }
        else
        {
          LODWORD(v26) = 0;
        }
        *(_DWORD *)long long buf = 136316418;
        *(void *)&uint8_t buf[4] = v51;
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v54;
        *(_WORD *)&unsigned char buf[22] = 2114;
        *(void *)&uint8_t buf[24] = v53;
        *(_WORD *)&uint8_t buf[32] = 2114;
        *(void *)&buf[34] = v59;
        *(_WORD *)&buf[42] = 2048;
        *(void *)&buf[44] = v22;
        *(_WORD *)&buf[52] = 2048;
        *(void *)&buf[54] = v25;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendGeolocationMessage: [slot: %s, to.focus: %{public}@, to.conversationID: %{public}@, messageIdentifier: %{public}@, .latitude: %{senstive}f, .longitude: %{senstive}f]", buf, 0x3Eu);
        if (v26)
        {
        }
        if (v24)
        {
        }
        if (v50)
        {
        }
        if (v57)
        {
        }
        if (v52) {

        }
        if (v55) {
      }
        }
      uint64_t v70 = 0;
      unsigned int v71 = 0;
      sub_1013FFAB8(&v70, self);
      if (v70)
      {
        id v28 = [v12 slotID];
        int v29 = v28 == (id)1;
        long long v74 = 0u;
        long long v75 = 0u;
        if (v28 == (id)2) {
          int v29 = 2;
        }
        unsigned int v56 = v29;
        long long v73 = 0uLL;
        memset(buf, 0, sizeof(buf));
        int v58 = [v15 coordinates];
        uint64_t v60 = [v58 longitude];
        [v60 doubleValue];
        *(void *)long long buf = v30;
        uint64_t v31 = [v15 coordinates];
        id v32 = [v31 latitude];
        [v32 doubleValue];
        *(void *)&uint8_t buf[8] = v33;
        uint8_t buf[16] = 0;
        uint8_t buf[40] = 0;
        buf[48] = 0;
        BYTE8(v73) = 0;
        id v34 = [v15 metaData];
        sub_1014056B0((uint64_t)&v74, v34);

        uint64_t v35 = v70;
        sub_10140BA5C((uint64_t)v63, v13);
        id v36 = [v14 uuid];
        sub_100058DB0(__p, (char *)[v36 UTF8String]);
        uint64_t v37 = (*(uint64_t (**)(uint64_t, void, uint8_t *, void **, uint8_t *))(*(void *)v35 + 296))(v35, v56, v63, __p, buf);
        if (v62 < 0) {
          operator delete(__p[0]);
        }

        if (v69 < 0) {
          operator delete(v68);
        }
        if (v67 < 0) {
          operator delete(v66);
        }
        if (v65 < 0) {
          operator delete(*(void **)v63);
        }
        if ((v37 & 0xFF00000000) != 0)
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v38 = v64;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v63);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__int16 v63 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Sending of Geolocation push failed...", v63, 2u);
          }
          *(_DWORD *)__int16 v63 = v37;
          v63[4] = 1;
          uint64_t v39 = sub_1005628AC((int *)v63);
          v16[2](v16, v39);
        }
        else
        {
          v16[2](v16, 0);
        }
        if (BYTE8(v75))
        {
          *(void *)__int16 v63 = &v74;
          sub_100155410((void ***)v63);
        }
        if (BYTE8(v73))
        {
          *(void *)__int16 v63 = &buf[48];
          sub_100155494((void ***)v63);
        }
        if (buf[40] && (char)buf[39] < 0) {
          operator delete(*(void **)&buf[16]);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v40 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        id v41 = sub_1005628AC((int *)buf);
        v16[2](v16, v41);
      }
      if (v71) {
        sub_10004D2C8(v71);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v19 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      id v20 = sub_1005628AC((int *)buf);
      v16[2](v16, v20);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    int v21 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion block while sending geolocation message to group chat", buf, 2u);
    }
  }
}

- (void)sendFileTransferMessage:(id)a3 toGroupDestination:(id)a4 withMessageID:(id)a5 withFileInformation:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12
      && v13
      && v14
      && ([v14 uuid], uint64_t v17 = objc_claimAutoreleasedReturnValue(), v17, v15)
      && v17)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v18 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        [v12 slotID];
        uint64_t v34 = CTSubscriptionSlotAsString();
        uint64_t v37 = [v13 focus];
        if (v37)
        {
          id v36 = [v13 focus];
        }
        else
        {
          id v36 = &stru_101AC1B28;
        }
        uint64_t v22 = [v13 conversationID];
        if (v22)
        {
          uint64_t v35 = [v13 conversationID];
        }
        else
        {
          uint64_t v35 = &stru_101AC1B28;
        }
        uint64_t v23 = [v14 uuid];
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = v34;
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v36;
        __int16 v59 = 2114;
        uint64_t v60 = v35;
        __int16 v61 = 2114;
        char v62 = v23;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendFileTransferMessage: [slot: %s, to.focus: %{public}@, to.conversationID: %{public}@, identifier: %{public}@]", buf, 0x2Au);

        if (v22) {
        if (v37)
        }
      }
      uint64_t v56 = 0;
      __int16 v57 = 0;
      sub_1013FFAB8(&v56, self);
      if (v56)
      {
        id v24 = [v12 slotID];
        uint64_t v55 = 0;
        memset(v54, 0, sizeof(v54));
        if (v24 == (id)2) {
          uint64_t v25 = 2;
        }
        else {
          uint64_t v25 = v24 == (id)1;
        }
        long long v52 = 0uLL;
        long long v53 = 0uLL;
        *(_OWORD *)int v50 = 0uLL;
        *(_OWORD *)uint64_t v51 = 0uLL;
        *(_OWORD *)char v48 = 0uLL;
        long long v49 = 0uLL;
        *(_OWORD *)uint64_t v47 = 0uLL;
        memset(v46, 0, sizeof(v46));
        sub_101405064((uint64_t)v46, v15);
        uint64_t v26 = v56;
        sub_10140BA5C((uint64_t)v40, v13);
        id v27 = [v14 uuid];
        sub_100058DB0(__p, (char *)[v27 UTF8String]);
        sub_10045449C(buf, (uint64_t)v46);
        char v63 = 0;
        char v64 = 0;
        id v28 = [v15 metaData];
        sub_1014056B0((uint64_t)&v65, v28);
        uint64_t v29 = (*(uint64_t (**)(uint64_t, uint64_t, void **, void **, unsigned char *))(*(void *)v26 + 304))(v26, v25, v40, __p, buf);
        sub_100454840((uint64_t)buf);

        if (v39 < 0) {
          operator delete(__p[0]);
        }

        if (v45 < 0) {
          operator delete(v44);
        }
        if (v43 < 0) {
          operator delete(v42);
        }
        if (v41 < 0) {
          operator delete(v40[0]);
        }
        if ((v29 & 0xFF00000000) != 0)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v30 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Sending of group file transfer failed...", buf, 2u);
          }
          *(_DWORD *)long long buf = v29;
          uint8_t buf[4] = 1;
          uint64_t v31 = sub_1005628AC((int *)buf);
          v16[2](v16, v31);
        }
        else
        {
          v16[2](v16, 0);
        }
        if ((_BYTE)v55)
        {
          *(void *)long long buf = (char *)v54 + 8;
          sub_100155410((void ***)buf);
        }
        if (SHIBYTE(v52) < 0) {
          operator delete(v51[1]);
        }
        if (SHIBYTE(v51[0]) < 0) {
          operator delete(v50[0]);
        }
        if (SHIBYTE(v49) < 0) {
          operator delete(v48[1]);
        }
        if (SHIBYTE(v48[0]) < 0) {
          operator delete(v47[0]);
        }
        sub_10045468C((uint64_t)v46);
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v32 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        uint64_t v33 = sub_1005628AC((int *)buf);
        v16[2](v16, v33);
      }
      if (v57) {
        sub_10004D2C8(v57);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v19 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      id v20 = sub_1005628AC((int *)buf);
      v16[2](v16, v20);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    int v21 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion block while sending file transfer message to group chat", buf, 2u);
    }
  }
}

- (void)sendGroupDispositionNotificationMessage:(id)a3 toGroup:(id)a4 to:(id)a5 withMessageID:(id)a6 withDisposition:(int64_t)a7 forMessageID:(id)a8 completion:(id)a9
{
  id v15 = a3;
  id v16 = a4;
  id v17 = a5;
  id v18 = a6;
  id v48 = a8;
  id v19 = (void (**)(id, void *))a9;
  if (v19)
  {
    if (v15 && v16 && v17)
    {
      uint64_t v20 = [v17 uri];
      int v21 = (void *)v20;
      if (v18 && v20)
      {
        uint64_t v22 = [v18 uuid];
        uint64_t v23 = v22;
        if (v48 && v22)
        {
          id v24 = [v48 uuid];

          if (v24)
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v25 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              [v15 slotID];
              uint64_t v42 = CTSubscriptionSlotAsString();
              char v45 = [v16 focus];
              if (v45)
              {
                char v44 = [v16 focus];
              }
              else
              {
                char v44 = &stru_101AC1B28;
              }
              uint64_t v47 = [v16 conversationID];
              if (v47)
              {
                char v43 = [v16 conversationID];
              }
              else
              {
                char v43 = &stru_101AC1B28;
              }
              char v46 = [v17 uri];
              uint64_t v29 = [v18 uuid];
              uint64_t v30 = [v48 uuid];
              *(_DWORD *)long long buf = 136316674;
              *(void *)&uint8_t buf[4] = v42;
              *(_WORD *)&buf[12] = 2114;
              *(void *)&buf[14] = v44;
              __int16 v62 = 2114;
              char v63 = v43;
              __int16 v64 = 2112;
              uint64_t v65 = v46;
              __int16 v66 = 2114;
              char v67 = v29;
              __int16 v68 = 2048;
              int64_t v69 = a7;
              __int16 v70 = 2114;
              unsigned int v71 = v30;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendGroupDispositionNotificationMessage: [slot: %s, group.focus: %{public}@, group.conversationID: %{public}@, to: %@, identifier: %{public}@, type: %ld, forMessageID: %{public}@]", buf, 0x48u);

              if (v47) {
              if (v45)
              }
            }
            uint64_t v59 = 0;
            uint64_t v60 = 0;
            sub_1013FFAB8(&v59, self);
            if (v59)
            {
              id v31 = [v15 slotID];
              if (v31 == (id)2) {
                uint64_t v32 = 2;
              }
              else {
                uint64_t v32 = v31 == (id)1;
              }
              if (a7 == 2) {
                int v33 = 2;
              }
              else {
                int v33 = -1;
              }
              if (!a7) {
                int v33 = 0;
              }
              *(_OWORD *)__int16 v57 = 0u;
              long long v58 = 0u;
              LODWORD(v57[0]) = v33;
              id v34 = [v48 uuid];
              sub_100058DB0(&v57[1], (char *)[v34 UTF8String]);

              uint64_t v35 = v59;
              sub_10140BA5C((uint64_t)v51, v16);
              sub_1014010FC((uint64_t)buf, v17);
              id v36 = [v18 uuid];
              sub_100058DB0(__p, (char *)[v36 UTF8String]);
              uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t, void **, unsigned char *, void **, void **))(*(void *)v35 + 312))(v35, v32, v51, buf, __p, v57);
              if (v50 < 0) {
                operator delete(__p[0]);
              }

              if (v74 < 0) {
                operator delete(v73);
              }
              if (v72)
              {
                __p[0] = (char *)&v69 + 2;
                sub_100047F64((void ***)__p);
              }
              if (SBYTE3(v67) < 0) {
                operator delete(v63);
              }
              if (SHIBYTE(v62) < 0) {
                operator delete(*(void **)buf);
              }
              if (v56 < 0) {
                operator delete(v55);
              }
              if (v54 < 0) {
                operator delete(v53);
              }
              if (v52 < 0) {
                operator delete(v51[0]);
              }
              if ((v37 & 0xFF00000000) != 0)
              {
                [(CTXPCClientHandler *)self getLogContext];
                id v38 = *(NSObject **)&buf[8];
                ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Sending of group file transfer failed...", buf, 2u);
                }
                *(_DWORD *)long long buf = v37;
                uint8_t buf[4] = 1;
                char v39 = sub_1005628AC((int *)buf);
                v19[2](v19, v39);
              }
              else
              {
                v19[2](v19, 0);
              }
              if (SHIBYTE(v58) < 0) {
                operator delete(v57[1]);
              }
            }
            else
            {
              [(CTXPCClientHandler *)self getLogContext];
              uint64_t v40 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", buf, 2u);
              }
              *(_DWORD *)long long buf = 5;
              uint8_t buf[4] = 1;
              char v41 = sub_1005628AC((int *)buf);
              v19[2](v19, v41);
            }
            if (v60) {
              sub_10004D2C8(v60);
            }
            goto LABEL_20;
          }
          goto LABEL_17;
        }
      }
    }
LABEL_17:
    [(CTXPCClientHandler *)self getLogContext];
    id v27 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v28 = sub_1005628AC((int *)buf);
    v19[2](v19, v28);

    goto LABEL_20;
  }
  [(CTXPCClientHandler *)self getLogContext];
  uint64_t v26 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Invalid completion block while sending file transfer message to group chat", buf, 2u);
  }
LABEL_20:
}

- (void)addParticipants:(id)a3 toGroupChat:(id)a4 withParticipantsToAdd:(id)a5 withOperationID:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12 && v13 && v14)
    {
      id v17 = [v14 memberList];
      id v18 = v17;
      if (v15 && v17)
      {
        id v19 = [v15 uuid];

        if (v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            [v12 slotID];
            uint64_t v21 = CTSubscriptionSlotAsString();
            uint64_t v40 = [v13 focus];
            if (v40)
            {
              uint64_t v42 = [v13 focus];
            }
            else
            {
              uint64_t v42 = &stru_101AC1B28;
            }
            uint64_t v25 = [v13 conversationID];
            if (v25)
            {
              char v41 = [v13 conversationID];
            }
            else
            {
              char v41 = &stru_101AC1B28;
            }
            uint64_t v38 = v21;
            char v39 = v20;
            uint64_t v26 = [v14 memberList];
            id v27 = [v26 count];
            id v28 = [v15 uuid];
            *(_DWORD *)long long buf = 136316162;
            *(void *)&uint8_t buf[4] = v38;
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = v42;
            __int16 v50 = 2114;
            uint64_t v51 = v41;
            __int16 v52 = 2048;
            id v53 = v27;
            __int16 v54 = 2112;
            v55[0] = v28;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] addParticipants: [slot: %s, to.focus: %{public}@, to.conversationID: %{public}@, list.memberList.size: %ld,  operationID: %@]", buf, 0x34u);

            if (v25) {
            if (v40)
            }
          }
          uint64_t v47 = 0;
          id v48 = 0;
          sub_1013FFAB8(&v47, self);
          if (v47)
          {
            id v29 = [v12 slotID];
            if (v29 == (id)2) {
              uint64_t v30 = 2;
            }
            else {
              uint64_t v30 = v29 == (id)1;
            }
            uint64_t v31 = v47;
            sub_10140BA5C((uint64_t)buf, v13);
            sub_10140E808((uint64_t)v45, v14);
            id v32 = [v15 uuid];
            sub_100058DB0(__p, (char *)[v32 UTF8String]);
            uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, unsigned char *, void **))(*(void *)v31 + 328))(v31, v30, buf, v45, __p);
            if (v44 < 0) {
              operator delete(__p[0]);
            }

            __p[0] = &v46;
            sub_1000D82FC((void ***)__p);
            __p[0] = v45;
            sub_100047F64((void ***)__p);
            if (v56 < 0) {
              operator delete(*(void **)((char *)v55 + 4));
            }
            if (SBYTE3(v55[0]) < 0) {
              operator delete(v51);
            }
            if (SHIBYTE(v50) < 0) {
              operator delete(*(void **)buf);
            }
            if ((v33 & 0xFF00000000) != 0)
            {
              [(CTXPCClientHandler *)self getLogContext];
              id v34 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Addition of participants to group chat failed...", buf, 2u);
              }
              *(_DWORD *)long long buf = v33;
              uint8_t buf[4] = 1;
              uint64_t v35 = sub_1005628AC((int *)buf);
              v16[2](v16, v35);
            }
            else
            {
              v16[2](v16, 0);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v36 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            uint64_t v37 = sub_1005628AC((int *)buf);
            v16[2](v16, v37);
          }
          if (v48) {
            sub_10004D2C8(v48);
          }
          goto LABEL_17;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v23 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v24 = sub_1005628AC((int *)buf);
    v16[2](v16, v24);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion block while adding participants", buf, 2u);
    }
  }
LABEL_17:
}

- (void)removeParticipants:(id)a3 fromGroupChat:(id)a4 withParticipantsToRemove:(id)a5 withOperationID:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12 && v13 && v14)
    {
      id v17 = [v14 memberList];
      id v18 = v17;
      if (v15 && v17)
      {
        id v19 = [v15 uuid];

        if (v19)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v20 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            [v12 slotID];
            uint64_t v21 = CTSubscriptionSlotAsString();
            uint64_t v40 = [v13 focus];
            if (v40)
            {
              uint64_t v42 = [v13 focus];
            }
            else
            {
              uint64_t v42 = &stru_101AC1B28;
            }
            uint64_t v25 = [v13 conversationID];
            if (v25)
            {
              char v41 = [v13 conversationID];
            }
            else
            {
              char v41 = &stru_101AC1B28;
            }
            uint64_t v38 = v21;
            char v39 = v20;
            uint64_t v26 = [v14 memberList];
            id v27 = [v26 count];
            id v28 = [v15 uuid];
            *(_DWORD *)long long buf = 136316162;
            *(void *)&uint8_t buf[4] = v38;
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = v42;
            __int16 v50 = 2114;
            uint64_t v51 = v41;
            __int16 v52 = 2048;
            id v53 = v27;
            __int16 v54 = 2114;
            v55[0] = v28;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] removeParticipants: [slot: %s, from.focus: %{public}@, from.conversationID: %{public}@, list.memberList.size: %ld, operationID: %{public}@]", buf, 0x34u);

            if (v25) {
            if (v40)
            }
          }
          uint64_t v47 = 0;
          id v48 = 0;
          sub_1013FFAB8(&v47, self);
          if (v47)
          {
            id v29 = [v12 slotID];
            if (v29 == (id)2) {
              uint64_t v30 = 2;
            }
            else {
              uint64_t v30 = v29 == (id)1;
            }
            uint64_t v31 = v47;
            sub_10140BA5C((uint64_t)buf, v13);
            sub_10140E808((uint64_t)v45, v14);
            id v32 = [v15 uuid];
            sub_100058DB0(__p, (char *)[v32 UTF8String]);
            uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, unsigned char *, void **))(*(void *)v31 + 336))(v31, v30, buf, v45, __p);
            if (v44 < 0) {
              operator delete(__p[0]);
            }

            __p[0] = &v46;
            sub_1000D82FC((void ***)__p);
            __p[0] = v45;
            sub_100047F64((void ***)__p);
            if (v56 < 0) {
              operator delete(*(void **)((char *)v55 + 4));
            }
            if (SBYTE3(v55[0]) < 0) {
              operator delete(v51);
            }
            if (SHIBYTE(v50) < 0) {
              operator delete(*(void **)buf);
            }
            if ((v33 & 0xFF00000000) != 0)
            {
              [(CTXPCClientHandler *)self getLogContext];
              id v34 = *(NSObject **)&buf[8];
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Removal of participants from group chat failed...", buf, 2u);
              }
              *(_DWORD *)long long buf = v33;
              uint8_t buf[4] = 1;
              uint64_t v35 = sub_1005628AC((int *)buf);
              v16[2](v16, v35);
            }
            else
            {
              v16[2](v16, 0);
            }
          }
          else
          {
            [(CTXPCClientHandler *)self getLogContext];
            id v36 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", buf, 2u);
            }
            *(_DWORD *)long long buf = 5;
            uint8_t buf[4] = 1;
            uint64_t v37 = sub_1005628AC((int *)buf);
            v16[2](v16, v37);
          }
          if (v48) {
            sub_10004D2C8(v48);
          }
          goto LABEL_17;
        }
      }
      else
      {
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v23 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v24 = sub_1005628AC((int *)buf);
    v16[2](v16, v24);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion block while removing participant from group chat", buf, 2u);
    }
  }
LABEL_17:
}

- (void)changeIcon:(id)a3 forGroupChat:(id)a4 withNewIcon:(id)a5 withOperationID:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v45 = a5;
  id v14 = a6;
  id v15 = (void (**)(id, void *))a7;
  if (v15)
  {
    if (v12
      && v13
      && v14
      && ([v14 uuid], id v16 = objc_claimAutoreleasedReturnValue(), v16, v16))
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v17 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        [v12 slotID];
        uint64_t v18 = CTSubscriptionSlotAsString();
        char v43 = [v13 focus];
        if (v43)
        {
          [v13 focus];
          objc_msgSend(v13, "conversationID", objc_claimAutoreleasedReturnValue());
        }
        else
        {
          objc_msgSend(v13, "conversationID", &stru_101AC1B28);
        uint64_t v22 = };
        if (v22)
        {
          uint64_t v23 = [v13 conversationID];
        }
        else
        {
          uint64_t v23 = &stru_101AC1B28;
        }
        id v24 = [v14 uuid];
        *(_DWORD *)long long buf = 136315907;
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&buf[12] = 2113;
        *(void *)&buf[14] = v42;
        *(_WORD *)&unsigned char buf[22] = 2114;
        *(void *)&uint8_t buf[24] = v23;
        *(_WORD *)&uint8_t buf[32] = 2114;
        *(void *)&buf[34] = v24;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] changeIcon: [slot: %s, chat.focus: %{private}@, chat.conversationID: %{public}@, operationID: %{public}@]", buf, 0x2Au);

        if (v22) {
        if (v43)
        }
      }
      uint64_t v55 = 0;
      char v56 = 0;
      sub_1013FFAB8(&v55, self);
      if (v55)
      {
        id v25 = [v12 slotID];
        int v26 = v25 == (id)1;
        uint64_t v59 = 0;
        *(_OWORD *)&uint8_t buf[32] = 0u;
        *(_OWORD *)long long v58 = 0u;
        if (v25 == (id)2) {
          int v26 = 2;
        }
        unsigned int v44 = v26;
        memset(buf, 0, 32);
        if (v45)
        {
          id v27 = [v45 data];
          BOOL v28 = v27 == 0;

          if (!v28)
          {
            id v29 = [v45 data];
            id v30 = [v29 length];

            id v31 = [v45 data];
            id v32 = [v31 bytes];

            __int16 v52 = 0;
            id v53 = 0;
            uint64_t v54 = 0;
            sub_1001E7940(&v52, v32, (uint64_t)v30 + (void)v32, (size_t)v30);
            id v33 = [v45 name];
            sub_100058DB0(v46, (char *)[v33 UTF8String]);
            v48[0] = 0;
            v48[1] = 0;
            uint64_t v49 = 0;
            sub_10005C928(v48, v52, (uint64_t)v53, v53 - (unsigned char *)v52);
            id v34 = [v45 type];
            sub_100058DB0(&v50, (char *)[v34 UTF8String]);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            *(_OWORD *)long long buf = *(_OWORD *)v46;
            *(void *)&uint8_t buf[16] = v47;
            HIBYTE(v47) = 0;
            v46[0] = 0;
            if (*(void *)&buf[24])
            {
              *(void *)&uint8_t buf[32] = *(void *)&buf[24];
              operator delete(*(void **)&buf[24]);
            }
            *(_OWORD *)&uint8_t buf[24] = *(_OWORD *)v48;
            *(void *)&uint8_t buf[40] = v49;
            v48[1] = 0;
            uint64_t v49 = 0;
            v48[0] = 0;
            if (SHIBYTE(v59) < 0)
            {
              operator delete(v58[0]);
              *(_OWORD *)long long v58 = v50;
              uint64_t v59 = v51;
              HIBYTE(v51) = 0;
              LOBYTE(v50) = 0;
              if (v48[0])
              {
                v48[1] = v48[0];
                operator delete(v48[0]);
              }
            }
            else
            {
              *(_OWORD *)long long v58 = v50;
              uint64_t v59 = v51;
              HIBYTE(v51) = 0;
              LOBYTE(v50) = 0;
            }
            if (SHIBYTE(v47) < 0) {
              operator delete(*(void **)v46);
            }

            if (v52)
            {
              id v53 = v52;
              operator delete(v52);
            }
          }
        }
        uint64_t v37 = v55;
        sub_10140BA5C((uint64_t)v46, v13);
        id v38 = [v14 uuid];
        sub_100058DB0(&v52, (char *)[v38 UTF8String]);
        uint64_t v39 = (*(uint64_t (**)(uint64_t, void, uint8_t *, unsigned char *, void **))(*(void *)v37 + 352))(v37, v44, v46, buf, &v52);
        if (SHIBYTE(v54) < 0) {
          operator delete(v52);
        }

        if (SHIBYTE(v51) < 0) {
          operator delete((void *)v50);
        }
        if (SHIBYTE(v49) < 0) {
          operator delete(v48[0]);
        }
        if (SHIBYTE(v47) < 0) {
          operator delete(*(void **)v46);
        }
        if ((v39 & 0xFF00000000) != 0)
        {
          [(CTXPCClientHandler *)self getLogContext];
          uint64_t v40 = *(NSObject **)&v46[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v46);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v46 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Change of icon for group chat failed...", v46, 2u);
          }
          *(_DWORD *)uint64_t v46 = v39;
          v46[4] = 1;
          char v41 = sub_1005628AC((int *)v46);
          v15[2](v15, v41);
        }
        else
        {
          v15[2](v15, 0);
        }
        if (SHIBYTE(v59) < 0) {
          operator delete(v58[0]);
        }
        if (*(void *)&buf[24])
        {
          *(void *)&uint8_t buf[32] = *(void *)&buf[24];
          operator delete(*(void **)&buf[24]);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v35 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while enabling lazuli", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        id v36 = sub_1005628AC((int *)buf);
        v15[2](v15, v36);
      }
      if (v56) {
        sub_10004D2C8(v56);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v19 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      uint64_t v20 = sub_1005628AC((int *)buf);
      v15[2](v15, v20);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v21 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Invalid completion block while changing icon", buf, 2u);
    }
  }
}

- (void)changeSubject:(id)a3 forGroupChat:(id)a4 withNewSubject:(id)a5 withOperationID:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12)
    {
      if (v13)
      {
        if (v15)
        {
          id v17 = [v15 uuid];

          if (v17)
          {
            [(CTXPCClientHandler *)self getLogContext];
            uint64_t v18 = *(NSObject **)&buf[8];
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
            if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
LABEL_31:
              uint64_t v47 = 0;
              id v48 = 0;
              sub_1013FFAB8(&v47, self);
              if (v47)
              {
                memset(&v46, 0, sizeof(v46));
                if (v14)
                {
                  id v27 = [v14 displayString];
                  sub_10003ED78(&v46, (char *)[v27 UTF8String]);
                }
                id v28 = [v12 slotID];
                if (v28 == (id)2) {
                  uint64_t v29 = 2;
                }
                else {
                  uint64_t v29 = v28 == (id)1;
                }
                uint64_t v30 = v47;
                sub_10140BA5C((uint64_t)buf, v13);
                id v31 = [v15 uuid];
                sub_100058DB0(__p, (char *)[v31 UTF8String]);
                uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, std::string *, void **))(*(void *)v30 + 344))(v30, v29, buf, &v46, __p);
                if (v45 < 0) {
                  operator delete(__p[0]);
                }

                if (v56 < 0) {
                  operator delete(*(void **)((char *)v55 + 4));
                }
                if (SBYTE3(v55[0]) < 0) {
                  operator delete(v51);
                }
                if (SHIBYTE(v50) < 0) {
                  operator delete(*(void **)buf);
                }
                if ((v32 & 0xFF00000000) != 0)
                {
                  [(CTXPCClientHandler *)self getLogContext];
                  id v33 = *(NSObject **)&buf[8];
                  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Change of icon for group chat failed...", buf, 2u);
                  }
                  *(_DWORD *)long long buf = v32;
                  uint8_t buf[4] = 1;
                  id v34 = sub_1005628AC((int *)buf);
                  v16[2](v16, v34);
                }
                else
                {
                  v16[2](v16, 0);
                }
                if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v46.__r_.__value_.__l.__data_);
                }
              }
              else
              {
                [(CTXPCClientHandler *)self getLogContext];
                uint64_t v35 = *(NSObject **)&buf[8];
                ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while changing subject", buf, 2u);
                }
                *(_DWORD *)long long buf = 5;
                uint8_t buf[4] = 1;
                id v36 = sub_1005628AC((int *)buf);
                v16[2](v16, v36);
              }
              if (v48) {
                sub_10004D2C8(v48);
              }
              goto LABEL_57;
            }
            [v12 slotID];
            uint64_t v19 = CTSubscriptionSlotAsString();
            char v43 = [v13 focus];
            if (v43)
            {
              uint64_t v42 = [v13 focus];
            }
            else
            {
              uint64_t v42 = &stru_101AC1B28;
            }
            uint64_t v40 = [v13 conversationID];
            if (v40)
            {
              char v41 = [v13 conversationID];
              if (v14) {
                goto LABEL_17;
              }
            }
            else
            {
              char v41 = &stru_101AC1B28;
              if (v14)
              {
LABEL_17:
                uint64_t v23 = [v14 displayString];
                if (v23)
                {
                  uint64_t v37 = v23;
                  id v24 = [v14 displayString];
                  int v39 = 1;
                }
                else
                {
                  uint64_t v37 = 0;
                  int v39 = 0;
                  id v24 = &stru_101AC1B28;
                }
                goto LABEL_22;
              }
            }
            int v39 = 0;
            id v24 = &stru_101AC1B28;
LABEL_22:
            id v25 = objc_msgSend(v15, "uuid", v37);
            *(_DWORD *)long long buf = 136316162;
            *(void *)&uint8_t buf[4] = v19;
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = v42;
            __int16 v50 = 2114;
            uint64_t v51 = v41;
            __int16 v52 = 2112;
            id v53 = v24;
            __int16 v54 = 2114;
            v55[0] = v25;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] changeSubject: [slot: %s, chat.focus: %{public}@, chat.conversationID: %{public}@, subject: %{senstive}@, operationID: %{public}@]", buf, 0x34u);

            if (v39) {
            if (v14)
            }

            int v26 = (void *)v40;
            if (v40)
            {

              int v26 = (void *)v40;
            }

            if (v43) {
            goto LABEL_31;
            }
          }
        }
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v20 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    uint64_t v21 = sub_1005628AC((int *)buf);
    v16[2](v16, v21);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v22 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid completion block while changing subject", buf, 2u);
    }
  }
LABEL_57:
}

- (void)create:(id)a3 groupChat:(id)a4 withOperationID:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v88 = a5;
  id v12 = (void (**)(id, void *))a6;
  long long v87 = v10;
  if (v12)
  {
    if (v10)
    {
      if (v11)
      {
        if (v88)
        {
          id v13 = [v88 uuid];
          if (v13)
          {
            id v14 = [v11 participants];
            if (v14)
            {
              id v15 = [v11 participants];
              id v16 = [v15 memberList];

              if (v16)
              {
                [(CTXPCClientHandler *)self getLogContext];
                id v17 = *(NSObject **)&buf[8];
                ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
                {
                  [v87 slotID];
                  uint64_t v86 = CTSubscriptionSlotAsString();
                  uint64_t v18 = [v11 participants];
                  xpc_object_t v84 = [v18 memberList];
                  id v19 = [v84 count];
                  uint64_t v20 = [v11 subject];
                  if (v20)
                  {
                    long long v81 = [v11 subject];
                    uint64_t v82 = [v81 displayString];
                    if (v82)
                    {
                      uint64_t v80 = [v11 subject];
                      uint64_t v21 = [v80 displayString];
                      int v22 = 1;
                    }
                    else
                    {
                      uint64_t v82 = 0;
                      int v22 = 0;
                      uint64_t v21 = &stru_101AC1B28;
                    }
                  }
                  else
                  {
                    int v22 = 0;
                    uint64_t v21 = &stru_101AC1B28;
                  }
                  int v26 = [v88 uuid];
                  *(_DWORD *)long long buf = 136316163;
                  *(void *)&uint8_t buf[4] = v86;
                  *(_WORD *)&buf[12] = 2048;
                  *(void *)&buf[14] = v19;
                  *(_WORD *)&unsigned char buf[22] = 2160;
                  *(void *)&uint8_t buf[24] = 1752392040;
                  *(_WORD *)&uint8_t buf[32] = 2117;
                  *(void *)&buf[34] = v21;
                  *(_WORD *)&buf[42] = 2114;
                  *(void *)&buf[44] = v26;
                  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] create: [slot: %s, chat.participants.size: %ld, chat.subject: %{sensitive, mask.hash}@, operationID: %{public}@]", buf, 0x34u);

                  if (v22)
                  {
                  }
                  if (v20)
                  {
                  }
                }
                uint64_t v101 = 0;
                xpc_object_t v102 = 0;
                sub_1013FFAB8(&v101, self);
                if (v101)
                {
                  id v27 = [v87 slotID];
                  long long v99 = 0u;
                  long long v100 = 0u;
                  if (v27 == (id)2) {
                    int v28 = 2;
                  }
                  else {
                    int v28 = v27 == (id)1;
                  }
                  long long v98 = 0uLL;
                  uint64_t v29 = [v11 participants];
                  uint64_t v30 = [v29 memberList];
                  unsigned int v85 = v28;
                  id v31 = (char *)[v30 count];

                  if (v31)
                  {
                    for (uint64_t i = 0; i != v31; ++i)
                    {
                      id v33 = [v11 participants];
                      id v34 = [v33 memberList];
                      uint64_t v35 = [v34 objectAtIndexedSubscript:i];

                      id v36 = [v35 member];
                      sub_100058DB0(__p, (char *)[v36 UTF8String]);
                      LODWORD(v93[1]) = -1;
                      long long v37 = v100;
                      if ((unint64_t)v100 >= *((void *)&v100 + 1))
                      {
                        uint64_t v39 = (uint64_t)(v100 - *((void *)&v99 + 1)) >> 5;
                        unint64_t v40 = v39 + 1;
                        if ((unint64_t)(v39 + 1) >> 59) {
                          sub_10006A748();
                        }
                        uint64_t v41 = *((void *)&v100 + 1) - *((void *)&v99 + 1);
                        if ((uint64_t)(*((void *)&v100 + 1) - *((void *)&v99 + 1)) >> 4 > v40) {
                          unint64_t v40 = v41 >> 4;
                        }
                        if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFE0) {
                          unint64_t v42 = 0x7FFFFFFFFFFFFFFLL;
                        }
                        else {
                          unint64_t v42 = v40;
                        }
                        *(void *)&uint8_t buf[32] = (char *)&v100 + 8;
                        char v43 = (char *)sub_1000F5A68((uint64_t)&v100 + 8, v42);
                        unsigned int v44 = (void **)&v43[32 * v39];
                        *(void *)long long buf = v43;
                        *(void *)&uint8_t buf[8] = v44;
                        *(void *)&uint8_t buf[24] = &v43[32 * v45];
                        long long v46 = *(_OWORD *)__p;
                        v44[2] = v93[0];
                        *(_OWORD *)unsigned int v44 = v46;
                        __p[1] = 0;
                        v93[0] = 0;
                        __p[0] = 0;
                        *((_DWORD *)v44 + 6) = v93[1];
                        *(void *)&uint8_t buf[16] = v44 + 4;
                        sub_1002B2D2C((uint64_t *)&v99 + 1, buf);
                        uint64_t v47 = v100;
                        sub_1002B2ED0((uint64_t)buf);
                        *(void *)&long long v100 = v47;
                        if (SHIBYTE(v93[0]) < 0) {
                          operator delete(__p[0]);
                        }
                      }
                      else
                      {
                        long long v38 = *(_OWORD *)__p;
                        *(void **)(v100 + 16) = v93[0];
                        *(_OWORD *)long long v37 = v38;
                        __p[1] = 0;
                        v93[0] = 0;
                        __p[0] = 0;
                        *(_DWORD *)(v37 + 24) = v93[1];
                        *(void *)&long long v100 = v37 + 32;
                      }
                    }
                  }
                  *(_OWORD *)long long v96 = 0u;
                  long long v97 = 0u;
                  id v48 = [v11 subject];
                  if (v48)
                  {
                    uint64_t v49 = [v11 subject];
                    __int16 v50 = [v49 displayString];
                    if (v50)
                    {
                      uint64_t v51 = [v11 subject];
                      __int16 v52 = [v51 displayString];
                      BOOL v53 = [v52 length] == 0;

                      if (!v53)
                      {
                        __int16 v54 = [v11 subject];
                        id v55 = [v54 displayString];
                        sub_100058DB0(buf, (char *)[v55 UTF8String]);
                        if (BYTE8(v97))
                        {
                          if (SBYTE7(v97) < 0) {
                            operator delete(v96[0]);
                          }
                          *(_OWORD *)long long v96 = *(_OWORD *)buf;
                          *(void *)&long long v97 = *(void *)&buf[16];
                          buf[23] = 0;
                          buf[0] = 0;
                        }
                        else
                        {
                          *(_OWORD *)long long v96 = *(_OWORD *)buf;
                          *(void *)&long long v97 = *(void *)&buf[16];
                          memset(buf, 0, 24);
                          BYTE8(v97) = 1;
                        }
                      }
                    }
                    else
                    {
                    }
                  }
                  *(_OWORD *)xpc_object_t v94 = 0u;
                  long long v95 = 0u;
                  memset(v93, 0, sizeof(v93));
                  *(_OWORD *)std::string __p = 0u;
                  long long v58 = [v11 icon];
                  BOOL v59 = v58 == 0;

                  if (!v59)
                  {
                    uint64_t v60 = [v11 icon];
                    __int16 v61 = [v60 data];
                    BOOL v62 = v61 == 0;

                    if (v62)
                    {
                      __int16 v70 = 0;
                      uint64_t v69 = 0;
                    }
                    else
                    {
                      char v63 = [v11 icon];
                      __int16 v64 = [v63 data];
                      id v65 = [v64 length];

                      __int16 v66 = [v11 icon];
                      id v67 = [v66 data];
                      id v68 = [v67 bytes];

                      memset(buf, 0, 24);
                      sub_1001E7940(buf, v68, (uint64_t)v65 + (void)v68, (size_t)v65);
                      __int16 v70 = *(void **)buf;
                      uint64_t v69 = *(void *)&buf[8];
                    }
                    std::string v83 = [v11 icon];
                    id v71 = [v83 name];
                    sub_100058DB0(buf, (char *)[v71 UTF8String]);
                    memset(&buf[24], 0, 24);
                    sub_10005C928(&buf[24], v70, v69, v69 - (void)v70);
                    char v72 = [v11 icon];
                    id v73 = [v72 type];
                    sub_100058DB0(&buf[48], (char *)[v73 UTF8String]);
                    if (BYTE8(v95))
                    {
                      if (SHIBYTE(v93[0]) < 0) {
                        operator delete(__p[0]);
                      }
                      *(_OWORD *)std::string __p = *(_OWORD *)buf;
                      v93[0] = *(void **)&buf[16];
                      buf[23] = 0;
                      buf[0] = 0;
                      if (v93[1])
                      {
                        v93[2] = v93[1];
                        operator delete(v93[1]);
                      }
                      *(_OWORD *)&v93[1] = *(_OWORD *)&buf[24];
                      v93[3] = *(void **)&buf[40];
                      memset(&buf[24], 0, 24);
                      if (SBYTE7(v95) < 0) {
                        operator delete(v94[0]);
                      }
                      *(_OWORD *)xpc_object_t v94 = *(_OWORD *)&buf[48];
                      *(void *)&long long v95 = v104;
                      BYTE7(v104) = 0;
                      unsigned char buf[48] = 0;
                      char v74 = *(void **)&buf[24];
                    }
                    else
                    {
                      char v74 = 0;
                      v93[0] = *(void **)&buf[16];
                      *(_OWORD *)std::string __p = *(_OWORD *)buf;
                      memset(buf, 0, sizeof(buf));
                      *(_OWORD *)&v93[1] = *(_OWORD *)&buf[24];
                      v93[3] = *(void **)&buf[40];
                      *(void *)&long long v95 = v104;
                      *(_OWORD *)xpc_object_t v94 = *(_OWORD *)&buf[48];
                      *(void *)&long long v104 = 0;
                      BYTE8(v95) = 1;
                    }
                    if (v74)
                    {
                      *(void *)&uint8_t buf[32] = v74;
                      operator delete(v74);
                    }
                    if ((char)buf[23] < 0) {
                      operator delete(*(void **)buf);
                    }

                    if (v70) {
                      operator delete(v70);
                    }
                  }
                  long long v113 = 0u;
                  long long v114 = 0u;
                  memset(v112, 0, sizeof(v112));
                  long long v110 = 0u;
                  memset(v111, 0, sizeof(v111));
                  long long v108 = 0u;
                  long long v109 = 0u;
                  long long v106 = 0u;
                  long long v107 = 0u;
                  long long v104 = 0u;
                  long long v105 = 0u;
                  memset(buf, 0, sizeof(buf));
                  sub_1000302C0((char *)buf, (long long *)v98, *((long long **)&v98 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v98 + 1) - v98) >> 3));
                  memset(&buf[24], 0, 24);
                  sub_1002B2788(&buf[24], *((long long **)&v99 + 1), (long long *)v100, (uint64_t)(v100 - *((void *)&v99 + 1)) >> 5);
                  BYTE8(v110) = 0;
                  *(_OWORD *)&unsigned char buf[48] = 0u;
                  long long v104 = 0u;
                  long long v105 = 0u;
                  LOBYTE(v106) = 0;
                  sub_1002B250C((uint64_t)v111, (long long *)v96);
                  sub_1002B2560((char *)v112, (uint64_t)__p);
                  long long v113 = 0uLL;
                  *(void *)&long long v114 = 0;
                  DWORD2(v114) = -1;
                  uint64_t v75 = v101;
                  id v76 = [v88 uuid];
                  sub_100058DB0(v89, (char *)[v76 UTF8String]);
                  uint64_t v77 = (*(uint64_t (**)(uint64_t, void, uint8_t *, uint8_t *))(*(void *)v75 + 320))(v75, v85, buf, v89);
                  if (v91 < 0) {
                    operator delete(*(void **)v89);
                  }

                  if ((v77 & 0xFF00000000) != 0)
                  {
                    [(CTXPCClientHandler *)self getLogContext];
                    uint64_t v78 = v90;
                    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v89);
                    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)unint64_t v89 = 0;
                      _os_log_error_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "Create group chat failed...", v89, 2u);
                    }
                    *(_DWORD *)unint64_t v89 = v77;
                    v89[4] = 1;
                    uint64_t v79 = sub_1005628AC((int *)v89);
                    v12[2](v12, v79);
                  }
                  else
                  {
                    v12[2](v12, 0);
                  }
                  sub_1002B26E8((uint64_t)buf);
                  sub_1002B268C((uint64_t)__p);
                  if (BYTE8(v97) && SBYTE7(v97) < 0) {
                    operator delete(v96[0]);
                  }
                  *(void *)long long buf = (char *)&v99 + 8;
                  sub_1000D82FC((void ***)buf);
                  *(void *)long long buf = &v98;
                  sub_100047F64((void ***)buf);
                }
                else
                {
                  [(CTXPCClientHandler *)self getLogContext];
                  char v56 = *(NSObject **)&buf[8];
                  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                  if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while creating group chat", buf, 2u);
                  }
                  *(_DWORD *)long long buf = 5;
                  uint8_t buf[4] = 1;
                  __int16 v57 = sub_1005628AC((int *)buf);
                  v12[2](v12, v57);
                }
                if (v102) {
                  sub_10004D2C8(v102);
                }
                goto LABEL_18;
              }
            }
            else
            {
            }
          }
        }
      }
    }
    [(CTXPCClientHandler *)self getLogContext];
    id v24 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
    }
    *(_DWORD *)long long buf = 4;
    uint8_t buf[4] = 1;
    id v25 = sub_1005628AC((int *)buf);
    v12[2](v12, v25);
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v23 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Invalid completion block while creating a group chat", buf, 2u);
    }
  }
LABEL_18:
}

- (void)exit:(id)a3 groupChat:(id)a4 withOperationID:(id)a5 completion:(id)a6
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(id, void *))a6;
  if (v13)
  {
    if (v10
      && v11
      && v12
      && ([v12 uuid], id v14 = objc_claimAutoreleasedReturnValue(), v14, v14))
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v15 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        [v10 slotID];
        uint64_t v16 = CTSubscriptionSlotAsString();
        id v33 = [v11 focus];
        if (v33)
        {
          uint64_t v32 = [v11 focus];
        }
        else
        {
          uint64_t v32 = &stru_101AC1B28;
        }
        uint64_t v20 = [v11 conversationID];
        if (v20)
        {
          uint64_t v21 = [v11 conversationID];
        }
        else
        {
          uint64_t v21 = &stru_101AC1B28;
        }
        int v22 = [v12 uuid];
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = v16;
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v32;
        __int16 v39 = 2114;
        unint64_t v40 = v21;
        __int16 v41 = 2114;
        unint64_t v42 = v22;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] exit: [slot: %s, chat.focus: %{public}@, chat.conversationID: %{public}@, operationID: %{public}@]", buf, 0x2Au);

        if (v20) {
        if (v33)
        }
      }
      uint64_t v36 = 0;
      long long v37 = 0;
      sub_1013FFAB8(&v36, self);
      if (v36)
      {
        id v23 = [v10 slotID];
        if (v23 == (id)2) {
          uint64_t v24 = 2;
        }
        else {
          uint64_t v24 = v23 == (id)1;
        }
        uint64_t v25 = v36;
        sub_10140BA5C((uint64_t)buf, v11);
        id v26 = [v12 uuid];
        sub_100058DB0(__p, (char *)[v26 UTF8String]);
        uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **))(*(void *)v25 + 360))(v25, v24, buf, __p);
        if (v35 < 0) {
          operator delete(__p[0]);
        }

        if (v45 < 0) {
          operator delete(v44);
        }
        if (v43 < 0) {
          operator delete(v40);
        }
        if (SHIBYTE(v39) < 0) {
          operator delete(*(void **)buf);
        }
        if ((v27 & 0xFF00000000) != 0)
        {
          [(CTXPCClientHandler *)self getLogContext];
          int v28 = *(NSObject **)&buf[8];
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Exit group chat failed...", buf, 2u);
          }
          *(_DWORD *)long long buf = v27;
          uint8_t buf[4] = 1;
          uint64_t v29 = sub_1005628AC((int *)buf);
          v13[2](v13, v29);
        }
        else
        {
          v13[2](v13, 0);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v30 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while exiting group chat", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        id v31 = sub_1005628AC((int *)buf);
        v13[2](v13, v31);
      }
      if (v37) {
        sub_10004D2C8(v37);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v17 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      uint64_t v18 = sub_1005628AC((int *)buf);
      v13[2](v13, v18);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    id v19 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid completion block while exiting a group chat", buf, 2u);
    }
  }
}

- (void)deleteChat:(id)a3 chat:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, void *))a5;
  if (v10)
  {
    if (v8 && v9)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v11 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        [v8 slotID];
        uint64_t v12 = CTSubscriptionSlotAsString();
        *(_DWORD *)long long buf = 136315395;
        *(void *)&uint8_t buf[4] = v12;
        *(_WORD *)&buf[12] = 2113;
        *(void *)&buf[14] = v9;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] deleteChat: [slot: %s, chat: %{private}@]", buf, 0x16u);
      }
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      sub_1013FFAB8(&v23, self);
      if (v23)
      {
        id v13 = [v8 slotID];
        if (v13 == (id)2) {
          uint64_t v14 = 2;
        }
        else {
          uint64_t v14 = v13 == (id)1;
        }
        uint64_t v15 = v23;
        sub_100058DB0(buf, (char *)[v9 UTF8String]);
        uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v15 + 368))(v15, v14, buf);
        if (v26 < 0) {
          operator delete(*(void **)buf);
        }
        if ((v16 & 0xFF00000000) != 0)
        {
          *(_DWORD *)long long buf = v16;
          uint8_t buf[4] = 1;
          id v17 = sub_1005628AC((int *)buf);
          v10[2](v10, v17);
        }
        else
        {
          v10[2](v10, 0);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v21 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while exiting group chat", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        int v22 = sub_1005628AC((int *)buf);
        v10[2](v10, v22);
      }
      if (v24) {
        sub_10004D2C8(v24);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v19 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      uint64_t v20 = sub_1005628AC((int *)buf);
      v10[2](v10, v20);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v18 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Invalid completion block while deleting a chat", buf, 2u);
    }
  }
}

- (void)setProvisioningServerURL:(id)a3 url:(id)a4 completion:(id)a5
{
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(id, void))a5;
  if (v10)
  {
    if (v8 && v9)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v11 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        [v8 slotID];
        uint64_t v12 = CTSubscriptionSlotAsString();
        *(_DWORD *)long long buf = 136315395;
        *(void *)&uint8_t buf[4] = v12;
        *(_WORD *)&buf[12] = 2113;
        *(void *)&buf[14] = v9;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] setProvisioningServerURL: [slot: %s, url: %{private}@]", buf, 0x16u);
      }
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      sub_1013FFAB8(buf, self);
      if (*(void *)buf)
      {
        id v13 = [v8 slotID];
        if (v13 == (id)2) {
          uint64_t v14 = 2;
        }
        else {
          uint64_t v14 = v13 == (id)1;
        }
        uint64_t v15 = *(void *)buf;
        sub_100058DB0(__p, (char *)[v9 UTF8String]);
        (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v15 + 160))(v15, v14, __p);
        if (v22 < 0) {
          operator delete(__p[0]);
        }
        v10[2](v10, 0);
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        id v19 = v25;
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v23);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v23 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while setting RCS configuration server URL", v23, 2u);
        }
        *(_DWORD *)uint64_t v23 = 5;
        char v24 = 1;
        uint64_t v20 = sub_1005628AC((int *)v23);
        ((void (**)(id, void *))v10)[2](v10, v20);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v17 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      uint64_t v18 = sub_1005628AC((int *)buf);
      ((void (**)(id, void *))v10)[2](v10, v18);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v16 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid completion block while setting RCS configuration server URL", buf, 2u);
    }
  }
}

- (void)getProvisioningServerURL:(id)a3 completion:(id)a4
{
  id v6 = a3;
  id v7 = (void (**)(id, void *, void))a4;
  if (v7)
  {
    if (v6)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v8 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        [v6 slotID];
        uint64_t v9 = CTSubscriptionSlotAsString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] getProvisioningServerURL: [slot: %s]", buf, 0xCu);
      }
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      sub_1013FFAB8(&v22, self);
      if (v22)
      {
        [v6 slotID];
        *(_OWORD *)long long buf = 0u;
        long long v25 = 0u;
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v22 + 168))(buf);
        if (BYTE8(v25))
        {
          if ((SBYTE7(v25) & 0x80u) == 0) {
            id v10 = buf;
          }
          else {
            id v10 = *(uint8_t **)buf;
          }
          id v11 = +[NSString stringWithUTF8String:v10];
          v7[2](v7, v11, 0);
        }
        else
        {
          [(CTXPCClientHandler *)self getLogContext];
          id v17 = v21;
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v19) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not get RCS configuration server URL", (uint8_t *)&v19, 2u);
          }
          int v19 = 5;
          char v20 = 1;
          uint64_t v18 = sub_1005628AC(&v19);
          ((void (**)(id, void *, void *))v7)[2](v7, 0, v18);
        }
        if (BYTE8(v25) && SBYTE7(v25) < 0) {
          operator delete(*(void **)buf);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v15 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while getting RCS configuration server URL", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        uint64_t v16 = sub_1005628AC((int *)buf);
        ((void (**)(id, void *, void *))v7)[2](v7, 0, v16);
      }
      if (v23) {
        sub_10004D2C8(v23);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v13 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      uint64_t v14 = sub_1005628AC((int *)buf);
      ((void (**)(id, void *, void *))v7)[2](v7, 0, v14);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    uint64_t v12 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid completion block while getting RCS configuration server URL", buf, 2u);
    }
  }
}

- (void)sendOneToManyTextMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withMessage:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  uint64_t v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12 && v13 && v14 && v15)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v17 = *((void *)&buf + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        [v12 slotID];
        uint64_t v18 = CTSubscriptionSlotAsString();
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendOneToManyTextMessage: [slot: %s]", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v36 = 0;
      long long v37 = 0;
      sub_1013FFAB8(&v36, self);
      if (v36)
      {
        id v19 = [v12 slotID];
        if (v19 == (id)2) {
          uint64_t v20 = 2;
        }
        else {
          uint64_t v20 = v19 == (id)1;
        }
        uint64_t v35 = 0;
        uint64_t v21 = v36;
        sub_1014129E8(&v34, v13);
        id v31 = [v14 uuid];
        sub_100058DB0(__p, (char *)[v31 UTF8String]);
        id v30 = [v15 content];
        sub_100058DB0(&buf, (char *)[v30 UTF8String]);
        char v41 = 0;
        char v42 = 0;
        uint64_t v22 = [v15 metaData];
        sub_1014056B0((uint64_t)v43, v22);
        uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, int64x2_t *, void **, long long *))(*(void *)v21 + 384))(v21, v20, &v34, __p, &buf);
        uint64_t v35 = v23;
        if (v43[24])
        {
          long long v38 = (void **)v43;
          sub_100155410(&v38);
        }
        if (v42)
        {
          long long v38 = (void **)&v41;
          sub_100155494(&v38);
        }
        if (v40 < 0) {
          operator delete((void *)buf);
        }

        if (v33 < 0) {
          operator delete(__p[0]);
        }

        *(void *)&long long buf = &v34;
        sub_100454BA8((void ***)&buf);
        if ((v23 & 0xFF00000000) != 0)
        {
          char v24 = sub_1005628AC((int *)&v35);
          v16[2](v16, v24);
        }
        else
        {
          v16[2](v16, 0);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        int v28 = *((void *)&buf + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while getting RCS configuration server URL", (uint8_t *)&buf, 2u);
        }
        LODWORD(buf) = 5;
        BYTE4(buf) = 1;
        uint64_t v29 = sub_1005628AC((int *)&buf);
        v16[2](v16, v29);
      }
      if (v37) {
        sub_10004D2C8(v37);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      char v26 = *((void *)&buf + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Invalid arguments", (uint8_t *)&buf, 2u);
      }
      LODWORD(buf) = 4;
      BYTE4(buf) = 1;
      uint64_t v27 = sub_1005628AC((int *)&buf);
      v16[2](v16, v27);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    long long v25 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Invalid completion block while sending one to many text", (uint8_t *)&buf, 2u);
    }
  }
}

- (void)sendOneToManyGeolocationMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withGeoPush:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  uint64_t v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12 && v13 && v14 && v15)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v17 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        [v12 slotID];
        uint64_t v18 = CTSubscriptionSlotAsString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendOneToManyTextMessage: [slot: %s]", buf, 0xCu);
      }
      uint64_t v47 = 0;
      id v48 = 0;
      sub_1013FFAB8(&v47, self);
      if (v47)
      {
        id v19 = [v12 slotID];
        int v20 = v19 == (id)1;
        if (v19 == (id)2) {
          int v20 = 2;
        }
        unsigned int v39 = v20;
        *(_OWORD *)char v45 = 0u;
        long long v46 = 0u;
        uint64_t v21 = [v15 additionalDescription];
        BOOL v22 = v21 == 0;

        if (!v22)
        {
          id v23 = [v15 additionalDescription];
          *(void *)long long buf = [v23 UTF8String];
          sub_1000791C0((std::string *)v45, (char **)buf);
        }
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v51 = 0u;
        *(_OWORD *)long long buf = 0u;
        *(_OWORD *)__int16 v50 = 0u;
        char v40 = [v15 coordinates];
        char v24 = [v40 longitude];
        [v24 doubleValue];
        *(void *)long long buf = v25;
        char v26 = [v15 coordinates];
        uint64_t v27 = [v26 latitude];
        [v27 doubleValue];
        *(void *)&uint8_t buf[8] = v28;
        sub_1000593FC((uint64_t)v50, (long long *)v45);
        LOBYTE(v52) = 0;
        BYTE8(v53) = 0;
        uint64_t v29 = [v15 metaData];
        sub_1014056B0((uint64_t)&v54, v29);

        uint64_t v30 = v47;
        sub_1014129E8(&v43, v13);
        id v31 = [v14 uuid];
        sub_100058DB0(__p, (char *)[v31 UTF8String]);
        uint64_t v32 = (*(uint64_t (**)(uint64_t, void, int64x2_t *, void **, uint8_t *))(*(void *)v30 + 392))(v30, v39, &v43, __p, buf);
        uint64_t v44 = v32;
        if (v42 < 0) {
          operator delete(__p[0]);
        }

        __p[0] = &v43;
        sub_100454BA8((void ***)__p);
        if ((v32 & 0xFF00000000) != 0)
        {
          char v33 = sub_1005628AC((int *)&v44);
          v16[2](v16, v33);
        }
        else
        {
          v16[2](v16, 0);
        }
        if (BYTE8(v55))
        {
          v43.i64[0] = (uint64_t)&v54;
          sub_100155410((void ***)&v43);
        }
        if (BYTE8(v53))
        {
          v43.i64[0] = (uint64_t)&v52;
          sub_100155494((void ***)&v43);
        }
        if (BYTE8(v51) && SBYTE7(v51) < 0) {
          operator delete(v50[0]);
        }
        if (BYTE8(v46) && SBYTE7(v46) < 0) {
          operator delete(v45[0]);
        }
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        long long v37 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while getting RCS configuration server URL", buf, 2u);
        }
        *(_DWORD *)long long buf = 5;
        uint8_t buf[4] = 1;
        long long v38 = sub_1005628AC((int *)buf);
        v16[2](v16, v38);
      }
      if (v48) {
        sub_10004D2C8(v48);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v35 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Invalid arguments", buf, 2u);
      }
      *(_DWORD *)long long buf = 4;
      uint8_t buf[4] = 1;
      uint64_t v36 = sub_1005628AC((int *)buf);
      v16[2](v16, v36);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    int64x2_t v34 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Invalid completion block while sending one to many text", buf, 2u);
    }
  }
}

- (void)sendOneToManyFileTransferMessage:(id)a3 to:(id)a4 withMessageID:(id)a5 withDescriptor:(id)a6 completion:(id)a7
{
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  uint64_t v16 = (void (**)(id, void *))a7;
  if (v16)
  {
    if (v12 && v13 && v14 && v15)
    {
      [(CTXPCClientHandler *)self getLogContext];
      id v17 = *((void *)&buf[0] + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        [v12 slotID];
        uint64_t v18 = CTSubscriptionSlotAsString();
        LODWORD(buf[0]) = 136315138;
        *(void *)((char *)buf + 4) = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "[MSG] ==>> laz ==>> [CT] sendOneToManyTextMessage: [slot: %s]", (uint8_t *)buf, 0xCu);
      }
      uint64_t v45 = 0;
      long long v46 = 0;
      sub_1013FFAB8(&v45, self);
      if (v45)
      {
        id v19 = [v12 slotID];
        uint64_t v44 = 0;
        memset(v43, 0, sizeof(v43));
        if (v19 == (id)2) {
          uint64_t v20 = 2;
        }
        else {
          uint64_t v20 = v19 == (id)1;
        }
        long long v41 = 0uLL;
        long long v42 = 0uLL;
        long long v39 = 0uLL;
        long long v40 = 0uLL;
        long long v37 = 0uLL;
        long long v38 = 0uLL;
        long long v36 = 0uLL;
        memset(v35, 0, sizeof(v35));
        sub_101405064((uint64_t)v35, v15);
        uint64_t v21 = v45;
        sub_1014129E8(&v33, v13);
        id v22 = [v14 uuid];
        sub_100058DB0(__p, (char *)[v22 UTF8String]);
        sub_10045449C(buf, (uint64_t)v35);
        char v48 = 0;
        char v49 = 0;
        id v23 = [v15 metaData];
        sub_1014056B0((uint64_t)&v50, v23);
        uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t, int64x2_t *, void **, _OWORD *))(*(void *)v21 + 400))(v21, v20, &v33, __p, buf);
        uint64_t v34 = v24;
        sub_100454840((uint64_t)buf);

        if (v32 < 0) {
          operator delete(__p[0]);
        }

        *(void *)&buf[0] = &v33;
        sub_100454BA8((void ***)buf);
        if ((v24 & 0xFF00000000) != 0)
        {
          uint64_t v25 = sub_1005628AC((int *)&v34);
          v16[2](v16, v25);
        }
        else
        {
          v16[2](v16, 0);
        }
        if ((_BYTE)v44)
        {
          *(void *)&buf[0] = &v43[8];
          sub_100155410((void ***)buf);
        }
        if (SHIBYTE(v41) < 0) {
          operator delete(*((void **)&v40 + 1));
        }
        if (SBYTE7(v40) < 0) {
          operator delete((void *)v39);
        }
        if (SHIBYTE(v38) < 0) {
          operator delete(*((void **)&v37 + 1));
        }
        if (SBYTE7(v37) < 0) {
          operator delete((void *)v36);
        }
        sub_10045468C((uint64_t)v35);
      }
      else
      {
        [(CTXPCClientHandler *)self getLogContext];
        uint64_t v29 = *((void *)&buf[0] + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Could not find Lazuli manager while getting RCS configuration server URL", (uint8_t *)buf, 2u);
        }
        LODWORD(buf[0]) = 5;
        BYTE4(buf[0]) = 1;
        uint64_t v30 = sub_1005628AC((int *)buf);
        v16[2](v16, v30);
      }
      if (v46) {
        sub_10004D2C8(v46);
      }
    }
    else
    {
      [(CTXPCClientHandler *)self getLogContext];
      uint64_t v27 = *((void *)&buf[0] + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Invalid arguments", (uint8_t *)buf, 2u);
      }
      LODWORD(buf[0]) = 4;
      BYTE4(buf[0]) = 1;
      uint64_t v28 = sub_1005628AC((int *)buf);
      v16[2](v16, v28);
    }
  }
  else
  {
    [(CTXPCClientHandler *)self getLogContext];
    char v26 = *((void *)&buf[0] + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Invalid completion block while sending one to many text", (uint8_t *)buf, 2u);
    }
  }
}

@end